[[{"text": ["is verifies object identity, and any implementation of Python, when it meets literal of immutable types, is perfectly free to either make a new object of that immutable type, or seek through existing objects of that type to see if some of them could be reused (by adding a new reference to the same underlying object).", "This is a pragmatic choice of optimization and not subject to semantic constraints, so your code should never rely on which path a give implementation may take (or it could break with a bugfix/optimization release of Python!", ")."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "is", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "either", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "or", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "not", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Consider for example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import dis\n&gt;&gt;&gt; def f():\n...   x = 'google.com'\n...   return x is 'google.com'\n... \n&gt;&gt;&gt; dis.dis(f)\n  2           0 LOAD_CONST               1 ('google.com')\n              3 STORE_FAST               0 (x)\n\n  3           6 LOAD_FAST                0 (x)\n              9 LOAD_CONST               1 ('google.com')\n             12 COMPARE_OP               8 (is)\n             15 RETURN_VALUE\n</code>\n</pre>\n", "senID": 2}, {"text": ["so in this particular implementation, within a function, your observation does not apply and only one object is made for the literal (any literal), and, indeed:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "within a function", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; f()\nTrue\n</code>\n</pre>\n", "senID": 4}, {"text": ["Pragmatically that's because within a function making a pass through the local table of constants (to save some memory by not making multiple constant immutable objects where one suffices) is pretty cheap and fast, and may offer good performance returns since the function may be called repeatedly afterwards."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["But, the very same implementation, at the interactive prompt (Edit: I originally thought this would also happen at a module's top level, but a comment by @Thomas set me right, see later):"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "at the interactive prompt", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "Edit", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = 'google.com'\n&gt;&gt;&gt; y = 'google.com'\n&gt;&gt;&gt; id(x), id(y)\n(4213000, 4290864)\n</code>\n</pre>\n", "senID": 7}, {"text": ["does NOT bother trying to save memory that way -- the ids are different, i.e., distinct objects.", "There are potentially higher costs and lower returns and so the heuristics of this implementation's optimizer tell it to not bother searching and just go ahead."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "id", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit: at module top level, per @Thomas' observation, given e.g."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ cat aaa.py\nx = 'google.com'\ny = 'google.com'\nprint id(x), id(y)\n</code>\n</pre>\n", "senID": 10}, {"text": ["again we see the table-of-constants-based memory-optimization in this implementation:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import aaa\n4291104 4291104\n</code>\n</pre>\n", "senID": 12}, {"text": ["(end of Edit per @Thomas' observation)."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["Lastly, again on the same implementation:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = 'google'\n&gt;&gt;&gt; y = 'google'\n&gt;&gt;&gt; id(x), id(y)\n(2484672, 2484672)\n</code>\n</pre>\n", "senID": 15}, {"text": ["the heuristics are different here because the literal string \"looks like it might be an identifier\" -- so it might be used in operation requiring interning... so the optimizer interns it anyway (and once interned, looking for it becomes very fast of course).", "And indeed, surprise surprise...:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; z = intern(x)\n&gt;&gt;&gt; id(z)\n2484672\n</code>\n</pre>\n", "senID": 17}, {"text": ["...x has been interned the very first time (as you see, the return value of intern is the same object as x and y, as it has the same id()).", "Of course, you shouldn't rely on this either -- the optimizer doesn't have to intern anything automatically, it's just an optimization heuristic; if you need interned string, intern them explicitly, just to be safe.", "When you do intern strings explicitly...:"], "childNum": 12, "tag": "p", "senID": 18, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "has", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "intern", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "intern", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "the same", "childNum": 0, "tag": "em", "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "childList": []}, {"text": "id()", "childNum": 0, "tag": "code", "childList": []}, {"text": "have", "childNum": 0, "tag": "strong", "childList": []}, {"text": "intern", "childNum": 0, "tag": "code", "childList": []}, {"text": "intern", "childNum": 0, "tag": "code", "childList": []}, {"text": "do", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = intern('google.com')\n&gt;&gt;&gt; y = intern('google.com')\n&gt;&gt;&gt; id(x), id(y)\n(4213000, 4213000)\n</code>\n</pre>\n", "senID": 19}, {"text": ["...then you do ensure exactly the same object (i.e., same id()) results each and every time -- so you can apply micro-optimizations such as checking with is rather than == (I've hardly ever found the miniscule performance gain to be worth the bother;-)."], "childNum": 4, "tag": "p", "senID": 20, "childList": [{"text": "do", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "id()", "childNum": 0, "tag": "code", "childList": []}, {"text": "is", "childNum": 0, "tag": "code", "childList": []}, {"text": "==", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: just to clarify, here are the kind of performance differences I'm talking about, on a slow Macbook Air...:"], "childNum": 1, "tag": "p", "senID": 21, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ python -mtimeit -s\"a='google';b='google'\" 'a==b'\n10000000 loops, best of 3: 0.132 usec per loop\n$ python -mtimeit -s\"a='google';b='google'\" 'a is b'\n10000000 loops, best of 3: 0.107 usec per loop\n$ python -mtimeit -s\"a='goo.gle';b='goo.gle'\" 'a==b'\n10000000 loops, best of 3: 0.132 usec per loop\n$ python -mtimeit -s\"a='google';b='google'\" 'a is b'\n10000000 loops, best of 3: 0.106 usec per loop\n$ python -mtimeit -s\"a=intern('goo.gle');b=intern('goo.gle')\" 'a is b'\n10000000 loops, best of 3: 0.0966 usec per loop\n$ python -mtimeit -s\"a=intern('goo.gle');b=intern('goo.gle')\" 'a == b'\n10000000 loops, best of 3: 0.126 usec per loop\n</code>\n</pre>\n", "senID": 22}, {"text": ["...a few tens of nanoseconds either way, at most.", "So, worth even thinking about only in the most extreme \"optimize the [expletive deleted] out of this [expletive deleted] performance bottleneck\" situations!-)"], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "thinking", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["\"is\" is an identity test.", "Python has some caching behavior for small integers and (apparently) strings.", "\"is\" is best used for singleton testing (ex.", "None)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = \"google\"\n&gt;&gt;&gt; x is \"google\"\nTrue\n&gt;&gt;&gt; id(x)\n32553984L\n&gt;&gt;&gt; id(\"google\")\n32553984L\n&gt;&gt;&gt; x = \"google.com\"\n&gt;&gt;&gt; x is \"google.com\"\nFalse\n&gt;&gt;&gt; id(x)\n32649320L\n&gt;&gt;&gt; id(\"google.com\")\n37787888L\n</code>\n</pre>\n", "senID": 1}]]