[[{"text": ["It's simple: A function that references variables from a containing scope, potentially after flow-of-control has left that scope.", "That last bit is very useful:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def makeConstantAdder(x):\n...     constant = x\n...     def adder(y):\n...         return y + constant\n...     return adder\n... \n&gt;&gt;&gt; f = makeConstantAdder(12)\n&gt;&gt;&gt; f(3)\n15\n&gt;&gt;&gt; g = makeConstantAdder(4)\n&gt;&gt;&gt; g(3)\n7\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that 12 and 4 have \"disappeared\" inside f and g, respectively, this feature is what make f and g proper closures."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Closure on closures"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Closure on closures", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mrevelle.blogspot.com/2006/10/closure-on-closures.html"}]}, {"code": "<pre>\n<code>\n def make_counter():\n    i = 0\n    def counter(): # counter() is a closure\n        nonlocal i\n        i += 1\n        return i\n    return counter\n\nc1 = make_counter()\nc2 = make_counter()\n\nprint (c1(), c1(), c2(), c2())\n# -&gt; 1 2 1 2\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I like this rough, succinct definition:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this rough, succinct definition", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/closure.htm"}]}, {"text": ["I'd add"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Decorators which accept parameters are a common use for closures.", "Closures are a common implementation mechanism for that sort of \"function factory\".", "I frequently choose to use closures in the Strategy Pattern when the strategy is modified by data at run-time."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Strategy Pattern", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://c2.com/cgi/wiki?StrategyPattern"}]}, {"text": ["In a language that allows anonymous block definition -- e.g., Ruby, C# -- closures can be used to implement (what amount to) novel new control structures.", "The lack of anonymous blocks is among the limitations of closures in Python."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "the limitations of closures in Python", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://ivan.truemesh.com/archives/000411.html"}]}], [{"text": ["To be honest, I understand closures perfectly well except I've never been clear about what exactly is the thing which is the \"closure\" and what's so \"closure\" about it.", "I recommend you give up looking for any logic behind the choice of term."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Anyway, here's my explanation:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def foo():\n   x = 3\n   def bar():\n      print x\n   x = 5\n   return bar\n\nbar = foo()\nbar()   # print 5\n</code>\n</pre>\n", "senID": 2}, {"text": ["A key idea here is that the function object returned from foo retains a hook to the local var 'x' even though 'x' has gone out of scope and should be defunct.", "This hook is to the var itself, not just the value that var had at the time, so when bar is called, it prints 5, not 3."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Also be clear that Python 2.x has limited closure: there's no way I can modify 'x' inside 'bar' because writing 'x = bla' would declare a local 'x' in bar, not assign to 'x' of foo.", "This is a side-effect of Python's assignment=declaration.", "To get around this, Python 3.0 introduces the nonlocal keyword:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def foo():\n   x = 3\n   def bar():\n      print x\n   def ack():\n      nonlocal x\n      x = 7\n   x = 5\n   return (bar, ack)\n\nbar, ack = foo()\nack()   # modify x of the call to foo\nbar()   # print 7\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I've never heard of transactions being used in the same context as explaining what a closure is and there really aren't any transaction semantics here."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's called a closure because it \"closes over\" the outside variable (constant)--i.e., it's not just a function but an enclosure of the environment where the function was created. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In the following example, calling the closure g after changing x will also change the value of x within g, since g closes over x:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n x = 0\n\ndef f():\n  def g(): \n    x * 2\n  return g\n\n\nclosure = f()\nprint(closure()) # 0\nx = 2\nprint(closure()) # 4\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here's a typical use case for closures - callbacks for GUI elements (this would be an alternative to subclassing the button class).", "For example, you can construct a function that will be called in response to a button press, and \"close\" over the relevant variables in the parent scope that are necessary for processing the click.", "This way you can wire up pretty complicated interfaces from the same initialization function, building all the dependencies into the closure."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The best explanation I ever saw of a closure was to explain the mechanism.", "It went something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Imagine your program stack as a degenerate tree where each node has only one child and the single leaf node is the context of your currently executing procedure."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Now relax the constraint that each node can have only one child."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you do this, you can have a construct ('yield') that can return from a procedure without discarding the local context (i.e.", "it doesn't pop it off the stack when you return).", "The next time the procedure is invoked, the invocation picks up the old stack (tree) frame and continues executing where it left off."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]