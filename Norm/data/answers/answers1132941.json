[[{"text": ["Actually, this is not a design flaw, and it is not because of internals, or performance.", "It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["As soon as you get to think into this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of \"member data\" and therefore their state may change from one call to the other - exactly as in any other object."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In any case, Effbot has a very nice explanation of the reasons for this behavior in Default Parameter Values in Python.", "I found it very clear, and I really suggest reading it for a better knowledge of how function objects work."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Default Parameter Values in Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/default-values.htm"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}], [{"text": ["Suppose you have the following code"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fruits = (\"apples\", \"bannanas\", \"loganberries\")\n\ndef eat(food=fruits):\n    ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["When I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple (\"apples\", \"bannanas\", \"loganberries\")"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "(\"apples\", \"bannanas\", \"loganberries\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["However, supposed later on in the code, I do something like"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def some_random_function():\n    global fruits\n    fruits = (\"blueberries\", \"mangos\")\n</code>\n</pre>\n", "senID": 4}, {"text": ["then if default parameters were bound at function execution rather than function declaration then I would be astonished (in a very bad way) to discover that fruits had been changed.", "This would be more astonishing IMO than discovering that your foo function above was mutating the list."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The real problem lies with mutable variables, and all languages have this problem to some extent.", "Here's a question: suppose in Java I have the following code:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n StringBuffer s = \"Hello World!\";\nMap&lt;StringBuffer,Integer&gt; counts = new HashMap&lt;StringBuffer,Integer&gt;();\ncounts.put(s, 5);\ns.append(\"!!!!\");\nSystem.out.println( counts.get(s) );  // does this work?\n</code>\n</pre>\n", "senID": 7}, {"text": ["Now, does my map use the value of the StringBuffer key when it was placed into the map, or does it store the key by reference?", "Either way, someone is astonished; either the person who tried to get the object out of the Map using a value identical to the one they put it in with, or the person who can't seem to retrieve their ovject even though the key they're using is literally the same object that was used to put it into the map.", "(This is actually why Python doesn't allow its mutable builtin data types to be used as dictionary keys."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Your example is a good one of a case where Python newcomers will be surprised and bitten.", "But I'd argue that if we fixed this, then that would only create a different situation where they'd be bitten instead, and that one would be even less intuitive.", "Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they're writing."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["I personally like Python's current approach: default function arguments are evaluated when the function is defined and that object is always the default.", "I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["I know nothing about the python interpreter inner workings (and I'm not an expert in compilers and interpreters either) so don't blame me if I propose anything unsensible or impossible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Provided that python objects are mutable I think that this should be taken into account when designing the default arguments stuff.", "When you instantiate a list:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "are mutable", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a = []\n</code>\n</pre>\n", "senID": 2}, {"text": ["you expect to get a new list referenced by a."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "new", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Why should the a=[] in"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def x(a=[]):\n</code>\n</pre>\n", "senID": 5}, {"text": ["instantiate a new list on function definition and not on invocation?", "It's just like you're asking \"if the user doesn't provide the argument than instantiate a new list and use it as if it was produced by the caller\".", "I think this is ambiguous instead:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "instantiate", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def x(a=datetime.datetime.now()):\n</code>\n</pre>\n", "senID": 7}, {"text": ["user, do you want a to default to the datetime corresponding to when you're defining or executing x?", "In this case, as in the previous one, I'll keep the same behaviour as if the default argument \"assignment\" was the first instruction of the function (datetime.now() called on function invocation).", "On the other hand, if the user wanted the defintion-time mapping he could write:"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "a", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "x", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n b = datetime.datetime.now()\ndef x(a=b):\n</code>\n</pre>\n", "senID": 9}, {"text": ["I know, I know: that's a closure.", "Alternatively python might provide a keyword to force definition-time binding:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n def x(static a=b):\n</code>\n</pre>\n", "senID": 11}], [{"text": ["Well, the reason is quite simply that bindings are done when code is executed, and the function definition is executed, well... when the functions is defined."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Compare this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class BananaBunch:\n    bananas = []\n\n    def addBanana(self, banana):\n        self.bananas.append(banana)\n</code>\n</pre>\n", "senID": 2}, {"text": ["This code suffers from the exact same unexpected happenstance.", "bananas is a class attribute, and hence, when you add things to it, it's added to all classes.", "The reason is exactly the same."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["It's just \"How It Works\", and making it work differently in the function case would probably be complicated, and in the class case likely impossible, or at least slow down object instantiation a lot, as you would have to keep the class code around and execute it when objects are created."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Yes, it is unexpected.", "But once the penny drops, it fits in perfectly with how Python works in general.", "In fact, it's a good teaching aid, and once you understand why this happens, you'll grok python much better."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["That said it should feature prominently in any good Python tutorial.", "Because as you mention, everyone runs into this problem sooner or later."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["What you're asking is why this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def func(a=[], b = 2):\n    pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["isn't internally equivalent to this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def func(a=None, b = None):\n    a_default = lambda: []\n    b_default = lambda: 2\n    def actual_func(a=None, b=None):\n        if a is None: a = a_default()\n        if b is None: b = b_default()\n    return actual_func\nfunc = func()\n</code>\n</pre>\n", "senID": 3}, {"text": ["except for the case of explicitly calling func(None, None), which we'll ignore."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In other words, instead of evaluating default parameters, why not store each of them, and evaluate them when the function is called?"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["One answer is probably right there--it would effectively turn every function with default parameters into a closure.", "Even if it's all hidden away in the interpreter and not a full-blown closure, the data's got to be stored somewhere.", "It'd be slower and use more memory."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["It's a performance optimization.", "As a result of this functionality, which of these two function calls do you think is faster?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def print_tuple(some_tuple=(1,2,3)):\n    print some_list\n\nprint_tuple()        #1\nprint_tuple((1,2,3)) #2\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'll give you a hint.", "Here's the disassembly:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 0 LOAD_GLOBAL              0 (print_tuple)\n3 CALL_FUNCTION            0\n6 POP_TOP\n7 LOAD_CONST               0 (None)\n10 RETURN_VALUE\n</code>\n</pre>\n", "senID": 3}, {"code": "<pre>\n<code>\n 0 LOAD_GLOBAL              0 (print_tuple)\n 3 LOAD_CONST               4 ((1, 2, 3))\n 6 CALL_FUNCTION            1\n 9 POP_TOP\n10 LOAD_CONST               0 (None)\n13 RETURN_VALUE\n</code>\n</pre>\n", "senID": 4}, {"text": ["As you can see, there is a performance benefit when using immutable default arguments.", "This can make a difference if it's a frequently called function.", "Also, bear in mind that Python isn't C.  In C you have constants that are pretty much free.", "In Python you don't have this benefit."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "is", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["I used to think that creating the objects at runtime would be the better approach.", "I'm less certain now, since you do lose some useful features, though it may be worth it regardless simply to prevent newbie confusion.", "The disadvantages of doing so are:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["1.", "Performance"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "1. Performance", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def foo(arg=something_expensive_to_compute())):\n    ...\n</code>\n</pre>\n", "senID": 2}, {"text": ["If call-time evaluation is used, then the expensive function is called every time your function is used without an argument.", "You'd either pay an expensive price on each call, or need to manually cache the value externally, polluting your namespace and adding verbosity."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["2.", "Forcing bound parameters"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "2. Forcing bound parameters", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["A useful trick is to bind parameters of a lambda to the current binding of a variable when the lambda is created.", "For example:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "current", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n funcs = [ lambda i=i: i for i in range(10)]\n</code>\n</pre>\n", "senID": 6}, {"text": ["This returns a list of functions that return 0,1,2,3... respectively.", "If the behaviour is changed, they will instead bind i to the call-time value of i, so you would get a list of functions that all returned 9."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "i", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "call-time", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "9", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The only way to implement this otherwise would be to create a further closure with the i bound, ie:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def make_func(i): return lambda: i\nfuncs = [make_func(i) for i in range(10)]\n</code>\n</pre>\n", "senID": 9}, {"text": ["3.", "Introspection"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "3. Introspection", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Consider the code:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def foo(a='test', b=100, c=[]):\n   print a,b,c\n</code>\n</pre>\n", "senID": 12}, {"text": ["We can get information about the arguments and defaults using the inspect module, which "], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "inspect", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; inspect.getargspec(foo)\n(['a', 'b', 'c'], None, None, ('test', 100, []))\n</code>\n</pre>\n", "senID": 14}, {"text": ["This information is very useful for things like document generation, metaprogramming, decorators etc."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["Now, suppose the behaviour of defaults could be changed so that this is the equivalent of:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n _undefined = object()  # sentinel value\n\ndef foo(a=_undefined, b=_undefined, c=_undefined)\n    if a is _undefined: a='test'\n    if b is _undefined: b=100\n    if c is _undefined: c=[]\n</code>\n</pre>\n", "senID": 17}, {"text": ["However, we've lost the ability to introspect, and see what the default arguments are.", "Because the objects haven't been constructed, we can't ever get hold of them without actually calling the function.", "The best we could do is to store off the source code and return that as a string."], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "are", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["This behavior is easy explained by:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def x(a=0, b=[], c=[], d=0):\n    a = a + 1\n    b = b + [1]\n    c.append(1)\n    print a, b, c\n</code>\n</pre>\n", "senID": 2}], [{"text": ["the shortest answer would probably be \"definition is execution\", therefore the whole argument makes no strict sense.", "as a more contrived example, you may cite this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def a(): return []\n\ndef b(x=a()):\n    print x\n</code>\n</pre>\n", "senID": 1}, {"text": ["hopefully it's enough to show that not executing the default argument expressions at the execution time of the def statement isn't easy or doesn't make sense, or both."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["i agree it's a gotcha when you try to use default constructors, though."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This actually has nothing to do with default values, other than that it often comes up as an unexpected behaviour when you write functions with mutable default values."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo(a):\n    a.append(5)\n    print a\n\n&gt;&gt;&gt; a  = [5]\n&gt;&gt;&gt; foo(a)\n[5, 5]\n&gt;&gt;&gt; foo(a)\n[5, 5, 5]\n&gt;&gt;&gt; foo(a)\n[5, 5, 5, 5]\n&gt;&gt;&gt; foo(a)\n[5, 5, 5, 5, 5]\n</code>\n</pre>\n", "senID": 1}, {"text": ["No default values in sight in this code, but you get exactly the same problem."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The problem is that foo is modifying a mutable variable passed in from the caller, when the caller doesn't expect this.", "Code like this would be fine if the function was called something like append_5; then the caller would be calling the function in order to modify the value they pass in, and the behaviour would be expected.", "But such a function would be very unlikely to take a default argument, and probably wouldn't return the list (since the caller already has a reference to that list; the one it just passed in)."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "modifying", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "append_5", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Your original foo, with a default argument, shouldn't be modifying a whether it was explicitly passed in or got the default value.", "Your code should leave mutable arguments alone unless it is clear from the context/name/documentation that the arguments are supposed to be modified.", "Using mutable values passed in as arguments as local temporaries is an extremely bad idea, whether we're in Python or not and whether there are default arguments involved or not."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If you need to destructively manipulate a local temporary in the course of computing something, and you need to start your manipulation from an argument value, you need to make a copy."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["It may be true that:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["it is entirely consistent to hold to both of the features above and still make another point:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The other answers, or at least some of them either make points 1 and 2 but not 3, or make point 3 and downplay points 1 and 2.", "But all three are true."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "But all three are true.", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["It may be true that switching horses in midstream here would be asking for significant breakage, and that there could be more problems created by changing Python to intuitively handle Stefano's opening snippet.", "And it may be true that someone who knew Python internals well could explain a minefield of consequences.", "However,"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "However,", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["The existing behavior is not Pythonic, and Python is successful because very little about the language violates the principle of least astonishment anywhere near this badly.", "It is a real problem, whether or not it would be wise to uproot it.", "It is a design flaw.", "If you understand the language much better by trying to trace out the behavior, I can say that C++ does all of this and more; you learn a lot by navigating, for instance, subtle pointer errors.", "But this is not Pythonic: people who care about Python enough to persevere in the face of this behavior are people who are drawn to the language because Python has far fewer surprises than other language.", "Dabblers and the curious become Pythonistas when they are astonished at how little time it takes to get something working--not because of a design fl--I mean, hidden logic puzzle--that cuts against the intuitions of programmers who are drawn to Python because it Just Works."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "near", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "Just Works", "childNum": 0, "tag": "strong", "pos": 5, "childList": []}]}], [{"text": ["You should not be using mutable objects for default argument values, it is far safer to do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo(a=None):\n    if a == None:\n        a = []\n    a.append(5)\n    return a\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Well, the default argument is getting bound at runtime (not definition)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["My understanding is that the behavior stems from the following facts:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So when needs to use the default argument (non-basic type), it finds the one already allocated."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Following demonstrates the difference in handling of basic and non-basic types."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def foo(a=[]):\n    a.append(5)\n    print \"foo:\",a\n\ndef bar(a=0):\n    a += 1\n    print \"bar:\",a\n\nfoo()\nfoo()\nbar()\nbar()\n</code>\n</pre>\n", "senID": 4}, {"text": ["Results:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n foo: [5]\nfoo: [5, 5]\nbar: 1\nbar: 1\n</code>\n</pre>\n", "senID": 6}], [{"text": ["This would be a good time for you to google for \"python gotchas\" and learn to avoid the others :-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "Paddy.", "tag": "none", "senID": 1}]}]]