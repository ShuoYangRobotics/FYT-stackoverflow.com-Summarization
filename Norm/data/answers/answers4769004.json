[[{"text": ["Here are some key differences to me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["1) Ruby has blocks; Python does not."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["2) Python has functions; Ruby does not.", "In Python, you can take any function or method and pass it to another function.", "In Ruby, everything is a method, and methods can't be directly passed.", "Instead, you have to wrap them in Proc's to pass them."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["3) Ruby and Python both support closures, but in different ways.", "In Python, you can define a function inside another function.", "The inner function has read access to variables from the outer function, but not write access.", "In Ruby, you define closures using blocks.", "The closures have full read and write access to variables from the outer scope."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["4) Python has list comprehensions, which are pretty expressive.", "For example, if you have a list of numbers, you can write"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n [x*x for x in values if x &gt; 15]\n</code>\n</pre>\n", "senID": 5}, {"text": ["to get a new list of the squares of all values greater than 15.", "In Ruby, you'd have to write the following:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n values.select {|v| v &gt; 15}.map {|v| v * v}\n</code>\n</pre>\n", "senID": 7}, {"text": ["The Ruby code doesn't feel as compact.", "It's also not as efficient since it first converts the values array into a shorter intermediate array containing the values greater than 15.", "Then, it takes the intermediate array and generates a final array containing the squares of the intermediates.", "The intermediate array is then thrown out.", "So, Ruby ends up with 3 arrays in memory during the computation; Python only needs the input list and the resulting list."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Python also supplies similar map comprehensions."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["5) Python supports tuples; Ruby doesn't.", "In Ruby, you have to use arrays to simulate tuples."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["EDITS FOLLOW"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["6) Ruby supports switch/case statements; Python does not."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["7) Ruby supports the standard expr ?", "val1 : val2 ternary operator; Python does not."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["8) Ruby supports only single inheritance.", "If you need to mimic multiple inheritance, you can define modules and use mix-ins to pull the module methods into classes.", "Python supports multiple inheritance rather than module mix-ins."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["MORE EDITS"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["9) Python supports only single-line lambda functions.", "Ruby blocks, which are kind of/sort of lambda functions, can be arbitrarily big.", "Because of this, Ruby code is typically written in a more functional style than Python code.", "For example, to loop over a list in Ruby, you typically do"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n collection.each do |value|\n  ...\nend\n</code>\n</pre>\n", "senID": 17}, {"text": ["The block works very much like a function being passed to collection.each.", "If you were to do the same thing in Python, you'd have to define a named inner function and then pass that to the collection each method (if list supported this method):"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n def some_operation(value):\n    ...\n\ncollection.each(some_operation)\n</code>\n</pre>\n", "senID": 19}, {"text": ["That doesn't flow very nicely.", "So, typically the following non-functional approach would be used in Python:"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"code": "<pre>\n<code>\n for value in collection:\n    ...\n</code>\n</pre>\n", "senID": 21}, {"text": ["10) Using resources in a safe way is quite different between the two languages.", "Here, the problem is that you want to allocate some resource (open a file, obtain a database cursor, etc), perform some arbitrary operation on it, and then close it in a safe manner even if an exception occurs."], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"text": ["In Ruby, because blocks are so easy to use (see #9), you would typically code this pattern as a method that takes a block for the arbitrary operation to perform on the resource."], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"text": ["In Python, passing in a function for the arbitrary action is a little clunkier since you have to write a named, inner function (see #9).", "Instead, Python uses a \"with\" statement for safe resource handling.", "See How do I correctly clean up a Python object?", "for more details."], "childNum": 1, "tag": "p", "senID": 24, "childList": [{"text": "How do I correctly clean up a Python object?", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/865115/how-do-i-correctly-clean-up-a-python-object/865272#865272"}]}], [{"text": ["I've just spent a couple of months learning Python after 6 years of Ruby.", "There really was no great comparison out there for the two languages, so I decided to man up and write one myself.", "Now, it is mainly concerned with functional programming, but since you mention Ruby's inject method, I'm guessing we're on the same wavelength."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "is", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "inject", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["I hope this helps: The 'ugliness' of Python"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "The 'ugliness' of Python", "tag": "a", "pos": 0, "childList": [{"text": "The 'ugliness' of Python", "tag": "strong"}], "childNum": 1, "href": "http://allthingsprogress.com/posts/the-ugliness-of-python"}, {"text": "The 'ugliness' of Python", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["A couple of points that will get you moving in the right direction:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["All the functional programming goodness you use in Ruby is in Python, and it's even easier.", "For example, you can map over functions exactly as you'd expect:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Python doesn't have a method that acts like each.", "Since you only use each for side effects, the equivalent in Python is the for loop:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "each", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "each", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["List comprehensions are great when a) you have to deal with functions and object collections together and b) when you need to iterate using multiple indexes.", "For example, to find all the palindromes in a string (assuming you have a function p() that returns true for palindromes), all you need is a single list comprehension:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "p()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]}], [{"text": ["I know little Ruby, but here are a few bullet points about the things you mentioned:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["nil"], "childNum": 0, "tag": "code", "senID": 1, "childList": []}, {"text": ["None"], "childNum": 0, "tag": "code", "senID": 2, "childList": []}, {"text": "For side effects, (", "tag": "none", "senID": 3}]}, {"text": ["Concerning looping: You have for, which operates on an iterable(!", "no counting), and while, which does what you would expect.", "The fromer is far more powerful, thanks to the extensive support for iterators.", "Not only nearly everything that can be an iterator instead of a list is an iterator (at least in Python 3 - in Python 2, you have both and the default is a list, sadly).", "The are numerous tools for working with iterators - zip iterates any number of iterables in parallel, enumerate gives you (index, item) (on any iterable, not just on lists), even slicing abritary (possibly large or infinite) iterables!", "I found that these make many many looping tasks much simpler.", "Needless to say, they integrate just fine with list comprehensions, generator expressions, etc."], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "while", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "zip", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "enumerate", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "(index, item)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "any", "childNum": 0, "tag": "em", "pos": 5, "childList": []}]}], [{"text": ["My suggestion: Don't try to learn the differences.", "Learn how to approach the problem in Python.", "Just like there's a Ruby approach to each problem (that works very well givin the limitations and strengths of the language), there's a Python approach to the problem.", "they are both different.", "To get the best out of each language, you really should learn the language itself, and not just the \"translation\" from one to the other.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Now, with that said, the difference will help you adapt faster and make 1 off modifications to a Python program.", "And that's fine for a start to get writing.", "But try to learn from other projects the why behind the architecture and design decisions rather than the how behind the semantics of the language..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["In Ruby, instance variables and methods are completely unrelated, except when you explicitly relate them with attr_accessor or something like that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In Python, methods are just a special class of attribute: one that is executable."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So for example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class foo:\n...     x = 5\n...     def y(): pass\n... \n&gt;&gt;&gt; f = foo()\n&gt;&gt;&gt; type(f.x)\n&lt;type 'int'&gt;\n&gt;&gt;&gt; type(f.y)\n&lt;type 'instancemethod'&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["That difference has a lot of implications, like for example that referring to f.x refers to the method object, rather than calling it.", "Also, as you can see, f.x is public by default, whereas in Ruby, instance variables are private by default."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]