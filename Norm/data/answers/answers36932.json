[[{"text": ["Here's yet another way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def enum(**enums):\n    return type('Enum', (), enums)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Used like so:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; Numbers = enum(ONE=1, TWO=2, THREE='three')\n&gt;&gt;&gt; Numbers.ONE\n1\n&gt;&gt;&gt; Numbers.TWO\n2\n&gt;&gt;&gt; Numbers.THREE\n'three'\n</code>\n</pre>\n", "senID": 3}, {"text": ["You can also easily support automatic enumeration with something like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def enum(*sequential, **named):\n    enums = dict(zip(sequential, range(len(sequential))), **named)\n    return type('Enum', (), enums)\n</code>\n</pre>\n", "senID": 5}, {"text": ["Used like so:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; Numbers = enum('ZERO', 'ONE', 'TWO')\n&gt;&gt;&gt; Numbers.ZERO\n0\n&gt;&gt;&gt; Numbers.ONE\n1\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Python doesn't have an equivalent but you can implement your own."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Myself, I like keeping it simple (I've seen some horribly complex examples on the net), something like this ..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Animal:\n    DOG=1\n    CAT=2\n\nx = Animal.DOG\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Here is what I use...."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Enum(set):\n    def __getattr__(self, name):\n        if name in self:\n            return name\n        raise AttributeError\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here is its Implementation..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Animals = Enum([\"DOG\", \"CAT\", \"Horse\"])\n\nprint Animals.DOG\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If you need the numeric values, here's the quickest way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dog, cat, rabbit = range(3)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The typesafe enum pattern which was used in Java pre-JDK 5 has a\nnumber of advantages.", "Much like in Alexandru's answer, you create a\nclass and class level fields are the enum values; however, the enum\nvalues are instances of the class rather than small integers.", "This has\nthe advantage that your enum values don't inadvertently compare equal\nto small integers, you can control how they're printed, add arbitrary\nmethods if that's useful and make assertions using isinstance:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Animal:\n   def __init__(self, name):\n       self.name = name\n\n   def __str__(self):\n       return self.name\n\n   def __repr__(self):\n       return \"&lt;Animal: %s&gt;\" % self\n\nAnimal.DOG = Animal(\"dog\")\nAnimal.CAT = Animal(\"cat\")\n\n&gt;&gt;&gt; x = Animal.DOG\n&gt;&gt;&gt; x\n&lt;Animal: dog&gt;\n&gt;&gt;&gt; x == 1\nFalse\n</code>\n</pre>\n", "senID": 1}, {"text": ["A recent thread on python-dev pointed out there are a couple of enum libraries in the wild, including:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "thread on python-dev", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-dev/2010-November/105873.html"}]}, {"tag": "ul", "num": 3, "lis": [{"text": ["flufl.enum"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}, {"text": ["lazr.enum"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}, {"text": "... and the imaginatively named ", "tag": "none", "senID": 5}]}], [{"text": ["Python doesn't have a built-in equivalent to enum, and other answers have ideas for implementing your own (you may also be interested in the over the top version in the Python cookbook)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "enum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://code.activestate.com/recipes/67107/", "text": "over the top version", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["However, in situations where an enum would be called for in C, I usually end up just using simple strings: because of the way objects/attributes are implemented, (C)Python is optimized to work very fast with short strings anyway, so there wouldn't really be any performance benefit to using integers.", "To guard against typos / invalid values you can insert checks in selected places."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "enum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "just using simple strings", "childNum": 1, "tag": "strong", "pos": -1, "childList": [{"text": "just using simple strings", "tag": "em"}]}, {"text": "just using simple strings", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n ANIMALS = ['cat', 'dog', 'python']\n\ndef take_for_a_walk(animal):\n    assert animal in ANIMALS\n    ...\n</code>\n</pre>\n", "senID": 2}, {"text": ["(One disadvantage compared to using a class is that you lose the benefit of autocomplete)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The best solution for you would depend on what you require from your fake enum."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "fake", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "enum", "childNum": 1, "tag": "strong", "childList": [{"text": "enum", "tag": "code"}]}, {"text": "enum", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Simple enum:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Simple enum:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If you need the enum as only a list of names identifying different items, the solution by Mark Harrison (above) is great:"], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "enum", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "enum", "tag": "code"}]}, {"text": "enum", "childNum": 0, "tag": "code", "childList": []}, {"text": "names", "childNum": 0, "tag": "em", "childList": []}, {"text": "items", "childNum": 0, "tag": "em", "childList": []}, {"text": "Mark Harrison", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n (Pen, Pencil, Eraser) = range(0, 3)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Using a range also allows you to set any starting value:"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "range", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "range", "tag": "code"}]}, {"text": "range", "childNum": 0, "tag": "code", "childList": []}, {"text": "starting value", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n (Pen, Pencil, Eraser) = range(9, 12)\n</code>\n</pre>\n", "senID": 5}, {"text": ["In addition to the above, if you also require that the items belong to a container of some sort, then embed them in a class:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "container", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Stationary:\n    (Pen, Pencil, Eraser) = range(0, 3)\n</code>\n</pre>\n", "senID": 7}, {"text": ["To use the enum item, you would now need to use the container name and the item name:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n stype = Stationary.Pen\n</code>\n</pre>\n", "senID": 9}, {"text": ["Complex enum:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Complex enum:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["For long lists of enum or more complicated uses of enum, these solutions will not suffice.", "You could look to the recipe by Will Ware for Simulating Enumerations in Python published in the Python Cookbook.", "An online version of that is available here."], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "Simulating Enumerations in Python", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "Python Cookbook", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "here", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/67107/"}]}, {"text": ["More info:"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "More info:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["PEP 354: Enumerations in Python has the interesting details of a proposal for enum in Python and why it was rejected."], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "PEP 354: Enumerations in Python", "tag": "a", "pos": 0, "childList": [{"text": "PEP 354: Enumerations in Python", "tag": "em"}], "childNum": 1, "href": "http://www.python.org/dev/peps/pep-0354/"}, {"text": "PEP 354: Enumerations in Python", "childNum": 0, "tag": "em", "childList": []}]}], [{"code": "<pre>\n<code>\n def M_add_class_attribs(attribs):\n    def foo(name, bases, dict_):\n        for v, k in attribs:\n            dict_[k] = v\n        return type(name, bases, dict_)\n    return foo\n\ndef enum(names):\n    class Foo(object):\n        __metaclass__ = M_add_class_attribs(enumerate(names))\n        def __setattr__(self, name, value):  # this makes it read-only\n            raise NotImplementedError\n    return Foo()\n</code>\n</pre>\n", "senID": 0}, {"text": ["Use it like this:  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n Animal = enum(('DOG', 'CAT'))\nAnimal.DOG # returns 0\nAnimal.CAT # returns 1\nAnimal.DOG = 2 # raises NotImplementedError\n</code>\n</pre>\n", "senID": 2}, {"text": ["if you just want unique symbols and don't care about the values, replace this line:  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n __metaclass__ = M_add_class_attribs(enumerate(names))\n</code>\n</pre>\n", "senID": 4}, {"text": ["with this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n __metaclass__ = M_add_class_attribs((object(), name) for name in names)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["What exactly do you want to use an enum for?", "Is there a more Pythonic way of doing it?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["So, I agree.", "Let's not enforce type safety in python, but I would like to protect myself from silly mistakes.", "So what do we think about this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Animal(object):\n    values = ['Horse','Dog','Cat']\n\n    class __metaclass__(type):\n        def __getattr__(self, name):\n            return self.values.index(name)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Keeps me from value-collision in defining my enums."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; Animal.Cat\n2\n</code>\n</pre>\n", "senID": 3}, {"text": ["[edit]"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Realized later there's another handy advantage.. really fast reverse lookups:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def nameOf(self, i):\n    return Animal.values[i]\n</code>\n</pre>\n", "senID": 6}], [{"text": ["What I use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Enum(object):\n    def __init__(self, names, separator=None):\n        self.names = names.split(separator)\n        for value, name in enumerate(self.names):\n            setattr(self, name.upper(), value)\n    def tuples(self):\n        return tuple(enumerate(self.names))\n</code>\n</pre>\n", "senID": 1}, {"text": ["How to use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; state = Enum('draft published retracted')\n&gt;&gt;&gt; state.DRAFT\n0\n&gt;&gt;&gt; state.RETRACTED\n2\n&gt;&gt;&gt; state.FOO\nTraceback (most recent call last):\n   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'Enum' object has no attribute 'FOO'\n&gt;&gt;&gt; state.tuples()\n((0, 'draft'), (1, 'published'), (2, 'retracted'))\n</code>\n</pre>\n", "senID": 3}, {"text": ["So this gives you integer constants like state.PUBLISHED and the two-tuples to use as choices in Django models."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Hmmm...", "I suppose the closest thing to an enum would be a dictionary, defined either like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n months = {\n    'January': 1,\n    'February': 2,\n    ...\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n months = dict(\n    January=1,\n    February=2,\n    ...\n)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then, you can use the symbolic name for the constants like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n mymonth = months['January']\n</code>\n</pre>\n", "senID": 5}, {"text": ["There are other options, like a list of tuples, or a tuple of tuples, but the dictionary is the only one that provides you with a \"symbolic\" (constant string) way to access the \nvalue."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Edit: I like Alexandru's answer too!"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["davidg recommends using dicts.", "I'd go one step further and use sets:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n months = set('January', 'February', ..., 'December')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now you can test whether a value matches one of the values in the set like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if m in months:\n</code>\n</pre>\n", "senID": 3}, {"text": ["like dF, though, I usually just use string constants in place of enums."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Alexandru's suggestion of using class constants for enums works quite well. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I also like to add a dictionary for each set of constants to lookup a human-readable string representation. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This serves two purposes: a) it provides a simple way to pretty-print your enum and b) the dictionary logically groups the constants so that you can test for membership."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Animal:    \n  TYPE_DOG = 1\n  TYPE_CAT = 2\n\n  type2str = {\n    TYPE_DOG: \"dog\",\n    TYPE_CAT: \"cat\"\n  }\n\n  def __init__(self, type_):\n    assert type_ in self.type2str.keys()\n    self._type = type_\n\n  def __repr__(self):\n    return \"&lt;%s type=%s&gt;\" % (\n        self.__class__.__name__, self.type2str[self._type].upper())\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You can take a look at the traits package.", "This gives you something like type safety and many other useful features."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "traits", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.enthought.com/projects/traits/"}]}, {"text": ["But it really depends on what you want to use such an enum for."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Its funny, I just had a need for this the other day and i couldnt find an implementation worth using... so i wrote my own"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import functools\n\nclass EnumValue(object):\n    def __init__(self,name,value,type):\n    \tself.__value=value\n    \tself.__name=name\n    \tself.Type=type\n    def __str__(self):\n    \treturn self.__name\n    def __repr__(self):#2.6 only... so change to what ever you need...\n    \treturn '{cls}({0!r},{1!r},{2})'.format(self.__name,self.__value,self.Type.__name__,cls=type(self).__name__)\n\n    def __hash__(self):\n    \treturn hash(self.__value)\n    def __nonzero__(self):\n    \treturn bool(self.__value)\n    def __cmp__(self,other):\n    \tif isinstance(other,EnumValue):\n    \t\treturn cmp(self.__value,other.__value)\n    \telse:\n    \t\treturn cmp(self.__value,other)#hopefully their the same type... but who cares?\n    def __or__(self,other):\n    \tif other is None:\n    \t\treturn self\n    \telif type(self) is not type(other):\n    \t\traise TypeError()\n    \treturn EnumValue('{0.Name} | {1.Name}'.format(self,other),self.Value|other.Value,self.Type)\n    def __and__(self,other):\n    \tif other is None:\n    \t\treturn self\n    \telif type(self) is not type(other):\n    \t\traise TypeError()\n    \treturn EnumValue('{0.Name} & {1.Name}'.format(self,other),self.Value&other.Value;,self.Type)\n    def __contains__(self,other):\n    \tif self.Value==other.Value:\n    \t\treturn True\n    \treturn bool(self&other;)\n    def __invert__(self):\n    \tenumerables=self.Type.__enumerables__\n    \treturn functools.reduce(EnumValue.__or__,(enum for enum in enumerables.itervalues() if enum not in self)) \n\n    @property\n    def Name(self):\n    \treturn self.__name\n\n    @property\n    def Value(self):\n    \treturn self.__value\n\nclass EnumMeta(type):\n    @staticmethod\n    def __addToReverseLookup(rev,value,newKeys,nextIter,force=True):\t\n    \tif value in rev:\n    \t\tforced,items=rev.get(value,(force,()) )\n    \t\tif forced and force: #value was forced, so just append\n    \t\t\trev[value]=(True,items+newKeys)\n    \t\telif not forced:#move it to a new spot\n    \t\t\tnext=nextIter.next()\n    \t\t\tEnumMeta.__addToReverseLookup(rev,next,items,nextIter,False)\n    \t\t\trev[value]=(force,newKeys)\n    \t\telse: #not forcing this value\n    \t\t\tnext = nextIter.next()\n    \t\t\tEnumMeta.__addToReverseLookup(rev,next,newKeys,nextIter,False)\n    \t\t\trev[value]=(force,newKeys)\n    \telse:#set it and forget it\n    \t\trev[value]=(force,newKeys)\n    \treturn value\n\n    def __init__(cls,name,bases,atts):\n    \tclassVars=vars(cls)\n    \tenums = classVars.get('__enumerables__',None)\n    \tnextIter = getattr(cls,'__nextitr__',itertools.count)()\n    \treverseLookup={}\n    \tvalues={}\n\n    \tif enums is not None:\n    \t\t#build reverse lookup\n    \t\tfor item in enums:\n    \t\t\tif isinstance(item,(tuple,list)):\n    \t\t\t\titems=list(item)\n    \t\t\t\tvalue=items.pop()\n    \t\t\t\tEnumMeta.__addToReverseLookup(reverseLookup,value,tuple(map(str,items)),nextIter)\n    \t\t\telse:\n    \t\t\t\tvalue=nextIter.next()\n    \t\t\t\tvalue=EnumMeta.__addToReverseLookup(reverseLookup,value,(str(item),),nextIter,False)#add it to the reverse lookup, but don't force it to that value\n\n    \t\t#build values and clean up reverse lookup\n    \t\tfor value,fkeys in reverseLookup.iteritems():\n    \t\t\tf,keys=fkeys\n    \t\t\tfor key in keys:\n    \t\t\t\tenum=EnumValue(key,value,cls)\n    \t\t\t\tsetattr(cls,key,enum)\n    \t\t\t\tvalues[key]=enum\n    \t\t\treverseLookup[value]=tuple(val for val in values.itervalues() if val.Value == value)\n    \tsetattr(cls,'__reverseLookup__',reverseLookup)\n    \tsetattr(cls,'__enumerables__',values)\n    \tsetattr(cls,'_Max',max([key for key in reverseLookup] or [0]))\n    \treturn super(EnumMeta,cls).__init__(name,bases,atts)\n\n    def __iter__(cls):\n    \tfor enum in cls.__enumerables__.itervalues():\n    \t\tyield enum\n    def GetEnumByName(cls,name):\n    \treturn cls.__enumerables__.get(name,None)\n    def GetEnumByValue(cls,value):\n    \treturn cls.__reverseLookup__.get(value,(None,))[0]\n\nclass Enum(object):\n    __metaclass__=EnumMeta\n    __enumerables__=None\n\nclass FlagEnum(Enum):\n    @staticmethod\n    def __nextitr__():\n    \tyield 0\n    \tfor val in itertools.count():\n    \t\tyield 2**val\n\n\ndef enum(name,*args):\n    return EnumMeta(name,(Enum,),dict(__enumerables__=args))\n</code>\n</pre>\n", "senID": 1}, {"text": ["take it or leave it, it did what i needed it to do :)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["use it like:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Air(FlagEnum):\n    __enumerables__=('None','Oxygen','Nitrogen','Hydrogen')\n\nclass Mammals(Enum):\n    __enumerables__=('Bat','Whale',('Dog','Puppy',1),'Cat')\nBool = enum('Bool','Yes',('No',0))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I had need of some symbolic constants in pyparsing to represent left and right associativity of binary operators.", "I used class constants like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # an internal class, not intended to be seen by client code\nclass _Constants(object):\n    pass\n\n\n# an enumeration of constants for operator associativity\nopAssoc = _Constants()\nopAssoc.LEFT = object()\nopAssoc.RIGHT = object()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now when client code wants to use these constants, they can import the entire enum using:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import opAssoc from pyparsing\n</code>\n</pre>\n", "senID": 3}, {"text": ["The enumerations are unique, they can be tested with 'is' instead of '==', they don't take up a big footprint in my code for a minor concept, and they are easily imported into the client code.", "They don't support any fancy str() behavior, but so far that is in the YAGNI category."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "YAGNI", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://c2.com/xp/YouArentGonnaNeedIt.html"}]}], [{"text": ["Here is another one.", "It seems somewhat similar to the general approach used by @Cipher.", "The author called it yapenum, \"yet another Python enum\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://blog.bstpierre.org/yet-another-python-enum-module"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://blog.bstpierre.org/yet-another-python-enum-module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://blog.bstpierre.org/yet-another-python-enum-module"}]}], [{"text": ["This is the best one I have seen: \"First Class Enums in Python\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://code.activestate.com/recipes/413486/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://code.activestate.com/recipes/413486/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/413486/"}]}, {"text": ["It gives you a class, and the class contains all the enums.", "The enums can be compared to each other, but don't have any particular value; you can't use them as an integer value.", "(I resisted this at first because I am used to C enums, which are integer values.", "But if you can't use it as an integer, you can't use it as an integer by mistake so overall I think it is a win.", ") Each enum is a unique value.", "You can print enums, you can iterate over them, you can test that an enum value is \"in\" the enum.", "It's pretty complete and slick."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Considering this same question several years later, the enum package from PyPi provides a robust implementation of enums.", "An earlier answer mentioned PEP 354; this was rejected but the proposal was implemented \nhttp://pypi.python.org/pypi/enum."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://pypi.python.org/pypi/enum", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/enum"}]}], [{"text": ["I prefer to define enums in Python like so:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Animal:\n  class Dog: pass\n  class Cat: pass\n\nx = Animal.Dog\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's more bug-proof than using integers since you don't have to worry about ensuring that the integers are unique (e.g.", "if you said Dog = 1 and Cat = 1 you'd be screwed)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It's more bug-proof than using strings since you don't have to worry about typos (e.g.", "x == \"catt\" fails silently, but x == Animal.Catt is a runtime exception)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Another, very simple, implementation of an enum in Python, using namedtuple:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "namedtuple", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from collections import namedtuple\n\ndef enum(*keys):\n    return namedtuple('Enum', keys)(*keys)\n\nMyEnum = enum('FOO', 'BAR', 'BAZ')\n</code>\n</pre>\n", "senID": 1}, {"text": ["or, alternatively,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # With sequential number values\ndef enum(*keys):\n    return namedtuple('Enum', keys)(*range(len(keys)))\n\n# From a dict / keyword args\ndef enum(**kwargs):\n    return namedtuple('Enum', kwargs.keys())(*kwargs.values())\n</code>\n</pre>\n", "senID": 3}, {"text": ["Like the method above that subclasses set, this allows:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 'FOO' in MyEnum\nother = MyEnum.FOO\nassert other == MyEnum.FOO\n</code>\n</pre>\n", "senID": 5}, {"text": ["But has more flexibility as it can have different keys and values.", "This allows"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n MyEnum.FOO &lt; MyEnum.BAR\n</code>\n</pre>\n", "senID": 7}, {"text": ["to act as is expected if you use the version that fills in sequential number values."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["What about :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n TYPE = {'EAN13':   u'EAN-13',\n        'CODE39':  u'Code 39',\n        'CODE128': u'Code 128',\n        'i25':     u'Interleaved 2 of 5',}\n\n&gt;&gt;&gt; TYPE.items()\n[('EAN13', u'EAN-13'), ('i25', u'Interleaved 2 of 5'), ('CODE39', u'Code 39'), ('CODE128', u'Code 128')]\n&gt;&gt;&gt; TYPE.keys()\n['EAN13', 'i25', 'CODE39', 'CODE128']\n&gt;&gt;&gt; TYPE.values()\n[u'EAN-13', u'Interleaved 2 of 5', u'Code 39', u'Code 128']\n</code>\n</pre>\n", "senID": 1}, {"text": ["I used that for Django model choices, it looks very pythonic.", "It is not really a Enum, but do the job."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Following the Java like enum implementation proposed by Aaron Maenpaa, i came out with this, the idea was to make it generic and parseable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Enum:\n    #'''\n    #Java like implementation for enums.\n    #\n    #Usage:\n    #class Tool(Enum): name = 'Tool'\n    #Tool.DRILL = Tool.register('drill')\n    #Tool.HAMMER = Tool.register('hammer')\n    #Tool.WRENCH = Tool.register('wrench')\n    #'''\n\n    name = 'Enum'    # Enum name\n    _reg = dict([])   # Enum registered values\n\n    @classmethod\n    def register(cls, value):\n        #'''\n        #Registers a new value in this enum.\n        #\n        #@param value: New enum value.\n        #\n        #@return: New value wrapper instance.\n        #'''\n        inst = cls(value)\n        cls._reg[value] = inst\n        return inst\n\n    @classmethod\n    def parse(cls, value):\n        #'''\n        #Parses a value, returning the enum instance.\n        #\n        #@param value: Enum value.\n        #\n        #@return: Value corresp instance.        \n        #'''\n        return cls._reg.get(value)    \n\n    def __init__(self, value):\n        #'''\n        #Constructor (only for internal use).\n        #'''\n        self.value = value\n\n    def __str__(self):\n        #'''\n        #str() overload.\n        #'''\n        return self.value\n\n    def __repr__(self):\n        #'''\n        #repr() overload.\n        #'''\n        return \"&lt;\" + self.name + \": \" + self.value + \"&gt;\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Why must enumerations be ints?", "Unfortunately, I can't think of any good looking construct to produce this without chaning the Python language, so I'll use strings:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Enumerator(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __eq__(self, other):\n        if self.name == other:\n            return True\n        return self is other\n\n    def __ne__(self, other):\n        if self.name != other:\n            return False\n        return self is other\n\n    def __repr__(self):\n        return 'Enumerator({0})'.format(self.name)\n\n    def __str__(self):\n        return self.name\n\nclass Enum(object):\n    def __init__(self, *enumerators):\n        for e in enumerators:\n            setattr(self, e, Enumerator(e))\n    def __getitem__(self, key):\n        return getattr(self, key)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then again maybe it's even better now that we can naturally test against strings, for the sake of config files or other remote input."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Cow(object):\n    State = Enum(\n        'standing',\n        'walking',\n        'eating',\n        'mooing',\n        'sleeping',\n        'dead',\n        'dying'\n    )\n    state = State.standing\n\nIn [1]: from enum import Enum\n\nIn [2]: c = Cow()\n\nIn [3]: c2 = Cow()\n\nIn [4]: c.state, c2.state\nOut[4]: (Enumerator(standing), Enumerator(standing))\n\nIn [5]: c.state == c2.state \nOut[5]: True\n\nIn [6]: c.State.mooing\nOut[6]: Enumerator(mooing)\n\nIn [7]: c.State['mooing']\nOut[7]: Enumerator(mooing)\n\nIn [8]: c.state = Cow.State.dead\n\nIn [9]: c.state == c2.state\nOut[9]: False\n\nIn [10]: c.state == Cow.State.dead\nOut[10]: True\n\nIn [11]: c.state == 'dead'\nOut[11]: True\n\nIn [12]: c.state == Cow.State['dead']\nOut[11]: True\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n def enum( *names ):\n\n    '''\n    Makes enum.\n    Usage:\n        E = enum( 'YOUR', 'KEYS', 'HERE' )\n        print( E.HERE )\n    '''\n\n    class Enum():\n        pass\n    for index, name in enumerate( names ):\n        setattr( Enum, name, index )\n    return Enum\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I like the java enum, that's how I do it in python: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def enum(clsdef): \n    class Enum(object):\n        __slots__=tuple([var for var in clsdef.__dict__ if isinstance((getattr(clsdef, var)), tuple) and not var.startswith('__')])\n\n        def __new__(cls, *args, **kwargs):\n            if not '_the_instance' in cls.__dict__:\n                cls._the_instance = object.__new__(cls, *args, **kwargs)\n            return cls._the_instance\n\n        def __init__(self):\n            clsdef.values=lambda cls, e=Enum: e.values()\n            clsdef.valueOf=lambda cls, n, e=self: e.valueOf(n)\n            for ordinal, key in enumerate(self.__class__.__slots__):\n                args=getattr(clsdef, key)\n                instance=clsdef(*args)\n                instance._name=key\n                instance._ordinal=ordinal\n                setattr(self, key, instance)\n\n        @classmethod\n        def values(cls):\n            if not hasattr(cls, '_values'):\n                cls._values=[getattr(cls, name) for name in cls.__slots__]\n            return cls._values\n\n        def valueOf(self, name):\n            return getattr(self, name)\n\n        def __repr__(self):\n            return ''.join(['&lt;class Enum (', clsdef.__name__, ') at ', str(hex(id(self))), '&gt;'])\n\n    return Enum()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Sample use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n i=2  \n@enum\nclass Test(object):\n    A=(\"a\",1)\n    B=(\"b\",)\n    C=(\"c\",2)\n    D=tuple()\n    E=(\"e\",3)\n\n    while True:\n        try:\n            F, G, H, I, J, K, L, M, N, O=[tuple() for _ in range(i)]\n            break;\n        except ValueError:\n            i+=1\n\n    def __init__(self, name=\"default\", aparam=0):\n        self.name=name\n        self.avalue=aparam\n</code>\n</pre>\n", "senID": 3}, {"text": ["all class variables are defined as a tuple, just like the constructor.", "so far, you can't use named arguments."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I needed the possibility of having the enum values be floats (not just integers) for use in defining API's where the enum classes are part of the API.", "My requirements (and implementation) are in this blog post:\nhttp://franktheblue.blogspot.com/2011/05/enums-in-python-more-flexible-and.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://franktheblue.blogspot.com/2011/05/enums-in-python-more-flexible-and.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://franktheblue.blogspot.com/2011/05/enums-in-python-more-flexible-and.html"}]}], [{"text": ["Here is a variant on Alec Thomas's solution:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Alec Thomas's solution", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/36932/whats-the-best-way-to-implement-an-enum-in-python/1695250#1695250"}]}, {"code": "<pre>\n<code>\n def enum(*args, **kwargs):\n    return type('Enum', (), dict((y, x) for x, y in enumerate(args), **kwargs)) \n\nx = enum('POOH', 'TIGGER', 'EEYORE', 'ROO', 'PIGLET', 'RABBIT', 'OWL')\nassert x.POOH == 0\nassert x.TIGGER == 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about the enumerate built-in function?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for i, season in enumerate(['Spring', 'Summer', 'Fall', 'Winter']):\n...     print i, season\n\n0 Spring\n1 Summer\n2 Fall\n3 Winter\n</code>\n</pre>\n", "senID": 1}]]