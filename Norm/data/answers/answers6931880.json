[[{"text": ["'cat' has an address because you create it in order to pass it to id().", "You haven't yet bound it to a name, but the object still exists."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "'cat'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "id()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Python caches and reuses short strings.", "But if you assemble strings by concatenation, then the code that searches the cache and attempts re-use is bypassed."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Note that the inner workings of the string cache is pure implementation detail and should not be relied upon."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Python interns all string literals, which means it stores them in a big table of string literals and reuses them wherever they occur.", "So, no matter where you use \"cat\", it always refers to the same string object.", "This is done at \"compile\" time (that is, when the bytecode is generated -- Python is only half-compiled)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "interns", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "\"cat\"", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["On the other hand, something like \"c\" + \"a\" + \"t\" is a string expression.", "Its value can't be known at \"compile\" time (well, it could be in this trivial case consisting only of string literals, but Python doesn't try), so it normally isn't interned.", "Thus its id() is different from that of \"cat\".", "But you can force a string to be interned using the intern() function.", "Thus:"], "childNum": 6, "tag": "p", "senID": 1, "childList": [{"text": "\"c\" + \"a\" + \"t\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "expression.", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "could", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "id()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "\"cat\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "intern()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n id(intern(\"c\" + \"a\" + \"t\")) == id(\"cat\")   # True\n</code>\n</pre>\n", "senID": 2}, {"text": ["As others have mentioned, interning is possible because strings are immutable.", "It isn't possible to change \"cat\" to \"dog\", in other words.", "You have to generate a new string object, which means that there's no danger that other names are pointing to the same string and will be affected."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "\"cat\"", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\"dog\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["All values must reside somewhere in memory.", "This is why id('cat') produces a value.", "You call it a \"non-existent\" string, but it clearly does exist, it just hasn't been assigned to a name yet."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "id('cat')", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Strings are immutable, so the interpreter can do clever things like make all instances of the literal 'cat' be the same object, so that id(a) and id(b) are the same."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "'cat'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "id(a)", "childNum": 0, "tag": "code", "childList": []}, {"text": "id(b)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Operating on strings will produce new strings.", "These may or may not be the same strings as previous strings with the same content."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note that all of these details are implementations details of CPython, and they can change at any time.", "You don't need to be concerned with these issues in actual programs."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Python variables are rather unlike variables in other languages (say, C).  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In many other languages, a variable is a name for a location in memory.", "In these languages, Different kinds of variables can refer to different kinds of locations, and the same location could be given multiple names.", "For the most part, a given memory location can have the data change from time to time.", "There are also ways to refer to memory locations indirectly (int *p would contain the address, and in the memory location at that address, there's an integer.", ")  But a the actual location a variable references cannot change; The variable is the location.", "A variable assignment in these languages is effectively \"Look up the location for this variable, and copy this data into that location\""], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "int *p", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "is", "childNum": 0, "tag": "em", "pos": 4, "childList": []}]}, {"text": ["Python doesn't work that way.", "In python, actual objects go in some memory location, and variables are like tags for locations.", "Python manages the stored values in a separate way from how it manages the variables.", "Essentially, an assignment in python means \"Look up the information for this variable, forget the location it already refers to, and replace that with this new location\".", "No data is copied.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["A common feature of langauges that work like python (as opposed to the first kind we were talking about earlier) is that some kinds of objects are managed in a special way; identical values are cached so that they don't take up extra memory, and so that they can be compared very easily (if they have the same address, they are equal).", "This process is called interning; All python string literals are interned (in addition to a few other types), although dynamically created strings may not be."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "interning", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/String_interning"}]}, {"text": ["In your exact code, The semantic dialog would be: "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n # before anything, since 'cat' is a literal constant, add it to the intern cache\n&gt;&gt;&gt; id('cat') # grab the constant 'cat' from the intern cache and look up \n              # it's address\n5181152\n&gt;&gt;&gt; a = 'cat' # grab the constant 'cat' from the intern cache and \n              # make the variable \"a\" point to it's location \n&gt;&gt;&gt; b = 'cat' # do the same thing with the variable \"b\"\n&gt;&gt;&gt; id(a) # look up the object \"a\" currently points to, \n          # then look up that object's address\n5181152\n&gt;&gt;&gt; id(b) # look up the object \"b\" currently points to, \n          # then look up that object's address\n5181152\n</code>\n</pre>\n", "senID": 5}], [{"text": ["The code you posted creates new strings as intermediate objects.", "These created strings eventually have the same contents as your originals.", "In the intermediate time period, they do not exactly match the original, and must be kept at a distinct address."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; id('cat')\n5181152\n</code>\n</pre>\n", "senID": 1}, {"text": ["As others have answered, by issuing these instructions, you cause the Python VM to create a string object containing the string \"cat\".", "This string object is cached and is at address 5181152."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = 'cat'\n&gt;&gt;&gt; id(a)\n5181152\n</code>\n</pre>\n", "senID": 3}, {"text": ["Again, a has been assigned to refer to this cached string object at 5181152, containing \"cat\"."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = a[0:2]\n&gt;&gt;&gt; id(a)\n27731511\n</code>\n</pre>\n", "senID": 5}, {"text": ["At this point in my modified version of your program, you have created two small string objects:  'cat' and 'ca'.", "'cat' still exists in the cache.", "The string to which a refers is a different and probably novel string object, containing the characters 'ca'."], "childNum": 5, "tag": "p", "senID": 6, "childList": [{"text": "'cat'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'ca'", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "'cat'", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "'ca'", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = a + 't'\n&gt;&gt;&gt; id(a)\n39964224\n</code>\n</pre>\n", "senID": 7}, {"text": ["Now you have created another new string object.", "This object is the concatenation of the string 'ca' at address 27731511, and the string 't'.", "This concatenation does match the previously-cached string 'cat'.", "Python does not automatically detect this case.", "As kindall indicated, you can force the search with the intern() method."], "childNum": 4, "tag": "p", "senID": 8, "childList": [{"text": "'ca'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "'t'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "'cat'", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "intern()", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"text": ["Hopefully this explanation illuminates the steps by which the address of a changed."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Your code did not include the intermediate state with a assigned the string 'ca'.", "The answer still applies, because the Python interpreter does generate a new string object to hold the intermediate result a[0:2], whether you assign that intermediate result to a variable or not."], "childNum": 3, "tag": "p", "senID": 10, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'ca'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a[0:2]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]