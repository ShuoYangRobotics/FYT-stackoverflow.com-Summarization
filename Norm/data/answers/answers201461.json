[[{"text": ["Well, you can make things a little easier by fixing up the syntax:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def r(a):\n  i = a.find('0')\n  ~i or exit(a)\n  [m in[(i-j)%9*(i/9^j/9)*(i/27^j/27|i%9/3^j%9/3)or a[j]for j in range(81)] or r(a[:i]+m+a[i+1:])for m in'%d'%5**18]\nfrom sys import *\nr(argv[1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Cleaning up a little:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from sys import exit, argv\ndef r(a):\n  i = a.find('0')\n  if i == -1:\n    exit(a)\n  for m in '%d' % 5**18:\n    m in[(i-j)%9*(i/9^j/9)*(i/27^j/27|i%9/3^j%9/3) or a[j] for j in range(81)] or r(a[:i]+m+a[i+1:])\n\nr(argv[1])\n</code>\n</pre>\n", "senID": 3}, {"text": ["Okay, so this script expects a command-line argument, and calls the function r on it.", "If there are no zeros in that string, r exits and prints out its argument.  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I guess this means that zeros correspond to open spaces, and a puzzle with no zeros is solved.", "Then there's that nasty recursive expression."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The loop is interesting: for m in'%d'%5**18"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "for m in'%d'%5**18", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Why 5**18?", "It turns out that '%d'%5**18 evaluates to '3814697265625'.", "This is a string that has each digit 1-9 at least once, so maybe it's trying to place each of them.", "In fact, it looks like this is what r(a[:i]+m+a[i+1:]) is doing: recursively calling r, with the first blank filled in by a digit from that string.", "But this only happens if the earlier expression is false.", "Let's look at that:"], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "'%d'%5**18", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "'3814697265625'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "r(a[:i]+m+a[i+1:])", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["m in [(i-j)%9*(i/9^j/9)*(i/27^j/27|i%9/3^j%9/3) or a[j] for j in range(81)]"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "m in [(i-j)%9*(i/9^j/9)*(i/27^j/27|i%9/3^j%9/3) or a[j] for j in range(81)]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So the placement is done only if m is not in that monster list.", "Each element is either a number (if the first expression is nonzero) or a character (if the first expression is zero).", "m is ruled out as a possible substitution if it appears as a character, which can only happen if the first expression is zero.", "When is the expression zero?"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["It has three parts that are multiplied:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": ["(i-j)%9"], "childNum": 0, "tag": "code", "senID": 11, "childList": []}, {"text": ["(i/9^j/9)"], "childNum": 0, "tag": "code", "senID": 12, "childList": []}, {"text": ["(i/27^j/27|i%9/3^j%9/3)"], "childNum": 0, "tag": "code", "senID": 13, "childList": []}, {"text": ["\ni/27^j^27which is zero if i/27 == j/27, i.e.", "the same block of three rows\n"], "childNum": 2, "tag": "ul", "senID": 14, "childList": [{"text": "i/27^j^27which is zero if i/27 == j/27, i.e. the same block of three rows", "childNum": 1, "tag": "li", "pos": -1, "childList": [{"text": "i/27^j^27", "tag": "code"}]}, {"text": "i/27^j^27", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["\ni%9/3^j%9/3which is zero if i%9/3 == j%9/3, i.e.", "the same block of three columns\n"], "childNum": 2, "tag": "ul", "senID": 15, "childList": [{"text": "i%9/3^j%9/3which is zero if i%9/3 == j%9/3, i.e. the same block of three columns", "childNum": 1, "tag": "li", "pos": -1, "childList": [{"text": "i%9/3^j%9/3", "tag": "code"}]}, {"text": "i%9/3^j%9/3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}, {"text": ["If any of these three parts is zero, the entire expression is zero.", "In other words, if i and j share a row, column, or 3x3 block, then the value of j can't be used as a candidate for the blank at i.  Aha!"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n from sys import exit, argv\ndef r(a):\n  i = a.find('0')\n  if i == -1:\n    exit(a)\n  for m in '3814697265625':\n    okay = True\n    for j in range(81):\n      if (i-j)%9 == 0 or (i/9 == j/9) or (i/27 == j/27 and i%9/3 == j%9/3):\n        if a[j] == m:\n          okay = False\n          break\n    if okay:\n      # At this point, m is not excluded by any row, column, or block, so let's place it and recurse\n      r(a[:i]+m+a[i+1:])\n\nr(argv[1])\n</code>\n</pre>\n", "senID": 17}, {"text": ["Note that if none of the placements work out, r will return and back up to the point where something else can be chosen, so it's a basic depth first algorithm."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["Not using any heuristics, it's not particularly efficient.", "I took this puzzle from Wikipedia (http://en.wikipedia.org/wiki/Sudoku):"], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "http://en.wikipedia.org/wiki/Sudoku", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Sudoku"}]}, {"code": "<pre>\n<code>\n $ time python sudoku.py 530070000600195000098000060800060003400803001700020006060000280000419005000080079\n534678912672195348198342567859761423426853791713924856961537284287419635345286179\n\nreal    0m47.881s\nuser    0m47.223s\nsys 0m0.137s\n</code>\n</pre>\n", "senID": 20}, {"text": ["Addendum: How I would rewrite it as a maintenance programmer (this version has about a 93x speedup :)"], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"code": "<pre>\n<code>\n import sys\n\ndef same_row(i,j): return (i/9 == j/9)\ndef same_col(i,j): return (i-j) % 9 == 0\ndef same_block(i,j): return (i/27 == j/27 and i%9/3 == j%9/3)\n\ndef r(a):\n  i = a.find('0')\n  if i == -1:\n    sys.exit(a)\n\n  excluded_numbers = set()\n  for j in range(81):\n    if same_row(i,j) or same_col(i,j) or same_block(i,j):\n      excluded_numbers.add(a[j])\n\n  for m in '123456789':\n    if m not in excluded_numbers:\n      # At this point, m is not excluded by any row, column, or block, so let's place it and recurse\n      r(a[:i]+m+a[i+1:])\n\nif __name__ == '__main__':\n  if len(sys.argv) == 2 and len(sys.argv[1]) == 81:\n    r(sys.argv[1])\n  else:\n    print 'Usage: python sudoku.py puzzle'\n    print '  where puzzle is an 81 character string representing the puzzle read left-to-right, top-to-bottom, and 0 is a blank'\n</code>\n</pre>\n", "senID": 22}], [{"text": ["unobfuscating it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def r(a):\n    i = a.find('0') # returns -1 on fail, index otherwise\n    ~i or exit(a) # ~(-1) == 0, anthing else is not 0\n                  # thus: if i == -1: exit(a)\n    inner_lexp = [ (i-j)%9*(i/9 ^ j/9)*(i/27 ^ j/27 | i%9/3 ^ j%9/3) or a[j] \n                   for j in range(81)]  # r appears to be a string of 81 \n                                        # characters with 0 for empty and 1-9 \n                                        # otherwise\n    [m in inner_lexp or r(a[:i]+m+a[i+1:]) for m in'%d'%5**18] # recurse\n                            # trying all possible digits for that empty field\n                            # if m is not in the inner lexp\n\nfrom sys import *\nr(argv[1]) # thus, a is some string\n</code>\n</pre>\n", "senID": 1}, {"text": ["So, we just need to work out the inner list expression.", "I know it collects the digits set in the line -- otherwise, the code around it makes no sense.", "However, I have no real clue how it does that (and Im too tired to work out that binary fancyness right now, sorry)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A lot of the short sudoku solvers just recursively try every possible legal number left until they have successfully filled the cells.", "I haven't taken this apart, but just skimming it, it looks like that's what it does."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["r(a) is a recursive function which attempts to fill in a 0 in the board in each step."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "r(a)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["i=a.find('0');~i or exit(a) is the on-success termination.", "If no more 0 values exist in the board, we're done."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "i=a.find('0');~i or exit(a)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["m is the current value we will try to fill the 0 with."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "m", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["m\nin[(i-j)%9*(i/9^j/9)*(i/27^j/27|i%9/3^j%9/3)or a[j]for\nj in range(81)] evaluates to truthy if it is obivously incorrect to put m in the current 0.", "Let's nickname it \"is_bad\".", "This is the most tricky bit.", ":)"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "m\nin[(i-j)%9*(i/9^j/9)*(i/27^j/27|i%9/3^j%9/3)or a[j]for\nj in range(81)]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "m", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["is_bad or r(a[:i]+m+a[i+1:] is a conditional recursive step.", "It will recursively try to evaluate the next 0  in the board iff the current solution candidate appears to be sane."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "is_bad or r(a[:i]+m+a[i+1:]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["for m in '%d'%5**18 enumerates all the numbers from 1 to 9 (inefficiently)."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "for m in '%d'%5**18", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Good grief, y'all.", "I like coding, but cripes, it's sudoku.", "Solve it like it was intended to be."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["So, basically this is a break down of how 4 great lines of code can be re-worded into 30 to serve the exact same purpose in a readable format for people too slow to comprehend the original 4 lines?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I love the multiplied or (|) followed by another or!", "Using or operators is often computationally faster for your processor.", "Assembly teaches us that the fastest way to set a particular register to 0 is not to actually set it to 0 but to Xor the register with itself!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you're not wrapping your brain around this code, don't worry!", "It's not exactly easy, but it IS fast and I actually like the obfuscated and compact form much better than the several versions of different formatting which only serve to bloat the code.", "Good thing this is Python because any good compiler would remove all the junk anyway and pretty much make the code look like the original lines."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It looks a little like a brute-force solution, but my python is rudimentary."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]