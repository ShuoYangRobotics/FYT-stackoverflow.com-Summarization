[[{"text": ["Calling close and shutdown have two different affects on the underlying socket."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "close", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "shutdown", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The first thing to point out is that the socket is a resource in the underlying OS and multiple processes can have a handle for the same underlying socket."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "multiple processes can have a handle for the same underlying socket.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["When you call close it decrements the handle count by one and if the handle count has reached zero then the socket and associated connection goes through the normal close procedure (effectively sending a FIN / EOF to the peer) and the socket is deallocated."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "close", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The thing to pay attention to here is that if the handle count does not reach zero because another process still has a handle to the socket then the connection is not closed and the socket is not deallocated."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "is not closed and the socket is not deallocated.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["On the other hand calling shutdown for reading and writing closes the underlying connection and sends a FIN / EOF to the peer regardless of how many processes have handles to the socket.", "However, it does not deallocate the socket and you still need to call close afterward."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "shutdown", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "does not", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}], [{"text": ["Here's one explanation:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "explanation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://publib.boulder.ibm.com/infocenter/systems/index.jsp?topic=/com.ibm.aix.progcomm/doc/progcomc/skt_shutdn.htm"}]}], [{"text": ["Explanation of shutdown and close: Graceful shutdown (msdn)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Graceful shutdown (msdn)", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://msdn.microsoft.com/en-us/library/ms738547(VS.85).aspx"}]}, {"text": ["Shutdown (in your case) indicates to the other end of the connection there is no further intention to read from or write to the socket.", "Then close frees up any memory associated with the socket."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Omitting shutdown may cause the socket to linger in the OSs stack until the connection has been closed gracefully."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["IMO the names 'shutdown' and 'close' are misleading, 'close' and 'destroy' would emphasise their differences."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["there are some flavours of shutdown: http://msdn.microsoft.com/en-us/library/system.net.sockets.socket.shutdown.aspx.", "*nix is similar."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://msdn.microsoft.com/en-us/library/system.net.sockets.socket.shutdown.aspx", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://msdn.microsoft.com/en-us/library/system.net.sockets.socket.shutdown.aspx"}]}], [{"text": ["Shutdown(1) , forces the socket no to send any more data"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is usefull in"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["1- Buffer flushing"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["2- Strange error detection"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["3- Safe guarding"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Let me explain more , when you send a data from A to B , it's not guaranteed to be \nsent to B , it's only guaranteed to be sent to the A os buffer , \nwhich in turn sends it to the B os buffer"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["So by calling shutdown(1) on A , you flush A's buffer and an error is raised \nif the buffer is not empty ie: data has not been sent to the peer yet"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Howoever this is irrevesable , so you can do that after you completely \nsent all your data and you want to be sure that it's atleast at the peer \nos buffer"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Isn't this code above wrong?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The close call directly after the shutdown call might make the kernel discard all outgoing buffers anyway."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["According to\nhttp://blog.netherlabs.nl/articles/2009/01/18/the-ultimate-so_linger-page-or-why-is-my-tcp-not-reliable\none needs to wait between the shutdown and the close until read returns 0."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://blog.netherlabs.nl/articles/2009/01/18/the-ultimate-so_linger-page-or-why-is-my-tcp-not-reliable", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://blog.netherlabs.nl/articles/2009/01/18/the-ultimate-so_linger-page-or-why-is-my-tcp-not-reliable"}]}]]