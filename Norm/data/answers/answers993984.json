[[{"text": ["NumPy's arrays are more compact than Python lists -- a list of lists as you describe, in Python, would take at least 20 MB or so, while a NumPy 3D array with single-precision floats in the cells would fit in 4 MB.", "Access in reading and writing items is also faster with NumPy."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Maybe you don't care that much for just a million cells, but you definitely would for a billion cells -- neither approach would fit in a 32-bit architecture, but with 64-bit builds NumPy would get away with 4 GB or so, Python alone would need at least about 12 GB (lots of pointers which double in size) -- a much costlier piece of hardware!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The difference is mostly due to \"indirectness\" -- a Python list is an array of pointers to Python objects, at least 4 bytes per pointer plus 16 bytes for even the smallest Python object (4 for type pointer, 4 for reference count, 4 for value -- and the memory allocators rounds up to 16).", "A NumPy array is an array of uniform values -- single-precision numbers takes 4 bytes each, double-precision ones, 8 bytes.", "Less flexible, but you pay substantially for the flexibility of standard Python lists!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Numpy is not just more efficient, it is also more convenient.", "You get a lot of vector and matrix operations for free, which sometimes allow one to avoid unnecessary work.", "And they are also efficiently implemented."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, you could read your cube directly from a file into an array:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n x = numpy.fromfile(file=open(\"data\"), dtype=float).reshape((100, 100, 100))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Sum along the second dimension:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n s = x.sum(axis=1)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Find which cells are above a threshold:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n (x &gt; 0.5).nonzero()\n</code>\n</pre>\n", "senID": 6}, {"text": ["Remove every even-indexed slice along the third dimension:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n x[:, :, ::2]\n</code>\n</pre>\n", "senID": 8}, {"text": ["Also, other libraries that could be useful for you work on numpy arrays.", "For example, statistical analysis and visualization libraries."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Even if you don't have performance problems, learning numpy is worth the effort."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["Alex mentioned memory efficiency, and Roberto mentions convenience, and these are both good points.", "For a few more ideas I'll mention speed and funcionality."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "speed", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "funcionality", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Functionality:  You get a lot built in with Numpy, FFTs, convolutions, fast searching, basic statistics, linear algebra, histograms, etc.", "And really, who can live without FFTs?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Speed: Here's a test on doing a sum over a list and a numpy array, showing that the sum on the numpy array is 10x faster (in this test -- milage may vary)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from numpy import arange\nfrom timeit import Timer\n\nNelements = 10000\nNtimeits = 10000\n\nx = arange(Nelements)\ny = range(Nelements)\n\nt_numpy = Timer(\"x.sum()\", \"from __main__ import x\")\nt_list = Timer(\"sum(y)\", \"from __main__ import y\")\nprint \"numpy: %.3e\" % (t_numpy.timeit(Ntimeits)/Ntimeits,)\nprint \"list:  %.3e\" % (t_list.timeit(Ntimeits)/Ntimeits,)\n</code>\n</pre>\n", "senID": 3}, {"text": ["which on my systems (while I'm running a backup) gives:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n numpy: 3.004e-05\nlist:  5.363e-04\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Note also that there is support for timeseries based on numpy in the timeseries scikits:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://pytseries.sourceforge.net"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://pytseries.sourceforge.net", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pytseries.sourceforge.net"}]}, {"text": ["For regression, I am pretty sure numpy will be order of magnitude faster and more convenient than lists even for the 100^3 problem"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]