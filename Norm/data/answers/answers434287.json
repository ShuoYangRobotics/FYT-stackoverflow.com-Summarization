[[{"code": "<pre>\n<code>\n def chunker(seq, size):\n    return (seq[pos:pos + size] for pos in xrange(0, len(seq), size))\n</code>\n</pre>\n", "senID": 0}, {"text": ["Simple.", "Easy.", "Fast.", "Works with any sequence:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n text = \"I am a very, very helpful text\"\n\nfor group in chunker(text, 7):\n   print repr(group),\n# 'I am a ' 'very, v' 'ery hel' 'pful te' 'xt'\n\nprint '|'.join(chunker(text, 10))\n# I am a ver|y, very he|lpful text\n\nanimals = ['cat', 'dog', 'rabbit', 'duck', 'bird', 'cow', 'gnu', 'fish']\n\nfor group in chunker(animals, 3):\n    print group\n# ['cat', 'dog', 'rabbit']\n# ['duck', 'bird', 'cow']\n# ['gnu', 'fish']\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Modified from the recipes section of Python's itertools docs:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "recipes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#recipes"}, {"href": "http://docs.python.org/library/itertools.html", "text": "itertools", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n def grouper(iterable, n, fillvalue=None):\n    args = [iter(iterable)] * n\n    return izip_longest(*args, fillvalue=fillvalue)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example\nIn pesudocode to keep the example terse."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Example", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"code": "<pre>\n<code>\n grouper('ABCDEFG', 3, 'x') --&gt; 'ABC' 'DEF' 'Gxx'\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note: izip_longest is new to Python 2.6"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "Note:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "izip_longest", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I'm a fan of "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n chunkSize= 4\nfor i in xrange(0, len(ints), chunkSize):\n    chunk = ints[i:i+chunkSize]\n    # process chunk of size &lt;= chunkSize\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import itertools\ndef chunks(iterable,size):\n    it = iter(iterable)\n    chunk = tuple(itertools.islice(it,size))\n    while chunk:\n        yield chunk\n        chunk = tuple(itertools.islice(it,size))\n\n# though this will throw ValueError if the length of ints\n# isn't a multiple of four:\nfor x1,x2,x3,x4 in chunks(ints,4):\n    foo += x1 + x2 + x3 + x4\n\nfor chunk in chunks(ints,4):\n    foo += sum(chunk)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Another way:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import itertools\ndef chunks2(iterable,size,filler=None):\n    it = itertools.chain(iterable,itertools.repeat(filler,size-1))\n    chunk = tuple(itertools.islice(it,size))\n    while len(chunk) == size:\n        yield chunk\n        chunk = tuple(itertools.islice(it,size))\n\n# x2, x3 and x4 could get the value 0 if the length is not\n# a multiple of 4.\nfor x1,x2,x3,x4 in chunks2(ints,4,0):\n    foo += x1 + x2 + x3 + x4\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n from itertools import izip_longest\n\ndef chunker(iterable, chunksize, filler):\n    return izip_longest(*[iter(iterable)]*chunksize, fillvalue=filler)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Since nobody's mentioned it yet here's a zip() solution:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "zip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def chunker(iterable, chunksize):\n...     return zip(*[iter(iterable)]*chunksize)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It works only if your sequence's length is always divisible by the chunk size or you don't care about a trailing chunk if it isn't."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = '1234567890'\n&gt;&gt;&gt; chunker(s, 3)\n[('1', '2', '3'), ('4', '5', '6'), ('7', '8', '9')]\n&gt;&gt;&gt; chunker(s, 4)\n[('1', '2', '3', '4'), ('5', '6', '7', '8')]\n&gt;&gt;&gt; chunker(s, 5)\n[('1', '2', '3', '4', '5'), ('6', '7', '8', '9', '0')]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Or using itertools.izip to return an iterator instead of a list:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "itertools.izip", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import izip\n&gt;&gt;&gt; def chunker(iterable, chunksize):\n...     return izip(*[iter(iterable)]*chunksize)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Padding can be fixed using @\u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5's answer:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "@\u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks-in-python#312644"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import chain, izip, repeat\n&gt;&gt;&gt; def chunker(iterable, chunksize, fillvalue=None):\n...     it   = chain(iterable, repeat(fillvalue, chunksize-1))\n...     args = [it] * chunksize\n...     return izip(*args)\n</code>\n</pre>\n", "senID": 8}], [{"text": ["There doesn't seem to be a pretty way to do this.", "Here is a page that has a number of methods, including:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/425397/"}]}, {"code": "<pre>\n<code>\n def split_seq(seq, size):\n    newseq = []\n    splitsize = 1.0/size*len(seq)\n    for i in range(size):\n        newseq.append(seq[int(round(i*splitsize)):int(round((i+1)*splitsize))])\n    return newseq\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In your second method, I would advance to the next group of 4 by doing this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ints = ints[4:]\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, I haven't done any performance measurement so I don't know which one might be more efficient."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Having said that, I would usually choose the first method.", "It's not pretty, but that's often a consequence of interfacing with the outside world."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If the list is large, the highest-performing way to do this will be to use a generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def get_chunk(iterable, chunk_size):\n    result = []\n    for item in iterable:\n        result.append(item)\n        if len(result) == chunk_size:\n            yield tuple(result)\n            result = []\n    if len(result) &gt; 0:\n        yield tuple(result)\n\nfor x in get_chunk([1,2,3,4,5,6,7,8,9,10], 3):\n    print x\n\n(1, 2, 3)\n(4, 5, 6)\n(7, 8, 9)\n(10,)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If the lists are the same size, you can combine them into lists of 4-tuples with zip().", "For example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "zip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # Four lists of four elements each.\n\nl1 = range(0, 4)\nl2 = range(4, 8)\nl3 = range(8, 12)\nl4 = range(12, 16)\n\nfor i1, i2, i3, i4 in zip(l1, l2, l3, l4):\n    ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here's what the zip() function produces:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "zip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print l1\n[0, 1, 2, 3]\n&gt;&gt;&gt; print l2\n[4, 5, 6, 7]\n&gt;&gt;&gt; print l3\n[8, 9, 10, 11]\n&gt;&gt;&gt; print l4\n[12, 13, 14, 15]\n&gt;&gt;&gt; print zip(l1, l2, l3, l4)\n[(0, 4, 8, 12), (1, 5, 9, 13), (2, 6, 10, 14), (3, 7, 11, 15)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["If the lists are large, and you don't want to combine them into a bigger list, use itertools.izip(), which produces an iterator, rather than a list."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "itertools.izip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import izip\n\nfor i1, i2, i3, i4 in izip(l1, l2, l3, l4):\n    ...\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Using itertools and iter, this simple function works both for sequences (tuples, lists) and iterables (no padding):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "iter", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n def grouper(n, it):\n  \"\"\"grouper(3, 'ABCDEFG') --&gt; ABC DEF G\"\"\"\n  return iter(lambda: list(itertools.islice(it, n)), [])\n\n&gt;&gt;&gt; list(grouper(2, iter([1,2,3,4,5])))\n[[1,2], [3,4], [5]]\n</code>\n</pre>\n", "senID": 1}]]