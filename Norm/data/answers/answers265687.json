[[{"text": ["In general, for any thread safety problem you will need to protect your internal data structures with locks.", "This can be done with various levels of granularity."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["You can use fine-grained locking, where every seperate structure has its own lock."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can use coarse-grained locking where one lock protects everything (the GIL approach)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]}, {"text": ["There are various pros and cons of each method.", "Fine-grained locking allows greater paralellism - two threads can\nexecute in paralell when they don't share any resources.", "However there is a much larger administrative overhead.", "For\nevery line of code, you may need to acquire and release several locks."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The coarse grained approach is the opposite.", "Two threads can't run at the same time, but an individual thread will run faster because its not doing so much bookkeeping.", "Ultimately it comes down to a tradeoff between single-threaded speed and paralellism."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["There have been a few attempts to remove the GIL in python, but the extra overhead for single threaded machines was generally too large.", "Some cases can actually be slower even on multi-processor machines\ndue to lock contention.  "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["In varies, and it probably shouldn't be considered a language property so much as an implementation property.", "For instance, there are Python implementations such as Jython and IronPython which use the threading approach of their underlying VM, rather than a GIL approach,\nand the next version of Ruby looks to be moving towards introducing a GIL."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "towards", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.infoq.com/news/2007/05/ruby-threading-futures"}]}], [{"text": ["The global interpreter lock is a big mutex-type lock that protects reference counters from getting hosed.", "If you are writing pure python code, this all happens behind the scenes, but if you embedding Python into C, then you might have to explicitly take/release the lock."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This mechanism is not related to Python being compiled to bytecode.", "It's not needed for Java.", "In fact, it's not even needed for Jython (python compiled to jvm)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Jython", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.jython.org/"}]}, {"text": ["see also this question"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "this question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/105095/are-locks-unnecessary-in-multi-threaded-python-code-because-of-the-gil"}]}], [{"text": ["The following is from the official Python/C API Reference Manual:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "official Python/C API Reference Manual", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/api/threads.html"}]}, {"text": ["I think it sums up the issue pretty well."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Python, like perl 5, was not designed from the ground up to be thread safe.", "Threads were grafted on after the fact, so the global interpreter lock is used to maintain mutual exclusion to where only one thread is executing code at a given time in the bowels of the interpreter."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Individual Python threads are cooperatively multitasked by the interpreter itself by cycling the lock every so often."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Grabbing the lock yourself is needed when you are talking to Python from C when other Python threads are active to 'opt in' to this protocol and make sure that nothing unsafe happens behind your back."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Other systems that have a single-threaded heritage that later evolved into mulithreaded systems often have some mechanism of this sort.", "For instance, the Linux kernel has the \"Big Kernel Lock\" from its early SMP days.", "Gradually over time as multi-threading performance becomes an issue there is a tendency to try to break these sorts of locks up into smaller pieces or replace them with lock-free algorithms and data structures where possible to maximize throughput."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Regarding your second qustion, not all scripting languages use this, but it only makes them less powerful.", "For instance, the theads in Ruby are green and not native.", "In Python the threads are native, and the GIL only prevents them from running on different cores."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "green", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Green_threads"}]}, {"text": ["In Perl the threads are even worse - they just copy the whole interpreter, and are far from being as usable as in Python."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Also, see this post on the GIL."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "post", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.voidspace.org.uk/python/weblog/arch_d7_2008_11_01.shtml#e1028"}]}], [{"text": ["Maybe this article by the BDFL will help."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.artima.com/weblogs/viewpost.jsp?thread=214235"}]}]]