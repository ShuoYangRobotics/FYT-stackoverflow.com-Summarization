[[{"text": ["Good question"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I've had a lot of experience running a compiled regex 1000s of times versus compiling on-the-fly, and have not noticed any perceivable difference.", "Obviously, this is colloquial, and certainly not a great argument against compiling, but I've found the difference to be negligible."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "against", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["EDIT:\nAfter a quick glance at the actual Python 2.5 library code, I see that Python internally compiles AND CACHES regexes whenever you use them anyway (including calls to re.match()), so you're really only changing WHEN the regex gets compiled, and shouldn't be saving much time at all - only the time it takes to check the cache (a key lookup on an internal dict type)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "re.match()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["From module re.py (comments are mine):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def match(pattern, string, flags=0):\n    return _compile(pattern, flags).match(string)\n\ndef _compile(*key):\n\n    # Does cache check at top of function\n    cachekey = (type(key[0]),) + key\n    p = _cache.get(cachekey)\n    if p is not None: return p\n\n    # ...\n    # Does actual compilation on cache miss\n    # ...\n\n    # Caches compiled regex\n    if len(_cache) &gt;= _MAXCACHE:\n        _cache.clear()\n    _cache[cachekey] = p\n    return p\n</code>\n</pre>\n", "senID": 4}, {"text": ["I still often pre-compile regular expressions, but only to bind them to a nice, reusable name, not for any expected performance gain."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["For me, the biggest benefit to re.compile isn't any kind of premature optimization (which is the root of all evil, anyway).", "It's being able to separate definition of the regex from its use."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "root of all evil", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://tinyurl.com/knuth-premature"}, {"text": "anyway", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Optimization_%28computer_science%29#When_to_optimize"}]}, {"text": ["Even a simple expression such as 0|[1-9][0-9]* (integer in base 10 without leading zeros) can be complex enough that you'd rather not have to retype it, check if you made any typos, and later have to recheck if there are typos when you start debugging.", "Plus, it's nicer to use a variable name such as num or num_b10 than 0|[1-9][0-9]+."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "0|[1-9][0-9]*", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "0|[1-9][0-9]+", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["It's certainly possible to store strings and pass them to re.match; however, that's less readable:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "less", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n num = \"...\"\n# then, much later:\nm = re.match(num, input)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Versus compiling:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n num = re.compile(\"...\")\n# then, much later:\nm = num.match(input)\n</code>\n</pre>\n", "senID": 5}, {"text": ["Though it is fairly close, the last line of the second feels more natural and simpler when used repeatedly."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["FWIW:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ python -m timeit -s \"import re\" \"re.match('hello', 'hello world')\"\n100000 loops, best of 3: 3.82 usec per loop\n\n$ python -m timeit -s \"import re; h=re.compile('hello')\" \"h.match('hello world')\"\n1000000 loops, best of 3: 1.26 usec per loop\n</code>\n</pre>\n", "senID": 1}, {"text": ["so, if you're going to be using  the same regex a lot, it may be worth it to do re.compile (especially for more complex regexes)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "same", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "re.compile", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The standard arguments against premature optimization apply, but I don't think you really lose much clarity/straightforwardness by using re.compile if you suspect that your regexps may become a performance bottleneck."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "re.compile", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["in general I find it is easier to use flags (at least easier to remember how), like re.I when compiling patterns than to use flags inline."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n foo_pat = re.compile('foo',re.I)\n\nfoo_pat.findall('some string FoO bar')\n&gt;&gt; ['FoO']\n</code>\n</pre>\n", "senID": 1}, {"text": ["vs "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n re.findall('(?i)foo','some string FoO bar')\n&gt;&gt; ['FoO']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I just tried this myself.", "For the simple case of parsing a number out of a string and summing it, using a compiled regular expression object is about twice as fast as using the re methods."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["As others have pointed out, the re methods (including re.compile) look up the regular expression string in a cache of previously compiled expressions.", "Therefore, in the normal case, the extra cost of using the re methods is simply the cost of the cache lookup."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "re", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "re.compile", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "re", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["However, examination of the code, shows the cache is limited to 100 expressions.", "This begs the question, how painful is it to overflow the cache?", "The code contains an internal interface to the regular expression compiler, re.sre_compile.compile.", "If we call it, we bypass the cache.", "It turns out to be about two orders of magnitude slower for a basic regular expression, such as r'\\w+\\s+([0-9_]+)\\s+\\w*'."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "code", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.google.com/codesearch/p?hl=en#1IKf2ZWr9OM/tools/third_party/python_26/Lib/re.py&q=lang%3apython%20re.py&sa=N&cd=4&ct=rc"}, {"text": "re.sre_compile.compile", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "r'\\w+\\s+([0-9_]+)\\s+\\w*'", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"text": ["Here's my test:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n#!/usr/bin/env python\nimport re\nimport time\n\ndef timed(func):\n    def wrapper(*args):\n        t = time.time()\n        result = func(*args)\n        t = time.time() - t\n        print '%s took %.3f seconds.' % (func.func_name, t)\n        return result\n    return wrapper\n\nregularExpression = r'\\w+\\s+([0-9_]+)\\s+\\w*'\ntestString = \"average    2 never\"\n\n@timed\ndef noncompiled():\n    a = 0\n    for x in xrange(1000000):\n        m = re.match(regularExpression, testString)\n        a += int(m.group(1))\n    return a\n\n@timed\ndef compiled():\n    a = 0\n    rgx = re.compile(regularExpression)\n    for x in xrange(1000000):\n        m = rgx.match(testString)\n        a += int(m.group(1))\n    return a\n\n@timed\ndef reallyCompiled():\n    a = 0\n    rgx = re.sre_compile.compile(regularExpression)\n    for x in xrange(1000000):\n        m = rgx.match(testString)\n        a += int(m.group(1))\n    return a\n\n\n@timed\ndef compiledInLoop():\n    a = 0\n    for x in xrange(1000000):\n        rgx = re.compile(regularExpression)\n        m = rgx.match(testString)\n        a += int(m.group(1))\n    return a\n\n@timed\ndef reallyCompiledInLoop():\n    a = 0\n    for x in xrange(10000):\n        rgx = re.sre_compile.compile(regularExpression)\n        m = rgx.match(testString)\n        a += int(m.group(1))\n    return a\n\nr1 = noncompiled()\nr2 = compiled()\nr3 = reallyCompiled()\nr4 = compiledInLoop()\nr5 = reallyCompiledInLoop()\nprint \"r1 = \", r1\nprint \"r2 = \", r2\nprint \"r3 = \", r3\nprint \"r4 = \", r4\nprint \"r5 = \", r5\n</pre>\n", "senID": 4}, {"text": ["And here is the output on my machine:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n$ regexTest.py \nnoncompiled took 4.555 seconds.\ncompiled took 2.323 seconds.\nreallyCompiled took 2.325 seconds.\ncompiledInLoop took 4.620 seconds.\nreallyCompiledInLoop took 4.074 seconds.\nr1 =  2000000\nr2 =  2000000\nr3 =  2000000\nr4 =  2000000\nr5 =  20000\n</pre>\n", "senID": 6}, {"text": ["The 'reallyCompiled' methods use the internal interface, which bypasses the cache.", "Note the one that compiles on each loop iteration is only iterated 10,000 times, not one million."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Interestingly, compiling does prove more efficient for me (Python 2.5.2 on Win XP):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nimport time\n\nrgx = re.compile('(\\w+)\\s+[0-9_]?\\s+\\w*')\nstr = \"average    2 never\"\na = 0\n\nt = time.time()\n\nfor i in xrange(1000000):\n    if re.match('(\\w+)\\s+[0-9_]?\\s+\\w*', str):\n    #~ if rgx.match(str):\n        a += 1\n\nprint time.time() - t\n</code>\n</pre>\n", "senID": 1}, {"text": ["Running the above code once as is, and once with the two if lines commented the other way around, the compiled regex is twice as fast"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Regular Expressions are compiled before being used when using the second version.", "If you are going to executing it many times it is definatly better to compile it first.", "If not compiling every time you match for one off's is fine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["This is a good question.", "You often see people use re.compile without reason.", "It lessens readability.", "But sure there are lots of times when pre-compiling the expression is called for.", "Like when you use it repeated times in a loop or some such."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's like everything about programming (everything in life actually).", "Apply common sense."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I ran this test before stumbling upon the discussion here.", "However, having run it I thought I'd at least post my results."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I stole and bastardized the example in Jeff Friedl's \"Mastering Regular Expressions\".", "This is on a macbook running OSX 10.6 (2Ghz intel core 2 duo, 4GB ram).", "Python version is 2.6.1."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Run 1 - using re.compile"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Run 1 - using re.compile", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import re \nimport time \nimport fpformat\nRegex1 = re.compile('^(a|b|c|d|e|f|g)+$') \nRegex2 = re.compile('^[a-g]+$')\nTimesToDo = 1000\nTestString = \"\" \nfor i in range(1000):\n    TestString += \"abababdedfg\"\nStartTime = time.time() \nfor i in range(TimesToDo):\n    Regex1.search(TestString) \nSeconds = time.time() - StartTime \nprint \"Alternation takes \" + fpformat.fix(Seconds,3) + \" seconds\"\n\nStartTime = time.time() \nfor i in range(TimesToDo):\n    Regex2.search(TestString) \nSeconds = time.time() - StartTime \nprint \"Character Class takes \" + fpformat.fix(Seconds,3) + \" seconds\"\n\nAlternation takes 2.299 seconds\nCharacter Class takes 0.107 seconds\n</code>\n</pre>\n", "senID": 3}, {"text": ["Run 2 - Not using re.compile"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Run 2 - Not using re.compile", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import re \nimport time \nimport fpformat\n\nTimesToDo = 1000\nTestString = \"\" \nfor i in range(1000):\n    TestString += \"abababdedfg\"\nStartTime = time.time() \nfor i in range(TimesToDo):\n    re.search('^(a|b|c|d|e|f|g)+$',TestString) \nSeconds = time.time() - StartTime \nprint \"Alternation takes \" + fpformat.fix(Seconds,3) + \" seconds\"\n\nStartTime = time.time() \nfor i in range(TimesToDo):\n    re.search('^[a-g]+$',TestString) \nSeconds = time.time() - StartTime \nprint \"Character Class takes \" + fpformat.fix(Seconds,3) + \" seconds\"\n\nAlternation takes 2.508 seconds\nCharacter Class takes 0.109 seconds\n</code>\n</pre>\n", "senID": 5}], [{"text": ["(months later) it's easy to add your own cache around re.match,\nor anything else for that matter --"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \"\"\" Re.py: Re.match = re.match + cache  \n    efficiency: re.py does this already (but what's _MAXCACHE ?)\n    readability, inline / separate: matter of taste\n\"\"\"\n\nimport re\n\ncache = {}\n_re_type = type( re.compile( \"\" ))\n\ndef match( pattern, str, *opt ):\n    \"\"\" Re.match = re.match + cache re.compile( pattern ) \n    \"\"\"\n    if type(pattern) == _re_type:\n        cpat = pattern\n    elif pattern in cache:\n        cpat = cache[pattern]\n    else:\n        cpat = cache[pattern] = re.compile( pattern, *opt )\n    return cpat.match( str )\n\n# def search ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["A wibni, wouldn't it be nice if: cachehint( size= ), cacheinfo() -> size, hits, nclear ..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["My understanding is that those two examples are effectively equivalent.", "The only difference is that in the first, you can reuse the compiled regular expression elsewhere without causing it to be compiled again."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's a reference for you: (http://diveintopython.org/refactoring/refactoring.html)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://diveintopython.org/refactoring/refactoring.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://diveintopython.org/refactoring/refactoring.html"}]}], [{"text": ["i'd like to motivate that pre-compiling is both conceptually and 'literately' (as in 'literate programming') advantageous.", "have a look at this code snippet:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from re import compile as _Re\n\nclass TYPO:\n\n  def text_has_foobar( self, text ):\n    return self._text_has_foobar_re_search( text ) is not None\n  _text_has_foobar_re_search = _Re( r\"\"\"(?i)foobar\"\"\" ).search\n\nTYPO = TYPO()\n</code>\n</pre>\n", "senID": 1}, {"text": ["in your application, you'd write:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from TYPO import TYPO\nprint( TYPO.text_has_foobar( 'FOObar ) )\n</code>\n</pre>\n", "senID": 3}, {"text": ["this is about as simple in terms of functionality as it can get.", "because this is example is so short, i conflated the way to get _text_has_foobar_re_search all in one line.", "the disadvantage of this code is that it occupies a little memory for whatever the lifetime of the TYPO library object is; the advantage is that when doing a foobar search, you'll get away with two function calls and two class dictionary lookups.", "how many regexes are cached by re and the overhead of that cache are irrelevant here. "], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "_text_has_foobar_re_search", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "TYPO", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "re", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["compare this with the more usual style, below:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nclass Typo:\n\n  def text_has_foobar( self, text ):\n    return re.compile( r\"\"\"(?i)foobar\"\"\" ).search( text ) is not None\n</code>\n</pre>\n", "senID": 6}, {"text": ["In the application:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n typo = Typo()\nprint( typo.text_has_foobar( 'FOObar ) )\n</code>\n</pre>\n", "senID": 8}, {"text": ["I readily admit that my style is highly unusual for python, maybe even debatable.", "however, in the example that more closely matches how python is mostly used, in order to do a single match, we must instantiate an object, do three instance dictionary lookups, and perform three function calls; additionally, we might get into re caching troubles when using more than 100 regexes.", "also, the regular expression gets hidden inside the method body, which most of the time is not such a good idea. "], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "re", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["be it said that every subset of measures---targeted, aliased import statements; aliased methods where applicable; reduction of function calls and object dictionary lookups---can help reduce computational and conceptual complexity. "], "childNum": 0, "tag": "p", "senID": 10, "childList": []}]]