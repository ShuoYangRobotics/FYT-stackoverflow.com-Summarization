[[{"text": ["Super lets you avoid referring to the base class explicitly, which can be nice.", "But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen.", "See the standard docs on super if you haven't already."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "fun stuff", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.artima.com/weblogs/viewpost.jsp?thread=236275"}, {"text": "standard docs on super", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#super"}]}, {"text": ["Edit: Note that the syntax changed in Python 3.0: you can just say super().__init__() instead of super(ChildB, self).__init__() which IMO is quite a bit nicer."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "super().__init__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "super(ChildB, self).__init__()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["There isn't, really.", "super() looks at the next class in the MRO (method resolution order, accessed with cls.__mro__) to call the methods.", "Just calling the base __init__ calls the base __init__.", "As it happens, the MRO has exactly one item-- the base.", "So you're really doing the exact same thing, but in a nicer way with super() (particularly if you get into multiple inheritance later)."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "super()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "cls.__mro__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "super()", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}]]