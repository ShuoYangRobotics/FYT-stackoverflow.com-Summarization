[[{"text": ["Right now, you can do what I do, which is kludgy but works perfectly well* (this usage assumes you're using virtualenvwrapper -- which you should be -- but you can easily substitute in the rather longer 'source' call you mentioned, if not):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def task():\n    workon = 'workon myvenv &amp;&amp; '\n    run(workon + 'git pull')\n    run(workon + 'do other stuff, etc')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Since version 1.0, Fabric has a prefixcontext manager which uses this technique so you can for example:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "prefixcontext manager", "tag": "a", "pos": 0, "childList": [{"text": "prefix", "tag": "code"}], "childNum": 1, "href": "http://docs.fabfile.org/en/1.2.0/api/core/context_managers.html?highlight=prefix#fabric.context_managers.prefix"}, {"text": "prefix", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def task():\n    with prefix('workon myvenv'):\n        run('git pull')\n        run('do other stuff, etc')\n</code>\n</pre>\n", "senID": 3}, {"text": ["* There are bound to be cases where using the command1 &amp;&amp; command2 approach may blow up on you, such as when command1 fails (command2 will never run) or if command1 isn't properly escaped and contains special shell characters, and so forth."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "command1 &amp;&amp; command2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "command1", "childNum": 0, "tag": "code", "childList": []}, {"text": "command2", "childNum": 0, "tag": "code", "childList": []}, {"text": "command1", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["As an update to bitprophet's forecast: With Fabric 1.0 you can make use of prefix() and your own context managers."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import with_statement\nfrom fabric.api import *\nfrom contextlib import contextmanager as _contextmanager\n\nenv.hosts = ['servername']\nenv.user = 'deploy'\nenv.keyfile = ['$HOME/.ssh/deploy_rsa']\nenv.directory = '/path/to/virtualenvs/project'\nenv.activate = 'source /path/to/virtualenvs/project/bin/activate'\n\n@_contextmanager\ndef virtualenv():\n    with cd(env.directory):\n        with prefix(env.activate):\n            yield\n\ndef deploy():\n    with virtualenv():\n        run('pip freeze')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm just using a simple wrapper function virtualenv() that can be called instead of run().", "It doesn't use the cd context manager, so relative paths can be used."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def virtualenv(command):\n    \"\"\"\n    Run a command in the virtualenv. This prefixes the command with the source\n    command.\n    Usage:\n        virtualenv('pip install django')\n    \"\"\"\n    source = 'source %(project_directory)s/bin/activate &amp;&amp; ' % env\n    run(source + command)\n</code>\n</pre>\n", "senID": 1}]]