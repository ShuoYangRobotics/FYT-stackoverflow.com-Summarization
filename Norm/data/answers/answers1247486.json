[[{"text": ["map may be microscopically faster in some cases (when you're NOT making a lambda for the purpose, but using the same function in map and a listcomp).", "List comprehensions may be faster in other cases and most (not all) pythonistas consider them more direct and clearer."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["An example of the tiny speed advantage of map when using exactly the same function:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'xs=range(10)' 'map(hex, xs)'\n100000 loops, best of 3: 4.86 usec per loop\n$ python -mtimeit -s'xs=range(10)' '[hex(x) for x in xs]'\n100000 loops, best of 3: 5.58 usec per loop\n</code>\n</pre>\n", "senID": 2}, {"text": ["An example of how performance comparison gets completely reversed when map needs a lambda:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'xs=range(10)' 'map(lambda x: x+2, xs)'\n100000 loops, best of 3: 4.24 usec per loop\n$ python -mtimeit -s'xs=range(10)' '[x+2 for x in xs]'\n100000 loops, best of 3: 2.32 usec per loop\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I find list comprehensions are generally more expressive of what I'm trying to do than map - they both get it done, but the former saves the mental load of trying to understand what could be a complex lambda expression."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["There's also an interview out there somewhere (I can't find it offhand) where Guido lists lambdas and the functional functions as the thing he most regrets about accepting into Python, so you could make the argument that they're un-Pythonic by virtue of that."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Cases"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Cases", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": ["Common case"], "childNum": 0, "tag": "strong", "senID": 1, "childList": []}, {"text": ["Less-common case"], "childNum": 0, "tag": "strong", "senID": 2, "childList": []}, {"text": ["Almost never"], "childNum": 0, "tag": "strong", "senID": 3, "childList": []}]}, {"text": ["\"Pythonism\""], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "\"Pythonism\"", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I dislike the word \"pythonic\" because I don't find that pythonic is always elegant in my eyes.", "Nevertheless, map and filter and similar functions (like the very useful itertools module) are probably considered unpythonic in terms of style."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "filter", "childNum": 0, "tag": "code", "childList": []}, {"text": "itertools", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Laziness"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Laziness", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["In terms of efficiency, like most functional programming constructs, MAP IS LAZY.", "That means you can do this (in python3) and your computer will not run out of memory and lose all your unsaved data:"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "MAP IS LAZY", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "python3", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; map(str, range(10**100))\n&lt;map object at 0x2201d50&gt;\n</code>\n</pre>\n", "senID": 8}, {"text": ["Try doing that with a list comprehension:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [str(n) for n in range(10**100)]\n# DO NOT TRY THIS AT HOME OR YOU WILL BE SAD #\n</code>\n</pre>\n", "senID": 10}, {"text": ["Do note that list comprehensions are also inherently lazy, but python has chosen to implement them as non-lazy.", "Nevertheless, python does support lazy list comprehensions in the form of generator expressions, as follows:"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "python has chosen to implement them as non-lazy", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; (str(n) for n in range(10**100)\n&lt;generator object &lt;genexpr&gt; at 0xacbdef&gt;\n</code>\n</pre>\n", "senID": 12}, {"text": ["You can basically think of the [...] syntax as passing in a generator expression to the list constructor, like list(x for x in range(5))."], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "[...]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list(x for x in range(5))", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Efficiency comparison for python3"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "Efficiency comparison for python3", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["map is now lazy:"], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n % python3 -mtimeit -s 'xs=range(1000)' 'f=lambda x:x' 'z=map(f,xs)'\n1000000 loops, best of 3: 0.336 usec per loop            ^^^^^^^^^\n</code>\n</pre>\n", "senID": 16}, {"text": ["some very interesting results:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n % python3 -mtimeit -s 'xs=range(1000)' 'f=lambda x:x' 'z=list(map(f,xs))'                                                                                                                                                \n10000 loops, best of 3: 165 usec per loop                ^^^^^^^^^^^^^^^\n                    for list(&lt;map object&gt;)\n\n% python3 -mtimeit -s 'xs=range(1000)' 'f=lambda x:x' 'z=[f(x) for x in xs]'                                                                                                                                      \n10000 loops, best of 3: 181 usec per loop                ^^^^^^^^^^^^^^^^^^\n                    for list(&lt;generator&gt;), probably optimized\n\n% python3 -mtimeit -s 'xs=range(1000)' 'f=lambda x:x' 'z=list(f(x) for x in xs)'                                                                                                                                    \n1000 loops, best of 3: 215 usec per loop                 ^^^^^^^^^^^^^^^^^^^^^^\n                    for list(&lt;generator&gt;)\n</code>\n</pre>\n", "senID": 18}, {"text": ["This makes sense, because map probably doesn't need to create any intermediate dummy expression f(x).", "If you're skilled at reading python assembly, you can put the code in a function toDisassemble and do dis.dis(toDisassemble) to see if that's actually what's going on behind the scenes:"], "childNum": 4, "tag": "p", "senID": 19, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "f(x)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "toDisassemble", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "dis.dis(toDisassemble)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def listComp():\n...     return [f(x) for x in xs]\n... \n&gt;&gt;&gt; def mapObject():\n...     return list(map(f,xs))\n... \n&gt;&gt;&gt; def listComp2():\n...     return list(f(x) for x in xs)\n... \n&gt;&gt;&gt; dis(listComp)\n  2           0 LOAD_CONST               1 (&lt;code object &lt;listcomp&gt; at 0x185a830, file \"&lt;stdin&gt;\", line 2&gt;) \n              3 MAKE_FUNCTION            0 \n              6 LOAD_GLOBAL              0 (xs) \n              9 GET_ITER             \n             10 CALL_FUNCTION            1 \n             13 RETURN_VALUE         \n&gt;&gt;&gt; dis(mapObject)\n  2           0 LOAD_GLOBAL              0 (list) \n              3 LOAD_GLOBAL              1 (map) \n              6 LOAD_GLOBAL              2 (f) \n              9 LOAD_GLOBAL              3 (xs) \n             12 CALL_FUNCTION            2 \n             15 CALL_FUNCTION            1 \n             18 RETURN_VALUE         \n&gt;&gt;&gt; dis(listComp2)\n  2           0 LOAD_GLOBAL              0 (list) \n              3 LOAD_CONST               1 (&lt;code object &lt;genexpr&gt; at 0x188d330, file \"&lt;stdin&gt;\", line 2&gt;) \n              6 MAKE_FUNCTION            0 \n              9 LOAD_GLOBAL              1 (xs) \n             12 GET_ITER             \n             13 CALL_FUNCTION            1 \n             16 CALL_FUNCTION            1 \n             19 RETURN_VALUE\n</code>\n</pre>\n", "senID": 20}], [{"text": ["Another reason to use list comprehension over map() and filter() is that Psyco can't compile these functions. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["See http://psyco.sourceforge.net/psycoguide/node29.htm"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://psyco.sourceforge.net/psycoguide/node29.htm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://psyco.sourceforge.net/psycoguide/node29.htm"}]}], [{"text": ["Here is one possible case:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n map(lambda op1,op2: op1*op2, list1, list2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["versus:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [op1*op2 for op1,op2 in zip(list1,list2)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["I am guessing the zip() is an unfortunate and unnecessary overhead you need to indulge in if you insist on using list comprehensions instead of the map.", "Would be great if someone clarifies this whether affirmatively or negatively."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]