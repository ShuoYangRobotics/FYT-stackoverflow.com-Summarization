[[{"text": ["The above code should do the job, it is cross-platform and runs on Python 2.4-3.2.", "I tested it on Windows, OS X and Linux."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from tendo import singleton\nme = singleton.SingleInstance() # will sys.exit(-1) if other instance is running\n</code>\n</pre>\n", "senID": 1}, {"text": ["The latest code version is available singleton.py.", "Please file bugs here."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "singleton.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://github.com/ssbarnea/tendo/blob/master/tendo/singleton.py"}, {"text": "file bugs here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "https://github.com/ssbarnea/tendo/issues?"}]}, {"text": ["You can install tend using one of the following methods:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["easy_install tendo"], "childNum": 0, "tag": "code", "senID": 4, "childList": []}, {"text": ["pip install tendo"], "childNum": 0, "tag": "code", "senID": 5, "childList": []}, {"text": "manually by getting it from ", "tag": "none", "senID": 6}]}], [{"text": ["I don't know if it's pythonic enough, but in the Java world listening on a defined port is a pretty widely used solution, as it works on all major platforms and doesn't have any problems with crashing programs."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Another advantage of listening to a port is that you could send a command to the running instance.", "For example when the users starts the program a second time, you could send the running instance a command to tell it to open another window (that's what Firefox does, for example.", "I don't know if they use TCP ports or named pipes or something like that, 'though)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Use a pid file.", "You have some known location, \"/path/to/pidfile\" and at startup you do something like this (partially pseudocode because I'm pre-coffee and don't want to work all that hard):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os, os.path\npidfilePath = \"\"\"/path/to/pidfile\"\"\"\nif os.path.exists(pidfilePath):\n   pidfile = open(pidfilePath,\"r\")\n   pidString = pidfile.read()\n   if &lt;pidString is equal to os.getpid()&gt;:\n      # something is real weird\n      Sys.exit(BADCODE)\n   else:\n      &lt;use ps or pidof to see if the process with pid pidString is still running&gt;\n      if  &lt;process with pid == 'pidString' is still running&gt;:\n          Sys.exit(ALREADAYRUNNING)\n      else:\n          # the previous server must have crashed\n          &lt;log server had crashed&gt;\n          &lt;reopen pidfilePath for writing&gt;\n          pidfile.write(os.getpid())\nelse:\n    &lt;open pidfilePath for writing&gt;\n    pidfile.write(os.getpid())\n</code>\n</pre>\n", "senID": 1}, {"text": ["So, in other words, you're checking if a pidfile exists; if not, write your pid to that file.", "If the pidfile does exist, then check to see if the pid is the pid of a running process; if so, then you've got another live process running, so just shut down.", "If not, then the previous process crashed, so log it, and then write your own pid to the file in place of the old one.", "Then continue."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Simple, cross-platform solution, found in another question by zgoda:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "cross-platform", "childNum": 0, "tag": "s", "pos": 0, "childList": []}, {"text": "another question", "childNum": 1, "tag": "b", "childList": [{"text": "another question", "tag": "a"}]}, {"href": "http://stackoverflow.com/questions/220525/ensuring-a-single-instance-of-an-application-in-linux#221159", "text": "another question", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://stackoverflow.com/users/12138/zgoda", "text": "zgoda", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n import fcntl, sys\npid_file = 'program.pid'\nfp = open(pid_file, 'w')\ntry:\n    fcntl.lockf(fp, fcntl.LOCK_EX | fcntl.LOCK_NB)\nexcept IOError:\n    # another instance is running\n    sys.exit(0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Alot like S.Lott's suggestion, but with the code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You already found reply to similar question in another thread, so for completeness sake see how to achieve the same on Windows uning named mutex."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://code.activestate.com/recipes/474070/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://code.activestate.com/recipes/474070/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/474070/"}]}], [{"text": ["This may work."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can wrap your program in a shell script that removes the PID file even if your program crashes."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can, also, use the PID file to kill the program if it hangs."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I've been wondering how to achieve just this, thanks to this question I've now.", "Couldn't get any simpler."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    import socket\n    s = socket.socket()\n    host = socket.gethostname()\n    port = 35636    #make sure this port is not used on this system\n    s.bind((host, port))\n    my_singlerun_function()\nexcept:\n    pass\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using a lock-file is a quite common approach on unix.", "If it crashes, you have to clean up manually.", "You could stor the PID in the file, and on startup check if there is a process with this PID, overriding the lock-file if not.", "(However, you also need a lock around the read-file-check-pid-rewrite-file).", "You will find what you need for getting and checking pid in the os-package.", "The common way of checking if there exists a process with a given pid, is to send it a non-fatal signal."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "os", "tag": "a", "pos": 4, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/os.html"}]}, {"text": ["Other alternatives could be combining this with flock or posix semaphores."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Opening a network socket, as saua proposed, would probably be the easiest and most portable."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I'm posting this as an answer because I'm a new user and Stack Overflow won't let me vote yet."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Sorin Sbarnea's solution works for me under OS X, Linux and Windows, and I am grateful for it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["However, tempfile.gettempdir() behaves one way under OS X and Windows and another under other some/many/all(?", ") *nixes (ignoring the fact that OS X is also Unix!).", "The difference is important to this code. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["OS X and Windows have user-specific temp directories, so a tempfile created by one user isn't visible to another user.", "By contrast, under many versions of *nix (I tested Ubuntu 9, RHEL 5, OpenSolaris 2008 and FreeBSD 8), the temp dir is /tmp for all users."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["That means that when the lockfile is created on a multi-user machine, it's created in /tmp and only the user who creates the lockfile the first time will be able to run the application."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["A possible solution is to embed the current username in the name of the lock file."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["It's worth noting that the OP's solution of grabbing a port will also misbehave on a multi-user machine."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Never written python before, but this is what I've just implemented in mycheckpoint, to prevent it being started twice or more by crond:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\nimport sys\nimport fcntl\nfh=0\ndef run_once():\n    global fh\n    fh=open(os.path.realpath(__file__),'r')\n    try:\n        fcntl.flock(fh,fcntl.LOCK_EX|fcntl.LOCK_NB)\n    except:\n        os._exit(0)\n\nrun_once()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Found Slava-N's suggestion after posting this in another issue (http://stackoverflow.com/questions/2959474).", "This one is called as a function, locks the executing scripts file (not a pid file) and maintains the lock until the script ends (normal or error)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]