[[{"text": ["A much neater way to get 'alternate constructors' is to use classmethods.", "For instance:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class MyData:\n...     def __init__(self, data):\n...         \"Initialize MyData from a sequence\"\n...         self.data = data\n...     \n...     @classmethod\n...     def fromfilename(cls, filename):\n...         \"Initialize MyData from a file\"\n...         data = open(filename).readlines()\n...         return cls(data)\n...     \n...     @classmethod\n...     def fromdict(cls, datadict):\n...         \"Initialize MyData from a dict's items\"\n...         return cls(datadict.items())\n... \n&gt;&gt;&gt; MyData([1, 2, 3]).data\n[1, 2, 3]\n&gt;&gt;&gt; MyData.fromfilename(\"/tmp/foobar\").data\n['foo\\n', 'bar\\n', 'baz\\n']\n&gt;&gt;&gt; MyData.fromdict({\"spam\": \"ham\"}).data\n[('spam', 'ham')]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The reason it's neater is that there is no doubt about what type is expected, and you aren't forced to guess at what the caller intended for you to do with the datatype it gave you.", "The problem with isinstance(x, basestring) is that there is no way for the caller to tell you, for instance, that even though the type is not a basestring, you should treat it as a string (and not another sequence.", ") And perhaps the caller would like to use the same type for different purposes, sometimes as a single item, and sometimes as a sequence of items.", "Being explicit takes all doubt away and leads to more robust and clearer code."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "isinstance(x, basestring)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Excellent question.", "I've tackled this problem as well, and while I agree that \"factories\" (class-method constructors) are a good method, I would like to suggest another, which I've also found very useful:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's a sample (this is a read method and not a constructor, but the idea is the same):"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "read", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def read(self, str=None, filename=None, addr=0):\n    \"\"\" Read binary data and return a store object. The data\n        store is also saved in the interal 'data' attribute.\n\n        The data can either be taken from a string (str \n        argument) or a file (provide a filename, which will \n        be read in binary mode). If both are provided, the str \n        will be used. If neither is provided, an ArgumentError \n        is raised.\n    \"\"\"\n    if str is None:\n        if filename is None:\n            raise ArgumentError('Please supply a string or a filename')\n\n        file = open(filename, 'rb')\n        str = file.read()\n        file.close()\n    ...\n    ... # rest of code\n</code>\n</pre>\n", "senID": 2}, {"text": ["The key idea is here is using Python's excellent support for named arguments to implement this.", "Now, if I want to read the data from a file, I say:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n obj.read(filename=\"blob.txt\")\n</code>\n</pre>\n", "senID": 4}, {"text": ["And to read it from a string, I say:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n obj.read(str=\"\\x34\\x55\")\n</code>\n</pre>\n", "senID": 6}, {"text": ["This way the user has just a single method to call.", "Handling it inside, as you saw, is not overly complex"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Use backticks to escape double underscores: __class__."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__class__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["A better way would be to use isinstance and type conversion.", "If I'm understanding you right, you want this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def __init__ (self, filename):\n    if isinstance (filename, basestring):\n        # filename is a string\n    else:\n        # try to convert to a list\n        self.path = list (filename)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You should use isinstance"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n isinstance(...)\n    isinstance(object, class-or-type-or-tuple) -&gt; bool\n\n    Return whether an object is an instance of a class or of a subclass thereof.\n    With a type as second argument, return whether that is the object's type.\n    The form using a tuple, isinstance(x, (A, B, ...)), is a shortcut for\n    isinstance(x, A) or isinstance(x, B) or ... (etc.).\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You probably want the isinstance builtin function:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "isinstance", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n self.data = data if isinstance(data, list) else self.parse(data)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["OK, great.", "I just tossed together this example with a tuple, not a filename, but that's easy.", "Thanks all."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MyData:\n    def __init__(self, data):\n        self.myList = []\n        if isinstance(data, tuple):\n            for i in data:\n                self.myList.append(i)\n        else:\n            self.myList = data\n\n    def GetData(self):\n        print self.myList\n</code>\n</pre>\n", "senID": 1}, {"text": ["a = [1,2]"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["b = (2,3)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["c = MyData(a)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["d = MyData(b)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["c.GetData()"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["d.GetData()"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["[1, 2]"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["[2, 3]"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}]]