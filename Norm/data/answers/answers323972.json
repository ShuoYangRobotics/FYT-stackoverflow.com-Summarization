[[{"text": ["It is generally a bad pattern to kill a thread abruptly, in python and in any language.", "Think of the following cases:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "the thread is holding a critical resource that must be closed properly", "tag": "none", "senID": 1}, {"text": "the thread has created several other threads that must be killed as well.", "tag": "none", "senID": 2}]}, {"text": ["The nice way of handling this if you can afford it (if you are managing your own threads) is to have an exit_request flag that each threads checks on regular interval to see if it is time for him to exit."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["For example:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "For example:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class StoppableThread(threading.Thread):\n    \"\"\"Thread class with a stop() method. The thread itself has to check\n    regularly for the stopped() condition.\"\"\"\n\n    def __init__(self):\n        super(StoppableThread, self).__init__()\n        self._stop = threading.Event()\n\n    def stop(self):\n        self._stop.set()\n\n    def stopped(self):\n        return self._stop.isSet()\n</code>\n</pre>\n", "senID": 5}, {"text": ["In this code, you should call stop() on the thread when you want it to exit, and wait for the thread to exit properly using join().", "The thread should check the stop flag at regular intervals."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["They are cases however when you really need to kill a thread, for example when you are wrapping an external library that is busy for long calls and you want to interrupt it."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["The following code allows (with some restrictions) to raise an Exception in a python thread:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def _async_raise(tid, exctype):\n    '''Raises an exception in the threads with id tid'''\n    if not inspect.isclass(exctype):\n        raise TypeError(\"Only types can be raised (not instances)\")\n    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid,\n                                                  ctypes.py_object(exctype))\n    if res == 0:\n        raise ValueError(\"invalid thread id\")\n    elif res != 1:\n        # \"if it returns a number greater than one, you're in trouble,\n        # and you should call it again with exc=NULL to revert the effect\"\n        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, 0)\n        raise SystemError(\"PyThreadState_SetAsyncExc failed\")\n\nclass ThreadWithExc(threading.Thread):\n    '''A thread class that supports raising exception in the thread from\n       another thread.\n    '''\n    def _get_my_tid(self):\n        \"\"\"determines this (self's) thread id\n\n        CAREFUL : this function is executed in the context of the caller\n        thread, to get the identity of the thread represented by this\n        instance.\n        \"\"\"\n        if not self.isAlive():\n            raise threading.ThreadError(\"the thread is not active\")\n\n        # do we have it cached?\n        if hasattr(self, \"_thread_id\"):\n            return self._thread_id\n\n        # no, look for it in the _active dict\n        for tid, tobj in threading._active.items():\n            if tobj is self:\n                self._thread_id = tid\n                return tid\n\n        # TODO: in python 2.6, there's a simpler way to do : self.ident\n\n        raise AssertionError(\"could not determine the thread's id\")\n\n    def raiseExc(self, exctype):\n        \"\"\"Raises the given exception type in the context of this thread.\n\n        If the thread is busy in a system call (time.sleep(),\n        socket.accept(), ...), the exception is simply ignored.\n\n        If you are sure that your exception should terminate the thread,\n        one way to ensure that it works is:\n\n            t = ThreadWithExc( ... )\n            ...\n            t.raiseExc( SomeException )\n            while t.isAlive():\n                time.sleep( 0.1 )\n                t.raiseExc( SomeException )\n\n        If the exception is to be caught by the thread, you need a way to\n        check that your thread has caught it.\n\n        CAREFUL : this function is executed in the context of the\n        caller thread, to raise an excpetion in the context of the\n        thread represented by this instance.\n        \"\"\"\n        _async_raise( self._get_my_tid(), exctype )\n</code>\n</pre>\n", "senID": 9}, {"text": ["As noted in the documentation, this is not a magic bullet because if the thread is busy outside the python interpreter, it will not catch the interruption."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["A good usage pattern of this code is to have the thread catch a specific exception and perform the cleanup.", "That way, you can interrupt a task and still have proper cleanup."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["There is no official API to do that, no."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You need to use platform API to kill the thread, e.g.", "pthread_kill, or TerminateThread.", "You can access such API e.g.", "through pythonwin, or through ctypes."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Notice that this is inherently unsafe.", "It will likely lead to uncollectable garbage (from local variables of the stack frames that become garbage), and may lead to deadlocks, if the thread being killed has the GIL at the point when it is killed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you are trying to terminate the whole program you can set the thread as a \"daemon\".", "see\nThread.daemon"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Thread.daemon", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/threading.html#threading.Thread.daemon"}]}], [{"text": ["You should never forcibly kill a thread without cooperating with it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Killing a thread removes any guarantees that try/finally blocks set up so you might leave locks locked, files open, etc."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The only time you can argue that forcibly killing threads is a good idea is to kill a program fast, but never single threads."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["For those who end up here when googling how to stop a Python thread."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from threading import *\n\n...\n\nfor thread in enumerate():\n    if thread.isAlive():\n        try:\n            thread._Thread__stop()\n        except:\n            print(str(thread.getName()) + ' could not be terminated'))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Give it a few seconds then your thread should be stoped, also check the thread.Thread_delete()"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Thread", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I'd reccomend a thread.quit() function for your own convencience, say you have a socket in your thread, i'd reccomend creating a quit() function in your socket-handle class and terminate the socket then run a thread.Thread_stop() inside of your quit()."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Thread", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["It is better if you don't kill a thread.", "A way could be to introduce a \"try\" block into the thread's cycle and to throw an exception when you want to stop the thread (for example a break/return/... that stops your for/while/...).", "I've used this on my app and it works..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can kill a thread by installing trace into the thread that will exit the thread.", "See attached link for one possible implementation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Kill a thread in Python "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Kill a thread in Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-list/2004-May/896157.html"}]}]]