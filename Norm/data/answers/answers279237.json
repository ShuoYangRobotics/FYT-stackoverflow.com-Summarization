[[{"text": ["Be sure that dirBar has the __init__.py file -- this makes a directory into a Python package."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__init__.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You could also add the sub directory to your python path so that it imports as a normal script."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\nsys.path.append( &lt;path to dirFoo&gt; )\nimport Bar\n</code>\n</pre>\n", "senID": 1}], [{"text": ["(This is from memory so someone edit if I make a typo, please."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you structure your project this way:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n src\\\n  __init__.py\n  main.py\n  dirFoo\\\n    __init__.py\n    Foo.py\n  dirBar\\\n    __init__.py\n    Bar.py\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then from Foo.py you should be able to do:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import dirFoo.Foo\n</code>\n</pre>\n", "senID": 4}, {"text": ["Or:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from dirFoo.Foo import FooObject\n</code>\n</pre>\n", "senID": 6}, {"text": ["EDIT 1:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "EDIT 1:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Per Tom's comment, this does require that the src folder is accessible either via site_packages or your search path.", "Also, as he mentions, __init__.py is implicitly imported when you first import a module in that package/directory.", "Typically __init__.py is simply an empty file."], "childNum": 4, "tag": "p", "senID": 8, "childList": [{"text": "src", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "site_packages", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__init__.py", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__init__.py", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["The easiest method is to use sys.path.append()."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, you may be also interested in the imp module.", "It provides access to internal import functions."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "imp", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/imp.html?highlight=imp#module-imp"}]}, {"code": "<pre>\n<code>\n # mod_name is the filename without the .py/.pyc extention\npy_mod = imp.load_source(mod_name,filename_path) # Loads .py file\npy_mod = imp.load_compiled(mod_name,filename_path) # Loads .pyc file\n</code>\n</pre>\n", "senID": 2}, {"text": ["This can be used to load modules dynamically when you don't know a module's name."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I've used this in the past to create a plugin type interface to an application, where the user would write a script with application specific functions, and just drop thier script in a specific directory."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Also, these functions may be useful:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n imp.find_module(name[, path])\nimp.load_module(name, file, pathname, description)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Assuming that both your directories are real python modules (do have the __init__.py file inside them), here is a safe solution for inclusion of modules relatively to the location of the script."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__init__.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I assume that you want to do this because you need to include a set of modules with your script.", "I use this in production in several products and works in many special scenarios like: scripts called from another directory or executed with python execute instead of opening a new interpreter."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import os, sys\n cmd_folder = os.path.dirname(os.path.abspath(__file__))\n if cmd_folder not in sys.path:\n     sys.path.insert(0, cmd_folder)\n</code>\n</pre>\n", "senID": 2}, {"text": ["As a bonus, this approach does let you force Python to use your module instead of the ones installed on the system. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This is the relevant PEP:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.python.org/dev/peps/pep-0328/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.python.org/dev/peps/pep-0328/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0328/"}]}, {"text": ["In particular, presuming dirFoo is a directory up from dirBar..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In dirFoo\\Foo.py:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from ..dirBar import Bar\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Add an _init_.py file:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "_init_.py", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "init", "tag": "em"}]}, {"text": "init", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n dirFoo\\\n    Foo.py\n    dirBar\\\n        __init__.py\n        Bar.py\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then add this code to the start of Foo.py:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import sys\nsys.path.append('dirBar')\nimport Bar\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Why don't do ?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os, sys\nlib_path = os.path.abspath('../../../lib')\nsys.path.append(lib_path)\n\nimport mymodule\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Just do Simple Things to import py file from different folder-"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Let's you have a directory like-"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n lib/abc.py\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then just keep a empty file in lib folder as named "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n __init__.py\n</code>\n</pre>\n", "senID": 4}, {"text": ["and then use "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from lib.abc import &lt;Your Module name&gt;\n</code>\n</pre>\n", "senID": 6}, {"text": ["Keep __init__.py file in every folder of hierarchy of import module"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "__init__.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["In my opinion the best choice is to put __ init __.py in the folder and call the file with"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__ init __.py", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from dirBar.Bar import *\n</code>\n</pre>\n", "senID": 1}, {"text": ["It is not recommended to use sys.path.append() because something might gone wrong if you use the same file name as the existing python package.", "I haven't test that but that will be ambiguous."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Look at the pkgutil module from the standard library.", "It may help you do what you want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n from .dirBar import Bar\n</code>\n</pre>\n", "senID": 0}, {"text": ["instead of:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from dirBar improt Bar\n</code>\n</pre>\n", "senID": 2}, {"text": ["just in case there could be another dirBar installed and confuse a foo.py reader."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Call me overly cautious but I like to make mine more portable because it's unsafe to assume that files will always be in the same place on every computer.", "Personally I have the code look up the file path first.", "I use linux so mine would look like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os, sys\nfrom subprocess import Popen, PIPE\ntry:\n    path = Popen(\"find / -name 'file' -type f\", shell=True, stdout=PIPE).stdout.read().splitlines()[0]\n    if not sys.path.__contains__(path):\n        sys.path.append(path)\nexcept IndexError:\n    raise RuntimeError(\"You must have FILE to run this program!\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["That is of course unless you plan to package these together.", "But if that's the case you don't really need two separate files anyway."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I had a similar problem and I found this and it works!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["apt-get install python-profiler"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]