[[{"text": ["The syntax is the*and**.", "The names *args and **kwargs are only by convention but there's no need not to use them."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "The syntax is the*and**", "tag": "a", "pos": 0, "childList": [{"text": "*", "tag": "code"}, {"text": "**", "tag": "code"}], "childNum": 2, "href": "http://docs.python.org/tutorial/controlflow.html#arbitrary-argument-lists"}, {"text": "*", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "**", "childNum": 0, "tag": "code", "childList": []}, {"text": "*args", "childNum": 0, "tag": "code", "childList": []}, {"text": "**kwargs", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You would use *args when you're not sure how many arguments might be passed to your function, i.e.", "it allows you pass an arbitrary number of arguments to your function.", "For example:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "*args", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def print_everything(*args):\n...     count = 1\n...     for thing in args:\n...         print \"%d. %s\" % (count,thing)\n...         count += 1\n...\n&gt;&gt;&gt; print_everything('apple', 'banana', 'cabbage')\n1. apple\n2. banana\n3. cabbage\n</code>\n</pre>\n", "senID": 2}, {"text": ["Similarly, **kwargs allows you to handle named arguments that you have not defined in advance:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "**kwargs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def table_things(**kwargs):\n...     for name,value in kwargs.items():\n...         print name, \"=\", value\n...\n&gt;&gt;&gt; table_things(apple = 'fruit', cabbage = 'vegetable')\ncabbage = vegetable\napple = fruit\n</code>\n</pre>\n", "senID": 4}, {"text": ["You can use these along with named arguments too.", "The explicit arguments get values first and then everything else is passed to *args and *kwargs.", "The named arguments come first in the list.", "For example:"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "*args", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "*kwargs", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def table_things(titlestring, **kwargs)\n</code>\n</pre>\n", "senID": 6}, {"text": ["You can also use both in the same function definition but *args must occur before **kwargs."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "*args", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "**kwargs", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You can also use the * and ** syntax when calling a function.", "For example:"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "*", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "**", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def print_three_things(a, b, c):\n...     print \"a =\", a, \"&amp; b =\", b, \"&amp; c =\", c\n...\n&gt;&gt;&gt; mylist = ['aardvark', 'baboon', 'cat']\n&gt;&gt;&gt; print_three_things(*mylist)\na = aardvark &amp; b = baboon &amp; c = cat\n</code>\n</pre>\n", "senID": 9}, {"text": ["As you can see in this case it takes the list (or tuple) of items and matches them to the arguments in the function.", "Of course, you could have a * both in the function definition and in the function call."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "*", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["One place where the use of *args and **kwargs is quite useful is for subclassing."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "*args", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "**kwargs", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class Foo(object):\n    def __init__(self, value1, value2):\n        # do something with the values\n        print value1, value2\n\nclass MyFoo(Foo):\n    def __init__(self, *args, **kwargs):\n        # do something else, don't care about the args\n        print 'myfoo'\n        super(MyFoo, self).__init__(*args, **kwargs)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This way you can extend the behaviour of the Foo class, without having to know too much about Foo.", "This can be quite convenient if you are programming to an API which might change.", "MyFoo just passes all arguments to the Foo class."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["One case where *args and **kwargs are useful is when writing wrapper functions (such as decorators) that need to be able accept arbitrary arguments to pass through to the function being wrapped.", "For example, a simple decorator that prints the arguments and return value of the function being wrapped:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def mydecorator( f ):\n   @functools.wraps( f )\n   def wrapper( *args, **kwargs ):\n      print \"Calling f\", args, kwargs\n      v = f( *args, **kwargs )\n      print \"f returned\", v\n      return v\n   return wrapper\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's one of my favorite places to use the ** syntax as in Dave Webb's final example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "**", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n mynum = 1000\nmystr = 'Hello World!'\nprint \"{mystr} New-style formatting is {mynum}x more fun!\".format(**locals())\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm not sure if it's terribly fast when compared to just using the names themselves, but it's a lot easier to type!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Try this, save this as example.py"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "example.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def any_function(required_arg, *args, **kwargs):\n    print required_arg\n\n    # args will be a list of positional arguments\n    # because it has * before it\n    if args: # If there is anything in args\n        print args\n\n    # kwargs will be a dictionary of keyword arguments,\n    # because it has ** before it\n    if kwargs: # If there is anything in kwargs\n        print kwargs\n\nany_function(\"Required Argument.\")\nany_function(\"Required Argument\", 1, 2, \"pos3\")\nany_function(\"Required Argument\", 1, 2, \"pos3\", keyword1=5, keyword2=\"spam\")\n</code>\n</pre>\n", "senID": 1}], [{"text": ["*args and **kwargs are special-magic features of Python.", "Think of a function that could have an unknown number of arguments.", "For example, for whatever reasons, you want to have function that sums an unknown number of numbers (and you don't want to use the built-in sum function).", "So you write this function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def sumFunction(*args):\n  result = 0\n  for x in args:\n    result += x\n  return result\n</code>\n</pre>\n", "senID": 1}, {"text": ["and use it like: sumFunction(3,4,6,3,6,8,9)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["**kwargs has a diffrent function.", "With **kwargs you can give arbitrary keyword arguments to a function and you can access them as a dictonary."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def someFunction(**kwargs):\n  if 'text' in kwargs:\n    print kwargs['text']\n</code>\n</pre>\n", "senID": 4}, {"text": ["Calling someFunction(text=\"foo\") will print foo."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["You can have a look at python docs (docs.python.org in the FAQ), but more specifically for a good explanation the mysterious miss args and mister kwargs."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "the mysterious miss args and mister kwargs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypatterns.net/post/2009/10/the-mysterious-miss-args-and-mister-kwargs"}]}, {"text": ["In a nutshell, both are used when optional parameters to a function or method are used.", "As Dave says, *args is used when you don't know how many arguments may be passed, and **kwargs when you want to handle parameters specified by name and value as in:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n myfunction(myarg=1)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["These parameters are typically used for proxy functions, so the proxy can pass any input parameter to the target function."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo(bar=2, baz=5):\n    print bar, baz\n\ndef proxy(x, *args, **kwargs): # reqire parameter x and accept any number of additional arguments\n    print x\n    foo(*args, **kwargs) # applies the \"non-x\" parameter to foo\n\nproxy(23, 5, baz='foo') # calls foo with bar=5 and baz=foo\nproxy(6)# calls foo with its default arguments\nproxy(7, bar='asdas') # calls foo with bar='asdas' and leave baz default argument\n</code>\n</pre>\n", "senID": 1}, {"text": ["But since these parameters hide the actual parameter names, it is better to avoid them."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Note that *args/**kwargs is part of function-calling syntax, and not really an operator.", "This has a particular side effect that I ran into, which is that you can't use *args expansion with the print statement, since print is not a function."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This seems reasonable:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def myprint(*args):\n    print *args\n</code>\n</pre>\n", "senID": 2}, {"text": ["Unfortunately it doesn't compile (syntax error)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["This compiles:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def myprint(*args):\n    print args\n</code>\n</pre>\n", "senID": 5}, {"text": ["But prints the arguments as a tuple, which isn't what we want."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["This is the solution I settled on:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def myprint(*args):\n    for arg in args:\n        print arg,\n    print\n</code>\n</pre>\n", "senID": 8}], [{"text": ["The names *args and **kwargs or **kw are purely by convention.", "It makes it easier for us to read each other's code"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "*args", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "**kwargs", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "**kw", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["One place it is handy is when using the struct module"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["struct.unpack() returns a tuple whereas struct.pack() uses a variable number of arguments.", "When manipulating data it is convenient to be able to pass a tuple to struck.pack() eg."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "struct.unpack()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "struct.pack()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "struck.pack()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n tuple_of_data = struct.unpack(format_str, data)\n... manipulate the data\nnew_data = struct.pack(format_str, *tuple_of_data)\n</code>\n</pre>\n", "senID": 3}, {"text": ["without this ability you would be forced to write"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n new_data = struct.pack(format_str, tuple_of_data[0], tuple_of_data[1], tuple_of_data[2],...)\n</code>\n</pre>\n", "senID": 5}, {"text": ["which also means the if the format_str changes and the size of the tuple changes, I'll have to go back and edit that really long line"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Just imagine you have a function but you don't want to restrict the number of parameter it takes.", "Example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import operator\n&gt;&gt;&gt; def multiply(*args):\n...  return reduce(operator.mul, args)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you use this function like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; multiply(1,2,3)\n6\n\nor\n\n&gt;&gt;&gt; numbers = [1,2,3]\n&gt;&gt;&gt; multiply(*numbers)\n6\n</code>\n</pre>\n", "senID": 3}]]