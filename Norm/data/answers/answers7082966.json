[[{"text": ["I would return None.", "If there is no result, why return something that looks like a result?"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "looks", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["It is also easier to test:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n result = getCity()\nif result:\n   # do something\n</code>\n</pre>\n", "senID": 2}, {"text": ["I would only return (None, None) if it were possible that only one of the two values is None (i.e.", "('Boston', None)).", "It would be more consistent in this case."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "(None, None)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "('Boston', None)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["By only returning one value in exceptional circumstances, you risk breaking the tuple unpacking idiom.", "Some of your callers might do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n city, state = getCityStateTuple(\"something\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["In that case, returning None will break the caller with the error:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["TypeError: 'NoneType' object is not iterable"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "TypeError: 'NoneType' object is not iterable", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So, I'd personally return (None, None) in your situation.", "Then again, your mileage may vary, and it depends on the patterns used by your callers."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "(None, None)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["(None, None) does not evaluate to False in Python.", "In addition, building a tuple requires more work than, well, not building a tuple.", "So I would prefer None."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "(None, None)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["As others have noted, a tuple with items in it does not test as False, which is one reason you might want to return None rather than (None, None).", "However, it is possible to write a tuple subclass that tests as False even when it has items in it by overriding its __nonzero__() method."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "False", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "(None, None)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "subclass", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "childList": []}, {"text": "__nonzero__()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class falsetuple(tuple):\n    def __nonzero__(self):\n        return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you could return falsetuple((None, None)) when there is no value available.", "In fact, you could always return the same falsetuple."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "falsetuple((None, None))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "same", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "falsetuple", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I'm not necessarily recommending that you do this, in fact I have serious misgivings about flouting this convention, I'm just saying that the truthiness of non-empty tuples is not necessarily in itself a reason to not return a tuple."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If your routine normally returns a tuple, then a tuple is what it should keep returning.", "The real choice is between returning (None, None), or raising an exception, and we don't have enough information to offer good advice on that."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "(None, None)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If it were me, and I chose the tuple over the exception, I would also go with the False_Tuple that kindall suggests -- that way you are supporting tuple extraction across all possible return values, and still allowing the pythonic idiom of asking the object, \"Do you evaluate as True?", "\"  (Here it is again for completeness):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class False_Tuple(tuple):\n    def __nonzero__(self):\n        return False\n</code>\n</pre>\n", "senID": 2}], [{"text": ["why not making State a property of City?", "That way your function would return always one value: a City or None."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Returning (None, None) is bad for all the reasons stated in the other answers and serves only to support tuple unpacking."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["None is the best value to return to state that no valid city can be returned, but having a function returning 1 or 2 values is not that good, again because of tuple unpacking."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["To me, returning (None, None) would imply that (None, State) or (City, None) would also be valid return values.", "If that is the case, go with (None, None), otherwise, Felix and Brent provide very good arguments for simply returning None."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I would implement a public method for object that returned, let say isValidLocation() that returns true if location is valid and false if location is none."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "isValidLocation()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If you return None, it will be much easier for you to check the return value."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]