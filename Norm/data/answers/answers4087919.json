[[{"text": ["If you're just wanting (semi) contiguous regions, there's already an easy implementation in Python: SciPy's ndimage.morphology module.", "This is a fairly common image morphology operation. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "SciPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/SciPy"}, {"text": "ndimage.morphology", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.scipy.org/doc/api_docs/SciPy.ndimage.morphology.html"}, {"text": "image morphology", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Mathematical_morphology"}]}, {"text": ["Basically, you have 5 steps:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def find_paws(data, smooth_radius=5, threshold=0.0001):\n    data = sp.ndimage.uniform_filter(data, smooth_radius)\n    thresh = data &gt; threshold\n    filled = sp.ndimage.morphology.binary_fill_holes(thresh)\n    coded_paws, num_paws = sp.ndimage.label(filled)\n    data_slices = sp.ndimage.find_objects(coded_paws)\n    return object_slices\n</code>\n</pre>\n", "senID": 2}, {"text": ["The two animations below show your \"Overlapping Paws\" and \"Grouped Paws\" example data.", "This method seems to be working perfectly.", "(And for whatever it's worth, this runs much more smoothly than the GIF images below on my machine, so the paw detection algorithm is fairly fast...)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"senID": 4}, {"text": ["Here's a full example (now with much more detailed explanations).", "The vast majority of this is reading the input and making an animation.", "The actual paw detection is only 5 lines of code."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import numpy as np\nimport scipy as sp\nimport scipy.ndimage\n\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\n\ndef animate(input_filename):\n    \"\"\"Detects paws and animates the position and raw data of each frame\n    in the input file\"\"\"\n    # With matplotlib, it's much, much faster to just update the properties\n    # of a display object than it is to create a new one, so we'll just update\n    # the data and position of the same objects throughout this animation...\n\n    infile = paw_file(input_filename)\n\n    # Since we're making an animation with matplotlib, we need \n    # ion() instead of show()...\n    plt.ion()\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    fig.suptitle(input_filename)\n\n    # Make an image based on the first frame that we'll update later\n    # (The first frame is never actually displayed)\n    im = ax.imshow(infile.next()[1])\n\n    # Make 4 rectangles that we can later move to the position of each paw\n    rects = [Rectangle((0,0), 1,1, fc='none', ec='red') for i in range(4)]\n    [ax.add_patch(rect) for rect in rects]\n\n    title = ax.set_title('Time 0.0 ms')\n\n    # Process and display each frame\n    for time, frame in infile:\n        paw_slices = find_paws(frame)\n\n        # Hide any rectangles that might be visible\n        [rect.set_visible(False) for rect in rects]\n\n        # Set the position and size of a rectangle for each paw and display it\n        for slice, rect in zip(paw_slices, rects):\n            dy, dx = slice\n            rect.set_xy((dx.start, dy.start))\n            rect.set_width(dx.stop - dx.start + 1)\n            rect.set_height(dy.stop - dy.start + 1)\n            rect.set_visible(True)\n\n        # Update the image data and title of the plot\n        title.set_text('Time %0.2f ms' % time)\n        im.set_data(frame)\n        im.set_clim([frame.min(), frame.max()])\n        fig.canvas.draw()\n\ndef find_paws(data, smooth_radius=5, threshold=0.0001):\n    \"\"\"Detects and isolates contiguous regions in the input array\"\"\"\n    # Blur the input data a bit so the paws have a continous footprint \n    data = sp.ndimage.uniform_filter(data, smooth_radius)\n    # Threshold the blurred data (this needs to be a bit &gt; 0 due to the blur)\n    thresh = data &gt; threshold\n    # Fill any interior holes in the paws to get cleaner regions...\n    filled = sp.ndimage.morphology.binary_fill_holes(thresh)\n    # Label each contiguous paw\n    coded_paws, num_paws = sp.ndimage.label(filled)\n    # Isolate the extent of each paw\n    data_slices = sp.ndimage.find_objects(coded_paws)\n    return data_slices\n\ndef paw_file(filename):\n    \"\"\"Returns a iterator that yields the time and data in each frame\n    The infile is an ascii file of timesteps formatted similar to this:\n\n    Frame 0 (0.00 ms)\n    0.0 0.0 0.0\n    0.0 0.0 0.0\n\n    Frame 1 (0.53 ms)\n    0.0 0.0 0.0\n    0.0 0.0 0.0\n    ...\n    \"\"\"\n    with open(filename) as infile:\n        while True:\n            try:\n                time, data = read_frame(infile)\n                yield time, data\n            except StopIteration:\n                break\n\ndef read_frame(infile):\n    \"\"\"Reads a frame from the infile.\"\"\"\n    frame_header = infile.next().strip().split()\n    time = float(frame_header[-2][1:])\n    data = []\n    while True:\n        line = infile.next().strip().split()\n        if line == []:\n            break\n        data.append(line)\n    return time, np.array(data, dtype=np.float)\n\nif __name__ == '__main__':\n    animate('Overlapping paws.bin')\n    animate('Grouped up paws.bin')\n    animate('Normal measurement.bin')\n</code>\n</pre>\n", "senID": 6}, {"text": ["Update: As far as identifying which paw is in contact with the sensor at what times, the simplest solution is to just do the same analysis, but use all of the data at once.", "(i.e.", "stack the input into a 3D array, and work with it, instead of the individual time frames.", ")  Because SciPy's ndimage functions are meant to work with n-dimensional arrays, we don't have to modify the original paw-finding function at all."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # This uses functions (and imports) in the previous code example!!\ndef paw_regions(infile):\n    # Read in and stack all data together into a 3D array\n    data, time = [], []\n    for t, frame in paw_file(infile):\n        time.append(t)\n        data.append(frame)\n    data = np.dstack(data)\n    time = np.asarray(time)\n\n    # Find and label the paw impacts\n    data_slices, coded_paws = find_paws(data, smooth_radius=4)\n\n    # Sort by time of initial paw impact... This way we can determine which\n    # paws are which relative to the first paw with a simple modulo 4.\n    # (Assuming a 4-legged dog, where all 4 paws contacted the sensor)\n    data_slices.sort(key=lambda dat_slice: dat_slice[2].start)\n\n    # Plot up a simple analysis\n    fig = plt.figure()\n    ax1 = fig.add_subplot(2,1,1)\n    annotate_paw_prints(time, data, data_slices, ax=ax1)\n    ax2 = fig.add_subplot(2,1,2)\n    plot_paw_impacts(time, data_slices, ax=ax2)\n    fig.suptitle(infile)\n\ndef plot_paw_impacts(time, data_slices, ax=None):\n    if ax is None:\n        ax = plt.gca()\n\n    # Group impacts by paw...\n    for i, dat_slice in enumerate(data_slices):\n        dx, dy, dt = dat_slice\n        paw = i%4 + 1\n        # Draw a bar over the time interval where each paw is in contact\n        ax.barh(bottom=paw, width=time[dt].ptp(), height=0.2, \n                left=time[dt].min(), align='center', color='red')\n    ax.set_yticks(range(1, 5))\n    ax.set_yticklabels(['Paw 1', 'Paw 2', 'Paw 3', 'Paw 4'])\n    ax.set_xlabel('Time (ms) Since Beginning of Experiment')\n    ax.yaxis.grid(True)\n    ax.set_title('Periods of Paw Contact')\n\ndef annotate_paw_prints(time, data, data_slices, ax=None):\n    if ax is None:\n        ax = plt.gca()\n\n    # Display all paw impacts (sum over time)\n    ax.imshow(data.sum(axis=2).T)\n\n    # Annotate each impact with which paw it is\n    # (Relative to the first paw to hit the sensor)\n    x, y = [], []\n    for i, region in enumerate(data_slices):\n        dx, dy, dz = region\n        # Get x,y center of slice...\n        x0 = 0.5 * (dx.start + dx.stop)\n        y0 = 0.5 * (dy.start + dy.stop)\n        x.append(x0); y.append(y0)\n\n        # Annotate the paw impacts         \n        ax.annotate('Paw %i' % (i%4 +1), (x0, y0),  \n            color='red', ha='center', va='bottom')\n\n    # Plot line connecting paw impacts\n    ax.plot(x,y, '-wo')\n    ax.axis('image')\n    ax.set_title('Order of Steps')\n</code>\n</pre>\n", "senID": 8}, {"src": "http://i.stack.imgur.com/XmY3A.png", "tag": "img", "senID": 9}, {"src": "http://i.stack.imgur.com/JWyK3.png", "tag": "img", "senID": 10}, {"src": "http://i.stack.imgur.com/Hbcia.png", "tag": "img", "senID": 11}], [{"text": ["I'm no expert in image detection, and I don't know Python, but I'll give it a whack..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To detect individual paws, you should first only select everything with a pressure greater than some small threshold, very close to no pressure at all.", "Every pixel/point that is above this should be \"marked.", "\"  Then, every pixel adjacent to all \"marked\" pixels becomes marked, and this process is repeated a few times.", "Masses that are totally connected would be formed, so you have distinct objects.", "Then, each \"object\" has a minimum and maximum x and y value, so bounding boxes can be packed neatly around them."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Pseudocode:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["(MARK) ALL PIXELS ABOVE (0.5)"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "(MARK) ALL PIXELS ABOVE (0.5)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["(MARK) ALL PIXELS (ADJACENT) TO (MARK) PIXELS"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "(MARK) ALL PIXELS (ADJACENT) TO (MARK) PIXELS", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["REPEAT (STEP 2) (5) TIMES"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "REPEAT (STEP 2) (5) TIMES", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["SEPARATE EACH TOTALLY CONNECTED MASS INTO A SINGLE OBJECT"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "SEPARATE EACH TOTALLY CONNECTED MASS INTO A SINGLE OBJECT", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["MARK THE EDGES OF EACH OBJECT, AND CUT APART TO FORM SLICES."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "MARK THE EDGES OF EACH OBJECT, AND CUT APART TO FORM SLICES.", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["That should about do it.  "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Note: I say pixel, but this could be regions using an average of the pixels.", "Optimization is another issue..."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Note:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Sounds like you need to analyze a function (pressure over time) for each pixel and determine where the function turns (when it changes > X in the other direction it is considered a turn to counter errors)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "where the function turns", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Maxima_and_minima"}]}, {"text": ["If you know at what frames it turns, you will know the frame where the pressure was the most hard and you will know where it was the least hard between the two paws.", "In theory, you then would know the two frames where the paws pressed the most hard and can calculate an average of those intervals."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This is the same tour as before, knowing when each paw applies the most pressure helps you decide."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]