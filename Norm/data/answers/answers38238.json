[[{"text": ["Class methods are for when you need to have methods that aren't specific to any particular instance, but still involve the class in some way.", "The most interesting thing about them is that they can be overridden by subclasses, something that's simply not possible in Java's static methods or Python's module-level functions."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you have a class MyClass, and a module-level function that operates on MyClass (factory, dependency injection stub, etc), make it a classmethod.", "Then it'll be available to subclasses."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "MyClass", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "classmethod", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Factory methods (alternative constructors) are indeed a classic example of class methods."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Basically, class methods are suitable anytime you need would like to have a method which naturally fits into the namespace of the class, but is not associated with a particular instance of the class."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As an example, in the excelent unipath module:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "unipath", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/Unipath/0.2.1"}]}, {"text": ["Current directory"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Path.cwd()\n", "tag": "none", "senID": 4}, {"text": ".chdir()\n", "tag": "none", "senID": 5}]}, {"text": ["As the current directory is process wide, the cwd method has no particular instance with which it should be associated.", "However, changing the cwd to the directory of a given Path instance should indeed be an instance method."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Hmmm... as Path.cwd() does indeed return a Path instance, I guess it could be considered to be a factory method..."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Alternative constructors are the classic example."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Think about it this way: normal methods are useful to hide the details of dispatch: you can type myobj.foo() without worrying about whether the foo() method is implemented by the myobj object's class or one of its parent classes.", "Class methods are exactly analogous to this, but with the class object instead: they let you call MyClass.foo() without having to worry about whether foo() is implemented specially by MyClass because it needed its own specialized version, or whether it is letting its parent class handle the call."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "myobj.foo()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "myobj", "childNum": 0, "tag": "code", "childList": []}, {"text": "MyClass.foo()", "childNum": 0, "tag": "code", "childList": []}, {"text": "foo()", "childNum": 0, "tag": "code", "childList": []}, {"text": "MyClass", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Class methods are essential when you are doing set-up or computation that precedes the creation of an actual instance, because until the instance exists you obviously cannot use the instance as the dispatch point for your method calls.", "A good example can be viewed in the SQLAlchemy source code; take a look at the dbapi() class method at the following link:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "precedes", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "dbapi()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["http://hg.sqlalchemy.org/sqlalchemy/file/230819db717a/lib/sqlalchemy/dialects/mssql/pymssql.py"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://hg.sqlalchemy.org/sqlalchemy/file/230819db717a/lib/sqlalchemy/dialects/mssql/pymssql.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://hg.sqlalchemy.org/sqlalchemy/file/230819db717a/lib/sqlalchemy/dialects/mssql/pymssql.py"}]}, {"text": ["You can see that the dbapi() method, which a database backend uses to import the vendor-specific database library it needs on-demand, is a class method because it needs to run before instances of a particular database connection start getting created \u2014 but that it cannot be a simple function or static function, because they want it to be able to call other, supporting methods that might similarly need to be written more specifically in subclasses than in their parent class.", "And if you dispatch to a function or static class, then you \"forget\" and lose the knowledge about which class is doing the initializing."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "dbapi()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "before", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}], [{"text": ["I recently wanted a very light-weight logging class that would output varying amounts of output depending on the logging level that could be programmatically set.", "But I didn't want to instantiate the class every time I wanted to output a debugging message or error or warning.", "But I also wanted to encapsulate the functioning of this logging facility and make it reusable without the declaration of any globals."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So I used class variables and the @classmethod decorator to achieve this."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "@classmethod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["With my simple Logging class, I could do the following:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Logger._level = Logger.DEBUG\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then, in my code, if I wanted to spit out a bunch of debugging information, I simply had to code"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n Logger.debug( \"this is some annoying message I only want to see while debugging\" )\n</code>\n</pre>\n", "senID": 5}, {"text": ["Errors could be out put with "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n Logger.error( \"Wow, something really awful happened.\" )\n</code>\n</pre>\n", "senID": 7}, {"text": ["In the \"production\" environment, I can specify "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n Logger._level = Logger.ERROR\n</code>\n</pre>\n", "senID": 9}, {"text": ["and now, only the error message will be output.", "The debug message will not be printed."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Here's my class:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n class Logger :\n    ''' Handles logging of debugging and error messages. '''\n\n    DEBUG = 5\n    INFO  = 4\n    WARN  = 3\n    ERROR = 2\n    FATAL = 1\n    _level = DEBUG\n\n    def __init__( self ) :\n        Logger._level = Logger.DEBUG\n\n    @classmethod\n    def isLevel( cls, level ) :\n        return cls._level &gt;= level\n\n    @classmethod\n    def debug( cls, message ) :\n        if cls.isLevel( Logger.DEBUG ) :\n            print \"DEBUG:  \" + message\n\n    @classmethod\n    def info( cls, message ) :\n        if cls.isLevel( Logger.INFO ) :\n            print \"INFO :  \" + message\n\n    @classmethod\n    def warn( cls, message ) :\n        if cls.isLevel( Logger.WARN ) :\n            print \"WARN :  \" + message\n\n    @classmethod\n    def error( cls, message ) :\n        if cls.isLevel( Logger.ERROR ) :\n            print \"ERROR:  \" + message\n\n    @classmethod\n    def fatal( cls, message ) :\n        if cls.isLevel( Logger.FATAL ) :\n            print \"FATAL:  \" + message\n</code>\n</pre>\n", "senID": 12}, {"text": ["And some code that tests it just a bit:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n def logAll() :\n    Logger.debug( \"This is a Debug message.\" )\n    Logger.info ( \"This is a Info  message.\" )\n    Logger.warn ( \"This is a Warn  message.\" )\n    Logger.error( \"This is a Error message.\" )\n    Logger.fatal( \"This is a Fatal message.\" )\n\nif __name__ == '__main__' :\n\n    print \"Should see all DEBUG and higher\"\n    Logger._level = Logger.DEBUG\n    logAll()\n\n    print \"Should see all ERROR and higher\"\n    Logger._level = Logger.ERROR\n    logAll()\n</code>\n</pre>\n", "senID": 14}], [{"text": ["Honestly?", "I've never found a use for staticmethod or classmethod.", "I've yet to see an operation that can't be done using a global function or an instance method."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It would be different if python used private and protected members more like Java does.", "In Java, I need a static method to be able to access an instance's private members to do stuff.", "In Python, that's rarely necessary."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Usually, I see people using staticmethods and classmethods when all they really need to do is use python's module-level namespaces better."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I used to work with PHP and recently I was asking myself, whats going on with this classmethod?", "Python manual is very technical and very short in words so it wont help with understanding that feature.", "I was googling and googling and I found answer -> http://code.anjanesh.net/2007/12/python-classmethods.html."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.anjanesh.net/2007/12/python-classmethods.html", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://code.anjanesh.net/2007/12/python-classmethods.html"}]}, {"text": ["If you are lazy to click it.", "My explanation is shorter and below.", ":)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["in PHP (maybe not all of you know PHP, but this language is so straight forward that everybody should understand what I'm talking about) we have static variables like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class A\n{\n\n    static protected $inner_var = null;\n\n    static public function echoInnerVar()\n    {\n        echo self::$inner_var.\"\\n\";\n    }\n\n    static public function setInnerVar($v)\n    {\n        self::$inner_var = $v;\n    }\n\n}\n\nclass B extends A\n{\n}\n\nA::setInnerVar(10);\nB::setInnerVar(20);\n\nA::echoInnerVar();\nB::echoInnerVar();\n</code>\n</pre>\n", "senID": 3}, {"text": ["The output will be in both cases 20."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["However in python we can add @classmethod decorator and thus it is possible to have output 10 and 20 respectively.", "Example:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    inner_var = 0\n\n    @classmethod\n    def setInnerVar(cls, value):\n        cls.inner_var = value\n\n    @classmethod\n    def echoInnerVar(cls):\n        print cls.inner_var\n\n\nclass B(A):\n    pass\n\n\nA.setInnerVar(10)\nB.setInnerVar(20)\n\nA.echoInnerVar()\nB.echoInnerVar()\n</code>\n</pre>\n", "senID": 6}, {"text": ["Smart, ain't?"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Class methods provide a \"semantic sugar\" (don't know if this term is widely used) - or \"semantic convenience\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Example: you got a set of classes representing objects.", "You might want to have the class method \"all\" or \"find\" to write \"User.all()\" ou \"User.find(firstname='Guido')\".", "That could be done using module level functions of course..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I think the most clear answer is AmanKow's one.", "It boils down to how u want to organize your code.", "You can write everything as module level functions which are wrapped in the namespace of the module i.e"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "AmanKow's", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n module.py (define file 1)\n---------\ndef f1() : pass\ndef f2() : pass\ndef f3() : pass\n\n\nusage.py (consume file 2)\n--------\nimport module\nf1()\nf2()\nf3()\ndef f4():pass in \ndef f5():pass\n\nusage1.py (consume file 3)\n-------------------\nimport usage\nf4()\nf5()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The above procedural code is not well organized, as you can see after only 3 modules it gets confusing, what is each method do ?", "You can use long descriptive names for functions(like in java) but still  your code gets unmanageable very quick."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The object oriented way is to break down your code into manageable blocks i.e Classes &amp; objects and functions can be associated with objects instances or with classes. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["With class functions you gain another level of division in your code compared with module level functions.", "So you can group related functions within a class to make them more specific to a task  that you assigned to that class.", "For example you can create a file utility class :"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class FileUtil ():\n  def copy(source,dest):pass\n  def move(source,dest):pass\n  def copyDir(source,dest):pass\n  def moveDir(source,dest):pass\n\n//usage\nFileUtil.copy(\"1.txt\",\"2.txt\")\nFileUtil.moveDir(\"dir1\",\"dir2\")\n</code>\n</pre>\n", "senID": 5}, {"text": ["This way is more flexible and more maintainable, you group functions together and its more obvious to what each function do.", "Also you prevent name conflicts, for example the function copy may exist in another imported module(for example network copy) that you use in your code, so when you use the full name FileUtil.copy() you remove the problem and both copy functions can be used side by side."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["If you are interested in using class methods in Python, you might want to consider some examples here."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "some examples here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.google.com/codesearch?q=classmethod+package%3ahttp://verse-quiz"}]}]]