[[{"text": ["Module importing is quite fast, but not instant.", "This means that:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Putting the imports at the top of the module is fine, because it's a trivial cost that's only paid once.", "tag": "none", "senID": 1}, {"text": "Putting the imports within a function will cause calls to that function to take longer.", "tag": "none", "senID": 2}]}, {"text": ["So if you care about efficiency, put the imports at the top.", "Only move them into a function if your profiling shows that would help (you did profile to see where best to improve performance, right??"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "did", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"tag": "hr", "senID": 4}, {"text": ["The best reasons I've seen to perform lazy imports are:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Optional library support. If your code has multiple paths that use different libraries, don't break if an optional library is not installed.", "tag": "none", "senID": 6}, {"text": "In the ", "tag": "none", "senID": 7}]}], [{"text": ["Putting the import statement inside of a function can prevent circular dependencies."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["It's a tradeoff, that only the programmer can decide to make. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Case 1 saves some memory and startup time by not importing the datetime module (and doing whatever initialization it might require) until needed.", "Note that doing the import 'only when called' also means doing it 'every time when called', so each call after the first one is still incurring the additional overhead of doing the import. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Case 2 save some execution time and latency by importing datetime beforehand so that not_often_called() will return more quickly when it is called, and also by not incurring the overhead of an import on every call."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "is", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Besides efficiency, it's easier to see module dependencies up front if the import statements are ... up front.", "Hiding them down in the code can make it more difficult to easily find what modules something depends on."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Personally I generally follow the PEP except for things like unit tests and such that I don't want always loaded because I know they aren't going to be used except for test code."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "know", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["I have adopted the practice of putting all imports in the functions that use them, rather than at the top of the module."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The benefit I get is the ability to refactor more reliably.", "When I move a function from one module to another, I know that the function will continue to work with all of its legacy of testing intact.", "If I have my imports at the top of the module, when I move a function, I find that I end up spending a lot of time getting the new module's imports complete and minimal.", "A refactoring IDE might make this irrelevant."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There is a speed penalty as mentioned elsewhere.", "I have measured this in my application and found it to be insignificant for my purposes. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It is also nice to be able to see all module dependencies up front without resorting to search (e.g.", "grep).", "However, the reason I care about module dependencies is generally because I'm installing, refactoring, or moving an entire system comprising multiple files, not just a single module.", "In that case, I'm going to perform a global search anyway to make sure I have the system-level dependencies.", "So I have not found global imports to aid my understanding of a system in practice."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I usually put the import of sys inside the if __name__=='__main__' check and then pass arguments (like sys.argv[1:]) to a main() function.", "This allows me to use main in a context where sys has not been imported."], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": "sys", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "if __name__=='__main__'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sys.argv[1:]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "main()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "main", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "sys", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The first variant is indeed more efficient than the second when the function is called either zero or one times.", "With the second and subsequent invocations, however, the \"import every call\" approach is actually less efficient.", "See this link for a lazy-loading technique that combines the best of both approaches by doing a \"lazy import\"."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this link", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/PythonSpeed/PerformanceTips#head-c849d5d5d94bc3eacbff9d5746af4083443cf2ca"}]}, {"text": ["But there are reasons other than efficiency why you might prefer one over the other.", "One approach is makes it much more clear to someone reading the code as to the dependencies that this module has.", "They also have very different failure characteristics -- the first will fail at load time if there's no \"datetime\" module while the second won't fail until the method is called."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Added Note: In IronPython, imports can be quite a bit more expensive than in CPython because the code is basically being compiled as it's being imported."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Added Note:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Most of the time this would be useful for clarity and sensible to do but it's not always the case.", "Below are a couple of examples of circumstances where module imports might live elsewhere."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Firstly, you could have a module with a unit test of the form:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if __name__ == '__main__':\n    import foo\n    aa = foo.xyz()         # initiate something for the test\n</code>\n</pre>\n", "senID": 2}, {"text": ["Secondly, you might have a requirement to conditionally import some different module at runtime."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n if [condition]:\n    import foo as plugin_api\nelse:\n    import bar as plugin_api\nxx = plugin_api.Plugin()\n[...]\n</code>\n</pre>\n", "senID": 4}, {"text": ["There are probably other situations where you might place imports in other parts in the code."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Curt makes a good point: the second version is clearer and will fail at load time rather than later, and unexpectedly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Normally I don't worry about the efficiency of loading modules, since it's (a) pretty fast, and (b) mostly only happens at startup."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you have to load heavyweight modules at unexpected times, it probably makes more sense to load them dynamically with the __import__ function, and be sure to catch ImportError exceptions, and handle them in a reasonable manner."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "__import__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sure", "childNum": 0, "tag": "b", "childList": []}, {"text": "ImportError", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Here's an example where all the imports are at the very top (this is the only time I've needed to do this).", "I want to be able to terminate a subprocess on both Un*x and Windows."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\n# ...\ntry:\n    kill = os.kill  # will raise AttributeError on Windows\n    from signal import SIGTERM\n    def terminate(process):\n        kill(process.pid, SIGTERM)\nexcept (AttributeError, ImportError):\n    try:\n        from win32api import TerminateProcess  # use win32api if available\n        def terminate(process):\n            TerminateProcess(int(process._handle), -1)\n    except ImportError:\n        def terminate(process):\n            raise NotImplementedError  # define a dummy function\n</code>\n</pre>\n", "senID": 1}, {"text": ["(On review: what John Millikin said."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "John Millikin", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/128478/should-python-import-statements-always-be-at-the-top-of-a-module#128577"}]}], [{"text": ["This is like many other optimizations - you sacrifice some readability for speed.", "As John mentioned, if you've done your profiling homework and found this to be a significantly useful enough change and you need the extra speed, then go for it.", "It'd probably be good to put a note up with all the other imports:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "and", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from foo import bar\nfrom baz import qux\n# Note: datetime is imported in SomeClass below\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I wouldn't worry about the efficiency of loading the module up front too much.", "The memory taken up by the module won't be very big (assuming it's modular enough) and the startup cost will be negligible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In most cases you want to load the modules at the top of the source file.", "For somebody reading your code, it makes it much easier to tell what function or object came from what module."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["One good reason to import a module elsewhere in the code is if it's used in a debugging statement."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n do_something_with_x(x0\n</code>\n</pre>\n", "senID": 4}, {"text": ["I could debug this with:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from pprint import pprint\npprint(x)\ndo_something_with_x(x)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Of course, the other reason to import modules elsewhere in the code is if you need to dynamically import them.", "This is because you pretty much don't have any choice."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["I wouldn't worry about the efficiency of loading the module up front too much.", "The memory taken up by the module won't be very big (assuming it's modular enough) and the startup cost will be negligible."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Module initialization only occurs once - on the first import.", "If the module in question is from the standard library, then you will likely import it from other modules in your program as well.", "For a module as prevalent as datetime, it is also likely a dependency for a slew of other standard libraries.", "The import statement would cost very little then since the module intialization would have happened already.", "All it is doing at this point is binding the existing module object to the local scope."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Couple that information with the argument for readability and I would say that it is best to have the import statement at module scope.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]