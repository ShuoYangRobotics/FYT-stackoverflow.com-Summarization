[[{"text": ["If you're just looking to iterate over a flattened version of the data structure and don't need an indexable sequence, consider itertools.chain and company."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.chain and company", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.chain"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list_of_menuitems = [['image00', 'image01'], ['image10'], []]\n&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; chain = itertools.chain(*list_of_menuitems)\n&gt;&gt;&gt; print(list(chain))\n['image00', 'image01', 'image10']\n</code>\n</pre>\n", "senID": 1}, {"text": ["It will work on anything that's iterable, which should include Django's iterable QuerySets, which it appears that you're using in the question."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "QuerySet", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit: This is probably as good as a reduce anyway, because reduce will have the same overhead copying the items into the list that's being extended.", "chain will only incur this (same) overhead if you run list(chain) at the end."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "chain", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "list(chain)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Meta-Edit: Actually, it's less overhead than the question's proposed solution, because you throw away the temporary lists you create when you extend the original with the temporary."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Meta-Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Edit: As J.F.", "Sebastian says itertools.chain.from_iterable avoids the unpacking and you should use that to avoid * magic, but the timeit app shows negligible performance difference."], "childNum": 5, "tag": "p", "senID": 5, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "J.F. Sebastian says", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/406121/flattening-a-shallow-list-in-python#411548"}, {"text": "itertools.chain.from_iterable", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "*", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://stackoverflow.com/questions/406121/flattening-a-shallow-list-in-python#408281", "text": "the timeit app", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["You almost have it!", "The way to do nested list comprehensions is to put the for statements in the same order as they would go in regular nested for statements."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "way to do nested list comprehensions", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#nested-list-comprehensions"}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Thus, this"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for inner_list in outer_list:\n    for item in inner_list:\n        ...\n</code>\n</pre>\n", "senID": 2}, {"text": ["corresponds to"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n [... for inner_list in outer_list for item in inner_list]\n</code>\n</pre>\n", "senID": 4}, {"text": ["So you want"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n [image for menuitem in list_of_menuitems for image in menuitem.image_set.all()]\n</code>\n</pre>\n", "senID": 6}], [{"text": ["@S.Lott: You inspired me to write a timeit app."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@S.Lott", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/406121/flattening-a-shallow-list-in-python#406622"}]}, {"text": ["I figured it would also vary based on the number of partitions (number of iterators within the container list) -- your comment didn't mention how many partitions there were of the thirty items.", "This plot is flattening a thousand items in every run, with varying number of partitions.", "The items are evenly distributed among the partitions."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"src": "http://lh4.ggpht.com/_t58Xs7CN35o/SWFNN5Z_Q1I/AAAAAAAABPs/ewrRhthazfs/s400/Flatten%20with%20Itertools%20Iterable%201000%20Items.png", "tag": "img", "senID": 2}, {"text": ["Code (Python 2.6):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python2.6\n\n\"\"\"Usage: %prog item_count\"\"\"\n\nfrom __future__ import print_function\n\nimport collections\nimport itertools\nimport operator\nfrom timeit import Timer\nimport sys\n\nimport matplotlib.pyplot as pyplot\n\ndef itertools_flatten(iter_lst):\n    return list(itertools.chain(*iter_lst))\n\ndef itertools_iterable_flatten(iter_iter):\n    return list(itertools.chain.from_iterable(iter_iter))\n\ndef reduce_flatten(iter_lst):\n    return reduce(operator.add, map(list, iter_lst))\n\ndef reduce_lambda_flatten(iter_lst):\n    return reduce(operator.add, map(lambda x: list(x), [i for i in iter_lst]))\n\ndef comprehension_flatten(iter_lst):\n    return list(item for iter_ in iter_lst for item in iter_)\n\nMETHODS = ['itertools', 'itertools_iterable', 'reduce', 'reduce_lambda',\n           'comprehension']\n\ndef _time_test_assert(iter_lst):\n    \"\"\"Make sure all methods produce an equivalent value.\n    :raise AssertionError: On any non-equivalent value.\"\"\"\n    callables = (globals()[method + '_flatten'] for method in METHODS)\n    results = [callable(iter_lst) for callable in callables]\n    if not all(result == results[0] for result in results[1:]):\n        raise AssertionError\n\ndef time_test(partition_count, item_count_per_partition, test_count=10000):\n    \"\"\"Run flatten methods on a list of :param:`partition_count` iterables.\n    Normalize results over :param:`test_count` runs.\n    :return: Mapping from method to (normalized) microseconds per pass.\n    \"\"\"\n    iter_lst = [[dict()] * item_count_per_partition] * partition_count\n    print('Partition count:    ', partition_count)\n    print('Items per partition:', item_count_per_partition)\n    _time_test_assert(iter_lst)\n    test_str = 'flatten(%r)' % iter_lst\n    result_by_method = {}\n    for method in METHODS:\n        setup_str = 'from test import %s_flatten as flatten' % method\n        t = Timer(test_str, setup_str)\n        per_pass = test_count * t.timeit(number=test_count) / test_count\n        print('%20s: %.2f usec/pass' % (method, per_pass))\n        result_by_method[method] = per_pass\n    return result_by_method\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2:\n        raise ValueError('Need a number of items to flatten')\n    item_count = int(sys.argv[1])\n    partition_counts = []\n    pass_times_by_method = collections.defaultdict(list)\n    for partition_count in xrange(1, item_count):\n        if item_count % partition_count != 0:\n            continue\n        items_per_partition = item_count / partition_count\n        result_by_method = time_test(partition_count, items_per_partition)\n        partition_counts.append(partition_count)\n        for method, result in result_by_method.iteritems():\n            pass_times_by_method[method].append(result)\n    for method, pass_times in pass_times_by_method.iteritems():\n        pyplot.plot(partition_counts, pass_times, label=method)\n    pyplot.legend()\n    pyplot.title('Flattening Comparison for %d Items' % item_count)\n    pyplot.xlabel('Number of Partitions')\n    pyplot.ylabel('Microseconds')\n    pyplot.show()\n</code>\n</pre>\n", "senID": 4}, {"text": ["Edit: Decided to make it community wiki."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Note: METHODS should probably be accumulated with a decorator, but I figure it'd be easier for people to read this way."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "Note:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "METHODS", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Performance Results.", "Revised."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\ndef itertools_flatten( aList ):\n    return list( itertools.chain(*aList) )\n\nfrom operator import add\ndef reduce_flatten1( aList ):\n    return reduce(add, map(lambda x: list(x), [mi for mi in aList]))\n\ndef reduce_flatten2( aList ):\n    return reduce(list.__add__, map(list, aList))\n\ndef comprehension_flatten( aList ):\n    return list(y for x in aList for y in x)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I flattened a 2-level list of 30 items 1000 times"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n itertools_flatten     0.00554\ncomprehension_flatten 0.00815\nreduce_flatten2       0.01103\nreduce_flatten1       0.01404\n</code>\n</pre>\n", "senID": 3}, {"text": ["Reduce is always a poor choice."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["In Python 2.6, using chain.from_iterable():"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "chain.from_iterable()", "tag": "a", "pos": 0, "childList": [{"text": "chain.from_iterable()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.itertools.chain.from_iterable"}, {"text": "chain.from_iterable()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import chain\n&gt;&gt;&gt; list(chain.from_iterable(mi.image_set.all() for mi in h.get_image_menu()))\n</code>\n</pre>\n", "senID": 1}, {"text": ["It avoids creating of intermediate list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here is the correct solution using list comprehensions (they're backward in the question):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; join = lambda it: (y for x in it for y in x)\n&gt;&gt;&gt; list(join([[1,2],[3,4,5],[]]))\n[1, 2, 3, 4, 5]\n</code>\n</pre>\n", "senID": 1}, {"text": ["In your case it would be"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [image for menuitem in list_of_menuitems for image in menuitem.image_set.all()]\n</code>\n</pre>\n", "senID": 3}, {"text": ["or you could use join and say"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "join", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n join(menuitem.image_set.all() for menuitem in list_of_menuitems)\n</code>\n</pre>\n", "senID": 5}, {"text": ["In either case, the gotcha was the nesting of the for loops."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This solution works for arbitrary nesting depths - not just the \"list of lists\" depth that some (all?", ") of the other solutions are limited to:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def flatten(x):\n    result = []\n    for el in x:\n        if hasattr(el, \"__iter__\") and not isinstance(el, basestring):\n            result.extend(flatten(el))\n        else:\n            result.append(el)\n    return result\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's the recursion which allows for arbitrary depth nesting - until you hit the maximum recursion depth, of course..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Off the top of my head, you can eliminate the lambda:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n reduce(list.__add__, map(list, [mi.image_set.all() for mi in list_of_menuitems]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or even eliminate the map, since you've already got a list-comp:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n reduce(list.__add__, [list(mi.image_set.all()) for mi in list_of_menuitems])\n</code>\n</pre>\n", "senID": 3}, {"text": ["You can also just express this as a sum of lists:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n sum([list(mi.image_set.all()) for mi in list_of_menuitems], [])\n</code>\n</pre>\n", "senID": 5}], [{"text": ["What about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from operator import add\nreduce(add, map(lambda x: list(x.image_set.all()), [mi for mi in list_of_menuitems]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["But, Guido is recommending against performing too much in a single line of code since it reduces readability.", "There is minimal, if any, performance gain by performing what you want in a single line vs. multiple lines."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]