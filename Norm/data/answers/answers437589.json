[[{"text": ["You can reload a module when it has already been imported by using the reload builtin function:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "reload", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html?highlight=reload#reload"}]}, {"code": "<pre>\n<code>\n import foo\n\nwhile True:\n    # Do some things.\n    if is_changed(foo):\n        foo = reload(foo)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think that this is what you want.", "Web servers like Django's development server use this so that you can see the effects of your code changes without restarting the server process itself."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["To quote from the docs:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["As you noted in your question, you'll have to reconstruct Foo objects if the Foo class resides in the foo module."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "Foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Foo", "childNum": 0, "tag": "code", "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["In Python 3, you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import imp\nimp.reload(foo)\n</code>\n</pre>\n", "senID": 1}, {"text": ["As per the BDFL."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "As per the BDFL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/edu-sig/2008-February/008421.html"}]}], [{"text": ["To cover my shame, here is a Python list thread that discusses how to delete a module.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The summary:  it can be especially difficult if the module is not pure python."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["How do I really delete an imported module | former (dead) link"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "How do I really delete an imported module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.velocityreviews.com/forums/t326253-how-do-i-really-delete-an-imported-module.html"}, {"href": "http://mail.python.org/pipermail/python-list/2003-December/241654.html", "text": "former (dead) link", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["In particular:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt; &gt;&gt;&gt; import sys, empty, os\n&gt; &gt;&gt;&gt; sys.getrefcount(sys) 9\n&gt; &gt;&gt;&gt; sys.getrefcount(os) 6\n&gt; &gt;&gt;&gt; sys.getrefcount(empty) 3\n</code>\n</pre>\n", "senID": 4}, {"code": "<pre>\n<code>\n &gt; &gt;&gt;&gt; del sys.modules[\"empty\"]\n&gt; &gt;&gt;&gt; del empty\n</code>\n</pre>\n", "senID": 5}], [{"text": ["reload(module), but only if it's completely stand-alone.", "If anything else has a reference to the module (or any object belonging to the module), then you'll get subtle and curious errors caused by the old code hanging around longer than you expected, and things like isinstance not working across different versions of the same code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you have one-way dependencies, you must also reload all modules that depend on the the reloaded module to get rid of all the references to the old code.", "And then reload modules that depend on the reloaded modules, recursively."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you have circular dependencies, which is very common for example when you are dealing with reloading a package, you must unload all the modules in the group in one go.", "You can't do this with reload() because it will re-import each module before its dependencies have been refreshed, allowing old references to creep into new modules."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The only way to do it in this case is to hack sys.modules, which is kind of unsupported.", "You'd have to go through and delete each sys.modules entry you wanted to be reloaded on next import, and also delete entries whose values are None to deal with an implementation issue to do with cacheing failed relative imports.", "It's not terribly nice but as long as you have a fully self-contained set of dependencies that doesn't leave references outside its codebase, it's workable."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["It's probably best to restart the server.", ":-)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n if 'myModule' in sys.modules:  \n    del(sys.modules[\"myModule\"])\n</code>\n</pre>\n", "senID": 0}], [{"text": ["For those like me who want to unload all modules (when running in Python interpreter under emacs):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for mod in sys.modules.values():\n      reload(mod)\n</code>\n</pre>\n", "senID": 1}, {"text": ["More information here: http://pyunit.sourceforge.net/notes/reloading.html"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://pyunit.sourceforge.net/notes/reloading.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyunit.sourceforge.net/notes/reloading.html"}]}], [{"text": ["If you want things out of the namespace, just do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n del foo\n</code>\n</pre>\n", "senID": 1}, {"text": ["and it's gone.", "In some environments (like IPython) this doesn't always remove everything.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]