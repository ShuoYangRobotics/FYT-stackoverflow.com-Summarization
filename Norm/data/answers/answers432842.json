[[{"text": ["If you're already normalizing the inputs to booleans, then != is xor."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n bool(a) != bool(b)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can always use the definition of xor to compute it from other logical operations:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (a and not b) or (not a and b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["But this is a little too verbose for me, and isn't particularly clear at first glance.", "Another way to do it is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n bool(a) ^ bool(b)\n</code>\n</pre>\n", "senID": 3}, {"text": ["The xor operator on two booleans is logical xor (unlike on ints, where it's bitwise).", "Which makes sense, since boolis just a subclass ofint, but is implemented to only have the values 0 and 1.", "And logical xor is equivalent to bitwise xor when the domain is restricted to 0 and 1."], "childNum": 7, "tag": "p", "senID": 4, "childList": [{"text": "boolis just a subclass ofint", "tag": "a", "pos": 1, "childList": [{"text": "bool", "tag": "code"}, {"text": "int", "tag": "code"}], "childNum": 2, "href": "http://docs.python.org/library/functions.html?highlight=bool#bool"}, {"text": "bool", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So the logical_xor function would be implemented like:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "logical_xor", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def logical_xor(str1, str2):\n    return bool(str1) ^ bool(str2)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Credit to Nick Coghlan on the Python-3000 mailing list."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Nick Coghlan on the Python-3000 mailing list", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-3000/2007-December/011560.html"}]}], [{"tag": "ul", "num": 2, "lis": [{"text": "Python logical ", "tag": "none", "senID": 0}, {"text": "Python logical ", "tag": "none", "senID": 1}]}, {"text": ["To keep most of that way of thinking, my logical xor definintion would be:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def logical_xor(a, b):\n    if bool(a) == bool(b):\n        return False\n    else:\n        return a or b\n</code>\n</pre>\n", "senID": 3}, {"text": ["That way it can return a, b, or False:"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; logical_xor('this', 'that')\nFalse\n&gt;&gt;&gt; logical_xor('', '')\nFalse\n&gt;&gt;&gt; logical_xor('this', '')\n'this'\n&gt;&gt;&gt; logical_xor('', 'that')\n'that'\n</code>\n</pre>\n", "senID": 5}], [{"text": ["As Zach explained, you can use:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Zach", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/432842/how-do-you-get-the-logical-xor-of-two-variables-in-python#432844"}]}, {"code": "<pre>\n<code>\n xor = bool(a) ^ bool(b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Personally, I favor a slightly different dialect:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n xor = bool(a) + bool(b) == 1\n</code>\n</pre>\n", "senID": 3}, {"text": ["This dialect is inspired from a logical diagramming language I learned in school where \"OR\" was denoted by a box containing \u22651 (greater than or equal to 1) and \"XOR\" was denoted by a box containing =1."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "\u22651", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "=1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This has the advantage of correctly implementing exclusive or on multiple operands."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "\"1 = a ^ b ^ c...\" means the number of true operands is odd. This operator is \"parity\".", "tag": "none", "senID": 6}, {"text": "\"1 = a + b + c...\" means exactly one operand is true. This is \"exclusive or\", meaning \"one to the exclusion of the others\".", "tag": "none", "senID": 7}]}], [{"text": ["How about this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (not b and a) or (not a and b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["will give a if b is false\nwill give b if a is false\nwill give False otherwise"], "childNum": 7, "tag": "p", "senID": 2, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Or with the Python 2.5+ ternary expression:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n (False if a else b) if b else a\n</code>\n</pre>\n", "senID": 4}], [{"text": ["It's easy when you know what XOR does:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def logical_xor(a, b):\n    return (a and not b) or (not a and b)\n\ntest_data = [\n  [False, False],\n  [False, True],\n  [True, False],\n  [True, True],\n]\n\nfor a, b in test_data:\n    print '%r xor %s = %r' % (a, b, logical_xor(a, b))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Exclusive Or is defined as follows"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def xor( a, b ):\n    return (a or b) and not (a and b)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Some of the implementations suggested here will cause repeated evaluation of the operands  in some cases, which may lead to unintended side effects and therefore must be avoided."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That said, a xor implementation that returns either True or False is fairly simple; one that returns one of the operands, if possible, is much trickier, because no consensus exists as to which operand should be the chosen one, especially when there are more than two operands.", "For instance, should xor(None, -1, [], True) return None, [] or False?", "I bet each answer appears to some people as the most intuitive one."], "childNum": 7, "tag": "p", "senID": 1, "childList": [{"text": "xor", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "xor(None, -1, [], True)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "[]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["For either the True- or the False-result, there are as many as five possible choices: return first operand (if it matches end result in value, else boolean), return first match (if at least one exists, else boolean), return last operand (if ... else ...), return last match (if ... else ...), or always return boolean.", "Altogether, that's 5 ** 2 = 25 flavors of xor."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "xor", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def xor(*operands, falsechoice = -2, truechoice = -2):\n  \"\"\"A single-evaluation, multi-operand, full-choice xor implementation\n  falsechoice, truechoice: 0 = always bool, +/-1 = first/last operand, +/-2 = first/last match\"\"\"\n  if not operands:\n    raise TypeError('at least one operand expected')\n  choices = [falsechoice, truechoice]\n  matches = {}\n  result = False\n  first = True\n  value = choice = None\n  # avoid using index or slice since operands may be an infinite iterator\n  for operand in operands:\n    # evaluate each operand once only so as to avoid unintended side effects\n    value = bool(operand)\n    # the actual xor operation\n    result ^= value\n    # choice for the current operand, which may or may not match end result\n    choice = choices[value]\n    # if choice is last match;\n    # or last operand and the current operand, in case it is last, matches result;\n    # or first operand and the current operand is indeed first;\n    # or first match and there hasn't been a match so far\n    if choice &lt; -1 or (choice == -1 and value == result) or (choice == 1 and first) or (choice &gt; 1 and value not in matches):\n      # store the current operand\n      matches[value] = operand\n    # next operand will no longer be first\n    first = False\n  # if choice for result is last operand, but they mismatch\n  if (choices[result] == -1) and (result != value):\n    return result\n  else:\n    # return the stored matching operand, if existing, else result as bool\n    return matches.get(result, result)\n\ntestcases = [\n  (-1, None, True, {None: None}, [], 'a'),\n  (None, -1, {None: None}, 'a', []),\n  (None, -1, True, {None: None}, 'a', []),\n  (-1, None, {None: None}, [], 'a')]\nchoices = {-2: 'last match', -1: 'last operand', 0: 'always bool', 1: 'first operand', 2: 'first match'}\nfor c in testcases:\n  print(c)\n  for f in sorted(choices.keys()):\n    for t in sorted(choices.keys()):\n      x = xor(*c, falsechoice = f, truechoice = t)\n      print('f: %d (%s)\\tt: %d (%s)\\tx: %s' % (f, choices[f], t, choices[t], x))\n  print()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["As I don't see the simple variant of xor using variable arguments and only operation on Truth values True or False, I'll just throw it here for anyone to use.", "It's as noted by others, pretty (not to say very) straightforward."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def xor(*vars):\n    sum = bool(False)\n    for v in vars:\n        sum = sum ^ bool(v)\n    return sum\n</code>\n</pre>\n", "senID": 1}, {"text": ["And usage is straightforward as well:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if xor(False, False, True, False):\n    print \"Hello World!\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["As this is the generalized n-ary logical XOR, it's truth value will be True whenever the number of True operands is odd (and not only when exactly one is True, this is just one case in which n-ary XOR is True)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Thus if you are in search of a n-ary predicate that is only True when exactly one of it's operands is, you might want to use:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def isOne(*vars):\n    sum = bool(False)\n    for v in vars:\n        if sum and v:\n            return False\n        else:\n            sum = sum or v\n    return sum\n</code>\n</pre>\n", "senID": 6}]]