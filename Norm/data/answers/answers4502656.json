[[{"text": ["Alright!", "I've finally managed to get something working consistently!", "This problem pulled me in for several days... Fun stuff!", "Sorry for the length of this answer, but I need to elaborate a bit on some things... (Though I may set a record for the longest non-spam stackoverflow answer ever!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As a side note, I'm using the full dataset that Ivo provided a link to in his original question.", "It's a series of rar files (one-per-dog) each containing several different experiment runs stored as ascii arrays.", "Rather than try to copy-paste stand-alone code examples into this question, here's a bitbucket mercurial repository with full, stand-alone code.", "You can clone it with "], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "provided a link to", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cid-0e685da213fd5935.skydrive.live.com/redir.aspx?page=browse&resid=E685DA213FD5935!148&type=6&authkey=WOUgehAzQ!o%24&Bsrc=EMSHGM&Bpub=SN.Notifications"}, {"text": "original question", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3684484/peak-detection-in-a-2d-array"}, {"text": "bitbucket mercurial repository", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "https://bitbucket.org/joferkington/paw-analysis/overview"}]}, {"text": ["hg clonehttps://joferkington@bitbucket.org/joferkington/paw-analysis"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "hg clonehttps://joferkington@bitbucket.org/joferkington/paw-analysis", "childNum": 1, "tag": "code", "pos": 0, "childList": [{"text": "https://joferkington@bitbucket.org/joferkington/paw-analysis", "tag": "a"}]}, {"href": "https://joferkington@bitbucket.org/joferkington/paw-analysis", "text": "https://joferkington@bitbucket.org/joferkington/paw-analysis", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Overview"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Overview", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["There are essentially two ways to approach the problem, as you noted in your question.", "I'm actually going to use both in different ways."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Basically, the first method works with the dog's paws follow the trapezoidal-like pattern shown in Ivo's question above, but fails whenever the paws don't follow that pattern.", "It's fairly easy to programatically detect when it doesn't work.  "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Therefore, we can use the measurements where it did work to build up a training dataset (of ~2000 paw impacts from ~30 different dogs) to recognize which paw is which, and the problem reduces to a supervised classification (With some additional wrinkles...", "Image recognition is a bit harder than a \"normal\" supervised classification problem)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Pattern Analysis"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Pattern Analysis", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["To elaborate on the first method, when a dog is walking (not running!", ") normally (which some of these dogs may not be), we expect paws to impact in the order of: Front Left, Hind Right, Front Right, Hind Left, Front Left, etc.", "The pattern may start with either the front left or front right paw."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["If this were always the case, we could simply sort the impacts by initial contact time and use a modulo 4 to group them by paw.  "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"src": "http://i.stack.imgur.com/gLhbt.png", "tag": "img", "senID": 10}, {"text": ["However, even when everything is \"normal\", this doesn't work.", "This is due to the trapezoid-like shape of the pattern.", "A hind paw spatially falls behind the previous front paw."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Therefore, the hind paw impact after the initial front paw impact often falls off the sensor plate, and isn't recorded.", "Similarly, the last paw impact is often not the next paw in the sequence, as the paw impact before it occured off the sensor plate and wasn't recorded."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"src": "http://i.stack.imgur.com/th87Q.png", "tag": "img", "senID": 13}, {"text": ["Nonetheless, we can use the shape of the paw impact pattern to determine when this has happened, and whether we've started with a left or right front paw.", "(I'm actually ignoring problems with the last impact here.", "It's not too hard to add it, though."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n def group_paws(data_slices, time):   \n    # Sort slices by initial contact time\n    data_slices.sort(key=lambda s: s[-1].start)\n\n    # Get the centroid for each paw impact...\n    paw_coords = []\n    for x,y,z in data_slices:\n        paw_coords.append([(item.stop + item.start) / 2.0 for item in (x,y)])\n    paw_coords = np.array(paw_coords)\n\n    # Make a vector between each sucessive impact...\n    dx, dy = np.diff(paw_coords, axis=0).T\n\n    #-- Group paws -------------------------------------------\n    paw_code = {0:'LF', 1:'RH', 2:'RF', 3:'LH'}\n    paw_number = np.arange(len(paw_coords))\n\n    # Did we miss the hind paw impact after the first \n    # front paw impact? If so, first dx will be positive...\n    if dx[0] &gt; 0: \n        paw_number[1:] += 1\n\n    # Are we starting with the left or right front paw...\n    # We assume we're starting with the left, and check dy[0].\n    # If dy[0] &gt; 0 (i.e. the next paw impacts to the left), then\n    # it's actually the right front paw, instead of the left.\n    if dy[0] &gt; 0: # Right front paw impact...\n        paw_number += 2\n\n    # Now we can determine the paw with a simple modulo 4..\n    paw_codes = paw_number % 4\n    paw_labels = [paw_code[code] for code in paw_codes]\n\n    return paw_labels\n</code>\n</pre>\n", "senID": 15}, {"text": ["In spite of all of this, it frequently doesn't work correctly.", "Many of the dogs in the full dataset appear to be running, and the paw impacts don't follow the same temporal order as when the dog is walking.", "(Or perhaps the dog just has severe hip problems...)"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"src": "http://i.stack.imgur.com/DwXZ5.png", "tag": "img", "senID": 17}, {"text": ["Fortunately, we can still programatically detect whether or not the paw impacts follow our expected spatial pattern:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n def paw_pattern_problems(paw_labels, dx, dy):\n    \"\"\"Check whether or not the label sequence \"paw_labels\" conforms to our\n    expected spatial pattern of paw impacts. \"paw_labels\" should be a sequence\n    of the strings: \"LH\", \"RH\", \"LF\", \"RF\" corresponding to the different paws\"\"\"\n    # Check for problems... (This could be written a _lot_ more cleanly...)\n    problems = False\n    last = paw_labels[0]\n    for paw, dy, dx in zip(paw_labels[1:], dy, dx):\n        # Going from a left paw to a right, dy should be negative\n        if last.startswith('L') and paw.startswith('R') and (dy &gt; 0):\n            problems = True\n            break\n        # Going from a right paw to a left, dy should be positive\n        if last.startswith('R') and paw.startswith('L') and (dy &lt; 0):\n            problems = True\n            break\n        # Going from a front paw to a hind paw, dx should be negative\n        if last.endswith('F') and paw.endswith('H') and (dx &gt; 0):\n            problems = True\n            break\n        # Going from a hind paw to a front paw, dx should be positive\n        if last.endswith('H') and paw.endswith('F') and (dx &lt; 0):\n            problems = True\n            break\n        last = paw\n    return problems\n</code>\n</pre>\n", "senID": 19}, {"text": ["Therefore, even though the simple spatial classification doesn't work all of the time, we can determine when it does work with reasonable confidence.  "], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"text": ["Training Dataset"], "childNum": 1, "tag": "p", "senID": 21, "childList": [{"text": "Training Dataset", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["From the pattern-based classifications where it worked correctly, we can build up a very large training dataset of correctly classified paws (~2400 paw impacts from 32 different dogs!", ").  "], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"text": ["We can now start to look at what an \"average\" front left, etc, paw looks like."], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"text": ["To do this, we need some sort of \"paw metric\" that is the same dimensionality for any dog.", "(In the full dataset, there are both very large and very small dogs!", ")  A paw print from an Irish elkhound will be both much wider and much \"heavier\" than a paw print from a toy poodle.", "We need to rescale each paw print so that a) they have the same number of pixels, and b) the pressure values are standardized.", "To do this, I resampled each paw print onto a 20x20 grid and rescaled the pressure values based on the maximum, mininum, and mean pressure value for the paw impact. "], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"code": "<pre>\n<code>\n def paw_image(paw):\n    from scipy.ndimage import map_coordinates\n    ny, nx = paw.shape\n\n    # Trim off any \"blank\" edges around the paw...\n    mask = paw &gt; 0.01 * paw.max()\n    y, x = np.mgrid[:ny, :nx]\n    ymin, ymax = y[mask].min(), y[mask].max()\n    xmin, xmax = x[mask].min(), x[mask].max()\n\n    # Make a 20x20 grid to resample the paw pressure values onto\n    numx, numy = 20, 20\n    xi = np.linspace(xmin, xmax, numx)\n    yi = np.linspace(ymin, ymax, numy)\n    xi, yi = np.meshgrid(xi, yi)  \n\n    # Resample the values onto the 20x20 grid\n    coords = np.vstack([yi.flatten(), xi.flatten()])\n    zi = map_coordinates(paw, coords)\n    zi = zi.reshape((numy, numx))\n\n    # Rescale the pressure values\n    zi -= zi.min()\n    zi /= zi.max()\n    zi -= zi.mean() #&lt;- Helps distinguish front from hind paws...\n    return zi\n</code>\n</pre>\n", "senID": 25}, {"text": ["After all of this, we can finally take a look at what an average left front, hind right, etc paw looks like.", "Note that this is averaged across >30 dogs of greatly different sizes, and we seem to be getting consistent results!"], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"src": "http://i.stack.imgur.com/1rcSk.png", "tag": "img", "senID": 27}, {"text": ["However, before we do any analysis on these, we need to subtract the mean (the average paw for all legs of all dogs)."], "childNum": 0, "tag": "p", "senID": 28, "childList": []}, {"src": "http://i.stack.imgur.com/y6sbC.png", "tag": "img", "senID": 29}, {"text": ["Now we can analyize the differences from the mean, which are a bit easier to recognize:"], "childNum": 0, "tag": "p", "senID": 30, "childList": []}, {"src": "http://i.stack.imgur.com/JkNR7.png", "tag": "img", "senID": 31}, {"text": ["Image-based Paw Recognition"], "childNum": 1, "tag": "p", "senID": 32, "childList": [{"text": "Image-based Paw Recognition", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Ok... We finally have a set of patterns that we can begin to try to match the paws against.", "Each paw can be treated as a 400-dimensional vector (returned by the paw_image function) that can be compared to these four 400-dimensional vectors.  "], "childNum": 1, "tag": "p", "senID": 33, "childList": [{"text": "paw_image", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Unfortunately, if we just use a \"normal\" supervised classification algorithm (i.e.", "find which of the 4 patterns is closest to a particular paw print using a simple distance), it doesn't work consistently.", "In fact, it doesn't do much better than random chance on the training dataset."], "childNum": 0, "tag": "p", "senID": 34, "childList": []}, {"text": ["This is a common problem in image recognition.", "Due to the high dimensionality of the input data, and the somewhat \"fuzzy\" nature of images (i.e.", "adjacent pixels have a high covariance), simply looking at the difference of an image from a template image does not give a very good measure of the similarity of their shapes.  "], "childNum": 0, "tag": "p", "senID": 35, "childList": []}, {"text": ["Eigenpaws"], "childNum": 1, "tag": "p", "senID": 36, "childList": [{"text": "Eigenpaws", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["To get around this we need to build a set of \"eigenpaws\" (just like \"eigenfaces\" in facial recognition), and describe each paw print as a combination of these eigenpaws.", "This is identical to principal components analysis, and basically provides a way to reduce the dimensionality of our data, so that distance is a good measure of shape."], "childNum": 0, "tag": "p", "senID": 37, "childList": []}, {"text": ["Because we have more training images than dimensions (2400 vs 400), there's no need to do \"fancy\" linear algebra for speed.", "We can work directly with the covariance matrix of the training data set:"], "childNum": 0, "tag": "p", "senID": 38, "childList": []}, {"code": "<pre>\n<code>\n def make_eigenpaws(paw_data):\n    \"\"\"Creates a set of eigenpaws based on paw_data.\n    paw_data is a numdata by numdimensions matrix of all of the observations.\"\"\"\n    average_paw = paw_data.mean(axis=0)\n    paw_data -= average_paw\n\n    # Determine the eigenvectors of the covariance matrix of the data\n    cov = np.cov(paw_data.T)\n    eigvals, eigvecs = np.linalg.eig(cov)\n\n    # Sort the eigenvectors by ascending eigenvalue (largest is last)\n    eig_idx = np.argsort(eigvals)\n    sorted_eigvecs = eigvecs[:,eig_idx]\n    sorted_eigvals = eigvals[:,eig_idx]\n\n    # Now choose a cutoff number of eigenvectors to use \n    # (50 seems to work well, but it's arbirtrary...\n    num_basis_vecs = 50\n    basis_vecs = sorted_eigvecs[:,-num_basis_vecs:]\n\n    return basis_vecs\n</code>\n</pre>\n", "senID": 39}, {"text": ["These basis_vecs are the \"eigenpaws\"."], "childNum": 1, "tag": "p", "senID": 40, "childList": [{"text": "basis_vecs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"src": "http://i.stack.imgur.com/NamaF.png", "tag": "img", "senID": 41}, {"text": ["To use these, we simply dot (i.e.", "matrix multiplication) each paw image (as a 400-dimensional vector, rather than a 20x20 image) with the basis vectors.", "This gives us a 50-dimensional vector (one element per basis vector) that we can use to classify the image.", "Instead of comparing a 20x20 image to the 20x20 image of each \"template\" paw, we compare the 50-dimensional, transformed image to each 50-dimensional transformed template paw.", "This is much less sensitive to small variations in exactly how each toe is positioned, etc, and basically reduces the dimensionality of the problem to just the relevant dimensions."], "childNum": 0, "tag": "p", "senID": 42, "childList": []}, {"text": ["Eigenpaw-based Paw Classification"], "childNum": 1, "tag": "p", "senID": 43, "childList": [{"text": "Eigenpaw-based Paw Classification", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Now we can simply use the distance between the 50-dimensional vectors and the \"template\" vectors for each leg to classify which paw is which:"], "childNum": 0, "tag": "p", "senID": 44, "childList": []}, {"code": "<pre>\n<code>\n codebook = np.load('codebook.npy') # Template vectors for each paw\naverage_paw = np.load('average_paw.npy')\nbasis_stds = np.load('basis_stds.npy') # Needed to \"whiten\" the dataset...\nbasis_vecs = np.load('basis_vecs.npy')\npaw_code = {0:'LF', 1:'RH', 2:'RF', 3:'LH'}\ndef classify(paw):\n    paw = paw.flatten()\n    paw -= average_paw\n    scores = paw.dot(basis_vecs) / basis_stds\n    diff = codebook - scores\n    diff *= diff\n    diff = np.sqrt(diff.sum(axis=1))\n    return paw_code[diff.argmin()]\n</code>\n</pre>\n", "senID": 45}, {"text": ["Here are some of the results:\n\n\n"], "childNum": 3, "tag": "p", "senID": 46, "childList": [{"text": "", "childNum": 0, "tag": "img", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "img", "childList": []}, {"text": "", "childNum": 0, "tag": "img", "childList": []}]}, {"text": ["Remaining Problems"], "childNum": 1, "tag": "p", "senID": 47, "childList": [{"text": "Remaining Problems", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["There are still some problems, particularly with dogs too small to make a clear pawprint... (It works best with large dogs, as the toes are more clearly seperated at the sensor's resolution.", ") Also, partial pawprints aren't recognized with this system, while they can be with the trapezoidal-pattern-based system. "], "childNum": 0, "tag": "p", "senID": 48, "childList": []}, {"text": ["However, because the eigenpaw analysis inherently uses a distance metric, we can classify the paws both ways, and fall back to the trapezoidal-pattern-based system when the eigenpaw analysis's smallest distance from the \"codebook\" is over some threshold.", "I haven't implemented this yet, though."], "childNum": 0, "tag": "p", "senID": 49, "childList": []}, {"text": ["Phew... That was long!", "My hat is off to Ivo for having such a fun question!"], "childNum": 0, "tag": "p", "senID": 50, "childList": []}], [{"text": ["Using the information purely based on duration, I think you could apply techniques from modeling kinematics; namely Inverse Kinematics.", "Combined with orientation, length, duration, and total weight it gives some level of periodicity which, I would hope could be the first step trying to solve your \"sorting of paws\" problem."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Inverse Kinematics", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Inverse_kinematics"}]}, {"text": ["All that data could be used to create a list of bounded polygons (or tuples), which you could use to sort by step size then by paw-ness [index]."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Can you have the technician running the test manually enter the first paw (or first two)?", "The process might be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Show tech the order of steps image and require them to annotate the first paw.", "tag": "none", "senID": 1}, {"text": "Label the other paws based on the first paw and allow the tech to make corrections or re-run the test. This allows for lame or 3-legged dogs.", "tag": "none", "senID": 2}]}]]