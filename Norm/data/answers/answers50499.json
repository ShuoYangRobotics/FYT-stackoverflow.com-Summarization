[[{"text": ["__file__ is the answer, however, it is relative to the path, so you'll need to use    os.path.abspath(__file__) to get the actual path to the file"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__file__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "os.path.abspath(__file__)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["e.g."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import os\n\ndef h():\n    print os.path.abspath( __file__ )\n</code>\n</pre>\n", "senID": 2}], [{"text": ["p1.py:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n execfile(\"p2.py\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["p2.py:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import inspect\nprint inspect.getfile( inspect.currentframe() )\n</code>\n</pre>\n", "senID": 3}], [{"text": ["It's not entirely clear what you mean by \"the filepath of the file that is currently running within the process\".", "sys.argv[0] usually contains the location of the script that was invoked by the Python interpreter.", "Check the sys documentation for more details."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sys.argv[0]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "sys documentation", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-sys.html"}]}, {"text": ["As @Tim and @Pat Notz have pointed out, the __file__ attribute provides access to"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Tim", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "#50521"}, {"href": "#50505", "text": "Pat Notz", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["The suggestions marked as best are all true if your script consists of only one file. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want to find out the name of the executable (i.e.", "the root file passed to the python interpreter for the current program) from a file that may be imported as a module, you need to do this (let's assume this is in a file named foo.py):"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "foo.py", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["import inspect"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "import inspect", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["print inspect.stack()[-1][1]"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "print inspect.stack()[-1][1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Because the last thing ([-1]) on the stack is the first thing that went into it (stacks are LIFO/FILO data structures)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "[-1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Then in file bar.py if you import foo it'll print bar.py, rather than foo.py, which would be the value of all of these:"], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "bar.py", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "import foo", "childNum": 0, "tag": "code", "childList": []}, {"text": "bar.py", "childNum": 0, "tag": "em", "childList": []}, {"text": "foo.py", "childNum": 0, "tag": "em", "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": ["__file__"], "childNum": 0, "tag": "code", "senID": 6, "childList": []}, {"text": ["inspect.getfile(inspect.currentframe())"], "childNum": 0, "tag": "code", "senID": 7, "childList": []}, {"text": ["inspect.stack()[0][1]"], "childNum": 0, "tag": "code", "senID": 8, "childList": []}]}], [{"text": ["The \"file\" attribute works for both the file containing the main execution code as well as imported modules http://pyref.infogami.com/__file__"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "file", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://pyref.infogami.com/__file__", "text": "http://pyref.infogami.com/__file__", "childNum": 0, "tag": "a", "childList": []}]}], [{"code": "<pre>\n<code>\n import sys\nprint sys.argv[0]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I think it's just __file__   Sounds like you may also want to checkout the inspect module."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__file__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/lib/module-inspect.html", "text": "inspect module", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Ugh.", "Stupid markdown... try \"underscore underscore file underscore underscore\""], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You can use inspect.stack()"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import inspect\ninspect.stack()[0]  =&gt; (&lt;frame object at 0x00AC2AC0&gt;, 'g:\\\\Python\\\\Test\\\\_GetCurrentProgram.py', 15, '&lt;module&gt;', ['print inspect.stack()[0]\\n'], 0)\nos.path.abspath (inspect.stack()[0][1]) =&gt; 'g:\\\\Python\\\\Test\\\\_GetCurrentProgram.py'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["__file__ as others have said.", "You may want to use os.realpath(__file__), however, in case it's a symlink"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__file__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "os.realpath(__file__)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"code": "<pre>\n<code>\n import sys\n\nprint sys.path[0]\n</code>\n</pre>\n", "senID": 0}, {"text": ["this would print the path of the currently executing script"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I used the approach with __file__\nos.path.abspath(__file__)\nbut there is a little trick, it returns the .py file \nwhen the code is run the first time, \nnext runs give the name of *.pyc file\nso I stayed with:\ninspect.getfile(inspect.currentframe())\nor\nsys._getframe().f_code.co_filename "], "childNum": 9, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "os.path.abspath(__file__)", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "inspect.getfile(inspect.currentframe())", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "sys._getframe().f_code.co_filename", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I think this is cleaner:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n print inspect.stack()[0][1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["and gets the same information as:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n print inspect.getfile(inspect.currentframe())\n</code>\n</pre>\n", "senID": 3}, {"text": ["Where [0] is the current frame in the stack (top of stack) and [1] is for the file name, increase to go backwards in the stack i.e."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n print inspect.stack()[1][1]\n</code>\n</pre>\n", "senID": 5}, {"text": ["would be the file name of the script that called the current frame.", "Also, using [-1] will get you to the bottom of the stack, the original calling script."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]