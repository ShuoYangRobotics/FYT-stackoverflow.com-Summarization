[[{"text": ["From Magnus Lycka answer on a mailing list:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Magnus Lycka answer on a mailing list", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/tutor/2003-November/026645.html"}]}], [{"code": "<pre>\n<code>\n # reopen stdout file descriptor with write mode\n# and 0 as the buffer size (unbuffered)\nsys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Credits: \"Sebastian\", somewhere on the Python mailing list."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Yes, it is."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can disable it on the commandline with the \"-u\" switch."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Alternatively, you could call .flush() on sys.stdout on every write (or wrap it with an object that does this automatically)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["One way to get unbuffered output would be to use sys.stderr instead of sys.stdout or to simply call sys.stdout.flush() to explicitly force a write to occur."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "sys.stderr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sys.stdout", "childNum": 0, "tag": "code", "childList": []}, {"text": "sys.stdout.flush()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You could easily redirect everything printed by doing:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import sys; sys.stdout = sys.stderr\nprint \"Hello World!\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["Or to redirect just for a particular print statement:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "print", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n print &gt;&gt;sys.stderr, \"Hello World!\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["To reset stdout you can just do:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n sys.stdout = sys.__stdout__\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Yes, it is enabled by default.", "You can disable it by using the -u option on the command line when calling python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can create an unbuffered file and assign this file to sys.stdout."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys \nmyFile= open( \"a.log\", \"w\", 0 ) \nsys.stdout= myFile\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can't magically change the system-supplied stdout; since it's supplied to your python program by the OS."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can also use fcntl to change the file flags in-fly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fl = fcntl.fcntl(fd.fileno(), fcntl.F_GETFL)\nfl |= os.O_SYNC # or os.O_DSYNC (if you don't care the file timestamp updates)\nfcntl.fcntl(fd.fileno(), fcntl.F_SETFL, fl)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def disable_stdout_buffering():\n    # Appending to gc.garbage is a way to stop an object from being\n    # destroyed.  If the old sys.stdout is ever collected, it will\n    # close() stdout, which is not good.\n    gc.garbage.append(sys.stdout)\n    sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)\n\n# Then this will give output in the correct order:\ndisable_stdout_buffering()\nprint \"hello\"\nsubprocess.call([\"echo\", \"bye\"])\n</code>\n</pre>\n", "senID": 0}, {"text": ["Without saving the old sys.stdout, disable_stdout_buffering() isn't idempotent, and multiple calls will result in an error like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n Traceback (most recent call last):\n  File \"test/buffering.py\", line 17, in &lt;module&gt;\n    print \"hello\"\nIOError: [Errno 9] Bad file descriptor\nclose failed: [Errno 9] Bad file descriptor\n</code>\n</pre>\n", "senID": 2}, {"text": ["Another possibility is:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def disable_stdout_buffering():\n    fileno = sys.stdout.fileno()\n    temp_fd = os.dup(fileno)\n    sys.stdout.close()\n    os.dup2(temp_fd, fileno)\n    os.close(temp_fd)\n    sys.stdout = os.fdopen(fileno, \"w\", 0)\n</code>\n</pre>\n", "senID": 4}, {"text": ["(Appending to gc.garbage is not such a good idea because it's where unfreeable cycles get put, and you might want to check for those."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]