[[{"text": ["I like using any and a generator:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "any", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if any(pred(x.item) for x in sequence):\n    ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["instead of code written like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n found = False\nfor x in sequence:\n    if pred(x.n):\n        found = True\nif found:\n    ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["I first learned of this technique from a Peter Norvig article."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "article", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://norvig.com/sudoku.html"}]}], [{"text": ["The only 'trick' I know that really wowed me when I learned it is enumerate.", "It allows you to have access to the indexes of the elements within a for loop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l = ['a','b','c','d','e','f']\n&gt;&gt;&gt; for (index,value) in enumerate(l):\n...     print index, value\n... \n0 a\n1 b\n2 c\n3 d\n4 e\n5 f\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Initializing a 2D list"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["While this can be done safely to initialize a list:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n lst = [0] * 3\n</code>\n</pre>\n", "senID": 2}, {"text": ["The same trick won\u2019t work for a 2D list (list of lists):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; lst_2d = [[0] * 3] * 3\n&gt;&gt;&gt; lst_2d\n[[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n&gt;&gt;&gt; lst_2d[0][0] = 5\n&gt;&gt;&gt; lst_2d\n[[5, 0, 0], [5, 0, 0], [5, 0, 0]]\n</code>\n</pre>\n", "senID": 4}, {"text": ["The operator * duplicates its operands, and duplicated lists constructed with [] point to the same list.", "The correct way to do this is:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; lst_2d = [[0] * 3 for i in xrange(3)]\n&gt;&gt;&gt; lst_2d\n[[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n&gt;&gt;&gt; lst_2d[0][0] = 5\n&gt;&gt;&gt; lst_2d\n[[5, 0, 0], [0, 0, 0], [0, 0, 0]]\n</code>\n</pre>\n", "senID": 6}], [{"text": ["zip(*iterable) transposes an iterable."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "zip(*iterable)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a=[[1,2,3],[4,5,6]]\n&gt;&gt;&gt; zip(*a)\n    [(1, 4), (2, 5), (3, 6)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's also useful with dicts."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d={\"a\":1,\"b\":2,\"c\":3}\n&gt;&gt;&gt; zip(*d.iteritems())\n[('a', 'c', 'b'), (1, 3, 2)]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["To flatten a list of lists, such as"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [['a', 'b'], ['c'], ['d', 'e', 'f']]\n</code>\n</pre>\n", "senID": 1}, {"text": ["into"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ['a', 'b', 'c', 'd', 'e', 'f']\n</code>\n</pre>\n", "senID": 3}, {"text": ["use"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n [inner\n    for outer in the_list\n        for inner in outer]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Huge speedup for nested list and dictionaries with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n deepcopy = lambda x: cPickle.loads(cPickle.dumps(x))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A \"progress bar\" that looks like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n |#############################---------------------|\n59 percent done\n</code>\n</pre>\n", "senID": 1}, {"text": ["Code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class ProgressBar():\n    def __init__(self, width=50):\n        self.pointer = 0\n        self.width = width\n\n    def __call__(self,x):\n         # x in percent\n         self.pointer = int(self.width*(x/100.0))\n         return \"|\" + \"#\"*self.pointer + \"-\"*(self.width-self.pointer)+\\\n                \"|\\n %d percent done\" % int(x)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Test function (for windows system, change \"clear\" into \"CLS\"):"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n if __name__ == '__main__':\n    import time, os\n    pb = ProgressBar()\n    for i in range(101):\n        os.system('clear')\n        print pb(i)\n        time.sleep(0.1)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Suppose you have a list of items, and you want a dictionary with these items as the keys.", "Use fromkeys:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; items = ['a', 'b', 'c', 'd']\n&gt;&gt;&gt; idict = dict().fromkeys(items, 0)\n&gt;&gt;&gt; idict\n{'a': 0, 'c': 0, 'b': 0, 'd': 0}\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["The second argument of fromkeys is the value to be granted to all the newly created keys."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["To find out if line is empty (i.e.", "either size 0 or contains only whitespace), use the string method strip in a condition, as follows:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if not line.strip():    # if line is empty\n    continue            # skip it\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Hardlink identical files in current directory (on unix, this means they have share physical storage, meaning much less space):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\nimport hashlib\n\ndupes = {}\n\nfor path, dirs, files in os.walk(os.getcwd()):\n    for file in files:\n        filename = os.path.join(path, file)\n        hash = hashlib.sha1(open(filename).read()).hexdigest()\n        if hash in dupes:\n            print 'linking \"%s\" -&gt; \"%s\"' % (dupes[hash], filename)\n            os.rename(filename, filename + '.bak')\n            try:\n                os.link(dupes[hash], filename)\n                os.unlink(filename + '.bak')\n            except:\n                os.rename(filename + '.bak', filename)\n            finally:\n        else:\n            dupes[hash] = filename\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I like this one to zip everything up in a directory.", "Hotkey it for instabackups!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import zipfile\n\nz = zipfile.ZipFile('my-archive.zip', 'w', zipfile.ZIP_DEFLATED)\nstartdir = \"/home/johnf\"\nfor dirpath, dirnames, filenames in os.walk(startdir):\n  for filename in filenames:\n    z.write(os.path.join(dirpath, filename))\nz.close()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["For list comprehensions that need current, next:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [fun(curr,next) \n for curr,next \n in zip(list,list[1:].append(None)) \n if condition(curr,next)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["For circular list zip(list,list[1:].append(list[0]))."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "zip(list,list[1:].append(list[0]))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For previous, current: zip([None].extend(list[:-1]),list) circular: zip([list[-1]].extend(list[:-1]),list)"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "zip([None].extend(list[:-1]),list)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "zip([list[-1]].extend(list[:-1]),list)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Here are few which I think are worth knowing but might not be useful on an everyday basis.", "Most of them are one liners."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Removing Duplicates from a List"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n L = list(set(L))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Getting Integers from a string (space seperated)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n ints = [int(x) for x in S.split()]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Finding Factorial"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n fac=lambda(n):reduce(int.__mul__,range(1,n+1),1)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Finding greatest common divisor"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def gcd(a,b):\n...     while(b):a,b=b,a%b\n...     return a\n</code>\n</pre>\n", "senID": 8}], [{"text": ["For Python 2.4+ or earlier:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for x,y in someIterator:\n  listDict.setdefault(x,[]).append(y)\n</code>\n</pre>\n", "senID": 1}, {"text": ["In Python 2.5+ there is alternative using defaultdict."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "defaultdict", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html#collections.defaultdict"}]}], [{"text": ["A custom list that when multiplied by other list returns a cartesian product... the good thing is that the cartesian product is indexable, not like that of itertools.product (but the multiplicands must be sequences, not iterators)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\n\nclass mylist(list):\n    def __getitem__(self, args):\n    \tif type(args) is tuple:\n    \t\treturn [list.__getitem__(self, i) for i in args]\n    \telse:\n    \t\treturn list.__getitem__(self, args)\n    def __mul__(self, args):\n    \tseqattrs = (\"__getitem__\", \"__iter__\", \"__len__\")\n    \tif all(hasattr(args, i) for i in seqattrs):\n    \t\treturn cartesian_product(self, args)\n    \telse:\n    \t\treturn list.__mul__(self, args)\n    def __imul__(self, args):\n    \treturn __mul__(self, args)\n    def __rmul__(self, args):\n    \treturn __mul__(args, self)\n    def __pow__(self, n):\n    \treturn cartesian_product(*((self,)*n))\n    def __rpow__(self, n):\n    \treturn cartesian_product(*((self,)*n))\n\nclass cartesian_product:\n    def __init__(self, *args):\n    \tself.elements = args\n    def __len__(self):\n    \treturn reduce(operator.mul, map(len, self.elements))\n    def __getitem__(self, n):\n    \treturn [e[i] for e, i  in zip(self.elements,self.get_indices(n))]\n    def get_indices(self, n):\n    \tsizes = map(len, self.elements)\n    \ttmp = [0]*len(sizes)\n    \ti = -1\n    \tfor w in reversed(sizes):\n    \t\ttmp[i] = n % w\n    \t\tn /= w\n    \t\ti -= 1\n    \treturn tmp\n    def __add__(self, arg):\n    \treturn mylist(map(None, self)+mylist(map(None, arg)))\n    def __imul__(self, args):\n    \treturn mylist(self)*mylist(args)\n    def __rmul__(self, args):\n    \treturn mylist(args)*mylist(self)\n    def __mul__(self, args):\n    \tif isinstance(args, cartesian_product):\n    \t\treturn cartesian_product(*(self.elements+args.elements))\n    \telse:\n    \t\treturn cartesian_product(*(self.elements+(args,)))\n    def __iter__(self):\n    \tfor i in xrange(len(self)):\n    \t\tyield self[i]\n    def __str__(self):\n    \treturn \"[\" + \",\".join(str(i) for i in self) +\"]\"\n    def __repr__(self):\n    \treturn \"*\".join(map(repr, self.elements))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Emulating a switch statement.", "For example switch(x) {..}:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def a():\n  print \"a\"\n\ndef b():\n  print \"b\"\n\ndef default():\n   print \"default\"\n\napply({1:a, 2:b}.get(x, default))\n</code>\n</pre>\n", "senID": 1}], [{"tag": "ul", "num": 4, "lis": [{"text": ["like another person above, I said 'Wooww !!", "' when I discovered enumerate()"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "enumerate()", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["I sang a praise to Python when I discovered repr() that gave me possibility to see precisely the content of strings that I wanted to analyse with a regex"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "repr()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I was very satisfied to discover that print '\\n'.join(list_of_strings) is displayed much more rapidly with '\\n'.join(...) than for ch  in list_of_strings: print ch"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "print '\\n'.join(list_of_strings)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'\\n'.join(...)", "childNum": 0, "tag": "strong", "childList": []}, {"text": "for ch  in list_of_strings: print ch", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["splitlines(1) with an argument keeps the newlines"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "splitlines(1)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}]}, {"text": ["These four \"tricks\" combined in one snippet very useful to rapidly display the code source of a web page , line after line, each line being numbered , all the special characters like '\\t' or newlines being not interpreted, and with the newlines present:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import urllib\nfrom time import clock,sleep\n\nsock = urllib.urlopen('http://docs.python.org/')\nch = sock.read()\nsock.close()\n\n\nte = clock()\nfor i,line in enumerate(ch.splitlines(1)):\n    print str(i) + ' ' + repr(line)\nt1 = clock() - te\n\n\nprint \"\\n\\nIn 3 seconds, I will print the same content, using '\\\\n'.join(....)\\n\" \n\nsleep(3)\n\nte = clock()\n# here's the point of interest:\nprint '\\n'.join(str(i) + ' ' + repr(line)\n                for i,line in enumerate(ch.splitlines(1)) )\nt2 = clock() - te\n\nprint '\\n'\nprint 'first  display took',t1,'seconds'\nprint 'second display took',t2,'seconds'\n</code>\n</pre>\n", "senID": 5}, {"text": ["With my not very fast computer, I got:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n first  display took 4.94626048841 seconds\nsecond display took 0.109297410704 seconds\n</code>\n</pre>\n", "senID": 7}], [{"code": "<pre>\n<code>\n import tempfile\nimport cPickle\n\nclass DiskFifo:\n    \"\"\"A disk based FIFO which can be iterated, appended and extended in an interleaved way\"\"\"\n    def __init__(self):\n        self.fd = tempfile.TemporaryFile()\n        self.wpos = 0\n        self.rpos = 0\n        self.pickler = cPickle.Pickler(self.fd)\n        self.unpickler = cPickle.Unpickler(self.fd)\n        self.size = 0\n\n    def __len__(self):\n        return self.size\n\n    def extend(self, sequence):\n        map(self.append, sequence)\n\n    def append(self, x):\n        self.fd.seek(self.wpos)\n        self.pickler.clear_memo()\n        self.pickler.dump(x)\n        self.wpos = self.fd.tell()\n        self.size = self.size + 1\n\n    def next(self):\n        try:\n            self.fd.seek(self.rpos)\n            x = self.unpickler.load()\n            self.rpos = self.fd.tell()\n            return x\n\n        except EOFError:\n            raise StopIteration\n\n    def __iter__(self):\n        self.rpos = 0\n        return self\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Fire up a simple web server for files in the current directory:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n python -m SimpleHTTPServer\n</code>\n</pre>\n", "senID": 1}, {"text": ["Useful for sharing files."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]