[[{"text": ["Why not look at the code for bisect_left/right and adapt it to suit your purpose."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def binary_search(a, x, lo=0, hi=None):\n    if hi is None:\n        hi = len(a)\n    while lo &lt; hi:\n        mid = (lo+hi)//2\n        midval = a[mid]\n        if midval &lt; x:\n            lo = mid+1\n        elif midval &gt; x: \n            hi = mid\n        else:\n            return mid\n    return -1\n</code>\n</pre>\n", "senID": 2}], [{"text": ["This is a little off-topic (since Moe's answer seems complete to the OP's question), but it might be worth looking at the complexity for your whole procedure from end to end.", "If you're storing thing in a sorted lists (which is where a binary search would help), and then just checking for existence, you're incurring (worst-case, unless specified):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Sorted Lists"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Sorted Lists", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "O( n log n) to initially create the list (if it's unsorted data, or O(n) )", "tag": "none", "senID": 2}, {"text": "O( log n) lookup", "tag": "none", "senID": 3}, {"text": "O( n ) insert / delete  (might be O(1) or O(log n) average case, depending on your pattern)", "tag": "none", "senID": 4}]}, {"text": ["Whereas with a set, you're incurring"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "set", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "O(n) to create", "tag": "none", "senID": 6}, {"text": "O(1) lookup", "tag": "none", "senID": 7}, {"text": "O(1) insert / delete", "tag": "none", "senID": 8}]}, {"text": ["The thing a sorted list really gets you are \"next\", \"previous\", and \"ranges\" (including inserting or deleting ranges), which are O(1) or O(|range|), given a starting index.", "If you aren't using those sorts of operations often, then storing as sets, and sorting for display might be a better deal overall.", "set() incurs very little additional overhead in python.  "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["Simplest is to use bisect and check one position back to see if the item is there:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "bisect", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/bisect.html"}]}, {"code": "<pre>\n<code>\n def binary_search(a,x,lo=0,hi=-1):\n    i = bisect(a,x,lo,hi)\n    if i == 0:\n        return -1\n    elif a[i-1] == x:\n        return i-1\n    else:\n        return -1\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n from bisect import bisect_left\n\ndef binary_search(a, x, lo=0, hi=None):   # can't use a to specify default for hi\n    hi = hi if hi is not None else len(a) # hi defaults to len(a)   \n    pos = bisect_left(a,x,lo,hi)          # find insertion position\n    return (pos if pos != hi and a[pos] == x else -1) # don't walk off the end\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If you just want to see if it's present, try turning the list into a dict:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # Generate a list\nl = [n*n for n in range(1000)]\n\n# Convert to dict - doesn't matter what you map values to\nd = dict((x, 1) for x in l)\n\ncount = 0\nfor n in range(1000000):\n    # Compare with \"if n in l\"\n    if n in d:\n        count += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["On my machine, \"if n in l\" took 37 seconds, while \"if n in d\" took 0.4 seconds."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Using a dict wouldn't like double your memory usage unless the objects you're storing are really tiny, since the values are only pointers to the actual objects:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = 'foo'\n&gt;&gt;&gt; b = [a]\n&gt;&gt;&gt; c = [a]\n&gt;&gt;&gt; b[0] is c[0]\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["In that example, 'foo' is only stored once.", "Does that make a difference for you?", "And exactly how many items are we talking about anyway?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It might be worth mentioning that the bisect docs now provide searching examples:\nhttp://docs.python.org/library/bisect.html#searching-sorted-lists"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/bisect.html#searching-sorted-lists", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/bisect.html#searching-sorted-lists"}]}, {"text": ["(Raising ValueError instead of returning -1 or None is more pythonic \u2013 list.index() does it, for example.", "But of course you can adapt the examples to your needs."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]