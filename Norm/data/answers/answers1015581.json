[[{"text": ["This feature has been added to PyDev 2.0.1 with an option to relaunch the tests in the last test run whenever a python file change, with an additional option to rerun only the errors -- although it'll run the full test suite if no errors were found, as the idea is that you work through your errors and when all pass a final launch for the whole suite is done (then you can move on to another task)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The current nightly build has this feature incorporated."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"src": "http://i.stack.imgur.com/ZZgWk.png", "tag": "img", "senID": 2}], [{"text": ["Pydev does have some unit-test integration, but that's only as a run configuration...so..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is not a very elegant way, but if you:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Then at least you will get something that outputs the test results to the console on resource saves."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I just realized that PyDev has rather powerful scripting support.", "Unfortunately I don't have the time to do it all for you (but if you complete this, please post it here :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you create a file named pyedit_nose.py that looks like this in an otherwise empty folder :"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "pyedit_nose.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n assert cmd is not None\nassert editor is not None\n\nif cmd == 'onSave':\n    from java.lang import Runtime\n    from java.io import BufferedReader\n    from java.io import InputStreamReader\n\n    from org.eclipse.core.resources import ResourcesPlugin\n    from org.eclipse.core.resources import IMarker\n    from org.eclipse.core.resources import IResource\n\n    proc = Runtime.getRuntime().exec('ls -al')\n    extra_message = BufferedReader(InputStreamReader(proc.inputStream)).readLine()\n\n    r = ResourcesPlugin.getWorkspace().getRoot()\n    for marker in r.findMarkers(IMarker.PROBLEM, False, IResource.DEPTH_INFINITE):\n        if marker.getAttribute(IMarker.MESSAGE).startsWith(\"Some test failed!\"):\n            marker.delete()\n\n    for rr in r.getProjects():\n        marker = rr.createMarker(IMarker.PROBLEM)\n        marker.setAttribute(IMarker.MESSAGE, \"Some test failed! \" + extra_message)\n        marker.setAttribute(IMarker.PRIORITY, IMarker.PRIORITY_HIGH)\n        marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR)\n</code>\n</pre>\n", "senID": 2}, {"text": ["and set up Preferences->PyDev->Scripting Pydev to point to this directory you will get all projects in your workspace marked with an error every time a file is saved."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["By executing a script that returns the test results in some easy to parse format rather than ls and parsing the output you should be able to put your markers in the right places."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "ls", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["See this for some starting points:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": ["Jython Scripting in Pydev"], "childNum": 0, "tag": "a", "senID": 6, "childList": []}, {"text": ["IMarker"], "childNum": 0, "tag": "a", "senID": 7, "childList": []}, {"text": ["IResource"], "childNum": 0, "tag": "a", "senID": 8, "childList": []}, {"text": ["IProject"], "childNum": 0, "tag": "a", "senID": 9, "childList": []}]}], [{"text": ["I am using Nosy which is handy."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Nosy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://jeffwinkler.net/2006/04/27/keeping-your-nose-green/"}]}], [{"text": ["I enhanced the \"nosy\" script to automatically build documentation and runs tests \ncontinuously.", "Nothing stellar, but gets the job done.", "Posting it here because the original\nlink went down.", "Unlike the original nosy script, this one scans the directory recursively\nand allows looking for multiple patterns."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\nimport os.path\nimport sys\nimport stat\nimport time\nimport subprocess\nfrom fnmatch import fnmatch\n\n\ndef match_patterns(pathname, patterns):\n    \"\"\"Returns True if the pathname matches any of the given patterns.\"\"\"\n    for pattern in patterns:\n        if fnmatch(pathname, pattern):\n            return True\n    return False\n\n\ndef filter_paths(pathnames, patterns=[\"*\"], ignore_patterns=[]):\n    \"\"\"Filters from a set of paths based on acceptable patterns and\n    ignorable patterns.\"\"\"\n    result = []\n    if patterns is None:\n        patterns = []\n    if ignore_patterns is None:\n        ignore_patterns = []\n    for path in pathnames:\n        if match_patterns(path, patterns) and not match_patterns(path, ignore_patterns):\n            result.append(path)\n    return result\n\n\ndef absolute_walker(path, recursive):\n    if recursive:\n        walk = os.walk\n    else:\n        def walk(path):\n            return os.walk(path).next()\n    for root, directories, filenames in walk(path):\n        yield root\n        for directory in directories:\n            yield os.path.abspath(os.path.join(root, directory))\n        for filename in filenames:\n            yield os.path.abspath(os.path.join(root, filename))\n\n\ndef glob_recursive(path, patterns=[\"*\"], ignore_patterns=[]):\n    full_paths = []\n    for root, directories, filenames in os.walk(path):\n        for filename in filenames:\n            full_path = os.path.abspath(os.path.join(root, filename))\n            full_paths.append(full_path)\n    filepaths = filter_paths(full_paths, patterns, ignore_patterns)\n    return filepaths\n\n\ndef check_sum(path='.', patterns=[\"*\"], ignore_patterns=[]):\n    sum = 0\n    for f in glob_recursive(path, patterns, ignore_patterns):\n        stats = os.stat(f)\n        sum += stats[stat.ST_SIZE] + stats[stat.ST_MTIME]\n    return sum\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) &gt; 1:\n        path = sys.argv[1]\n    else:\n        path = '.'\n\n    if len(sys.argv) &gt; 2:\n        command = sys.argv[2]\n    else:\n        command = \"make -C docs html; bin/python tests/run_tests.py\"\n\n    previous_checksum = 0\n    while True:\n        calculated_checksum = check_sum(path, patterns=['*.py', '*.rst', '*.rst.inc'])\n        if calculated_checksum != previous_checksum:\n            previous_checksum = calculated_checksum\n            subprocess.Popen(command, shell=True)\n            time.sleep(2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Hope this helps."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["=)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I run the test by hand the first time (Run > Run As > Python unit test).", "After that, I use\nCtrl+Shift+F9 to have the files saved and the tests executed, instead of saving with Ctrl+S and expecting some magic to happen. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Run > Run As > Python unit test", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "Ctrl+Shift+F9", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Ctrl+S", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The Ctrl+Shift+F9 key combination relaunches the last run configuration."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Ctrl+Shift+F9", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Disclaimer: I'm new to Eclipse and to PyDev, so I may be suggesting something silly/obvious/wrong"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Disclaimer", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}]]