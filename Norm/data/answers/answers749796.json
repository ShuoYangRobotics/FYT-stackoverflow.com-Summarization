[[{"code": "<pre>\n<code>\n import xml.dom.minidom\n\nxml = xml.dom.minidom.parse(xml_fname) # or xml.dom.minidom.parseString(xml_string)\npretty_xml_as_string = xml.toprettyxml()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["lxml is recent, updated, and includes a pretty print function"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import lxml.etree as etree\n\nx = etree.parse(\"filename\")\nprint etree.tostring(x, pretty_print = True)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Check out the lxml tutorial:\nhttp://codespeak.net/lxml/tutorial.html"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://codespeak.net/lxml/tutorial.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://codespeak.net/lxml/tutorial.html"}]}], [{"text": ["Here's my (hacky?", ") solution to get around the ugly text node problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n uglyXml = doc.toprettyxml(indent='  ')\n\ntext_re = re.compile('&gt;\\n\\s+([^&lt;&gt;\\s].*?)\\n\\s+&lt;/', re.DOTALL)    \nprettyXml = text_re.sub('&gt;\\g&lt;1&gt;&lt;/', uglyXml)\n\nprint prettyXml\n</code>\n</pre>\n", "senID": 1}, {"text": ["The above code will produce:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &lt;?xml version=\"1.0\" ?&gt;\n&lt;issues&gt;\n  &lt;issue&gt;\n    &lt;id&gt;1&lt;/id&gt;\n    &lt;title&gt;Add Visual Studio 2005 and 2008 solution files&lt;/title&gt;\n    &lt;details&gt;We need Visual Studio 2005/2008 project files for Windows.&lt;/details&gt;\n  &lt;/issue&gt;\n&lt;/issues&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["Instead of this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &lt;?xml version=\"1.0\" ?&gt;\n&lt;issues&gt;\n  &lt;issue&gt;\n    &lt;id&gt;\n      1\n    &lt;/id&gt;\n    &lt;title&gt;\n      Add Visual Studio 2005 and 2008 solution files\n    &lt;/title&gt;\n    &lt;details&gt;\n      We need Visual Studio 2005/2008 project files for Windows.\n    &lt;/details&gt;\n  &lt;/issue&gt;\n&lt;/issues&gt;\n</code>\n</pre>\n", "senID": 5}, {"text": ["Disclaimer: There are probably some limitations."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Disclaimer:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Another solution is to use this indent function: http://effbot.org/zone/element-lib.htm#prettyprint and the elementtree library that's built in to Python since 2.4.", "Here's what that would look like:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://effbot.org/zone/element-lib.htm#prettyprint", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/element-lib.htm#prettyprint"}]}, {"code": "<pre>\n<code>\n from xml.etree import ElementTree\n\ndef indent(elem, level=0):\n    i = \"\\n\" + level*\"  \"\n    if len(elem):\n        if not elem.text or not elem.text.strip():\n            elem.text = i + \"  \"\n        if not elem.tail or not elem.tail.strip():\n            elem.tail = i\n        for elem in elem:\n            indent(elem, level+1)\n        if not elem.tail or not elem.tail.strip():\n            elem.tail = i\n    else:\n        if level and (not elem.tail or not elem.tail.strip()):\n            elem.tail = i\n\nroot = ElementTree.parse('/tmp/xmlfile').getroot()\nindent(root)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you're using a DOM implementation, each has their own form of pretty-printing built-in:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # minidom\n#\ndocument.toprettyxml()\n\n# 4DOM\n#\nxml.dom.ext.PrettyPrint(document, stream)\n\n# pxdom (or other DOM Level 3 LS-compliant imp)\n#\nserializer.domConfig.setParameter('format-pretty-print', True)\nserializer.writeToString(document)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you're using something else without its own pretty-printer\u2009\u2014\u2009or those pretty-printers don't quite do it the way you want\u2009\u2014\u2009 you'd probably have to write or subclass your own serialiser."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As others pointed out, lxml has a pretty printer built in."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Be aware though that by default it changes CDATA sections to normal text, which can have nasty results."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here's a Python function that preserves the input file and only changes the indentation (notice the strip_cdata=False).", "Furthermore it makes sure the output uses UTF-8 as encoding instead of the default ASCII (notice the encoding='utf-8'):"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "strip_cdata=False", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "encoding='utf-8'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from lxml import etree\n\ndef prettyPrintXml(xmlFilePathToPrettyPrint):\n    assert xmlFilePathToPrettyPrint is not None\n    parser = etree.XMLParser(resolve_entities=False, strip_cdata=False)\n    document = etree.parse(xmlFilePathToPrettyPrint, parser)\n    document.write(xmlFilePathToPrettyPrint, pretty_print=True, encoding='utf-8')\n</code>\n</pre>\n", "senID": 3}, {"text": ["Example usage:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n prettyPrintXml('some_folder/some_file.xml')\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I had some problems with minidom's pretty print.", "I'd get a UnicodeError whenever I tried pretty-printing a document with characters outside the given encoding, eg if I had a \u03b2 in a document and I tried doc.toprettyxml(encoding='latin-1').", "Here's my workaround for it:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "doc.toprettyxml(encoding='latin-1')", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def toprettyxml(doc, encoding):\n    \"\"\"Return a pretty-printed XML document in a given encoding.\"\"\"\n    unistr = doc.toprettyxml().replace(u'&lt;?xml version=\"1.0\" ?&gt;',\n                          u'&lt;?xml version=\"1.0\" encoding=\"%s\"?&gt;' % encoding)\n    return unistr.encode(encoding, 'xmlcharrefreplace')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["XML pretty print for python looks pretty good for this task.", "(Appropriately named, too."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "XML pretty print for python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.codeplex.com/xmlpp"}]}, {"text": ["An alternative is to use pyXML, which has a PrettyPrint function."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "pyXML", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyxml.sourceforge.net/topics/"}, {"href": "http://guillaume.segu.in/blog/home/119/python-tip-of-the-day-replace-pyxmls-prettyprint/", "text": "PrettyPrint function", "childNum": 0, "tag": "a", "childList": []}]}]]