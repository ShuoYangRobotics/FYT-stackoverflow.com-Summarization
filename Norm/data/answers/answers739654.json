[[{"text": ["Since this answer explaining yield has been quite a success, I think a little tutorial about Python decorators could help as well."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/231767/can-somebody-explain-me-the-python-yield-statement/231855#231855"}]}, {"text": ["If you are not into long explanations, see Paolo Bergantino's anwser."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Paolo Bergantino's anwser", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/739654/understanding-python-decorators#answer-739665"}]}, {"text": ["To understand decorators, you must first understand that functions are objects in Python.", "This has important consequences.", "Let's see why with a simple example :"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def shout(word=\"yes\") :\n    return word.capitalize()+\" !\"\n\nprint shout()\n# outputs : 'Yes !'\n\n# As an object, you can assign the function to a variable like any\n# other object \n\nscream = shout\n\n# Notice we don't use parenthesis : we are not calling the function, we are\n# putting the function \"shout\" into the variable \"scream\". It means you can then\n# call \"shout\" from \"scream\" :\n\nprint scream()\n# outputs : 'Yes !'\n\n# More than that, it means you can remove the old name 'shout', the function will still\n# be accessible from 'scream'\n\ndel shout\ntry :\n    print shout()\nexcept NameError, e :\n    print e\n    #outputs : \"name 'shout' is not defined\"\n\nprint scream()\n# outputs : 'Yes !'\n</code>\n</pre>\n", "senID": 3}, {"text": ["Ok, keep that in mind, we are going back to it soon.", "Another interesting property of Python functions is they can be defined... inside another function !"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def talk() :\n\n    # You can define a function on the fly in \"talk\" ...\n    def whisper(word=\"yes\") :\n        return word.lower()+\"...\";\n\n    # ... and use it right away !\n\n    print whisper()\n\n# You call \"talk\", that defines \"whisper\" EVERY TIME you call it, then \"whisper\"\n# is called in \"talk\". \ntalk()\n# outputs : \n# yes...\n\n# But \"whisper\" DOES NOT EXIST outside \"talk\" :\n\ntry :\n    print whisper()\nexcept NameError, e :\n    print e\n    #outputs : \"name 'whisper' is not defined\"*\n</code>\n</pre>\n", "senID": 5}, {"text": ["Ok, still here ?", "Now the fun part, you've seen that functions are objects and therefor :"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "can be assign to a variable;", "tag": "none", "senID": 7}, {"text": "can be defined in an other function.", "tag": "none", "senID": 8}]}, {"text": ["Well, that means that a function can return another function :-) Have a look :"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n def getTalk(type=\"shout\") :\n\n    # We define functions on the fly\n    def shout(word=\"yes\") :\n        return word.capitalize()+\" !\"\n\n    def whisper(word=\"yes\") :\n        return word.lower()+\"...\";\n\n    # Then we return one of them\n    if type == \"shout\" :\n        # We don't use \"()\", we are not calling the function,\n        # we are returning the function object\n        return shout  \n    else :\n        return whisper\n\n# How do you use this strange beast ?\n\n# Get the function and assign it to a variable\ntalk = getTalk()      \n\n# You can see that \"talk\" is here a function object :\nprint talk\n#outputs : &lt;function shout at 0xb7ea817c&gt;\n\n# The object is the one returned by the function :\nprint talk()\n\n# And you can even use it directly if you feel wild :\nprint getTalk(\"whisper\")()\n#outputs : yes...\n</code>\n</pre>\n", "senID": 10}, {"text": ["But wait, there is more.", "If you can return a function, then you can pass one as a parameter:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def doSomethingBefore(func) : \n    print \"I do something before then I call the function you gave me\"\n    print func()\n\ndoSomethingBefore(scream)\n#outputs : \n#I do something before then I call the function you gave me\n#Yes !\n</code>\n</pre>\n", "senID": 12}, {"text": ["Well, you just have everything needed to understand decorators You see, decorators are wrappers, meaning, they let you execute code before and after the function they decorate without the need to modify the function itself."], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "they let you execute code before and after the function they decorate", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["How you would do it manually :"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n # A decorator is a function that expects ANOTHER function as parameter\ndef my_shiny_new_decorator(a_function_to_decorate) :\n\n    # Inside, the decorator defines a function on the fly : the wrapper.\n    # This function is going to be wrapped around the original function\n    # so it can execute code before and after it.\n    def the_wrapper_around_the_original_function() :\n\n        # Put here the code you want to be executed BEFORE the original \n        # function is called\n        print \"Before the function runs\"\n\n        # Call the function here (using parenthesis)\n        a_function_to_decorate()\n\n        # Put here the code you want to be executed AFTER the original \n        # function is called\n        print \"After the function runs\"\n\n    # At this point, \"a_function_to_decorate\" HAS NEVER BEEN EXECUTED.\n    # We return the wrapper function we just created.\n    # The wrapper contains the function and the code to execute before\n    # and after. It's ready to use !\n    return the_wrapper_around_the_original_function\n\n# Now imagine you create a function you don't want to ever touch again.\ndef a_stand_alone_function() :\n    print \"I am a stand alone function, don't you dare modify me\"\n\na_stand_alone_function() \n#outputs : I am a stand alone function, don't you dare modify me\n\n# Well, you can decorate it to extends its behavior.\n# Just pass it to the decorator, it will wrap it dynamically in \n# any code you want and returns you a new function ready to be used :\n\na_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)\na_stand_alone_function_decorated()\n#outputs :\n#Before the function runs\n#I am a stand alone function, don't you dare modify me\n#After the function runs\n</code>\n</pre>\n", "senID": 15}, {"text": ["Now, you probably want that every time you call a_stand_alone_function, a_stand_alone_function_decorated is called instead.", "That's easy, just erase a_stand_alone_function with the function returned by my_shiny_new_decorator :"], "childNum": 4, "tag": "p", "senID": 16, "childList": [{"text": "a_stand_alone_function", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a_stand_alone_function_decorated", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a_stand_alone_function", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "my_shiny_new_decorator", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)\na_stand_alone_function()\n#outputs :\n#Before the function runs\n#I am a stand alone function, don't you dare modify me\n#After the function runs\n\n# And guess what, that's EXACTLY what decorators do !\n</code>\n</pre>\n", "senID": 17}, {"text": ["The previous example, using the decorator syntax :"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n @my_shiny_new_decorator\ndef another_stand_alone_function() :\n    print \"Leave me alone\"\n\nanother_stand_alone_function()  \n#outputs :  \n#Before the function runs\n#Leave me alone\n#After the function runs\n</code>\n</pre>\n", "senID": 19}, {"text": ["Yes, that's all, it's that simple.", "@decorator is just a shortcut to :"], "childNum": 1, "tag": "p", "senID": 20, "childList": [{"text": "@decorator", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)\n</code>\n</pre>\n", "senID": 21}, {"text": ["Decorators are just a pythonic variant of the decorator design pattern.", "There are several classic design patterns embedded in Python to ease developpement, like iterators."], "childNum": 1, "tag": "p", "senID": 22, "childList": [{"text": "decorator design pattern", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Decorator_pattern"}]}, {"text": ["Of course, you can cumulate decorators :"], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"code": "<pre>\n<code>\n def bread(func) :\n    def wrapper() :\n        print \"&lt;/''''''\\&gt;\"\n        func()\n        print \"&lt;\\______/&gt;\"\n    return wrapper\n\ndef ingredients(func) :\n    def wrapper() :\n        print \"#tomatoes#\"\n        func()\n        print \"~salad~\"\n    return wrapper\n\ndef sandwich(food=\"--ham--\") :\n    print food\n\nsandwich()\n#outputs : --ham--\nsandwich = bread(ingredients(sandwich))\nsandwich()\n#outputs :\n#&lt;/''''''\\&gt;\n# #tomatoes#\n# --ham--\n# ~salad~\n#&lt;\\______/&gt;\n</code>\n</pre>\n", "senID": 24}, {"text": ["Using the Python decorator syntax :"], "childNum": 0, "tag": "p", "senID": 25, "childList": []}, {"code": "<pre>\n<code>\n @bread\n@ingredients\ndef sandwich(food=\"--ham--\") :\n    print food\n\nsandwich()\n#outputs :\n#&lt;/''''''\\&gt;\n# #tomatoes#\n# --ham--\n# ~salad~\n#&lt;\\______/&gt;\n</code>\n</pre>\n", "senID": 26}, {"text": ["The order you set the decorators MATTERS :"], "childNum": 0, "tag": "p", "senID": 27, "childList": []}, {"code": "<pre>\n<code>\n @ingredients\n@bread\ndef strange_sandwich(food=\"--ham--\") :\n    print food\n\nstrange_sandwich()\n#outputs :\n##tomatoes#\n#&lt;/''''''\\&gt;\n# --ham--\n#&lt;\\______/&gt;\n# ~salad~\n</code>\n</pre>\n", "senID": 28}, {"text": ["As a conclusion, you can easily see how to anwser to this StackOverflow.com question :"], "childNum": 0, "tag": "p", "senID": 29, "childList": []}, {"code": "<pre>\n<code>\n # The decorator to make it bold\ndef makebold(fn):\n    # The new function the decorator returns\n    def wrapper():\n        # Insertion of some code before and after\n        return \"&lt;b&gt;\" + fn() + \"&lt;/b&gt;\"\n    return wrapper\n\n# The decorator to make it italic\ndef makeitalic(fn):\n    # The new function the decorator returns\n    def wrapper():\n        # Insertion of some code before and after\n        return \"&lt;i&gt;\" + fn() + \"&lt;/i&gt;\"\n    return wrapper\n\n@makebold\n@makeitalic\ndef say():\n    return \"hello\"\n\nprint say() \n#outputs: &lt;b&gt;&lt;i&gt;hello&lt;/i&gt;&lt;/b&gt;\n\n# This is the exact equivalent to \ndef say():\n    return \"hello\"\nsay = makebold(makeitalic(say))\n\nprint say() \n#outputs: &lt;b&gt;&lt;i&gt;hello&lt;/i&gt;&lt;/b&gt;\n</code>\n</pre>\n", "senID": 30}, {"text": ["You can now just leave happy, or burn your brain a little bit more and see advanced used of decorators."], "childNum": 0, "tag": "p", "senID": 31, "childList": []}, {"code": "<pre>\n<code>\n # It's not black magic, you just have to let the wrapper \n# pass the argument :\n\ndef a_decorator_passing_arguments(function_to_decorate) :\n    def a_wrapper_accepting_arguments(arg1, arg2) :\n        print \"I got args ! Look :\", arg1, arg2\n        function_to_decorate(arg1, arg2)\n    return a_wrapper_accepting_arguments\n\n# Since when you are calling the function returned by the decorator, you are\n# calling the wrapper, passing arguments to it, will let it pass them to \n# the decorated function\n\n@a_decorator_passing_arguments\ndef print_full_name(first_name, last_name) :\n    print \"My name is\",first_name,last_name\n\nprint_full_name(\"Peter\", \"Venkman\")\n# outputs:\n#I got args ! Look : Peter Venkman\n#My name is Peter Venkman\n</code>\n</pre>\n", "senID": 32}, {"text": ["What's great with Python is that methods and functions are really the same, except methods expect their first  parameter to be a reference to the current object (self).", "It means you can build a decorator for methods the same way, just remember to take self in consideration :"], "childNum": 0, "tag": "p", "senID": 33, "childList": []}, {"code": "<pre>\n<code>\n def method_friendly_decorator(method_to_decorate) :\n    def wrapper(self, lie) :\n        lie = lie - 3 # very friendly, decrease age even more :-)\n        return method_to_decorate(self, lie)\n    return wrapper\n\n\nclass Lucy(object) :\n\n    def __init__(self) :\n        self.age = 32\n\n    @method_friendly_decorator\n    def sayYourAge(self, lie) :\n        print \"I am %s, what did you think ?\" % (self.age + lie)\n\nl = Lucy()\nl.sayYourAge(-3)\n#outputs: I am 26, what did you think ?\n</code>\n</pre>\n", "senID": 34}, {"text": ["Of course, if you make a very general decorator and wish you can apply it to any function / method, no matter its arguments, then just use *args, **kwargs :"], "childNum": 0, "tag": "p", "senID": 35, "childList": []}, {"code": "<pre>\n<code>\n def a_decorator_passing_arbitrary_arguments(function_to_decorate) :\n    # The wrapper accepts any arguments\n    def a_wrapper_accepting_arbitrary_arguments(*args, **kwargs) :\n        print \"Do I have args ? :\"\n        print args\n        print kwargs\n        # Then you unpack the arguments here *args, **kwargs\n        # If you are not familiar with unpacking, check :\n        # http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/\n        function_to_decorate(*args, **kwargs)\n    return a_wrapper_accepting_arbitrary_arguments\n\n@a_decorator_passing_arbitrary_arguments\ndef function_with_no_argument() :\n    print \"Python is cool, no argument here.\"\n\nfunction_with_no_argument()\n#outputs\n#Do I have args ? :\n#()\n#{}\n#Python is cool, no argument here.\n\n@a_decorator_passing_arbitrary_arguments\ndef function_with_arguments(a, b, c) :\n    print a, b, c\n\nfunction_with_arguments(1,2,3)\n#outputs\n#Do I have args ? :\n#(1, 2, 3)\n#{}\n#1 2 3 \n\n@a_decorator_passing_arbitrary_arguments\ndef function_with_named_arguments(a, b, c, platypus=\"Why not ?\") :\n    print \"Do %s, %s and %s like platipus ? %s\" %\\\n    (a, b, c, platypus)\n\nfunction_with_named_arguments(\"Bill\", \"Linus\", \"Steve\", platypus=\"Indeed !\")\n#outputs\n#Do I have args ? :\n#('Bill', 'Linus', 'Steve')\n#{'platypus': 'Indeed !'}\n#Do Bill, Linus and Steve like platipus ? Indeed !\n\nclass Mary(object) :\n\n    def __init__(self) :\n        self.age = 31\n\n    @a_decorator_passing_arbitrary_arguments\n    def sayYourAge(self, lie=-3) : # You can now add a default value\n        print \"I am %s, what did you think ?\" % (self.age + lie)\n\nm = Mary()\nm.sayYourAge()\n#outputs\n# Do I have args ? :\n#(&lt;__main__.Mary object at 0xb7d303ac&gt;,)\n#{}\n#I am 28, what did you think ?\n</code>\n</pre>\n", "senID": 36}, {"text": ["Great, now what would you say about passing arguments to the decorator itself?", "Well this is a bit twisted because a decorator must accept a function as an argument and therefor, you can not pass the decorated function arguments directly to the decorator."], "childNum": 0, "tag": "p", "senID": 37, "childList": []}, {"text": ["Before rushing to the solution, let's write a little reminder : "], "childNum": 0, "tag": "p", "senID": 38, "childList": []}, {"code": "<pre>\n<code>\n # Decorators are ORDINARY functions\ndef my_decorator(func) :\n    print \"I am a ordinary function\"\n    def wrapper() :\n        print \"I am function returned by the decorator\"\n        func()\n    return wrapper\n\n# Therefor, you can call it without any \"@\"\n\ndef lazy_function() :\n    print \"zzzzzzzz\"\n\ndecorated_function = my_decorator(lazy_function)\n#ouputs : I am a ordinary function\n\n# It ouputs \"I am a ordinary function\", because that's just what you do :\n# calling a function. Nothing magic.\n\n@my_decorator\ndef lazy_function() :\n    print \"zzzzzzzz\"\n\n#ouputs : I am a ordinary function\n</code>\n</pre>\n", "senID": 39}, {"text": ["It's exactly the same.", "\"my_decorator\" is called.", "So when you @my_decorator, you are telling Python to call the function 'labelled by the variable \"my_decorator\"'.", "It's important, because, the label you give can point directly to the decorator... or not !", "Let's start to be evil !"], "childNum": 3, "tag": "p", "senID": 40, "childList": [{"text": "my_decorator", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "@my_decorator", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "my_decorator", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def decorator_maker() :\n\n    print \"I make decorators ! I am executed only once: \"+\\\n          \"when you make me create a decorator.\"\n\n    def my_decorator(func) :\n\n        print \"I am a decorator ! I am executed only when you decorate a function.\"\n\n        def wrapped() :\n            print \"I am the wrapper arround the decorated function. \"+\\\n                  \"I am called when you call the decorated function. \"+\\\n                  \"As the wrapper, I return the RESULT of the decorated function.\"\n            return func()\n\n        print \"As the decorator, I return the wrapped function.\"\n\n        return wrapped\n\n    print \"As a decorator maker, I return a decorator\"\n    return my_decorator\n\n# Let's create a decorator. It's just a new function after all.\nnew_decorator = decorator_maker()       \n#ouputs:\n#I make decorators ! I am executed only once: when you make me create a decorator.\n#As a decorator maker, I return a decorator\n\n# Then we decorate the function\n\ndef decorated_function() :\n    print \"I am the decorated function.\"\n\ndecorated_function = new_decorator(decorated_function)\n#ouputs:\n#I am a decorator ! I am executed only when you decorate a function.\n#As the decorator, I return the wrapped function\n\n# Let's call the function :\ndecorated_function()\n#ouputs:\n#I am the wrapper arround the decorated function. I am called when you call the decorated function.\n#As the wrapper, I return the RESULT of the decorated function.\n#I am the decorated function.\n</code>\n</pre>\n", "senID": 41}, {"text": ["No surprise here.", "Let's do EXACTLY the same thing, but skipping intermediate variables :"], "childNum": 0, "tag": "p", "senID": 42, "childList": []}, {"code": "<pre>\n<code>\n def decorated_function() :\n    print \"I am the decorated function.\"\ndecorated_function = decorator_maker()(decorated_function)\n#ouputs:\n#I make decorators ! I am executed only once: when you make me create a decorator.\n#As a decorator maker, I return a decorator\n#I am a decorator ! I am executed only when you decorate a function.\n#As the decorator, I return the wrapped function.\n\n# Finally :\ndecorated_function()    \n#ouputs:\n#I am the wrapper arround the decorated function. I am called when you call the decorated function.\n#As the wrapper, I return the RESULT of the decorated function.\n#I am the decorated function.\n</code>\n</pre>\n", "senID": 43}, {"text": ["Let's make it AGAIN, even shorter :"], "childNum": 0, "tag": "p", "senID": 44, "childList": []}, {"code": "<pre>\n<code>\n @decorator_maker()\ndef decorated_function() :\n    print \"I am the decorated function.\"\n#ouputs:\n#I make decorators ! I am executed only once: when you make me create a decorator.\n#As a decorator maker, I return a decorator\n#I am a decorator ! I am executed only when you decorate a function.\n#As the decorator, I return the wrapped function.\n\n#Eventually : \ndecorated_function()    \n#ouputs:\n#I am the wrapper arround the decorated function. I am called when you call the decorated function.\n#As the wrapper, I return the RESULT of the decorated function.\n#I am the decorated function.\n</code>\n</pre>\n", "senID": 45}, {"text": ["Hey, did you see that, whe used a function call whith the \"@\" syntax :-) So back to decorators with arguments.", "If we can use functions to generate the decorator on the fly, we can pass arguments to that function, right ?"], "childNum": 1, "tag": "p", "senID": 46, "childList": [{"text": "@", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def decorator_maker_with_arguments(decorator_arg1, decorator_arg2) :\n\n    print \"I make decorators ! And I accept arguments:\", decorator_arg1, decorator_arg2\n\n    def my_decorator(func) :\n        # The hability to pass arguments here is a gift from closures.\n        # If you are not confortable with closures, you can assume it's ok,\n        # or read : http://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python\n        print \"I am the decorator. Somehow you passed me arguments:\", decorator_arg1, decorator_arg2\n\n        # Don't confuse decorator arguments and function arguments !\n        def wrapped(function_arg1, function_arg2) :\n            print \"I am the wrapper arround the decorated function.\",\\\n                  \"\\nI can access all the variables\",\\\n                  \"\\n\\t- from the decorator:\", decorator_arg1, decorator_arg2,\\\n                  \"\\n\\t- from the function call:\", function_arg1, function_arg2,\\\n                  \"\\nThen I can pass them to the decorated function\"\n            return func(function_arg1, function_arg2)\n\n        return wrapped\n\n    return my_decorator\n\n@decorator_maker_with_arguments(\"Leonard\", \"Sheldon\")\ndef decorated_function_with_arguments(function_arg1, function_arg2) :\n    print \"I am the decorated function and only knows about my arguments :\",\\\n          function_arg1, function_arg2\n\ndecorated_function_with_arguments(\"Rajesh\", \"Howard\")\n#outputs:\n#I make decorators ! And I accept arguments: Leonard Sheldon\n#I am the decorator. Somehow you passed me arguments: Leonard Sheldon\n#I am the wrapper arround the decorated function. \n#I can access all the variables \n#   - from the decorator: Leonard Sheldon \n#   - from the function call: Rajesh Howard \n#Then I can pass them to the decorated function\n#I am the decorated function and only knows about my arguments : Rajesh Howard\n</code>\n</pre>\n", "senID": 47}, {"text": ["Here it is, a decorator with arguments.", "Arguments can be set as variable :"], "childNum": 0, "tag": "p", "senID": 48, "childList": []}, {"code": "<pre>\n<code>\n c1 = \"Penny\"\nc2 = \"Leslie\"\n\n@decorator_maker_with_arguments(\"Leonard\", c1)\ndef decorated_function_with_arguments(function_arg1, function_arg2) :\n    print \"I am the decorated function and only knows about my arguments :\",\\\n          function_arg1, function_arg2\n\ndecorated_function_with_arguments(c2, \"Howard\")\n#outputs:\n#I make decorators ! And I accept arguments: Leonard Penny\n#I am the decorator. Somehow you passed me arguments: Leonard Penny\n#I am the wrapper arround the decorated function. \n#I can access all the variables \n#   - from the decorator: Leonard Penny \n#   - from the function call: Leslie Howard \n#Then I can pass them to the decorated function\n#I am the decorated function and only knows about my arguments : Leslie Howard\n</code>\n</pre>\n", "senID": 49}, {"text": ["As you can see, you can pass arguments to the decorator like any function using this trick.", "You can even use *args, **kwargs if you wish.", "But remember decorators are called only once.", "Just when Python import the script.", "You can't dynamically set the arguments afterwards.", "When you do \"import x\", the function is already decorated, you can't\nchange anything."], "childNum": 3, "tag": "p", "senID": 50, "childList": [{"text": "*args, **kwargs", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "only once", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "the function is already decorated", "childNum": 0, "tag": "strong", "pos": 5, "childList": []}]}, {"text": ["Ok, as a bonus, I'll give you a snippet to make any decorator accept generically any argument.", "After all, in order to accept arguments, we created our decorator using another function.", "We wrapped the decorator.", "Anything else we saw recently that wrapped function ?", "Of yes, decorators !", "Let's have some fun and write a decorator for the decorators :"], "childNum": 0, "tag": "p", "senID": 51, "childList": []}, {"code": "<pre>\n<code>\n def decorator_with_args(decorator_to_enhance) :\n    \"\"\" \n    This function is supposed to be used as a decorator.\n    It must decorate an other function, that is intended to be used as a decorator.\n    Take a cup of coffee.\n    It will allow any decorator to accept an arbitrary number of arguments,\n    saving you the headache to remember how to do that every time.\n    \"\"\"\n\n    # We use the same trick we did to pass arguments\n    def decorator_maker(*args, **kwargs) :\n\n        # We create on the fly a decorator that accepts only a function\n        # but keeps the passed arguments from the maker .\n        def decorator_wrapper(func) :\n\n            # We return the result of the original decorator, which, after all, \n            # IS JUST AN ORDINARY FUNCTION (which returns a function).\n            # Only pitfall : the decorator must have this specific signature or it won't work :\n            return decorator_to_enhance(func, *args, **kwargs)\n\n        return decorator_wrapper\n\n    return decorator_maker\n</code>\n</pre>\n", "senID": 52}, {"text": ["It can be used as followed :"], "childNum": 0, "tag": "p", "senID": 53, "childList": []}, {"code": "<pre>\n<code>\n # You create the function you will use as a decorator. And stick a decorator on it :-)\n# Donc forget, the signature is \"decorator(func, *args, **kwargs)\"\n@decorator_with_args \ndef decorated_decorator(func, *args, **kwargs): \n    def wrapper(function_arg1, function_arg2) :\n        print \"Decorated with\", args, kwargs\n        return func(function_arg1, function_arg2)\n    return wrapper\n\n# Then you decorate the functions you wish with your brand new decorated decorator.\n\n@decorated_decorator(42, 404, 1024)\ndef decorated_function(function_arg1, function_arg2) :\n    print \"Hello\", function_arg1, function_arg2\n\ndecorated_function(\"Universe and\", \"everything\")\n#outputs:\n#Decorated with (42, 404, 1024) {}\n#Hello Universe and everything\n\n# Whoooot !\n</code>\n</pre>\n", "senID": 54}, {"text": ["I know, the last time you had this feeling, it was after listening a guy saying : \"before understanding recursion, you must first understand recursion\".", "But know, don't you feel good about mastering thi?"], "childNum": 0, "tag": "p", "senID": 55, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "They exists only since Python 2.4, therefor be sure that's what your code is running on. ", "tag": "none", "senID": 56}, {"text": "Decorators slow down the code. Keep that in mind.", "tag": "none", "senID": 57}, {"text": "You can not undecorate a function. There are hacks to create decorators that can be removed but nobody uses them. So once a function is decorated, it's done. ", "tag": "none", "senID": 58}, {"text": "Decorators wrap functions, making them hard to debug. ", "tag": "none", "senID": 59}]}, {"text": ["Python 2.5 solves this last issue by providing the functools modules including functools.wraps that copies the name, module and docstring of any wrapped function to it's wrapper.", "Fun fact, functools.wraps is a decorator :-)"], "childNum": 3, "tag": "p", "senID": 60, "childList": [{"text": "functools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "functools.wraps", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "functools.wraps", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n # For debugging, the stacktrace prints you the function __name__\ndef foo() :\n    print \"foo\"\n\nprint foo.__name__\n#outputs: foo\n\n# With a decorator, it gets messy    \ndef bar(func) :\n    def wrapper() :\n        print \"bar\"\n        return func()\n    return wrapper\n\n@bar\ndef foo() :\n    print \"foo\"\n\nprint foo.__name__\n#outputs: wrapper\n\n# \"functools\" can help for that\n\nimport functools\n\ndef bar(func) :\n    # We say that \"wrapper\", is wrapping \"func\"\n    # and the magic begins\n    @functools.wraps(func)\n    def wrapper() :\n        print \"bar\"\n        return func()\n    return wrapper\n\n@bar\ndef foo() :\n    print \"foo\"\n\nprint foo.__name__\n#outputs: foo\n</code>\n</pre>\n", "senID": 61}, {"text": ["Now the big question, what can I use decorators for?", "Seem cool and powerful, but a practical example would be great.", "Well, there are 1000 possibilities.", "Classic uses are extending a function behavior from an external lib (you can't modify it) or for a debug purpose (you don't want to modify it because it's temporary).", "You can use them to extends several functions with the same code without rewriting it everytime, for DRY sake.", "E.G:"], "childNum": 0, "tag": "p", "senID": 62, "childList": []}, {"code": "<pre>\n<code>\n def benchmark(func):\n    \"\"\"\n    A decorator that print the time of function take\n    to execute.\n    \"\"\"\n    import time\n    def wrapper(*args, **kwargs):\n        t = time.clock()\n        res = func(*args, **kwargs)\n        print func.__name__, time.clock()-t\n        return res\n    return wrapper\n\n\ndef loggin(func) :\n    \"\"\"\n    A decorator that logs the activty of the script.\n    Ok, it really just print it, put it could be loggin !\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        res = func(*args, **kwargs)\n        print func.__name__, args, kwargs\n        return res\n    return wrapper\n\n\ndef counter(func):\n    \"\"\"\n    A decorator that print the number of time a function has been executed\n    \"\"\"\n    counter.count = 0\n    def wrapper(*args, **kwargs):\n        counter.count = counter.count + 1\n        res = func(*args, **kwargs)\n        print func.__name__, \"has been used : \", counter.count, \"X\"\n        return res\n    return wrapper\n\n@counter\n@benchmark\n@loggin\ndef reverse_string(string) :\n    return string[::-1]\n\nprint reverse_string(\"Able was I ere I saw Elba\")\nprint reverse_string(\" A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal : Panama!\")\n\n#outputs:\n#reverse_string ('Able was I ere I saw Elba',) {}\n#wrapper 0.0\n#wrapper has been used :  1 X\n#ablE was I ere I saw elbA\n#reverse_string (' A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal : Panama!',) {}\n#wrapper 0.0\n#wrapper has been used :  2 X\n#!amanaP : lanac a ,noep a ,stah eros ,raj a ,hsac ,oloR a ,tur a ,mapS ,snip ,eperc a ,)lemac a ro( niaga gab ananab a ,gat a ,nat a ,gab ananab a ,gag a ,inoracam ,elacrep ,epins ,spam ,arutaroloc a ,shajar ,soreh ,atsap ,eonac a ,nalp a ,nam A\n</code>\n</pre>\n", "senID": 63}, {"text": ["Of course the good thing with decorators is that you case use them right away on almost anything without rewriting.", "DRY, I said :"], "childNum": 0, "tag": "p", "senID": 64, "childList": []}, {"code": "<pre>\n<code>\n @counter\n@benchmark\n@loggin\ndef get_random_furturama_quote() :\n    import httplib\n    conn = httplib.HTTPConnection(\"slashdot.org:80\")\n    conn.request(\"HEAD\", \"/index.html\")\n    for key, value in conn.getresponse().getheaders() :\n        if key.startswith(\"x-b\") or key.startswith(\"x-f\"):\n            return value\n    return \"No, I'm ...doesn't!\"\n\nprint get_random_furturama_quote()\nprint get_random_furturama_quote()\n\n#outputs:\n#get_random_furturama_quote () {}\n#wrapper 0.02\n#wrapper has been used :  1 X\n#The laws of science be a harsh mistress.\n#get_random_furturama_quote () {}\n#wrapper 0.01\n#wrapper has been used :  2 X\n#Curse you, merciful Poseidon!\n</code>\n</pre>\n", "senID": 65}, {"text": ["Python itselft provides several decorators : memoize, property, staticmethod, etc.", "Django use decorators to manage caching.", "Twisted to fake inlining asynchronous functions calls.", "This really is a large playground."], "childNum": 3, "tag": "p", "senID": 66, "childList": [{"text": "memoize", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "property", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "staticmethod", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["EDIT: given the success of this answer, and people asking me to do the same with metaclasses, I did."], "childNum": 1, "tag": "p", "senID": 67, "childList": [{"text": "I did", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/6581949#6581949"}]}], [{"text": ["Check out the documentation to see how decorators work.", "Here is what you asked for:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "the documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/compound%5Fstmts.html#function"}]}, {"code": "<pre>\n<code>\n def makebold(fn):\n    def wrapped():\n        return \"&lt;b&gt;\" + fn() + \"&lt;/b&gt;\"\n    return wrapped\n\ndef makeitalic(fn):\n    def wrapped():\n        return \"&lt;i&gt;\" + fn() + \"&lt;/i&gt;\"\n    return wrapped\n\n@makebold\n@makeitalic\ndef hello():\n    return \"hello world\"\n\nprint hello() ## returns &lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Alternatively, you could write a factory function which return a decorator which wraps the return value of the decorated function in a tag passed to the factory function.", "For example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from functools import wraps\n\ndef wrap_in_tag(tag):\n    def factory(func):\n        @wraps(func)\n        def decorator():\n            return '&lt;%(tag)s&gt;%(rv)s&lt;/%(tag)s&gt;' % (\n                {'tag': tag, 'rv': func()})\n        return decorator\n    return factory\n</code>\n</pre>\n", "senID": 1}, {"text": ["This enables you to write:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n @wrap_in_tag('b')\n@wrap_in_tag('i')\ndef say():\n    return 'hello'\n</code>\n</pre>\n", "senID": 3}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n makebold = wrap_in_tag('b')\nmakeitalic = wrap_in_tag('i')\n\n@makebold\n@makeitalic\ndef say():\n    return 'hello'\n</code>\n</pre>\n", "senID": 5}, {"text": ["Personally I would have written the decorator somewhat differently:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n from functools import wraps\n\ndef wrap_in_tag(tag):\n    def factory(func):\n        @wraps(func)\n        def decorator(val):\n            return func('&lt;%(tag)s&gt;%(val)s&lt;/%(tag)s&gt;' %\n                        {'tag': tag, 'val': val})\n        return decorator\n    return factory\n</code>\n</pre>\n", "senID": 7}, {"text": ["which would yield:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n @wrap_in_tag('b')\n@wrap_in_tag('i')\ndef say(val):\n    return val\nsay('hello')\n</code>\n</pre>\n", "senID": 9}, {"text": ["Don't forget the construction for which decorator syntax is a shorthand:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n say = wrap_in_tag('b')(wrap_in_tag('i')(say)))\n</code>\n</pre>\n", "senID": 11}], [{"text": ["Python decorators add extra functionality to another function"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["An italics decorator could be like"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def makeitalic(fn):\n    def newFunc():\n        return \"&lt;i&gt;\" + fn() + \"&lt;/i&gt;\"\n    return newFunc\n</code>\n</pre>\n", "senID": 2}, {"text": ["Note that a function is defined inside a function.", "What it basically does is replace a function with the newly defined one.", "For example, I have this class"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class foo:\n    def bar(self):\n        print \"hi\"\n    def foobar(self):\n        print \"hi again\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now say, I want both functions to print \"---\" after and before they are done.", "I could add a print \"---\" before and after each print statement.", "But because I don't like repeating myself, I will make a decorator"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def addDashes(fn): # notice it takes a function as an argument\n    def newFunction(self): # define a new function\n        print \"---\"\n        fn(self) # call the original function\n        print \"---\"\n    return newFunction\n    # Return the newly defined function - it will \"replace\" the original\n</code>\n</pre>\n", "senID": 6}, {"text": ["So now I can change my class to "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n class foo:\n    @addDashes\n    def bar(self):\n        print \"hi\"\n\n    @addDashes\n    def foobar(self):\n        print \"hi again\"\n</code>\n</pre>\n", "senID": 8}, {"text": ["For more on decorators, check\nhttp://www.ibm.com/developerworks/linux/library/l-cpdecor.html"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "http://www.ibm.com/developerworks/linux/library/l-cpdecor.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ibm.com/developerworks/linux/library/l-cpdecor.html"}]}], [{"text": ["It looks like the other people have already told you how to solve the problem.", "I hope this will help you understand what decorators are."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Decorators are just syntactical sugar."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n @decorator\ndef func():\n    ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["expands to    "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def func():\n    ...\nfunc = decorator(func)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["And of course you can return lambdas as well from a decorator function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def makebold(f): \n    return lambda: \"&lt;b&gt;\" + f() + \"&lt;/b&gt;\"\ndef makeitalic(f): \n    return lambda: \"&lt;i&gt;\" + f() + \"&lt;/i&gt;\"\n\n@makebold\n@makeitalic\ndef say():\n    return \"Hello\"\n\nprint say()\n</code>\n</pre>\n", "senID": 1}]]