[[{"text": ["This may be quicker than yours.", "Makes no assumptions about line length.", "Backs through the file one block at a time till it's found the right number of '\\n' characters."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def tail( f, window=20 ):\n    BUFSIZ = 1024\n    f.seek(0, 2)\n    bytes = f.tell()\n    size = window\n    block = -1\n    data = []\n    while size &gt; 0 and bytes &gt; 0:\n        if (bytes - BUFSIZ &gt; 0):\n            # Seek back one whole BUFSIZ\n            f.seek(block*BUFSIZ, 2)\n            # read BUFFER\n            data.append(f.read(BUFSIZ))\n        else:\n            # file too small, start from begining\n            f.seek(0,0)\n            # only read what was not read\n            data.append(f.read(bytes))\n        linesFound = data[-1].count('\\n')\n        size -= linesFound\n        bytes -= BUFSIZ\n        block -= 1\n    return '\\n'.join(''.join(data).splitlines()[-window:])\n</code>\n</pre>\n", "senID": 1}, {"text": ["I don't like tricky assumptions about line length when -- as a practical matter -- you can never know things like that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Generally, this will locate the last 20 lines on the first or second pass through the loop.", "If your 74 character thing is actually accurate, you make the block size 2048 and you'll tail 20 lines almost immediately."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Also, I don't burn a lot of brain calories trying to finesse alignment with physical OS blocks.", "Using these high-level I/O packages, I doubt you'll see any performance consequence of trying to align on OS block boundaries.", "If you use lower-level I/O, then you might see a speedup."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The code I ended up using.", "I think this is the best so far:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def tail(f, n, offset=None):\n    \"\"\"Reads a n lines from f with an offset of offset lines.  The return\n    value is a tuple in the form ``(lines, has_more)`` where `has_more` is\n    an indicator that is `True` if there are more lines in the file.\n    \"\"\"\n    avg_line_length = 74\n    to_read = n + (offset or 0)\n\n    while 1:\n        try:\n            f.seek(-(avg_line_length * to_read), 2)\n        except IOError:\n            # woops.  apparently file is smaller than what we want\n            # to step back, go to the beginning instead\n            f.seek(0)\n        pos = f.tell()\n        lines = f.read().splitlines()\n        if len(lines) &gt;= to_read or pos == 0:\n            return lines[-to_read:offset and -offset or None], \\\n                   len(lines) &gt; to_read or pos &gt; 0\n        avg_line_length *= 1.3\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Assumes a unix-like system."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\ndef tail(f, n, offset=0):\n  stdin,stdout = os.popen2(\"tail -n \"+n+offset+\" \"+f)\n  stdin.close()\n  lines = stdout.readlines(); stdout.close()\n  return lines[:,-offset]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If reading the whole file is acceptable then use a deque."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import deque\ndeque(f, maxlen=n)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Prior to 2.6, deques didn't have a maxlen option, but it's easy enough to implement."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import itertools\ndef maxque(items, size):\n    items = iter(items)\n    q = deque(itertools.islice(items, size))\n    for item in items:\n    \tdel q[0]\n    \tq.append(item)\n    return q\n</code>\n</pre>\n", "senID": 3}, {"text": ["If it's a requirement to read the file from the end, then use a gallop (a.k.a exponential) search."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def tail(f, n):\n    assert n &gt;= 0\n    pos, lines = n+1, []\n    while len(lines) &lt;= n:\n    \ttry:\n    \t\tf.seek(-pos, 2)\n    \texcept IOError:\n    \t\tf.seek(0)\n    \t\tbreak\n    \tfinally:\n    \t\tlines = list(f)\n    \tpos *= 2\n    return lines[-n:]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["For efficiency with very large files (common in logfile situations where you may want to use tail), you generally want to avoid reading the whole file (even if you do do it without reading the whole file into memory at once)  However, you do need to somehow work out the offset in lines rather than characters.", "One possibility is reading backwards with seek() char by char, but this is very slow.", "Instead, its better to process in larger blocks."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I've a utility function I wrote a while ago to read files backwards that can be used here."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import os, itertools\n\ndef rblocks(f, blocksize=4096):\n    \"\"\"Read file as series of blocks from end of file to start.\n\n    The data itself is in normal order, only the order of the blocks is reversed.\n    ie. \"hello world\" -&gt; [\"ld\",\"wor\", \"lo \", \"hel\"]\n    Note that the file must be opened in binary mode.\n    \"\"\"\n    if 'b' not in f.mode.lower():\n        raise Exception(\"File must be opened using binary mode.\")\n    size = os.stat(f.name).st_size\n    fullblocks, lastblock = divmod(size, blocksize)\n\n    # The first(end of file) block will be short, since this leaves \n    # the rest aligned on a blocksize boundary.  This may be more \n    # efficient than having the last (first in file) block be short\n    f.seek(-lastblock,2)\n    yield f.read(lastblock)\n\n    for i in range(fullblocks-1,-1, -1):\n        f.seek(i * blocksize)\n        yield f.read(blocksize)\n\ndef tail(f, nlines):\n    buf = ''\n    result = []\n    for block in rblocks(f):\n        buf = block + buf\n        lines = buf.splitlines()\n\n        # Return all lines except the first (since may be partial)\n        if lines:\n            result.extend(lines[1:]) # First line may not be complete\n            if(len(result) &gt;= nlines):\n                return result[-nlines:]\n\n            buf = lines[0]\n\n    return ([buf]+result)[-nlines:]\n\n\nf=open('file_to_tail.txt','rb')\nfor line in tail(f, 20):\n    print line\n</code>\n</pre>\n", "senID": 2}, {"text": ["[Edit] Added more specific version (avoids need to reverse twice)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["On second thought, this is probably just as fast as anything here."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def tail( f, window=20 ):\n    lines= ['']*window\n    count= 0\n    for l in f:\n        lines[count%window]= l\n        count += 1\n    print lines[count%window:], lines[:count%window]\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's a lot simpler.", "And it does seem to rip along at a good pace.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["based on S.Lott's top voted answer (Sep 25 '08 at 21:43), but fixed for small files."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def tail(the_file, lines_2find=20):  \n    the_file.seek(0, 2)                         #go to end of file\n    bytes_in_file = the_file.tell()             \n    lines_found, total_bytes_scanned = 0, 0\n    while lines_2find+1 &gt; lines_found and bytes_in_file &gt; total_bytes_scanned: \n        byte_block = min(1024, bytes_in_file-total_bytes_scanned)\n        the_file.seek(-(byte_block+total_bytes_scanned), 2)\n        total_bytes_scanned += byte_block\n        lines_found += the_file.read(1024).count('\\n')\n    the_file.seek(-total_bytes_scanned, 2)\n    line_list = list(the_file.readlines())\n    return line_list[-lines_2find:]\n\n    #we read at least 21 line breaks from the bottom, block by block for speed\n    #21 to ensure we don't get a half line\n</code>\n</pre>\n", "senID": 1}, {"text": ["Hope this is useful."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["you can go to the end of your file with f.seek(0, 2) and then read off lines one by one with the following replacement for readline():"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def readline_backwards(self, f):\n    backline = ''\n    last = ''\n    while not last == '\\n':\n        backline = last + backline\n        if f.tell() &lt;= 0:\n            return backline\n        f.seek(-1, 1)\n        last = f.read(1)\n        f.seek(-1, 1)\n    backline = last\n    last = ''\n    while not last == '\\n':\n        backline = last + backline\n        if f.tell() &lt;= 0:\n            return backline\n        f.seek(-1, 1)\n        last = f.read(1)\n        f.seek(-1, 1)\n    f.seek(1, 1)\n    return backline\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Based on Eyecue answer (Jun 10 '10 at 21:28): this class add head() and tail() method to file object."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class File(file):\n    def head(self, lines_2find=1):\n        self.seek(0)                            #Rewind file\n        return [self.next() for x in xrange(lines_2find)]\n\n    def tail(self, lines_2find=1):  \n        self.seek(0, 2)                         #go to end of file\n        bytes_in_file = self.tell()             \n        lines_found, total_bytes_scanned = 0, 0\n        while (lines_2find+1 &gt; lines_found and\n               bytes_in_file &gt; total_bytes_scanned): \n            byte_block = min(1024, bytes_in_file-total_bytes_scanned)\n            self.seek(-(byte_block+total_bytes_scanned), 2)\n            total_bytes_scanned += byte_block\n            lines_found += self.read(1024).count('\\n')\n        self.seek(-total_bytes_scanned, 2)\n        line_list = list(self.readlines())\n        return line_list[-lines_2find:]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n f = File('path/to/file', 'r')\nf.head(3)\nf.tail(3)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Several of these solutions have issues if the file doesn't end in \\n or in ensuring the complete first line is read."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def tail(file, n=1, bs=1024):\n    f = open(file)\n    f.seek(-1,2)\n    l = 1-f.read(1).count('\\n') # If file doesn't end in \\n, count it anyway.\n    B = f.tell()\n    while n &gt;= l and B &gt; 0:\n            block = min(bs, B)\n            B -= block\n            f.seek(B, 0)\n            l += f.read(block).count('\\n')\n    f.seek(B, 0)\n    l = min(l,n) # discard first (incomplete) line if l &gt; n\n    lines = f.readlines()[-l:]\n    f.close()\n    return lines\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Simple and fast solution with mmap:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import mmap\nimport os\n\ndef tail(filename, n):\n    \"\"\"Returns last n lines from the filename. No exception handling\"\"\"\n    size = os.path.getsize(filename)\n    with open(filename, \"rb\") as f:\n        # for Windows the mmap parameters are different\n        fm = mmap.mmap(f.fileno(), 0, mmap.MAP_SHARED, mmap.PROT_READ)\n        try:\n            for i in xrange(size - 1, -1, -1):\n                if fm[i] == '\\n':\n                    n -= 1\n                    if n == -1:\n                        break\n            return fm[i + 1 if i else 0:].splitlines()\n        finally:\n            fm.close()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["S.Lott's answer above almost works for me but ends up giving me partial lines.", "It turns out that it corrupts data on block boundaries because data holds the read blocks in reversed order.", "When ''.join(data) is called, the blocks are in the wrong order.", "This fixes that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def tail(f, window=20):\n    \"\"\"\n    Returns the last `window` lines of file `f` as a list.\n    \"\"\"\n    BUFSIZ = 1024\n    f.seek(0, 2)\n    bytes = f.tell()\n    size = window + 1\n    block = -1\n    data = []\n    while size &gt; 0 and bytes &gt; 0:\n        if bytes - BUFSIZ &gt; 0:\n            # Seek back one whole BUFSIZ\n            f.seek(block * BUFSIZ, 2)\n            # read BUFFER\n            data.insert(0, f.read(BUFSIZ))\n        else:\n            # file too small, start from begining\n            f.seek(0,0)\n            # only read what was not read\n            data.insert(0, f.read(bytes))\n        linesFound = data[0].count('\\n')\n        size -= linesFound\n        bytes -= BUFSIZ\n        block -= 1\n    return ''.join(data).splitlines()[-window:]\n</code>\n</pre>\n", "senID": 1}]]