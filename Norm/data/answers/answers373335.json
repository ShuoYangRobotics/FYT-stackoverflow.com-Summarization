[[{"text": ["You could just use normal Python argument passing syntax to specify your crontab.", "For example, suppose we define an Event class as below:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from datetime import datetime, timedelta\nimport time\n\n# Some utility classes / functions first\nclass AllMatch(set):\n    \"\"\"Universal set - match everything\"\"\"\n    def __contains__(self, item): return True\n\nallMatch = AllMatch()\n\ndef conv_to_set(obj):  # Allow single integer to be provided\n    if isinstance(obj, (int,long)):\n        return set([obj])  # Single item\n    if not isinstance(obj, set):\n        obj = set(obj)\n    return obj\n\n# The actual Event class\nclass Event(object):\n    def __init__(self, action, min=allMatch, hour=allMatch, \n                       day=allMatch, month=allMatch, dow=allMatch, \n                       args=(), kwargs={}):\n        self.mins = conv_to_set(min)\n        self.hours= conv_to_set(hour)\n        self.days = conv_to_set(day)\n        self.months = conv_to_set(month)\n        self.dow = conv_to_set(dow)\n        self.action = action\n        self.args = args\n        self.kwargs = kwargs\n\n    def matchtime(self, t):\n        \"\"\"Return True if this event should trigger at the specified datetime\"\"\"\n        return ((t.minute     in self.mins) and\n                (t.hour       in self.hours) and\n                (t.day        in self.days) and\n                (t.month      in self.months) and\n                (t.weekday()  in self.dow))\n\n    def check(self, t):\n        if self.matchtime(t):\n            self.action(*self.args, **self.kwargs)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Note: Not thoroughly tested)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Then your CronTab can be specified in normal python syntax as:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n c = CronTab(\n  Event(perform_backup, 0, 2, dow=6 ),\n  Event(purge_temps, 0, range(9,18,2), dow=range(0,5))\n)\n</code>\n</pre>\n", "senID": 4}, {"text": ["This way you get the full power of Python's argument mechanics (mixing positional and keyword args, and can use symbolic names for names of weeks and months)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The CronTab class would be defined as simply sleeping in minute increments, and calling check() on each event.", "(There are probably some subtleties with daylight savings time / timezones to be wary of though).", "Here's a quick implementation:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n class CronTab(object):\n    def __init__(self, *events):\n        self.events = events\n\n    def run(self):\n        t=datetime(*datetime.now().timetuple()[:5])\n        while 1:\n            for e in self.events:\n                e.check(t)\n\n            t += timedelta(minutes=1)\n            while datetime.now() &lt; t:\n                time.sleep((t - datetime.now()).seconds)\n</code>\n</pre>\n", "senID": 7}, {"text": ["A few things to note:  Python's weekdays / months are zero indexed (unlike cron), and that range excludes the last element, hence syntax like \"1-5\" becomes range(0,5) - ie [0,1,2,3,4].", "If you prefer cron syntax, parsing it shouldn't be too difficult however."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["TurboGears ships with scheduled task capability based on Kronos"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "TurboGears", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://turbogears.com/"}, {"href": "http://www.razorvine.net/download/kronos.py", "text": "Kronos", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["I've never used Kronos directly, but the scheduling in TG has a decent set of features and is solid."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["More or less same as above but concurrent using gevent :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \"\"\"Gevent based crontab implementation\"\"\"\n\nfrom datetime import datetime, timedelta\nimport gevent\n\n# Some utility classes / functions first\ndef conv_to_set(obj):\n    \"\"\"Converts to set allowing single integer to be provided\"\"\"\n\n    if isinstance(obj, (int, long)):\n        return set([obj])  # Single item\n    if not isinstance(obj, set):\n        obj = set(obj)\n    return obj\n\nclass AllMatch(set):\n    \"\"\"Universal set - match everything\"\"\"\n    def __contains__(self, item): \n        return True\n\nallMatch = AllMatch()\n\nclass Event(object):\n    \"\"\"The Actual Event Class\"\"\"\n\n    def __init__(self, action, minute=allMatch, hour=allMatch, \n                       day=allMatch, month=allMatch, daysofweek=allMatch, \n                       args=(), kwargs={}):\n        self.mins = conv_to_set(minute)\n        self.hours = conv_to_set(hour)\n        self.days = conv_to_set(day)\n        self.months = conv_to_set(month)\n        self.daysofweek = conv_to_set(daysofweek)\n        self.action = action\n        self.args = args\n        self.kwargs = kwargs\n\n    def matchtime(self, t1):\n        \"\"\"Return True if this event should trigger at the specified datetime\"\"\"\n        return ((t1.minute     in self.mins) and\n                (t1.hour       in self.hours) and\n                (t1.day        in self.days) and\n                (t1.month      in self.months) and\n                (t1.weekday()  in self.daysofweek))\n\n    def check(self, t):\n        \"\"\"Check and run action if needed\"\"\"\n\n        if self.matchtime(t):\n            self.action(*self.args, **self.kwargs)\n\nclass CronTab(object):\n    \"\"\"The crontab implementation\"\"\"\n\n    def __init__(self, *events):\n        self.events = events\n\n    def _check(self):\n        \"\"\"Check all events in separate greenlets\"\"\"\n\n        t1 = datetime(*datetime.now().timetuple()[:5])\n        for event in self.events:\n            gevent.spawn(event.check, t1)\n\n        t1 += timedelta(minutes=1)\n        s1 = (t1 - datetime.now()).seconds + 1\n        print \"Checking again in %s seconds\" % s1\n        job = gevent.spawn_later(s1, self._check)\n\n    def run(self):\n        \"\"\"Run the cron forever\"\"\"\n\n        self._check()\n        while True:\n            gevent.sleep(60)\n\nimport os \ndef test_task():\n    \"\"\"Just an example that sends a bell and asd to all terminals\"\"\"\n\n    os.system('echo asd | wall')  \n\ncron = CronTab(\n  Event(test_task, 22, 1 ),\n  Event(test_task, 0, range(9,18,2), daysofweek=range(0,5)),\n)\ncron.run()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["One thing that in my searches I've seen is python's sched module which might be the kind of thing you're looking for."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sched", "tag": "a", "pos": 0, "childList": [{"text": "sched", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/sched.html"}, {"text": "sched", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Check out Celery, they have periodic tasks like cron."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Celery", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://celeryq.org/docs/getting-started/periodic-tasks.html"}]}], [{"text": ["maybe this has come up only after the question was asked; I thought I just mention it for completeness sake: http://packages.python.org/APScheduler/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://packages.python.org/APScheduler/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://packages.python.org/APScheduler/"}]}], [{"text": ["There isn't a \"pure python\" way to do this because some other process would have to launch python in order to run your solution.", "Every platform will have one or twenty different ways to launch processes and monitor their progress.", "On unix platforms, cron is the old standard.", "On Mac OS X there is also launchd, which combines cron-like launching with watchdog functionality that can keep your process alive if that's what you want.", "Once python is running, then you can use the sched module to schedule tasks."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sched module", "tag": "a", "pos": 4, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/sched.html"}]}], [{"text": ["Just in case, if you are using windows, there exists a pycron.", "Check out http://sourceforge.net/projects/pycron/ .", "For linux,I will go by either cron or sched."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://sourceforge.net/projects/pycron/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://sourceforge.net/projects/pycron/"}]}], [{"text": ["I have a minor fix for the CronTab class run method avove."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The timing was out by one second leading to a one-second, hard loop at the end of each minute."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class CronTab(object):\n    def __init__(self, *events):\n        self.events = events\n\n    def run(self):\n        t=datetime(*datetime.now().timetuple()[:5])\n        while 1:\n            for e in self.events:\n                e.check(t)\n\n            t += timedelta(minutes=1)\n            n = datetime.now()\n            while n &lt; t:\n                s = (t - n).seconds + 1\n                time.sleep(s)\n                n = datetime.now()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Thanks Brain, it's very elegant way.", "But there is a subtle bug in following code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n t += timedelta(minutes=1)\n        while datetime.now() &lt; t:\n            time.sleep((t - datetime.now()).seconds)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's possible to get  t &lt; datetime.now() in the 'while' block and fall asleep for a long time.", "Accidentally, I've been caught in this trap."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can also try this: http://bitbucket.org/marnold/py-cron"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://bitbucket.org/marnold/py-cron", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bitbucket.org/marnold/py-cron"}]}], [{"text": ["Brian's solution is working quite well.", "However, as others have pointed out, there is a subtle bug in the run code.", "Also i found it overly complicated for the needs."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Brian's solution", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/373335/suggestions-for-a-cron-like-scheduler-in-python/374207#374207"}]}, {"text": ["Here is my simpler and functional alternative for the run code in case anybody needs it:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def run(self):\n    while 1:\n        t = datetime.now()\n        for e in self.events:\n            e.check(t)\n\n        time.sleep(60 - t.second - t.microsecond / 1000000.0)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I took Brian's solution, made a few changes, added the beginnings of a standard crontab file parser, and put it at https://bitbucket.org/dbenamy/devcron."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "https://bitbucket.org/dbenamy/devcron", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://bitbucket.org/dbenamy/devcron"}]}], [{"text": ["I don't know if something like that already exists.", "It would be easy to write your own with time, datetime and/or calendar modules, see http://docs.python.org/library/time.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/time.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/time.html"}]}, {"text": ["The only concern for a python solution is that your job needs to be always running and possibly be automatically \"resurrected\" after a reboot, something for which you do need to rely on system dependent solutions. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "do", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}]]