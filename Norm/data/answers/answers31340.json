[[{"text": ["Python's a fairly easy language to thread in, but there are caveats.", "The biggest thing you need to know about is the Global Interpreter Lock.", "This allows only one thread to access the interpreter.", "This means two things:  1)  you rarely ever find yourself using a lock statement in python and 2) if you want to take advantage of multi-processor systems, you have to use separate processes.", "EDIT:  I should also point out that you can put some of the code in C/C++ if you want to get around the GIL as well."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Thus, you need to re-consider why you want to use threads.", "If you want to parallelize your app to take advantage of dual-core architecture, you need to consider breaking your app up into multiple processes."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you want to improve responsiveness, you should CONSIDER using threads.", "There are other alternatives though, namely microthreading.", "There are also some frameworks that you should look into:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "microthreading", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Microthread"}]}, {"text": ["stackless python"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "stackless python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.stackless.com/"}]}, {"text": ["Kamaelia"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Kamaelia", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://edit.kamaelia.org/Home"}]}, {"text": ["greenlets "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "greenlets", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://codespeak.net/py/dist/greenlet.html"}]}], [{"text": ["Yes, because of the Global Interpreter Lock (GIL) there can only run one thread at a time.", "Here are some links with some insights about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": ["http://blog.snaplogic.org/?p=94"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["http://www.artima.com/weblogs/viewpost.jsp?thread=214235"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}, {"text": ["http://effbot.org/pyfaq/can-t-we-get-rid-of-the-global-interpreter-lock.htm"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}, {"text": ["http://smoothspan.wordpress.com/2007/09/14/guido-is-right-to-leave-the-gil-in-python-not-for-multicore-but-for-utility-computing/"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}]}, {"text": ["From the last link an interesting quote:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["If you want to use multi core, pyprocessing defines an process based API to do real parallelization.", "The PEP also includes some interesting benchmarks."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "pyprocessing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0371/"}, {"text": "PEP", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Python_Enhancement_Proposal#Development"}]}], [{"text": ["Below is a basic threading sample.", "It will spawn 20 threads; each thread will output its thread number.", "Run it and observe the order in which they print."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import threading\nclass Foo (threading.Thread):\n    def __init__(self,x):\n        self.__x = x\n        threading.Thread.__init__(self)\n    def run (self):\n          print str(self.__x)\n\nfor x in xrange(20):\n    Foo(x).start()\n</code>\n</pre>\n", "senID": 1}, {"text": ["As you have hinted at Python threads are implemented through time-slicing.", "This is how they get the \"parallel\" effect. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In my example my Foo class extends thread, I then implement the run method, which is where the code that you would like to run in a thread goes.", "To start the thread you call start() on the thread object, which will automatically invoke the run method..."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "run", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "start()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "run", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Of course, this is just the very basics.", "You will eventually want to learn about semaphores, mutexes, and locks for thread synchronization and message passing."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Use threads in python if the individual workers are doing I/O bound operations.", "If you are trying to scale across multiple cores on a machine either find a good IPC framework for python or pick a different language."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "IPC", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0371/"}]}], [{"text": ["Try to remember that the GIL is set to poll around every so often in order to do show the appearance of multiple tasks.", "This setting can be fine tuned, but I offer the suggestion that there should be work that the threads are doing or lots of context switches are going to cause problems."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I would go so far as to suggest multiple parents on processors and try to keep like jobs on the same core(s)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]