[[{"text": ["AFAIK, len is special in this respect and has historical roots."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "len", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Here's a quote from the FAQ:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "from the FAQ", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/faq/design.html"}]}, {"text": ["The other \"magical methods\" (actually called special method in the Python folklore) make lots of sense, and similar functionality exists in other languages.", "They're mostly used for code that gets called implicitly when special syntax is used."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "special method", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "overloaded operators (exist in C++ and others)", "tag": "none", "senID": 4}, {"text": "constructor/destructor", "tag": "none", "senID": 5}, {"text": "hooks for accessing attributes", "tag": "none", "senID": 6}, {"text": "tools for metaprogramming", "tag": "none", "senID": 7}]}, {"text": ["and so on..."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["From the Zen of Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is one of the reasons - with custom methods, developers would be free to choose a different method name, like getLength(), length(), getlength() or whatsoever.", "Python enforces strict naming so that the common function len() can be used."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "getLength()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "length()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "getlength()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "len()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["All operations that are common for many types of objects are put into magic methods, like __nonzero__, __len__ or __repr__.", "They are mostly optional, though."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "__nonzero__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__len__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__repr__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Operator overloading is also done with magic methods (e.g.", "__le__), so it makes sense to use them for other common operations, too."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "__le__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Some of these functions do more than a single method would be able to implement (without abstract methods on a superclass).", "For instance bool() acts kind of like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "bool()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def bool(obj):\n    if hasattr(obj, '__bool__'):\n        return bool(obj.__nonzero__())\n    elif hasattr(obj, '__len__'):\n        if obj.__len__():\n            return True\n        else:\n            return False\n    return True\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can also be 100% sure that bool() will always return True or False; if you relied on a method you couldn't be entirely sure what you'd get back."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "bool()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Some other functions that have relatively complicated implementations (more complicated than the underlying magic methods are likely to be) are iter() and cmp(), and all the attribute methods (getattr, setattr and delattr).", "Things like int also access magic methods when doing coercion (you can implement __int__), but do double duty as types.", "len(obj) is actually the one case where I don't believe it's ever different from obj.__len__()."], "childNum": 9, "tag": "p", "senID": 3, "childList": [{"text": "iter()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "cmp()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "getattr", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "setattr", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "delattr", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__int__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "len(obj)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "obj.__len__()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["They are not really \"magic names\".", "It's just the interface an object has to implement to provide a given service.", "In this sense, they are not more magic than any predefined interface definition you have to reimplement."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["There is not a lot to add to the above two posts, but all the \"magic\" functions are not really magic at all.", "They are part of the __ builtins__ module which is implicitly/automatically imported when the interpreter starts.", "IE:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from __builtins__ import *\n</code>\n</pre>\n", "senID": 1}, {"text": ["happens every time before your program starts."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I always thought it would be more correct if python only did this for the interactive shell, and required scripts to import the various parts from builtins they needed.", "Also probably different __ main__ handling would be nice in shells vs interactive.", "Anyways, check out all the functions, and see what it is like without them:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n dir (__builtins__)\n...\ndel __builtins__\n</code>\n</pre>\n", "senID": 4}], [{"text": ["While the reason is mostly historic, there are some peculiarities in Python's len that make the use of a function instead of a method appropriate. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "len", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Some operations in Python are implemented as methods, for example list.index and dict.append, while others are implemented as callables and magic methods, for example str and iter and reversed.", "The two groups differ enough so the different approach is justified:"], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "list.index", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict.append", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "iter", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "reversed", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["I personally call the first group method-like and the second group operator-like.", "It's not a very good distinction, but I hope it helps somehow."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Having said this, len doesn't exactly fit in the second group.", "It's more close to the operations in the first one, with the only difference that it's way more common than almost any of them.", "But the only thing that it does is calling __len__, and it's very close to L.index.", "However, there are some differences.", "For example, __len__ might be called for the implementation of other features, such as bool, if the method was called len you might break bool(x) with custom len method that does completely different thing."], "childNum": 8, "tag": "p", "senID": 3, "childList": [{"text": "len", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__len__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "L.index", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__len__", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "bool", "childNum": 0, "tag": "code", "childList": []}, {"text": "len", "childNum": 0, "tag": "code", "childList": []}, {"text": "bool(x)", "childNum": 0, "tag": "code", "childList": []}, {"text": "len", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In short, you have a set of very common features that classes might implement that might be accessed through an operator, through a special function (that usually does more than the implementation, as an operator would), during object construction, and all of them share some common traits.", "All the rest is a method.", "And len is somewhat of an exception to that rule."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "len", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}]]