[[{"text": ["In Python, there is a difference between functions and bound methods."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo():\n...     print \"foo\"\n...\n&gt;&gt;&gt; class A:\n...     def bar( self ):\n...         print \"bar\"\n...\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; foo\n&lt;function foo at 0x00A98D70&gt;\n&gt;&gt;&gt; a.bar\n&lt;bound method A.bar of &lt;__main__.A instance at 0x00A9BC88&gt;&gt;\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Bound methods have been \"bound\" (how descriptive) to an instance, and that instance will be passed as the first argument whenever the method is called."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Callables that are attributes of a class (as opposed to an instance) are still unbound, though, so you can modify the class definition whenever you want:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def fooFighters( self ):\n...     print \"fooFighters\"\n...\n&gt;&gt;&gt; A.fooFighters = fooFighters\n&gt;&gt;&gt; a2 = A()\n&gt;&gt;&gt; a2.fooFighters\n&lt;bound method A.fooFighters of &lt;__main__.A instance at 0x00A9BEB8&gt;&gt;\n&gt;&gt;&gt; a2.fooFighters()\nfooFighters\n</code>\n</pre>\n", "senID": 4}, {"text": ["Previously defined instances are updated as well (as long as they haven't overridden the attribute themselves):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a.fooFighters()\nfooFighters\n</code>\n</pre>\n", "senID": 6}, {"text": ["The problem comes when you want to attach a method to a single instance:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def barFighters( self ):\n...     print \"barFighters\"\n...\n&gt;&gt;&gt; a.barFighters = barFighters\n&gt;&gt;&gt; a.barFighters()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: barFighters() takes exactly 1 argument (0 given)\n</code>\n</pre>\n", "senID": 8}, {"text": ["The function is not automatically bound when it's attached directly to an instance:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a.barFighters\n&lt;function barFighters at 0x00A98EF0&gt;\n</code>\n</pre>\n", "senID": 10}, {"text": ["To bind it, we can use the MethodType function in the types module:"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "MethodType function in the types module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/types.html?highlight=methodtype#module-types"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import types\n&gt;&gt;&gt; a.barFighters = types.MethodType( barFighters, a )\n&gt;&gt;&gt; a.barFighters\n&lt;bound method ?.barFighters of &lt;__main__.A instance at 0x00A9BC88&gt;&gt;\n&gt;&gt;&gt; a.barFighters()\nbarFighters\n</code>\n</pre>\n", "senID": 12}, {"text": ["This time other instances of the class have not been affected:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a2.barFighters()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: A instance has no attribute 'barFighters'\n</code>\n</pre>\n", "senID": 14}, {"text": ["More information can be found by reading about descriptors and metaclass programming."], "childNum": 3, "tag": "p", "senID": 15, "childList": [{"text": "descriptors", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://users.rcn.com/python/download/Descriptor.htm"}, {"href": "http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html", "text": "metaclass", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://www.gnosis.cx/publish/programming/metaclass_2.html", "text": "programming", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Module new is deprecated since python 2.6 and removed in 3.0, use types"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "new", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "types", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["see docs.python.org/library/new.html"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In the example below I've deliberately removed return value from patch_me() function.", "I think that giving return value may make one believe that patch returns a new object, which is not true - it modifies the incoming one.", "Probably this can facilitate a more disciplined use of monkeypatching."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import types\n\nclass A(object):#but seems to work for old style objects too\n    pass\n\ndef patch_me(target):\n    def method(target,x):\n        print \"x=\",x\n        print \"called from\", target\n    target.method = types.MethodType(method,target)\n    #add more if needed\n\na = A()\nprint a\n#out: &lt;__main__.A object at 0x2b73ac88bfd0&gt;  \npatch_me(a)    #patch instance\na.method(5)\n#out: x= 5\n#out: called from &lt;__main__.A object at 0x2b73ac88bfd0&gt;\npatch_me(A)\nA.method(6)        #can patch class too\n#out: x= 6\n#out: called from &lt;class '__main__.A'&gt;\n</code>\n</pre>\n", "senID": 3}], [{"text": ["In Python monkey patching generally works by overwriting a class or functions signature with your own.", "Below is an example from the Zope Wiki:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Zope Wiki", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://wiki.zope.org/zope2/MonkeyPatch"}]}, {"code": "<pre>\n<code>\n from SomeOtherProduct.SomeModule import SomeClass\n <br />\n def speak(self):\n <br />\n return \"ook ook eee eee eee!\"\n <br />\n SomeClass.speak = speak\n <br />\n</code>\n</pre>\n", "senID": 1}, {"text": ["That code will overwrite/create a method called speak on the class.", "In Jeff Atwood's recent post on monkey patching.", "He shows an example in C# 3.0 which is the current language I use for work."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "recent post on monkey patching", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.codinghorror.com/blog/archives/001151.html"}]}], [{"text": ["I also don't know Python, but this struck me as something that should be rather easy to find in Google."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I was right.", "(Note, I don't actually know if this is what you want, but it sure sounds like it."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "I was right.", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/monkey"}]}], [{"text": ["I don't know Python syntax, but I know Ruby can do it, and it is rather trivial.", "Let's say you want to add a method to Array that prints the length to standard out:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Array\n <br />\n def print_length\n <br />\n puts length\n <br />\n end\n <br />\n end\n <br />\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you don't want to modify the whole class, you can just add the method to a single instance of the array, and no other arrays will have the method:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n array = [1, 2, 3]\n <br />\n def array.print_length\n <br />\n puts length\n <br />\n end\n <br />\n</code>\n</pre>\n", "senID": 3}, {"text": ["Just be aware of the issues involved in using this feature.", "Jeff Atwood actually wrote about it not too long ago."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "wrote about it", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.codinghorror.com/blog/archives/001151.html"}]}], [{"text": ["(I'm invoking the \"I don't know Python\" line here.", ") In Perl, you can create a package (which is how Perl implements the concept of a class) with the methods you want to patch in, then add that package to the @ISA of the package you want to patch.", "Heck, you can even edit the target package's symbol table directly."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@ISA", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["What you're looking for is setattr I believe.", "Use this to set an attribute on an object."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "setattr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def printme(s): print repr(s)\n <br />\n &gt;&gt;&gt; class A: pass\n <br />\n &gt;&gt;&gt; setattr(A,'printme',printme)\n <br />\n &gt;&gt;&gt; a = A()\n <br />\n &gt;&gt;&gt; a.printme() # s becomes the implicit 'self' variable\n <br />\n &lt; __ main __ . A instance at 0xABCDEFG&gt;\n <br />\n</code>\n</pre>", "senID": 1}], [{"text": ["What Jason Pratt posted is correct."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class Test(object):\n...   def a(self):\n...     pass\n... \n&gt;&gt;&gt; def b(self):\n...   pass\n... \n&gt;&gt;&gt; Test.b = b\n&gt;&gt;&gt; type(b)\n&lt;type 'function'&gt;\n&gt;&gt;&gt; type(Test.a)\n&lt;type 'instancemethod'&gt;\n&gt;&gt;&gt; type(Test.b)\n&lt;type 'instancemethod'&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["As you can see, Python doesn't consider b() any different than a().", "In Python all methods are just variables that happen to be functions. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]