[[{"text": ["My first instinct would be to refactor the nested loop into a function and use return to break out. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "return", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["PEP 3136 proposes labeled break/continue.", "Guido rejected it because \"code so complicated to require this feature is very rare\".", "The PEP does mention some workarounds, though (such as the exception technique), while Guido feels refactoring to use return will be simpler in most cases."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "PEP 3136", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3136/"}, {"text": "rejected it", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-3000/2007-July/008663.html"}]}], [{"text": ["First, you may also consider making the process of getting and validating the input a function; within that function, you can just return the value if its correct, and keep spinning in the while loop if not.", "This essentially obviates the problem you solved, and can usually be applied in the more general case (breaking out of multiple loops).", "If you absolutely must keep this structure in your code, and really don't want to deal with bookkeeping booleans..."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "while", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["You may also use goto in the following way (using an April Fools module from here):"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "goto", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"href": "http://entrian.com/goto/", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n #import the stuff\nfrom goto import goto, label\n\nwhile True:\n    #snip: print out current state\n    while True:\n        ok = get_input(\"Is this ok? (y/n)\")\n        if ok == \"y\" or ok == \"Y\": goto .breakall\n        if ok == \"n\" or ok == \"N\": break\n    #do more processing with menus and stuff\nlabel .breakall\n</code>\n</pre>\n", "senID": 2}, {"text": ["I know, I know, \"thou shalt not use goto\" and all that, but it works well in strange cases like this."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["First, ordinary logic is helpful.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If, for some reason, the terminating conditions can't be worked out, exceptions are a fall-back plan.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class GetOutOfLoop( Exception ):\n     pass\n\ntry:\n    done= False\n    while not done:\n        isok= False\n        while not (done or isok):\n            ok = get_input(\"Is this ok? (y/n)\")\n            if ok in (\"y\", \"Y\") or ok in (\"n\", \"N\") : \n                done= True # probably better\n                raise GetOutOfLoop\n        # other stuff\nexcept GetOutOfLoop:\n    pass\n</code>\n</pre>\n", "senID": 2}, {"text": ["For this specific example, an exception may not be necessary.  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["On other other hand, we often have \"Y\", \"N\" and \"Q\" options in character-mode applications.", "For the \"Q\" option, we want an immediate exit.", "That's more exceptional."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n keeplooping=True\nwhile keeplooping:\n    #Do Stuff\n    while keeplooping:\n          #do some other stuff\n          if finisheddoingstuff(): keeplooping=False\n</code>\n</pre>\n", "senID": 0}, {"text": ["or something like that.", "You could set a variable in the inner loop, and check it in the outer loop immediately after the inner loop exits, breaking if appropriate.", "I kinda like the GOTO method, provided you don't mind using an April Fool's joke module - its not Pythonic, but it does make sense."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This isn't the prettiest way to do it, but in my opinion, it's the best way.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def loop():\n    while True:\n    #snip: print out current state\n        while True:\n            ok = get_input(\"Is this ok? (y/n)\")\n            if ok == \"y\" or ok == \"Y\": return\n            if ok == \"n\" or ok == \"N\": break\n        #do more processing with menus and stuff\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm pretty sure you could work out something using recursion here as well, but I dunno if that's a good option for you."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I tend to agree that refactoring into a function is usually the best approach for this sort of situation, but for when you really need to break out of nested loops, here's an interesting variant of the exception-raising approach that @S.Lott described.", "It uses Python's with statement to make the exception raising look a bit nicer.", "Define a new context manager (you only have to do this once) with:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "really", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "with", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from contextlib import contextmanager\n@contextmanager\ndef nested_break():\n    class NestedBreakException(Exception):\n        pass\n    try:\n        yield NestedBreakException\n    except NestedBreakException:\n        pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now you can use this context manager as follows:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n with nested_break() as mylabel:\n    while True:\n        print \"current state\"\n        while True:\n            ok = raw_input(\"Is this ok? (y/n)\")\n            if ok == \"y\" or ok == \"Y\": raise mylabel\n            if ok == \"n\" or ok == \"N\": break\n        print \"more processing\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["Advantages: (1) it's slightly cleaner (no explicit try-except block), and (2) you get a custom-built Exception subclass for each use of nested_break;  no need to declare your own Exception subclass each time."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "Exception", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "nested_break", "childNum": 0, "tag": "code", "childList": []}, {"text": "Exception", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Factor your loop logic into an iterator that yields the loop variables and returns when done -- here is a simple one that lays out images in rows/columns until we're out of images or out of places to put them:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def it(rows, cols, images):\n    i = 0\n    for r in xrange(rows):\n        for c in xrange(cols):\n            if i &gt;= len(images):\n                return\n            yield r, c, images[i]\n            i += 1 \n\nfor r, c, image in it(rows=4, cols=4, images=['a.jpg', 'b.jpg', 'c.jpg']):\n    ... do something with r, c, image ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["This has the advantage of splitting up the complicated loop logic and the processing..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's another approach that is short.", "The disadvantage is that you can only break the outer loop, but sometimes it's exactly what you want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for a in xrange(10):\n    for b in xrange(20):\n        if something(a, b):\n            # Break the inner loop...\n            break\n    else:\n        # Continue if the inner loop wasn't broken.\n        continue\n    # Inner loop was broken, break the outer.\n    break\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Introduce a new variable that you'll use as a 'loop breaker'.", "First assign something to it(False,0, etc.", "), and then, inside the outer loop, before you break from it, change the value to something else(True,1,...).", "Once the loop exits make the 'parent' loop check for that value.", "Let me demonstrate:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n breaker = False #our mighty loop exiter!\nwhile True:\n    while True:\n        if conditionMet:\n            #insert code here...\n            breaker = True \n            break\n    if breaker: # the interesting part!\n        break   # &lt;--- !\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you have an infinite loop, this is the only way out; for other loops execution is really a lot faster.", "This also works if you have many nested loops.", "You can exit all, or just a few.", "Endless possibilities!", "Hope this helped!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]