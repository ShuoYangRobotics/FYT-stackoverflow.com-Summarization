[[{"text": ["Make sure you are not keeping global references to data.", "That prevents the python garbage collector from releasing the memory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Don't use mod_python.", "It loads an interpreter inside apache.", "If you need to use apache, use mod_wsgi instead.", "It is not tricky to switch.", "It is very easy.", "mod_wsgi is way easier to configure for django than brain-dead mod_python."], "childNum": 6, "tag": "p", "senID": 1, "childList": [{"text": "mod_python", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "mod_wsgi", "tag": "a", "pos": 2, "childList": [{"text": "mod_wsgi", "tag": "code"}], "childNum": 1, "href": "http://code.google.com/p/modwsgi/"}, {"text": "mod_wsgi", "childNum": 0, "tag": "code", "pos": 5, "childList": []}, {"text": "mod_wsgi", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://code.google.com/p/modwsgi/wiki/IntegrationWithDjango", "text": "configure for django", "childNum": 0, "tag": "a", "childList": []}, {"text": "mod_python", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you can remove apache from your requirements, that would be even better to your memory.", "spawning seems to be the new fast scalable way to run python web applications."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "spawning", "tag": "a", "pos": 1, "childList": [{"text": "spawning", "tag": "code"}], "childNum": 1, "href": "http://pypi.python.org/pypi/Spawning/0.7"}, {"text": "spawning", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["EDIT: I don't see how switching to mod_wsgi could be \"tricky\".", "It should be a very easy task.", "Please elaborate on the problem you are having with the switch."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "tricky", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}], [{"text": ["If you are running under mod_wsgi, and presumably spawning since it is WSGI compliant, you can use Dozer to look at your memory usage."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Dozer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/Dozer"}]}, {"text": ["Under mod_wsgi just add this at the bottom of your WSGI script:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from dozer import Dozer\napplication = Dozer(application)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then point your browser at http://domain/_dozer/index to see a list of all your memory allocations."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://domain/_dozer/index", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://domain/_dozer/index"}]}, {"text": ["I'll also just add my voice of support for mod_wsgi.", "It makes a world of difference in terms of performance and memory usage over mod_python.", "Graham Dumpleton's support for mod_wsgi is outstanding, both in terms of active development and in helping people on the mailing list to optimize their installations.", "David Cramer at curse.com has posted some charts (which I can't seem to find now unfortunately) showing the drastic reduction in cpu and memory usage after they switched to mod_wsgi on that high traffic site.", "Several of the django devs have switched.", "Seriously, it's a no-brainer :)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "curse.com", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://www.curse.com/"}]}], [{"text": ["These are the Python memory profiler solutions I'm aware of (not Django related):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": ["Heapy"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["pysizer"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}, {"text": ["Python Memory Validator"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}, {"text": ["Pympler"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}]}, {"text": ["Disclaimer: I have a stake in the latter."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The individual project's documentation should give you an idea of how to use these tools to analyze memory behavior of Python applications."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["The following is a nice \"war story\" that also gives some helpful pointers:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": ["Reducing the footprint of python applications"], "childNum": 0, "tag": "a", "senID": 8, "childList": []}]}], [{"text": ["In addition to not keeping around global references to large data objects, try to avoid loading large datasets into memory at all wherever possible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Switch to mod_wsgi in daemon mode, and use Apache's worker mpm instead of prefork.", "This latter step can allow you to serve many more concurrent users with much less memory overhead."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Additionally, check if you do not use any of known leakers.", "MySQLdb is known to leak enormous amounts of memory with Django due to bug in unicode handling.", "Other than that, Django Debug Toolbar might help you to track the hogs."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Django Debug Toolbar", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://github.com/robhudson/django-debug-toolbar/tree/master"}]}], [{"text": ["Another plus for mod_wsgi: set a maximum-requests parameter in your WSGIDaemonProcess directive and mod_wsgi will restart the daemon process every so often.", "There should be no visible effect for the user, other than a slow page load the first time a fresh process is hit, as it'll be loading Django and your application code into memory."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "maximum-requests", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "WSGIDaemonProcess", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["But even if you do have memory leaks, that should keep the process size from getting too large, without having to interrupt service to your users."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "do", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Webfaction actually has some tips for keeping django memory usage down."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "some tips", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://blog.webfaction.com/tips-to-keep-your-django-mod-python-memory-usage-down"}]}, {"text": ["The major points:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 6, "lis": [{"text": "Make sure debug is set to false (you already know that).", "tag": "none", "senID": 2}, {"text": "Use \"ServerLimit\" in your apache config", "tag": "none", "senID": 3}, {"text": "Check that no big objects are being loaded in memory", "tag": "none", "senID": 4}, {"text": "Consider serving static content in a separate process or server.", "tag": "none", "senID": 5}, {"text": "Use \"MaxRequestsPerChild\" in your apache config", "tag": "none", "senID": 6}, {"text": "Find out and understand how much memory you're using", "tag": "none", "senID": 7}]}], [{"text": ["Here is the script I use for mod_wsgi (called wsgi.py, and put in the root off my django project):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\nimport sys\nimport django.core.handlers.wsgi\n\nfrom os import path\n\nsys.stdout = open('/dev/null', 'a+')\nsys.stderr = open('/dev/null', 'a+')\n\nsys.path.append(path.join(path.dirname(__file__), '..'))\n\nos.environ['DJANGO_SETTINGS_MODULE'] = 'myproject.settings'\napplication = django.core.handlers.wsgi.WSGIHandler()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Adjust myproject.settings and the path as needed.", "I redirect all output to /dev/null since mod_wsgi by default prevents printing.", "Use logging instead."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For apache:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &lt;VirtualHost *&gt;\n   ServerName myhost.com\n\n   ErrorLog /var/log/apache2/error-myhost.log\n   CustomLog /var/log/apache2/access-myhost.log common\n\n   DocumentRoot \"/var/www\"\n\n   WSGIScriptAlias / /path/to/my/wsgi.py\n\n&lt;/VirtualHost&gt;\n</code>\n</pre>\n", "senID": 4}, {"text": ["Hopefully this should at least help you set up mod_wsgi so you can see if it makes a difference."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Caches: make sure they're being flushed.", "Its easy for something to land in a cache, but never be GC'd because of the cache reference."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Swig'd code: Make sure any memory management is being done correctly, its really easy to miss these in python, especially with third party libraries"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Monitoring: If you can, get data about memory usage and hits.", "Usually you'll see a correlation between a certain type of request and memory usage."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["We stumbled over a bug in Django with big sitemaps (10.000 items).", "Seems Django is trying to load them all in memory when generating the sitemap: http://code.djangoproject.com/ticket/11572 - effectively kills the apache process when Google pays a visit to the site."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.djangoproject.com/ticket/11572", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.djangoproject.com/ticket/11572"}]}]]