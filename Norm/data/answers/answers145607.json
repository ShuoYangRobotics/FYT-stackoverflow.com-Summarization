[[{"text": ["Look at difflib.", "(Python)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "difflib", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-difflib.html"}]}, {"text": ["That will calculate the diffs in various formats.", "You could then use the size of the context diff as a measure of how different two documents are?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I can recommend to take a look at Neil Fraser's code and articles:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["google-diff-match-patch"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "google-diff-match-patch", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/google-diff-match-patch/"}]}, {"text": ["Neil Fraser: Diff Strategies - for theory and implementation notes"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Neil Fraser: Diff Strategies", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://neil.fraser.name/writing/diff/"}]}], [{"text": ["In Python, there is difflib, as also others have suggested."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "difflib", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-difflib.html"}]}, {"text": ["difflib offers the SequenceMatcher class, which can be used to give you a similarity ratio.", "Example function:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "difflib", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "SequenceMatcher", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/sequence-matcher.html"}]}, {"code": "<pre>\n<code>\n def text_compare(text1, text2, isjunk=None):\n    return difflib.SequenceMatcher(isjunk, text1, text2).ratio()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Bazaar contains an alternative difference algorithm, called patience diff (there's more info in the comments on that page) which is claimed to be better than the traditional diff algorithm.", "The file 'patiencediff.py' in the bazaar distribution is a simple command line front end."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Bazaar", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bazaar-vcs.org/"}, {"text": "patience diff", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://bramcohen.livejournal.com/37690.html"}]}], [{"text": ["If you need a finer granularity than lines, you can use Levenshtein distance.", "Levenshtein distance is a straight-forward measure on how to similar two texts are.", "You can also use it to extract the edit logs and can a very fine-grained diff, similar to that on the edit history pages of SO.", "Be warned though that Levenshtein distance can be quite CPU- and memory-intensive to calculate, so using difflib,as Douglas Leder suggested, is most likely going to be faster."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["Cf.", "also this answer."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "this answer", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/132478/how-to-perform-string-diffs-in-java#132547"}]}], [{"text": ["My current understanding is that the best solution to the Shortest Edit Script (SES) problem is Myers \"middle-snake\" method with the Hirschberg linear space refinement."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The Myers algorithm is described in:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The GNU diff utility uses the Myers algorighm."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The \"similarity score\" you speak of is called the \"edit distance\" in the literature which is the number of inserts or deletes necessary to transform one sequence into the other."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Note that a number of people have cited the Levenshtein distance algorithm but that is, albeit easy to implement, not the optimal solution as it is inefficient (requires the use of a possibly huge n*m matrix) and does not provide the \"edit script\" which is the sequence of edits that could be used to transform one sequence into the other and visa versa."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["For a good Myers / Hirschberg implementation look at:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["http://www.ioplex.com/~miallen/libmba/dl/src/diff.c"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "http://www.ioplex.com/~miallen/libmba/dl/src/diff.c", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ioplex.com/~miallen/libmba/dl/src/diff.c"}]}, {"text": ["The particular library that it is contained within is not longer maintained but to my knowledge the diff.c module itself is still correct."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Mike"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["As stated, use difflib.", "Once you have the diffed output, you may find the Levenshtein distance of the different strings as to give a \"value\" of how different they are."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Levenshtein distance", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Levenshtein_distance"}]}], [{"text": ["There are a number of distance metrics, as paradoja mentioned there is the Levenshtein distance, but there is also NYSIIS and Soundex.", "In terms of Python implementations, I have used py-editdist and ADVAS before.", "Both are nice in the sense that you get a single number back as a score.", "Check out ADVAS first, it implements a bunch of algorithms."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "NYSIIS", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/New_York_State_Identification_and_Intelligence_System"}, {"text": "Soundex", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Soundex"}, {"text": "py-editdist", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.mindrot.org/projects/py-editdist/"}, {"text": "ADVAS", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://advas.sourceforge.net/"}]}], [{"text": ["You could use the solution to the Longest Common Subsequence (LCS) problem.", "See also the discussion about possible ways to optimize this solution."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "solution to the Longest Common Subsequence (LCS) problem", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Longest_common_subsequence_problem#Code_for_the_dynamic_programming_solution"}]}], [{"text": ["One method I've employed for a different functionality, to calculate how much data was new in a modified file, could perhaps work for you as well."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I have a diff/patch implementation C# that allows me to take two files, presumably old and new version of the same file, and calculate the \"difference\", but not in the usual sense of the word.", "Basically I calculate a set of operations that I can perform on the old version to update it to have the same contents as the new version."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["To use this for the functionality initially described, to see how much data was new, I simple ran through the operations, and for every operation that copied from the old file verbatim, that had a 0-factor, and every operation that inserted new text (distributed as part of the patch, since it didn't occur in the old file) had a 1-factor.", "All characters was given this factory, which gave me basically a long list of 0's and 1's."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["All I then had to do was to tally up the 0's and 1's.", "In your case, with my implementation, a low number of 1's compared to 0's would mean the files are very similar."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["This implementation would also handle cases where the modified file had inserted copies from the old file out of order, or even duplicates (ie.", "you copy a part from the start of the file and paste it near the bottom), since they would both be copies of the same original part from the old file."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I experimented with weighing copies, so that the first copy counted as 0, and subsequent copies of the same characters had progressively higher factors, in order to give a copy/paste operation some \"new-factor\", but I never finished it as the project was scrapped."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["If you're interested, my diff/patch code is available from my Subversion repository."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]