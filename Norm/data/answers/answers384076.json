[[{"text": ["I already knew about the color escapes, I used them in my bash prompt a while ago.", "Thanks anyway.", "What I wanted was to integrate it with the logging module, which I eventually did after a couple of tries and errors.", "Here is what I end up with:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE = range(8)\n\n#The background is set with 40 plus the number of the color, and the foreground with 30\n\n#These are the sequences need to get colored ouput\nRESET_SEQ = \"\\033[0m\"\nCOLOR_SEQ = \"\\033[1;%dm\"\nBOLD_SEQ = \"\\033[1m\"\n\ndef formatter_message(message, use_color = True):\n    if use_color:\n        message = message.replace(\"$RESET\", RESET_SEQ).replace(\"$BOLD\", BOLD_SEQ)\n    else:\n        message = message.replace(\"$RESET\", \"\").replace(\"$BOLD\", \"\")\n    return message\n\nCOLORS = {\n    'WARNING': YELLOW,\n    'INFO': WHITE,\n    'DEBUG': BLUE,\n    'CRITICAL': YELLOW,\n    'ERROR': RED\n}\n\nclass ColoredFormatter(logging.Formatter):\n    def __init__(self, msg, use_color = True):\n        logging.Formatter.__init__(self, msg)\n        self.use_color = use_color\n\n    def format(self, record):\n        levelname = record.levelname\n        if self.use_color and levelname in COLORS:\n            levelname_color = COLOR_SEQ % (30 + COLORS[levelname]) + levelname + RESET_SEQ\n            record.levelname = levelname_color\n        return logging.Formatter.format(self, record)\n</code>\n</pre>\n", "senID": 1}, {"text": ["And to use it, create your own Logger:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # Custom logger class with multiple destinations\nclass ColoredLogger(logging.Logger):\n    FORMAT = \"[$BOLD%(name)-20s$RESET][%(levelname)-18s]  %(message)s ($BOLD%(filename)s$RESET:%(lineno)d)\"\n    COLOR_FORMAT = formatter_message(FORMAT, True)\n    def __init__(self, name):\n        logging.Logger.__init__(self, name, logging.DEBUG)                \n\n        color_formatter = ColoredFormatter(self.COLOR_FORMAT)\n\n        console = logging.StreamHandler()\n        console.setFormatter(color_formatter)\n\n        self.addHandler(console)\n        return\n\n\nlogging.setLoggerClass(ColoredLogger)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Just in case anyone else needs it."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Here is a solution that should work on any platform.", "If it doesn't just tell me and I will update it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["How it works: on platform supporting ANSI escapes is using them (non-Windows) and on Windows it does use API calls to change the console colors."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The script does hack the logging.StreamHandler.emit method from standard library adding a wrapper to it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["TestColorer.py"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "TestColorer.py", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n# Usage: add Colorer.py near you script and import it.\nimport logging\nimport Colorer\n\nlogging.warn(\"a warning\")\nlogging.error(\"some error\")\nlogging.info(\"some info\")\n</pre>\n", "senID": 4}, {"text": ["Colorer.py"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Colorer.py", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n#!/usr/bin/env python\n# encoding: utf-8\nimport logging\n# now we patch Python code to add color support to logging.StreamHandler\ndef add_coloring_to_emit_windows(fn):\n        # add methods we need to the class\n    def _out_handle(self):\n        import ctypes\n        return ctypes.windll.kernel32.GetStdHandle(self.STD_OUTPUT_HANDLE)\n    out_handle = property(_out_handle)\n\n    def _set_color(self, code):\n        import ctypes\n        # Constants from the Windows API\n        self.STD_OUTPUT_HANDLE = -11\n        hdl = ctypes.windll.kernel32.GetStdHandle(self.STD_OUTPUT_HANDLE)\n        ctypes.windll.kernel32.SetConsoleTextAttribute(hdl, code)\n\n    setattr(logging.StreamHandler, '_set_color', _set_color)\n\n    def new(*args):\n        FOREGROUND_BLUE      = 0x0001 # text color contains blue.\n        FOREGROUND_GREEN     = 0x0002 # text color contains green.\n        FOREGROUND_RED       = 0x0004 # text color contains red.\n        FOREGROUND_INTENSITY = 0x0008 # text color is intensified.\n        FOREGROUND_WHITE     = FOREGROUND_BLUE|FOREGROUND_GREEN |FOREGROUND_RED\n       # winbase.h\n        STD_INPUT_HANDLE = -10\n        STD_OUTPUT_HANDLE = -11\n        STD_ERROR_HANDLE = -12\n\n        # wincon.h\n        FOREGROUND_BLACK     = 0x0000\n        FOREGROUND_BLUE      = 0x0001\n        FOREGROUND_GREEN     = 0x0002\n        FOREGROUND_CYAN      = 0x0003\n        FOREGROUND_RED       = 0x0004\n        FOREGROUND_MAGENTA   = 0x0005\n        FOREGROUND_YELLOW    = 0x0006\n        FOREGROUND_GREY      = 0x0007\n        FOREGROUND_INTENSITY = 0x0008 # foreground color is intensified.\n\n        BACKGROUND_BLACK     = 0x0000\n        BACKGROUND_BLUE      = 0x0010\n        BACKGROUND_GREEN     = 0x0020\n        BACKGROUND_CYAN      = 0x0030\n        BACKGROUND_RED       = 0x0040\n        BACKGROUND_MAGENTA   = 0x0050\n        BACKGROUND_YELLOW    = 0x0060\n        BACKGROUND_GREY      = 0x0070\n        BACKGROUND_INTENSITY = 0x0080 # background color is intensified.     \n\n        levelno = args[1].levelno\n        if(levelno>=50):\n            color = BACKGROUND_YELLOW | FOREGROUND_RED | FOREGROUND_INTENSITY | BACKGROUND_INTENSITY \n        elif(levelno>=40):\n            color = FOREGROUND_RED | FOREGROUND_INTENSITY\n        elif(levelno>=30):\n            color = FOREGROUND_YELLOW | FOREGROUND_INTENSITY\n        elif(levelno>=20):\n            color = FOREGROUND_GREEN\n        elif(levelno>=10):\n            color = FOREGROUND_MAGENTA\n        else:\n            color =  FOREGROUND_WHITE\n        args[0]._set_color(color)\n\n        ret = fn(*args)\n        args[0]._set_color( FOREGROUND_WHITE )\n        #print \"after\"\n        return ret\n    return new\n\ndef add_coloring_to_emit_ansi(fn):\n    # add methods we need to the class\n    def new(*args):\n        levelno = args[1].levelno\n        if(levelno>=50):\n            color = '\\x1b[31m' # red\n        elif(levelno>=40):\n            color = '\\x1b[31m' # red\n        elif(levelno>=30):\n            color = '\\x1b[33m' # yellow\n        elif(levelno>=20):\n            color = '\\x1b[32m' # green \n        elif(levelno>=10):\n            color = '\\x1b[35m' # pink\n        else:\n            color = '\\x1b[0m' # normal\n        args[1].msg = color + args[1].msg +  '\\x1b[0m'  # normal\n        #print \"after\"\n        return fn(*args)\n    return new\n\nimport platform\nif platform.system()=='Windows':\n    # Windows does not support ANSI escapes and we are using API calls to set the console color\n    logging.StreamHandler.emit = add_coloring_to_emit_windows(logging.StreamHandler.emit)\nelse:\n    # all non-Windows platforms are supporting ANSI escapes so we use them\n    logging.StreamHandler.emit = add_coloring_to_emit_ansi(logging.StreamHandler.emit)\n    #log = logging.getLogger()\n    #log.addFilter(log_filter())\n    #//hdlr = logging.StreamHandler()\n    #//hdlr.setFormatter(formatter())\n</pre>\n", "senID": 6}], [{"text": ["I updated the example from airmind supporting tags for foreground and background.", "Just use the color variables $BLACK - $WHITE in your log formatter string.", "To set the background just use $BG-BLACK - $BG-WHITE."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import logging\n\nBLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE = range(8)\n\nCOLORS = {\n    'WARNING'  : YELLOW,\n    'INFO'     : WHITE,\n    'DEBUG'    : BLUE,\n    'CRITICAL' : YELLOW,\n    'ERROR'    : RED,\n    'RED'      : RED,\n    'GREEN'    : GREEN,\n    'YELLOW'   : YELLOW,\n    'BLUE'     : BLUE,\n    'MAGENTA'  : MAGENTA,\n    'CYAN'     : CYAN,\n    'WHITE'    : WHITE,\n}\n\nRESET_SEQ = \"\\033[0m\"\nCOLOR_SEQ = \"\\033[1;%dm\"\nBOLD_SEQ  = \"\\033[1m\"\n\nclass ColorFormatter(logging.Formatter):\n\n    def __init__(self, *args, **kwargs):\n        # can't do super(...) here because Formatter is an old school class\n        logging.Formatter.__init__(self, *args, **kwargs)\n\n    def format(self, record):\n        levelname = record.levelname\n        color     = COLOR_SEQ % (30 + COLORS[levelname])\n        message   = logging.Formatter.format(self, record)\n        message   = message.replace(\"$RESET\", RESET_SEQ)\\\n                           .replace(\"$BOLD\",  BOLD_SEQ)\\\n                           .replace(\"$COLOR\", color)\n        for k,v in COLORS.items():\n            message = message.replace(\"$\" + k,    COLOR_SEQ % (v+30))\\\n                             .replace(\"$BG\" + k,  COLOR_SEQ % (v+40))\\\n                             .replace(\"$BG-\" + k, COLOR_SEQ % (v+40))\n        return message + RESET_SEQ\n\nlogging.ColorFormatter = ColorFormatter\n</code>\n</pre>\n", "senID": 1}, {"text": ["So now you can simple do the following in your config file:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [formatter_colorFormatter]\nclass=logging.ColorFormatter\nformat= $COLOR%(levelname)s $RESET %(asctime)s $BOLD$COLOR%(name)s$RESET %(message)s\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I modified the original example provided by Sorin and subclassed StreamHandler to a ColorizedConsoleHandler."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The downside of their solution is that it modifies the message, and because that is modifying the actual logmessage any other handlers will get the modified message as well."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This resulted in logfiles with colorcodes in them in our case because we use multiple loggers."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The class below only works on platforms that support ansi, but it should be trivial to add the windows colorcodes to it."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import copy, logging\nclass ColoredConsoleHandler( logging.StreamHandler ):\ndef emit( self, record ):\n    # Need to make a actual copy of the record \n    # to prevent altering the message for other loggers\n    myrecord = copy.copy( record )\n    levelno = myrecord.levelno\n    if( levelno &gt;= 50 ): # CRITICAL / FATAL\n        color = '\\x1b[31m' # red\n    elif( levelno &gt;= 40 ): # ERROR\n        color = '\\x1b[31m' # red\n    elif( levelno &gt;= 30 ): # WARNING\n        color = '\\x1b[33m' # yellow\n    elif( levelno &gt;= 20 ): # INFO\n        color = '\\x1b[32m' # green\n    elif( levelno &gt;= 10 ): # DEBUG\n        color = '\\x1b[35m' # pink\n    else: # NOTSET and anything else\n        color = '\\x1b[0m' # normal\n    myrecord.msg = color + str( myrecord.msg ) + '\\x1b[0m'  # normal\n    logging.StreamHandler.emit( self, myrecord )\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Another minor remix of airmind's approach that keeps everything in one class:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class ColorFormatter(logging.Formatter):\n  FORMAT = (\"[$BOLD%(name)-20s$RESET][%(levelname)-18s]  \"\n            \"%(message)s \"\n            \"($BOLD%(filename)s$RESET:%(lineno)d)\")\n\n  BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE = range(8)\n\n  RESET_SEQ = \"\\033[0m\"\n  COLOR_SEQ = \"\\033[1;%dm\"\n  BOLD_SEQ = \"\\033[1m\"\n\n  COLORS = {\n    'WARNING': YELLOW,\n    'INFO': WHITE,\n    'DEBUG': BLUE,\n    'CRITICAL': YELLOW,\n    'ERROR': RED\n  }\n\n  def formatter_msg(self, msg, use_color = True):\n    if use_color:\n      msg = msg.replace(\"$RESET\", self.RESET_SEQ).replace(\"$BOLD\", self.BOLD_SEQ)\n    else:\n      msg = msg.replace(\"$RESET\", \"\").replace(\"$BOLD\", \"\")\n    return msg\n\n  def __init__(self, use_color=True):\n    msg = self.formatter_msg(self.FORMAT, use_color)\n    logging.Formatter.__init__(self, msg)\n    self.use_color = use_color\n\n  def format(self, record):\n    levelname = record.levelname\n    if self.use_color and levelname in self.COLORS:\n      fore_color = 30 + self.COLORS[levelname]\n      levelname_color = self.COLOR_SEQ % fore_color + levelname + self.RESET_SEQ\n      record.levelname = levelname_color\n    return logging.Formatter.format(self, record)\n</code>\n</pre>\n", "senID": 1}, {"text": ["To use attach the formatter to a handler, something like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n handler.setFormatter(ColorFormatter())\nlogger.addHandler(handler)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Look at the following solution.", "The stream handler should be the thing doing the colouring, then you have the option of colouring words rather than just the whole line (with the Formatter). "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://plumberjack.blogspot.com/2010/12/colorizing-logging-output-in-terminals.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://plumberjack.blogspot.com/2010/12/colorizing-logging-output-in-terminals.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://plumberjack.blogspot.com/2010/12/colorizing-logging-output-in-terminals.html"}]}], [{"text": ["The bit I had trouble with was setting up the formatter properly:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class ColouredFormatter(logging.Formatter):    \n    def __init__(self, msg):\n        logging.Formatter.__init__(self, msg)\n        self._init_colour = _get_colour()\n\n    def close(self):\n        # restore the colour information to what it was\n        _set_colour(self._init_colour)\n\n    def format(self, record):        \n        # Add your own colourer based on the other examples\n        _set_colour( LOG_LEVEL_COLOUR[record.levelno] )\n        return logging.Formatter.format(self, record)         \n\ndef init():\n    # Set up the formatter. Needs to be first thing done.\n    rootLogger = logging.getLogger()\n    hdlr = logging.StreamHandler()\n    fmt = ColouredFormatter('%(message)s')\n    hdlr.setFormatter(fmt)\n    rootLogger.addHandler(hdlr)\n</code>\n</pre>\n", "senID": 1}, {"text": ["And then to use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import coloured_log\nimport logging\n\ncoloured_log.init()\nlogging.info(\"info\")    \nlogging.debug(\"debug\")    \n\ncoloured_log.close()    # restore colours\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I believe (as David has alluded to) that you need to look into escape characters.", "There seems to be a pretty good tutorial here with an example (in C) but the concept should be the same.", "But a general google for terminal escape characters should point you in the right direction."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://linuxgazette.net/issue65/padala.html"}]}], [{"text": ["Here is my solution.", "I think that by splitting it up into modules you can get cleaner code "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://paste.ofcode.org/33VBitj9AwyGCMzEDqLkdHa"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://paste.ofcode.org/33VBitj9AwyGCMzEDqLkdHa", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://paste.ofcode.org/33VBitj9AwyGCMzEDqLkdHa"}]}]]