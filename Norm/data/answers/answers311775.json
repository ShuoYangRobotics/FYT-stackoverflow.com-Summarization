[[{"code": "<pre>\n<code>\n def doAppend( size=10000 ):\n    result = []\n    for i in range(size):\n        message= \"some unique object %d\" % ( i, )\n        result.append(message)\n    return result\n\ndef doAllocate( size=10000 ):\n    result=size*[None]\n    for i in range(size):\n        message= \"some unique object %d\" % ( i, )\n        result[i]= message\n    return result\n</code>\n</pre>\n", "senID": 0}, {"text": ["Results.", "(evaluate each function 144 times and average the duration)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Results", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n simple append 0.0102\npre-allocate  0.0098\n</code>\n</pre>\n", "senID": 2}, {"text": ["Conclusion.", "It barely matters.  "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Conclusion", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Premature optimization is the root of all evil."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Python lists have no built-in pre-allocation.", "If you really need to make a list, and need to avoid the overhead of appending (and you should verify that you do), you can do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = [None] * 1000 # Make a list of 1000 None's\nfor i in xrange(1000):\n    # baz\n    l[i] = bar\n    # qux\n</code>\n</pre>\n", "senID": 1}, {"text": ["Perhaps you could avoid the list by using a generator instead:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def my_things():\n    while foo:\n        #baz\n        yield bar\n        #qux\n\nfor thing in my_things():\n    # do something with thing\n</code>\n</pre>\n", "senID": 3}, {"text": ["This way, the list isn't every stored all in memory at all, merely generated as needed."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["i ran @s.lott's code and produced the same 10% perf increase by pre-allocating.", "tried @jeremy's idea using a generator and was able to see the perf of the gen better than that of the doAllocate.", "For my proj the 10% improvement matters, so thanks to everyone as this helps a bunch."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def doAppend( size=10000 ):\n    result = []\n    for i in range(size):\n        message= \"some unique object %d\" % ( i, )\n        result.append(message)\n    return result\n\ndef doAllocate( size=10000 ):\n    result=size*[None]\n    for i in range(size):\n        message= \"some unique object %d\" % ( i, )\n        result[i]= message\n    return result\n\ndef doGen( size=10000 ):\n    return list(\"some unique object %d\" % ( i, ) for i in xrange(size))\n\nsize=1000\n@print_timing\ndef testAppend():\n    for i in xrange(size):\n    \tdoAppend()\n\n@print_timing\ndef testAlloc():\n    for i in xrange(size):\n    \tdoAllocate()\n\n@print_timing\ndef testGen():\n    for i in xrange(size):\n    \tdoGen()\n\n\ntestAppend()\ntestAlloc()\ntestGen()\n\ntestAppend took 14440.000ms\ntestAlloc took 13580.000ms\ntestGen took 13430.000ms\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Short version: use"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n pre_allocated_list = [None] * size\n</code>\n</pre>\n", "senID": 1}, {"text": ["to pre-allocate a list (that is, to be able to address 'size' elements of the list instead of gradually forming the list by appending).", "This operation is VERY fast, even on big lists.", "Allocating new objects that will be later assigned to list elements will take MUCH longer and will be THE bottleneck in your program, performance-wise."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Long version:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I think that initialization time should be taken into account.", "Since in python everything is a reference, it doesn't matter whether you set each element into None or some string - either way it's only a reference.", "Though it will take longer if you want to create new object for each element to reference."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["For Python 3.2:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import time\nimport copy\n\ndef print_timing (func):\n  def wrapper (*arg):\n    t1 = time.time ()\n    res = func (*arg)\n    t2 = time.time ()\n    print (\"{} took {} ms\".format (func.__name__, (t2 - t1) * 1000.0))\n    return res\n\n  return wrapper\n\n@print_timing\ndef prealloc_array (size, init = None, cp = True, cpmethod=copy.deepcopy, cpargs=(), use_num = False):\n  result = [None] * size\n  if init is not None:\n    if cp:\n      for i in range (size):\n          result[i] = init\n    else:\n      if use_num:\n        for i in range (size):\n            result[i] = cpmethod (i)\n      else:\n        for i in range (size):\n            result[i] = cpmethod (cpargs)\n  return result\n\n@print_timing\ndef prealloc_array_by_appending (size):\n  result = []\n  for i in range (size):\n    result.append (None)\n  return result\n\n@print_timing\ndef prealloc_array_by_extending (size):\n  result = []\n  none_list = [None]\n  for i in range (size):\n    result.extend (none_list)\n  return result\n\ndef main ():\n  n = 1000000\n  x = prealloc_array_by_appending(n)\n  y = prealloc_array_by_extending(n)\n  a = prealloc_array(n, None)\n  b = prealloc_array(n, \"content\", True)\n  c = prealloc_array(n, \"content\", False, \"some object {}\".format, (\"blah\"), False)\n  d = prealloc_array(n, \"content\", False, \"some object {}\".format, None, True)\n  e = prealloc_array(n, \"content\", False, copy.deepcopy, \"a\", False)\n  f = prealloc_array(n, \"content\", False, copy.deepcopy, (), False)\n  g = prealloc_array(n, \"content\", False, copy.deepcopy, [], False)\n\n  print (\"x[5] = {}\".format (x[5]))\n  print (\"y[5] = {}\".format (y[5]))\n  print (\"a[5] = {}\".format (a[5]))\n  print (\"b[5] = {}\".format (b[5]))\n  print (\"c[5] = {}\".format (c[5]))\n  print (\"d[5] = {}\".format (d[5]))\n  print (\"e[5] = {}\".format (e[5]))\n  print (\"f[5] = {}\".format (f[5]))\n  print (\"g[5] = {}\".format (g[5]))\n\nif __name__ == '__main__':\n  main()\n</code>\n</pre>\n", "senID": 6}, {"text": ["Evaluation:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n prealloc_array_by_appending took 118.00003051757812 ms\nprealloc_array_by_extending took 102.99992561340332 ms\nprealloc_array took 3.000020980834961 ms\nprealloc_array took 49.00002479553223 ms\nprealloc_array took 316.9999122619629 ms\nprealloc_array took 473.00004959106445 ms\nprealloc_array took 1677.9999732971191 ms\nprealloc_array took 2729.999780654907 ms\nprealloc_array took 3001.999855041504 ms\nx[5] = None\ny[5] = None\na[5] = None\nb[5] = content\nc[5] = some object blah\nd[5] = some object 5\ne[5] = a\nf[5] = []\ng[5] = ()\n</code>\n</pre>\n", "senID": 8}, {"text": ["As you can see, just making a big list of references to the same None object takes very little time. "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Prepending or extending takes longer (i didn't average anything, but after running this a few times i can tell you that extending and appending take roughly the same time)."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Allocating new object for each element - that is what takes the most time.", "And S.Lott's answer does that - formats a new string every time.", "Which is not strictly required - if you want to pre-allocate some space, just make a list of None, then assign data to list elements at will.", "Either way it takes more time to generate data than to append/extend a list, whether you generate it while creating the list, or after that.", "But if you want a sparsely-populated list, then starting with a list of None is definitely faster."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["From what I understand, python lists are already quite similar to ArrayLists.", "But if you want to tweak those parameters I found this post on the net that may be interesting (basically, just create your own ScalableList extension):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ScalableList", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["http://mail.python.org/pipermail/python-list/2000-May/035082.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://mail.python.org/pipermail/python-list/2000-May/035082.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-list/2000-May/035082.html"}]}]]