[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; a = \"545.2222\"\n&gt;&gt;&gt; float(a)\n545.22220000000004\n&gt;&gt;&gt; int(float(a))\n545\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n float(x) if '.' in x else int(x)\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n def num (s):\n    try:\n        return int(s)\n    except exceptions.ValueError:\n        return float(s)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["codelogic and harley are correct, but keep in mind if you know the string is an integer (e.g.", "545) you can call int(\"545\") without first casting to float."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If your strings are in a list, you could use the map function as well. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = [\"545.0\", \"545.6\", \"999.2\"]\n&gt;&gt;&gt; map(float, x)\n[545.0, 545.60000000000002, 999.20000000000005]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["Only good if they're all the same type."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["float(\"545.2222\") and int(float(\"545.2222\"))"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "float(\"545.2222\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "int(float(\"545.2222\"))", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["May be you are looking out for something like this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In [78]: s=\"545.22222\"\n\nIn [79]: eval(s)\nOut[79]: 545.22221999999999\n\nIn [80]: import math\n\nIn [81]: math.ceil(eval(s))\nOut[81]: 546.0\n\nIn [82]: math.floor(eval(s))\nOut[82]: 545.0\n</code>\n</pre>\n", "senID": 1}, {"text": ["floor and ceil are more relevant in some cases then just int()."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Cheers"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n try:\n    float(x) if '.' in x else int(x)\nexcept ValueError:\n    print \"Not a numeric string.\"\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You need to take into account rounding to do this properly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I.e.", "int(5.1) => 5\n     int(5.6) => 5  -- wrong, should be 6 so we do int(5.6 + 0.5) => 6"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def convert(n):\n    try:\n        return int(n)\n    except ValueError:\n        return float(n + 0.5)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The question seems a little bit old.", "But let me suggest a function parseStr which makes sth similar, i.e.", "returns integer or float and if a given ASCII string cannot be converted to none of them it returns it untouched.", "The code of course might be adjusted to do only what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import string\n   &gt;&gt;&gt; parseStr = lambda x: x.isalpha() and x or x.isdigit() and \\\n   ...                      int(x) or x.isalnum() and x or \\\n   ...                      len(set(string.punctuation).intersection(x)) == 1 and \\\n   ...                      x.count('.') == 1 and float(x) or x\n   &gt;&gt;&gt; parseStr('123')\n   123\n   &gt;&gt;&gt; parseStr('123.3')\n   123.3\n   &gt;&gt;&gt; parseStr('3HC1')\n   '3HC1'\n   &gt;&gt;&gt; parseStr('12.e5')\n   1200000.0\n   &gt;&gt;&gt; parseStr('12$5')\n   '12$5'\n   &gt;&gt;&gt; parseStr('12.2.2')\n   '12.2.2'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's another interpretation of your question.", "(hint: it's vague) It's possible you're looking for something like this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def parseIntOrFloat( aString ):\n    return eval( aString )\n</code>\n</pre>\n", "senID": 1}, {"text": ["Works like this..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; parseIntOrFloat(\"545.2222\")\n545.22220000000004\n&gt;&gt;&gt; parseIntOrFloat(\"545\")\n545\n</code>\n</pre>\n", "senID": 3}, {"tag": "hr", "senID": 4}, {"text": ["Edit.", "Theoretically, there's an injection vulnerability.", "The string could, for example be \"import os; os.abort()\".", "Without any background on where the string comes from, however, the possibility is theoretical speculation.", "Since the question is vague, it's not at all clear if this vulnerability actually exists or not."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "\"import os; os.abort()\"", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}]]