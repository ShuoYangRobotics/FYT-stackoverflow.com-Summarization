[[{"code": "<pre>\n<code>\n import socket\nsocket.gethostbyname(socket.gethostname())\n</code>\n</pre>\n", "senID": 0}, {"text": ["This won't work always (returns 127.0.0.1 on machines having the hostname in /etc/hosts as 127.0.0.1), a paliative would be what gimel shows, use socket.getfqdn() instead.", "Of course your machine needs a resolvable hostname."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I just found this but it seems a bit hackish, however they say tried it on *nix and I did on windows and it worked."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\ns.connect((\"gmail.com\",80))\nprint s.getsockname()\n</code>\n</pre>\n", "senID": 1}, {"text": ["This assumes you have an internet access, and that there is no local proxy."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n import socket\nprint([ip for ip in socket.gethostbyname_ex(socket.gethostname())[2] if not ip.startswith(\"127.\")][0])\n</code>\n</pre>\n", "senID": 0}, {"text": ["I'm using this, because one of the computers I was on had an /etc/hosts with duplicate entries and references to itself.", "socket.gethostbyname() only returns the last entry in /etc/hosts.", "This solution weeds out the ones starting with \"127.\".", "Works with Python 3 and 2.5, possibly other versions too.", "Does not deal with several network devices or IPv6.", "Works on Linux and Windows."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You can use the netifaces module.", "Just type:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "netifaces", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/netifaces/0.4"}]}, {"code": "<pre>\n<code>\n easy_install netifaces\n</code>\n</pre>\n", "senID": 1}, {"text": ["in your command shell and it will install itself on default Python installation."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Then you can use it like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from netifaces import interfaces, ifaddresses, AF_INET\nfor ifaceName in interfaces():\n    addresses = [i['addr'] for i in ifaddresses(ifaceName).setdefault(AF_INET, [{'addr':'No IP addr'}] )]\n    print '%s: %s' % (ifaceName, ', '.join(addresses))\n</code>\n</pre>\n", "senID": 4}, {"text": ["On my computer it printed:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n{45639BDC-1050-46E0-9BE9-075C30DE1FBC}: 192.168.0.100\n{D43A468B-F3AE-4BF9-9391-4863A4500583}: 10.5.9.207\n</pre>\n", "senID": 6}, {"text": ["Author of this module claims it should work on Windows, UNIX and Mac OS X."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["If you don't want to use external packages and don't want to rely on outside Internet servers, this might help.", "It's a code sample that I found on Google Code Search and modified to return required information:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Google Code Search", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.google.com/codesearch?hl=en&lr=&q=getMACAddrWin&sbtn=Search"}]}, {"code": "<pre>\n<code>\n def getIPAddresses():\n    from ctypes import Structure, windll, sizeof\n    from ctypes import POINTER, byref\n    from ctypes import c_ulong, c_uint, c_ubyte, c_char\n    MAX_ADAPTER_DESCRIPTION_LENGTH = 128\n    MAX_ADAPTER_NAME_LENGTH = 256\n    MAX_ADAPTER_ADDRESS_LENGTH = 8\n    class IP_ADDR_STRING(Structure):\n        pass\n    LP_IP_ADDR_STRING = POINTER(IP_ADDR_STRING)\n    IP_ADDR_STRING._fields_ = [\n        (\"next\", LP_IP_ADDR_STRING),\n        (\"ipAddress\", c_char * 16),\n        (\"ipMask\", c_char * 16),\n        (\"context\", c_ulong)]\n    class IP_ADAPTER_INFO (Structure):\n        pass\n    LP_IP_ADAPTER_INFO = POINTER(IP_ADAPTER_INFO)\n    IP_ADAPTER_INFO._fields_ = [\n        (\"next\", LP_IP_ADAPTER_INFO),\n        (\"comboIndex\", c_ulong),\n        (\"adapterName\", c_char * (MAX_ADAPTER_NAME_LENGTH + 4)),\n        (\"description\", c_char * (MAX_ADAPTER_DESCRIPTION_LENGTH + 4)),\n        (\"addressLength\", c_uint),\n        (\"address\", c_ubyte * MAX_ADAPTER_ADDRESS_LENGTH),\n        (\"index\", c_ulong),\n        (\"type\", c_uint),\n        (\"dhcpEnabled\", c_uint),\n        (\"currentIpAddress\", LP_IP_ADDR_STRING),\n        (\"ipAddressList\", IP_ADDR_STRING),\n        (\"gatewayList\", IP_ADDR_STRING),\n        (\"dhcpServer\", IP_ADDR_STRING),\n        (\"haveWins\", c_uint),\n        (\"primaryWinsServer\", IP_ADDR_STRING),\n        (\"secondaryWinsServer\", IP_ADDR_STRING),\n        (\"leaseObtained\", c_ulong),\n        (\"leaseExpires\", c_ulong)]\n    GetAdaptersInfo = windll.iphlpapi.GetAdaptersInfo\n    GetAdaptersInfo.restype = c_ulong\n    GetAdaptersInfo.argtypes = [LP_IP_ADAPTER_INFO, POINTER(c_ulong)]\n    adapterList = (IP_ADAPTER_INFO * 10)()\n    buflen = c_ulong(sizeof(adapterList))\n    rc = GetAdaptersInfo(byref(adapterList[0]), byref(buflen))\n    if rc == 0:\n        for a in adapterList:\n            adNode = a.ipAddressList\n            while True:\n                ipAddr = adNode.ipAddress\n                if ipAddr:\n                    yield ipAddr\n                adNode = adNode.next\n                if not adNode:\n                    break\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for addr in getIPAddresses():\n&gt;&gt;&gt;    print addr\n192.168.0.100\n10.5.9.207\n</code>\n</pre>\n", "senID": 3}, {"text": ["As it relies on windll, this will work only on Windows."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "windll", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I'm afraid there aren't any good platform independent ways to do this other than connecting to another computer and having it send you your IP address.", "For example:  findmyipaddress.", "Note that this won't work if you need an IP address that's behind NAT unless the computer you're connecting to is behind NAT as well."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "findmyipaddress", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.findmyipaddress.info/locateipaddresses.html"}]}, {"text": ["Here's one solution that works in Linux:  get the IP address associated with a network interface."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "get the IP address associated with a network interface", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/439094/"}]}], [{"text": ["I use this on my ubuntu machines:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import commands\ncommands.getoutput(\"ifconfig\").split(\"\\n\")[1].split()[1][5:]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["im using following module:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n\n# module for getting the lan ip address of the computer\n\nimport os\n\nimport socket\n\nif os.name != \"nt\":\n\n    import fcntl\n\n    import struct\n\n    def get_interface_ip(ifname):\n\n    \ts = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n    \treturn socket.inet_ntoa(fcntl.ioctl(\n\n    \t\t\ts.fileno(),\n\n    \t\t\t0x8915,  # SIOCGIFADDR\n\n    \t\t\tstruct.pack('256s', ifname[:15])\n\n    \t\t)[20:24])\n\n\n\ndef get_lan_ip():\n\n    ip = socket.gethostbyname(socket.gethostname())\n\n    if ip.startswith(\"127.\") and os.name != \"nt\":\n\n    \tinterfaces = [\"eth0\",\"eth1\",\"eth2\",\"wlan0\",\"wlan1\",\"wifi0\",\"ath0\",\"ath1\",\"ppp0\"]\n\n    \tfor ifname in interfaces:\n\n    \t\ttry:\n\n    \t\t\tip = get_interface_ip(ifname)\n\n    \t\t\tbreak;\n\n    \t\texcept IOError:\n\n    \t\t\tpass\n\n    return ip\n</code>\n</pre>\n", "senID": 1}, {"text": ["Tested with windows and linux (and doesnt require additional modules for those)\nintended for use on systems which are in a single LAN."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["FYI I can verify that the method:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import socket\naddr = socket.gethostbyname(socket.gethostname())\n</code>\n</pre>\n", "senID": 1}, {"text": ["Works in OS X (10.6,10.5), Windows XP, and on a well administered RHEL department server.", "It did not work on a very minimal CentOS VM that I just do some kernel hacking on.", "So for that instance you can just check for a 127.0.0.1 address and in that case do the following:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if addr == \"127.0.0.1\":\n     import commands\n     output = commands.getoutput(\"/sbin/ifconfig\")\n     addr = parseaddress(output)\n</code>\n</pre>\n", "senID": 3}, {"text": ["And then parse the ip address from the output.", "It should be noted that ifconfig is not in a normal user's PATH by default and that is why I give the full path in the command.", "I hope this helps."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["one simple way to produce \"clean\" output via command line utils"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["import commands"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["ips = commands.getoutput(\"/sbin/ifconfig | grep -i \\\"inet\\\" | grep -iv \\\"inet6\\\" | awk {'print $2'} | sed -ne 's/adr\\:/ /p'\")\nprint ips"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["it will show all ipv4 address on system ;)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["For a list of IP addresses on *nix systems,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import subprocess\nco = subprocess.Popen(['ifconfig'], stdout = subprocess.PIPE)\nifconfig = co.stdout.read()\nip_regex = re.compile('((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-4]|2[0-5][0-9]|[01]?[0-9][0-9]?))')\n[match[0] for match in ip_regex.findall(ifconfig, re.MULTILINE)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Though it's a bit late for this answer, I thought someone else may find it useful :-)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["PS : It'll return Broadcast addresses and Netmask as well."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]