[[{"text": ["Example of optimization issue, which a commenter says \"he's never seen\":"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ python -mtimeit '[\"fee\", \"fie\", \"fo\", \"fum\"]'\n1000000 loops, best of 3: 0.432 usec per loop\n$ python -mtimeit '(\"fee\", \"fie\", \"fo\", \"fum\")'\n10000000 loops, best of 3: 0.0563 usec per loop\n</code>\n</pre>\n", "senID": 1}, {"text": ["Speeding an operation up by seven-eight times not \"substantial enough\" for you?!", "Wow, you're definitely a very demanding person when it comes to deeming an optimization \"substantial\"...!-)"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "seven-eight times", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "very", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}], [{"text": ["None of the answers above point out the real issue of tuples vs lists, which many new to Python seem to not fully understand."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Tuples and lists serve different purposes.", "Lists store homogenous data.", "You can and should have a list like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n [\"Bob\", \"Joe\", \"John\", \"Sam\"]\n</code>\n</pre>\n", "senID": 2}, {"text": ["The reason that is a correct use of lists is because those are all homogenous types of data, specifically, people's names.", "But take a list like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n [\"Billy\", \"Bob\", \"Joe\", 42]\n</code>\n</pre>\n", "senID": 4}, {"text": ["That list is one person's full name, and their age.", "That isn't one type of data.", "The correct way to store that information is either in a tuple, or in an object.", "Lets say we have a few :"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n [(\"Billy\", \"Bob\", \"Joe\", 42), (\"Robert\", \"\", \"Smith\", 31)]\n</code>\n</pre>\n", "senID": 6}, {"text": ["The immutability and mutability of Tuples and Lists is not the main difference.", "A list is a list of the same kind of items: files, names, objects.", "Tuples are a grouping of different types of objects.", "They have different uses, and many Python coders abuse lists for what tuples are meant for."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Please don't."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Edit:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["I think this blog post explains why I think this better than I did: http://news.e-scribe.com/397"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "http://news.e-scribe.com/397", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://news.e-scribe.com/397"}]}], [{"text": ["Sometimes we like to use objects as dictionary keys"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For what it's worth, tuples recently (2.6+) grew index() and count() methods"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "index()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "count()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["In this particular case, there probably isn't a point.", "This is a non-issue, because this isn't one of the cases where you'd consider using a tuple."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As you point out, tuples are immutable.", "The reasons for having immutable types apply to tuples:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "copy efficiency: rather than copying an immutable object, you can alias it (bind a variable to a reference)", "tag": "none", "senID": 2}, {"text": "comparison efficiency: when you're using copy-by-reference, you can compare two variables by comparing location, rather than content", "tag": "none", "senID": 3}, {"text": "interning: you need to store at most one copy of any immutable value", "tag": "none", "senID": 4}, {"text": "there's no need to synchronize access to immutable objects in concurrent code", "tag": "none", "senID": 5}, {"text": "const correctness: some values shouldn't be allowed to change. This (to me) is the main reason for immutable types.", "tag": "none", "senID": 6}]}, {"text": ["Note that a particular Python implementation may not make use of all of the above features."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Dictionary keys must be immutable, otherwise changing the properties of a key-object can invalidate invariants of the underlying data structure.", "Tuples can thus potentially be used as keys.", "This is a consequence of const correctness."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["See also \"Introducing tuples\", from Dive Into Python."], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "Introducing tuples", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://diveintopython.org/getting_to_know_python/tuples.html"}, {"href": "http://diveintopython.org/toc/index.html", "text": "Dive Into Python", "childNum": 1, "tag": "a", "childList": [{"text": "Dive Into Python", "tag": "em"}]}, {"text": "Dive Into Python", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["I've always found having two completely separate types for the same basic data structure (arrays) to be an awkward design, but not a real problem in practice.", "(Every language has its warts, Python included, but this isn't an important one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["These are different things.", "Mutability isn't related to the place it's stored in memory; it means the stuff it points to can't change."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "stuff it points to", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Python objects can't change location after they're created, mutable or not.", "(More accurately, the value of id() can't change--same thing, in practice.", ")  The internal storage of mutable objects can change, but that's a hidden implementation detail."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x='hello'\n&gt;&gt;&gt; id(x)\n1234567\n&gt;&gt;&gt; x='good bye'\n&gt;&gt;&gt; id(x)\n5432167\n</code>\n</pre>\n", "senID": 3}, {"text": ["This isn't modifying (\"mutating\") the variable; it's creating a new variable with the same name, and discarding the old one.", "Compare to a mutating operation:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [1,2,3]\n&gt;&gt;&gt; id(a)\n3084599212L\n&gt;&gt;&gt; a[1] = 5\n&gt;&gt;&gt; a\n[1, 5, 3]\n&gt;&gt;&gt; id(a)\n3084599212L\n</code>\n</pre>\n", "senID": 5}, {"text": ["As others have pointed out, this allows using arrays as keys to dictionaries, and other data structures that need immutability."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Note that keys for dictionaries do not have to be completely immutable.", "Only the part of it used as a key needs to be immutable; for some uses, this is an important distinction.", "For example, you could have a class representing a user, which compares equality and a hash by the unique username.", "You could then hang other mutable data on the class--\"user is logged in\", etc.", "Since this doesn't affect equality or the hash, it's possible and perfectly valid to use this as a key in a dictionary.", "This isn't too commonly needed in Python; I just point it out since several people have claimed that keys need to be \"immutable\", which is only partially correct.", "I've used this many times with C++ maps and sets, though."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["As gnibbler offered in a comment, Guido had an opinion that is not fully accepted/appreciated: \u201clists are for homogeneous data, tuples are for heterogeneous data\u201d.", "Of course, many of the opposers interpreted this as meaning that all elements of a list should be of the same type."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "opinion", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://aspn.activestate.com/ASPN/Mail/Message/python-list/1566320"}]}, {"text": ["I like to see it differently, not unlike others also have in the past:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "others", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://jtauber.com/blog/2006/04/15/python_tuples_are_not_just_constant_lists/"}]}, {"code": "<pre>\n<code>\n blue= 0, 0, 255\nalist= [\"red\", \"green\", blue]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Note that I consider alist to be homogeneous, even if type(alist[1]) != type(alist[2])."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If I can change the order of the elements and I won't have issues in my code (apart from assumptions, e.g.", "\u201cit should be sorted\u201d), then a list should be used.", "If not (like in the tuple blue above), then I should use a tuple."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "blue", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["They are important since they guarantee the caller that the object they pass won't be mutated.", "If you do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = [1,1,1]\ndoWork(a)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The caller has no guarantee of the value of a after the call.", "However, "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "a", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a = (1,1,1)\ndoWorK(a)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now you as the caller or as a reader of this code know that a is the same.", "You could always for this scenario make a copy of the list and pass that but now you are wasting cycles instead of using a language construct that makes more semantic sense."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "a", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["you can see here for some discussion on this"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://groups.google.com.sg/group/comp.lang.python/browse_thread/thread/ae048e3a99f1d04b/f43385cdccd633df?hl=en&lnk=gst&q=why+tuples#f43385cdccd633df"}]}], [{"text": ["Your question (and follow-up comments) focus on whether the id() changes during an assignment.", "Focusing on this follow-on effect of the difference between immutable object replacement and mutable object modification rather than the difference itself is perhaps not the best approach."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Before we continue, make sure that the behavior demonstrated below is what you expect from Python."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a1 = [1]\n&gt;&gt;&gt; a2 = a1\n&gt;&gt;&gt; print a2[0]\n1\n&gt;&gt;&gt; a1[0] = 2\n&gt;&gt;&gt; print a2[0]\n2\n</code>\n</pre>\n", "senID": 2}, {"text": ["In this case, the contents of a2 was changed, even though only a1 had a new value assigned.", "Contrast to the following:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a1 = [1]\n&gt;&gt;&gt; a2 = a1\n&gt;&gt;&gt; print a2[0]\n1\n&gt;&gt;&gt; a1 = [2]\n&gt;&gt;&gt; print a2[0]\n1\n</code>\n</pre>\n", "senID": 4}, {"text": ["In this latter case, we replaced the entire list, rather than updating its contents.", "With immutable types such as tuples, this is the only behavior allowed."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "With immutable types such as tuples, this is the only behavior allowed.", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Why does this matter?", "Let's say you have a dict:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; t1 = (1,2)\n&gt;&gt;&gt; d1 = { t1 : 'three' }\n&gt;&gt;&gt; print d1\n{(1,2): 'three'}\n&gt;&gt;&gt; t1[0] = 0  ## results in a TypeError, as tuples cannot be modified\n&gt;&gt;&gt; t1 = (2,3) ## creates a new tuple, does not modify the old one\n&gt;&gt;&gt; print d1   ## as seen here, the dict is still intact\n{(1,2): 'three'}\n</code>\n</pre>\n", "senID": 7}, {"text": ["Using a tuple, the dictionary is safe from having its keys changed \"out from under it\" to items which hash to a different value.", "This is critical to allow efficient implementation."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}]]