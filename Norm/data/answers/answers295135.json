[[{"text": ["This whitelist approach (ie, allowing only the chars present in valid_chars) will work if there aren't limits on the formatting of the files or combination of valid chars that are illegal (like \"..\"), for example, what you say would allow a filename named \" .", "txt\" which I think is not valid on Windows.", "As this is the most simple approach I'd try to remove whitespace from the valid_chars and prepend a known valid string in case of error, any other approach will have to know about what is allowed where to cope with Windows file naming limitations and thus be a lot more complex. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Windows file naming limitations", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/62771/how-check-if-given-string-is-legal-allowed-file-name-under-windows"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import string\n&gt;&gt;&gt; valid_chars = \"-_.() %s%s\" % (string.ascii_letters, string.digits)\n&gt;&gt;&gt; valid_chars\n'-_.() abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\n&gt;&gt;&gt; filename = \"This Is a (valid) - filename%$&amp;$ .txt\"\n&gt;&gt;&gt; ''.join(c for c in filename if c in valid_chars)\n'This Is a (valid) - filename .txt'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can look at the Django framework for how they create a \"slug\" from arbitrary text.", "A slug is URL- and filename- friendly."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Django framework", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.djangoproject.com"}]}, {"text": ["Their template/defaultfilters.py (at around line 183) defines a function, slugify, that's probably the gold standard for this kind of thing.", "Essentially, their code is the following."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "template/defaultfilters.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "slugify", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def slugify(value):\n    \"\"\"\n    Normalizes string, converts to lowercase, removes non-alpha characters,\n    and converts spaces to hyphens.\n    \"\"\"\n    import unicodedata\n    value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore')\n    value = unicode(re.sub('[^\\w\\s-]', '', value).strip().lower())\n    ... re.sub('[-\\s]+', '-', value)\n</code>\n</pre>\n", "senID": 2}, {"text": ["There's more, but I left it out, since it doesn't address slugification, but escaping."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["What is the reason to use the strings as file names?", "If human readability is not a factor I would go with base64 module which can produce file system safe strings.", "It won't be readable but you won't have to deal with collisions and it is reversible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import base64\nfile_name_string = base64.urlsafe_b64encode(your_string)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Update: Changed based on Matthew comment."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Just to further complicate things, you are not guaranteed to get a valid filename just by removing invalid characters.", "Since allowed characters differ on different filenames, a conservative approach could end up turning a valid name into an invalid one.", "You may want to add special handling for the cases where:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["The string is all invalid characters (leaving you with an empty string)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You end up with a string with a special meaning, eg \".", "\" or \"..\""], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["On windows, certain device names are reserved.", "For instance, you can't create a file named \"nul\", \"nul.txt\" (or nul.anything in fact)  The reserved names are:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "certain device names", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://msdn.microsoft.com/en-us/library/aa365247.aspx"}]}]}, {"text": ["You can probably work around these issues by prepending some string to the filenames that can never result in one of these cases, and stripping invalid characters."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You can use list comprehension together with the string methods."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s\n'foo-bar#baz?qux@127/\\\\9]'\n&gt;&gt;&gt; \"\".join([x for x in s if x.isalpha() or x.isdigit()])\n'foobarbazqux1279'\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import string\n&gt;&gt;&gt; safechars = '_-.()' + string.digits + string.ascii_letters\n&gt;&gt;&gt; allchars = string.maketrans('', '')\n&gt;&gt;&gt; deletions = ''.join(set(allchars) - set(safechars))\n&gt;&gt;&gt; filename = '#abc.$%.txt'\n&gt;&gt;&gt; safe_filename = string.translate(filename, allchars, deletions)\n&gt;&gt;&gt; safe_filename\n'abc..txt'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}, {"text": ["The above code doesn't work for unicode strings.", "It doesn't handle empty strings, special filenames ('nul', 'con', etc) also."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This is the solution I ultimately used:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import unicodedata\n\nvalidFilenameChars = \"-_.() %s%s\" % (string.ascii_letters, string.digits)\n\ndef removeDisallowedFilenameChars(filename):\n    cleanedFilename = unicodedata.normalize('NFKD', filename).encode('ASCII', 'ignore')\n    return ''.join(c for c in cleanedFilename if c in validFilenameChars)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The unicodedata.normalize call replaces accented characters with the unaccented equivalent, which is better than simply stripping them out.", "After that all disallowed characters are removed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["My solution doesn't prepend a known string to avoid possible disallowed filenames, because I know they can't occur given my particular filename format.", "A more general solution would need to do so."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Keep in mind, there are actually no restrictions on filenames on Unix systems other than "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "It may not contain \\0 ", "tag": "none", "senID": 1}, {"text": "It may not contain  /", "tag": "none", "senID": 2}]}, {"text": ["Everything else is fair game. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n$ touch \"\n> even multiline\n> haha\n> ^[[31m red ^[[0m\n> evil\"\n$ ls -la \n-rw-r--r--       0 Nov 17 23:39 ?even multiline?haha??[31m red ?[0m?evil\n$ ls -lab\n-rw-r--r--       0 Nov 17 23:39 \\neven\\ multiline\\nhaha\\n\\033[31m\\ red\\ \\033[0m\\nevil\n$ perl -e 'for my $i ( glob(q{./*even*}) ){ print $i; } '\n./\neven multiline\nhaha\n red \nevil\n</pre>\n", "senID": 4}, {"text": ["Yes, i just stored ANSI Colour Codes in a file name and had them take effect. "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["For entertainment, put a BEL character in a directory name and watch the fun that ensues when you CD into it ;) "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Why not just wrap the \"osopen\" with a try/except and let the underlying OS sort out whther the file is valid?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Much less work and valid no matter which OS you use."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Another issue that the other comments haven't addressed yet is the empty string, which is obviously not a valid filename.", "You can also end up with an empty string from stripping too many characters."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What with the Windows reserved filenames and issues with dots, the safest answer to the question \u201chow do I normalise a valid filename from arbitrary user input?\u201d is \u201cdon't even bother try\u201d: if you can find any other way to avoid it (eg.", "using integer primary keys from a database as filenames), do that."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you must, and you really need to allow spaces and \u2018.\u2019 for file extensions as part of the name, try something like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import re\nbadchars= re.compile(r'[^A-Za-z0-9_. ]+|^\\.|\\.$|^ | $|^$')\nbadnames= re.compile(r'(aux|com[1-9]|con|lpt[1-9]|prn)(\\.|$)')\n\ndef makeName(s):\n    name= badchars.sub('_', s)\n    if badnames.match(name):\n        name= '_'+name\n    return name\n</code>\n</pre>\n", "senID": 3}, {"text": ["Even this can't be guaranteed right especially on unexpected OSs\u2009\u2014\u2009for example RISC OS hates spaces and uses \u2018.\u2019 as a directory separator."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You could use the re.sub() method to replace anything not \"filelike\".", "But in effect, every character could be valid; so there are no prebuilt functions (I believe), to get it done."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nstr = \"File!name?.txt\"\nf = open(os.path.join(\"/tmp\", re.sub('[^a-zA-Z0-9_-.() ]+', '', str))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Would result in a filehandle to /tmp/filename.txt."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Though you have to be careful.", "It is not clearly said in your intro, if you are looking only at latine language.", "Some words can become meaningless or another meaning if you sanitize them with ascii characters only."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["imagine you have \"for\u00eat po\u00e9sie\" (forest poetry), your sanitization might give \"fort-posie\" (strong + something meaningless)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Worse if  you have to deal with chinese characters."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["\"\u4e0b\u5317\u6ca2\" your system might end up doing \"---\" which is doomed to fail after a while and not very helpful.", "So if you deal with only files I would encourage to either call them a generic chain that you control or to keep the characters as it is.", "For URIs, about the same."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Shouldn't this be built into the os.path module?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The bobcat project contains a python module that does just this."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "bobcat", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["It's not completely robust, see this post and this reply."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "post", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-list/2007-September/628023.html"}, {"href": "http://mail.python.org/pipermail/python-list/2007-September/628042.html", "text": "reply", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["So, as noted: base64 encoding is probably a better idea if readability doesn't matter."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "base64", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "Docs ", "tag": "none", "senID": 3}, {"text": "Source ", "tag": "none", "senID": 4}]}], [{"text": ["Maybe the most elegant way would be to use a regex ?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]