[[{"text": ["It's pretty simple really:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a[start:end] # items start through end-1\na[start:]    # items start through the rest of the array\na[:end]      # items from the beginning through end-1\na[:]         # a copy of the whole array\n</code>\n</pre>\n", "senID": 1}, {"text": ["There is also the step value, which can be used with any of the above:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "step", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a[start:end:step] # start through not past end, by step\n</code>\n</pre>\n", "senID": 3}, {"text": ["The key point to remember is that the :end value represents the first value that is not in the selected slice.", "So, the difference beween end and start is the number of elements selected (if step is 1, the default)."], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": ":end", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "end", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "start", "childNum": 0, "tag": "code", "childList": []}, {"text": "step", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The other feature is that start or end may be a negative number, which means it counts from the end of the array instead of the beginning.", "So:"], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "start", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "end", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "negative", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n a[-1]    # last item in the array\na[-2:]   # last two items in the array\na[:-2]   # everything except the last two items\n</code>\n</pre>\n", "senID": 6}, {"text": ["Python is kind to the programmer if there are fewer items than you ask for.", "For example, if you ask for a[:-2] and a only contains one element, you get an empty list instead of an error.", "Sometimes you would prefer the error, so you have to be aware that this may happen."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "a[:-2]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["The tutorial talks about it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://docs.python.org/tutorial/introduction.html#strings"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/tutorial/introduction.html#strings", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/introduction.html#strings"}]}, {"text": ["(Scroll down a bit until you get to the part about slicing.", ")  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The ASCII art diagram is helpful too for remembering how slices work:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n +---+---+---+---+---+\n | H | e | l | p | A |\n +---+---+---+---+---+\n 0   1   2   3   4   5\n-5  -4  -3  -2  -1\n</code>\n</pre>\n", "senID": 4}], [{"text": ["And a couple of things that weren't immediately obvious to me when I first saw the slicing syntax:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = [1,2,3,4,5,6]\n&gt;&gt;&gt; x[::-1]\n[6,5,4,3,2,1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Easy way to reverse sequences!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["And if you wanted, for some reason, every second item in the reversed sequence:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = [1,2,3,4,5,6]\n&gt;&gt;&gt; x[::-2]\n[6,4,2]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Enumerating the possibilities allowed by the grammar:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; seq[:]                # [seq[0],   seq[1],          ..., seq[-1]    ]\n&gt;&gt;&gt; seq[low:]             # [seq[low], seq[low+1],      ..., seq[-1]    ]\n&gt;&gt;&gt; seq[:high]            # [seq[0],   seq[1],          ..., seq[high-1]]\n&gt;&gt;&gt; seq[low:high]         # [seq[low], seq[low+1],      ..., seq[high-1]]\n&gt;&gt;&gt; seq[::stride]         # [seq[0],   seq[stride],     ..., seq[-1]    ]\n&gt;&gt;&gt; seq[low::stride]      # [seq[low], seq[low+stride], ..., seq[-1]    ]\n&gt;&gt;&gt; seq[:high:stride]     # [seq[0],   seq[stride],     ..., seq[high-1]]\n&gt;&gt;&gt; seq[low:high:stride]  # [seq[low], seq[low+stride], ..., seq[high-1]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course, if (high-low)%stride != 0, then the end point will be a little lower than high-1."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "(high-low)%stride != 0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "high-1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Extended slicing (with commas and ellipses) are mostly used only by special data structures (like Numpy); the basic sequences don't support them."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class slicee:\n...     def __getitem__(self, item):\n...         return `item`\n...\n&gt;&gt;&gt; slicee()[0, 1:2, ::5, ...]\n'(0, slice(1, 2, None), slice(None, None, 10), Ellipsis)'\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The answers above don't discuss slice assignment:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; r=[1,2,3,4]\n&gt;&gt;&gt; r[1:1]\n[]\n&gt;&gt;&gt; r[1:1]=[9,8]\n&gt;&gt;&gt; r\n[1, 9, 8, 2, 3, 4]\n&gt;&gt;&gt; r[1:1]=['blah']\n&gt;&gt;&gt; r\n[1, 'blah', 9, 8, 2, 3, 4]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This may also clarify the difference between slicing and indexing."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["After using it a bit I realise that the simplest description is that it is exactly the same as the arguments in a for loop..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (from:to:step)\n</code>\n</pre>\n", "senID": 1}, {"text": ["any of them are optional"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n (:to:step)\n(from::step)\n(from:to)\n</code>\n</pre>\n", "senID": 3}, {"text": ["then the negative indexing just needs you to add the length of the string to the negative indices to understand it."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["This works for me anyway..."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Do you mean http://www.python.org/doc/2.5.2/ref/slicings.html#tok-slicing ?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.python.org/doc/2.5.2/ref/slicings.html#tok-slicing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/ref/slicings.html#tok-slicing"}]}, {"text": ["Or http://docs.python.org/reference/expressions.html#grammar-token-slicing ?"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/reference/expressions.html#grammar-token-slicing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/expressions.html#grammar-token-slicing"}]}, {"text": ["Or http://docs.python.org/3.0/library/functions.html#slice"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://docs.python.org/3.0/library/functions.html#slice", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/3.0/library/functions.html#slice"}]}, {"text": ["Or something else?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I use the \"an index points between elements\" method of thinking about it myself, but one way of describing it which sometimes helps others get it is this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n mylist[X:Y]\n</code>\n</pre>\n", "senID": 1}, {"text": ["X is the index of the first element you want.", "Y is the index of the first element you don't want."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "don't", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["Found this great table at http://wiki.python.org/moin/MovingToPythonFromOtherLanguages"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://wiki.python.org/moin/MovingToPythonFromOtherLanguages", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/MovingToPythonFromOtherLanguages"}]}, {"code": "<pre>\n<code>\n Python indexes and slices for a six-element list.\nIndexes enumerate the elements, slices enumerate the spaces between the elements.\n\nIndex from rear:    -6  -5  -4  -3  -2  -1      a=[0,1,2,3,4,5]    a[1:]==[1,2,3,4,5]\nIndex from front:    0   1   2   3   4   5      len(a)==6          a[:5]==[0,1,2,3,4]\n                   +---+---+---+---+---+---+    a[0]==0            a[:-2]==[0,1,2,3]\n                   | a | b | c | d | e | f |    a[5]==5            a[1:2]==[1]\n                   +---+---+---+---+---+---+    a[-1]==5           a[1:-1]==[1,2,3,4]\nSlice from front:  :   1   2   3   4   5   :    a[-2]==4\nSlice from rear:   :  -5  -4  -3  -2  -1   :\n                                                b=a[:]\n                                                b==[0,1,2,3,4,5] (shallow copy of a)\n</code>\n</pre>\n", "senID": 1}]]