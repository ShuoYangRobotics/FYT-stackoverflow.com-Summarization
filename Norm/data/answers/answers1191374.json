[[{"text": ["If you're on Unix,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import signal\n  ...\nclass Alarm(Exception):\n    pass\n\ndef alarm_handler(signum, frame):\n    raise Alarm\n\nsignal.signal(signal.SIGALRM, alarm_handler)\nsignal.alarm(5*60)  # 5 minutes\ntry:\n    stdoutdata, stderrdata = proc.communicate()\n    signal.alarm(0)  # reset the alarm\nexcept Alarm:\n    print \"Oops, taking too long!\"\n    # whatever else\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is Alex Martelli's solution as a module with proper process killing.", "The other approaches do not work because they do not use proc.communicate().", "So if you have a process that produces lots of output, it will fill its output buffer and then block until you read something from it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from os import kill\nfrom signal import alarm, signal, SIGALRM, SIGKILL\nfrom subprocess import PIPE, Popen\n\ndef run(args, cwd = None, shell = False, kill_tree = True, timeout = -1, env = None):\n    '''\n    Run a command with a timeout after which it will be forcibly\n    killed.\n    '''\n    class Alarm(Exception):\n        pass\n    def alarm_handler(signum, frame):\n        raise Alarm\n    p = Popen(args, shell = shell, cwd = cwd, stdout = PIPE, stderr = PIPE, env = env)\n    if timeout != -1:\n        signal(SIGALRM, alarm_handler)\n        alarm(timeout)\n    try:\n        stdout, stderr = p.communicate()\n        if timeout != -1:\n            alarm(0)\n    except Alarm:\n        pids = [p.pid]\n        if kill_tree:\n            pids.extend(get_process_children(p.pid))\n        for pid in pids:\n            # process might have died before getting to this line\n            # so wrap to avoid OSError: no such process\n            try: \n                kill(pid, SIGKILL)\n            except OSError:\n                pass\n        return -9, '', ''\n    return p.returncode, stdout, stderr\n\ndef get_process_children(pid):\n    p = Popen('ps --no-headers -o pid --ppid %d' % pid, shell = True,\n              stdout = PIPE, stderr = PIPE)\n    stdout, stderr = p.communicate()\n    return [int(p) for p in stdout.split()]\n\nif __name__ == '__main__':\n    print run('find /', shell = True, timeout = 3)\n    print run('find', shell = True)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I don't know much about the low level details; but, given that in\npython 2.6 the API offers the ability to wait for threads and\nterminate processes, what about running the process in a separate\nthread?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import subprocess, threading\n\nclass Command(object):\n    def __init__(self, cmd):\n        self.cmd = cmd\n        self.process = None\n\n    def run(self, timeout):\n        def target():\n            print 'Thread started'\n            self.process = subprocess.Popen(self.cmd, shell=True)\n            self.process.communicate()\n            print 'Thread finished'\n\n        thread = threading.Thread(target=target)\n        thread.start()\n\n        thread.join(timeout)\n        if thread.is_alive():\n            print 'Terminating process'\n            self.process.terminate()\n            thread.join()\n        print self.process.returncode\n\ncommand = Command(\"echo 'Process started'; sleep 2; echo 'Process finished'\")\ncommand.run(timeout=3)\ncommand.run(timeout=1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The output of this snippet in my machine is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Thread started\nProcess started\nProcess finished\nThread finished\n0\nThread started\nProcess started\nTerminating process\nThread finished\n-15\n</code>\n</pre>\n", "senID": 3}, {"text": ["where it can be seen that, in the first execution, the process\nfinished correctly (return code 0), while the in the second one the\nprocess was terminated (return code -15)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I haven't tested in windows; but, aside from updating the example\ncommand, I think it should work since I haven't found in the\ndocumentation anything that says that thread.join or process.terminate\nis not supported."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["This is the best I could come up with (extracted from my private program):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # poll for terminated status till timeout is reached\n        t_beginning = time.time()\n        seconds_passed = 0\n        while True:\n            if p.poll() is not None:\n                break\n            seconds_passed = time.time() - t_beginning\n            if timeout and seconds_passed &gt; timeout:\n                p.terminate()\n                raise TimeoutError(cmd, timeout)\n            time.sleep(0.1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(inspired by some other SO comment elsewhere)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Another option is to write to a temporary file to prevent the stdout blocking instead of needing to poll with communicate().", "This worked for me where the other answers did not; for example on windows."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n outFile =  tempfile.SpooledTemporaryFile() \n    errFile =   tempfile.SpooledTemporaryFile() \n    proc = subprocess.Popen(args, stderr=errFile, stdout=outFile, universal_newlines=False)\n    wait_remaining_sec = timeout\n\n    while proc.poll() is None and wait_remaining_sec &gt; 0:\n        time.sleep(1)\n        wait_remaining_sec -= 1\n\n    if wait_remaining_sec &lt;= 0:\n        killProc(proc.pid)\n        raise ProcessIncompleteError(proc, timeout)\n\n    # read temp streams from start\n    outFile.seek(0);\n    errFile.seek(0);\n    out = outFile.read()\n    err = errFile.read()\n    outFile.close()\n    errFile.close()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I've used killableprocess successfully on Windows, Linux and Mac.", "If you are using Cygwin Python, you'll need OSAF's version of killableprocess because otherwise native Windows processes won't get killed."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "killableprocess", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://benjamin.smedbergs.us/blog/2006-12-11/killableprocesspy/"}, {"text": "OSAF's version of killableprocess", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://svn.osafoundation.org/chandler/trunk/chandler/tools/killableprocess.py"}]}], [{"text": ["I've implemented what I could gather from a few of these.", "This works in Windows, and since this is a community wiki, I figure I would share my code as well:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Command(threading.Thread):\n    def __init__(self, cmd, outFile, errFile, timeout):\n        threading.Thread.__init__(self)\n        self.cmd = cmd\n        self.process = None\n        self.outFile = outFile\n        self.errFile = errFile\n        self.timed_out = False\n        self.timeout = timeout\n\n    def run(self):\n        self.process = subprocess.Popen(self.cmd, stdout = self.outFile, \\\n            stderr = self.errFile)\n\n        while (self.process.poll() is None and self.timeout &gt; 0):\n            time.sleep(1)\n            self.timeout -= 1\n\n        if not self.timeout &gt; 0:\n            self.process.terminate()\n            self.timed_out = True\n        else:\n            self.timed_out = False\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then from another class or file:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n outFile =  tempfile.SpooledTemporaryFile()\n        errFile =   tempfile.SpooledTemporaryFile()\n\n        executor = command.Command(c, outFile, errFile, timeout)\n        executor.daemon = True\n        executor.start()\n\n        executor.join()\n        if executor.timed_out:\n            out = 'timed out'\n        else:\n            outFile.seek(0)\n            errFile.seek(0)\n            out = outFile.read()\n            err = errFile.read()\n\n        outFile.close()\n        errFile.close()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Although I haven't looked at it extensively, this decorator I found at ActiveState seems to be quite useful for this sort of thing.", "Along with subprocess.Popen(..., close_fds=True), at least I'm ready for shell-scripting in Python."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "decorator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/307871-timing-out-function/"}, {"text": "subprocess.Popen(..., close_fds=True)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I added the solution with threading from jcollado to my project."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Install:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n easy_install easyprocess\n</code>\n</pre>\n", "senID": 2}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from easyprocess import Proc\n\n# shell is not supported!\nstdout=Proc('ping localhost').call(timeout=1.5).stdout\nprint stdout\n</code>\n</pre>\n", "senID": 4}]]