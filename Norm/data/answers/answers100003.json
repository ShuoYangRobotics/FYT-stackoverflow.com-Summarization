[[{"text": ["Now that I know better, and due to demands in the answers on the yield keyword and the decorators, I'm going to answer this question with a lot of detail. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "yield keyword", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/231767/the-python-yield-keyword-explained"}, {"href": "http://stackoverflow.com/questions/739654/understanding-python-decorators", "text": "decorators", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Disclaimer: very long post."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Disclaimer: very long post.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Before understanding metaclasses, you need to master classes in Python.", "And Python has a very peculiar idea of what classes are, borrowed from the Smalltalk language."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In most languages, classes are just pieces of code that describe how to produce an object.", "That's kinda true in Python too:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class ObjectCreator(object):\n  ...       pass\n  ... \n\n  &gt;&gt;&gt; my_object = ObjectCreator()\n  &gt;&gt;&gt; print my_object\n  &lt;__main__.ObjectCreator object at 0x8974f2c&gt;\n</code>\n</pre>\n", "senID": 4}, {"text": ["But classes are more than that in Python.", "Classes are objects too."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Yes, objects. "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["As soon as you use the keyword class, Python executes it and creates\nan OBJECT.", "The instruction"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "class", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class ObjectCreator(object):\n  ...       pass\n  ...\n</code>\n</pre>\n", "senID": 8}, {"text": ["creates in memory an object with the name ObjectCreator. "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["This object (the class) is itself capable of creating objects (the instances), \nand this is why it's a class. "], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "This object (the class) is itself capable of creating objects (the instances), \nand this is why it's a class", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["But still, it's an object, and therefore:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "you can assign it to a variable", "tag": "none", "senID": 12}, {"text": "you can copy it", "tag": "none", "senID": 13}, {"text": "you can add attributes to it", "tag": "none", "senID": 14}, {"text": "you can pass it as a function parameter", "tag": "none", "senID": 15}]}, {"text": ["e.g."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print ObjectCreator # you can print a class because it's an object\n  &lt;class '__main__.ObjectCreator'&gt;\n  &gt;&gt;&gt; def echo(o):\n  ...       print o\n  ... \n  &gt;&gt;&gt; echo(ObjectCreator) # you can pass a class as a parameter\n  &lt;class '__main__.ObjectCreator'&gt;\n  &gt;&gt;&gt; print hasattr(ObjectCreator, 'new_attribute')\n  False\n  &gt;&gt;&gt; ObjectCreator.new_attribute = 'foo' # you can add attributes to a class\n  &gt;&gt;&gt; print hasattr(ObjectCreator, 'new_attribute')\n  True\n  &gt;&gt;&gt; print ObjectCreator.new_attribute\n  foo\n  &gt;&gt;&gt; ObjectCreatorMirror = ObjectCreator # you can assign a class to a variable\n  &gt;&gt;&gt; print ObjectCreatorMirror.new_attribute\n  foo\n  &gt;&gt;&gt; print ObjectCreatorMirror()\n  &lt;__main__.ObjectCreator object at 0x8997b4c&gt;\n</code>\n</pre>\n", "senID": 17}, {"text": ["Since classes are objects, you can create them on the fly, like any object."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["First, you can create a class in a function using class:"], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "class", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def choose_class(name):\n  ...     if name == 'foo':\n  ...         class Foo(object):\n  ...             pass\n  ...         return Foo # return the class, not an instance\n  ...     else:\n  ...         class Bar(object):\n  ...             pass\n  ...         return Bar\n  ...     \n  &gt;&gt;&gt; MyClass = choose_class('foo') \n  &gt;&gt;&gt; print MyClass # the function returns a class, not an instance\n  &lt;class '__main__.Foo'&gt;\n  &gt;&gt;&gt; print MyClass() # you can create an object from this class\n  &lt;__main__.Foo object at 0x89c6d4c&gt;\n</code>\n</pre>\n", "senID": 20}, {"text": ["But it's not so dynamic, since you still have to write the whole class yourself."], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"text": ["Since classes are objects, they must be generated by something."], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"text": ["When you use the class keyword, Python creates this object automatically.", "But as\nwith most things in Python, it gives you a way to do it manually."], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "class", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Remember the function type?", "The good old function that lets you know what \ntype an object is:"], "childNum": 1, "tag": "p", "senID": 24, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print type(1)\n&lt;type 'int'&gt;\n&gt;&gt;&gt; print type(\"1\")\n&lt;type 'str'&gt;\n&gt;&gt;&gt; print type(ObjectCreator)\n&lt;type 'type'&gt;\n&gt;&gt;&gt; print type(ObjectCreator())\n&lt;class '__main__.ObjectCreator'&gt;\n</code>\n</pre>\n", "senID": 25}, {"text": ["Well, type has a completely different ability, it can also create classes on \nthe fly.", "type can take the description of a class as parameters, \nand return a class."], "childNum": 2, "tag": "p", "senID": 26, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "type", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["(I  know, it's silly that the same function can have two completely different uses\naccording to the parameters you pass to it.", "It's an issue due to backwards \ncompatibility in Python)"], "childNum": 0, "tag": "p", "senID": 27, "childList": []}, {"text": ["type works this way:"], "childNum": 1, "tag": "p", "senID": 28, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n type(name of the class, \n       tuple of the parent class (for inheritance, can be empty), \n       dictionary containing attributes names and values)\n</code>\n</pre>\n", "senID": 29}, {"text": ["e.g."], "childNum": 0, "tag": "p", "senID": 30, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class MyShinyClass(object):\n...       pass\n</code>\n</pre>\n", "senID": 31}, {"text": ["can be created manually this way:"], "childNum": 0, "tag": "p", "senID": 32, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; MyShinyClass = type('MyShinyClass', (), {}) # returns a class object\n  &gt;&gt;&gt; print MyShinyClass\n  &lt;class '__main__.MyShinyClass'&gt;\n  &gt;&gt;&gt; print MyShinyClass() # create an instance with the class\n  &lt;__main__.MyShinyClass object at 0x8997cec&gt;\n</code>\n</pre>\n", "senID": 33}, {"text": ["You'll notice that we use \"MyShinyClass\" as the name of the class\nand as the variable to hold the class reference.", "They can be different,\nbut there is no reason to complicate things."], "childNum": 0, "tag": "p", "senID": 34, "childList": []}, {"text": ["type accepts a dictionary to define the attributes of the class.", "So:"], "childNum": 1, "tag": "p", "senID": 35, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class Foo(object):\n...       bar = True\n</code>\n</pre>\n", "senID": 36}, {"text": ["Can be translated to:"], "childNum": 0, "tag": "p", "senID": 37, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; Foo = type('Foo', (), {'bar':True})\n</code>\n</pre>\n", "senID": 38}, {"text": ["And used as a normal class:"], "childNum": 0, "tag": "p", "senID": 39, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print Foo\n  &lt;class '__main__.Foo'&gt;\n  &gt;&gt;&gt; print Foo.bar\n  True\n  &gt;&gt;&gt; f = Foo()\n  &gt;&gt;&gt; print f\n  &lt;__main__.Foo object at 0x8a9b84c&gt;\n  &gt;&gt;&gt; print f.bar\n  True\n</code>\n</pre>\n", "senID": 40}, {"text": ["And of course, you can inherit from it, so:"], "childNum": 0, "tag": "p", "senID": 41, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;   class FooChild(Foo):\n  ...         pass\n</code>\n</pre>\n", "senID": 42}, {"text": ["would be:"], "childNum": 0, "tag": "p", "senID": 43, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; FooChild = type('FooChild', (Foo,), {})\n  &gt;&gt;&gt; print FooChild\n  &lt;class '__main__.FooChild'&gt;\n  &gt;&gt;&gt; print FooChild.bar # bar is inherited from Foo\n  True\n</code>\n</pre>\n", "senID": 44}, {"text": ["Eventually you'll want to add methods to your class.", "Just define a function\nwith the proper signature and assign it as an attribute."], "childNum": 0, "tag": "p", "senID": 45, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def echo_bar(self):\n...       print self.bar\n... \n&gt;&gt;&gt; FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})\n&gt;&gt;&gt; hasattr(Foo, 'echo_bar')\n&gt;&gt;&gt; hasattr(FooChild, 'echo_bar')\nTrue\n&gt;&gt;&gt; my_foo = FooChild()\n&gt;&gt;&gt; my_foo.echo_bar()\nTrue\n</code>\n</pre>\n", "senID": 46}, {"text": ["You see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically."], "childNum": 0, "tag": "p", "senID": 47, "childList": []}, {"text": ["This is what Python does when you use the keyword class, and it does so by using a metaclass."], "childNum": 1, "tag": "p", "senID": 48, "childList": [{"text": "class", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Metaclasses are the 'stuff' that creates classes."], "childNum": 0, "tag": "p", "senID": 49, "childList": []}, {"text": ["You define classes in order to create objects, right?"], "childNum": 0, "tag": "p", "senID": 50, "childList": []}, {"text": ["But we learned that Python classes are objects."], "childNum": 0, "tag": "p", "senID": 51, "childList": []}, {"text": ["Well, metaclasses are what create these objects.", "There are the classes' classes,\nyou can picture them this way:"], "childNum": 0, "tag": "p", "senID": 52, "childList": []}, {"code": "<pre>\n<code>\n MyClass = MetaClass()\n  MyObject = MyClass()\n</code>\n</pre>\n", "senID": 53}, {"text": ["You've seen that type lets you do something like this:"], "childNum": 1, "tag": "p", "senID": 54, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n MyClass = type('MyClass', (), {})\n</code>\n</pre>\n", "senID": 55}, {"text": ["It's because the function type is in fact a metaclass.", "type is the \nmetaclass Python uses to create all classes behind the scenes."], "childNum": 2, "tag": "p", "senID": 56, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "type", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Now you wonder why the heck is it written in lowercase, and not Type?"], "childNum": 1, "tag": "p", "senID": 57, "childList": [{"text": "Type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Well, I guess it's a matter of consistency with str, the class that creates\nstrings objects, and int the class that creates integer objects.", "type is\njust the class that creates class objects."], "childNum": 3, "tag": "p", "senID": 58, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "type", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You see that by checking the __class__ attribute. "], "childNum": 1, "tag": "p", "senID": 59, "childList": [{"text": "__class__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Everything, and I mean everything, is an object in Python.", "That includes ints, \nstrings, functions and classes.", "All of them are objects.", "And all of them have\nbeen created from a class:"], "childNum": 0, "tag": "p", "senID": 60, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; age = 35\n  &gt;&gt;&gt; age.__class__\n  &lt;type 'int'&gt;\n  &gt;&gt;&gt; name = 'bob'\n  &gt;&gt;&gt; name.__class__\n  &lt;type 'str'&gt;\n  &gt;&gt;&gt; def foo(): pass\n  &gt;&gt;&gt; foo.__class__\n  &lt;type 'function'&gt;\n  &gt;&gt;&gt; class Bar(object): pass\n  &gt;&gt;&gt; b = Bar()\n  &gt;&gt;&gt; b.__class__\n  &lt;class '__main__.Bar'&gt;\n</code>\n</pre>\n", "senID": 61}, {"text": ["Now, what is the __class__ of any __class__ ?"], "childNum": 2, "tag": "p", "senID": 62, "childList": [{"text": "__class__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__class__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a.__class__.__class__\n  &lt;type 'type'&gt;\n  &gt;&gt;&gt; age.__class__.__class__\n  &lt;type 'type'&gt;\n  &gt;&gt;&gt; foo.__class__.__class__\n  &lt;type 'type'&gt;\n  &gt;&gt;&gt; b.__class__.__class__\n  &lt;type 'type'&gt;\n</code>\n</pre>\n", "senID": 63}, {"text": ["So, a metaclass is just the stuff that creates class objects."], "childNum": 0, "tag": "p", "senID": 64, "childList": []}, {"text": ["You can call it a 'class factory' if you wish."], "childNum": 0, "tag": "p", "senID": 65, "childList": []}, {"text": ["type is the built-in metaclass Python uses, but of course, you can create your\nown metaclass."], "childNum": 1, "tag": "p", "senID": 66, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You can add a __metaclass__ attribute when you write a class:"], "childNum": 1, "tag": "p", "senID": 67, "childList": [{"text": "__metaclass__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Foo(object):\n  __metaclass__ = something...\n  [...]\n</code>\n</pre>\n", "senID": 68}, {"text": ["If you do so, Python will use the metaclass to create the class Foo."], "childNum": 1, "tag": "p", "senID": 69, "childList": [{"text": "Foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Careful, it's tricky."], "childNum": 0, "tag": "p", "senID": 70, "childList": []}, {"text": ["You write class Foo(object) first, but the class object Foo is not created\nin memory yet."], "childNum": 2, "tag": "p", "senID": 71, "childList": [{"text": "class Foo(object)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Foo", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Python will look for __metaclass__ in the class definition.", "If it finds it,\nif will use it to create the object class Foo.", "If it doesn't, it will use\ntype to create the class."], "childNum": 3, "tag": "p", "senID": 72, "childList": [{"text": "__metaclass__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Foo", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "type", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Read that several times."], "childNum": 0, "tag": "p", "senID": 73, "childList": []}, {"text": ["When you do:"], "childNum": 0, "tag": "p", "senID": 74, "childList": []}, {"code": "<pre>\n<code>\n class Foo(Bar):\n  pass\n</code>\n</pre>\n", "senID": 75}, {"text": ["Python does the following:"], "childNum": 0, "tag": "p", "senID": 76, "childList": []}, {"text": ["Is there a __metaclass__ attribute in Foo?"], "childNum": 2, "tag": "p", "senID": 77, "childList": [{"text": "__metaclass__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Foo", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If yes, create in memory a class object (I said a class object, stay with me here),\nwith the name Foo by using what is in __metaclass__."], "childNum": 2, "tag": "p", "senID": 78, "childList": [{"text": "Foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__metaclass__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If Python can't find __metaclass__, it will look for a __metaclass__ in \nBar (the parent class), and try to do the same."], "childNum": 2, "tag": "p", "senID": 79, "childList": [{"text": "__metaclass__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__metaclass__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If Python can't find __metaclass__ in any parent, it will look for \na __metaclass__ at the MODULE level, and try to do the same."], "childNum": 2, "tag": "p", "senID": 80, "childList": [{"text": "__metaclass__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__metaclass__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Then if it can't find any __metaclass__ at all, it will use type\nto create the class object."], "childNum": 2, "tag": "p", "senID": 81, "childList": [{"text": "__metaclass__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "type", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Now the big question is, what can you put in __metaclass__ ?"], "childNum": 1, "tag": "p", "senID": 82, "childList": [{"text": "__metaclass__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The answer is: something that can create a class."], "childNum": 0, "tag": "p", "senID": 83, "childList": []}, {"text": ["And what can create a class?", "type, or anything that subclasses or uses it."], "childNum": 1, "tag": "p", "senID": 84, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The main purpose of a metaclass is to change the class automatically,\nwhen it's created."], "childNum": 0, "tag": "p", "senID": 85, "childList": []}, {"text": ["You usually do this for APIs, where you want to create classes matching the\ncurrent context."], "childNum": 0, "tag": "p", "senID": 86, "childList": []}, {"text": ["Imagine a stupid example, where you decide that all classes in your module\nshould have their attributes written in uppercase.", "There are several ways to \ndo this, but one way is to set __metaclass__ at the module level."], "childNum": 1, "tag": "p", "senID": 87, "childList": [{"text": "__metaclass__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This way, all classes of this module will be created using this metaclass, \nand we just have to tell the metaclass to turn all attributes to uppercase."], "childNum": 0, "tag": "p", "senID": 88, "childList": []}, {"text": ["Luckily, __metaclass__ can actually be any callable, it doesn't need to be a\nformal class (I know, something with 'class' in its name doesn't need to be \na class, go figure... but it's helpful)."], "childNum": 1, "tag": "p", "senID": 89, "childList": [{"text": "__metaclass__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So we will start with a simple example, by using a function."], "childNum": 0, "tag": "p", "senID": 90, "childList": []}, {"code": "<pre>\n<code>\n # the metaclass will automatically get passed the same argument\n# that you usually pass to `type`\ndef upper_attr(future_class_name, future_class_parents, future_class_attr):\n  \"\"\"\n    Return a class object, with the list of its attribute turned \n    into uppercase.\n  \"\"\"\n\n  # pick up any attribute that doesn't start with '__'\n  attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))\n  # turn them into uppercase\n  uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n\n  # let `type` do the class creation\n  return type(future_class_name, future_class_parents, uppercase_attr)\n\n__metaclass__ = upper_attr # this will affect all classes in the module\n\nclass Foo(object): \n  # we can define __metaclass__ here instead to affect only this class\n  bar = 'bip'\n\nprint hasattr(Foo, 'bar')\n# Out: False\nprint hasattr(Foo, 'BAR')\n# Out: True\n\nf = Foo()\nprint f.BAR\n# Out: 'bip'\n</code>\n</pre>\n", "senID": 91}, {"text": ["Now, let's do exactly the same, but using a real class for a metaclass:"], "childNum": 0, "tag": "p", "senID": 92, "childList": []}, {"code": "<pre>\n<code>\n # remember that `type` is actually a class like `str` and `int`\n# so you can inherit from it\nclass UpperAttrMetaclass(type): \n    # __new__ is the method called before __init__\n    # it's the method that creates the object and returns it\n    # while __init__ just initializes the object passed as parameter\n    # you rarely use __new__, except when you want to control how the object\n    # is created.\n    # here the created object is the class, and we want to customize it\n    # so we override __new__\n    # you can do some stuff in __init__ too if you wish\n    # some advanced use involves overriding __call__ as well, but we won't\n    # see this\n    def __new__(upperattr_metaclass, future_class_name, \n                future_class_parents, future_class_attr):\n\n        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))\n        uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n\n        return type(future_class_name, future_class_parents, uppercase_attr)\n</code>\n</pre>\n", "senID": 93}, {"text": ["But this is not really OOP.", "We call type directly and we don't override\ncall the parent __new__.", "Let's do it:"], "childNum": 2, "tag": "p", "senID": 94, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n class UpperAttrMetaclass(type): \n\n    def __new__(upperattr_metaclass, future_class_name, \n                future_class_parents, future_class_attr):\n\n        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))\n        uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n\n        # reuse the type.__new__ method\n        # this is basic OOP, nothing magic in there\n        return type.__new__(upperattr_metaclass, future_class_name, \n                            future_class_parents, uppercase_attr)\n</code>\n</pre>\n", "senID": 95}, {"text": ["You may have noticed the extra argument upperattr_metaclass.", "There is\nnothing special about it: a method always receives the current instance as\nfirst parameter.", "Just like you have self for ordinary methods."], "childNum": 2, "tag": "p", "senID": 96, "childList": [{"text": "upperattr_metaclass", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Of course, the names I used here are long for the sake of clarity, but like\nfor self, all the arguments have conventional names.", "So a real production\nmetaclass would look like this:"], "childNum": 1, "tag": "p", "senID": 97, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class UpperAttrMetaclass(type): \n\n    def __new__(cls, name, bases, dct):\n\n        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__'))\n        uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n\n        return type.__new__(cls, name, bases, uppercase_attr)\n</code>\n</pre>\n", "senID": 98}, {"text": ["We can make it even cleaner by using super, which will ease inheritance (because\nyes, you can have metaclasses, inheriting from metaclasses, inheriting from type):"], "childNum": 1, "tag": "p", "senID": 99, "childList": [{"text": "super", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class UpperAttrMetaclass(type): \n\n    def __new__(cls, name, bases, dct):\n\n        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__'))\n        uppercase_attr = dict((name.upper(), value) for name, value in attrs)\n\n        return super(UpperAttrMetaclass, cls).__new__(name, bases, dct)\n</code>\n</pre>\n", "senID": 100}, {"text": ["That's it.", "There is really nothing more about metaclasses."], "childNum": 0, "tag": "p", "senID": 101, "childList": []}, {"text": ["The reason behind the complexity of the code using metaclasses is not because\nof metaclasses, it's because you usually use metaclasses to do twisted stuff\nrelying on introspection, manipulating inheritance, vars such as __dict__, etc."], "childNum": 1, "tag": "p", "senID": 102, "childList": [{"text": "__dict__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Indeed, metaclasses are especially useful to do black magic, and therefore\ncomplicated sutff.", "But by themselves, they are simple:"], "childNum": 0, "tag": "p", "senID": 103, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "intercept a class creation", "tag": "none", "senID": 104}, {"text": "modify the class", "tag": "none", "senID": 105}, {"text": "return the modified class", "tag": "none", "senID": 106}]}, {"text": ["Since __metaclass__ can accept any callable, why would you use a class\nsince it's obviously more complicated?"], "childNum": 1, "tag": "p", "senID": 107, "childList": [{"text": "__metaclass__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["There are several reasons to do so:"], "childNum": 0, "tag": "p", "senID": 108, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "The intention is clear. When you read ", "tag": "none", "senID": 109}, {"text": "You can use OOP. Metaclass can inherit from metaclass, override parent methods.\nMetaclasses can even use metaclasses.", "tag": "none", "senID": 110}, {"text": "You can structure your code better. You never use metaclasses for something as\ntrivial as the above example. It's usually for something complicated. Having the\nability to make several methods and group them in one class is very useful\nto make the code easier to read.", "tag": "none", "senID": 111}, {"text": "You can hook on ", "tag": "none", "senID": 112}, {"text": "These are called metaclasses, damn it! It must mean something!", "tag": "none", "senID": 113}]}, {"text": ["Now the big question.", "Why would use some obscure error prone feature?"], "childNum": 0, "tag": "p", "senID": 114, "childList": []}, {"text": ["Well, usually you don't:"], "childNum": 0, "tag": "p", "senID": 115, "childList": []}, {"text": ["Python Guru Tim Peters"], "childNum": 1, "tag": "p", "senID": 116, "childList": [{"text": "Python Guru Tim Peters", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["The main use case for a metaclass is creating an API.", "A typical example of this is the Django ORM."], "childNum": 0, "tag": "p", "senID": 117, "childList": []}, {"text": ["It allows you to define something like this:"], "childNum": 0, "tag": "p", "senID": 118, "childList": []}, {"code": "<pre>\n<code>\n class Person(models.Model):\n    name = models.CharField(max=length=30)\n    age = models.IntegerField()\n</code>\n</pre>\n", "senID": 119}, {"text": ["But if you do this:"], "childNum": 0, "tag": "p", "senID": 120, "childList": []}, {"code": "<pre>\n<code>\n guy = Person(name='bob', age='35')\n  print guy.age\n</code>\n</pre>\n", "senID": 121}, {"text": ["It won't return an IntegerField object.", "It will return an int, and can even take it directly from the database."], "childNum": 2, "tag": "p", "senID": 122, "childList": [{"text": "IntegerField", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This is possible because models.Model defines __metaclass__ and \nit uses some magic that will turn the Person you just defined with simple statements\ninto a complex hook to a database field. "], "childNum": 3, "tag": "p", "senID": 123, "childList": [{"text": "models.Model", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__metaclass__", "childNum": 0, "tag": "code", "childList": []}, {"text": "Person", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Django makes something complex looks simple by exposing a simple API\nand using metaclasses, recreating code from this API to do the real job\nbehind the scenes."], "childNum": 0, "tag": "p", "senID": 124, "childList": []}, {"text": ["First, you know that classes are objects that can create instances."], "childNum": 0, "tag": "p", "senID": 125, "childList": []}, {"text": ["Well in fact, classes are themselves instances.", "Of metaclasses."], "childNum": 0, "tag": "p", "senID": 126, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class Foo(object): pass\n  &gt;&gt;&gt; id(Foo)\n  142630324\n</code>\n</pre>\n", "senID": 127}, {"text": ["Everything is an object in Python, and they are all either instances of classes\nor instances of metaclasses."], "childNum": 0, "tag": "p", "senID": 128, "childList": []}, {"text": ["Except for type."], "childNum": 1, "tag": "p", "senID": 129, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["type is actually it's own metaclass.", "This is not something you could\nreproduce in pure Python, and is done by cheating a little bit at the implementation\nlevel."], "childNum": 1, "tag": "p", "senID": 130, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Secondly, metaclasses are complicated.", "You may not want to use them for \nvery simple class alterations.", "You can change classes by using two different techniques:"], "childNum": 0, "tag": "p", "senID": 131, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "monkey patching", "tag": "none", "senID": 132}, {"text": "class decorators", "tag": "none", "senID": 133}]}, {"text": ["99% of the time you need class alteration, you are better off using these."], "childNum": 0, "tag": "p", "senID": 134, "childList": []}, {"text": ["But 99% of the time, you don't need class alteration at all :-)"], "childNum": 0, "tag": "p", "senID": 135, "childList": []}], [{"text": ["A metaclass is the class of a class.", "Like a class defines how an instance of the class behaves, a metaclass defines how a class behaves.", "A class is an instance of a metaclass."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["While in Python you can use arbitrary callables for metaclasses (like Jerub shows), the more useful approach is actually to make it an actual class itself.", "'type' is the usual metaclass in Python.", "In case you're wondering, yes, 'type' is itself a class, and it is its own type.", "You won't be able to recreate something like 'type' purely in Python, but Python cheats a little.", "To create your own metaclass in Python you really just want to subclass 'type'."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Jerub", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/100037#100037"}]}, {"text": ["A metaclass is most commonly used as a class-factory.", "Like you create an instance of the class by calling the class, Python creates a new class (when it executes the 'class' statement) by calling the metaclass.", "Combined with the normal __init__ and __new__ methods, metaclasses therefor allow you to do 'extra things' when creating a class, like registering the new class with some registry, or even replace the class with something else entirely."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["When the 'class' statement is executed, Python first executes the body of the 'class' statement as a normal block of code.", "The resulting namespace (a dict) holds the attributes of the class-to-be.", "The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the __metaclass__ attribute of the class-to-be (if any) or the '__metaclass__' global variable.", "The metaclass is then called with the name, bases and attributes of the class to instantiate it."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["However, metaclasses actually define the type of a class, not just a factory for it, so you can do much more with them.", "You can, for instance, define normal methods on the metaclass.", "These metaclass-methods are like classmethods, in that they can be called on the class without an instance, but they are also not like classmethods in that they cannot be called on an instance of the class.", "type.__subclasses__() is an example of a method on the 'type' metaclass.", "You can also define the normal 'magic' methods, like __add__, __iter__ and __getattr__, to implement or change how the class behaves."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "type", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Here's an aggregated example of the bits and pieces:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def make_hook(f):\n    \"\"\"Decorator to turn 'foo' method into '__foo__'\"\"\"\n    f.is_hook = 1\n    return f\n\nclass MyType(type):\n    def __new__(cls, name, bases, attrs):\n\n        if name.startswith('None'):\n            return None\n\n        # Go over attributes and see if they should be renamed.\n        newattrs = {}\n        for attrname, attrvalue in attrs.iteritems():\n            if getattr(attrvalue, 'is_hook', 0):\n                newattrs['__%s__' % attrname] = attrvalue\n            else:\n                newattrs[attrname] = attrvalue\n\n        return super(MyType, cls).__new__(cls, name, bases, newattrs)\n\n    def __init__(self, name, bases, attrs):\n        super(MyType, self).__init__(name, bases, attrs)\n\n        # classregistry.register(self, self.interfaces)\n        print \"Would register class %s now.\" % self\n\n    def __add__(self, other):\n        class AutoClass(self, other):\n            pass\n        return AutoClass\n        # Alternatively, to autogenerate the classname as well as the class:\n        # return type(self.__name__ + other.__name__, (self, other), {})\n\n    def unregister(self):\n        # classregistry.unregister(self)\n        print \"Would unregister class %s now.\" % self\n\nclass MyObject:\n    __metaclass__ = MyType\n\n\nclass NoneSample(MyObject):\n    pass\n\n# Will print \"NoneType None\"\nprint type(NoneSample), repr(NoneSample)\n\nclass Example(MyObject):\n    def __init__(self, value):\n        self.value = value\n    @make_hook\n    def add(self, other):\n        return self.__class__(self.value + other.value)\n\n# Will unregister the class\nExample.unregister()\n\ninst = Example(10)\n# Will fail with an AttributeError\n#inst.unregister()\n\nprint inst + inst\nclass Sibling(MyObject):\n    pass\n\nExampleSibling = Example + Sibling\n# ExampleSibling is now a subclass of both Example and Sibling (with no\n# content of its own) although it will believe it's called 'AutoClass'\nprint ExampleSibling\nprint ExampleSibling.__mro__\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Metaclasses are the secret sauce that make 'class' work.", "The default metaclass for a new style object is called 'type'."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Metaclasses take 3 args.", "'name', 'bases' and 'dict'"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "name", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "bases", "childNum": 0, "tag": "strong", "childList": []}, {"text": "dict", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Here is where the secret starts.", "Look for where name, bases and the dict come from in this example class definition."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class ThisIsTheName(Bases, Are, Here):\n    All_the_code_here\n    def doesIs(create, a):\n        dict\n</code>\n</pre>\n", "senID": 3}, {"text": ["Lets define a metaclass that will demonstrate how 'class:' calls it."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "class:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def test_metaclass(name, bases, dict):\n    print 'The Class Name is', name\n    print 'The Class Bases are', bases\n    print 'The dict has', len(dict), 'elems, the keys are', dict.keys()\n\n    return \"yellow\"\n\nclass TestName(object, None, int, 1):\n    __metaclass__ = test_metaclass\n    foo = 1\n    def baz(self, arr):\n        pass\n\nprint 'TestName = ', repr(TestName)\n\n# output =&gt; \nThe Class Name is TestName\nThe Class Bases are (&lt;type 'object'&gt;, None, &lt;type 'int'&gt;, 1)\nThe dict has 4 elems, the keys are ['baz', '__module__', 'foo', '__metaclass__']\nTestName =  'yellow'\n</code>\n</pre>\n", "senID": 5}, {"text": ["And now, an example that actually means something, this will automatically make the variables in the list \"attributes\" set on the class, and set to None."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def init_attributes(name, bases, dict):\n    if 'attributes' in dict:\n        for attr in dict['attributes']:\n            dict[attr] = None\n\n    return type(name, bases, dict)\n\nclass Initialised(object):\n    __metaclass__ = init_attributes\n    attributes = ['foo', 'bar', 'baz']\n\nprint 'foo =&gt;', Initialised.foo\n# output=&gt;\nfoo =&gt; None\n</code>\n</pre>\n", "senID": 7}, {"text": ["Note that the magic behaviour that 'Initalised' gains by having the metaclass init_attributes is not passed onto a subclass of Initalised."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Here is an even more concrete example, showing how you can subclass 'type' to make a metaclass that performs an action when the class is created.", "This is quite tricky:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n class MetaSingleton(type):\n    instance = None\n    def __call__(cls, *args, **kw):\n        if cls.instance is None:\n            cls.instance = super(MetaSingleton, cls).__call__(*args, **kw)\n        return cls.instance\n\n class Foo(object):\n     __metaclass__ = MetaSingleton\n\n a = Foo()\n b = Foo()\n assert a is b\n</code>\n</pre>\n", "senID": 10}], [{"text": ["One use for metaclasses is adding new properties and methods to an instance automatically."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, if you look at Django models, their definition looks a bit confusing.", "It looks as if you are only defining class properties:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Django models", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev/topics/db/models/"}]}, {"code": "<pre>\n<code>\n class Person(models.Model):\n    first_name = models.CharField(max_length=30)\n    last_name = models.CharField(max_length=30)\n</code>\n</pre>\n", "senID": 2}, {"text": ["However, at runtime the Person objects are filled with all sorts of useful methods.", "See the source for some amazing metaclassery."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "source", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.djangoproject.com/browser/django/trunk/django/db/models/base.py"}]}], [{"text": ["I think the ONLamp introduction to metaclass programming is well written and gives a really good introduction to the topic despite being several years old already."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html"}]}, {"text": ["In short: A class is a blueprint for the creation of an instance, a metaclass is a blueprint for the creation of a class.", "It can be easily seen that in Python classes need to be first-class objects too to enable this behavior."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I've never written one myself, but I think one of the nicest uses of metaclasses can be seen in the Django framework.", "The model classes use a metaclass approach to enable a declarative style of writing new models or form classes.", "While the metaclass is creating the class, all members get the possibility to customize the class itself."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Django framework", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.djangoproject.com/"}]}, {"tag": "ul", "num": 2, "lis": [{"text": ["Creating a new model"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}, {"text": ["The metaclass enabling this"], "childNum": 0, "tag": "a", "senID": 5, "childList": []}]}, {"text": ["The thing that's left to say is: If you don't know what metaclasses are, the probability that you will not need them is 99%."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "will not need them", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Here are a list of sites that helped me learn more about metaclasses:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": ["A conservative metaclass"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["Stupid Metaclass and Template Tricks"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}, {"text": ["Metaclass programming in Python (ibm.com): Part 1 ibm.com"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}, {"text": ["Metaclass programming in Python (ibm.com): Part 2 ibm.com"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}, {"text": ["Metaclass programming in Python (ibm.com): Part 3 ibm.com"], "childNum": 0, "tag": "a", "senID": 5, "childList": []}]}], [{"text": ["Others have explained how metaclasses work and how they fit into the Python type system.", "Here's an example of what they can be used for.", "In a script I wrote, I wanted to keep track of the order in which classes were defined, so that I could later instantiate them in this order.", "I found it easiest to do this using a metaclass."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MyMeta(type):\n\n    counter = 0\n\n    def __init__(cls, name, bases, dic):\n        type.__init__(cls, name, bases, dic)\n        cls._order = MyMeta.counter\n        MyMeta.counter += 1\n\nclass MyType(object):\n\n    __metaclass__ = MyMeta\n</code>\n</pre>\n", "senID": 1}, {"text": ["Anything that's a subclass of MyType then gets a class attribute _order that records the order in which the classes were defined."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "MyType", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "_order", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Short and useful example using metaclass\n6 - 8 line complete Plugin framework"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://djangosnippets.org/snippets/542/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://djangosnippets.org/snippets/542/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://djangosnippets.org/snippets/542/"}]}], [{"text": ["The best metaclass explanation I have read is \"Metaclasses Demystified\"  http://cleverdevil.org/computing/78/, which originally appeared in Python Magazine."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://cleverdevil.org/computing/78/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cleverdevil.org/computing/78/"}]}]]