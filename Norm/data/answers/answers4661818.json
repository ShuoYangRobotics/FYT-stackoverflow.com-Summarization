[[{"text": ["Python 2.7+, 201 192 187 181 179 175 171 chars"], "childNum": 1, "tag": "h2", "senID": 0, "childList": [{"text": "201 192 187 181 179 175", "childNum": 0, "tag": "del", "pos": 0, "childList": []}]}, {"text": ["PS.", "After the problem was relaxed (no need to output state line on empty input), here is new code that's notably shorter.", "If you are on version &lt;2.7, there is no dict comprehension, so instead of {c+o:s for o,c,s in i[1:-1]} try dict((c+o,s)for o,c,s in i[1:-1]) for the price of +5."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "dict comprehension", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "{c+o:s for o,c,s in i[1:-1]}", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict((c+o,s)for o,c,s in i[1:-1])", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import sys\ni=map(str.split,sys.stdin)\ns=i[0][0]\nfor c in''.join(i[-1]):\n    if s:o=s;s={c+o:s for o,c,s in i[1:-1]}.get(c+s,());print o,c,'-&gt;',s\nprint'ARCECJEEPCTT'[s&gt;'Z'::2]\n</code>\n</pre>\n", "senID": 2}, {"text": ["And its test output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # for empty input\nACCEPT\n\n# for input '1001010'\nS1 1  -&gt;  S1\nS1 0  -&gt;  s2\ns2 0  -&gt;  S1\nS1 1  -&gt;  S1\nS1 0  -&gt;  s2\ns2 1  -&gt;  s2\ns2 0  -&gt;  S1\nACCEPT\n\n# for input '101'\nS1 1  -&gt;  S1\nS1 0  -&gt;  s2\ns2 1  -&gt;  s2\nREJECT\n\n# for input '10X'\nS1 1  -&gt;  S1\nS1 0  -&gt;  s2\ns2 X  -&gt;  ()\nREJECT\n\n# for input 'X10'\nS1 X  -&gt;  ()\nREJECT\n</code>\n</pre>\n", "senID": 4}, {"text": ["Previous entry (len 201):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import sys\ni=list(sys.stdin)\ns=i[0].split()[0]\nt={}\nfor r in i[1:-1]:a,b,c=r.split();t[a,b]=c\ntry:\n    for c in i[-1]:print s,c.strip(),;s=t[s,c];print' -&gt;',s\nexcept:print('ACCEPT','REJECT')[s&gt;'Z'or' '&lt;c]\n</code>\n</pre>\n", "senID": 6}, {"text": ["I want to apologize before someone slaps me for it: the code behavior is slightly different from the original spec - per question-comments discussion.", "This is my illustration for the discussion."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "the code behavior is slightly different", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["PS.", "while i like the resolution ACCEPT/REJECT on the same line with the final state, it can me moved to solitude (e.g.", "imagine results are to be parsed by stupid script that only cares about last line being accept or reject) by adding '\\n'+ (5 chars) to the last print for the price of +5 chars."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "'\\n'+", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "print", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Example output:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n # for empty input\nS1  ACCEPT\n\n# for input '1001010'\nS1 1  -&gt; S1\nS1 0  -&gt; s2\ns2 0  -&gt; S1\nS1 1  -&gt; S1\nS1 0  -&gt; s2\ns2 1  -&gt; s2\ns2 0  -&gt; S1\nS1  ACCEPT\n\n# for input '101'\nS1 1  -&gt; S1\nS1 0  -&gt; s2\ns2 1  -&gt; s2\ns2  REJECT\n\n# for input '10X'\nS1 1  -&gt; S1\nS1 0  -&gt; s2\ns2 X REJECT\n\n# for input 'X10'\nS1 X REJECT\n</code>\n</pre>\n", "senID": 10}], [{"text": ["I'm feeling retro today, my language of choice for this task is IBM Enterprise Cobol - char count 2462 4078 (Sorry, pasted from a screen oriented device, trailing spaces are a tragic side effect):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "2462", "childNum": 0, "tag": "s", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n Identification Division.               \n Program-ID. FSM.                       \n Environment Division.                  \n Data Division.                         \n Working-Storage Section.               \n\n 01 FSM-Storage.                        \n\n*&gt; The current state                    \n   05 Start-State      Pic X(2).        \n   05 Next-State       Pic X(2).        \n\n*&gt; List of valid states                 \n   05 FSM-State-Cnt    Pic 9.           \n   05 FSM-States       Occurs 9         \n                       Pic X(2).        \n\n*&gt; List of valid transitions            \n   05 FSM-Trans-Cnt    Pic 999.         \n   05 FSM-Trans        Occurs 999.      \n     10 Trans-Start    Pic X(2).        \n     10 Trans-Char     Pic X.           \n     10 Trans-End      Pic X(2).        \n\n*&gt; Input                                \n   05 In-Buff          Pic X(72).      \n\n*&gt; Some work fields                     \n   05 II               Pic s9(8) binary.\n   05 JJ               Pic s9(8) binary.\n\n   05 Wk-Start         Pic X(2).        \n   05 Wk-Char          Pic X.           \n   05 Wk-End           Pic X(2).        \n   05 Wk-Cnt           Pic 999.         \n\n   05                  Pic X value ' '. \n     88 Valid-Input        value 'V'.   \n\n   05                  Pic X value ' '.                 \n     88 Valid-State        value 'V'.                   \n\n   05                  Pic X value ' '.                 \n     88 End-Of-States      value 'E'.                   \n\n   05                  Pic X value ' '.                 \n     88 Trans-Not-Found    value ' '.                   \n     88 Trans-Found        value 'T'.                   \n\n\n Linkage Section.                                       \n\n 01 The-Char-Area.                                      \n   05 The-Char         Pic X.                           \n     88 End-Of-Input       value x'13'.                 \n   05 The-Next-Char    Pic X.                           \n\n Procedure Division.                                    \n\n      Perform Load-States                               \n      Perform Load-Transitions                          \n      Perform Load-Input                                \n      Perform Process-Input                             \n\n      Goback.                                           \n\n*&gt; Run the machine...                                   \n Process-Input.                                         \n\n      Move FSM-States (1) to Start-State                \n      Set address of The-Char-Area to address of In-Buff\n\n      Perform until End-Of-Input                        \n\n        Perform Get-Next-State                          \n        Set address of The-Char-Area to address of The-Next-Char\n\n        Move Next-State to Start-State                          \n\n      End-Perform                                               \n\n      If Start-State (1:1) is Alphabetic-Lower                  \n        Display 'REJECT'                                        \n      Else                                                      \n        Display 'ACCEPT'                                        \n      End-If                                                    \n\n      Exit.                                                     \n\n*&gt; Look up the first valid transition...                        \n Get-Next-State.                                                \n\n      Set Trans-Not-Found to true                               \n      Perform varying II from 1 by 1                            \n        until (II &gt; FSM-State-Cnt)                              \n           or Trans-Found                                       \n\n        If Start-State = Trans-Start (II)                       \n          and The-Char = Trans-Char (II)                        \n\n          Move Trans-End (II) to Next-State                     \n          Set Trans-Found to true                               \n\n        End-If                                                  \n\n      End-Perform                                               \n      Display Start-State ' ' The-Char ' -&gt; ' Next-State        \n\n      Exit.                                                     \n\n*&gt; Read the states in...                                        \n Load-States.                                                   \n\n      Move low-values to In-Buff                         \n      Accept In-Buff from SYSIN                          \n\n      Move 0 to FSM-State-Cnt                            \n      Unstring In-Buff                                   \n        delimited by ' '                                 \n        into FSM-States (1) FSM-States (2) FSM-States (3)\n             FSM-States (4) FSM-States (5) FSM-States (6)\n             FSM-States (7) FSM-States (8) FSM-States (9)\n        count in FSM-State-Cnt                           \n      End-Unstring                                       \n\n      Exit.                                              \n\n*&gt; Read the transitions in...                            \n Load-Transitions.                                       \n\n      Move low-values to In-Buff                         \n      Accept In-Buff from SYSIN                          \n\n      Perform varying II from 1 by 1                     \n        until End-Of-States                              \n\n        Move 0 to Wk-Cnt                                 \n        Unstring In-Buff                                 \n          delimited by ' '                               \n          into Wk-Start Wk-Char Wk-End                   \n          count in Wk-Cnt                                \n        End-Unstring                                     \n\n        If Wk-Cnt = 3                                    \n\n          Add 1 to FSM-Trans-Cnt                         \n          Move Wk-Start to Trans-Start (FSM-Trans-Cnt)   \n          Move Wk-Char  to Trans-Char  (FSM-Trans-Cnt)   \n          Move Wk-End   to Trans-End   (FSM-Trans-Cnt)   \n\n          Move low-values to In-Buff                     \n          Accept In-Buff from SYSIN                           \n\n        Else                                                  \n\n          Set End-Of-States to true                           \n\n        End-If                                                \n\n      End-Perform                                             \n\n      Exit.                                                   \n\n*&gt; Fix input so it has newlines...the joys of mainframes      \n Load-Input.                                                  \n\n      Perform varying II from length of In-Buff by -1         \n        until Valid-Input                                     \n\n        If In-Buff (II:1) = ' ' or In-Buff (II:1) = low-values\n          Move x'13' to In-Buff (II:1)                        \n        Else                                                  \n          Set Valid-Input to true                             \n        End-If                                                \n\n      End-Perform                                             \n\n      Exit.                                                   \n\n  End Program FSM.\n</code>\n</pre>\n", "senID": 1}], [{"text": ["sed -- 118 137 characters"], "childNum": 1, "tag": "h2", "senID": 0, "childList": [{"text": "118", "childNum": 0, "tag": "s", "pos": 0, "childList": []}]}, {"text": ["This is using the -r flag (+3), for a total of 134+3=137 characters."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n $!{H;D}\n/:/!{G;s/(\\S*)..(\\S*)/\\2 \\1:/}\ns/(.* .)(.*\\n\\1 (\\S*))/\\1 -&gt; \\3\\n\\3 \\2/\n/-/{P;D}\n/^[A-Z].* :/cACCEPT\ns/( .).*/\\1/\n/:/!P\ncREJECT\n</code>\n</pre>\n", "senID": 2}, {"text": ["This should handle inputs without transitions correctly... hopefully it fully complies with the spec now..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Ruby 1.9.2 - 178 190 182 177 153 161 158 154 145 characters"], "childNum": 1, "tag": "h2", "senID": 0, "childList": [{"text": "178 190 182 177 153 161 158 154", "childNum": 0, "tag": "strike", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n h={}\no=s=p\n$&lt;.map{|l|o,b,c=l.split;h[[o,b]]=c;s||=o}\no.chars{|c|puts s+' '+c+((s=h[[s,c]])?' -&gt; '+s :'')}rescue 0\nputs s&amp;&amp;s&lt;'['?:ACCEPT: :REJECT\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n<code>\n [\n  \"S1 s2\nS1 0 s2\nS1 1 S1\ns2 0 S1\ns2 1 s2\n1001010\",\n  \"S1 s2\nS1 0 s2\nS1 1 S1\ns2 0 S1\ns2 1 s2\n101\",\n  \"S1 s2\nS1 0 s2\nS1 1 S1\ns2 0 S1\ns2 1 s2\n\",\n  \"S1 s2\nS1 0 s2\nS1 1 S1\ns2 0 S1\ns2 1 s2\n10X\"\n].each do |b|\n  puts \"------\"\n  puts \"Input:\"\n  puts b\n  puts\n  puts \"Output:\"\n  puts `echo \"#{b}\" | ruby fsm-golf.rb`\n  puts \"------\"\nend\n</code>\n</pre>\n", "senID": 2}, {"text": ["All input starts with:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n S1 s2\nS1 0 s2\nS1 1 S1\ns2 0 S1\ns2 1 s2\n</code>\n</pre>\n", "senID": 4}, {"code": "<pre>\n<code>\n Input: '1001010'\nOutput:\nS1 1 -&gt; S1\nS1 0 -&gt; s2\ns2 0 -&gt; S1\nS1 1 -&gt; S1\nS1 0 -&gt; s2\ns2 1 -&gt; s2\ns2 0 -&gt; S1\nACCEPT\n\nInput: '101'\nOutput:\nS1 1 -&gt; S1\nS1 0 -&gt; s2\ns2 1 -&gt; s2\nREJECT\n\nInput: 'X10'\nOutput:\nS1 X\nREJECT\n\nInput: ''\nOutput:\nACCEPT\n\nInput: '10X'\nOutput:\nS1 1 -&gt; S1\nS1 0 -&gt; s2\ns2 X\nREJECT\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Adam provided a reference implementation.", "I didn't see it before I made mine, but the logic is similar:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Edit: This is Python 2.6 code.", "I did not try to minimize length; I just tried to make it conceptually simple."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import sys\na = sys.stdin.read().split('\\n')\nstates = a[0].split()\ntransitions = a[1:-2]\ninput = a[-2]\nstatelist = {}\nfor state in states:\n    statelist[state] = {}\n\nfor start, char, end in [x.split() for x in transitions]:\n    statelist[start][char] = end\n\nstate = states[0]\nfor char in input:\n    if char not in statelist[state]:\n        print state,char\n        print \"REJECT\"\n        exit()\n    newstate = statelist[state][char]\n    print state, char, '-&gt;', newstate\n    state = newstate\nif state[0].upper() == state[0]:\n    print \"ACCEPT\"\nelse:\n    print \"REJECT\"\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Python, 218 characters"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\nT=sys.stdin.read()\nP=T.split()\nS=P[0]\nn=\"\\n\"\nfor L in P[-1]if T[-2]!=n else\"\":\n i=T.find(n+S+\" \"+L)\n if i&lt;0:print S,L;S=n;break\n S=T[i:].split()[2];print S,L,\"-&gt;\",S\nprint (\"REJECT\",\"ACCEPT\")[S[0].isupper()]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Haskell - 252 216 204 197 192 characters"], "childNum": 4, "tag": "h2", "senID": 0, "childList": [{"text": "252", "childNum": 0, "tag": "strike", "pos": 0, "childList": []}, {"text": "216", "childNum": 0, "tag": "strike", "childList": []}, {"text": "204", "childNum": 0, "tag": "strike", "childList": []}, {"text": "197", "childNum": 0, "tag": "strike", "childList": []}]}, {"code": "<pre>\n<code>\n s%(c:d,t)=s++' ':c:maybe('\\n':x)(\\[u]-&gt;\" -&gt; \"++u++'\\n':u%(d,t))(lookup[s,[c]]t)\ns%_|s&lt;\"[\"=\"ACCEPT\\n\"|1&lt;3=x\nx=\"REJECT\\n\"\np(i:j)=(words i!!0)%(last j,map(splitAt 2.words)j)\nmain=interact$p.lines\n</code>\n</pre>\n", "senID": 1}, {"text": ["Conforms to output specification."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Ungolf'd version:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n type State = String\ntype Transition = ((State, Char), State)\n\nrun :: [Transition] -&gt; State -&gt; String -&gt; [String]\nrun ts s (c:cs) =  maybe notFound found $ lookup (s,c) ts\n  where\n    notFound =  stateText                 : [\"REJECT\"]\n    found u  = (stateText ++ \" -&gt; \" ++ u) : run ts u cs\n    stateText = s ++ \" \" ++ [c]\n\nrun _ (s:_) \"\" | s &gt;= 'A' &amp;&amp; s &lt;= 'Z' = [\"ACCEPT\"]\n               | otherwise            = [\"REJECT\"]\n\nprepAndRun :: [String] -&gt; [String]\nprepAndRun (l0:ls) = run ts s0 input\n  where\n    s0 = head $ words l0\n    input = last ls\n    ts = map (makeEntry . words) $ init ls\n    makeEntry [s,(c:_),t] = ((s,c),t)\n\nmain' = interact $ unlines . prepAndRun . lines\n</code>\n</pre>\n", "senID": 4}, {"text": ["A good puzzle is why init isn't needed in the golf'd version!", "Other than that, rest are all standard Haskell golf techniques."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "init", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["(Count excluding all newlines, which are optional."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ($s)=split' ',&lt;&gt;;$\\=$/;\nwhile(&lt;&gt;){chomp;$r{$_[1].$_[0]}=$_[2]if split&gt;2;$t=$_}\n$_=$t;\n1 while$s&amp;&amp;s/(.)(.*)/print\"$s $1\",($s=$r{$1.$s})?\" -&gt; $s\":\"\";$2/e;\nprint$s=~/^[A-Z]/?\"ACCEPT\":\"REJECT\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also, this 155-character program does not implement the intermediate outputs, but executes the machine entirely as a repeated substitution on the whole FSM definition (changing the start state and input string).", "It was inspired by, but not derived from, the sed solution.", "It could be shortened by 2 characters by converting the (?:...", ") into a (...) and renumbering as needed."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "sed", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "(?:...)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "(...)", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n $/=\"\";$_=&lt;&gt;;\n1 while s/\\A(\\S+)(?: +\\S+)*\\n(.*\\n)?\\1 +(.) +(.+)\\n(.*\\n)?\\3([^\\n]*)\\n\\z/$4\\n$2$1 $3 $4\\n$5$6\\n/s;\nprint/\\A[A-Z].*\\n\\n\\z/s?\"ACCEPT\\n\":\"REJECT\\n\"\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The output format seems a bit hard to fit."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\nL=[i.split()for i in sys.stdin]\nN,P=L[0][0],print\nfor c in L[-1]and L[-1][-1]:\n if N:O,N=N,{(i[0],i[1]):i[2]for i in L[1:-1]}.get((N,c),'');P(O,c,N and'-&gt; '+N)\nP(('REJECT','ACCEPT')[''&lt;N&lt;'_'])\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n main=interact$r.lines\nr f=g t z$last f where{(z:_):t=map words f;g _ s\"\"|s&lt;\"[\"=\"ACCEPT\\n\";g([q,j,p]:_)s(i:k)|i:s==j++q=s++' ':i:\" -&gt; \"++p++'\\n':g t p k;g(_:y)s i=g y s i;g _ _ _=\"REJECT\\n\"}\n</code>\n</pre>\n", "senID": 0}, {"text": ["EDIT: Does not correctly implement the output for no-transition rejection."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Line-broken version and variable guide:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n -- r: run FSM\n-- f: fsm definition as lines\n-- z: initial state\n\n-- g: loop function\n-- t: transition table\n-- s: current state\n-- i: current input\n-- k: rest of input\n\n-- q: transition table match state\n-- j: transition table match input\n-- p: transition table next state\n-- y: tail of transition table\n\nmain=interact$r.lines;\nr f=g t z$last f where{\n(z:_):t=map words f;\ng _ s\"\"|s&lt;\"[\"=\"ACCEPT\\n\";\ng([q,j,p]:_)s(i:k)|i:s==j++q=s++' ':i:\" -&gt; \"++p++'\\n':g t p k;\ng(_:y)s i=g y s i;\ng _ _ _=\"REJECT\\n\"}\n</code>\n</pre>\n", "senID": 3}, {"text": ["I got the s&lt;\"[\" technique from MtnViewMark's solution; the rest is my own design.", "Notable characteristics:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "s&lt;\"[\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "The input is left as junk in the transition table. This is OK as long as the input does not contain two spaces; but note that the transition rule format is arguably unfriendly to transitioning on the space character anyway.", "tag": "none", "senID": 5}, {"text": "Stepping through the input string and searching the transition table are the same function.", "tag": "none", "senID": 6}, {"text": "Both REJECT cases are handled by the same fallthrough.", "tag": "none", "senID": 7}]}], [{"text": ["Common Lisp - 725"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Common Lisp - 725", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n (defun split (string)\n  (loop for i = 0 then (1+ j)\n     as j = (position #\\Space string :start i)\n     collect (subseq string i j)\n     while j))\n\n(defun do-fsm ()\n  (let* ((lines (loop for l = (read-line *standard-input* nil)\n      until (not l)\n     collect (split l)))\n  (cur (caar lines))\n  (transitions (subseq lines 1 (- (length lines) 1))))\n    (if (or (loop for c across (caar (last lines))\n      do (format t \"~a ~a\" cur c)\n        when (not (loop for tr in transitions\n       when (and (equal cur (car tr))\n          (equal c (char (cadr tr) 0)))\n       return (progn (format t \" -&gt; ~a~%\"\n        (setq cur (caddr tr)))\n       t)\n         ))\n        return t)\n     (lower-case-p (char cur 0)))\n (format t \"~%REJECT~%\")\n (format t \"ACCEPT~%\"))))\n</code>\n</pre>\n", "senID": 1}, {"text": ["No real attempt to minimize the code -- Common Lisp pays a heavy penalty in the required input processing, so I don't think there's much chance of this solution winning :-) "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Ruby \u2014 183"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n h={}\nr=$&lt;.read\nt=s=r.split[0]\ni=r[-1]==\"\n\"?\"\":r.split[-1]\nr.scan(/(\\S+) (.) (.+)/){|a,b,c|h[[a,b]]=c}\ni.chars{|c|puts s+\" #{c} -&gt; #{s=h[[s,c]]}\"}\nputs s&amp;&amp;s[/^[A-Z]/]?\"ACCEPT\":\"REJECT\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Really, strange output specification.", "Here how my works: http://ideone.com/cxweL"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://ideone.com/cxweL", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://ideone.com/cxweL"}]}], [{"text": ["Rexx 205 characters"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["(This answer went through few edits as I initially just posted some code for general interest and then decided to actually post a real solution)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here's a Rexx version to give people a taste for that less known lanugage.", "Rexx http://en.wikipedia.org/wiki/REXX is an interpreted language used in IBM's VM/CMS mainframe operating system and later in IBM OS/2 (and I believe there was an Amiga variant).", "It's a very expressive language and an amazing general purpose/\"scripting\" language."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://en.wikipedia.org/wiki/REXX", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/REXX"}]}, {"code": "<pre>\n<code>\n Parse pull i .\nd.='~'\nDo until l='';Parse pull o l d.o.l;End\nDo j=1 to LENGTH(o)\nt=SUBSTR(o,j,1);p=i t;i=d.i.t\nIf i=d. then Do;Say p;Leave;End\nSay p '-&gt;' i\nEnd\nSay WORD('ACCEPT REJECT',c2d(left(i,1))%32-1)\n</code>\n</pre>\n", "senID": 3}, {"text": ["This can be run with the Regina Rexx interpreter."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Regina Rexx", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://regina-rexx.sourceforge.net/"}]}, {"text": ["Handling the incorrect transition scenario with its unique output and also testing for uppercase is a bit expensive."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Code from some older edits below for people interested in the Rexx syntax, those aren't 100% compliant with the output requirements but are functional (all code in this answer works with the samples I pasted below but the code above handles the other required corners):"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Older short version:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n Parse pull i .\nDo until l = \"\"; Parse pull o l d; t.o.l = d; End\nDo j=1 to LENGTH(o); t=substr(o,j,1); Say i t \"-&gt;\" t.i.t; i=t.i.t; End\nIf LEFT(i,1)='S' then Say 'ACCEPT'; else say 'REJECT'\n</code>\n</pre>\n", "senID": 8}, {"text": ["Longer version:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n Parse pull initial . /* Rexx has a powerful built in string parser, this takes the first word into initial */\n\nDo until letter = \"\" /* This style of do loops is a bit unusual, note how it doesn't matter that letter isn't defined yet */\n  Parse pull origin letter destination /* Here we parse the inpt line into three words */\n  transition.origin.letter = destination /* Rexx has a very powerful notion of associative containers/dictionaries, many years pre-Python */\nEnd\n\n/* Now we take the last line and iterate over the transitions */\nDo i = 1 to LENGTH(origin) \n  t = substr(origin, i, 1) /* This is the actual letter using Rexx's string functions */\n  Say initial t \"-&gt;\" transition.initial.t /* Say is like print */\n  initial = transition.initial.t /* Perform the transition */\nEnd\n\n/* check for uppercase in the current state */\nif left(initial, 1) = 'S' then Say 'ACCEPT'; else say 'REJECT'\n</code>\n</pre>\n", "senID": 10}, {"text": ["Sample in/out:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n S1 s2\nS1 0 s2\n0\nS1 0 -&gt; s2\nREJECT\n\nS1 s2\nS1 0 s2\nS1 1 S1\ns2 0 S1\ns2 1 s2\n1001010\nS1 1 -&gt; S1\nS1 0 -&gt; s2\ns2 0 -&gt; S1\nS1 1 -&gt; S1\nS1 0 -&gt; s2\ns2 1 -&gt; s2\ns2 0 -&gt; S1\nACCEPT\n</code>\n</pre>\n", "senID": 12}], [{"text": ["Lua, 356"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Lua, 356", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Takes any nonspace characters for states, and any non-space one characters for transition letters.", "Though it seems not shortest, I'll post it any way.", "Could save 25 chars printing tabs instead of spaces."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Readable version:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n i=io.read\np=print\nS={}\ni():gsub(\"(%S+)\",function (a) f=f or a S[a]={} end )\nl=i\"*a\"\nfor a,t,d in l:gmatch\"(%S+) (%S) (%S+)\"do\n    S[a][t]=d\nend\nI=l:match\"(%S+)%s$\"or\"\" -- fixes empty input\nfunction F(a,i)\n    t=I:sub(i,i)\n    if t==\"\"then\n        p\"ACCEPT\"\n    elseif S[a][t] then\n        p((\"%s %s -&gt; %s\"):format(a,t, S[a][t]))\n        return F( S[a][t],i+1)\n    else\n        if t~=\"\"then p(a..\" \"..t)end p'REJECT'\n    end\nend\nF(f,1)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Golfed version + in- an output."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n i=io.read p=print S={}i():gsub('(%S+)',function(a)f=f or a S[a]={}end)l=i'*a'for a,t,d in l:gmatch\"(%S+) (%S) (%S+)\"do S[a][t]=d end I=l:match'(%S+)%s$'or''function F(a,i)t=I:sub(i,i)if t==\"\"and a:match'^%u'then p'ACCEPT'elseif S[a][t]then p(('%s %s -&gt; %s'):format(a,t,S[a][t]))return F(S[a][t],i+1)else if t~=''then p(a..\" \"..t)end p'REJECT'end end F(f,1)\n-- input --\nA B C   \nA B B\nA C C\nA A A\nB A A \nB B B\nB C C\nC A A \nC B B\nC C C\nAABCCBCBAX\n-- output --\n\nA A -&gt; A\nA A -&gt; A\nA B -&gt; B\nB C -&gt; C\nC C -&gt; C\nC B -&gt; B\nB C -&gt; C\nC B -&gt; B\nB A -&gt; A\nREJECT\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\ndeclare -A a\nread s x\nwhile read f m t&&[ $m ];do a[$f $m]=$t;done\nfor((i=0;i-${#f};i++))do b=\"$s ${f:i:1}\";s=${a[$b]};echo $b -\\> $s;done\n[ \"$s\" = \"${s,}\" ]&&echo; REJECT||echo ACCEPT\n</pre>\n", "senID": 0}, {"text": ["Note that this does actually require bash - POSIX sh doesn't have associative arrays or the C-style for syntax (and probably doesn't have all the parameter expansions used either, although I haven't checked)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit: alternatively, for the exact same length,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\ndeclare -A a\nread s x\nwhile read f m t&&[ $m ];do a[$f $m]=$t;done\nwhile [ $f ];do b=\"$s ${f:i:1}\";f=${f:1};s=${a[$b]};echo $b -\\> $s;done\n[ \"$s\" = \"${s,}\" ]&&echo; REJECT||echo ACCEPT\n</pre>\n", "senID": 3}], [{"text": ["MIXAL 898 characters"], "childNum": 1, "tag": "h2", "senID": 0, "childList": [{"text": "MIXAL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/MIXAL"}]}, {"code": "<pre>\n<code>\n ORIG    3910\nA   ALF ACCEP\n    ALF T    \n    ORIG    3940\nR   ALF REJEC\n    ALF T    \n    ORIG    3970\nO   CON 0\n    ALF -&gt;   \n    ORIG    3000\nS   ENT6    0\nT   IN  0,6(19)\n    INC6    14\n    JBUS    *(19)\n    LDA -14,6\n    JANZ    T\n    LDA -28,6(9)\n    DECA    30\n    JAZ C\n    DECA    1\n    JANZ    B\nC   LD2 0(10)\n    ENT4    -28,6\n    ENT5    9\nD   JMP G\n    ENT3    0\nF   INC3    14\n    LD1 0,3(10)\n    DEC2    0,1\n    J2Z M\n    INC2    0,1\n    DEC3    -28,6\n    J3NN    U\n    INC3    -28,6\n    JMP F\nM   INC2    0,1\n    LD1 0,3(36)\n    DECA    0,1\n    JAZ H\n    INCA    0,1\n    JMP F\nH   INCA    0,1\n    ST2 O(10)\n    LD2 1,3(10)\n    STA O(36)\n    ST2 O+1(37)\n    OUT O(18)\n    JBUS    *(18)\n    JMP D\n    HLT\nE   LD1 0(10)\n    DEC1    0,2\n    J1Z B\nU   OUT R(18)\n    JBUS    *(18)\n    HLT\nB   OUT A(18)\n    JBUS    *(18)\n    HLT\nG   STJ K\n    ST5 *+1(36)\n    LDA 0,4\n    JAZ E\n    DECA    30\n    JAZ I\n    DECA    1\n    JANZ    W\n    INCA    1\nI   INCA    30\n    DEC5    45\n    J5NN    J\n    INC5    54\n    JMP K\nJ   INC4    1\n    ENT5    9\nK   JMP *\nW   ST2 O(10)\n    INCA    31\n    STA O(36)\n    STZ O+1\n    OUT O(18)\n    JBUS    *(18)\n    JMP B\n    END S\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Python (2.6) ~ 269 characters."], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Probably still room for improvement, hints welcome.", "Handles specifications I think."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import sys;a=sys.stdin.readlines();b=a[0].split()\nf=b[0];d=dict((x,{})for x in b);s=''\nfor x,y,z in map(str.split,a[1:-1]):d[x][y]=z\nfor g in a[-1]:\n try:s+=f+' '+g;f=d[f][g];s+=' -&gt; '+f+'\\n'\n except:s+='\\n';break\nprint s+(\"REJECT\",\"ACCEPT\")[ord(f[0])&lt;90 and g in d[f]]\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n r=...\np=print\nM={}\ns=r:match('(%a%d)')\nfor i,n,o in r:gmatch('(%a%d)%s(%d)%s(%a%d)')do\nM[i]=M[i]or{}\nM[i][n]=o\nend\nfor c in r:match('%d%d+'):gmatch('(%d)')do\nz=s\ns=M[z][c]\np(z,c,'-&gt;',s)\nend\np(s==s:upper()and'ACCEPT'or'REJECT')\n</code>\n</pre>\n", "senID": 0}, {"text": ["check running version on codepad old version"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "codepad", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://codepad.org/qZ6CeCmu"}, {"href": "http://codepad.org/PEdQkG9M", "text": "old version", "childNum": 1, "tag": "a", "childList": [{"text": "old version", "tag": "strike"}]}, {"text": "old version", "childNum": 0, "tag": "strike", "childList": []}]}], [{"text": ["C# -453375353345 characters"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "C# -453375353345 characters", "childNum": 3, "tag": "strong", "pos": 0, "childList": [{"text": "453", "tag": "strike"}, {"text": "375", "tag": "strike"}, {"text": "353", "tag": "strike"}]}, {"text": "453", "childNum": 0, "tag": "strike", "childList": []}, {"text": "375", "childNum": 0, "tag": "strike", "childList": []}, {"text": "353", "childNum": 0, "tag": "strike", "childList": []}]}, {"text": ["This doesn't win (not that anyone should have expected it to), but it was fun to write anyway.", "I kept the leading spaces and newlines for legibility:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n using System;\nclass P\n{\n  static void Main()\n  {\n    string c,k=\"\";\n    var t=new string[99999][];\n    int p=-1,n;\n    while((c=Console.ReadLine())!=\"\")\n      t[++p]=c.Split(' ');\n\n    c=t[0][0];\n    foreach(var d in t[p][0]){\n      k+=c+' '+d;\n      for(n=1;n&lt;p;n++)\n        if(c==t[n][0]&amp;&amp;d==t[n][1][0])\n      {\n        c=t[n][2];\n        k+=\" -&gt; \"+c;\n        break;\n      }\n      k+=\"\\n\";\n      if(n==p){\n        c=\"~\";\n        break;\n      }\n    }\n    Console.Write(k+(c[0]&gt;'Z'?\"REJECT\":\"ACCEPT\"));\n  }\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["In my last update I was able to save 22 characters by assuming a practical limit to the number of input rows (namely 99,999).", "In the worst case, you'd need to up that to the Int32 max of 2,147,483,647 which would add 5 chars.", "My machine doesn't like the idea of an array that long though..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["An example of the execution:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;FSM.exe\nS1 s2\nS1 0 s2\nS1 1 S1\ns2 0 S1\ns2 1 s2\n1001010\n\nS1 1 -&gt; S1\nS1 0 -&gt; s2\ns2 0 -&gt; S1\nS1 1 -&gt; S1\nS1 0 -&gt; s2\ns2 1 -&gt; s2\ns2 0 -&gt; S1\nACCEPT\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Not bad for immutable golf I think.", "I didn't do very good on the course today though."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n open System\nlet f,p,a=Array.fold,printf,Map.add\nlet l=Console.In.ReadToEnd().Split '\\n'\nlet e,s=l.Length,l.[0].Split ' '\nlet t,w=Map.ofList[for q in s-&gt;q,Map.empty],[|\"ACCEPT\";\"REJECT\"|]\nlet m=f(fun t (r:String)-&gt;let s=r.Split ' 'in a s.[0](t.[s.[0]]|&gt;a s.[1].[0]s.[2])t)t l.[1..e-2]\ntry let r=l.[e-1].ToCharArray()|&gt;f(fun s c-&gt;p\"%s %c \"s c;let n=m.[s].[c]in p\"-&gt; %s\\n\"n;n)s.[0]in p\"%s\"w.[int r.[0]/97]with|_-&gt;p\"%s\"w.[1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["33 lines for un-golfed F#.", "I'll update again in a bit after I've golfed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n open System\n\nlet input = Console.In.ReadToEnd()\n//let input = \"S1 s2\\nS1 0 s2\\nS1 1 S1\\ns2 0 S1\\ns2 1 s2\\n1001010\"\nlet lines = input.Split '\\n'\nlet length = lines.Length\nlet states = lines.[0].Split ' '\n\nlet stateMap = Map.ofList [for state in states -&gt; (state, Map.empty)]\n\nlet folder stateMap (line:String) =\n    let s = line.Split ' '\n    stateMap |&gt; Map.add s.[0] (stateMap.[s.[0]] |&gt; Map.add s.[1].[0] s.[2])\n\nlet machine = Array.fold folder stateMap lines.[1 .. (length-2)]\n\nlet stateMachine state char =\n    printf \"%s %c \" state char\n    let newState = machine.[state].[char]\n    printfn \"-&gt; %s\" newState\n    newState\n\ntry\n    let result = \n        lines.[length-1].ToCharArray()\n        |&gt; Array.fold stateMachine states.[0]\n\n    if Char.IsUpper result.[0] then\n        printf \"ACCEPT\"\n    else\n        printf \"REJECT\"\nwith\n    | _ -&gt; printf \"REJECT\"\n</code>\n</pre>\n", "senID": 3}]]