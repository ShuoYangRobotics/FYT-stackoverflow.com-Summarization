[[{"code": "<pre>\n<code>\n import a_module\nprint a_module.__file__\n</code>\n</pre>\n", "senID": 0}, {"text": ["Will actually give you the path to the .pyc file that was loaded, at least on Mac OS X.", "So I guess you can do"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import os\npath = os.path.dirname(amodule.__file__)\n</code>\n</pre>\n", "senID": 2}, {"text": ["To get the directory to look for changes."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This was trivial."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Each module has a __file__ variable that shows its relative path from where you are right now."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__file__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Therefore, getting a directory for the module to notify it is simple as:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n os.path.dirname(__file__)\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n import os\npath = os.path.abspath(__file__)\ndir_path = os.path.dirname(path)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["As the other answers have said, the best way to do this is with __file__ (demonstrated again below).", "However, there is an important caveat, which is that __file__ does NOT exist if you are running the module on its own  (i.e.", "as __main__)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__file__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__file__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__main__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["For example, say you have two files (both of which are on your PYTHONPATH):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #/path1/foo.py\nimport bar\nprint bar.__file__\n</code>\n</pre>\n", "senID": 2}, {"text": ["and"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n #/path2/bar.py\nimport os\nprint os.getcwd()\nprint __file__\n</code>\n</pre>\n", "senID": 4}, {"text": ["Running foo.py will give the output:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n /path1        # \"import bar\" causes the line \"print os.getcwd()\" to run\n/path2/bar.py # then \"print __file__\" runs\n/path2/bar.py # then the import statement finishes and \"print bar.__file__\" runs\n</code>\n</pre>\n", "senID": 6}, {"text": ["HOWEVER if you try to run bar.py on its own, you will get:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n /path2                              # \"print os.getcwd()\" still works fine\nTraceback (most recent call last):  # but __file__ doesn't exist if bar.py is running as main\n  File \"/path2/bar.py\", line 3, in &lt;module&gt;\n    print __file__\nNameError: name '__file__' is not defined\n</code>\n</pre>\n", "senID": 8}, {"text": ["Hope this helps.", "This caveat cost me a lot of time and confusion while testing the other solutions presented."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}]]