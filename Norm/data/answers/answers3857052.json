[[{"text": ["Congratulations, you have just discovered the importance of I/O buffering!", ":-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The disk appears to be faster, because it is highly buffered: all Python's write() calls are returning before anything is actually written to physical disk.", "(The OS does this later, combining many thousands of individual writes into a big, efficient chunks."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "appears", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "write()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The terminal, on the other hand, does little or no buffering: each individual print / write(line) waits for the full write (i.e.", "display to output device) to complete."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "print", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "write(line)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "full", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["To make the comparison fair, you must make the file test use the same output buffering as the terminal, which you can do by modifying your example to:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n fp = file(\"out.txt\", \"w\", 1)   # line-buffered, like stdout\n[...]\nfor x in range(lineCount):\n    fp.write(line)\n    os.fsync(fp.fileno())      # wait for the write to actually complete\n</code>\n</pre>\n", "senID": 4}, {"text": ["I ran your file writing test on my machine, and with buffering, it also 0.05s here for 100,000 lines."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["However, with the above modifications to write unbuffered, it takes 40 seconds to write only 1,000 lines to disk.", "I gave up waiting for 100,000 lines to write, but extrapolating from the previous, it would take over an hour."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "over an hour", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["That puts the terminal's 11 seconds into perspective, doesn't it?"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["So to answer your original question, writing to a terminal is actually blazingly fast, all things considered, and there's not a lot of room to make it much faster (but individual terminals do vary in how much work they do; see Russ's comment to this answer)."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["(You could add more write buffering, like with disk I/O, but then you wouldn't see what was written to your terminal until after the buffer gets flushed.", "It's a trade-off: interactivity versus bulk efficiency."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["Thanks for all the comments!", "I've ended up answering it myself with your help.", "It feels dirty answering your own question, though."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Question 1: Why is printing to stdout slow?"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Question 1: Why is printing to stdout slow?", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Answer: Printing to stdout is not inherently slow.", "It is the terminal you work with that is slow.", "And it has pretty much zero to do with I/O buffering on the application side (eg: python file buffering).", "See below."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Answer:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["Question 2: Can it be sped up?"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Question 2: Can it be sped up?", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Answer: Yes it can, but seemingly not from the program side (the side doing the 'printing' to stdout).", "To speed it up, use a faster different terminal emulator."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Answer:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Explanation..."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I tried a self-described 'lightweight' terminal program called wterm and got significantly better results.", "Below is the output of my test script (at the bottom of the question) when running in wterm at 1920x1200 in on the same system where the basic print option took 12s using gnome-terminal:"], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "wterm", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "significantly", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "wterm", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n-----\ntiming summary (100k lines each)\n-----\nprint                         : 0.261 s\nwrite to file (+fsync)        : 0.110 s\nprint with stdout = /dev/null : 0.050 s\n</pre>\n", "senID": 7}, {"text": ["0.26s is MUCH better than 12s!", "I don't know whether wterm is more intelligent about how it renders to screen along the lines of how I was suggesting (render the 'visible' tail at a reasonable frame rate), or whether it just \"does less\" than gnome-terminal.", "For the purposes of my question I've got the answer, though.", "gnome-terminal is slow."], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "wterm", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "gnome-terminal", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "gnome-terminal", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So - If you have a long running script that you feel is slow and it spews massive amounts of text to stdout... try a different terminal and see if it is any better!"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Note that I pretty much randomly pulled wterm from the ubuntu/debian repositories.", "This link might be the same terminal, but I'm not sure.", "I did not test any other terminal emulators."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "wterm", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "This link", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://sourceforge.net/projects/wterm/"}]}, {"text": ["Update: Because I had to scratch the itch, I tested a whole pile of other terminal emulators with the same script and full screen (1920x1200).", "My manually collected stats are here:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\nwterm           0.3s\naterm           0.3s\nrxvt            0.3s\nmrxvt           0.4s\nkonsole         0.6s\nyakuake         0.7s\nlxterminal        7s\nxterm             9s\ngnome-terminal   12s\nxfce4-terminal   12s\nvala-terminal    18s\nxvt              48s\n</pre>\n", "senID": 12}, {"text": ["The recorded times are manually collected, but they were pretty consistent.", "I recorded the best(ish) value.", "YMMV, obviously."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["As a bonus, it was an interesting tour of some of the various terminal emulators available out there!", "I'm amazed my first 'alternate' test turned out to be the best of the bunch."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}], [{"text": ["Your redirection probably does nothing as programs can determine whether their output FD points to a tty."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's likely that stdout is line buffered when pointing to a terminal (the same as C's stdout stream behaviour)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "stdout", "tag": "a", "pos": 0, "childList": [{"text": "stdout", "tag": "code"}], "childNum": 1, "href": "http://linux.die.net/man/3/stdout"}, {"text": "stdout", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["As an amusing experiment, try piping the output to cat."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "cat", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I've tried my own amusing experiment, and here are the results."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n $ python test.py 2&gt;foo\n...\n$ cat foo\n-----\ntiming summary (100k lines each)\n-----\nprint                         : 6.040 s\nwrite to file                 : 0.122 s\nprint with stdout = /dev/null : 0.121 s\n\n$ python test.py 2&gt;foo |cat\n...\n$ cat foo\n-----\ntiming summary (100k lines each)\n-----\nprint                         : 1.024 s\nwrite to file                 : 0.131 s\nprint with stdout = /dev/null : 0.122 s\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Printing to the terminal is going to be slow.", "Unfortunately short of writing a new terminal implementation I can't really see how you'd speed this up significantly. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I can't talk about the technical details because I don't know them, but this doesn't surprise me: the terminal was not designed for printing lots of data like this.", "Indeed, you even provide a link to a load of GUI stuff that it has to do every time you want to print something!", "Notice that if you call the script with pythonw instead, it does not take 15 seconds; this is entirely a GUI issue.", "Redirect stdout to a file to avoid this:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "pythonw", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "stdout", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n import contextlib, io\n@contextlib.contextmanager\ndef redirect_stdout(stream):\n    import sys\n    sys.stdout = stream\n    yield\n    sys.stdout = sys.__stdout__\n\noutput = io.StringIO\nwith redirect_stdout(output):\n    ...\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In addition to the output probably defaulting to a line-buffered mode, output to a terminal is also causing your data to flow into a terminal and serial line with a maximum throughput, or a pseudo-terminal and a separate process that is handling a display event loop, rendering characters from some font, moving display bits to implement a scrolling display.", "The latter scenario is probably spread over multiple processes (e.g.", "telnet server/client, terminal app, X11 display server) so there are context switching and latency issues too."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]