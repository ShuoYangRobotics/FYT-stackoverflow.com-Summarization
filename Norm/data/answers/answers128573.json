[[{"text": ["Reading the Python 2.2 release notes, I find the following."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python 2.2 release", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/download/releases/2.2/descrintro/#property"}]}, {"text": ["NOTE: The below method doesn't actually work for setters, only getters."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "NOTE: The below method doesn't actually work for setters, only getters.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Therefore, I believe the prescribed solution is to create a ClassProperty as a subclass of property."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class ClassProperty(property):\n    def __get__(self, cls, owner):\n        return self.fget.__get__(None, owner)()\n\nclass foo(object):\n    _var=5\n    def getvar(cls):\n        return cls._var\n    getvar=classmethod(getvar)\n    def setvar(cls,value):\n        cls._var=value\n    setvar=classmethod(setvar)\n    var=ClassProperty(getvar,setvar)\n\nassert foo.getvar() == 5\nfoo.setvar(4)\nassert foo.getvar() == 4\nassert foo.var == 4\nfoo.var = 3\nassert foo.var == 3\n</code>\n</pre>\n", "senID": 3}, {"text": ["However, the setters don't actually work:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n foo.var = 4\nassert foo.var == foo._var # raises AssertionError\n</code>\n</pre>\n", "senID": 5}, {"text": ["foo._var is unchanged, you've simply overwritten the property with a new value."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "foo._var", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You can also use ClassProperty as a decorator:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "ClassProperty", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Foo(object):\n    _var = 5\n\n    @ClassProperty\n    @classmethod\n    def var(cls):\n        return cls._var\n\n    @var.setter\n    @classmethod\n    def var(cls, value):\n        cls._var = value\n\nassert foo.var == 5\n</code>\n</pre>\n", "senID": 8}], [{"text": ["There is no reasonable way to make this \"class property\" system to work in Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is one unreasonable way to make it work.", "You can certainly make it more seamless with increasing amounts of metaclass magic."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class ClassProperty(object):\n    def __init__(self, getter, setter):\n        self.getter = getter\n        self.setter = setter\n    def __get__(self, cls, owner):\n        return getattr(cls, self.getter)()\n    def __set__(self, cls, value):\n        getattr(cls, self.setter)(value)\n\nclass MetaFoo(type):\n    var = ClassProperty('getvar', 'setvar')\n\nclass Foo(object):\n    __metaclass__ = MetaFoo\n    _var = 5\n    @classmethod\n    def getvar(cls):\n        print \"Getting var =\", cls._var\n        return cls._var\n    @classmethod\n    def setvar(cls, value):\n        print \"Setting var =\", value\n        cls._var = value\n\nx = Foo.var\nprint \"Foo.var = \", x\nFoo.var = 42\nx = Foo.var\nprint \"Foo.var = \", x\n</code>\n</pre>\n", "senID": 2}, {"text": ["The knot of the issue is that properties are what Python calls \"descriptors\".", "There is no short and easy way to explain how this sort of metaprogramming works, so I must point you to the descriptor howto."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "descriptor howto", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://users.rcn.com/python/download/Descriptor.htm"}]}, {"text": ["You only ever need to understand this sort of things if you are implementing a fairly advanced framework.", "Like a transparent object persistence or RPC system, or a kind of domain-specific language."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["However, in a comment to a previous answer, you say that you "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["It seems to me, what you really want is an Observer design pattern."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Observer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Observer_pattern"}]}], [{"text": ["Do you have access to at least one instance of the class?", "I can think of a way to do it then:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MyClass (object):\n    __var = None\n\n    def _set_var (self, value):\n        type (self).__var = value\n\n    def _get_var (self):\n        return self.__var\n\n    var = property (_get_var, _set_var)\n\na = MyClass ()\nb = MyClass ()\na.var = \"foo\"\nprint b.var\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Setting it only on the meta class doesn't help if you want to access the class property via an instantiated object, in this case you need to install a normal property on the object as well (which dispatches to the class property).", "I think the following is a bit more clear:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n\nclass classproperty(property):\n    def __get__(self, obj, type_):\n        return self.fget.__get__(None, type_)()\n\n    def __set__(self, obj, value):\n        cls = type(obj)\n        return self.fset.__get__(None, cls)(value)\n\nclass A (object):\n\n    _foo = 1\n\n    @classproperty\n    @classmethod\n    def foo(cls):\n        return cls._foo\n\n    @foo.setter\n    @classmethod\n    def foo(cls, value):\n        cls.foo = value\n\na = A()\n\nprint a.foo\n\nb = A()\n\nprint b.foo\n\nb.foo = 5\n\nprint a.foo\n\nA.foo = 10\n\nprint b.foo\n\nprint A.foo\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's my suggestion.", "Don't use class methods.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Seriously.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["What's the reason for using class methods in this case?", "Why not have an ordinary object of an ordinary class?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "hr", "senID": 3}, {"text": ["If you simply want to change the value, a property isn't really very helpful is it?", "Just set the attribute value and be done with it."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["A property should only be used if there's something to conceal -- something that might change in a future implementation.  "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Maybe your example is way stripped down, and there is some hellish calculation you've left off.", "But it doesn't look like the property adds significant value."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["The Java-influenced \"privacy\" techniques (in Python, attribute names that begin with _) aren't really very helpful.", "Private from whom?", "The point of private is a little nebulous when you have the source (as you do in Python."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["The Java-influenced EJB-style getters and setters (often done as properties in Python) are there to facilitate Java's primitive introspection as well as to pass muster with the static language compiler.", "All those getters and setters aren't as helpful in Python."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Half a solution, __set__ on the class does not work, still.", "The solution is a custom property class implementing both a property and a staticmethod"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class ClassProperty(object):\n    def __init__(self, fget, fset):\n        self.fget = fget\n        self.fset = fset\n\n    def __get__(self, instance, owner):\n        return self.fget()\n\n    def __set__(self, instance, value):\n        self.fset(value)\n\nclass Foo(object):\n    _bar = 1\n    def get_bar():\n        print 'getting'\n        return Foo._bar\n\n    def set_bar(value):\n        print 'setting'\n        Foo._bar = value\n\n    bar = ClassProperty(get_bar, set_bar)\n\nf = Foo()\n#__get__ works\nf.bar\nFoo.bar\n\nf.bar = 2\nFoo.bar = 3 #__set__ does not\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Give this a try, it gets the job done without having to change/add a lot of existing code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class foo(object):\n...     _var = 5\n...     def getvar(cls):\n...         return cls._var\n...     getvar = classmethod(getvar)\n...     def setvar(cls, value):\n...         cls._var = value\n...     setvar = classmethod(setvar)\n...     var = property(lambda self: self.getvar(), lambda self, val: self.setvar(val))\n...\n&gt;&gt;&gt; f = foo()\n&gt;&gt;&gt; f.var\n5\n&gt;&gt;&gt; f.var = 3\n&gt;&gt;&gt; f.var\n3\n</code>\n</pre>\n", "senID": 1}, {"text": ["The property function needs two callable arguments.", "give them lambda wrappers (which it passes the instance as its first argument) and all is well."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "property", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "callable", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["A property is created on a class but affects an instance.", "So if you want a classmethod property, create the property on the metaclass."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class foo(object):\n    _var = 5\n    class __metaclass__(type):\n    \tpass\n    @classmethod\n    def getvar(cls):\n    \treturn cls._var\n    @classmethod\n    def setvar(cls, value):\n    \tcls._var = value\n\n\n&gt;&gt;&gt; foo.__metaclass__.var = property(foo.getvar.im_func, foo.setvar.im_func)\n&gt;&gt;&gt; foo.var\n5\n&gt;&gt;&gt; foo.var = 3\n&gt;&gt;&gt; foo.var\n3\n</code>\n</pre>\n", "senID": 1}, {"text": ["But since you're using a metaclass anyway, it will read better if you just move the classmethods in there."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class foo(object):\n    _var = 5\n    class __metaclass__(type):\n    \t@property\n    \tdef var(cls):\n    \t\treturn cls._var\n    \t@var.setter\n    \tdef var(cls, value):\n    \t\tcls._var = value\n\n\n&gt;&gt;&gt; foo.var\n5\n&gt;&gt;&gt; foo.var = 3\n&gt;&gt;&gt; foo.var\n3\n</code>\n</pre>\n", "senID": 3}]]