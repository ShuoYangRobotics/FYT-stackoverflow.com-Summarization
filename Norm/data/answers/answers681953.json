[[{"text": ["Apart from the question whether class decorators are the right solution to your problem:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["in Python 2.6 and higher, there are class decorators with the @-syntax, so you can write:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n @addID\nclass Foo:\n    pass\n</code>\n</pre>\n", "senID": 2}, {"text": ["in older versions, you can do it another way:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Foo:\n    pass\n\nFoo = addID(Foo)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Note however that this works the same as for function decorators, and that the decorator should return the new (or modified original) class, which is not what you're doing in the example.", "The addID decorator would look like this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def addID(original_class):\n    orig_init = original_class.__init__\n    # make copy of original __init__, so we can call it without recursion\n\n    def __init__(self, id, *args, **kws):\n        self.__id = id\n        self.getId = getId\n        orig_init(self, *args, **kws) # call the original __init__\n\n    original_class.__init__ = __init__ # set the class' __init__ to the new one\n    return original_class\n</code>\n</pre>\n", "senID": 6}, {"text": ["You could then use the appropriate syntax for your python version as described above."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["But I agree with others that inheritance is better suited if you want to override __init__."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["UPDATE: changed to correct the issue Gerald mentioned in comment."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["I would second the notion that you may wish to consider a subclass instead of the approach you've outlined.", "However, not knowing your specific scenario, YMMV :-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What you're thinking of is a metaclass.", "The __new__ function in a metaclass is passed the full proposed definition of the class, which it can then rewrite before the class is created.", "You can, at that time, sub out the constructor for a new one."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__new__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def substitute_init(self, id, *args, **kwargs):\n    pass\n\nclass FooMeta(type):\n\n    def __new__(cls, name, bases, attrs):\n        attrs['__init__'] = substitute_init\n        return super(FooMeta, cls).__new__(cls, name, bases, attrs)\n\nclass Foo(object):\n\n    __metaclass__ = FooMeta\n\n    def __init__(self, value1):\n        pass\n</code>\n</pre>\n", "senID": 3}, {"text": ["Replacing the constructor is perhaps a bit dramatic, but the language does provide support for this kind of deep introspection and dynamic modification."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["That's not a good practice and there is no mechanism to do that because of that.", "The right way to accomplish what you want is inheritance."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Take a look into the class documentation."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "class documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html#inheritance"}]}, {"text": ["A little example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Employee(object):\n\n    def __init__(self, age, sex, siblings=0):\n        self.age = age\n        self.sex = sex    \n        self.siblings = siblings\n\n    def born_on(self):    \n        today = datetime.date.today()\n\n        return today - datetime.timedelta(days=self.age*365)\n\n\nclass Boss(Employee):    \n    def __init__(self, age, sex, siblings=0, bonus=0):\n        self.bonus = bonus\n        Employee.__init__(self, age, sex, siblings)\n</code>\n</pre>\n", "senID": 3}, {"text": ["This way Boss has everything Employee has, with also his own __init__ method and own members."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "Employee", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 1, "tag": "strong", "childList": [{"text": "__init__", "tag": "code"}]}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}]]