[[{"text": ["The *args and **kwargs ist a common idiom to allow arbitrary number of arguments to functions as described in the section more on defining functions in the  the python documentation."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "more on defining functions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/tutorial/controlflow.html#more-on-defining-functions"}]}, {"text": ["The *args will give you all funtion parameters a a list:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n In [1]: def foo(*args):\n   ...:     for a in args:\n   ...:         print a\n   ...:         \n   ...:         \n\nIn [2]: foo(1)\n1\n\n\nIn [4]: foo(1,2,3)\n1\n2\n3\n</code>\n</pre>\n", "senID": 2}, {"text": ["The **kwargs will give you all \nkeyword arguments except for those corresponding to a formal parameter as a dictionary."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "keyword arguments", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n In [5]: def bar(**kwargs):\n   ...:     for a in kwargs:\n   ...:         print a, kwargs[a]\n   ...:         \n   ...:         \n\nIn [6]: bar(name=\"one\", age=27)\nage 27\nname one\n</code>\n</pre>\n", "senID": 4}, {"text": ["Both idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def foo(kind, *args, **kwargs):\n   pass\n</code>\n</pre>\n", "senID": 6}, {"text": ["An other usage of the *l idiom is to unpack argument lists when calling a function."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "unpack argument lists", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n In [9]: def foo(bar, lee):\n   ...:     print bar, lee\n   ...:     \n   ...:     \n\nIn [10]: l = [1,2]\n\nIn [11]: foo(*l)\n1 2\n</code>\n</pre>\n", "senID": 8}, {"text": ["In the upcoming python 3.0 it will be possible to use *l on the left side of an assignment (Extended Iterable Unpacking):"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Extended Iterable Unpacking", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3132/"}]}, {"code": "<pre>\n<code>\n first, *rest = [1,2,3,4]\nfirst, *l, last = [1,2,3,4]\n</code>\n</pre>\n", "senID": 10}], [{"text": ["It's also worth noting that you can use * and ** when calling functions as well.", "This is a shortcut that allows you to pass multiple arguments to a function directly using either a list/tuple or a dictionary.", "For example, if you have the following function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo(x,y,z):\n    print \"x=\" + str(x)\n    print \"y=\" + str(y)\n    print \"z=\" + str(z)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can do things like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; mylist = [1,2,3]\n&gt;&gt;&gt; foo(*mylist)\nx=1\ny=2\nz=3\n\n&gt;&gt;&gt; mydict = {'x':4,'y':5,'z':6}\n&gt;&gt;&gt; foo(**mydict)\nx=4\ny=5\nz=6\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The single * means that there can be any number of extra positional arguments.", "foo() can be invoked like foo(1,2,3,4,5).", "In the body of foo() param2 is a sequence containing 2-5."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "foo()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "foo(1,2,3,4,5)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The double ** means there can be any number of extra named parameters.", "bar() can be invoked like bar(1, a=2, b=3).", "In the body of bar() param2 is a dictionary containing {'a':2, 'b':3 }"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "bar()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "bar(1, a=2, b=3)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["With the following code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def foo(param1, *param2):\n    print param1\n    print param2\n\ndef bar(param1, **param2):\n    print param1\n    print param2\n\nfoo(1,2,3,4,5)\nbar(1,a=2,b=3)\n</code>\n</pre>\n", "senID": 3}, {"text": ["the output is"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n 1\n(2, 3, 4, 5)\n1\n{'a': 2, 'b': 3}\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Also, it's a good idea not to populate your interface signatures with these conventions.", "It's okay to use them for private implementations, but for a public API, they can often obscure meaning.", "They're basically advertising, \"Hey, this function/method accepts anything!", "\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Peter's answer is exceptional.", "I will only add that Python does not have function overloading like other languages, so to achieve the same effect, a programmer can use the *args and **kwargs conventions to allow the same function to be called with different inputs, similar to overloading."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["From the Python documentation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I have to disagree when you say it's rare it's the only answer to a problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Actually, I have one problem right now which I believe could be very well solved using **kwargs.", "I have a class constructor which takes 20 parameters, 16 of them optional.", "Using **kwargs, I'd have only 5 parameters on the function definition and the effect would be the same with a much more organized code."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Of course, it's important that, when it's used, the user comments the whereabouts of the code to let possible readers know the reason this solution is being used."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I second Zac, from a style and clarity point of view, using named function/method arguments is superior.", "If you use pyLint, it will yell at you whenever you get tempted by the dark-side of \"* magic\".", "That's not to say it's not necessary and/or useful, it's just that (in my opinion) it's rare it's the only answer to your problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]