[[{"text": ["Maybe this sounds too simple, but it works.", "Randomly distribute values to all the cells until only two are empty.", "Test for adjacency of all values.", "Compute the average the percent of successful casts vs. all casts until the variance drops to within an acceptable margin."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The risk goes to zero and the that which is at risk is only a little runtime."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This isn't an answer, just a contribution to the discussion which is too long for a comment."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["tl; dr; Any algorithm which boils down to, \"Compute the possibilities and count them,\" such as Eric Lippert's or a brute force approach won't work for @Yaroslav's goal of q &lt;= 100 and n &lt;= 18."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "q &lt;= 100", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "n &lt;= 18", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Let's first think about a single n x 1 column.", "How many valid numberings of this one column exist?", "For the first cell we can pick between q numbers.", "Since we can't repeat vertically, we can pick between q - 1 numbers for the second cell, and therefore q - 1 numbers for the third cell, and so on.", "For q == 100 and n == 18 that means there are q * (q - 1) ^ (n - 1) = 100 * 99 ^ 17 valid colorings which is very roughly 10 ^ 36."], "childNum": 8, "tag": "p", "senID": 2, "childList": [{"text": "n x 1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "q", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "q - 1", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "q - 1", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "q == 100", "childNum": 0, "tag": "code", "childList": []}, {"text": "n == 18", "childNum": 0, "tag": "code", "childList": []}, {"text": "q * (q - 1) ^ (n - 1) = 100 * 99 ^ 17", "childNum": 0, "tag": "code", "childList": []}, {"text": "10 ^ 36", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Now consider any two valid columns (call them the bread columns) separated by a buffer column (call it the mustard column).", "Here is a trivial algorithm to find a valid set of values for the mustard column when q &gt;= 4.", "Start at the top cell of the mustard column.", "We only have to worry about the adjacent cells of the bread columns which have at most 2 unique values.", "Pick any third number for the mustard column.", "Consider the second cell of the mustard column.", "We must consider the previous mustard cell and the 2 adjacent bread cells with a total of at most 3 unique values.", "Pick the 4th value.", "Continue to fill out the mustard column."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "q &gt;= 4", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["We have at most 2 columns containing a hard coded cell of 0.", "Using mustard columns, we can therefore make at least 6 bread columns, each with about 10 ^ 36 solutions for a total of at least 10 ^ 216 valid solutions, give or take an order of magnitude for rounding errors."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "10 ^ 36", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "10 ^ 216", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["There are, according to Wikipedia, about 10 ^ 80 atoms in the universe."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "10 ^ 80", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Therefore, be cleverer."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I'm the author.", "Not 41, just 3 embarrassingly parallelizable CPU hours.", "I've counted symmetries.", "For n=10 there are only 675 really distinct pairs of (i,j) and (k,l).", "My program needs ~ 16 seconds per each."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "counted", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "https://github.com/infnty/stuff/raw/master/grid-colorings/orbits.py"}]}], [{"text": ["I'm building a contribution based on the contribution to the discussion by Dave Aaron Smith."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Let's not consider for now the last two constraints ((i,j) and (k,l))."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "(i,j)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(k,l)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["With only one column (nx1) the solution is q * (q - 1) ^ (n - 1)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "q * (q - 1) ^ (n - 1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["\nHow many choices for a second column ?", "(q-1) for the top cell (1,2) but then q-1 or q-2 for the cell (2,2) if (1,2)/(2,1) have or not the same color."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "hr", "pos": 0, "childList": []}, {"text": "(q-1)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "q-1", "childNum": 0, "tag": "code", "childList": []}, {"text": "q-2", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Same thing for (3,2) : q-1 or q-2 solutions."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "q-1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "q-2", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["We can see we have a binary tree of possibilities and we need to sum over that tree.", "Let's assume left child is always \"same color on top and at left\" and right child is \"different colors\"."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["By computing over the tree the number of possibilities for the left column to create a such configurations and the number of possibilities for the new cells we are coloring we would count the number of possibilities for coloring two columns."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["But let's now consider the probability distribution foe the coloring of the second column : if we want to iterate the process, we need to have an uniform distribution on the second column, it would be like the first one never existed and among all coloring of the first two column we could say things like 1/q of them have color 0 in the top cell of second column."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "1/q", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Without an uniform distribution it would be impossible."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["The problem : is the distribution uniform ?"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Answer :\nWe would have obtain the same number of solution by building first the second column them the first one and then the third one.", "The distribution of the second column is uniform in that case so it also is in the first case."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Answer :", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["We can now apply the same \"tree idea\" to count the number of possibilities for the third column."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["I will try to develop on that and build a general formula (since the tree is of size 2^n we don't want to explicitly explore it)."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["A few observations which might help other answerers as well:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Point 3 makes the whole program O( n2(n2-3) ) as a minimum, and also suggests that you will need something reasonably efficient for each pair of zeroes as simply writing 100 million lines without any computation will take a while.", "For reference, at a second per line, that is 1x108s ~ 3 years, or 3 months on a 12-core box."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "2", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}, {"text": "2", "childNum": 0, "tag": "sup", "pos": 1, "childList": []}, {"text": "8", "childNum": 0, "tag": "sup", "childList": []}]}, {"text": ["I suspect that there is an elegant answer given a pair of zeroes, but I'm not sure that there is an analytic solution to it.", "Given that you can do it with 2 or 3 colours depending on the positions of the zeroes, you could split the map into a series of regions, each of which uses only 2 or 3 colours, and then it's just the number of different combinations of 2 or 3 in q (qC2 or qC3) for each region times the number of regions, times the number of ways of splitting the map."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]