[[{"text": ["difflib can do it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "difflib", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/difflib.html"}]}, {"text": ["Example from the docs:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; get_close_matches('appel', ['ape', 'apple', 'peach', 'puppy'])\n['apple', 'ape']\n&gt;&gt;&gt; import keyword\n&gt;&gt;&gt; get_close_matches('wheel', keyword.kwlist)\n['while']\n&gt;&gt;&gt; get_close_matches('apple', keyword.kwlist)\n[]\n&gt;&gt;&gt; get_close_matches('accept', keyword.kwlist)\n['except']\n</code>\n</pre>\n", "senID": 2}, {"text": ["Check it out.", "It has other functions that can help you build something custom."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Levenshtein Python extension and C library."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://code.google.com/p/pylevenshtein/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://code.google.com/p/pylevenshtein/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/pylevenshtein/"}]}, {"text": ["The Levenshtein Python C extension module contains functions for fast\ncomputation of\n- Levenshtein (edit) distance, and edit operations\n- string similarity\n- approximate median strings, and generally string averaging\n- string sequence and set similarity\nIt supports both normal and Unicode strings."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import Levenshtein\n\n&gt;&gt;&gt; help(Levenshtein.ratio)\n\nratio(...)\n    Compute similarity of two strings.\n\n    ratio(string1, string2)\n\n    The similarity is a number between 0 and 1, it's usually equal or\n    somewhat higher than difflib.SequenceMatcher.ratio(), becuase it's\n    based on real minimal edit distance.\n\n    Examples:\n    &gt;&gt;&gt; ratio('Hello world!', 'Holly grail!')\n    0.58333333333333337\n    &gt;&gt;&gt; ratio('Brian', 'Jesus')\n    0.0\n\n&gt;&gt;&gt; help(Levenshtein.distance)\n\ndistance(...)\n    Compute absolute Levenshtein distance of two strings.\n\n    distance(string1, string2)\n\n    Examples (it's hard to spell Levenshtein correctly):\n    &gt;&gt;&gt; distance('Levenshtein', 'Lenvinsten')\n    4\n    &gt;&gt;&gt; distance('Levenshtein', 'Levensthein')\n    2\n    &gt;&gt;&gt; distance('Levenshtein', 'Levenshten')\n    1\n    &gt;&gt;&gt; distance('Levenshtein', 'Levenshtein')\n    0\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I like nosklo's answer; another method is the Damerau-Levenshtein distance:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "nosklo's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/682367/good-python-modules-for-fuzzy-string-comparison/682398#682398"}, {"href": "http://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein%5Fdistance", "text": "Damerau-Levenshtein distance", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["\"In information theory and computer science, Damerau\u2013Levenshtein distance is a 'distance' (string metric) between two strings, i.e., finite sequence of symbols, given by counting the minimum number of operations needed to transform one string into the other, where an operation is defined as an insertion, deletion, or substitution of a single character, or a transposition of two characters."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["An implementation in Python from Wikibooks:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Wikibooks", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikibooks.org/wiki/Algorithm%5Fimplementation/Strings/Levenshtein%5Fdistance"}]}, {"code": "<pre>\n<code>\n def lev(a, b):\n    if not a: return len(b)\n    if not b: return len(a)\n    return min(lev(a[1:], b[1:])+(a[0] != b[0]), \\\n    lev(a[1:], b)+1, lev(a, b[1:])+1)\n</code>\n</pre>\n", "senID": 3}, {"text": ["More from Wikibooks, \nthis gives you the length of the longest common substring (LCS):"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "longest common substring (LCS)", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikibooks.org/wiki/Algorithm%5Fimplementation/Strings/Longest%5Fcommon%5Fsubstring"}]}, {"code": "<pre>\n<code>\n def LCSubstr_len(S, T):\n    m = len(S); n = len(T)\n    L = [[0] * (n+1) for i in xrange(m+1)]\n    lcs = 0\n    for i in xrange(m):\n        for j in xrange(n):\n            if S[i] == T[j]:\n                L[i+1][j+1] = L[i][j] + 1\n                lcs = max(lcs, L[i+1][j+1])\n    return lcs\n</code>\n</pre>\n", "senID": 5}], [{"text": ["There is also Google's own google-diff-match-patch (\"Currently available in Java, JavaScript, C++ and Python\"). "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "google-diff-match-patch", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/google-diff-match-patch/"}]}, {"text": ["(Can't comment on it, since I have only used python's difflib myself)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["As nosklo said, use the difflib module from the Python standard library.  "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "nosklo", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/682367/good-python-modules-for-fuzzy-string-comparison/682398#682398"}, {"href": "http://docs.python.org/library/difflib.html", "text": "difflib", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["The difflib module can return a measure of the sequences' similarity using the ratio() method of a SequenceMatcher() object.", "The similarity is returned as a float in the range 0.0 to 1.0."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "ratio()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "SequenceMatcher()", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/difflib.html#sequencematcher-objects"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import difflib\n\n&gt;&gt;&gt; difflib.SequenceMatcher(None, 'abcde', 'abcde').ratio()\n1.0\n\n&gt;&gt;&gt; difflib.SequenceMatcher(None, 'abcde', 'zbcde').ratio()\n0.80000000000000004\n\n&gt;&gt;&gt; difflib.SequenceMatcher(None, 'abcde', 'zyzzy').ratio()\n0.0\n</code>\n</pre>\n", "senID": 2}], [{"text": ["While not specific to Python, here is a question about similar string algorithms:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://stackoverflow.com/questions/451884/similar-string-algorithm/451910#451910"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://stackoverflow.com/questions/451884/similar-string-algorithm/451910#451910", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/451884/similar-string-algorithm/451910#451910"}]}], [{"text": ["Here's a python script for computing longest comon substring of two words--may ned tweaking to work for multi-word phrases: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["def lcs(word1, word2):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n w1 = set(word1[i:j] for i in range(0, len(word1))\n         for j in range(1, len(word1) + 1))\n\nw2 = set(word2[i:j] for i in range(0, len(word2))\n         for j in range(1, len(word2) + 1))\n\ncommon_subs     = w1.intersection(w2)\n\nsorted_cmn_subs = sorted([\n    (len(str), str) for str in list(common_subs)\n    ])\n\nreturn sorted_cmn_subs.pop()[1]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Another alternative would be to use the recently released package FuzzyWuzzy.", "The various functions supported by the package are also described in this blogpost."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "FuzzyWuzzy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://github.com/seatgeek/fuzzywuzzy"}, {"text": "this blogpost", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://seatgeek.com/blog/dev/fuzzywuzzy-fuzzy-string-matching-in-python"}]}]]