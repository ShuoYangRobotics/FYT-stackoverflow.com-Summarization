[[{"text": ["Iterables"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["To understand what yield does, you must understand what generators are.", "And before generators come iterables.", "When you create a list, you can read its items one by one, and it's called iteration :"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; mylist = [1, 2, 3]\n&gt;&gt;&gt; for i in mylist :\n...    print(i)\n1\n2\n3\n</code>\n</pre>\n", "senID": 2}, {"text": ["Mylist is an iterable.", "When you use a comprehension list, you create a list, and so an iterable :"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; mylist = [x*x for x in range(3)]\n&gt;&gt;&gt; for i in mylist :\n...    print(i)\n0\n1\n4\n</code>\n</pre>\n", "senID": 4}, {"text": ["Everything you can use \"for... in...\" on is an iterable : lists, strings, files...", "These iterables are handy because you can read them as much as you wish, but you store all the values in memory and it's not always what you want when you have a lot of values."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Generators"], "childNum": 0, "tag": "h2", "senID": 6, "childList": []}, {"text": ["Generators are iterables, but you can only read them once.", "It's because they do not store all the values in memory, they generate the values on the fly :"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "you can only read them once", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "they generate the values on the fly", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; mygenerator = (x*x for x in range(3))\n&gt;&gt;&gt; for i in mygenerator :\n...    print(i)\n0\n1\n4\n</code>\n</pre>\n", "senID": 8}, {"text": ["It just the same except you used () instead of [].", "BUT, you can not perform for i in mygenerator a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1 and ends calculating 4, one by one."], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "for i in mygenerator", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Yield"], "childNum": 0, "tag": "h2", "senID": 10, "childList": []}, {"text": ["Yield is a keyword that is used like return, except the function will return a generator."], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "Yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def createGenerator() :\n...    mylist = range(3)\n...    for i in mylist :\n...        yield i*i\n...\n&gt;&gt;&gt; mygenerator = createGenerator() # create a generator\n&gt;&gt;&gt; print(mygenerator) # mygenerator is an object !\n&lt;generator object createGenerator at 0xb7555c34&gt;\n&gt;&gt;&gt; for i in mygenerator:\n...     print(i)\n0\n1\n4\n</code>\n</pre>\n", "senID": 12}, {"text": ["Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["To master yield, you must understand that when you call the function, the code you have written in the function body does not run.", "The function only returns the generator object, this is bit tricky :-)"], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "when you call the function, the code you have written in the function body does not run.", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Then, your code will be run each time the for uses the generator."], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Now the hard part :"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["The first time your function will run, it will run from the beginning until it hits yield, then it'll return the first value of the loop.", "Then, each other call will run the loop you have written in the function one more time, and return the next value, until there is no value to return."], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The generator is considered empty once the function runs but does not hit yield anymore.", "It can be because the loop had come to ends, or because you do not satisfy a \"if/else\" anymore."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["Your code explained"], "childNum": 0, "tag": "h2", "senID": 19, "childList": []}, {"text": ["Generator:"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"code": "<pre>\n<code>\n # Here you create the method of the node object that will return the generator\ndef node._get_child_candidates(self, distance, min_dist, max_dist):\n\n  # Here is the code that will be called each time you use the generator object :\n\n  # If there is still a child of the node object on its left\n  # AND if distance is ok, return the next child\n  if self._leftchild and distance - max_dist &lt; self._median:\n                yield self._leftchild\n\n  # If there is still a child of the node object on its right\n  # AND if distance is ok, return the next child\n  if self._rightchild and distance + max_dist &gt;= self._median:\n                yield self._rightchild\n\n  # If the function arrives here, the generator will be considered empty\n  # there is no more than two values : the left and the right children\n</code>\n</pre>\n", "senID": 21}, {"text": ["Caller:    "], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"code": "<pre>\n<code>\n # Create an empty list and a list with the current object reference\nresult, candidates = list(), [self]\n\n# Loop on candidates (they contain only one element at the beginning) \nwhile candidates:\n\n    # Get the last candidate and remove it from the list\n    node = candidates.pop()\n\n    # Get the distance between obj and the candidate\n    distance = node._get_dist(obj)\n\n    # If distance is ok, then you can fill the result\n    if distance &lt;= max_dist and distance &gt;= min_dist:\n        result.extend(node._values)\n\n    # Add the children of the candidate in the candidates list \n    # so the loop will keep running until it will have looked\n    # at all the children of the children of the children, etc. of the candidate\n    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))\n\nreturn result\n</code>\n</pre>\n", "senID": 23}, {"text": ["This code contains several smart parts :"], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["The loop iterate on a list but the list expends while the loop is been iterated :-) It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop.", "In this case, candidates.extend(node._get_child_candidates(distance, min_dist, max_dist)) exhausts all the values of the generator, but while keep creating new generators object which will produce different values from the previous ones since it's not applied on the same node. "], "childNum": 2, "tag": "p", "senID": 25, "childList": [{"text": "candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "while", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The extend() method is a list object method that expects an iterable and adds its values to the list. "], "childNum": 1, "tag": "p", "senID": 26, "childList": [{"text": "extend()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}, {"text": ["Usually we pass a list to it :"], "childNum": 0, "tag": "p", "senID": 27, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [1, 2]\n&gt;&gt;&gt; b = [3, 4]\n&gt;&gt;&gt; a.extend(b)\n&gt;&gt;&gt; print(a)\n[1, 2, 3, 4]\n</code>\n</pre>\n", "senID": 28}, {"text": ["But in your code it gets a generator, which is good because :"], "childNum": 0, "tag": "p", "senID": 29, "childList": []}, {"text": ["And it works because Python does not care if the argument of a method is a list or not.", "Python expects iterables so it will work with strings, lists, tuples and generators !", "This is called duck typing and is one of the reason why Python is so cool.", "But this is another story, for another question..."], "childNum": 0, "tag": "p", "senID": 30, "childList": []}, {"text": ["You can stop here, or read a little bit to see a advanced use of generator :"], "childNum": 0, "tag": "p", "senID": 31, "childList": []}, {"text": ["Controlling a generator exhaustion"], "childNum": 0, "tag": "h2", "senID": 32, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class Bank(): # let's create a bank, building ATMs\n...    crisis = False\n...    def create_atm(self) :\n...        while not self.crisis :\n...            yield \"$100\"\n&gt;&gt;&gt; hsbc = Bank() # when everything is fine, you can get as much money as you want from an ATM\n&gt;&gt;&gt; corner_street_atm = hsbc.create_atm()\n&gt;&gt;&gt; print(corner_street_atm.next())\n$100\n&gt;&gt;&gt; print(corner_street_atm.next())\n$100\n&gt;&gt;&gt; print([corner_street_atm.next() for cash in range(5)])\n['$100', '$100', '$100', '$100', '$100']\n&gt;&gt;&gt; hsbc.crisis = True # crisis is coming, no more money !\n&gt;&gt;&gt; print(corner_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; wall_street_atm = hsbc.create_atm() # but it's true even for newly built ATM\n&gt;&gt;&gt; print(wall_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; hsbc.crisis = False # trouble is, when the crisis is off, the ATM are still empty...\n&gt;&gt;&gt; print(corner_street_atm.next())\n&lt;type 'exceptions.StopIteration'&gt;\n&gt;&gt;&gt; brand_new_atm = hsbc.create_atm() # but if you build new ones, you're in business again !\n&gt;&gt;&gt; for cash in brand_new_atm :\n...    print cash\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n...\n</code>\n</pre>\n", "senID": 33}, {"text": ["It can be useful for various things like controlling access to a resource."], "childNum": 0, "tag": "p", "senID": 34, "childList": []}, {"text": ["Itertools, your best friend"], "childNum": 0, "tag": "h2", "senID": 35, "childList": []}, {"text": ["The itertools module contains special functions to manipulate iterables.", "Ever wish to duplicate a generator ?", "Chain a two generators ?", "Groups values in nested list with a one liner ?", "Map / Zip without creating another list ?"], "childNum": 0, "tag": "p", "senID": 36, "childList": []}, {"text": ["Then just import itertools."], "childNum": 1, "tag": "p", "senID": 37, "childList": [{"text": "import itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["An example ?", "Let's see the possible orders of arrival for a 4 horses race:"], "childNum": 0, "tag": "p", "senID": 38, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; horses = [1, 2, 3, 4]\n&gt;&gt;&gt; races = itertools.permutations(horses)\n&gt;&gt;&gt; print(races)\n&lt;itertools.permutations object at 0xb754f1dc&gt;\n&gt;&gt;&gt; print(list(itertools.permutations(horses)))\n[(1, 2, 3, 4),\n (1, 2, 4, 3),\n (1, 3, 2, 4),\n (1, 3, 4, 2),\n (1, 4, 2, 3),\n (1, 4, 3, 2),\n (2, 1, 3, 4),\n (2, 1, 4, 3),\n (2, 3, 1, 4),\n (2, 3, 4, 1),\n (2, 4, 1, 3),\n (2, 4, 3, 1),\n (3, 1, 2, 4),\n (3, 1, 4, 2),\n (3, 2, 1, 4),\n (3, 2, 4, 1),\n (3, 4, 1, 2),\n (3, 4, 2, 1),\n (4, 1, 2, 3),\n (4, 1, 3, 2),\n (4, 2, 1, 3),\n (4, 2, 3, 1),\n (4, 3, 1, 2),\n (4, 3, 2, 1)]\n</code>\n</pre>\n", "senID": 39}, {"text": ["Understanding the inner mechanisms of iteration"], "childNum": 0, "tag": "h2", "senID": 40, "childList": []}, {"text": ["Iteration is a process implying iterables (implementing the __iter__() method) and iterators (implementing the __next__() method).", "Iterables are any objects you can get an iterator from.", "Iterators are objects that let you iterate on iterables."], "childNum": 2, "tag": "p", "senID": 41, "childList": [{"text": "__iter__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__next__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["More about it in in this article about how does the for loop work."], "childNum": 1, "tag": "p", "senID": 42, "childList": [{"text": "how does the for loop work", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/python-for-statement.htm"}]}, {"text": ["Oh, and if you liked this answer, you'll probably like my explanation for decorators and metaclasses."], "childNum": 2, "tag": "p", "senID": 43, "childList": [{"text": "decorators", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/739654/understanding-python-decorators#1594484"}, {"href": "http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python/6581949#6581949", "text": "metaclasses", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Shortcut to Grokking yield"], "childNum": 1, "tag": "h2", "senID": 0, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["When you see a function with yield statements, apply this easy trick to understand what will happen:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This trick may give you an idea of the logic behind the function, but what actually happens with yield is significantly different that what happens in the list based approach.", "In many cases the yield approach will be a lot more memory efficient and faster too.", "In other cases this trick will get you stuck in an infinite loop, even though the original function works just fine.", "Read on to learn more..."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Don't confuse your Iterables, Iterators and Generators"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"text": ["First, the iterator protocol - when you write"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "iterator protocol", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for x in mylist:\n    ...loop body...\n</code>\n</pre>\n", "senID": 5}, {"text": ["Python performs the following two steps:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["The truth is Python performs the above two steps anytime it wants to loop over the contents of an object - so it could be a for loop, but it could also be code like otherlist.extend(mylist) (where otherlist is a Python list)."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "loop over", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "otherlist.extend(mylist)", "childNum": 0, "tag": "code", "childList": []}, {"text": "otherlist", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Here mylist is an iterable because it implements the iterator protocol.", "In a user defined class, you can implement the __iter__() method to make instances of your class iterable.", "This method should return an iterator.", "An iterator is an object with a next() method.", "It is possible to implement both __iter__() and next() on the same class, and have __iter__() return self.", "This will work for simple cases, but not when you want two iterators looping over the same object at the same time."], "childNum": 9, "tag": "p", "senID": 8, "childList": [{"text": "mylist", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "iterable", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "__iter__()", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "iterator", "childNum": 0, "tag": "em", "pos": 5, "childList": []}, {"text": "next()", "childNum": 0, "tag": "code", "childList": []}, {"text": "__iter__()", "childNum": 0, "tag": "code", "childList": []}, {"text": "next()", "childNum": 0, "tag": "code", "childList": []}, {"text": "__iter__()", "childNum": 0, "tag": "code", "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So that's the iterator protocol, many objects implement this protocol:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Note that a for loop doesn't know what kind of object it's dealing with - it just follows the iterator protocol, and is happy to get item after item as it calls next().", "Built-in lists return their items one by one, dictionaries return the keys one by one, files return the lines one by one, etc.", "And generators return... well that's where yield comes in:"], "childNum": 5, "tag": "p", "senID": 10, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "next()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "keys", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "lines", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "yield", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n def f123():\n    yield 1\n    yield 2\n    yield 3\n\nfor item in f():\n    print item\n</code>\n</pre>\n", "senID": 11}, {"text": ["Instead of yield statements, if you had three return statements in f123() only the first would get executed, and the function would exit.", "But f123() is no ordinary function.", "When f123() is called, it does not return any of the values in the yield statements!", "It returns a generator object.", "Also, the function does not really exit - it goes into a suspended state.", "When the for loop tries to loop over the generator object, the function resumes from its suspended state, runs until the next yield statement and returns that as the next item.", "This happens until the function exits, at which point the generator raises StopIteration, and the loop exits. "], "childNum": 9, "tag": "p", "senID": 12, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "f123()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "f123()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "f123()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "does not", "childNum": 0, "tag": "em", "pos": 4, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": 5, "childList": []}, {"text": "yield", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "StopIteration", "childNum": 0, "tag": "code", "pos": 6, "childList": []}]}, {"text": ["So the generator object is sort of like an adapter - at one end it exhibits the iterator protocol, by exposing __iter__() and next() methods to keep the for loop happy.", "At the other end however, it runs the function just enough to get the next value out of it, and puts it back in suspended mode."], "childNum": 3, "tag": "p", "senID": 13, "childList": [{"text": "__iter__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "next()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Why Use Generators?"], "childNum": 0, "tag": "h2", "senID": 14, "childList": []}, {"text": ["Usually you can write code that doesn't use generators but implements the same logic.", "One option is to use the temporary list 'trick' I mentioned before.", "That will not work in all cases, for e.g.", "if you have infinite loops, or it may make inefficient use of memory when you have a really long list.", "The other approach is to implement a new iterable class SomethingIter that keeps state in instance members and performs the next logical step in it's next() method.", "Depending on the logic, the code inside the next() method may end up looking very complex and be prone to bugs.", "Here generators provide a clean and easy solution."], "childNum": 3, "tag": "p", "senID": 15, "childList": [{"text": "SomethingIter", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "next()", "childNum": 0, "tag": "code", "pos": 5, "childList": []}, {"text": "next()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Think of it this way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["An iterator is just a fancy sounding term for an object that has a next() method.", "So a yield-ed function ends up being something like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Original version:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def some_function():\n    for i in xrange(4):\n        yield i\n\nfor i in some_function():\n    print i\n</code>\n</pre>\n", "senID": 3}, {"text": ["This is basically what the python interpreter does with the above code:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class it:\n    def __init__(self):\n        self.count = -1  #start at -1 so that we get 0 when we add 1 below\n    def next(self):    #the next method will be called implicitly by the for loop\n        self.count += 1\n        if self.count &lt; 4:\n            return self.count\n        else:\n           #a StopIteration exception is raised to signal that the iterator is done.  This is caught implicitly by the for loop\n            raise StopIteration \n\ndef some_func():\n    return it()\n\nfor i in some_func():\n    print i\n</code>\n</pre>\n", "senID": 5}, {"text": ["For more insight as to what's happening behind the scenes, the for loop can be rewritten to this:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n iterator = some_func()\ntry:\n    while 1:\n        print iterator.next()\nexcept StopIteration:\n    pass\n</code>\n</pre>\n", "senID": 7}, {"text": ["Does that make more sense or just confuse you more?", ":)"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["EDIT: I should note that this IS an oversimplification for illustrative purposes.", ":)"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["EDIT 2: Forgot to throw the StopIteration exception"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "EDIT 2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["I feel like I post a link to this presentation every day:  David M. Beazly's Generator Tricks for Systems Programmers.", "If you're a Python programmer and you're not extremely familiar with generators, you should read this.", "It's a very clear explanation of what generators are, how they work, what the yield statement does, and it answers the question \"Do you really want to mess around with this obscure language feature?", "\"  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Generator Tricks for Systems Programmers", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/generators/"}]}, {"text": ["SPOILER ALERT.", "The answer is:  Yes.", "Yes, you do."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["yield is just like return.", "It returns whatever you tell it to.", "The only difference is that the next time you call the function, execution starts from the last call to the yield statement."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In the case of your code, the function get_child_candidates is acting like an iterator so that when you extend your list, it adds one element at a time to the new list."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["list.extend calls an iterator until it's exhausted.", "In the case of the code sample you posted, it would be much clearer to just return a tuple and append that to the list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["An example in plain language.", "I will provide a correspondence between high-level human concepts to low-level python concepts."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I want to operate on a sequence of numbers, but I don't want to bother my self with the creation of that sequence, I want only to focus on the operation I want to do.", "So, I do the following:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "I call you and tell you that I want a sequence of numbers which is produced in a specific way, and I let you know what the algorithm is.", "tag": "none", "senID": 2}, {"text": "Sometime later, I tell you, \"ok, get ready to tell me the sequence of numbers\".", "tag": "none", "senID": 3}, {"text": "I ask you, \"tell me the next number\", and you tell me the first number; after that, you wait for me to ask you for the next number. It's your job to remember where you were, what numbers you have already said, what is the next number. I don't care about the details.", "tag": "none", "senID": 4}, {"text": "\u2026 repeat previous step, until\u2026", "tag": "none", "senID": 5}, {"text": "eventually, you might come to an end. You don't tell me a number, you just shout, \"hold your horses! I'm done! No more numbers!\"", "tag": "none", "senID": 6}]}, {"text": ["This is what a generator does (a function that contains a yield); it starts executing, pauses whenever it does a yield, and when asked for a .next() value it continues from the point it was last.", "It fits perfectly by design with the iterator protocol of python, which describes how to sequentially request for values."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "yield", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": ".next()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The most famous user of the iterator protocol is the for command in python.", "So, whenever you do a:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for item in sequence:\n</code>\n</pre>\n", "senID": 9}, {"text": ["it doesn't matter if sequence is a list, a string, a dictionary or a generator object like described above; the result is the same: you read items off a sequence one by one."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "sequence", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "object", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Note that defining a function which contains a yield keyword is not the only way to create a generator; it's just the easiest way to create one."], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "def", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "yield", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For more accurate information, read about iterator types, the yield statement and generators in the Python documentation."], "childNum": 3, "tag": "p", "senID": 12, "childList": [{"text": "iterator types", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#iterator-types"}, {"href": "http://docs.python.org/reference/simple_stmts.html#yield", "text": "yield statement", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://docs.python.org/glossary.html#term-generator", "text": "generators", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["There's one extra thing to mention: a function that yields doesn't actually have to terminate.", "I've written code like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fib():\n    yield 1\n    yield 1\n    cur = 1\n    last = 1\n    while True:\n        cur, last = cur+last, cur\n        yield cur\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then I can use it in other code like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for f in fib():\n    if some_condition: break\n    coolfuncs(f);\n</code>\n</pre>\n", "senID": 3}, {"text": ["It really helps simplify some problems, and makes some things easier to work with. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["It's returning a generator.", "I'm not particularly familiar with Python, but I believe it's the same kind of thing as C#'s iterator blocks if you're familiar with those."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "C#'s iterator blocks", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://csharpindepth.com/Articles/Chapter11/StreamingAndIterators.aspx"}]}, {"text": ["There's an IBM article which explains it reasonably well (for Python) as far as I can see."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "IBM article", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ibm.com/developerworks/library/l-pycon.html"}]}, {"text": ["The key idea is that the compiler/interpreter/whatever does some trickery so that as far as the caller is concerned, they can keep calling next() and it will keep returning values - as if the generator method was paused.", "Now obviously you can't really \"pause\" a method, so the compiler builds a state machine for you to remember where you currently are and what the local variables etc look like.", "This is much easier than writing an iterator yourself."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "as if the generator method was paused", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["The yield keyword reduced to 2 simple facts:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In a nutshell: a generator is a lazy, incrementally-pending list, and yieldstatements allow you to use function notation to program the list values the generator should incrementally spit out."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "a generator is a lazy, incrementally-pending list", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "yieldstatements allow you to use function notation to program the list values", "childNum": 1, "tag": "strong", "childList": [{"text": "yield", "tag": "code"}]}, {"text": "yield", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n generator = myYieldingFunction(...)\nx = list(generator)\n\n   generator\n       v\n[x[0], ..., ???]\n\n         generator\n             v\n[x[0], x[1], ..., ???]\n\n               generator\n                   v\n[x[0], x[1], x[2], ..., ???]\n\n                       StopIteration exception\n[x[0], x[1], x[2]]     done\n\nlist==[x[0], x[1], x[2]]\n</code>\n</pre>\n", "senID": 2}, {"text": ["examples"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"text": ["Let's define a function makeRange that's just like python's range.", "Calling makeRange(n) RETURNS A GENERATOR:"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "makeRange", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "range", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "makeRange(n)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def makeRange(n):\n    # return &lt;generator object&gt;\n    i = 0\n    while i &lt; n:\n        yield i\n        i += 1\n\n&gt;&gt;&gt; makeRange(5)\n&lt;generator object makeRange at 0x19e4aa0&gt;\n</code>\n</pre>\n", "senID": 5}, {"text": ["All iterators can be converted to lists or sets by passing them into the constructor:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(makeRange(5))\n[0, 1, 2, 3, 4]\n</code>\n</pre>\n", "senID": 7}, {"text": ["An iterator is the last part of a list comprehension:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n #                  __ITERATOR__\n&gt;&gt;&gt; [x+10 for x in makeRange(5)]\n[10, 11, 12, 13, 14]\n</code>\n</pre>\n", "senID": 9}, {"text": ["This is how the iteration protocol works, i.e.", "what is going on when you do list(makeRange(5)).", "This is what I describe earlier as a \"lazy, incremental list\":"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "list(makeRange(5))", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x=iter(range(5))\n&gt;&gt;&gt; next(x)\n0\n&gt;&gt;&gt; next(x)\n1\n&gt;&gt;&gt; next(x)\n2\n&gt;&gt;&gt; next(x)\n3\n&gt;&gt;&gt; next(x)\n4\n&gt;&gt;&gt; next(x)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nStopIteration\n</code>\n</pre>\n", "senID": 11}, {"text": ["To get a better feel for generators, you can play around with the itertools module (some of which are infinitely long lazy lists)."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["From The Python Reference Manual:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "The Python Reference Manual", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/ref/yield.html"}]}, {"text": ["Do you have the entire generator function listed?", "It doesn't look complete."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["My guess from the incomplete code is that you set the parameters, and every time you call the function it returns the next child node that fits the parameters.", "The yield allows you to easily write a function (generator function) that is called repeatedly to gather 'chunks' of information, by 'pausing' the function, returning the value, and then continuing the function where it was paused when next called."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]