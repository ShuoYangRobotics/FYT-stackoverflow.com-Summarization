[[{"text": ["Asserts should be used to test conditions that should never happen.", "The purpose is to crash early in the case of a corrupt program state."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "should never happen", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Exceptions should be used for errors that can conceivably happen, and you should almost always create your own Exception classes."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "hr", "senID": 2}, {"text": ["For example, if you're writing a function to read from a configuration file into a dict, improper formatting in the file should raise a ConfigurationSyntaxError, while you can assert that you're not about to return None."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ConfigurationSyntaxError", "childNum": 0, "tag": "code", "childList": []}, {"text": "assert", "childNum": 0, "tag": "code", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}, {"tag": "hr", "senID": 4}, {"text": ["In your example, if x is a value set via a user interface or from an external source, an exception is best."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If x is only set by your own code in the same program, go with an assertion."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["To be able to automatically throw an error when x become less than zero throughout the function.", "You can use class descriptors.", "Here is an example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "class descriptors", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html#implementing-descriptors"}]}, {"code": "<pre>\n<code>\n class ZeroException(Exception):\n    pass\n\nclass variable(object):\n    def __init__(self, value=0):\n        self.__x = value\n\n    def __set__(self, obj, value):\n        if value &lt; 0:\n            raise ZeroException('x is less than zero')\n\n        self.__x  = value\n\n    def __get__(self, obj, objType):\n        return self.__x\n\nclass MyClass(object):\n    x = variable()\n\n&gt;&gt;&gt; m = MyClass()\n&gt;&gt;&gt; m.x = 10\n&gt;&gt;&gt; m.x -= 20\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"my.py\", line 7, in __set__\n    raise ZeroException('x is less than zero')\nZeroException: x is less than zero\n</code>\n</pre>\n", "senID": 1}], [{"text": ["\"assert\" statements are removed when the compilation is optimized.", "So, yes, there are both performance and functional differences."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\"assert\" statements are removed when the compilation is optimized", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If you use assert to implement application functionality, then optimize the deployment to production, you will be plagued by \"but-it-works-in-dev\" defects."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "assert", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["See PYTHONOPTIMIZE and -O -OO"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "PYTHONOPTIMIZE", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/using/cmdline.html?highlight=optimization%20options#envvar-PYTHONOPTIMIZE"}, {"href": "http://docs.python.org/using/cmdline.html?highlight=optimization%20options#miscellaneous-options", "text": "-O -OO", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["The only thing that's really wrong with this approach is that it's hard to make a very descriptive exception using assert statements.", "If you're looking for the simpler syntax, remember you can also do something like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "can", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class XLessThanZeroException(Exception):\n    pass\n\ndef CheckX(x):\n    if x &lt; 0:\n        raise XLessThanZeroException()\n\ndef foo(x):\n    CheckX(x)\n    #do stuff here\n</code>\n</pre>\n", "senID": 1}, {"text": ["Another problem is that using assert for normal condition-checking is that it makes it difficult to disable the debugging asserts using the -O flag."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["In addition to the other answers, asserts themselves throw exceptions, but only AssertionErrors.", "From a utilitarian standpoint, assertions aren't suitable for when you need fine grain control over which exceptions you catch."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Well, in general I agree with Deestan, but sometimes we need to test our custom exception, so..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["we can take unittest's method assertRaises, rewrite it a little - and get asserNotRaises method:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class SomeTest(unittest.TestCase):\n    def assertNotRaises(self, excClass, callableObj, *args, **kwargs):\n        try:\n            callableObj(*args, **kwargs)\n        except excClass:\n            if hasattr(excClass,'__name__'): excName = excClass.__name__\n            else: excName = str(excClass)\n            raise self.failureException, \"%s raised\" % excName\n</code>\n</pre>\n", "senID": 2}, {"text": ["And then to use it like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n self.assertNotRaises(MyException, my_callable)\n</code>\n</pre>\n", "senID": 4}]]