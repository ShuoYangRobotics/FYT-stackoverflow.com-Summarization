[[{"text": ["See Function Definitions in the Language Reference."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Function Definitions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/ref/function.html"}]}, {"text": ["Also, see Function Calls."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Function Calls", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/ref/calls.html#calls"}]}], [{"text": ["I only have one thing to add that wasn't clear from the other answers (for completeness's sake)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You may also use the stars when calling the function.", "For example, say you have code like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo(*args):\n...     print(args)\n...\n&gt;&gt;&gt; l = [1,2,3,4,5]\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can pass the list l into foo like so..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; foo(*l)\n(1, 2, 3, 4, 5)\n</code>\n</pre>\n", "senID": 4}, {"text": ["You can do the same for dictionaries..."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo(**argd):\n...     print(argd)\n...\n&gt;&gt;&gt; d = {'a' : 'b', 'c' : 'd'}\n&gt;&gt;&gt; foo(**d)\n{'a': 'b', 'c': 'd'}\n</code>\n</pre>\n", "senID": 6}], [{"text": ["A single star means that the variable 'a' will be a tuple of extra parameters that were supplied to the function.", "The double star means the variable 'kw' will be a variable-size dictionary of extra parameters that were supplied with keywords."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Although the actual behavior is spec'd out, it still sometimes can be very non-intuitive.", "Writing some sample functions and calling them with various parameter styles may help you understand what is allowed and what the results are."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def f0(a)\ndef f1(*a)\ndef f2(**a)\ndef f3(*a, **b)\netc...\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I find * useful when writing a function that takes another callback function as a parameter:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def some_function(parm1, parm2, callback, *callback_args):\n    a = 1\n    b = 2\n    ...\n    callback(a, b, *callback_args)\n    ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["That way, callers can pass in arbitrary extra parameters that will be passed through to their callback function.", "The nice thing is that the callback function can use normal function parameters.", "That is, it doesn't need to use the * syntax at all.", "Here's an example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def my_callback_function(a, b, x, y, z):\n    ...\n\nx = 5\ny = 6\nz = 7\n\nsome_function('parm1', 'parm2', my_callback_function, x, y, z)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Of course, closures provide another way of doing the same thing without requiring you to pass x, y, and z through some_function() and into my_callback_function()."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["All of the above answers were perfectly clear and complete, but just for the record I'd like to confirm that the meaning of * and ** in python has absolutely no similarity with the meaning of similar-looking operators in C. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["They are called the argument-unpacking and keyword-argument-unpacking operators."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]