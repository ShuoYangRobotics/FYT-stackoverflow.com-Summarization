[[{"text": ["I prefer to use tuples whenever a tuple feels \"natural\"; coordinates are a typical example, where the separate objects can stand on their own, e.g.", "in one-axis only scaling calculations."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I use dictionaries as a return value only when the grouped objects aren't always the same.", "Think optional email headers."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For the rest of the cases, where the grouped objects have inherent meaning inside the group or a fully-fledged object with its own methods is needed, I use a class."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["+1 on S.Lott's suggestion of a named container class."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For python 2.6 and up, a named tuple provides a useful way of easily creating these container classes, and the results are \"lightweight and require no more memory than regular tuples\"."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "named tuple", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html#collections.namedtuple"}]}], [{"text": ["Named tuples were added in 2.6 for this purpose.", "Also see os.stat for a similar builtin example."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Named tuples", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields"}, {"text": "os.stat", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/os.html#os.stat"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import collections\n&gt;&gt;&gt; point = collections.namedtuple('Point', ['x', 'y'])\n&gt;&gt;&gt; p = point(1, y=2)\n&gt;&gt;&gt; p.x, p.y\n(1, 2)\n&gt;&gt;&gt; p[0], p[1]\n(1, 2)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["For small projects I find it easiest to work with tuples.", "When that gets too hard to manage (and not before) I start grouping things into logical structures, however I think your suggested use of dictionaries and ReturnValue objects is wrong (or too simplistic)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Returning a dictionary with keys y0, y1, y2 etc doesn't offer any advantage over tuples.", "Returning a ReturnValue instance with properties .y0 .y1 .y2 etc doesn't offer any advantage over tuples either.", "You need to start naming things if you want to get anywhere, and you can do that using tuples anyway:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def getImageData(filename):\n  [snip]\n  return size, (format, version, compression), (width,height)\nsize, type, dimensions = getImageData(x)\n</code>\n</pre>\n", "senID": 2}, {"text": ["IMHO, the only good technique beyond tuples is to return real objects with proper methods and properties, like you get from re.match() or open(file)."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "re.match()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "open(file)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Generally, the \"specialized structure\" actually IS a sensible current state of an object, with its own methods."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Some3SpaceThing(object):\n  def __init__(self,x):\n    self.g(x)\n  def g(self,x):\n    self.y0 = x + 1\n    self.y1 = x * 3\n    self.y2 = y0 ** y3\n\nr = Some3SpaceThing( x )\nr.y0\nr.y1\nr.y2\n</code>\n</pre>\n", "senID": 1}, {"text": ["I like to find names for anonymous structures where possible.", "Meaningful names make things more clear."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I prefer"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def g(x):\n  y0 = x + 1\n  y1 = x * 3\n  y2 = y0 ** y3\n  return {'y0':y0, 'y1':y1 ,'y2':y2 }\n</code>\n</pre>\n", "senID": 1}, {"text": ["it seems everything else is just extra code to do the same thing."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["In languages like Python, I would usually use a dictionary as it involves less overhead than creating a new class."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, if I find myself constantly returning the same set of variables, then that probably involves a new class that I'll factor out."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I vote for the dictionary."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I find that if I make a function that returns anything more than 2-3 variables I'll fold them up in a dictionary.", "Otherwise I tend to forget the order and content of what I'm returning."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Also, introducing a 'special' structure makes your code more difficult to follow.", "(Someone else will have to search through the code to find out what it is)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If your concerned about type look up, use descriptive dictionary keys, for example, 'x-values list'."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def g(x):\n  y0 = x + 1\n  y1 = x * 3\n  y2 = y0 ** y3\n  return {'y0':y0, 'y1':y1 ,'y2':y2 }\n</code>\n</pre>\n", "senID": 4}]]