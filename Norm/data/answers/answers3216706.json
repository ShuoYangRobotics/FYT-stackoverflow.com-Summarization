[[{"text": ["Using += with a list is like calling extend, not +."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "+=", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "extend", "childNum": 0, "tag": "code", "childList": []}, {"text": "+", "childNum": 0, "tag": "code", "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "You can call ", "tag": "none", "senID": 1}, {"text": "You can only use ", "tag": "none", "senID": 2}]}, {"text": ["I can only guess why this decision was made, but I imagine it is for performance reasons.", "Calling + results in a new object being created and all items being copied, whereas extend can use free space in the existing list object saving a copy in some cases. "], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "extend", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Another side-effect of this decision is that if you write x += y other references to the list will see the change but if you use x = x + y then they will not.", "This is demonstrated below:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "x += y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x = x + y", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n>>> x = ['a','b']\n>>> y = ['c', d']\n>>> z = x\n>>> x += y\n>>> z\n['a', 'b', 'c', 'd']\n\n>>> x = ['a','b']\n>>> y = ['c', d']\n>>> z = x\n>>> x = x + y\n>>> z\n['a', 'b']\n</pre>\n", "senID": 5}, {"text": ["References"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "References", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Python source code for list."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Python source code for list", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Objects/listobject.c?view=markup"}]}, {"text": ["Source code for +=:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "+=", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\nstatic PyObject *\nlist_inplace_concat(PyListObject *self, PyObject *other)\n{\n    PyObject *result;\n\n    result =\n<b>\n listextend\n</b>\n(self, other);\n    if (result == NULL)\n        return result;\n    Py_DECREF(result);\n    Py_INCREF(self);\n    return (PyObject *)self;\n}\n</pre>\n", "senID": 9}, {"text": ["Source code for +:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\nstatic PyObject *\nlist_concat(PyListObject *a, PyObject *bb)\n{\n    Py_ssize_t size;\n    Py_ssize_t i;\n    PyObject **src, **dest;\n    PyListObject *np;\n    if (!PyList_Check(bb)) {\n        PyErr_Format(PyExc_TypeError,\n<b>\n \"can only concatenate list (not \\\"%.200s\\\") to list\",\n</b>\nbb->ob_type->tp_name);\n        return NULL;\n    }\n\n    // etc ...\n</pre>\n", "senID": 11}], [{"text": ["You're thinking about it backwards.", "You're asking why x = x + 'ha' throws an exception, given that x += 'ha' works.", "Really, the question is why x += 'ha' works at all."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "x = x + 'ha'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "x += 'ha'", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "x += 'ha'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Everyone agrees (I hope) that 'abc' + 'ha' and [1, 2, 3] + ['h', 'a'] should work.", "And in these cases, overloading += to do in-place modification seems reasonable."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "'abc' + 'ha'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[1, 2, 3] + ['h', 'a']", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The language designers decided that [1, 2, 3] + 'ha' shouldn't, because you're mixing different types.", "And that seems reasonable as well."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[1, 2, 3] + 'ha'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So the question is why they decided to allow mixing different types in the case of x += 'ha'.", "In this case, I imagine there are a couple reasons:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "allow", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "x += 'ha'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "It's a convenient shorthand", "tag": "none", "senID": 4}, {"text": "It's obvious what happens (you append each of the items in the iterable to ", "tag": "none", "senID": 5}]}, {"text": ["In general, Python tries to let you do what you want, but where there's ambiguity, it tends to force you to be explicit."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["When defining operators, there are two different \"add\" operators: One is called __add__, the other __iadd__.", "The latter one is for in-place additions with +=, the other one is the regular + operator.", "http://docs.python.org/reference/datamodel.html has more infos on that."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "__add__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__iadd__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "+", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "http://docs.python.org/reference/datamodel.html", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html"}]}]]