[[{"text": ["Iterator objects in python conform to the iterator protocol, which basically means they provide two methods: __iter__()  and  next().", "The __iter__ returns the iterator object and is implicitly called at the start of loops.", "The next() method returns the next value and is implicitly called at each loop increment.", "next() raises a StopIteration exception when there are no more value to return, which is implicitly captured by looping constructs to stop iterating."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "__iter__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "next()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__iter__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "next()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "next()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Here's a simple example of a counter:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Counter:\n    def __init__(self, low, high):\n        self.current = low\n        self.high = high\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        if self.current &gt; self.high:\n            raise StopIteration\n        else:\n            self.current += 1\n            return self.current - 1\n\n\nfor c in Counter(3, 8):\n    print c\n</code>\n</pre>\n", "senID": 2}, {"text": ["This will print:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n 3\n4\n5\n6\n7\n8\n</code>\n</pre>\n", "senID": 4}, {"text": ["This is easier to write using a generator, as covered in a previous answer:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def counter(low, high):\n    current = low\n    while current &lt;= high:\n        yield current\n        current += 1\n\nfor c in counter(3, 8):\n    print c\n</code>\n</pre>\n", "senID": 6}, {"text": ["The printed output will be the same.", "Under the hood, the generator object supports the iterator protocol and does something roughly similar to the class Counter."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["David Mertz's article, Iterators and Simple Generators, is a pretty good introduction. "], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Iterators and Simple Generators", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ibm.com/developerworks/library/l-pycon.html"}]}], [{"text": ["First of all the itertools module is incredibly useful for all sorts of cases in which an iterator would be useful, but here is all you need to create an iterator in python:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-itertools.html"}]}, {"text": ["Isn't that cool?", "Yield can be used to replace a normal return in a function.", "It returns the object just the same, but instead of destroying state and exiting, it saves state for when you want to execute the next iteration.", "Here is an example of it in action pulled directly from the itertools function list:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "return", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "itertools function list", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/itertools-functions.html"}]}, {"code": "<pre>\n<code>\n def count(n=0):\n     while True:\n         yield n\n         n += 1\n</code>\n</pre>\n", "senID": 2}, {"text": ["As stated in the functions description (it's the count() function from the itertools module...) , it produces an iterator that returns consecutive integers starting with n."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "count()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Generator expressions are a whole other can of worms (awesome worms!).", "They may be used in place of a List Comprehension to save memory (list comprehensions create a list in memory that is destroyed after use if not assigned to a variable, but generator expressions can create a Generator Object... which is a fancy way of saying Iterator).", "Here is an example of a generator expression definition:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "Generator expressions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/ref/genexpr.html"}, {"text": "List Comprehension", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.secnetix.de/olli/Python/list_comprehensions.hawk"}]}, {"code": "<pre>\n<code>\n gen = (n for n in xrange(0,11))\n</code>\n</pre>\n", "senID": 5}, {"text": ["This is very similar to our iterator definition above except the full range is predetermined to be between 0 and 10."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I just found xrange() (suprised I hadn't seen it before...) and added it to the above example.", "xrange() is an iterable version of range() which has the advantage of not prebuilding the list.", "It would be  very useful if you had a giant corpus of data to iterate over and only had so much memory to do it in."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "xrange()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "xrange()", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "range()", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}], [{"text": ["Addendum to the above poster: the code sample he provides for the Counter works in Python 2.x, but not in Python 3.x.", "In Python 3.x, you need to define the method __next__(), not next().", "Otherwise it's pretty much the same AFAIK."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__next__()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "next()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Source: PEP 3114"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "PEP 3114", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3114/"}]}], [{"text": ["There are four ways to build an iterative function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "create a generator (uses the ", "tag": "none", "senID": 1}, {"text": "use a generator expression (", "tag": "none", "senID": 2}, {"text": "create an iterator (defines ", "tag": "none", "senID": 3}, {"text": "create a function that Python can iterate over on its own (", "tag": "none", "senID": 4}]}, {"text": ["Examples:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n # generator\ndef uc_gen(text):\n    for char in text:\n        yield char.upper()\n\n# generator expression\ndef uc_genexp(text):\n    return (char.upper() for char in text)\n\n # iterator protocol\n class uc_iter():\n     def __init__(self, text):\n         self.text = text\n         self.index = 0\n     def __iter__(self):\n         return self\n     def __next__(self):\n         try:\n             result = self.text[self.index].upper()\n         except IndexError:\n             raise StopIteration\n         self.index += 1\n         return result\n\n # getitem method\n class uc_getitem():\n     def __init__(self, text):\n         self.text = text\n     def __getitem__(self, index):\n         result = self.text[index].upper()\n         return result\n</code>\n</pre>\n", "senID": 6}]]