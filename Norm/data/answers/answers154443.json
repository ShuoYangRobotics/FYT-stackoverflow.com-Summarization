[[{"text": ["From \"What\u2019s New in Python 2.6 - Interpreter Changes\":"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\"What\u2019s New in Python 2.6 - Interpreter Changes\"", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/whatsnew/2.6.html#interpreter-changes"}]}, {"text": ["Update 2010-11-27: Python 3.2 addresses the issue of cluttering source folders with .pyc files by introducing a special __pycache__ subfolder, see What's New in Python 3.2 - PYC Repository Directories."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": ".pyc", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__pycache__", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/dev/whatsnew/3.2.html#pep-3147-pyc-repository-directories", "text": "What's New in Python 3.2 - PYC Repository Directories", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["There actually IS a way to do it in Python 2.3+, but it's a bit esoteric.", "I don't know if you realize this, but you can do the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ unzip -l /tmp/example.zip\n Archive:  /tmp/example.zip\n   Length     Date   Time    Name\n --------    ----   ----    ----\n     8467  11-26-02 22:30   jwzthreading.py\n --------                   -------\n     8467                   1 file\n$ ./python\nPython 2.3 (#1, Aug 1 2003, 19:54:32) \n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.path.insert(0, '/tmp/example.zip')  # Add .zip file to front of path\n&gt;&gt;&gt; import jwzthreading\n&gt;&gt;&gt; jwzthreading.__file__\n'/tmp/example.zip/jwzthreading.py'\n</code>\n</pre>\n", "senID": 1}, {"text": ["According to the zipimport library:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "zipimport", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-zipimport.html"}]}, {"text": ["Thus, all you have to do is zip the files up, add the zipfile to your sys.path and then import them."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If you're building this for UNIX, you might also consider packaging your script using this recipe:  unix zip executable, but note that you might have to tweak this if you plan on using stdin or reading anything from sys.args (it CAN be done without too much trouble)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "unix zip executable", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/497000/"}]}, {"text": ["In my experience performance doesn't suffer too much because of this, but you should think twice before importing any very large modules this way."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["In 2.5, theres no way to suppress it, other than measures like not giving users write access to the directory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In python 2.6 and 3.0 however, there may be a setting in the sys module called \"dont_write_bytecode\" that can be set to suppress this.", "This can also be set by passing the \"-B\" option, or setting the environment variable \"PYTHONDONTWRITEBYTECODE\""], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["As far as I know python will compile all modules you \"import\".", "However python will NOT compile a python script run using: \"python script.py\" (it will however compile any modules that the script imports)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The real questions is why you don't want python to compile the modules?", "You could probably automate a way of cleaning these up if they are getting in the way."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You could make the directories that your modules exist in read-only for the user that the Python interpreter is running as."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I don't think there's a more elegant option.", "PEP 304 appears to have been an attempt to introduce a simple option for this, but it appears to have been abandoned."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "PEP 304", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0304/"}]}, {"text": ["I imagine there's probably some other problem you're trying to solve, for which disabling .py[co] would appear to be a workaround, but it'll probably be better to attack whatever this original problem is instead."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you run a python file directly (#!", "/usr/bin/python at the top of the file) it should interpret it directly instead of byte-compiling it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Googly is our friend: http://mail.python.org/pipermail/python-list/2005-June/326211.html of course someone somewhere (official mailing list) had already asked it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://mail.python.org/pipermail/python-list/2005-June/326211.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-list/2005-June/326211.html"}]}], [{"text": ["Super-dumb solution but I thought I'd post it anyway ;)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Add this your your ~.bash_rc:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n alias lv = 'rm *.pyc &amp;&amp; ls'\n</code>\n</pre>\n", "senID": 2}, {"text": ["EDIT:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I also found this works."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["#!/usr/bin/env python -B"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "#!/usr/bin/env python -B", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]