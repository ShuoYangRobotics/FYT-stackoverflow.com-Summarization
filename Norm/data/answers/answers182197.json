[[{"text": ["Have you already looked at the documentation available on http://timgolden.me.uk/python/win32_how_do_i/watch_directory_for_changes.html?", "If you only need it to work under Windows the 2nd example seems to be exactly what you want (if you exchange the path of the directory with the one of the file you want to watch). "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://timgolden.me.uk/python/win32_how_do_i/watch_directory_for_changes.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://timgolden.me.uk/python/win32_how_do_i/watch_directory_for_changes.html"}]}, {"text": ["Otherwise, polling will probably be the only really platform-independent option."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Note: I haven't tried any of these solutions."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Note:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["If polling is good enough for you, I'd just watch if the \"modified time\" file stat changes.", "To read it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n os.stat(filename).st_mtime\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Also note that the Windows native change event solution does not work in all circumstances, e.g.", "on network drives."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It should not work on windows (maybe with cygwin ?", "), but for unix user, you should use the \"fcntl\" system call.", "Here is an example in Python.", "It's mostly the same code if you need to write it in C (same function names)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import time\nimport fcntl\nimport os\nimport signal\n\nFNAME = \"/HOME/TOTO/FILETOWATCH\"\n\ndef handler(signum, frame):\n    print \"File %s modified\" % (FNAME,)\n\nsignal.signal(signal.SIGIO, handler)\nfd = os.open(FNAME,  os.O_RDONLY)\nfcntl.fcntl(fd, fcntl.F_SETSIG, 0)\nfcntl.fcntl(fd, fcntl.F_NOTIFY,\n            fcntl.DN_MODIFY | fcntl.DN_CREATE | fcntl.DN_MULTISHOT)\n\nwhile True:\n    time.sleep(10000)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Did you try using Watchdog?", "http://packages.python.org/watchdog/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://packages.python.org/watchdog/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://packages.python.org/watchdog/"}]}], [{"text": ["Well after a bit of hacking of Tim Golden's script, I have the following which seems to work quite well:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\n\nimport win32file\nimport win32con\n\npath_to_watch = \".\" # look at the current directory\nfile_to_watch = \"test.txt\" # look for changes to a file called test.txt\n\ndef ProcessNewData( newData ):\n    print \"Text added: %s\"%newData\n\n# Set up the bits we'll need for output\nACTIONS = {\n  1 : \"Created\",\n  2 : \"Deleted\",\n  3 : \"Updated\",\n  4 : \"Renamed from something\",\n  5 : \"Renamed to something\"\n}\nFILE_LIST_DIRECTORY = 0x0001\nhDir = win32file.CreateFile (\n  path_to_watch,\n  FILE_LIST_DIRECTORY,\n  win32con.FILE_SHARE_READ | win32con.FILE_SHARE_WRITE,\n  None,\n  win32con.OPEN_EXISTING,\n  win32con.FILE_FLAG_BACKUP_SEMANTICS,\n  None\n)\n\n# Open the file we're interested in\na = open(file_to_watch, \"r\")\n\n# Throw away any exising log data\na.read()\n\n# Wait for new data and call ProcessNewData for each new chunk that's written\nwhile 1:\n  # Wait for a change to occur\n  results = win32file.ReadDirectoryChangesW (\n    hDir,\n    1024,\n    False,\n    win32con.FILE_NOTIFY_CHANGE_LAST_WRITE,\n    None,\n    None\n  )\n\n  # For each change, check to see if it's updating the file we're interested in\n  for action, file in results:\n    full_filename = os.path.join (path_to_watch, file)\n    #print file, ACTIONS.get (action, \"Unknown\")\n    if file == file_to_watch:\n        newText = a.read()\n        if newText != \"\":\n            ProcessNewData( newText )\n</code>\n</pre>\n", "senID": 1}, {"text": ["It could probably do with a load more error checking, but for simply watching a log file and doing some processing on it before spitting it out to the screen, this works well."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Thanks everyone for your input - great stuff!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Check out pyinotify."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["inotify replaces dnotify (from an earlier answer) in newer linuxes and allows file-level rather than directory-level monitoring."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://trac.dbzteam.org/pyinotify"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://trac.dbzteam.org/pyinotify", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://trac.dbzteam.org/pyinotify"}]}], [{"text": ["Check my answer to a similar question.", "You could try the same loop in Python.", "This page suggests:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "my answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/62832/reading-data-from-a-log-file-as-a-separate-application-is-writing-to-it#63446"}, {"text": "similar question", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/62832/"}, {"text": "This page", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/157035/"}]}, {"code": "<pre>\n<code>\n import time\n\nwhile 1:\n    where = file.tell()\n    line = file.readline()\n    if not line:\n        time.sleep(1)\n        file.seek(where)\n    else:\n        print line, # already has newline\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also see the question tail() a file with Python."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "tail() a file with Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/136168/tail-a-file-with-python"}]}], [{"text": ["As you can see in Tim Golden's article, pointed by Horst Gutmann, WIN32 is relatively complex and watches directories, not a single file."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Tim Golden's article", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://timgolden.me.uk/python/win32_how_do_i/watch_directory_for_changes.html"}, {"href": "http://stackoverflow.com/users/22312/horst-gutmann", "text": "Horst Gutmann", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["I'd like to suggest you look into IronPython, which is a .NET python implementation.", "With IronPython you can use all the .NET functionality - including"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "IronPython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.codeplex.com/IronPython"}, {"text": ".NET", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": ".NET", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n System.IO.FileSystemWatcher\n</code>\n</pre>\n", "senID": 2}, {"text": ["Which handles single files with a simple Event interface."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Event", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["If you want a multiplataform solution, then check QFileSystemWatcher.", "Here an example code (not saniticed):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "QFileSystemWatcher", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://doc.qt.nokia.com/latest/qfilesystemwatcher.html"}]}, {"code": "<pre>\n<code>\n from PyQt4 import QtCore\n\n@QtCore.pyqtSlot(str)\ndef directory_changed(path):\n    print('Directory Changed!!!')\n\n@QtCore.pyqtSlot(str)\ndef file_changed(path):\n    print('File Changed!!!')\n\nfs_watcher = QtCore.QFileSystemWatcher(['/path/to/files_1', '/path/to/files_2', '/path/to/files_3'])\n\nfs_watcher.connect(fs_watcher, QtCore.SIGNAL('directoryChanged(QString)'), directory_changed)\nfs_watcher.connect(fs_watcher, QtCore.SIGNAL('fileChanged(QString)'), file_changed)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Well, since you are using Python, you can just open a file and keep reading lines from it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f = open('file.log')\n</code>\n</pre>\n", "senID": 1}, {"text": ["If the line read is not empty, you process it."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "not empty", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n line = f.readline()\nif line:\n    // Do what you want with the line\n</code>\n</pre>\n", "senID": 3}, {"text": ["You may be missing that it is ok to keep calling readline at the EOF.", "It will just keep returning an empty string in this case.", "And when something is appended to the log file, the reading will continue from where it stopped, as you need."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "readline", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you are looking for a solution that uses events, or a particular library, please specify this in your question.", "Otherwise, I think this solution is just fine."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Here is a simplified version of Kender's code that appears to do the same trick and does not import the entire file:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # Check file for new data.\n\nimport time\n\nf = open(r'c:\\temp\\test.txt', 'r')\n\nwhile True:\n\n    line = f.readline()\n    if not line:\n        time.sleep(1)\n        print 'Nothing New'\n    else:\n        print 'Call Function: ', line\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I don't know any Windows specific function.", "You could try getting the MD5 hash of the file every second/minute/hour (depends on how fast you need it) and compare it to the last hash.", "When it differs you know the file has been changed and you read out the newest lines."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I'd try something like this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n            f = open(filePath)\n    except IOError:\n            print \"No such file: %s\" % filePath\n            raw_input(\"Press Enter to close window\")\n    try:\n            lines = f.readlines()\n            while True:\n                    line = f.readline()\n                    try:\n                            if not line:\n                                    time.sleep(1)\n                            else:\n                                    functionThatAnalisesTheLine(line)\n                    except Exception, e:\n                            # handle the exception somehow (for example, log the trace) and raise the same exception again\n                            raw_input(\"Press Enter to close window\")\n                            raise e\n    finally:\n            f.close()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The loop checks if there is a new line(s) since last time file was read - if there is, it's read and passed to the functionThatAnalisesTheLine function.", "If not, script waits 1 second and retries the process. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "functionThatAnalisesTheLine", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]
