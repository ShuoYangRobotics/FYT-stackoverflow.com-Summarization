[[{"text": ["You should consider Boost.Python if you are not planning to generate bindings for other languages as well with swig. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you have a lot of functions and classes to bind, Py++ is a great tool that automatically generates the needed code to make the bindings."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Py++", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.language-binding.net/pyplusplus/pyplusplus.html"}]}, {"text": ["Pybindgen  may also be an option, but it's a new project and less complete that Boost.Python."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Pybindgen", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/pybindgen/"}]}, {"tag": "hr", "senID": 3}, {"text": ["Edit:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Maybe I need to be more explicit about pro and cons."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": ["Swig:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Boost.Python:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Py++: it's Boost.Python made easy.", "Py++ uses a C++ parser to read your code and then generates Boost.Python code automatically.", "You also have a great support from its author (no it's not me ;-) )."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Pybindgen:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}]}, {"text": ["It's definitely worth a good look."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "A new one:\nOn 2009/01/20 (yesterday), the author of Py++ announced a ", "tag": "none", "senID": 11}]}], [{"text": ["For sure you will always have a performance gain doing this by hand, but the gain will be very small compared to the effort required to do this.", "I don't have any figure to give you but I don't recommend this, because you will need to maintain the interface by hand, and this is not an option if your module is large!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You did the right thing to chose to use a scripting language because you wanted rapid development.", "This way you've avoided the early optimization syndrome, and now you want to optimize bottleneck parts, great!", "But if you do the C/python interface by hand you will fall in the early optimization syndrome for sure."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you want something with less interface code, you can think about creating a dll from your C code, and use that library directly from python with cstruct."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "cstruct", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://python.net/crew/theller/ctypes/"}]}, {"text": ["Consider also Cpython if you want to use only python code in your program."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Cpython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cython.org/"}]}], [{"text": ["Using Cython is pretty good.", "You can write your C extension with a Python-like syntax and have it generate C code.", "Boilerplate included.", "Since you have the code already in python, you have to do just a few changes to your bottleneck code and C code will be generated from it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Cython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cython.org/"}]}, {"text": ["Example.", "hello.pyx:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "hello.pyx", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n cdef int hello(int a, int b):\n    return a + b\n</code>\n</pre>\n", "senID": 2}, {"text": ["That generates 601 lines of boilerplate code:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "601 lines", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n /* Generated by Cython 0.10.3 on Mon Jan 19 08:24:44 2009 */\n\n#define PY_SSIZE_T_CLEAN\n#include \"Python.h\"\n#include \"structmember.h\"\n#ifndef PY_LONG_LONG\n  #define PY_LONG_LONG LONG_LONG\n#endif\n#ifndef DL_EXPORT\n  #define DL_EXPORT(t) t\n#endif\n#if PY_VERSION_HEX &lt; 0x02040000\n  #define METH_COEXIST 0\n#endif\n#if PY_VERSION_HEX &lt; 0x02050000\n  typedef int Py_ssize_t;\n  #define PY_SSIZE_T_MAX INT_MAX\n  #define PY_SSIZE_T_MIN INT_MIN\n  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)\n  #define PyInt_AsSsize_t(o)   PyInt_AsLong(o)\n  #define PyNumber_Index(o)    PyNumber_Int(o)\n  #define PyIndex_Check(o)     PyNumber_Check(o)\n#endif\n#if PY_VERSION_HEX &lt; 0x02060000\n  #define Py_REFCNT(ob) (((PyObject*)(ob))-&gt;ob_refcnt)\n  #define Py_TYPE(ob)   (((PyObject*)(ob))-&gt;ob_type)\n  #define Py_SIZE(ob)   (((PyVarObject*)(ob))-&gt;ob_size)\n  #define PyVarObject_HEAD_INIT(type, size) \\\n          PyObject_HEAD_INIT(type) size,\n  #define PyType_Modified(t)\n\n  typedef struct {\n       void *buf;\n       PyObject *obj;\n       Py_ssize_t len;\n       Py_ssize_t itemsize;\n       int readonly;\n       int ndim;\n       char *format;\n       Py_ssize_t *shape;\n       Py_ssize_t *strides;\n       Py_ssize_t *suboffsets;\n       void *internal;\n  } Py_buffer;\n\n  #define PyBUF_SIMPLE 0\n  #define PyBUF_WRITABLE 0x0001\n  #define PyBUF_LOCK 0x0002\n  #define PyBUF_FORMAT 0x0004\n  #define PyBUF_ND 0x0008\n  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)\n  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)\n  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)\n  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)\n  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)\n\n#endif\n#if PY_MAJOR_VERSION &lt; 3\n  #define __Pyx_BUILTIN_MODULE_NAME \"__builtin__\"\n#else\n  #define __Pyx_BUILTIN_MODULE_NAME \"builtins\"\n#endif\n#if PY_MAJOR_VERSION &gt;= 3\n  #define Py_TPFLAGS_CHECKTYPES 0\n  #define Py_TPFLAGS_HAVE_INDEX 0\n#endif\n#if (PY_VERSION_HEX &lt; 0x02060000) || (PY_MAJOR_VERSION &gt;= 3)\n  #define Py_TPFLAGS_HAVE_NEWBUFFER 0\n#endif\n#if PY_MAJOR_VERSION &gt;= 3\n  #define PyBaseString_Type            PyUnicode_Type\n  #define PyString_Type                PyBytes_Type\n  #define PyInt_Type                   PyLong_Type\n  #define PyInt_Check(op)              PyLong_Check(op)\n  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)\n  #define PyInt_FromString             PyLong_FromString\n  #define PyInt_FromUnicode            PyLong_FromUnicode\n  #define PyInt_FromLong               PyLong_FromLong\n  #define PyInt_FromSize_t             PyLong_FromSize_t\n  #define PyInt_FromSsize_t            PyLong_FromSsize_t\n  #define PyInt_AsLong                 PyLong_AsLong\n  #define PyInt_AS_LONG                PyLong_AS_LONG\n  #define PyInt_AsSsize_t              PyLong_AsSsize_t\n  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask\n  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask\n  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)\n#else\n  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)\n  #define PyBytes_Type                 PyString_Type\n#endif\n#if PY_MAJOR_VERSION &gt;= 3\n  #define PyMethod_New(func, self, klass) PyInstanceMethod_New(func)\n#endif\n#if !defined(WIN32) &amp;&amp; !defined(MS_WINDOWS)\n  #ifndef __stdcall\n    #define __stdcall\n  #endif\n  #ifndef __cdecl\n    #define __cdecl\n  #endif\n#else\n  #define _USE_MATH_DEFINES\n#endif\n#ifdef __cplusplus\n#define __PYX_EXTERN_C extern \"C\"\n#else\n#define __PYX_EXTERN_C extern\n#endif\n#include &lt;math.h&gt;\n#define __PYX_HAVE_API__helloworld\n\n#ifdef __GNUC__\n#define INLINE __inline__\n#elif _WIN32\n#define INLINE __inline\n#else\n#define INLINE \n#endif\n\ntypedef struct \n    {PyObject **p; char *s; long n; \n     char is_unicode; char intern; char is_identifier;} \n     __Pyx_StringTabEntry; /*proto*/\n\nstatic int __pyx_skip_dispatch = 0;\n\n\n/* Type Conversion Predeclarations */\n\n#if PY_MAJOR_VERSION &lt; 3\n#define __Pyx_PyBytes_FromString PyString_FromString\n#define __Pyx_PyBytes_AsString   PyString_AsString\n#else\n#define __Pyx_PyBytes_FromString PyBytes_FromString\n#define __Pyx_PyBytes_AsString   PyBytes_AsString\n#endif\n\n#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))\nstatic INLINE int __Pyx_PyObject_IsTrue(PyObject* x);\nstatic INLINE PY_LONG_LONG __pyx_PyInt_AsLongLong(PyObject* x);\nstatic INLINE unsigned PY_LONG_LONG __pyx_PyInt_AsUnsignedLongLong(PyObject* x);\nstatic INLINE Py_ssize_t __pyx_PyIndex_AsSsize_t(PyObject* b);\n\n#define __pyx_PyInt_AsLong(x) (PyInt_CheckExact(x) ? PyInt_AS_LONG(x) : PyInt_AsLong(x))\n#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))\n\nstatic INLINE unsigned char __pyx_PyInt_unsigned_char(PyObject* x);\nstatic INLINE unsigned short __pyx_PyInt_unsigned_short(PyObject* x);\nstatic INLINE char __pyx_PyInt_char(PyObject* x);\nstatic INLINE short __pyx_PyInt_short(PyObject* x);\nstatic INLINE int __pyx_PyInt_int(PyObject* x);\nstatic INLINE long __pyx_PyInt_long(PyObject* x);\nstatic INLINE signed char __pyx_PyInt_signed_char(PyObject* x);\nstatic INLINE signed short __pyx_PyInt_signed_short(PyObject* x);\nstatic INLINE signed int __pyx_PyInt_signed_int(PyObject* x);\nstatic INLINE signed long __pyx_PyInt_signed_long(PyObject* x);\nstatic INLINE long double __pyx_PyInt_long_double(PyObject* x);\n#ifdef __GNUC__\n/* Test for GCC &gt; 2.95 */\n#if __GNUC__ &gt; 2 ||               (__GNUC__ == 2 &amp;&amp; (__GNUC_MINOR__ &gt; 95)) \n#define likely(x)   __builtin_expect(!!(x), 1)\n#define unlikely(x) __builtin_expect(!!(x), 0)\n#else /* __GNUC__ &gt; 2 ... */\n#define likely(x)   (x)\n#define unlikely(x) (x)\n#endif /* __GNUC__ &gt; 2 ... */\n#else /* __GNUC__ */\n#define likely(x)   (x)\n#define unlikely(x) (x)\n#endif /* __GNUC__ */\n\nstatic PyObject *__pyx_m;\nstatic PyObject *__pyx_b;\nstatic PyObject *__pyx_empty_tuple;\nstatic int __pyx_lineno;\nstatic int __pyx_clineno = 0;\nstatic const char * __pyx_cfilenm= __FILE__;\nstatic const char *__pyx_filename;\nstatic const char **__pyx_f;\n\nstatic void __Pyx_AddTraceback(const char *funcname); /*proto*/\n\n/* Type declarations */\n/* Module declarations from helloworld */\n\nstatic int __pyx_f_10helloworld_hello(int, int); /*proto*/\n\n\n/* Implementation of helloworld */\n\n/* \"/home/nosklo/devel/ctest/hello.pyx\":1\n * cdef int hello(int a, int b):             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n *     return a + b\n * \n */\n\nstatic  int __pyx_f_10helloworld_hello(int __pyx_v_a, int __pyx_v_b) {\n  int __pyx_r;\n\n  /* \"/home/nosklo/devel/ctest/hello.pyx\":2\n * cdef int hello(int a, int b):\n *     return a + b             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n * \n */\n  __pyx_r = (__pyx_v_a + __pyx_v_b);\n  goto __pyx_L0;\n\n  __pyx_r = 0;\n  __pyx_L0:;\n  return __pyx_r;\n}\n\nstatic struct PyMethodDef __pyx_methods[] = {\n  {0, 0, 0, 0}\n};\n\nstatic void __pyx_init_filenames(void); /*proto*/\n\n#if PY_MAJOR_VERSION &gt;= 3\nstatic struct PyModuleDef __pyx_moduledef = {\n    PyModuleDef_HEAD_INIT,\n    \"helloworld\",\n    0, /* m_doc */\n    -1, /* m_size */\n    __pyx_methods /* m_methods */,\n    NULL, /* m_reload */\n    NULL, /* m_traverse */\n    NULL, /* m_clear */\n    NULL /* m_free */\n};\n#endif\nstatic int __Pyx_InitCachedBuiltins(void) {\n  return 0;\n  return -1;\n}\n\nstatic int __Pyx_InitGlobals(void) {\n  return 0;\n  return -1;\n}\n\n#if PY_MAJOR_VERSION &lt; 3\nPyMODINIT_FUNC inithelloworld(void); /*proto*/\nPyMODINIT_FUNC inithelloworld(void)\n#else\nPyMODINIT_FUNC PyInit_helloworld(void); /*proto*/\nPyMODINIT_FUNC PyInit_helloworld(void)\n#endif\n{\n  __pyx_empty_tuple = PyTuple_New(0); \n  if (unlikely(!__pyx_empty_tuple))\n      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; \n       __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  /*--- Library function declarations ---*/\n  __pyx_init_filenames();\n  /*--- Initialize various global constants etc. ---*/\n  if (unlikely(__Pyx_InitGlobals() &lt; 0)) \n     {__pyx_filename = __pyx_f[0]; \n      __pyx_lineno = 1; \n      __pyx_clineno = __LINE__; \n      goto __pyx_L1_error;}\n  /*--- Module creation code ---*/\n  #if PY_MAJOR_VERSION &lt; 3\n  __pyx_m = Py_InitModule4(\"helloworld\", __pyx_methods, 0, 0, PYTHON_API_VERSION);\n  #else\n  __pyx_m = PyModule_Create(&amp;__pyx_moduledef);\n  #endif\n  if (!__pyx_m) \n     {__pyx_filename = __pyx_f[0]; \n      __pyx_lineno = 1; __pyx_clineno = __LINE__; \n      goto __pyx_L1_error;};\n  #if PY_MAJOR_VERSION &lt; 3\n  Py_INCREF(__pyx_m);\n  #endif\n  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME);\n  if (!__pyx_b) \n     {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; \n      __pyx_clineno = __LINE__; goto __pyx_L1_error;};\n  if (PyObject_SetAttrString(__pyx_m, \"__builtins__\", __pyx_b) &lt; 0) \n      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; \n       __pyx_clineno = __LINE__; goto __pyx_L1_error;};\n  /*--- Builtin init code ---*/\n  if (unlikely(__Pyx_InitCachedBuiltins() &lt; 0)) \n      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; \n       __pyx_clineno = __LINE__; goto __pyx_L1_error;}\n  __pyx_skip_dispatch = 0;\n  /*--- Global init code ---*/\n  /*--- Function export code ---*/\n  /*--- Type init code ---*/\n  /*--- Type import code ---*/\n  /*--- Function import code ---*/\n  /*--- Execution code ---*/\n\n  /* \"/home/nosklo/devel/ctest/hello.pyx\":1\n * cdef int hello(int a, int b):             # &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n *     return a + b\n * \n */\n  #if PY_MAJOR_VERSION &lt; 3\n  return;\n  #else\n  return __pyx_m;\n  #endif\n  __pyx_L1_error:;\n  __Pyx_AddTraceback(\"helloworld\");\n  #if PY_MAJOR_VERSION &gt;= 3\n  return NULL;\n  #endif\n}\n\nstatic const char *__pyx_filenames[] = {\n  \"hello.pyx\",\n};\n\n/* Runtime support code */\n\nstatic void __pyx_init_filenames(void) {\n  __pyx_f = __pyx_filenames;\n}\n\n#include \"compile.h\"\n#include \"frameobject.h\"\n#include \"traceback.h\"\n\nstatic void __Pyx_AddTraceback(const char *funcname) {\n    PyObject *py_srcfile = 0;\n    PyObject *py_funcname = 0;\n    PyObject *py_globals = 0;\n    PyObject *empty_string = 0;\n    PyCodeObject *py_code = 0;\n    PyFrameObject *py_frame = 0;\n\n    #if PY_MAJOR_VERSION &lt; 3\n    py_srcfile = PyString_FromString(__pyx_filename);\n    #else\n    py_srcfile = PyUnicode_FromString(__pyx_filename);\n    #endif\n    if (!py_srcfile) goto bad;\n    if (__pyx_clineno) {\n        #if PY_MAJOR_VERSION &lt; 3\n        py_funcname = PyString_FromFormat( \"%s (%s:%d)\", funcname, \n             __pyx_cfilenm, __pyx_clineno);\n        #else\n        py_funcname = PyUnicode_FromFormat( \"%s (%s:%d)\", funcname, \n             __pyx_cfilenm, __pyx_clineno);\n        #endif\n    }\n    else {\n        #if PY_MAJOR_VERSION &lt; 3\n        py_funcname = PyString_FromString(funcname);\n        #else\n        py_funcname = PyUnicode_FromString(funcname);\n        #endif\n    }\n    if (!py_funcname) goto bad;\n    py_globals = PyModule_GetDict(__pyx_m);\n    if (!py_globals) goto bad;\n    #if PY_MAJOR_VERSION &lt; 3\n    empty_string = PyString_FromStringAndSize(\"\", 0);\n    #else\n    empty_string = PyBytes_FromStringAndSize(\"\", 0);\n    #endif\n    if (!empty_string) goto bad;\n    py_code = PyCode_New(\n        0,            /*int argcount,*/\n        #if PY_MAJOR_VERSION &gt;= 3\n        0,            /*int kwonlyargcount,*/\n        #endif\n        0,            /*int nlocals,*/\n        0,            /*int stacksize,*/\n        0,            /*int flags,*/\n        empty_string, /*PyObject *code,*/\n        __pyx_empty_tuple,  /*PyObject *consts,*/\n        __pyx_empty_tuple,  /*PyObject *names,*/\n        __pyx_empty_tuple,  /*PyObject *varnames,*/\n        __pyx_empty_tuple,  /*PyObject *freevars,*/\n        __pyx_empty_tuple,  /*PyObject *cellvars,*/\n        py_srcfile,   /*PyObject *filename,*/\n        py_funcname,  /*PyObject *name,*/\n        __pyx_lineno,   /*int firstlineno,*/\n        empty_string  /*PyObject *lnotab*/\n    );\n    if (!py_code) goto bad;\n    py_frame = PyFrame_New(\n        PyThreadState_GET(), /*PyThreadState *tstate,*/\n        py_code,             /*PyCodeObject *code,*/\n        py_globals,          /*PyObject *globals,*/\n        0                    /*PyObject *locals*/\n    );\n    if (!py_frame) goto bad;\n    py_frame-&gt;f_lineno = __pyx_lineno;\n    PyTraceBack_Here(py_frame);\nbad:\n    Py_XDECREF(py_srcfile);\n    Py_XDECREF(py_funcname);\n    Py_XDECREF(empty_string);\n    Py_XDECREF(py_code);\n    Py_XDECREF(py_frame);\n}\n\n/* Type Conversion Functions */\n\nstatic INLINE Py_ssize_t __pyx_PyIndex_AsSsize_t(PyObject* b) {\n  Py_ssize_t ival;\n  PyObject* x = PyNumber_Index(b);\n  if (!x) return -1;\n  ival = PyInt_AsSsize_t(x);\n  Py_DECREF(x);\n  return ival;\n}\n\nstatic INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {\n   if (x == Py_True) return 1;\n   else if (x == Py_False) return 0;\n   else return PyObject_IsTrue(x);\n}\n\nstatic INLINE PY_LONG_LONG __pyx_PyInt_AsLongLong(PyObject* x) {\n    if (PyInt_CheckExact(x)) {\n        return PyInt_AS_LONG(x);\n    }\n    else if (PyLong_CheckExact(x)) {\n        return PyLong_AsLongLong(x);\n    }\n    else {\n        PY_LONG_LONG val;\n        PyObject* tmp = PyNumber_Int(x); if (!tmp) return (PY_LONG_LONG)-1;\n        val = __pyx_PyInt_AsLongLong(tmp);\n        Py_DECREF(tmp);\n        return val;\n    }\n}\n\nstatic INLINE unsigned PY_LONG_LONG __pyx_PyInt_AsUnsignedLongLong(PyObject* x) {\n    if (PyInt_CheckExact(x)) {\n        long val = PyInt_AS_LONG(x);\n        if (unlikely(val &lt; 0)) {\n            PyErr_SetString(PyExc_TypeError, \"Negative assignment to unsigned type.\");\n            return (unsigned PY_LONG_LONG)-1;\n        }\n        return val;\n    }\n    else if (PyLong_CheckExact(x)) {\n        return PyLong_AsUnsignedLongLong(x);\n    }\n    else {\n        PY_LONG_LONG val;\n        PyObject* tmp = PyNumber_Int(x); if (!tmp) return (PY_LONG_LONG)-1;\n        val = __pyx_PyInt_AsUnsignedLongLong(tmp);\n        Py_DECREF(tmp);\n        return val;\n    }\n}\n\n\nstatic INLINE unsigned char __pyx_PyInt_unsigned_char(PyObject* x) {\n    if (sizeof(unsigned char) &lt; sizeof(long)) {\n        long long_val = __pyx_PyInt_AsLong(x);\n        unsigned char val = (unsigned char)long_val;\n        if (unlikely((val != long_val)  || (long_val &lt; 0))) {\n            PyErr_SetString(PyExc_OverflowError, \"value too large to convert to unsigned char\");\n            return (unsigned char)-1;\n        }\n        return val;\n    }\n    else {\n        return __pyx_PyInt_AsLong(x);\n    }\n}\n\nstatic INLINE unsigned short __pyx_PyInt_unsigned_short(PyObject* x) {\n    if (sizeof(unsigned short) &lt; sizeof(long)) {\n        long long_val = __pyx_PyInt_AsLong(x);\n        unsigned short val = (unsigned short)long_val;\n        if (unlikely((val != long_val)  || (long_val &lt; 0))) {\n            PyErr_SetString(PyExc_OverflowError, \"value too large to convert to unsigned short\");\n            return (unsigned short)-1;\n        }\n        return val;\n    }\n    else {\n        return __pyx_PyInt_AsLong(x);\n    }\n}\n\nstatic INLINE char __pyx_PyInt_char(PyObject* x) {\n    if (sizeof(char) &lt; sizeof(long)) {\n        long long_val = __pyx_PyInt_AsLong(x);\n        char val = (char)long_val;\n        if (unlikely((val != long_val) )) {\n            PyErr_SetString(PyExc_OverflowError, \"value too large to convert to char\");\n            return (char)-1;\n        }\n        return val;\n    }\n    else {\n        return __pyx_PyInt_AsLong(x);\n    }\n}\n\nstatic INLINE short __pyx_PyInt_short(PyObject* x) {\n    if (sizeof(short) &lt; sizeof(long)) {\n        long long_val = __pyx_PyInt_AsLong(x);\n        short val = (short)long_val;\n        if (unlikely((val != long_val) )) {\n            PyErr_SetString(PyExc_OverflowError, \"value too large to convert to short\");\n            return (short)-1;\n        }\n        return val;\n    }\n    else {\n        return __pyx_PyInt_AsLong(x);\n    }\n}\n\nstatic INLINE int __pyx_PyInt_int(PyObject* x) {\n    if (sizeof(int) &lt; sizeof(long)) {\n        long long_val = __pyx_PyInt_AsLong(x);\n        int val = (int)long_val;\n        if (unlikely((val != long_val) )) {\n            PyErr_SetString(PyExc_OverflowError, \"value too large to convert to int\");\n            return (int)-1;\n        }\n        return val;\n    }\n    else {\n        return __pyx_PyInt_AsLong(x);\n    }\n}\n\nstatic INLINE long __pyx_PyInt_long(PyObject* x) {\n    if (sizeof(long) &lt; sizeof(long)) {\n        long long_val = __pyx_PyInt_AsLong(x);\n        long val = (long)long_val;\n        if (unlikely((val != long_val) )) {\n            PyErr_SetString(PyExc_OverflowError, \"value too large to convert to long\");\n            return (long)-1;\n        }\n        return val;\n    }\n    else {\n        return __pyx_PyInt_AsLong(x);\n    }\n}\n\nstatic INLINE signed char __pyx_PyInt_signed_char(PyObject* x) {\n    if (sizeof(signed char) &lt; sizeof(long)) {\n        long long_val = __pyx_PyInt_AsLong(x);\n        signed char val = (signed char)long_val;\n        if (unlikely((val != long_val) )) {\n            PyErr_SetString(PyExc_OverflowError, \"value too large to convert to signed char\");\n            return (signed char)-1;\n        }\n        return val;\n    }\n    else {\n        return __pyx_PyInt_AsLong(x);\n    }\n}\n\nstatic INLINE signed short __pyx_PyInt_signed_short(PyObject* x) {\n    if (sizeof(signed short) &lt; sizeof(long)) {\n        long long_val = __pyx_PyInt_AsLong(x);\n        signed short val = (signed short)long_val;\n        if (unlikely((val != long_val) )) {\n            PyErr_SetString(PyExc_OverflowError, \"value too large to convert to signed short\");\n            return (signed short)-1;\n        }\n        return val;\n    }\n    else {\n        return __pyx_PyInt_AsLong(x);\n    }\n}\n\nstatic INLINE signed int __pyx_PyInt_signed_int(PyObject* x) {\n    if (sizeof(signed int) &lt; sizeof(long)) {\n        long long_val = __pyx_PyInt_AsLong(x);\n        signed int val = (signed int)long_val;\n        if (unlikely((val != long_val) )) {\n            PyErr_SetString(PyExc_OverflowError, \"value too large to convert to signed int\");\n            return (signed int)-1;\n        }\n        return val;\n    }\n    else {\n        return __pyx_PyInt_AsLong(x);\n    }\n}\n\nstatic INLINE signed long __pyx_PyInt_signed_long(PyObject* x) {\n    if (sizeof(signed long) &lt; sizeof(long)) {\n        long long_val = __pyx_PyInt_AsLong(x);\n        signed long val = (signed long)long_val;\n        if (unlikely((val != long_val) )) {\n            PyErr_SetString(PyExc_OverflowError, \"value too large to convert to signed long\");\n            return (signed long)-1;\n        }\n        return val;\n    }\n    else {\n        return __pyx_PyInt_AsLong(x);\n    }\n}\n\nstatic INLINE long double __pyx_PyInt_long_double(PyObject* x) {\n    if (sizeof(long double) &lt; sizeof(long)) {\n        long long_val = __pyx_PyInt_AsLong(x);\n        long double val = (long double)long_val;\n        if (unlikely((val != long_val) )) {\n            PyErr_SetString(PyExc_OverflowError, \"value too large to convert to long double\");\n            return (long double)-1;\n        }\n        return val;\n    }\n    else {\n        return __pyx_PyInt_AsLong(x);\n    }\n}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["There be dragons here.", "Don't swig, don't boost.", "For any complicated project the code you have to fill in yourself to make them work becomes unmanageable quickly.", "If it's a plain C API to your library (no classes), you can just use ctypes.", "It will be easy and painless, and you won't have to spend hours trawling through the documentation for these labyrinthine wrapper projects trying to find the one tiny note about the feature you need."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Since you are concerned with speed and overhead, I suggest considering PyBindGen. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PyBindGen", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/pybindgen/"}]}, {"text": ["I have experience using it to wrap a large internal C++ library.", "After trying SWIG, SIP, and Boost.Python I prefer PyBindGen for the following reasons:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Before giving up on your python code, have a look at ShedSkin.", "They claim better performance than Psyco on some code (and also state that it is still experimental)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ShedSkin", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/shedskin/"}]}, {"text": ["Else, there are several choices for binding C/C++ code to python."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Boost is lengthy to compile but is really the most flexible and easy to use solution."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I have never used SWIG but compared to boost, it's not as flexible as it's generic binding framework, not a framework dedicated to python."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Next choice is Pyrex.", "It allows to write pseudo python code that gets compiled as a C extension."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Pyrex", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/"}]}], [{"text": ["If its not a big extension, boost::python might also be an option, it executes faster than swig, because you control what's happening, but it'll take longer to dev."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Anyways swig's overhead is acceptable if the amount of work within a single call is large enough.", "For example if you issue is that you have some medium sized logic block you want to move to C/C++, but that block is called within a tight-loop, frequently, you might have to avoid swig, but I can't really think of any real-world examples except for scripted graphics shaders."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["SWIG 2.0.4 has introduced a new -builtin option that improves performance.", "I did some benchmarking using an example program that does a lot of fast calls to a C++ extension.", "I built the extension using boost.python, PyBindGen, SIP and SWIG with and without the -builtin option.", "Here are the results (average of 100 runs):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n SWIG with -builtin     2.67s\nSIP                    2.70s\nPyBindGen              2.74s\nboost.python           3.07s\nSWIG without -builtin  4.65s\n</code>\n</pre>\n", "senID": 1}, {"text": ["SWIG used to be slowest.", "With the new -builtin option, SWIG seems to be fastest."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["An observation: Based on the benchmarking conducted by the pybindgen developers, there is no significant difference between boost.python and swig.", "I haven't done my own benchmarking to verify how much of this depends on the proper use of the boost.python functionality. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Note also that there may be a reason that pybindgen seems to be in general quite a bit faster than swig and boost.python: it may not produce as versatile a binding as the other two.", "For instance, exception propagation, call argument type checking, etc.", "I haven't had a chance to use pybindgen yet but I intend to. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "may", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Boost is in general quite big package to install, and last I saw you can't just install boost python you pretty much need the whole Boost library.", "As others have mentioned compilation will be slow due to heavy use of template programming, which also means typically rather cryptic error messages at compile time. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Summary: given how easy SWIG is to install and use, that it generates decent binding that is robust and versatile, and that one interface file allows your C++ DLL to be available from several other languages like LUA, C#, and Java, I would favor it over boost.python.", "But unless you really need multi-language support I would take a close look at PyBindGen because of its purported speed, and pay close attention to robustness and versatility of binding it generates. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]