[[{"text": ["Quoting Jacob Hallen:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Jacob Hallen", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/lists/python-list/531365/"}]}], [{"text": ["You would want to use __slots__ if you are going to instantiate a lot (hundreds, thousands) of objects of the same class.", "__slots__ only exists as a memory optimization tool."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__slots__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["It's highly discouraged to use __slots__ for constraining attribute creation, and in general you want to avoid it because it breaks pickle, along with some other introspection features of python."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Each python object has a __dict__ atttribute which is a dictionary containing all other attributes.", "e.g.", "when you type self.attr python is actually doing self.__dict__['attr'].", "As you can imagine using a dictionary to store attribute takes some extra space &amp; time for accessing it."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__dict__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self.attr", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "self.__dict__['attr']", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["However, when you use __slots__, any object created for that class won't have a __dict__ attribute.", "Instead, all attribute access is done directly via pointers."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__dict__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["So if want a C style structure rather than a full fledged class you can use __slots__ for compacting size of the objects &amp; reducing attribute access time.", "A good example is a Point class containing attributes x &amp; y.", "If you are going to have a lot of points, you can try using __slots__ in order to conserve some memory."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__slots__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["You have -- essentially -- no use for __slots__.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The time when you think you might need __slots__, you actually want to use Lightweght or Flyweight design patterns.", "These are cases when you no longer want to use purely Python objects.", "Instead, you want a Python object-like wrapper around an array, struct or numpy array."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Lightweght", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "Flyweight", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n class Flyweight( object ):\n    def get( self, theData, index ):\n        return theData[index]\n    def set( self, theData, index, value ):\n        theData[index]= value\n</code>\n</pre>\n", "senID": 2}, {"text": ["The class-like wrapper has no attributes -- it just provides methods that act on the underlying data.", "The methods can be reduced to class methods.", "Indeed, it could be reduced to just functions operating on the underlying array of data."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]