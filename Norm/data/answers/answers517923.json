[[{"text": ["How about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import unicodedata\ndef strip_accents(s):\n   return ''.join((c for c in unicodedata.normalize('NFD', s) if unicodedata.category(c) != 'Mn'))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This works on greek letters, too:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; strip_accents(u\"A \\u00c0 \\u0394 \\u038E\")\nu'A A \\u0394 \\u03a5'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["Update:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The character category (link is broken, see the unicode glossary) \"Mn\" stands for \"Mark, Nonspacing\", which is similar to unicodedata.combining in MiniQuark's answer (I didn't think of unicodedata.combining, but it is probably the better solution, because it's more explicit)."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "character category", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://unicode.org/Public/UNIDATA/UCD.html#General_Category_Values"}, {"href": "http://unicode.org/glossary/#nonspacing_mark", "text": "glossary", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["And keep in mind, these manipulations may significantly alter the meaning of the text.", "Accents, Umlauts etc.", "are not \"decoration\"."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Unidecode is the correct answer for this.", "It transliterates any unicode string into the closest possible representation in ascii text."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Unidecode", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/Unidecode/0.04.1"}]}], [{"text": ["I just found this answer on the Web:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import unicodedata\n\ndef remove_accents(input_str):\n    nkfd_form = unicodedata.normalize('NFKD', unicode(input_str))\n    only_ascii = nkfd_form.encode('ASCII', 'ignore')\n    return only_ascii\n</code>\n</pre>\n", "senID": 1}, {"text": ["It works fine (for French, for example), but I think the second step (removing the accents) could be handled better than dropping the non-ASCII characters, because this will fail for some languages (Greek, for example).", "The best solution would probably be to explicitly remove the unicode characters that are tagged as being diacritics."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: this does the trick:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import unicodedata\n\ndef remove_accents(input_str):\n    nkfd_form = unicodedata.normalize('NFKD', unicode(input_str))\n    return u\"\".join([c for c in nkfd_form if not unicodedata.combining(c)])\n</code>\n</pre>\n", "senID": 4}, {"text": ["unicodedata.combining(c) will return true if the character c can be combined with the preceding character, that is mainly if it's a diacritic."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "unicodedata.combining(c)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Maybe this?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://packages.ubuntu.com/hardy/python/python-unac"}]}], [{"text": ["This is quite a good solution.", "Written in JavaScript but easily ported:\nhttp://semplicewebsites.com/removing-accents-javascript"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://semplicewebsites.com/removing-accents-javascript", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://semplicewebsites.com/removing-accents-javascript"}]}]]