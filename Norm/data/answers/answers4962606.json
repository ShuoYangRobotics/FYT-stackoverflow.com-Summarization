[[{"text": ["Here is how to do it with a single Python loop:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def rotT(T, g):\n    Tprime = T\n    for i in range(4):\n        slices = [None] * 4\n        slices[i] = slice(None)\n        slices *= 2\n        Tprime = g[slices].T * Tprime\n    return Tprime.sum(-1).sum(-1).sum(-1).sum(-1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Admittedly, this is a bit hard to grasp at first glance, but it's quite a bit faster :)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["To use tensordot, compute the outer product of the g tensors:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "tensordot", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "g", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def rotT(T, g):\n    gg = np.outer(g, g)\n    gggg = np.outer(gg, gg).reshape(4 * g.shape)\n    axes = ((0, 2, 4, 6), (0, 1, 2, 3))\n    return np.tensordot(gggg, T, axes)\n</code>\n</pre>\n", "senID": 1}, {"text": ["On my system, this is around seven times faster than Sven's solution.", "If the g tensor doesn't change often, you can also cache the gggg tensor.", "If you do this and turn on some micro-optimizations (inlining the tensordot code, no checks, no generic shapes), you can still make it two times faster:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "g", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "gggg", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "tensordot", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n def rotT(T, gggg):\n    return np.dot(gggg.transpose((1, 3, 5, 7, 0, 2, 4, 6)).reshape((81, 81)),\n                  T.reshape(81, 1)).reshape((3, 3, 3, 3))\n</code>\n</pre>\n", "senID": 3}, {"text": ["Results of timeit on my home laptop (500 iterations):"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "timeit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n Your original code: 19.471129179\nSven's code: 0.718412876129\nMy first code: 0.118047952652\nMy second code: 0.0690279006958\n</code>\n</pre>\n", "senID": 5}, {"text": ["The numbers on my work machine are:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n Your original code: 9.77922987938\nSven's code: 0.137110948563\nMy first code: 0.0569641590118\nMy second code: 0.0308079719543\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Out of curiosity I've compared Cython implementation of a naive code from the question with the numpy code from @Philipp's answer.", "Cython code is four times faster on my machine:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "Cython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/Cython/"}, {"text": "the question", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4962606/fast-tensor-rotation-with-numpy"}, {"text": "@Philipp's answer", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4962606/fast-tensor-rotation-with-numpy/4963113#4963113"}, {"text": "four times faster", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "https://gist.github.com/910aa19c6bc70874f974"}]}, {"code": "<pre>\n<code>\n #cython: boundscheck=False, wraparound=False\nimport numpy as np\ncimport numpy as np\n\ndef rotT(np.ndarray[np.float64_t, ndim=4] T,\n         np.ndarray[np.float64_t, ndim=2] g):\n    cdef np.ndarray[np.float64_t, ndim=4] Tprime\n    cdef Py_ssize_t i, j, k, l, ii, jj, kk, ll\n    cdef np.float64_t gg\n\n    Tprime = np.zeros((3,3,3,3), dtype=T.dtype)\n    for i in range(3):\n        for j in range(3):\n            for k in range(3):\n                for l in range(3):\n                    for ii in range(3):\n                        for jj in range(3):\n                            for kk in range(3):\n                                for ll in range(3):\n                                    gg = g[ii,i]*g[jj,j]*g[kk,k]*g[ll,l]\n                                    Tprime[i,j,k,l] = Tprime[i,j,k,l] + \\\n                                         gg*T[ii,jj,kk,ll]\n    return Tprime\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Thanks to hard work by M. Wiebe, the next version of Numpy (which will probably be 1.6) is going to make this even easier:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; Trot = np.einsum('ai,bj,ck,dl,abcd-&gt;ijkl', g, g, g, g, T)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Philipp's approach is at the moment 3x faster, though, but perhaps there is some room for improvement.", "The speed difference is probably mostly due to tensordot being able to unroll the whole operation as a single matrix product that can be passed on to BLAS, and so avoiding much of the overhead associated with small arrays --- this is not possible for general Einstein summation, as not all operations that can be expressed in this form resolve to a single matrix product."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]