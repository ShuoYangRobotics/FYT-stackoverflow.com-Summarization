[[{"text": ["As per comments, I've updated the code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import time\nimport math\n\ndef timeit1():\n    s = time.time()\n    for i in xrange(750000):\n        z=i**.5\n    print \"Took %f seconds\" % (time.time() - s)\n\ndef timeit2(arg=math.sqrt):\n    s = time.time()\n    for i in xrange(750000):\n        z=arg(i)\n    print \"Took %f seconds\" % (time.time() - s)\n\ntimeit1()\ntimeit2()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now the math.sqrt function is directly in a local argument, meaning it has the fastest lookup possible. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "math.sqrt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["UPDATE: The python version seems to matter here.", "I used to think that timeit1 would be faster, since when python parses \"i**.5\" it knows, syntactically, which method to call (__pow__ or some variant), so it doesn't have to go through the overhead of lookup that the math.sqrt variant does.", "But I might be wrong:"], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "UPDATE:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "timeit1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__pow__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "math.sqrt", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Python 2.5: 0.191000 vs. 0.224000"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Python 2.5:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Python 2.6: 0.195000 vs. 0.139000"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Python 2.6:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Also psyco seems to deal with math.sqrt better:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "math.sqrt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Python 2.5 + Psyco 2.0: 0.109000 vs. 0.043000"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Python 2.5 + Psyco 2.0:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Python 2.6 + Psyco 2.0: 0.128000 vs. 0.067000"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Python 2.6 + Psyco 2.0:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n | Interpreter    |  x**.5, |   sqrt, | sqrt faster, % |\n|                | seconds | seconds |                |\n|----------------+---------+---------+----------------|\n| Python 3.2rc1+ |    0.32 |    0.27 |             19 |\n| Python 3.1.2   |   0.136 |   0.088 |             55 |\n| Python 3.0.1   |   0.155 |   0.102 |             52 |\n| Python 2.7     |   0.132 |   0.079 |             67 |\n| Python 2.6.6   |   0.121 |   0.075 |             61 |\n| PyPy 1.4.1     |   0.083 |  0.0159 |            422 |\n| Jython 2.5.1   |   0.132 |    0.22 |            -40 |\n| Python 2.5.5   |   0.129 |   0.125 |              3 |\n| Python 2.4.6   |   0.131 |   0.123 |              7 |\n#+TBLFM: $4=100*($2-$3)/$3;%.0f\n</code>\n</pre>\n", "senID": 9}, {"text": ["Table results produced on machine:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n $ uname -vms\nLinux #42-Ubuntu SMP Thu Dec 2 02:41:37 UTC 2010 x86_64\n$ cat /proc/cpuinfo | grep 'model name' | head -1\nmodel name      : Intel(R) Core(TM) i7 CPU         920  @ 2.67GHz\n</code>\n</pre>\n", "senID": 11}, {"text": ["To reproduce results:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "get source: ", "tag": "none", "senID": 13}, {"text": "install ", "tag": "none", "senID": 14}, {"text": "run ", "tag": "none", "senID": 15}]}], [{"text": ["How many square roots are you really performing?", "Are you trying to write some 3D graphics engine in Python?", "If not, then why go with code which is cryptic over code that is easy to read?", "The time difference is would be less than anybody could notice in just about any application I could forsee.", "I really don't mean to put down your question, but it seems that you're going a little too far with premature optimization."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"tag": "ul", "num": 2, "lis": [{"text": "first rule of optimization: ", "tag": "none", "senID": 0}, {"text": "second rule: ", "tag": "none", "senID": 1}]}, {"text": ["Here's some timings (Python 2.5.2, Windows):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ python -mtimeit -s\"from math import sqrt; x = 123\" \"x**.5\"\n1000000 loops, best of 3: 0.445 usec per loop\n\n$ python -mtimeit -s\"from math import sqrt; x = 123\" \"sqrt(x)\"\n1000000 loops, best of 3: 0.574 usec per loop\n\n$ python -mtimeit -s\"import math; x = 123\" \"math.sqrt(x)\"\n1000000 loops, best of 3: 0.727 usec per loop\n</code>\n</pre>\n", "senID": 3}, {"text": ["This test shows that x**.5 is slightly faster than sqrt(x)."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "x**.5", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sqrt(x)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For the Python 3.0 the result is the opposite:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n $ \\Python30\\python -mtimeit -s\"from math import sqrt; x = 123\" \"x**.5\"\n1000000 loops, best of 3: 0.803 usec per loop\n\n$ \\Python30\\python -mtimeit -s\"from math import sqrt; x = 123\" \"sqrt(x)\"\n1000000 loops, best of 3: 0.695 usec per loop\n\n$ \\Python30\\python -mtimeit -s\"import math; x = 123\" \"math.sqrt(x)\"\n1000000 loops, best of 3: 0.761 usec per loop\n</code>\n</pre>\n", "senID": 6}, {"text": ["math.sqrt(x) is always faster than x**.5 on another machine (Ubuntu, Python 2.6 and 3.1):"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "math.sqrt(x)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x**.5", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n $ python -mtimeit -s\"from math import sqrt; x = 123\" \"x**.5\"\n10000000 loops, best of 3: 0.173 usec per loop\n$ python -mtimeit -s\"from math import sqrt; x = 123\" \"sqrt(x)\"\n10000000 loops, best of 3: 0.115 usec per loop\n$ python -mtimeit -s\"import math; x = 123\" \"math.sqrt(x)\"\n10000000 loops, best of 3: 0.158 usec per loop\n$ python3.1 -mtimeit -s\"from math import sqrt; x = 123\" \"x**.5\"\n10000000 loops, best of 3: 0.194 usec per loop\n$ python3.1 -mtimeit -s\"from math import sqrt; x = 123\" \"sqrt(x)\"\n10000000 loops, best of 3: 0.123 usec per loop\n$ python3.1 -mtimeit -s\"import math; x = 123\" \"math.sqrt(x)\"\n10000000 loops, best of 3: 0.157 usec per loop\n</code>\n</pre>\n", "senID": 8}], [{"text": ["In these micro-benchmarks, math.sqrt will be slower, because of the slight time it takes to lookup the sqrt in the math namespace.", "You can improve it slightly with "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from math import sqrt\n</code>\n</pre>\n", "senID": 1}, {"text": ["Even then though, running a few variations through timeit, show a slight (4-5%) performance advantage for \"x**.5\""], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["interestingly, doing"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import math\n sqrt = math.sqrt\n</code>\n</pre>\n", "senID": 4}, {"text": ["sped it up even more, to within 1% difference in speed, with very little statistical significance."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I will repeat Kibbee, and say that this is probably a premature optimization."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["using Claudiu's code, on my machine even with \"from math import sqrt\" x**.5 is faster but using psyco.full() sqrt(x) becomes much faster, at least by 200%"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Most likely math.sqrt(x), because it's optimized for square rooting."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Benchmarks will provide you the answer you are looking for."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["For what it's worth (see Jim's answer).", "On my machine, running python 2.5:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n PS C:\\&gt; python -m timeit -n 100000 10000**.5\n100000 loops, best of 3: 0.0543 usec per loop\nPS C:\\&gt; python -m timeit -n 100000 -s \"import math\" math.sqrt(10000)\n100000 loops, best of 3: 0.162 usec per loop\nPS C:\\&gt; python -m timeit -n 100000 -s \"from math import sqrt\" sqrt(10000)\n100000 loops, best of 3: 0.0541 usec per loop\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In python 2.6 the (float).__pow__()  function uses the C pow() function and the math.sqrt() functions uses the C sqrt() function."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "(float).__pow__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "pow()", "childNum": 0, "tag": "code", "childList": []}, {"text": "math.sqrt()", "childNum": 0, "tag": "code", "childList": []}, {"text": "sqrt()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In glibc compiler the implementation of pow(x,y) is quite complex and it is well optimized for various exceptional cases.", "For example, calling C pow(x,0.5) simply calls the sqrt() function."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "pow(x,y)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "pow(x,0.5)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "sqrt()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The difference in speed of using .", "** or math.sqrt is caused by the wrappers used around the C functions and the speed strongly depends on optimization flags/C compiler used on the system. "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": ".**", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "math.sqrt", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Here are the results of Claudiu's algorithm on my machine.", "I got different results:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n zoltan@host:~$ python2.4 p.py \nTook 0.173994 seconds\nTook 0.158991 seconds\nzoltan@host:~$ python2.5 p.py \nTook 0.182321 seconds\nTook 0.155394 seconds\nzoltan@host:~$ python2.6 p.py \nTook 0.166766 seconds\nTook 0.097018 seconds\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Someone commented about the \"fast Newton-Raphson square root\" from Quake 3...", "I implemented it with ctypes, but it's super slow in comparison to the native versions.", "I'm going to try a few optimizations and alternate implementations."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from ctypes import c_float, c_long, byref, POINTER, cast\n\ndef sqrt(num):\n xhalf = 0.5*num\n x = c_float(num)\n i = cast(byref(x), POINTER(c_long)).contents.value\n i = c_long(0x5f375a86 - (i&gt;&gt;1))\n x = cast(byref(i), POINTER(c_float)).contents.value\n\n x = x*(1.5-xhalf*x*x)\n x = x*(1.5-xhalf*x*x)\n return x * num\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here's another method using struct, comes out about 3.6x faster than the ctypes version, but still 1/10 the speed of C."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from struct import pack, unpack\n\ndef sqrt_struct(num):\n xhalf = 0.5*num\n i = unpack('L', pack('f', 28.0))[0]\n i = 0x5f375a86 - (i&gt;&gt;1)\n x = unpack('f', pack('L', i))[0]\n\n x = x*(1.5-xhalf*x*x)\n x = x*(1.5-xhalf*x*x)\n return x * num\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You might want to benchmark the fast Newton-Raphson square root as well.", "Shouldn't take much to convert to Python."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "fast Newton-Raphson square root", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.codemaestro.com/reviews/9"}]}], [{"text": ["Claudiu's results differ from mine.", "I'm using Python 2.6 on Ubuntu on an old P4 2.4Ghz machine...", "Here's my results:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; timeit1()\nTook 0.564911 seconds\n&gt;&gt;&gt; timeit2()\nTook 0.403087 seconds\n&gt;&gt;&gt; timeit1()\nTook 0.604713 seconds\n&gt;&gt;&gt; timeit2()\nTook 0.387749 seconds\n&gt;&gt;&gt; timeit1()\nTook 0.587829 seconds\n&gt;&gt;&gt; timeit2()\nTook 0.379381 seconds\n</code>\n</pre>\n", "senID": 1}, {"text": ["sqrt is consistently faster for me...", "Even Codepad.org NOW seems to agree that sqrt, in the local context, is faster (http://codepad.org/6trzcM3j).", "Codepad seems to be running Python 2.5 presently.", "Perhaps they were using 2.4 or older when Claudiu first answered?"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://codepad.org/6trzcM3j", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://codepad.org/6trzcM3j"}]}, {"text": ["In fact, even using math.sqrt(i) in place of arg(i), I still get better times for sqrt.", "In this case timeit2() took between 0.53 and 0.55 seconds on my machine, which is still better than the 0.56-0.60 figures from timeit1."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I'd say, on modern Python, use math.sqrt and definitely bring it to local context, either with somevar=math.sqrt or with from math import sqrt."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]