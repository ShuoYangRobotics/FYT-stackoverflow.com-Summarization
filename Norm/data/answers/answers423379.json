[[{"text": ["You can use a global variable in other functions by declaring it as global in each function that modifies it:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "global", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n globvar = 0\n\ndef set_globvar_to_one():\n    global globvar    # Needed to modify global copy of globvar\n    globvar = 1\n\ndef print_globvar():\n    print globvar     # No need for global declaration to read value of globvar\n\nset_globvar_to_one()\nprint_globvar()       # Prints 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["I imagine the reason for it is that, since global variables are so dangerous, Python wants to make sure that you really know that's what you're playing with by explicitly requiring the global keyword."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "global", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["See other answers if you want to share a global variable across modules."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If I'm understanding your situation correctly, what you're seeing is the result of how Python handles local (function) and global (module) namespaces."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Say you've got a module like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n ----- sample.py -----\nmyGlobal = 5\n\ndef func1():\n    myGlobal = 42\n\ndef func2():\n    print myGlobal\n\nfunc1()\nfunc2()\n</code>\n</pre>\n", "senID": 2}, {"text": ["You might expecting this to print 42, but instead it prints 5.", "As has already been mentioned, if you add a 'global' declaration to func1(), then func2() will print 42."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def func1():\n    global myGlobal\n    myGlobal = 42\n</code>\n</pre>\n", "senID": 4}, {"text": ["What's going on here is that Python assumes that any name that is assigned to, anywhere within a function, is local to that function unless explicitly told otherwise.", "If it is only reading from a name, and the name doesn't exist locally, it will try to look up the name in any containing scopes (e.g.", "the module's global scope)."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "assigned to", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "reading", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["When you assign 42 to the name myGlobal, therefore, Python creates a local variable that shadows the global variable of the same name.", "That local goes out of scope and is garbage-collected when func1() returns; meanwhile, func2() can never see anything other than the (unmodified) global name.", "Note that this namespace decision happens at compile time, not at runtime -- if you were read the value of myGlobal inside func1() before you assign to it, you'd get an UnboundLocalError, because Python has already decided that it must be a local variable but it has not had any value associated with it yet.", "But by using the 'global' statement, you tell Python that it should look elsewhere for the name instead of assigning to it locally."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["(I believe that this behavior originated largely through an optimization of local namespaces -- without this behavior,  Python's VM would need to perform at least three name lookups each time a new name is assigned to inside a function (to ensure that the name didn't already exist at module/builtin level), which would significantly slow down a very common operation."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["You may want to explore the notion of namespaces.", "In Python, the module is the natural place for global data:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "namespaces", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html"}, {"text": "module", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/modules.html"}, {"text": "global", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["A specific use of global-in-a-module is described here - how-do-i-share-global-variables-across-modules:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "how-do-i-share-global-variables-across-modules", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/pyfaq/how-do-i-share-global-variables-across-modules.htm"}]}, {"code": "<pre>\n<code>\n x = 0   # Default value of the 'x' configuration setting\n</code>\n</pre>\n", "senID": 2}, {"code": "<pre>\n<code>\n import config\nconfig.x = 1\n</code>\n</pre>\n", "senID": 3}, {"code": "<pre>\n<code>\n import config\nimport mod\nprint config.x\n</code>\n</pre>\n", "senID": 4}], [{"text": ["If you want to refer to global variable in a function, you can use global keyword to declare which variables are global.", "You don't have to use it in all cases (as someone here incorrectly claims) - if the name referenced in an expression cannot be found in local scope or scopes in the functions in which this function is defined, it is looked up among global variables.", "However, if you assign to a new variable not declared as global in the function, it is implicitly declared as local, and it can overshadow any existing global variable with the same name."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "global", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Also, global variables are useful, contrary to some OOP zealots who claim otherwise - especially for smaller scripts, where OOP is overkill."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I could ask just as properly why you're asking.", "Why do you believe the global is a better solution.", "Global shared state is a widely known source of common problems.", "Keep adding functions that manipulate global data and you'll quickly loose track what what might be causing some unexpected problem with it.", "Python's many design decisions are artifacts of understanding what keeps software understandable and crafting a language that encourages that wisdom."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Python uses a simple heuristic to decide which scope it should load a variable from, between local and global.", "If a variable name appears on the left hand side of an assignment, but is not declared global, it is assumed to be local.", "If it does not appear on the left hand side of an assignment, it is assumed to be global.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import dis\n&gt;&gt;&gt; def foo():\n...     global bar\n...     baz = 5\n...     print bar\n...     print baz\n...     print quux\n... \n&gt;&gt;&gt; dis.disassemble(foo.func_code)\n  3           0 LOAD_CONST               1 (5)\n              3 STORE_FAST               0 (baz)\n\n  4           6 LOAD_GLOBAL              0 (bar)\n              9 PRINT_ITEM          \n             10 PRINT_NEWLINE       \n\n  5          11 LOAD_FAST                0 (baz)\n             14 PRINT_ITEM          \n             15 PRINT_NEWLINE       \n\n  6          16 LOAD_GLOBAL              1 (quux)\n             19 PRINT_ITEM          \n             20 PRINT_NEWLINE       \n             21 LOAD_CONST               0 (None)\n             24 RETURN_VALUE        \n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["See how baz, which appears on the left side of an assignment in foo(), is the only LOAD_FAST variable."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "foo()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "LOAD_FAST", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You're not actually storing the global in a local variable, just creating a local reference to the same object that your original global reference refers to.", "Remember that pretty much everything in Python is a name referring to an object, and nothing gets copied in usual operation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you didn't have to explicitly specify when an identifier was to refer to a predefined global, then you'd presumably have to explicitly specify when an identifier is a new local variable instead (for example, with something like the 'var' command seen in JavaScript).", "Since local variables are more common than global variables in any serious and non-trivial system, Python's system makes more sense in most cases."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You could have a language which attempted to guess, using a global variable if it existed or creating a local variable if it didn't.", "However, that would be very error-prone.", "For example, importing another module could inadvertently introduce a global variable by that name, changing the behaviour of your program."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "could", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}]]