[[{"text": ["Warning: timeit results may vary due to differences in hardware or\nversion of Python.  "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Warning:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "timeit", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Below is a script which compares a number of implementations: \nambi_sieve_plain,rwh_primes,rwh_primes1,rwh_primes2,sieveOfAtkin,sieveOfEratosthenes,sundaram3,sieve_wheel_30,ambi_sieve(requires numpy)primesfrom3to(requires numpy)primesfrom2to(requires numpy)"], "childNum": 22, "tag": "p", "senID": 1, "childList": [{"text": "ambi_sieve_plain,rwh_primes,rwh_primes1,rwh_primes2,sieveOfAtkin,sieveOfEratosthenes,sundaram3,sieve_wheel_30,ambi_sieve(requires numpy)primesfrom3to(requires numpy)primesfrom2to(requires numpy)", "childNum": 21, "tag": "ul", "pos": 0, "childList": [{"text": "ambi_sieve_plain,", "tag": "li"}, {"text": "rwh_primes,", "tag": "li"}, {"text": "rwh_primes", "tag": "a"}, {"text": "rwh_primes1,", "tag": "li"}, {"text": "rwh_primes1", "tag": "a"}, {"text": "rwh_primes2,", "tag": "li"}, {"text": "rwh_primes2", "tag": "a"}, {"text": "sieveOfAtkin,", "tag": "li"}, {"text": "sieveOfAtkin", "tag": "a"}, {"text": "sieveOfEratosthenes,", "tag": "li"}, {"text": "sieveOfEratosthenes", "tag": "a"}, {"text": "sundaram3,", "tag": "li"}, {"text": "sundaram3", "tag": "a"}, {"text": "sieve_wheel_30,", "tag": "li"}, {"text": "sieve_wheel_30", "tag": "a"}, {"text": "ambi_sieve(requires numpy)", "tag": "li"}, {"text": "ambi_sieve", "tag": "a"}, {"text": "primesfrom3to(requires numpy)", "tag": "li"}, {"text": "primesfrom3to", "tag": "a"}, {"text": "primesfrom2to(requires numpy)", "tag": "li"}, {"text": "primesfrom2to", "tag": "a"}]}, {"text": "ambi_sieve_plain,", "childNum": 0, "tag": "li", "childList": []}, {"text": "rwh_primes,", "childNum": 1, "tag": "li", "childList": [{"text": "rwh_primes", "tag": "a"}]}, {"href": "http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188", "text": "rwh_primes", "childNum": 0, "tag": "a", "childList": []}, {"text": "rwh_primes1,", "childNum": 1, "tag": "li", "childList": [{"text": "rwh_primes1", "tag": "a"}]}, {"href": "http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188", "text": "rwh_primes1", "childNum": 0, "tag": "a", "childList": []}, {"text": "rwh_primes2,", "childNum": 1, "tag": "li", "childList": [{"text": "rwh_primes2", "tag": "a"}]}, {"href": "http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188", "text": "rwh_primes2", "childNum": 0, "tag": "a", "childList": []}, {"text": "sieveOfAtkin,", "childNum": 1, "tag": "li", "childList": [{"text": "sieveOfAtkin", "tag": "a"}]}, {"href": "http://krenzel.info/?p=83", "text": "sieveOfAtkin", "childNum": 0, "tag": "a", "childList": []}, {"text": "sieveOfEratosthenes,", "childNum": 1, "tag": "li", "childList": [{"text": "sieveOfEratosthenes", "tag": "a"}]}, {"href": "http://groups.google.com/group/comp.lang.python/msg/f1f10ced88c68c2d", "text": "sieveOfEratosthenes", "childNum": 0, "tag": "a", "childList": []}, {"text": "sundaram3,", "childNum": 1, "tag": "li", "childList": [{"text": "sundaram3", "tag": "a"}]}, {"href": "http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/2073279#2073279", "text": "sundaram3", "childNum": 0, "tag": "a", "childList": []}, {"text": "sieve_wheel_30,", "childNum": 1, "tag": "li", "childList": [{"text": "sieve_wheel_30", "tag": "a"}]}, {"href": "http://zerovolt.com/?p=88", "text": "sieve_wheel_30", "childNum": 0, "tag": "a", "childList": []}, {"text": "ambi_sieve(requires numpy)", "childNum": 1, "tag": "li", "childList": [{"text": "ambi_sieve", "tag": "a"}]}, {"href": "http://tommih.blogspot.com/2009/04/fast-prime-number-generator.html", "text": "ambi_sieve", "childNum": 0, "tag": "a", "childList": []}, {"text": "primesfrom3to(requires numpy)", "childNum": 1, "tag": "li", "childList": [{"text": "primesfrom3to", "tag": "a"}]}, {"href": "http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188", "text": "primesfrom3to", "childNum": 0, "tag": "a", "childList": []}, {"text": "primesfrom2to(requires numpy)", "childNum": 1, "tag": "li", "childList": [{"text": "primesfrom2to", "tag": "a"}]}, {"href": "http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188", "text": "primesfrom2to", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Many thanks to stephan for bringing sieve_wheel_30 to my attention.", "Credit goes to Robert William Hanks for primesfrom2to, primesfrom3to, rwh_primes, rwh_primes1, and rwh_primes2."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "stephan", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/92092/stephan"}, {"text": "Robert William Hanks", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188"}]}, {"text": ["Of the plain Python methods tested, with psyco, for n=1000000,\nrwh_primes1 was the fastest tested."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "with psyco", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "rwh_primes1", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n +---------------------+-------+\n| Method              | ms    |\n+---------------------+-------+\n| rwh_primes1         | 43.0  |\n| sieveOfAtkin        | 46.4  |\n| rwh_primes          | 57.4  |\n| sieve_wheel_30      | 63.0  |\n| rwh_primes2         | 67.8  |    \n| sieveOfEratosthenes | 147.0 |\n| ambi_sieve_plain    | 152.0 |\n| sundaram3           | 194.0 |\n+---------------------+-------+\n</code>\n</pre>\n", "senID": 4}, {"text": ["Of the plain Python methods tested, without psyco, for n=1000000,\nrwh_primes2 was the fastest."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "without psyco", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "rwh_primes2", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n +---------------------+-------+\n| Method              | ms    |\n+---------------------+-------+\n| rwh_primes2         | 68.1  |\n| rwh_primes1         | 93.7  |\n| rwh_primes          | 94.6  |\n| sieve_wheel_30      | 97.4  |\n| sieveOfEratosthenes | 178.0 |\n| ambi_sieve_plain    | 286.0 |\n| sieveOfAtkin        | 314.0 |\n| sundaram3           | 416.0 |\n+---------------------+-------+\n</code>\n</pre>\n", "senID": 6}, {"text": ["Of all the methods tested, allowing numpy, for n=1000000,\nprimesfrom2to was the fastest tested."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "allowing numpy", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "primesfrom2to", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n +---------------------+-------+\n| Method              | ms    |\n+---------------------+-------+\n| primesfrom2to       | 15.9  |\n| primesfrom3to       | 18.4  |\n| ambi_sieve          | 29.3  |\n+---------------------+-------+\n</code>\n</pre>\n", "senID": 8}, {"text": ["Timings were measured using the command:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n python -mtimeit -s\"import primes\" \"primes.{method}(10000000)\"\n</code>\n</pre>\n", "senID": 10}, {"text": ["with {method} replaced by each of the method names."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "{method}", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["primes.py:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nimport psyco; psyco.full()\nfrom math import sqrt, ceil\nimport numpy as np\n\ndef rwh_primes(n):\n    # http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Returns  a list of primes &lt; n \"\"\"\n    sieve = [True] * n\n    for i in xrange(3,int(n**0.5)+1,2):\n        if sieve[i]:\n            sieve[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1)\n    return [2] + [i for i in xrange(3,n,2) if sieve[i]]\n\ndef rwh_primes1(n):\n    # http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Returns  a list of primes &lt; n \"\"\"\n    sieve = [True] * (n/2)\n    for i in xrange(3,int(n**0.5)+1,2):\n        if sieve[i/2]:\n            sieve[i*i/2::i] = [False] * ((n-i*i-1)/(2*i)+1)\n    return [2] + [2*i+1 for i in xrange(1,n/2) if sieve[i]]\n\ndef rwh_primes2(n):\n    # http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Input n&gt;=6, Returns a list of primes, 2 &lt;= p &lt; n \"\"\"\n    correction = (n%6&gt;1)\n    n = {0:n,1:n-1,2:n+4,3:n+3,4:n+2,5:n+1}[n%6]\n    sieve = [True] * (n/3)\n    sieve[0] = False\n    for i in xrange(int(n**0.5)/3+1):\n      if sieve[i]:\n        k=3*i+1|1\n        sieve[      ((k*k)/3)      ::2*k]=[False]*((n/6-(k*k)/6-1)/k+1)\n        sieve[(k*k+4*k-2*k*(i&amp;1))/3::2*k]=[False]*((n/6-(k*k+4*k-2*k*(i&amp;1))/6-1)/k+1)\n    return [2,3] + [3*i+1|1 for i in xrange(1,n/3-correction) if sieve[i]]\n\ndef sieve_wheel_30(N):\n    # http://zerovolt.com/?p=88\n    ''' Returns a list of primes &lt;= N using wheel criterion 2*3*5 = 30\n\nCopyright 2009 by zerovolt.com\nThis code is free for non-commercial purposes, in which case you can just leave this comment as a credit for my work.\nIf you need this code for commercial purposes, please contact me by sending an email to: info [at] zerovolt [dot] com.'''\n    __smallp = ( 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59,\n    61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139,\n    149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,\n    229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,\n    313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401,\n    409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491,\n    499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,\n    601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683,\n    691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,\n    809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,\n    907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997)\n\n    wheel = (2, 3, 5)\n    const = 30\n    if N &lt; 2:\n        return []\n    if N &lt;= const:\n        pos = 0\n        while __smallp[pos] &lt;= N:\n            pos += 1\n        return list(__smallp[:pos])\n    # make the offsets list\n    offsets = (7, 11, 13, 17, 19, 23, 29, 1)\n    # prepare the list\n    p = [2, 3, 5]\n    dim = 2 + N // const\n    tk1  = [True] * dim\n    tk7  = [True] * dim\n    tk11 = [True] * dim\n    tk13 = [True] * dim\n    tk17 = [True] * dim\n    tk19 = [True] * dim\n    tk23 = [True] * dim\n    tk29 = [True] * dim\n    tk1[0] = False\n    # help dictionary d\n    # d[a , b] = c  ==&gt; if I want to find the smallest useful multiple of (30*pos)+a\n    # on tkc, then I need the index given by the product of [(30*pos)+a][(30*pos)+b]\n    # in general. If b &lt; a, I need [(30*pos)+a][(30*(pos+1))+b]\n    d = {}\n    for x in offsets:\n        for y in offsets:\n            res = (x*y) % const\n            if res in offsets:\n                d[(x, res)] = y\n    # another help dictionary: gives tkx calling tmptk[x]\n    tmptk = {1:tk1, 7:tk7, 11:tk11, 13:tk13, 17:tk17, 19:tk19, 23:tk23, 29:tk29}\n    pos, prime, lastadded, stop = 0, 0, 0, int(ceil(sqrt(N)))\n    # inner functions definition\n    def del_mult(tk, start, step):\n        for k in xrange(start, len(tk), step):\n            tk[k] = False\n    # end of inner functions definition\n    cpos = const * pos\n    while prime &lt; stop:\n        # 30k + 7\n        if tk7[pos]:\n            prime = cpos + 7\n            p.append(prime)\n            lastadded = 7\n            for off in offsets:\n                tmp = d[(7, off)]\n                start = (pos + prime) if off == 7 else (prime * (const * (pos + 1 if tmp &lt; 7 else 0) + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n        # 30k + 11\n        if tk11[pos]:\n            prime = cpos + 11\n            p.append(prime)\n            lastadded = 11\n            for off in offsets:\n                tmp = d[(11, off)]\n                start = (pos + prime) if off == 11 else (prime * (const * (pos + 1 if tmp &lt; 11 else 0) + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n        # 30k + 13\n        if tk13[pos]:\n            prime = cpos + 13\n            p.append(prime)\n            lastadded = 13\n            for off in offsets:\n                tmp = d[(13, off)]\n                start = (pos + prime) if off == 13 else (prime * (const * (pos + 1 if tmp &lt; 13 else 0) + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n        # 30k + 17\n        if tk17[pos]:\n            prime = cpos + 17\n            p.append(prime)\n            lastadded = 17\n            for off in offsets:\n                tmp = d[(17, off)]\n                start = (pos + prime) if off == 17 else (prime * (const * (pos + 1 if tmp &lt; 17 else 0) + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n        # 30k + 19\n        if tk19[pos]:\n            prime = cpos + 19\n            p.append(prime)\n            lastadded = 19\n            for off in offsets:\n                tmp = d[(19, off)]\n                start = (pos + prime) if off == 19 else (prime * (const * (pos + 1 if tmp &lt; 19 else 0) + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n        # 30k + 23\n        if tk23[pos]:\n            prime = cpos + 23\n            p.append(prime)\n            lastadded = 23\n            for off in offsets:\n                tmp = d[(23, off)]\n                start = (pos + prime) if off == 23 else (prime * (const * (pos + 1 if tmp &lt; 23 else 0) + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n        # 30k + 29\n        if tk29[pos]:\n            prime = cpos + 29\n            p.append(prime)\n            lastadded = 29\n            for off in offsets:\n                tmp = d[(29, off)]\n                start = (pos + prime) if off == 29 else (prime * (const * (pos + 1 if tmp &lt; 29 else 0) + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n        # now we go back to top tk1, so we need to increase pos by 1\n        pos += 1\n        cpos = const * pos\n        # 30k + 1\n        if tk1[pos]:\n            prime = cpos + 1\n            p.append(prime)\n            lastadded = 1\n            for off in offsets:\n                tmp = d[(1, off)]\n                start = (pos + prime) if off == 1 else (prime * (const * pos + tmp) )//const\n                del_mult(tmptk[off], start, prime)\n    # time to add remaining primes\n    # if lastadded == 1, remove last element and start adding them from tk1\n    # this way we don't need an \"if\" within the last while\n    if lastadded == 1:\n        p.pop()\n    # now complete for every other possible prime\n    while pos &lt; len(tk1):\n        cpos = const * pos\n        if tk1[pos]: p.append(cpos + 1)\n        if tk7[pos]: p.append(cpos + 7)\n        if tk11[pos]: p.append(cpos + 11)\n        if tk13[pos]: p.append(cpos + 13)\n        if tk17[pos]: p.append(cpos + 17)\n        if tk19[pos]: p.append(cpos + 19)\n        if tk23[pos]: p.append(cpos + 23)\n        if tk29[pos]: p.append(cpos + 29)\n        pos += 1\n    # remove exceeding if present\n    pos = len(p) - 1\n    while p[pos] &gt; N:\n        pos -= 1\n    if pos &lt; len(p) - 1:\n        del p[pos+1:]\n    # return p list\n    return p\n\ndef sieveOfEratosthenes(n):\n    \"\"\"sieveOfEratosthenes(n): return the list of the primes &lt; n.\"\"\"\n    # Code from: &lt;dickinsm@gmail.com&gt;, Nov 30 2006\n    # http://groups.google.com/group/comp.lang.python/msg/f1f10ced88c68c2d\n    if n &lt;= 2:\n        return []\n    sieve = range(3, n, 2)\n    top = len(sieve)\n    for si in sieve:\n        if si:\n            bottom = (si*si - 3) // 2\n            if bottom &gt;= top:\n                break\n            sieve[bottom::si] = [0] * -((bottom - top) // si)\n    return [2] + [el for el in sieve if el]\n\ndef sieveOfAtkin(end):\n    \"\"\"sieveOfAtkin(end): return a list of all the prime numbers &lt;end\n    using the Sieve of Atkin.\"\"\"\n    # Code by Steve Krenzel, &lt;Sgk284@gmail.com&gt;, improved\n    # Code: http://krenzel.info/?p=83\n    # Info: http://en.wikipedia.org/wiki/Sieve_of_Atkin\n    assert end &gt; 0\n    lng = ((end-1) // 2)\n    sieve = [False] * (lng + 1)\n\n    x_max, x2, xd = int(sqrt((end-1)/4.0)), 0, 4\n    for xd in xrange(4, 8*x_max + 2, 8):\n        x2 += xd\n        y_max = int(sqrt(end-x2))\n        n, n_diff = x2 + y_max*y_max, (y_max &lt;&lt; 1) - 1\n        if not (n &amp; 1):\n            n -= n_diff\n            n_diff -= 2\n        for d in xrange((n_diff - 1) &lt;&lt; 1, -1, -8):\n            m = n % 12\n            if m == 1 or m == 5:\n                m = n &gt;&gt; 1\n                sieve[m] = not sieve[m]\n            n -= d\n\n    x_max, x2, xd = int(sqrt((end-1) / 3.0)), 0, 3\n    for xd in xrange(3, 6 * x_max + 2, 6):\n        x2 += xd\n        y_max = int(sqrt(end-x2))\n        n, n_diff = x2 + y_max*y_max, (y_max &lt;&lt; 1) - 1\n        if not(n &amp; 1):\n            n -= n_diff\n            n_diff -= 2\n        for d in xrange((n_diff - 1) &lt;&lt; 1, -1, -8):\n            if n % 12 == 7:\n                m = n &gt;&gt; 1\n                sieve[m] = not sieve[m]\n            n -= d\n\n    x_max, y_min, x2, xd = int((2 + sqrt(4-8*(1-end)))/4), -1, 0, 3\n    for x in xrange(1, x_max + 1):\n        x2 += xd\n        xd += 6\n        if x2 &gt;= end: y_min = (((int(ceil(sqrt(x2 - end))) - 1) &lt;&lt; 1) - 2) &lt;&lt; 1\n        n, n_diff = ((x*x + x) &lt;&lt; 1) - 1, (((x-1) &lt;&lt; 1) - 2) &lt;&lt; 1\n        for d in xrange(n_diff, y_min, -8):\n            if n % 12 == 11:\n                m = n &gt;&gt; 1\n                sieve[m] = not sieve[m]\n            n += d\n\n    primes = [2, 3]\n    if end &lt;= 3:\n        return primes[:max(0,end-2)]\n\n    for n in xrange(5 &gt;&gt; 1, (int(sqrt(end))+1) &gt;&gt; 1):\n        if sieve[n]:\n            primes.append((n &lt;&lt; 1) + 1)\n            aux = (n &lt;&lt; 1) + 1\n            aux *= aux\n            for k in xrange(aux, end, 2 * aux):\n                sieve[k &gt;&gt; 1] = False\n\n    s  = int(sqrt(end)) + 1\n    if s  % 2 == 0:\n        s += 1\n    primes.extend([i for i in xrange(s, end, 2) if sieve[i &gt;&gt; 1]])\n\n    return primes\n\ndef ambi_sieve_plain(n):\n    s = range(3, n, 2)\n    for m in xrange(3, int(n**0.5)+1, 2): \n        if s[(m-3)/2]: \n            for t in xrange((m*m-3)/2,(n&gt;&gt;1)-1,m):\n                s[t]=0\n    return [2]+[t for t in s if t&gt;0]\n\ndef sundaram3(max_n):\n    # http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/2073279#2073279\n    numbers = range(3, max_n+1, 2)\n    half = (max_n)//2\n    initial = 4\n\n    for step in xrange(3, max_n+1, 2):\n        for i in xrange(initial, half, step):\n            numbers[i-1] = 0\n        initial += 2*(step+1)\n\n        if initial &gt; half:\n            return [2] + filter(None, numbers)\n\n################################################################################\n# Using Numpy:\ndef ambi_sieve(n):\n    # http://tommih.blogspot.com/2009/04/fast-prime-number-generator.html\n    s = np.arange(3, n, 2)\n    for m in xrange(3, int(n ** 0.5)+1, 2): \n        if s[(m-3)/2]: \n            s[(m*m-3)/2::m]=0\n    return np.r_[2, s[s&gt;0]]\n\ndef primesfrom3to(n):\n    # http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Returns a array of primes, p &lt; n \"\"\"\n    assert n&gt;=2\n    sieve = np.ones(n/2, dtype=np.bool)\n    for i in xrange(3,int(n**0.5)+1,2):\n        if sieve[i/2]:\n            sieve[i*i/2::i] = False\n    return np.r_[2, 2*np.nonzero(sieve)[0][1::]+1]    \n\ndef primesfrom2to(n):\n    # http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188\n    \"\"\" Input n&gt;=6, Returns a array of primes, 2 &lt;= p &lt; n \"\"\"\n    sieve = np.ones(n/3 + (n%6==2), dtype=np.bool)\n    sieve[0] = False\n    for i in xrange(int(n**0.5)/3+1):\n        if sieve[i]:\n            k=3*i+1|1\n            sieve[      ((k*k)/3)      ::2*k] = False\n            sieve[(k*k+4*k-2*k*(i&amp;1))/3::2*k] = False\n    return np.r_[2,3,((3*np.nonzero(sieve)[0]+1)|1)]\n\nif __name__=='__main__':\n    import itertools\n    import sys\n\n    def test(f1,f2,num):\n        print('Testing {f1} and {f2} return same results'.format(\n            f1=f1.func_name,\n            f2=f2.func_name))\n        if not all([a==b for a,b in itertools.izip_longest(f1(num),f2(num))]):\n            sys.exit(\"Error: %s(%s) != %s(%s)\"%(f1.func_name,num,f2.func_name,num))\n\n    n=1000000\n    test(sieveOfAtkin,sieveOfEratosthenes,n)\n    test(sieveOfAtkin,ambi_sieve,n)\n    test(sieveOfAtkin,ambi_sieve_plain,n) \n    test(sieveOfAtkin,sundaram3,n)\n    test(sieveOfAtkin,sieve_wheel_30,n)\n    test(sieveOfAtkin,primesfrom3to,n)\n    test(sieveOfAtkin,primesfrom2to,n)\n    test(sieveOfAtkin,rwh_primes,n)\n    test(sieveOfAtkin,rwh_primes1,n)         \n    test(sieveOfAtkin,rwh_primes2,n)\n</code>\n</pre>\n", "senID": 13}, {"text": ["Running the script tests that all implementations give the same result."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}], [{"text": ["There's a pretty neat sample from the Python Cookbook here -- the fastest version proposed on that URL is:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://oreilly.com/pub/a/python/excerpt/pythonckbk_chap1/index1.html?page=last"}]}, {"code": "<pre>\n<code>\n import itertools\ndef erat2( ):\n    D = {  }\n    yield 2\n    for q in itertools.islice(itertools.count(3), 0, None, 2):\n        p = D.pop(q, None)\n        if p is None:\n            D[q*q] = q\n            yield q\n        else:\n            x = p + q\n            while x in D or not (x&amp;1):\n                x += p\n            D[x] = p\n</code>\n</pre>\n", "senID": 1}, {"text": ["so that would give"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n get_primes_erat(n):\n  return list(itertools.takewhile(lambda p: p&lt;n, erat2()))\n</code>\n</pre>\n", "senID": 3}, {"text": ["Measuring at the shell prompt (as I prefer to do) with this code in pri.py, I observe:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n $ python2.5 -mtimeit -s'import pri' 'pri.get_primes(1000000)'\n10 loops, best of 3: 1.69 sec per loop\n$ python2.5 -mtimeit -s'import pri' 'pri.get_primes_erat(1000000)'\n10 loops, best of 3: 673 msec per loop\n</code>\n</pre>\n", "senID": 5}, {"text": ["so it looks like the Cookbook solution is over twice as fast."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Related question(dealing with primes generators &amp; including benchmarks):\nSpeed up bitstring/bit operations in Python? "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/2897297/speed-up-bitstring-bit-operations-in-python", "text": "Speed up bitstring/bit operations in Python?", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Faster &amp; more memory-wise pure Python code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def primes(n):\n    \"\"\" Returns  a list of primes &lt; n \"\"\"\n    sieve = [True] * n\n    for i in xrange(3,int(n**0.5)+1,2):\n        if sieve[i]:\n            sieve[i*i::2*i]=[False]*((n-i*i-1)/(2*i)+1)\n    return [2] + [i for i in xrange(3,n,2) if sieve[i]]\n</code>\n</pre>\n", "senID": 2}, {"text": ["or starting with half sieve"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def primes1(n):\n    \"\"\" Returns  a list of primes &lt; n \"\"\"\n    sieve = [True] * (n/2)\n    for i in xrange(3,int(n**0.5)+1,2):\n        if sieve[i/2]:\n            sieve[i*i/2::i] = [False] * ((n-i*i-1)/(2*i)+1)\n    return [2] + [2*i+1 for i in xrange(1,n/2) if sieve[i]]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Faster &amp; more memory-wise numpy code:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import numpy\ndef primesfrom3to(n):\n    \"\"\" Returns a array of primes, 3 &lt;= p &lt; n \"\"\"\n    sieve = numpy.ones(n/2, dtype=numpy.bool)\n    for i in xrange(3,int(n**0.5)+1,2):\n        if sieve[i/2]:\n            sieve[i*i/2::i] = False\n    return 2*numpy.nonzero(sieve)[0][1::]+1\n</code>\n</pre>\n", "senID": 6}, {"text": ["a faster variation starting with a third of a sieve:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import numpy\ndef primesfrom2to(n):\n    \"\"\" Input n&gt;=6, Returns a array of primes, 2 &lt;= p &lt; n \"\"\"\n    sieve = numpy.ones(n/3 + (n%6==2), dtype=numpy.bool)\n    for i in xrange(1,int(n**0.5)/3+1):\n        if sieve[i]:\n            k=3*i+1|1\n            sieve[       k*k/3     ::2*k] = False\n            sieve[k*(k-2*(i&amp;1)+4)/3::2*k] = False\n    return numpy.r_[2,3,((3*numpy.nonzero(sieve)[0][1:]+1)|1)]\n</code>\n</pre>\n", "senID": 8}, {"text": ["A (hard-to-code) pure-python version of the above code would be:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n def primes2(n):\n    \"\"\" Input n&gt;=6, Returns a list of primes, 2 &lt;= p &lt; n \"\"\"\n    n, correction = n-n%6+6, 2-(n%6&gt;1)\n    sieve = [True] * (n/3)\n    for i in xrange(1,int(n**0.5)/3+1):\n      if sieve[i]:\n        k=3*i+1|1\n        sieve[      k*k/3      ::2*k] = [False] * ((n/6-k*k/6-1)/k+1)\n        sieve[k*(k-2*(i&amp;1)+4)/3::2*k] = [False] * ((n/6-k*(k-2*(i&amp;1)+4)/6-1)/k+1)\n    return [2,3] + [3*i+1|1 for i in xrange(1,n/3-correction) if sieve[i]]\n</code>\n</pre>\n", "senID": 10}, {"text": ["Unfortunately pure-python don't adopt the simpler and faster numpy way of doing Assignment, and calling len() inside the loop as in [False]*len(sieve[((k*k)/3)::2*k]) is too slow.", "So i had to improvise to correct input (&amp; avoid more math) and do some extreme (&amp; painful) math-magic.", "Personally i think it is a shame that numpy (which is so widely used) is not part of python standard library(2 years after python 3 release &amp; no numpy compatibility), and that the improvements in syntax and speed seem to be completely overlooked by python developers."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}], [{"text": ["For truly fastest solution with sufficiently large N would be to download a pre-calculated list of primes, store it as a tuple and do something like:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "truly", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://primes.utm.edu/lists/small/millions/", "text": "pre-calculated list of primes", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n for pos,i in enumerate(primes):\n    if i &gt; N:\n        print primes[:pos]\n</code>\n</pre>\n", "senID": 1}, {"text": ["If N &gt; primes[-1] only then calculate more primes and save the new list in your code, so next time it is equally as fast."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "N &gt; primes[-1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "only", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Always think outside the box."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Always think outside the box.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["The algorithm is fast, but it has a serious flaw:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sorted(get_primes(530))\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\n79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163,\n167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251,\n257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349,\n353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443,\n449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 527, 529]\n&gt;&gt;&gt; 17*31\n527\n&gt;&gt;&gt; 23*23\n529\n</code>\n</pre>\n", "senID": 1}, {"text": ["You assume that numbers.pop() would return the smallest number in the set, but this is not guaranteed at all.", "Sets are unordered and pop() removes and returns an arbitrary element, so it cannot be used to select the next prime from the remaining numbers."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "numbers.pop()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "pop()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://docs.python.org/library/stdtypes.html#set.pop", "text": "arbitrary", "childNum": 1, "tag": "a", "childList": [{"text": "arbitrary", "tag": "strong"}]}, {"text": "arbitrary", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["Using Sundaram's Sieve, I think I broke pure-Python's record:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Sundaram's Sieve", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://plus.maths.org/issue50/features/havil/index.html"}]}, {"code": "<pre>\n<code>\n def sundaram3(max_n):\n    numbers = range(3, max_n+1, 2)\n    half = (max_n)//2\n    initial = 4\n\n    for step in xrange(3, max_n+1, 2):\n        for i in xrange(initial, half, step):\n            numbers[i-1] = 0\n        initial += 2*(step+1)\n\n        if initial &gt; half:\n            return [2] + filter(None, numbers)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Comparasion:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n C:\\USERS&gt;python -m timeit -n10 -s \"import get_primes\" \"get_primes.get_primes_erat(1000000)\"\n10 loops, best of 3: 710 msec per loop\n\nC:\\USERS&gt;python -m timeit -n10 -s \"import get_primes\" \"get_primes.daniel_sieve_2(1000000)\"\n10 loops, best of 3: 435 msec per loop\n\nC:\\USERS&gt;python -m timeit -n10 -s \"import get_primes\" \"get_primes.sundaram3(1000000)\"\n10 loops, best of 3: 327 msec per loop\n</code>\n</pre>\n", "senID": 3}], [{"text": ["A deterministic implementation of Miller-Rabin's Primality test on the assumption that N &lt; 9,080,191"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\nimport random\n\ndef miller_rabin_pass(a, n):\n    d = n - 1\n    s = 0\n    while d % 2 == 0:\n        d &gt;&gt;= 1\n        s += 1\n\n    a_to_power = pow(a, d, n)\n    if a_to_power == 1:\n        return True\n    for i in xrange(s-1):\n        if a_to_power == n - 1:\n            return True\n        a_to_power = (a_to_power * a_to_power) % n\n    return a_to_power == n - 1\n\n\ndef miller_rabin(n):\n    for a in [2, 3, 37, 73]:\n      if not miller_rabin_pass(a, n):\n        return False\n    return True\n\n\nn = int(sys.argv[1])\nprimes = [2]\nfor p in range(3,n,2):\n  if miller_rabin(p):\n    primes.append(p)\nprint len(primes)\n</code>\n</pre>\n", "senID": 1}, {"text": ["According to the article on Wikipedia (http://en.wikipedia.org/wiki/Miller\u2013Rabin_primality_test) testing N &lt; 9,080,191 for a = 2,3,37, and 73 is enough to decide whether N is composite or not."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["And I adapted the source code from the probabilistic implementation of original Miller-Rabin's test found here: http://en.literateprograms.org/Miller-Rabin_primality_test_(Python)"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://en.literateprograms.org/Miller-Rabin_primality_test_(Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.literateprograms.org/Miller-Rabin_primality_test_(Python"}]}], [{"text": ["For the fastest code, the numpy solution is the best.", "For purely academic reasons, though, I'm posting my pure python version, which is a bit less than 50% faster than the cookbook version posted above.", "Since I make the entire list in memory, you need enough space to hold everything, but it seems to scale fairly well."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def daniel_sieve_2(maxNumber):\n    \"\"\"\n    Given a number, returns all numbers less than or equal to\n    that number which are prime.\n    \"\"\"\n    allNumbers = range(3, maxNumber+1, 2)\n    for mIndex, number in enumerate(xrange(3, maxNumber+1, 2)):\n        if allNumbers[mIndex] == 0:\n            continue\n        # now set all multiples to 0\n        for index in xrange(mIndex+number, (maxNumber-3)/2+1, number):\n            allNumbers[index] = 0\n    return [2] + filter(lambda n: n!=0, allNumbers)\n</code>\n</pre>\n", "senID": 1}, {"text": ["And the results:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;mine = timeit.Timer(\"daniel_sieve_2(1000000)\",\n...                    \"from sieves import daniel_sieve_2\")\n&gt;&gt;&gt;prev = timeit.Timer(\"get_primes_erat(1000000)\",\n...                    \"from sieves import get_primes_erat\")\n&gt;&gt;&gt;print \"Mine: {0:0.4f} ms\".format(min(mine.repeat(3, 1))*1000)\nMine: 428.9446 ms\n&gt;&gt;&gt;print \"Previous Best {0:0.4f} ms\".format(min(prev.repeat(3, 1))*1000)\nPrevious Best 621.3581 ms\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If you have control over N, the very fastest way to list all primes is to precompute them.", "Seriously.", "Precomputing is a way overlooked optimization."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["A slightly different implementation of a half sieve using Numpy:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://rebrained.com/?p=458"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://rebrained.com/?p=458", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://rebrained.com/?p=458"}]}, {"code": "<pre>\nimport math\nimport numpy\ndef prime6(upto):\n    primes=numpy.arange(3,upto+1,2)\n    isprime=numpy.ones((upto-1)/2,dtype=bool)\n    for factor in primes[:int(math.sqrt(upto))]:\n        if isprime[(factor-2)/2]: isprime[(factor*3-2)/2:(upto-1)/2:factor]=0\n    return numpy.insert(primes[isprime],0,2)\n</pre>\n", "senID": 2}, {"text": ["Can someone compare this with the other timings?", "On my machine it seems pretty comparable to the other Numpy half-sieve."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["What size of primes do you want?", "There are some very fast statistical algorithms out there (eg Miller-Rabin), but their overheads mean they turn out slower unless dealing with very big (over 2^64) numbers.."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In general if you need fast number computation python is not the best choice.", "Today there are a lot of faster (and complex) algorithm.", "For example on my computer I got 2.2 second for your code, with Mathematica I got 0.088005."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First of all: do you need set?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The easiest optimization to implement is that if you want to check whether n is prime, you only have to check to see if n is divisible by a number up to square_root(n).", "Is this for Project Euler?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Here's the code I normally use to generate primes in Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'import sieve' 'sieve.sieve(1000000)' \n10 loops, best of 3: 445 msec per loop\n$ cat sieve.py\nfrom math import sqrt\n\ndef sieve(size):\n prime=[True]*size\n rng=xrange\n limit=int(sqrt(size))\n\n for i in rng(3,limit+1,+2):\n  if prime[i]:\n   prime[i*i::+i]=[False]*len(prime[i*i::+i])\n\n return [2]+[i for i in rng(3,size,+2) if prime[i]]\n\nif __name__=='__main__':\n print sieve(100)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It can't compete with the faster solutions posted here, but at least it is pure python."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Thanks for posting this question.", "I really learnt a lot today. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["My guess is that the fastest of all ways is to hard code the primes in your code."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "fastest", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["So why not just write a slow script that generates another source file that has all numbers hardwired in it, and then import that source file when you run your actual program."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Of course, this works only if you know the upper bound of N at compile time, but thus is the case for (almost) all project Euler problems. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["&nbsp;"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["PS: I might be wrong though iff parsing the source with hard-wired primes is slower than computing them in the first place, but as far I know Python runs from compiled.pycfiles so reading a binary array with all primes up to N should be bloody fast in that case."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "PS:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "I might be wrong though iff parsing the source with hard-wired primes is slower than computing them in the first place, but as far I know Python runs from compiled.pycfiles so reading a binary array with all primes up to N should be bloody fast in that case.", "childNum": 1, "tag": "em", "childList": [{"text": ".pyc", "tag": "code"}]}, {"text": ".pyc", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Sorry to bother but erat2() has a serious flaw in the algorithm."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["While searching for the next composite, we need to test odd numbers only.", "q,p both are odd; then q+p is even and doesn't need to be tested, but q+2*p is always odd.", "This eliminates the \"if even\" test in the while loop condition and saves about 30% of the runtime."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["While we're at it: instead of the elegant 'D.pop(q,None)' get and delete method use 'if q in D: p=D[q],del D[q]' which is twice as fast!", "At least on my machine (P3-1Ghz).", "So I suggest this implementation of this clever algorithm:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def erat3( ):\n    from itertools import islice, count\n\n    # q is the running integer that's checked for primeness.\n    # yield 2 and no other even number thereafter\n    yield 2\n    D = {}\n    # no need to mark D[4] as we will test odd numbers only\n    for q in islice(count(3),0,None,2):\n        if q in D:                  #  is composite\n            p = D[q]\n            del D[q]\n            # q is composite. p=D[q] is the first prime that\n            # divides it. Since we've reached q, we no longer\n            # need it in the map, but we'll mark the next\n            # multiple of its witnesses to prepare for larger\n            # numbers.\n            x = q + p+p        # next odd(!) multiple\n            while x in D:      # skip composites\n                x += p+p\n            D[x] = p\n        else:                  # is prime\n            # q is a new prime.\n            # Yield it and mark its first multiple that isn't\n            # already marked in previous iterations.\n            D[q*q] = q\n            yield q\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The fastest method I've tried so far is based on the Python cookbookerat2 function:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Python cookbookerat2", "tag": "a", "pos": 0, "childList": [{"text": "erat2", "tag": "code"}], "childNum": 1, "href": "http://oreilly.com/pub/a/python/excerpt/pythonckbk_chap1/index1.html?page=last"}, {"text": "erat2", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import itertools as it\ndef erat2a( ):\n    D = {  }\n    yield 2\n    for q in it.islice(it.count(3), 0, None, 2):\n        p = D.pop(q, None)\n        if p is None:\n            D[q*q] = q\n            yield q\n        else:\n            x = q + 2*p\n            while x in D:\n                x += 2*p\n            D[x] = p\n</code>\n</pre>\n", "senID": 1}, {"text": ["See this answer for an explanation of the speeding-up."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2211990/how-to-implement-an-efficient-infinite-generator-of-prime-numbers-in-python/3796442#3796442"}]}]]