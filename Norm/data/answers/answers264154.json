[[{"text": ["Starting with Version 1.3.6 (released Aug-17-2010) you CAN "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "CAN", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["From the changelog:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "From the changelog:", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/googleappengine/wiki/SdkReleaseNotes#Version_1.3.6_-_August_17,_2010"}]}], [{"text": ["Every time this comes up as a limitation, I always wonder \"why do you need more than 1,000 results?", "\"  Did you know that Google themselves doesn't serve up more than 1,000 results?", "Try this search:  http://www.google.ca/search?hl=en&amp;client=firefox-a&amp;rls=org.mozilla:en-US:official&amp;hs=qhu&amp;q=1000+results&amp;start=1000&amp;sa=N  I didn't know that until recently, because I'd never taken the time to click into the 100th page of search results on a query."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "why", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "http://www.google.ca/search?hl=en&amp;client=firefox-a&amp;rls=org.mozilla:en-US:official&amp;hs=qhu&amp;q=1000+results&amp;start=1000&amp;sa=N", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.google.ca/search?hl=en&client=firefox-a&rls=org.mozilla:en-US:official&hs=qhu&q=1000+results&start=1000&sa=N"}]}, {"text": ["If you're actually returning more than 1,000 results back to the user, then I think there's a bigger problem at hand than the fact that the data store won't let you do it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["One possible (legitimate) reason to need that many results is if you were doing a large operation on the data and presenting a summary (for example, what is the average of all this data).", "The solution to this problem (which is talked about in the Google I/O talk) is to calculate the summary data on-the-fly, as it comes in, and save it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["App Engine gives you a nice way of \"paging\" through the results by 1000 by ordering on Keys and using the last key as the next offset.", "They even provide some sample code here:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://code.google.com/appengine/docs/python/datastore/queriesandindexes.html#Queries_on_Keys"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://code.google.com/appengine/docs/python/datastore/queriesandindexes.html#Queries_on_Keys", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/appengine/docs/python/datastore/queriesandindexes.html#Queries_on_Keys"}]}, {"text": ["Although their example spreads the queries out over many requests, you can change the page size from 20 to 1000 and query in a loop, combining the querysets.", "Additionally you might use itertools to link the queries without evaluating them before they're needed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For example, to count how many rows beyond 1000:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class MyModel(db.Expando):\n    @classmethod\n    def count_all(cls):\n        \"\"\"\n        Count *all* of the rows (without maxing out at 1000)\n        \"\"\"\n        count = 0\n        query = cls.all().order('__key__')\n\n        while count % 1000 == 0:\n            current_count = query.count()\n            if current_count == 0:\n                break\n\n            count += current_count\n\n            if current_count == 1000:\n                last_key = query.fetch(1, 999)[0].key()\n                query = query.filter('__key__ &gt; ', last_key)\n\n        return count\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You can't."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "You can't.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Part of the FAQ states that there is no way you can access beyond row 1000 of a query, increasing the \"OFFSET\" will just result in a shorter result set, "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["ie: OFFSET 999 --> 1 result comes back. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["From Wikipedia: "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["From http://code.google.com/appengine/docs/whatisgoogleappengine.html"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://code.google.com/appengine/docs/whatisgoogleappengine.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/appengine/docs/whatisgoogleappengine.html"}]}, {"text": ["From http://code.google.com/appengine/docs/datastore/gqlreference.html"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "http://code.google.com/appengine/docs/datastore/gqlreference.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/appengine/docs/datastore/gqlreference.html"}]}, {"text": ["From http://code.google.com/appengine/docs/datastore/queryclass.html"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "http://code.google.com/appengine/docs/datastore/queryclass.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/appengine/docs/datastore/queryclass.html"}]}, {"text": ["What this means is "], "childNum": 0, "tag": "h2", "senID": 7, "childList": []}, {"text": ["If you have a singular query, there is no way to request anything outside the range 0-1000. "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Increasing offset will just raise the 0, so"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n LIMIT 1000  OFFSET 0\n</code>\n</pre>\n", "senID": 10}, {"text": ["Will return 1000 rows, "], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["and "], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n LIMIT 1000 OFFSET 1000\n</code>\n</pre>\n", "senID": 13}, {"text": ["Will return 0 rows, thus, making it impossible to, with a single query syntax, fetch 2000 results either manually or using the API. "], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "0 rows", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The only plausible exception"], "childNum": 0, "tag": "h2", "senID": 15, "childList": []}, {"text": ["Is to create a numeric index on the table, ie: "], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n SELECT * FROM Foo  WHERE ID &gt; 0 AND ID &lt; 1000 \n\n SELECT * FROM Foo WHERE ID &gt;= 1000 AND ID &lt; 2000\n</code>\n</pre>\n", "senID": 17}, {"text": ["If your data or query can't have this 'ID' hardcoded identifier, then you are out of luck"], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "out of luck", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Just for the record - fetch limit of 1000 entries is now gone:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://googleappengine.blogspot.com/2010/02/app-engine-sdk-131-including-major.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://googleappengine.blogspot.com/2010/02/app-engine-sdk-131-including-major.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://googleappengine.blogspot.com/2010/02/app-engine-sdk-131-including-major.html"}]}, {"text": ["Quotation:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The 1000 record limit is a hard limit in Google AppEngine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This presentation http://sites.google.com/site/io/building-scalable-web-applications-with-google-app-engine explains how to efficiently page through data using AppEngine."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://sites.google.com/site/io/building-scalable-web-applications-with-google-app-engine", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://sites.google.com/site/io/building-scalable-web-applications-with-google-app-engine"}]}, {"text": ["(Basically by using a numeric id as key and specifying a WHERE clause on the id."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This 1K limit issue is resolved."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["query = MyModel.all()\nfor doc in query:\n    print doc.title"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["By treating the Query object as an iterable: The iterator retrieves results from the datastore in small batches, allowing for the app to stop iterating on results to avoid fetching more than is needed.", "Iteration stops when all of the results that match the query have been retrieved.", "As with fetch(), the iterator interface does not cache results, so creating a new iterator from the Query object will re-execute the query."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The max batch size is 1K.", "And you still have the auto Datastore quotas as well."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["But with the plan 1.3.1 SDK, they've introduced cursors that can be serialized and saved so that a future invocation can begin the query where it last left off at."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n class Count(object):\ndef getCount(self,cls):\n\tclass Count(object):\ndef getCount(self,cls):\n\t\"\"\"\n\tCount *all* of the rows (without maxing out at 1000)\n\t\"\"\"\n\tcount = 0\n\tquery = cls.all().order('__key__')\n\n\n\twhile 1:\n\t\tcurrent_count = query.count()\n\t\tcount += current_count\n\t\tif current_count == 0:\n\t\t\tbreak\n\n\t\tlast_key = query.fetch(1, current_count-1)[0].key()\n\t\tquery = query.filter('__key__ &gt; ', last_key)\n\n\treturn count\n</code>\n</pre>\n", "senID": 0}], [{"text": ["we are using something in our ModelBase class that is:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ModelBase", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n @classmethod\ndef get_all(cls):\n  q = cls.all()\n  holder = q.fetch(1000)\n  result = holder\n  while len(holder) == 1000:\n    holder = q.with_cursor(q.cursor()).fetch(1000)\n    result += holder\n  return result\n</code>\n</pre>\n", "senID": 1}, {"text": ["This gets around the 1000 query limit on every model without having to think about it.", "I suppose a keys version would be just as easy to implement."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["JJG: your solution above is awesome, except that it causes an infinite loop if you have 0 records.", "(I found this out while testing some of my reports locally)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I modified the start of the while loop to look like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n while count % 1000 == 0:\n    current_count = query.count()\n    if current_count == 0:\n        break\n</code>\n</pre>\n", "senID": 2}], [{"text": ["To add the contents of the two queries together:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n list1 = first query\nlist2 = second query\nlist1 += list2\n</code>\n</pre>\n", "senID": 1}, {"text": ["List 1 now contains all 2000 results."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The proposed solution only works if entries are sorted by key...", "If you are sorting by another column first, you still have to use a limit(offset, count) clause, then the 1000 entries limitation still apply.", "It is the same if you use two requests : one for retrieving indexes (with conditions and sort) and another using where index in () with a subset of indexes from the first result, as the first request cannot return more than 1000 keys ?", "(The Google Queries on Keys section does not state clearly if we have to sort by key to remove the 1000 results limitation)"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Queries on Keys", "childNum": 0, "tag": "em", "pos": 3, "childList": []}, {"text": "key", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["I'm building an app that needs to report on events occurring.", "An event has a type and I also need to report by event type."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The 1000 limit is throwing a wrench into how I would normally do it.", "I don't need to retrieve all of the entities and present them to the user, but I do need to show the total count for a specific date range.", "Any suggestions?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Thanks!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This is close to the solution provided by Gabriel, but doesn't fetch the results it just counts them:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n count = 0\nq = YourEntityClass.all().filter('myval = ', 2)\ncountBatch = q.count()\nwhile countBatch &gt; 0:\n    count += countBatch\n    countBatch = q.with_cursor(q.cursor()).count()\n\nlogging.info('Count=%d' % count)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Works perfectly for my queries, and fast too (1.1 seconds to count 67,000 entities)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note that the query must not be an inequality filter or a set or the cursor will not work and you'll get this exception:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n entities = []\nfor entity in Entity.all():\n    entities.append(entity)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Simple as that.", "Note that there is an RPC made for every entity which is much slower than fetching in chunks.", "So if you're concerned about performance, do the following:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you have less than 1M items:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n entities = Entity.all().fetch(999999)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Otherwise, use a cursor and make sure to order your entities to avoid dupes."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["It should also be noted that:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n Entity.all().fetch(Entity.all().count())\n</code>\n</pre>\n", "senID": 6}, {"text": ["returns 1000 max and should not be used."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]]