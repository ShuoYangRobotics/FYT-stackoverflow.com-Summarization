[[{"text": ["The proposed (and accepted) solution of calling into clib is quite stupid.", "Here is a simple benchmark:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #/usr/bin/env python2.5\nimport random\nimport timeit\n\nfrom ctypes import *\nlibc = CDLL(\"libc.dylib\") # change to \"libc.so.6\" on linux\n\nwords = [word.rstrip() for word in\n          open('/usr/share/dict/words', 'r').readlines()]\nrandom.shuffle(words)\nprint '%i words in list' % len(words)\n\nsetup = 'from __main__ import words, libc'\nstmts = [\n    (\"simple sort\", \"sorted(words)\"),\n    (\"sort with key=str.lower\", \"sorted(words, key=str.lower)\"),\n    (\"sort with cmp=libc.strcasecmp\", \"sorted(words, cmp=libc.strcasecmp)\"),\n]\n\nfor (comment, stmt) in stmts:\n    t = timeit.Timer(stmt=stmt, setup=setup)\n    print \"%s: %.2f msec/pass\" % (comment, (1000*t.timeit(10)/10))\n</code>\n</pre>\n", "senID": 1}, {"text": ["typical times on my machine:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 234936 words in list\nsimple sort: 397.59 msec/pass\nsort with key=str.lower: 827.00 msec/pass\nsort with cmp=libc.strcasecmp: 2924.86 msec/pass\n</code>\n</pre>\n", "senID": 3}, {"text": ["So, the version with str.lower is not only the fastest by far, but also the most portable and pythonic of all the proposed solutions here.", "I have not profiled memory usage, but the original poster has still not given a compelling reason to worry about it.", "Also, who says that a call into the libc module doesn't duplicate any strings?"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "str.lower", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["NB: The lower() string method also has the advantage of being locale-dependent.", "Something you will probably not be getting right when writing your own \"optimised\" solution.", "Even so, due to bugs and missing features in Python, this kind of comparison may give you wrong results in a unicode context."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "lower()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Your question implies that you don't need Unicode.", "Try the following code snippet; if it works for you, you're done:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Python 2.5.2 (r252:60911, Aug 22 2008, 02:34:17)\n[GCC 4.3.1] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import locale\n&gt;&gt;&gt; locale.setlocale(locale.LC_COLLATE, \"en_US\")\n'en_US'\n&gt;&gt;&gt; sorted(\"ABCabc\", key=locale.strxfrm)\n['a', 'A', 'b', 'B', 'c', 'C']\n&gt;&gt;&gt; sorted(\"ABCabc\", cmp=locale.strcoll)\n['a', 'A', 'b', 'B', 'c', 'C']\n</code>\n</pre>\n", "senID": 1}, {"text": ["Clarification: in case it is not obvious at first sight, locale.strcoll seems to be the function you need, avoiding the str.lower or locale.strxfrm \"duplicate\" strings."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Are you using this compare in a very-frequently-executed path of a highly-performance-sensitive application?", "Alternatively, are you running this on strings which are megabytes in size?", "If not, then you shouldn't worry about the performance and just use the .lower() method."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The following code demonstrates that doing a case-insensitive compare by calling .lower() on two strings which are each almost a megabyte in size takes about 0.009 seconds on my 1.8GHz desktop computer:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from timeit import Timer\n\ns1 = \"1234567890\" * 100000 + \"a\"\ns2 = \"1234567890\" * 100000 + \"B\"\n\ncode = \"s1.lower() &lt; s2.lower()\"\ntime = Timer(code, \"from __main__ import s1, s2\").timeit(1000)\nprint time / 1000   # 0.00920499992371 on my machine\n</code>\n</pre>\n", "senID": 2}, {"text": ["If indeed this is an extremely significant, performance-critical section of code, then I recommend writing a function in C and calling it from your Python code, since that will allow you to do a truly efficient case-insensitive search.", "Details on writing C extension modules can be found here: http://www.python.org/doc/ext/intro.html"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://www.python.org/doc/ext/intro.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/ext/intro.html"}]}], [{"text": ["This is how you'd do it with re:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\np = re.compile('^hello$', re.I)\np.match('Hello')\np.match('hello')\np.match('HELLO')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There's no built in equivalent to that function you want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can write your own fuction that converts to .lower() each carachter at a time to avoid  duplicating both strings, but I'm sure it will very cpu-intensive and extremely inefficient. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Unless you are working with extremely long strings (so long that can cause a memory problem if duplicated) then I would keep it simple and use "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n str1.lower() == str2.lower()\n</code>\n</pre>\n", "senID": 3}, {"text": ["You'll be ok"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I can't find any other built-in way of doing case-insensitive comparison: The python cook-book recipe uses lower()."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "python cook-book recipe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/170242/"}]}, {"text": ["However you have to be careful when using lower for comparisons because of the Turkish I problem.", "Unfortunately Python's handling for Turkish Is is not good.", "\u0131 is converted to I, but I is not converted to \u0131. \u0130 is converted to i, but i is not converted to \u0130. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Turkish I problem", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Turkish_dotted_and_dotless_I"}]}], [{"text": ["The recommended idiom to sort lists of values using expensive-to-compute keys is to the so-called \"decorated pattern\".", "It consists simply in building a list of (key, value) tuples from the original list, and sort that list.", "Then it is trivial to eliminate the keys and get the list of sorted values:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; original_list = ['a', 'b', 'A', 'B']\n&gt;&gt;&gt; decorated = [(s.lower(), s) for s in original_list]\n&gt;&gt;&gt; decorated.sort()\n&gt;&gt;&gt; sorted_list = [s[1] for s in decorated]\n&gt;&gt;&gt; sorted_list\n['A', 'a', 'B', 'b']\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or if you like one-liners:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sorted_list = [s[1] for s in sorted((s.lower(), s) for s in original_list)]\n&gt;&gt;&gt; sorted_list\n['A', 'a', 'B', 'b']\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you really worry about the cost of calling lower(), you can just store tuples of (lowered string, original string) everywhere.", "Tuples are the cheapest kind of containers in Python, they are also hashable so they can be used as dictionary keys, set members, etc."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I'm pretty sure you either have to use .lower() or use a regular expression.", "I'm not aware of a built-in case-insensitive string comparison function."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You could subclass str and create your own case-insenstive string class but IMHO that would be extremely unwise and create far more trouble than it's worth."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["For occasional or even repeated comparisons, a few extra string objects shouldn't matter as long as this won't happen in the innermost loop of your core code or you don't have enough data to actually notice the performance impact.", "See if you do: doing things in a \"stupid\" way is much less stupid if you also do it less."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you seriously want to keep comparing lots and lots of text case-insensitively you could somehow keep the lowercase versions of the strings at hand to avoid finalization and re-creation, or normalize the whole data set into lowercase.", "This of course depends on the size of the data set.", "If there are a relatively few needles and a large haystack, replacing the needles with compiled regexp objects is one solution.", "If It's hard to say without seeing a concrete example."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["An alternative way to do this in place is to iterate over each character in the first string and compare it to the same character in the second string (make sure you check the sizes match first.. if they don't the strings are not the same) and then just lowercase each character individually.", "This will prevent having to make a new copy of the string.", "(this is psuedo real python code i don't know python very well and am too lazy to look the exact syntax up)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if string1.size &lt;&gt; string2.size return false \nfor char in string1: y = char\n    for char in string2: x = char  \n        if x.lower() &lt;&gt; y.lower() then \n        return false \nreturn true\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could translate each string to lowercase once --- lazily only when you need it, or as a prepass to the sort if you know you'll be sorting the entire collection of strings.", "There are several ways to attach this comparison key to the actual data being sorted, but these techniques should be addressed in a separate issue."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Note that this technique can be used not only to handle upper/lower case issues, but for other types of sorting such as locale specific sorting, or \"Library-style\" title sorting that ignores leading articles and otherwise normalizes the data before sorting it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Just use the str().lower() method, unless high-performance is important - in which case write that sorting method as a C extension."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "str().lower()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["\"How to write a Python Extension\" seems like a decent intro.."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "\"How to write a Python Extension\"", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://starship.python.net/crew/arcege/extwriting/pyext.html"}]}, {"text": ["More interestingly, This guide compares using the ctypes library vs writing an external C module (the ctype is quite-substantially slower than the C extension)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "This guide", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.dalkescientific.com/writings/NBN/c_extensions.html"}]}], [{"text": ["This question is asking 2 very different things:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Since #1 has been answered very well already (ie: str1.lower() &lt; str2.lower())  I will answer #2."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def strincmp(str1, str2, numchars=None):\n    result = 0\n    len1 = len(str1)\n    len2 = len(str2)\n    if numchars is not None:\n        minlen = min(len1,len2,numchars)\n    else:\n        minlen = min(len1,len2)\n    #end if\n    orda = ord('a')\n    ordz = ord('z')\n\n    i = 0\n    while i &lt; minlen and 0 == result:\n        ord1 = ord(str1[i])\n        ord2 = ord(str2[i])\n        if ord1 &gt;= orda and ord1 &lt;= ordz:\n            ord1 = ord1-32\n        #end if\n        if ord2 &gt;= orda and ord2 &lt;= ordz:\n            ord2 = ord2-32\n        #end if\n        result = cmp(ord1, ord2)\n        i += 1\n    #end while\n\n    if 0 == result and minlen != numchars:\n        if len1 &lt; len2:\n            result = -1\n        elif len2 &lt; len1:\n            result = 1\n        #end if\n    #end if\n\n    return result\n#end def\n</code>\n</pre>\n", "senID": 2}, {"text": ["Only use this function when it makes sense to as in many instances the lowercase technique will be superior."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I only work with ascii strings, I'm not sure how this will behave with unicode."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I like the regular expression solution.", "Here's a function you can copy and paste into any function, thanks to python's block structure support."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def equals_ignore_case(str1, str2):\n    import re\n    return re.match(re.escape(str1) + r'\\Z', str2, re.I) is not None\n</code>\n</pre>\n", "senID": 1}, {"text": ["Since I used match instead of search, I didn't need to add a caret (^) to the regular expression."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["In response to your clarification..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You could use ctypes to execute the c function \"strcasecmp\".", "Ctypes is included in Python 2.5.", "It provides the ability to call out to dll and shared libraries such as libc.", "Here is a quick example (Python on Linux; see link for Win32 help):"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "ctypes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/ctypes-ctypes-tutorial.html"}]}, {"code": "<pre>\n<code>\n from ctypes import *\nlibc = CDLL(\"libc.so.6\")  // see link above for Win32 help\nlibc.strcasecmp(\"THIS\", \"this\") // returns 0\nlibc.strcasecmp(\"THIS\", \"THAT\") // returns 8\n</code>\n</pre>\n", "senID": 2}, {"text": ["may also want to reference strcasecmp documentation"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "strcasecmp documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://linux.die.net/man/3/strcasecmp"}]}, {"text": ["Not really sure this is any faster or slower (have not tested), but it's a way to use a C function to do case insensitive string comparisons. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["~~~~~~~~~~~~~~"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["ActiveState Code - Recipe 194371: Case Insensitive Strings\nis a recipe for creating a case insensitive string class.", "It might be a bit over kill for something quick, but could provide you with a common way of handling case insensitive strings if you plan on using them often."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "ActiveState Code - Recipe 194371: Case Insensitive Strings", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/194371/"}]}]]