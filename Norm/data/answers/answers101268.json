[[{"text": ["Chaining comparison operators:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Chaining comparison operators", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = 5\n&gt;&gt;&gt; 1 &lt; x &lt; 10\nTrue\n&gt;&gt;&gt; 10 &lt; x &lt; 20 \nFalse\n&gt;&gt;&gt; x &lt; 10 &lt; x*10 &lt; 100\nTrue\n&gt;&gt;&gt; 10 &gt; x &lt;= 9\nTrue\n&gt;&gt;&gt; 5 == x &gt; 4\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["In case you're thinking it's doing 1 &lt; x, which comes out as True, and then comparing True &lt; 10, which is also True, then no, that's really not what happens (see the last example.", ") It's really translating into 1 &lt; x and x &lt; 10, and x &lt; 10 and 10 &lt; x * 10 and x*10 &lt; 100, but with less typing and each term is only evaluated once."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "1 &lt; x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "True &lt; 10", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "1 &lt; x and x &lt; 10", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "x &lt; 10 and 10 &lt; x * 10 and x*10 &lt; 100", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Creating generators objects"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Creating generators objects", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If you write "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n x=(n for n in foo if bar(n))\n</code>\n</pre>\n", "senID": 2}, {"text": ["you can get out the generator and assign it to x.", "Now it means you can do"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for n in x:\n</code>\n</pre>\n", "senID": 4}, {"text": ["The advantage of this is that you don't need intermediate storage, which you would need if you did"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n x = [n for n in foo if bar(n)]\n</code>\n</pre>\n", "senID": 6}, {"text": ["In some cases this can lead to significant speed up."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["You can append many if statements to the end of the generator, basically replicating nested for loops:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; n = ((a,b) for a in range(0,2) for b in range(4,6))\n&gt;&gt;&gt; for i in n:\n...   print i \n\n(0, 4)\n(0, 5)\n(1, 4)\n(1, 5)\n</code>\n</pre>\n", "senID": 9}], [{"text": ["iter() can take a callable argument"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "iter() can take a callable argument", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["For instance:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def seek_next_line(f):\n    for c in iter(lambda: f.read(1),'\\n'):\n        pass\n</code>\n</pre>\n", "senID": 2}, {"text": ["The iter(callable, until_value) function repeatedly calls callable and yields its result until until_value is returned. "], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "iter(callable, until_value)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "callable", "childNum": 0, "tag": "code", "childList": []}, {"text": "until_value", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Sending values into generator functions.", "For example having this function:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Sending values into generator functions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0342/"}]}, {"code": "<pre>\n<code>\n def mygen():\n    \"\"\"Yield 5 until something else is passed back via send()\"\"\"\n    a = 5\n    while True:\n        f = (yield a) #yield a and possibly get f in return\n        if f is not None: \n            a = f  #store the new value\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; g = mygen()\n&gt;&gt;&gt; g.next()\n5\n&gt;&gt;&gt; g.next()\n5\n&gt;&gt;&gt; g.send(7)  #we send this back to the generator\n7\n&gt;&gt;&gt; g.next() #now it will yield 7 until we send something else\n7\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Decorators"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Decorators", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Decorators allow to wrap a function or method in another function that can add functionality, modify arguments or results, etc.", "You write decorators one line above the function definition, beginning with an \"at\" sign (@)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Decorators", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/ref/function.html#tok-decorators"}]}, {"text": ["Example shows a print_args decorator that prints the decorated function's arguments before calling it:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "print_args", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def print_args(function):\n&gt;&gt;&gt;     def wrapper(*args, **kwargs):\n&gt;&gt;&gt;         print 'Arguments:', args, kwargs\n&gt;&gt;&gt;         return function(*args, **kwargs)\n&gt;&gt;&gt;     return wrapper\n\n&gt;&gt;&gt; @print_args\n&gt;&gt;&gt; def write(text):\n&gt;&gt;&gt;     print text\n\n&gt;&gt;&gt; write('foo')\nArguments: ('foo',) {}\nfoo\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The step argument in slice operators.", "For example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = [1,2,3,4,5]\n&gt;&gt;&gt; a[::2]  # iterate over the whole list in 2-increments\n[1,3,5]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The special case x[::-1] is a useful idiom for 'x reversed'."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "x[::-1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a[::-1]\n[5,4,3,2,1]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Readable regular expressions"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Readable regular expressions", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["In Python you can split a regular expression over multiple lines, name your matches and insert comments."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Example verbose syntax (from Dive into Python):"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Dive into Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://diveintopython.org/regular%5Fexpressions/index.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; pattern = \"\"\"\n... ^                   # beginning of string\n... M{0,4}              # thousands - 0 to 4 M's\n... (CM|CD|D?C{0,3})    # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 C's),\n...                     #            or 500-800 (D, followed by 0 to 3 C's)\n... (XC|XL|L?X{0,3})    # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 X's),\n...                     #        or 50-80 (L, followed by 0 to 3 X's)\n... (IX|IV|V?I{0,3})    # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 I's),\n...                     #        or 5-8 (V, followed by 0 to 3 I's)\n... $                   # end of string\n... \"\"\"\n&gt;&gt;&gt; re.search(pattern, 'M', re.VERBOSE)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Example naming matches (from Regular Expression HOWTO)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Regular Expression HOWTO", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.amk.ca/python/howto/regex/"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; p = re.compile(r'(?P&lt;word&gt;\\b\\w+\\b)')\n&gt;&gt;&gt; m = p.search( '(((( Lots of punctuation )))' )\n&gt;&gt;&gt; m.group('word')\n'Lots'\n</code>\n</pre>\n", "senID": 5}, {"text": ["You can also verbosely write a regex without using re.VERBOSE thanks to string literal concatenation."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "re.VERBOSE", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; pattern = (\n...     \"^\"                 # beginning of string\n...     \"M{0,4}\"            # thousands - 0 to 4 M's\n...     \"(CM|CD|D?C{0,3})\"  # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 C's),\n...                         #            or 500-800 (D, followed by 0 to 3 C's)\n...     \"(XC|XL|L?X{0,3})\"  # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 X's),\n...                         #        or 50-80 (L, followed by 0 to 3 X's)\n...     \"(IX|IV|V?I{0,3})\"  # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 I's),\n...                         #        or 5-8 (V, followed by 0 to 3 I's)\n...     \"$\"                 # end of string\n... )\n&gt;&gt;&gt; print pattern\n\"^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$\"\n</code>\n</pre>\n", "senID": 7}], [{"text": ["In-place value swapping"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "In-place value swapping", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = 10\n&gt;&gt;&gt; b = 5\n&gt;&gt;&gt; a, b\n(10, 5)\n\n&gt;&gt;&gt; a, b = b, a\n&gt;&gt;&gt; a, b\n(5, 10)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The right-hand side of the assignment is an expression that creates a new tuple.", "The left-hand side of the assignment immediately unpacks that (unreferenced) tuple to the names a and b."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["After the assignment, the new tuple is unreferenced and marked for garbage collection, and the values bound to a and b have been swapped."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["As noted in the Python tutorial section on data structures,"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Python tutorial section on data structures", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#tuples-and-sequences"}]}], [{"text": ["Function argument unpacking"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Function argument unpacking", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You can unpack a list or a dictionary as function arguments using * and **."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "*", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "**", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def draw_point(x, y):\n    # do some magic\n\npoint_foo = (3, 4)\npoint_bar = {'y': 3, 'x': 2}\n\ndraw_point(*point_foo)\ndraw_point(**point_bar)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Very useful shortcut since lists, tuples and dicts are widely used as containers."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Context managers and the \"with\" Statement"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Context managers and the \"with\" Statement", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "with", "tag": "code"}]}, {"text": "with", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Introduced in PEP 343, a context manager is an object that acts as a run-time context for a suite of statements."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "PEP 343", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0343/"}, {"href": "http://docs.python.org/library/stdtypes.html#context-manager-types", "text": "context manager", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Since the feature makes use of new keywords, it is introduced gradually: it is available in Python 2.5 via the __future__ directive.", "Python 2.6 and above (including Python 3) has it available by default."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "__future__", "tag": "a", "pos": 0, "childList": [{"text": "__future__", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/lib/module-future.html"}, {"text": "__future__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["I have used the \"with\" statement a lot because I think it's a very useful construct, here is a quick demo:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "\"with\" statement", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0343/"}]}, {"code": "<pre>\n<code>\n from __future__ import with_statement\n\nwith open('foo.txt', 'w') as f:\n    f.write('hello!')\n</code>\n</pre>\n", "senID": 4}, {"text": ["What's happening here behind the scenes, is that the \"with\" statement calls the special __enter__ and __exit__ methods on the file object.", "Exception details are also passed to __exit__ if any exception was raised from the with statement body, allowing for exception handling to happen there."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "\"with\" statement", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0343/"}, {"text": "__enter__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__exit__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__exit__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["What this does for you in this particular case is that it guarantees that the file is closed when execution falls out of scope of the with suite, regardless if that occurs normally or whether an exception was thrown.", "It is basically a way of abstracting away common exception-handling code."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "with", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Other common use cases for this include locking with threads and database transactions. "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Creating new types in a fully dynamic manner"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Creating new types in a fully dynamic manner", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; NewType = type(\"NewType\", (object,), {\"x\": \"hello\"})\n&gt;&gt;&gt; n = NewType()\n&gt;&gt;&gt; n.x\n\"hello\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["which is exactly the same as"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class NewType(object):\n&gt;&gt;&gt;     x = \"hello\"\n&gt;&gt;&gt; n = NewType()\n&gt;&gt;&gt; n.x\n\"hello\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["Probably not the most useful thing, but nice to know."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Edit: Fixed name of new type, should be NewType to be the exact same thing as with class statement."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "NewType", "childNum": 0, "tag": "code", "childList": []}, {"text": "class", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: Adjusted the title to more accurately describe the feature."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Descriptors"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Descriptors", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["They're the magic behind a whole bunch of core Python features. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["When you use dotted access to look up a member (eg, x.y), Python first looks for the member in the instance dictionary.", "If it's not found, it looks for it in the class dictionary.", "If it finds it in the class dictionary, and the object implements the descriptor protocol, instead of just returning it, Python executes it.", "A descriptor is any class that implements the __get__, __set__, or __del__ methods."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "__get__", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "__set__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__del__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Here's how you'd implement your own (read-only) version of property using descriptors:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Property(object):\n    def __init__(self, fget):\n        self.fget = fget\n\n    def __get__(self, obj, type):\n        if obj is None:\n            return self\n        return self.fget(obj)\n</code>\n</pre>\n", "senID": 4}, {"text": ["and you'd use it just like the built-in property():"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class MyClass(object):\n    @Property\n    def foo(self):\n        return \"Foo!\"\n</code>\n</pre>\n", "senID": 6}, {"text": ["Descriptors are used in Python to implement properties, bound methods, static methods, class methods and slots, amongst other things.", "Understanding them makes it easy to see why a lot of things that previously looked like Python 'quirks' are the way they are."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Raymond Hettinger has an excellent tutorial that does a much better job of describing them than I do."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "an excellent tutorial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://users.rcn.com/python/download/Descriptor.htm"}]}], [{"text": ["Doctest: documentation and unit-testing at the same time. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Doctest", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-doctest.html"}]}, {"text": ["Example extracted from the Python documentation:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def factorial(n):\n    \"\"\"Return the factorial of n, an exact integer &gt;= 0.\n\n    If the result is small enough to fit in an int, return an int.\n    Else return a long.\n\n    &gt;&gt;&gt; [factorial(n) for n in range(6)]\n    [1, 1, 2, 6, 24, 120]\n    &gt;&gt;&gt; factorial(-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: n must be &gt;= 0\n\n    Factorials of floats are OK, but the float must be an exact integer:\n    \"\"\"\n\n    import math\n    if not n &gt;= 0:\n        raise ValueError(\"n must be &gt;= 0\")\n    if math.floor(n) != n:\n        raise ValueError(\"n must be exact integer\")\n    if n+1 == n:  # catch a value like 1e300\n        raise OverflowError(\"n too large\")\n    result = 1\n    factor = 2\n    while factor &lt;= n:\n        result *= factor\n        factor += 1\n    return result\n\ndef _test():\n    import doctest\n    doctest.testmod()    \n\nif __name__ == \"__main__\":\n    _test()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Re-raising exceptions:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Re-raising exceptions", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # Python 2 syntax\ntry:\n    some_operation()\nexcept SomeError, e:\n    if is_fatal(e):\n        raise\n    handle_nonfatal(e)\n\n# Python 3 syntax\ntry:\n    some_operation()\nexcept SomeError as e:\n    if is_fatal(e):\n        raise\n    handle_nonfatal(e)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The 'raise' statement with no arguments inside an error handler tells Python to re-raise the exception with the original traceback intact, allowing you to say \"oh, sorry, sorry, I didn't mean to catch that, sorry, sorry."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "with the original traceback intact", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["If you wish to print, store or fiddle with the original traceback, you can get it with sys.exc_info(), and printing it like Python would is done with the 'traceback' module."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Main messages :)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Main messages :)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import this\n# btw look at this module's source :)\n</code>\n</pre>\n", "senID": 1}, {"tag": "hr", "senID": 2}, {"text": ["De-cyphered:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "De-cyphered", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Lib/this.py?view=markup"}]}], [{"text": ["Nested list comprehensions and generator expressions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [(i,j) for i in range(3) for j in range(i) ]    \n((i,j) for i in range(4) for j in range(i) )\n</code>\n</pre>\n", "senID": 1}, {"text": ["These can replace huge chunks of nested-loop code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can use property to make your class interfaces more strict."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "property", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#property"}]}, {"code": "<pre>\n<code>\n class C(object):\n    def __init__(self, foo, bar):\n        self.foo = foo # read-write property\n        self.bar = bar # simple attribute\n\n    def _set_foo(self, value):\n        self._foo = value\n\n    def _get_foo(self):\n        return self._foo\n\n    def _del_foo(self):\n        del self._foo\n\n    # any of fget, fset, fdel and doc are optional,\n    # so you can make a write-only and/or delete-only property.\n    foo = property(fget = _get_foo, fset = _set_foo,\n                   fdel = _del_foo, doc = 'Hello, I am foo!')\n\nclass D(C):\n    def _get_foo(self):\n        return self._foo * 2\n\n    def _set_foo(self, value):\n        self._foo = value / 2\n\n    foo = property(fget = _get_foo, fset = _set_foo,\n                   fdel = C.foo.fdel, doc = C.foo.__doc__)\n</code>\n</pre>\n", "senID": 1}, {"text": ["In Python 2.6 and 3.0:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "2.6 and 3.0", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/whatsnew/2.6.html"}]}, {"code": "<pre>\n<code>\n class C(object):\n    def __init__(self, foo, bar):\n        self.foo = foo # read-write property\n        self.bar = bar # simple attribute\n\n    @property\n    def foo(self):\n        '''Hello, I am foo!'''\n\n        return self._foo\n\n    @foo.setter\n    def foo(self, value):\n        self._foo = value\n\n    @foo.deleter\n    def foo(self):\n        del self._foo\n\nclass D(C):\n    @C.foo.getter\n    def foo(self):\n        return self._foo * 2\n\n    @foo.setter\n    def foo(self, value):\n        self._foo = value / 2\n</code>\n</pre>\n", "senID": 3}, {"text": ["To learn more about how property works refer to descriptors."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "descriptors", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/howto/descriptor.html"}]}], [{"text": ["Getter functions in module operator"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Getter functions in module operator", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The functions attrgetter() and itemgetter() in module operator can be used to generate fast access functions for use in sorting and search objects and dictionaries"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "attrgetter()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itemgetter()", "childNum": 0, "tag": "code", "childList": []}, {"text": "operator", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Chapter 6.7 in the Python Library Docs"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Chapter 6.7", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-operator.html"}]}], [{"text": ["Interleavingifandforin list comprehensions"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Interleavingifandforin list comprehensions", "childNum": 2, "tag": "strong", "pos": 0, "childList": [{"text": "if", "tag": "code"}, {"text": "for", "tag": "code"}]}, {"text": "if", "childNum": 0, "tag": "code", "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [(x, y) for x in range(4) if x % 2 == 1 for y in range(4)]\n[(1, 0), (1, 1), (1, 2), (1, 3), (3, 0), (3, 1), (3, 2), (3, 3)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I never realized this until I learned Haskell."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The Python Interpreter"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "The Python Interpreter", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Maybe not lesser known, but certainly one of my favorite features of Python."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Metaclasses"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Metaclasses", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["of course :-) http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python"}]}], [{"text": ["Implicit concatenation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print \"Hello \" \"World\"\nHello World\n</code>\n</pre>\n", "senID": 1}, {"text": ["Useful when you want to make a long text fit on several lines in a script:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n hello = \"Greaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa Hello \" \\\n        \"Word\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n hello = (\"Greaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa Hello \" \n         \"Word\")\n</code>\n</pre>\n", "senID": 5}], [{"text": ["First-class functions"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "First-class functions", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["It's not really a hidden feature, but the fact that functions are first class objects is simply great.", "You can pass them around like any other variable."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def jim(phrase):\n...   return 'Jim says, \"%s\".' % phrase\n&gt;&gt;&gt; def say_something(person, phrase):\n...   print person(phrase)\n\n&gt;&gt;&gt; say_something(jim, 'hey guys')\n'Jim says, \"hey guys\".'\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Some of the builtin favorites, map(), reduce(), and filter().", "All extremely fast and powerful."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "builtin", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Ability to substitute even things like file deletion, file opening etc.", "- direct manipulation of language library.", "This is a huge advantage when testing.", "You don't have to wrap everything in complicated containers.", "Just substitute a function/method and go.", "This is also called monkey-patching."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "testing.", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "monkey-patching.", "childNum": 0, "tag": "strong", "pos": 5, "childList": []}]}], [{"text": ["Too lazy to initialize every field in a dictionary?", "No problem:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In Python > 2.3:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\n</code>\n</pre>\n", "senID": 2}, {"text": ["In Python &lt;= 2.3:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def defaultdict(type_):\n    class Dict(dict):\n        def __getitem__(self, key):\n            return self.setdefault(key, type_())\n    return Dict()\n</code>\n</pre>\n", "senID": 4}, {"text": ["In any version:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n d = defaultdict(list)\nfor stuff in lots_of_stuff:\n     d[stuff.name].append(stuff)\n</code>\n</pre>\n", "senID": 6}, {"text": ["UPDATE:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "UPDATE:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Thanks Ken Arnold.", "I reimplemented a more sophisticated version of defaultdict.", "It should behave exactly as the one in the standard library."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "Ken Arnold", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/69707/ken-arnold"}, {"text": "the one in the standard library", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html#collections.defaultdict"}]}, {"code": "<pre>\n<code>\n def defaultdict(default_factory, *args, **kw):                              \n\n    class defaultdict(dict):\n\n        def __missing__(self, key):\n            if default_factory is None:\n                raise KeyError(key)\n            return self.setdefault(key, default_factory())\n\n        def __getitem__(self, key):\n            try:\n                return dict.__getitem__(self, key)\n            except KeyError:\n                return self.__missing__(key)\n\n    return defaultdict(*args, **kw)\n</code>\n</pre>\n", "senID": 9}], [{"text": ["List comprehensions"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "List comprehensions", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["list comprehensions"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "list comprehensions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.secnetix.de/olli/Python/list_comprehensions.hawk"}]}, {"text": ["Compare the more traditional (without list comprehension):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n foo = []\nfor x in xrange(10):\n  if x % 2 == 0:\n     foo.append(x)\n</code>\n</pre>\n", "senID": 3}, {"text": ["to:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n foo = [x for x in xrange(10) if x % 2 == 0]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Special methods"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Special methods", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Absolute power! "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Absolute power!", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/ref/specialnames.html"}]}], [{"text": ["Everything is dynamic"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Everything is dynamic", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["\"There is no compile-time\".", "Everything in Python is runtime.", "A module is 'defined' by executing the module's source top-to-bottom, just like a script, and the resulting namespace is the module's attribute-space.", "Likewise, a class is 'defined' by executing the class body top-to-bottom, and the resulting namespace is the class's attribute-space.", "A class body can contain completely arbitrary code -- including import statements, loops and other class statements.", "Creating a class, function or even module 'dynamically', as is sometimes asked for, isn't hard; in fact, it's impossible to avoid, since everything is 'dynamic'."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; x=[1,1,2,'a','a',3]\n&gt;&gt;&gt; y = [ _x for _x in x if not _x in locals()['_[1]'] ]\n&gt;&gt;&gt; y\n[1, 2, 'a', 3]\n</code>\n</pre>\n", "senID": 0}, {"text": ["\n\"locals()['_[1]']\" is the \"secret name\" of the list being created.", "Very useful when state of list being built affects subsequent build decisions."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}]]