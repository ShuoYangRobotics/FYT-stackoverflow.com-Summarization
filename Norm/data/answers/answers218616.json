[[{"text": ["Take a look at the inspect module - this will do the inspection of the various code object properties for you."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "inspect", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/inspect.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; inspect.getargspec(aMethod)\n(['arg1', 'arg2'], None, None, None)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The other results are the name of the *args and **kwargs variables, and the defaults provided.", "ie."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo(a,b,c=4, *arglist, **keywords): pass\n&gt;&gt;&gt; inspect.getargspec(foo)\n(['a', 'b', 'c'], 'arglist', 'keywords', (4,))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["In CPython, the number of arguments is"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n aMethod.func_code.co_argcount\n</code>\n</pre>\n", "senID": 1}, {"text": ["and their names are in the beginning of"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n aMethod.func_code.co_varnames\n</code>\n</pre>\n", "senID": 3}, {"text": ["These are implementation details of CPython, so this probably does not work in other implementations of Python, such as IronPython and Jython."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["One portable way to admit \"pass-through\" arguments is to define your function with the signature func(*args, **kwargs).", "This is used a lot in e.g.", "matplotlib, where the outer API layer passes lots of keyword arguments to the lower-level API."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "func(*args, **kwargs)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Here is something I think will work for what you want, using a decorator."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class LogWrappedFunction(object):\n    def __init__(self, function):\n        self.function = function\n\n    def logAndCall(self, *arguments, **namedArguments):\n        print \"Calling %s with arguments %s and named arguments %s\" %\\\n                      (self.function.func_name, arguments, namedArguments)\n        self.function.__call__(*arguments, **namedArguments)\n\ndef logwrap(function):\n    return LogWrappedFunction(function).logAndCall\n\n@logwrap\ndef doSomething(spam, eggs, foo, bar):\n    print \"Doing something totally awesome with %s and %s.\" % (spam, eggs)\n\n\ndoSomething(\"beans\",\"rice\", foo=\"wiggity\", bar=\"wack\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["Run it, it will yield the following output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n C:\\scripts&gt;python decoratorExample.py\nCalling doSomething with arguments ('beans', 'rice') and named arguments {'foo':\n 'wiggity', 'bar': 'wack'}\nDoing something totally awesome with beans and rice.\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I think what you're looking for is the locals method - "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In [6]: def test(a, b):print locals()\n   ...: \n\nIn [7]: test(1,2)              \n{'a': 1, 'b': 2}\n</code>\n</pre>\n", "senID": 1}]]