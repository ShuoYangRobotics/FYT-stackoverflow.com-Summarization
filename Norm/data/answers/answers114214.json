[[{"text": ["In Python, there is a distinction between bound and unbound methods. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "bound", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "unbound", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Basically, a call to a member function (like method_one), a bound function"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "method_one", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a_test.method_one()\n</code>\n</pre>\n", "senID": 2}, {"text": ["is translated to"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n Test.method_one(a_test)\n</code>\n</pre>\n", "senID": 4}, {"text": ["i.e.", "a call to an unbound method.", "Because of that, a call to your version of method_two will fail with a TypeError"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "method_two", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "TypeError", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a_test = Test() \n&gt;&gt;&gt; a_test.method_two()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: method_two() takes no arguments (1 given)\n</code>\n</pre>\n", "senID": 6}, {"text": ["You can change the behavior of a method using a decorator"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n class Test(object):\n    def method_one(self):\n        print \"Called method_one\"\n\n    @staticmethod\n    def method_two():\n        print \"Called method two\"\n</code>\n</pre>\n", "senID": 8}, {"text": ["The decorator tells the built-in default metaclass type (the class of a class, cf.", "this question) to not create bound methods for method_two."], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "this question", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python"}, {"text": "method_two", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Now, you can invoke static method both on an instance or on the class directly:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a_test = Test()\n&gt;&gt;&gt; a_test.method_one()\nCalled method_one\n&gt;&gt;&gt; a_test.method_two()\nCalled method_two\n&gt;&gt;&gt; Test.method_two()\nCalled method_two\n</code>\n</pre>\n", "senID": 11}], [{"text": ["Methods in Python are a very, very simple thing once you understood the basics of the descriptor system.", "Imagine the following class:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class C(object):\n    def foo(self):\n        pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now let's have a look at that class in the shell:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; C.foo\n&lt;unbound method C.foo&gt;\n&gt;&gt;&gt; C.__dict__['foo']\n&lt;function foo at 0x17d05b0&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["As you can see if you access the foo attribute on the class you get back an unbound method, however inside the class storage (the dict) there is a function.", "Why's that?", "The reason for this is that the class of your class implements a __getattribute__ that resolves descriptors.", "Sounds complex, but is not.", "C.foo is roughly equivalent to this code in that special case:"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__getattribute__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "C.foo", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; C.__dict__['foo'].__get__(None, C)\n&lt;unbound method C.foo&gt;\n</code>\n</pre>\n", "senID": 5}, {"text": ["That's because functions have a __get__ method which makes them descriptors.", "If you have an instance of a class it's nearly the same, just that None is the class instance:"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "__get__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; c = C()\n&gt;&gt;&gt; C.__dict__['foo'].__get__(c, C)\n&lt;bound method C.foo of &lt;__main__.C object at 0x17bd4d0&gt;&gt;\n</code>\n</pre>\n", "senID": 7}, {"text": ["Now why does Python do that?", "Because the method object binds the first parameter of a function to the instance of the class.", "That's where self comes from.", "Now sometimes you don't want your class to make a function a method, that's where staticmethod comes into play:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "staticmethod", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n class C(object):\n  @staticmethod\n  def foo():\n   pass\n</code>\n</pre>\n", "senID": 9}, {"text": ["The staticmethod decorator wraps your class and implements a dummy __get__ that returns the wrapped function as function and not as a method:"], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "staticmethod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__get__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; C.__dict__['foo'].__get__(None, C)\n&lt;function foo at 0x17d0c30&gt;\n</code>\n</pre>\n", "senID": 11}, {"text": ["Hope that explains it."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["When you call a class member, Python automatically uses a reference to the object as the first parameter.", "The variable self actually means nothing, it's just a coding convention.", "You could call it gargaloo if you wanted.", "That said, the call to method_two would raise a TypeError, because Python is automatically trying to pass a parameter (the reference to its parent object) to a method that was defined as having no parameters."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "gargaloo", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "method_two", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "TypeError", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To actually make it work, you could append this to your class definition:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n method_two = staticmethod(method_two)\n</code>\n</pre>\n", "senID": 2}, {"text": ["or you could use the @staticmethod function decorator."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "@staticmethod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/ref/function.html", "text": "function decorator", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["method_two won't work because you're defining a member function but not telling it what the function is a member of.", "If you execute the last line you'll get:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a_test.method_two()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: method_two() takes no arguments (1 given)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you're defining member functions for a class the first argument must always be 'self'."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; class Class(object):\n...     def __init__(self):\n...         self.i = 0\n...     def instance_method(self):\n...         self.i += 1\n...         print self.i\n...     c = 0\n...     @classmethod\n...     def class_method(cls):\n...         cls.c += 1\n...         print cls.c\n...     @staticmethod\n...     def static_method(s):\n...         s += 1\n...         print s\n... \n&gt;&gt;&gt; a = Class()\n&gt;&gt;&gt; a.class_method()\n1\n&gt;&gt;&gt; Class.class_method()    # The class shares this value across instances\n2\n&gt;&gt;&gt; a.instance_method()\n1\n&gt;&gt;&gt; Class.instance_method() # The class cannot use an instance method\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unbound method instance_method() must be called with Class instance as first argument (got nothing instead)\n&gt;&gt;&gt; Class.instance_method(a)\n2\n&gt;&gt;&gt; b = 0\n&gt;&gt;&gt; a.static_method(b)\n1\n&gt;&gt;&gt; a.static_method(a.c) # Static method does not have direct access to \n&gt;&gt;&gt;                      # class or instance properties.\n3\n&gt;&gt;&gt; Class.c        # a.c above was passed by value and not by reference.\n2\n&gt;&gt;&gt; a.c\n2\n&gt;&gt;&gt; a.c = 5        # The connection between the instance\n&gt;&gt;&gt; Class.c        # and its class is weak as seen here.\n2\n&gt;&gt;&gt; Class.class_method()\n3\n&gt;&gt;&gt; a.c\n5\n</code>\n</pre>\n", "senID": 0}], [{"text": ["The call to method_two will throw an exception for not accepting the self parameter the Python runtime will automatically pass it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want to create a static method in a Python class, decorate it with the staticmethod decorator."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "staticmethod decorator", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n Class Test(Object):\n  @staticmethod\n  def method_two():\n    print \"Called method_two\"\n\nTest.method_two()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["that is an error."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["first of all, first line should be like this (be careful of capitals)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Test(object):\n</code>\n</pre>\n", "senID": 2}, {"text": ["Whenever you call a method of a class, it gets itself as the first argument (hence the name self) and method_two gives this error "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a.method_two()\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: method_two() takes no arguments (1 given)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The second one won't work because when you call it like that python internally tries to call it with the a_test instance as the first argument, but your method_two doesn't accept any arguments, so it wont work, you'll get a runtime error.", "If you want the equivalent of a static method you can use a class method.", "There's much less need for class methods in Python than static methods in languages like Java or C#.", "Most often the best solution is to use a method in the module, outside a class definition, those work more efficiently than class methods."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]