[[{"text": ["For html encoding, there's cgi.escape from the standard library:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "cgi.escape", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt; help(cgi.escape)\ncgi.escape = escape(s, quote=None)\n    Replace special characters \"&amp;\", \"&lt;\" and \"&gt;\" to HTML-safe sequences.\n    If the optional flag quote is true, the quotation mark character (\")\n    is also translated.\n</code>\n</pre>\n", "senID": 1}, {"text": ["For html decoding, I use the following:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from htmlentitydefs import name2codepoint\n# for some reason, python 2.5.2 doesn't have this one (apostrophe)\nname2codepoint['#39'] = 39\n\ndef unescape(s):\n    \"unescape HTML code refs; c.f. http://wiki.python.org/moin/EscapingHtml\"\n    return re.sub('&amp;(%s);' % '|'.join(name2codepoint),\n              lambda m: unichr(name2codepoint[m.group(1)]), s)\n</code>\n</pre>\n", "senID": 3}, {"text": ["For anything more complicated, I use BeautifulSoup."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The Cheetah function should work, but is missing the single-quote.", "Use this tuple instead:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n htmlCodes = (\n    ('&amp;', '&amp;amp;'),\n    ('&lt;', '&amp;lt;'),\n    ('&gt;', '&amp;gt;'),\n    ('\"', '&amp;quot;'),\n    (\"'\", '&amp;#39;'),\n)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here's Django's django.utils.html.escape function for reference:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def escape(html):\n    \"\"\"Returns the given HTML with ampersands, quotes and carets encoded.\"\"\"\n    return mark_safe(force_unicode(html).replace('&amp;', '&amp;amp;').replace('&lt;', '&amp;l\nt;').replace('&gt;', '&amp;gt;').replace('\"', '&amp;quot;').replace(\"'\", '&amp;#39;'))\n</code>\n</pre>\n", "senID": 3}, {"text": ["I also think it would make more sense to store the HTML unescaped in your database.", "It'd be worth looking into getting unescaped results back from BeautifulSoup if possible."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In addition, escaping only occurs in Django during template rendering.", "So to prevent escaping you just tell the templating engine not to escape your string:  Use either {{ context_var|safe }} or {% autoescape off %}{{ context_var }}{% endautoescape %} in your templates."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "{{ context_var|safe }}", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "{% autoescape off %}{{ context_var }}{% endautoescape %}", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Use daniel's solution if the set of encoded characters is relatively restricted.", "Otherwise, use one of the numerous HTML-parsing libraries."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I like BeautifulSoup because it can handle malformed XML/HTML :"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://www.crummy.com/software/BeautifulSoup/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.crummy.com/software/BeautifulSoup/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/"}]}, {"text": ["for your question, there's an example in their documentation "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/documentation.html"}]}, {"code": "<pre>\n<code>\n from BeautifulSoup import BeautifulStoneSoup\nBeautifulStoneSoup(\"Sacr&amp;eacute; bl&amp;#101;u!\", \n                   convertEntities=BeautifulStoneSoup.HTML_ENTITIES).contents[0]\n# u'Sacr\\xe9 bleu!'\n</code>\n</pre>\n", "senID": 4}], [{"text": ["See at the bottom of this page at Python wiki, there are at least 2 options to \"unescape\" html."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "page at Python wiki", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/EscapingHtml"}]}], [{"text": ["Daniel's comment as an answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\"escaping only occurs in Django during template rendering.", "Therefore, there's no need for an unescape - you just tell the templating engine not to escape.", "either {{ context_var|safe }} or {% autoescape off %}{{ context_var }}{% endautoescape %}\""], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I found a fine function at: http://snippets.dzone.com/posts/show/4569"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://snippets.dzone.com/posts/show/4569", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://snippets.dzone.com/posts/show/4569"}]}, {"code": "<pre>\n<code>\n def decodeHtmlentities(string):\n    import re\n    entity_re = re.compile(\"&amp;(#?)(\\d{1,5}|\\w{1,8});\")\n\n    def substitute_entity(match):\n        from htmlentitydefs import name2codepoint as n2cp\n        ent = match.group(2)\n        if match.group(1) == \"#\":\n            return unichr(int(ent))\n        else:\n            cp = n2cp.get(ent)\n\n            if cp:\n                return unichr(cp)\n            else:\n                return match.group()\n\n    return entity_re.subn(substitute_entity, string)[0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I found this in the Cheetah source code (here)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.koders.com/python/fid549827F97513858275EEA43DC0135AC97AEAEF57.aspx"}]}, {"code": "<pre>\n<code>\n htmlCodes = [\n    ['&amp;', '&amp;amp;'],\n    ['&lt;', '&amp;lt;'],\n    ['&gt;', '&amp;gt;'],\n    ['\"', '&amp;quot;'],\n]\nhtmlCodesReversed = htmlCodes[:]\nhtmlCodesReversed.reverse()\ndef htmlDecode(s, codes=htmlCodesReversed):\n    \"\"\" Returns the ASCII decoded version of the given HTML string. This does\n        NOT remove normal HTML tags like &lt;p&gt;. It is the inverse of htmlEncode().\"\"\"\n    for code in codes:\n        s = s.replace(code[1], code[0])\n    return s\n</code>\n</pre>\n", "senID": 1}, {"text": ["not sure why they reverse the list,\n I think it has to do with the way they encode, so with you it may not need to be reversed.", "Also if I were you I would change htmlCodes to be a list of tuples rather than a list of lists...\nthis is going in my library though :)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["i noticed your title asked for encode too, so here is Cheetah's encode function."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def htmlEncode(s, codes=htmlCodes):\n    \"\"\" Returns the HTML encoded version of the given string. This is useful to\n        display a plain ASCII text string on a web page.\"\"\"\n    for code in codes:\n        s = s.replace(code[0], code[1])\n    return s\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Encode:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import cgi\nprint cgi.escape(\"&lt;\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["Decode:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import HTMLParser\nhtmlparser = HTMLParser.HTMLParser()\nprint htmlparser.unescape(\"&amp;gt;\")\n</code>\n</pre>\n", "senID": 3}]]