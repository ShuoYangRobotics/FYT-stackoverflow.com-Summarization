[[{"text": ["The answers suggesting list comprehensions are ALMOST correct -- except that they build a completely new list and then give it the same name the old list as, they do NOT modify the old list in place.", "That's different from what you'd be doing by selective removal, as in @Lennart's suggestion -- it's faster, but if your list is accessed via multiple references the fact that you're just reseating one of the references and NOT altering the list object itself can lead to subtle, disastrous bugs."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Fortunately, it's extremely easy to get both the speed of list comprehensions AND the required semantics of in-place alteration -- just code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n somelist[:] = [tup for tup in somelist if determine(tup)]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Note the subtle differene with other answers: this one is NOT assigning to a barename - it's asssigning to a list slice that just happens to be the entire list, thereby replacing the list contents within the same Python list object, rather than just reseating one reference (from previous list object to new list object) like the other answers."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "contents", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "within the same Python list object", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["A list comprehension is best for this kind of loop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n somelist = [x for x in somelist if determine(x)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT:\nJobs' comment says that he wants the 'determine' to say what should be deleted.", "That would then be just."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n somelist = [x for x in somelist if not determine(x)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["EDIT:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n somelist[:] = [x for x in somelist if not determine(x)]\n</code>\n</pre>\n", "senID": 5}, {"text": ["Brandon Corfman is correct, you will loose reference to the original list unless you do it this way and please see Alex Martelli's answer for the detail."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Also, I liked Cides' suggestion below using itertools.", "However there is no non iterator filterfalse, so it will have to be."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n from itertools import ifilterfalse\nsomelist[:] = list(ifilterfalse(determine, somelist))\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Your best approach for such an example would be a list comprehension"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "list comprehension", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions"}]}, {"code": "<pre>\n<code>\n somelist = [tup for tup in somelist if determine(tup)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["In cases where you're doing something more complex than calling a determine function, I prefer constructing a new list and simply appending to it as I go.", "For example"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "determine", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n newlist = []\nfor tup in somelist:\n    # lots of code here, possibly setting things up for calling determine\n    if determine(tup):\n        newlist.append(tup)\nsomelist = newlist\n</code>\n</pre>\n", "senID": 3}, {"text": ["Copying the list using remove might make your code look a little cleaner, as described in one of the answers below.", "You should definitely not do this for extremely large lists, since this involves first copying the entire list, and also performing an O(n) remove operation for each element being removed, making this an O(n^2) algorithm."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "remove", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "O(n)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "remove", "childNum": 0, "tag": "code", "childList": []}, {"text": "O(n^2)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n for tup in somelist[:]:\n    # lots of code here, possibly setting things up for calling determine\n    if determine(tup):\n        newlist.append(tup)\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n for i in xrange(len(somelist) - 1, -1, -1):\n    if some_condition(somelist, i):\n        del somelist[i]\n</code>\n</pre>\n", "senID": 0}, {"text": ["You need to go backwards otherwise it's a bit like sawing off the tree-branch that you are sitting on :-)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["For those that like functional programming:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; somelist[:] = filter(lambda tup: not determine(tup), somelist)\nor:\n&gt;&gt;&gt; from itertools import ifilterfalse\n&gt;&gt;&gt; somelist[:] = list(ifilterfalse(determine, somelist))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Updated to correct my answer.", "Thanks, David Raznick."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You need to take a copy of the list and iterate over it first, or the iteration will fail with what may be unexpected results."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example (depends on what type of list):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for tup in somelist[:]:\n    etc....\n</code>\n</pre>\n", "senID": 2}, {"text": ["An example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list = range(10)\n&gt;&gt;&gt; for x in list:\n...     list.remove(x)\n&gt;&gt;&gt; list\n[1, 3, 5, 7, 9]\n\n&gt;&gt;&gt; list = range(10)\n&gt;&gt;&gt; for x in list[:]:\n...     list.remove(x)\n&gt;&gt;&gt; list\n[]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You might want to use filter() available as the built-in."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://docs.python.org/library/functions.html#filter"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/functions.html#filter", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#filter"}]}], [{"text": ["The question was about modifying while iterating, not computing a new list and storing it in the extent of the old list.", "The only solution which actually answers the question is the one which iterates backwards by index."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]