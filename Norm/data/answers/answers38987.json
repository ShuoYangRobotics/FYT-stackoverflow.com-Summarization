[[{"text": ["In your case, what you can do is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n z = dict(x.items() + y.items())\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will, as you want it, put the final dict in z, and make the value for b be properly overridden by the second dict's value:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = {'a':1, 'b': 2}\n&gt;&gt;&gt; y = {'b':10, 'c': 11}\n&gt;&gt;&gt; z = dict(x.items() + y.items())\n&gt;&gt;&gt; z\n{'a': 1, 'c': 11, 'b': 10}\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you use Python 3, it is only a little more complicated.", "To create z:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; z = dict(list(x.items()) + list(y.items()))\n&gt;&gt;&gt; z\n{'a': 1, 'c': 11, 'b': 10}\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Another, more concise, option:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n z = dict(x, **y)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note: this has become a popular answer, but it is important to point out that if y has any non-string keys, the fact that this works at all is an abuse of a CPython implementation detail, and it does not work in CPython 3.2, or in PyPy, IronPython, or Jython.", "Also, Guido is not a fan.", "So I can't recommend this technique for forward-compatible or cross-implementation portable code, which really means it should be avoided entirely."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "Note", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"href": "http://mail.python.org/pipermail/python-dev/2010-April/099459.html", "text": "Guido is not a fan", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["This probably won't be a popular answer, but you almost certainly do not want to do this.", "If you want a copy that's a merge, then use copy (or deepcopy, depending on what you want) and then update.", "The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().", "Explicit is better than implicit."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "deepcopy", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-copy.html"}]}, {"text": ["In addition, when you use .items() (pre Python 3.0), you're creating a new list that contains the items from the dict.", "If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).", "update() can work more efficiently, because it can run through the second dict item-by-item."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In terms of time:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "time", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-timeit.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; timeit.Timer(\"dict(x, **y)\", \"x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))\").timeit(100000)\n15.52571702003479\n&gt;&gt;&gt; timeit.Timer(\"temp = x.copy()\\ntemp.update(y)\", \"x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))\").timeit(100000)\n15.694622993469238\n&gt;&gt;&gt; timeit.Timer(\"dict(x.items() + y.items())\", \"x = dict(zip(range(1000), range(1000)))\\ny=dict(zip(range(1000,2000), range(1000,2000)))\").timeit(100000)\n41.484580039978027\n</code>\n</pre>\n", "senID": 3}, {"text": ["IMO the tiny slowdown between the first two is worth it for the readability.", "In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Carl, in a follow-up answer, you asked about the relative performance of these two alternatives:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n z1 = dict(x.items() + y.items())\nz2 = dict(x, **y)\n</code>\n</pre>\n", "senID": 1}, {"text": ["On my machine, at least (a fairly ordinary x86_64 running Python 2.5.2), alternative z2 is not only shorter and simpler but also significantly faster.", "You can verify this for yourself using the timeit module that comes with Python."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "z2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "timeit", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Example 1: identical dictionaries mapping 20 consecutive integers to themselves"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n % python -m timeit -s 'x=y=dict((i,i) for i in range(20))' 'z1=dict(x.items() + y.items())'\n100000 loops, best of 3: 5.67 usec per loop\n% python -m timeit -s 'x=y=dict((i,i) for i in range(20))' 'z2=dict(x, **y)' \n100000 loops, best of 3: 1.53 usec per loop\n</code>\n</pre>\n", "senID": 4}, {"text": ["z2 wins by a factor of 3.5 or so.", "Different dictionaries seem to yield quite different results, but z2 always seems to come out ahead.", "(If you get inconsistent results for the same test, try passing in -r with a number larger than the default 3."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "z2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "z2", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "same", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "-r", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Example 2: non-overlapping dictionaries mapping 252 short strings to integers and vice versa"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n % python -m timeit -s 'from htmlentitydefs import codepoint2name as x, name2codepoint as y' 'z1=dict(x.items() + y.items())'\n1000 loops, best of 3: 260 usec per loop\n% python -m timeit -s 'from htmlentitydefs import codepoint2name as x, name2codepoint as y' 'z2=dict(x, **y)'               \n10000 loops, best of 3: 26.9 usec per loop\n</code>\n</pre>\n", "senID": 7}, {"text": ["z2 wins by about a factor of 10.", "That's a pretty big win in my book!"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "z2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["After comparing those two, I wondered if z1's poor performance could be attributed to the overhead of constructing the two item lists, which in turn led me to wonder if this variation might work better:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "z1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import chain\nz3 = dict(chain(x.iteritems(), y.iteritems()))\n</code>\n</pre>\n", "senID": 10}, {"text": ["A few quick tests, e.g."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n % python -m timeit -s 'from itertools import chain; from htmlentitydefs import codepoint2name as x, name2codepoint as y' 'z3=dict(chain(x.iteritems(), y.iteritems()))'\n10000 loops, best of 3: 66 usec per loop\n</code>\n</pre>\n", "senID": 12}, {"text": ["lead me to conclude that z3 is somewhat faster than z1, but not nearly as fast as z2.", "Definitely not worth all the extra typing."], "childNum": 3, "tag": "p", "senID": 13, "childList": [{"text": "z3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "z1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "z2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["This discussion is still missing something important, which is a performance comparison of these alternatives with the \"obvious\" way of merging two lists: using the update method.", "To try to keep things on an equal footing with the expressions, none of which modify x or y, I'm going to make a copy of x instead of modifying it in-place, as follows:"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "update", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n z0 = dict(x)\nz0.update(y)\n</code>\n</pre>\n", "senID": 15}, {"text": ["A typical result:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n % python -m timeit -s 'from htmlentitydefs import codepoint2name as x, name2codepoint as y' 'z0=dict(x); z0.update(y)'\n10000 loops, best of 3: 26.9 usec per loop\n</code>\n</pre>\n", "senID": 17}, {"text": ["In other words, z0 and z2 seem to have essentially identical performance.", "Do you think this might be a coincidence?", "I don't...."], "childNum": 2, "tag": "p", "senID": 18, "childList": [{"text": "z0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "z2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["In fact, I'd go so far as to claim that it's impossible for pure Python code to do any better than this.", "And if you can do significantly better in a C extension module, I imagine the Python folks might well be interested in incorporating your code (or a variation on your approach) into the Python core.", "Python uses dict in lots of places; optimizing its operations is a big deal."], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["[UPDATE: You could also write this as"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"code": "<pre>\n<code>\n z0 = x.copy()\nz0.update(y)\n</code>\n</pre>\n", "senID": 21}, {"text": ["as Tony does, but (not surprisingly) the difference in notation turns out not to have any measurable effect on performance.", "Use whichever looks right to you.", "Of course, he's absolutely correct to point out that the two-statement version is much easier to understand."], "childNum": 0, "tag": "p", "senID": 22, "childList": []}], [{"text": ["An alternative:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n z = x.copy()\nz.update(y)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I wanted something similar, but with the ability to specify how the values on duplicate keys were merged, so I hacked this out (not heavily tested!).", "Obviously this is not a single expression, but it is a single fn.", "call."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def merge(d1, d2, merge=lambda x,y:y):\n    \"\"\"\n    Merges two dictionaries, non-destructively, combining \n    values on duplicate keys as defined by the optional merge\n    function.  The default behavior replaces the values in d1\n    with corresponding values in d2.  (There is no other generally\n    applicable merge strategy, but often you'll have homogeneous \n    types in your dicts, so specifying a merge technique can be \n    valuable.)\n\n    Examples:\n\n    &gt;&gt;&gt; d1\n    {'a': 1, 'c': 3, 'b': 2}\n    &gt;&gt;&gt; merge(d1, d1)\n    {'a': 1, 'c': 3, 'b': 2}\n    &gt;&gt;&gt; merge(d1, d1, lambda x,y: x+y)\n    {'a': 2, 'c': 6, 'b': 4}\n\n    \"\"\"\n    result = dict(d1)\n    for k,v in d2.iteritems():\n        if k in result:\n            result[k] = merge(result[k], v)\n        else:\n            result[k] = v\n    return result\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n x = {'a':1, 'b': 2}\ny = {'b':10, 'c': 11}\nz = dict(x.items() + y.items())\nprint z\n</code>\n</pre>\n", "senID": 0}, {"text": ["For items with keys in both dictionaries ('b'), you can control which one ends up in the output by putting that one last."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The best version I could think while not using copy would be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import chain\nx = {'a':1, 'b': 2}\ny = {'b':10, 'c': 11}\ndict(chain(x.iteritems(), y.iteritems()))\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's faster than dict(x.items() + y.items()) but not as fast as n = copy(a); n.update(b), at least on CPython.", "This version also works in Python 3 if you change iteritems() to items(), which is automatically done by the 2to3 tool."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "dict(x.items() + y.items())", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "n = copy(a); n.update(b)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "iteritems()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "items()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Personally I like this version best because it describes fairly good what I want in a single  functional syntax.", "The only minor problem is that it doesn't make completely obvious that values from y takes precedence over values from x, but I don't believe it's difficult to figure that out."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]