[[{"text": ["A case where regular expressions are justified:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nDATA = \"Hey, you - what are you doing here!?\"\nprint re.findall(r'\\w+', DATA)\n# Prints ['Hey', 'you', 'what', 'are', 'you', 'doing', 'here']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["re.split()"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re.split()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html#re.split"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; re.split('\\W+', 'Words, words, words.')\n['Words', 'words', 'words', '']\n&gt;&gt;&gt; re.split('(\\W+)', 'Words, words, words.')\n['Words', ', ', 'words', ', ', 'words', '.', '']\n&gt;&gt;&gt; re.split('\\W+', 'Words, words, words.', 1)\n['Words', 'words, words.']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["another way, without regex"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import string\npunc = string.punctuation\nthestring =  \"Hey, you - what are you doing here!?\"\ns=list(thestring)\n''.join([ o for o in s if not o in string.punctuation ]).split()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Kinda late answer :), but I had a similar dilemma and didn't want to use 're' module."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def my_split(s, seps):\n    res = [s]\n    for sep in seps:\n        s, res = res, []\n        for seq in s:\n            res += seq.split(sep)\n    return res\n\nprint my_split('1111  2222 3333;4444,5555;6666', [' ', ';', ','])\n['1111', '', '2222', '3333', '4444', '5555', '6666']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nphrase = \"Hey, you - what are you doing here!?\"\nmatches = re.findall('\\w+', phrase)\nprint matches\n</code>\n</pre>\n", "senID": 1}, {"text": ["this will print ['Hey', 'you', 'what', 'are', 'you', 'doing', 'here']"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "['Hey', 'you', 'what', 'are', 'you', 'doing', 'here']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Another way to achieve this is to use the Natural Language Tool Kit (nltk)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "nltk", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://nltk.org/doc/en/ch02.html"}]}, {"code": "<pre>\n<code>\n import nltk\ndata= \"Hey, you - what are you doing here!?\"\nword_tokens = nltk.tokenize.regexp_tokenize(data, r'\\w+')\nprint word_tokens\n</code>\n</pre>\n", "senID": 1}, {"text": ["This prints: ['Hey', 'you', 'what', 'are', 'you', 'doing', 'here']"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "['Hey', 'you', 'what', 'are', 'you', 'doing', 'here']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The biggest drawback of this method is that you need to install the nltk package."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "install the nltk package", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/nltk/0.9.9"}]}, {"text": ["The benefits are that you can do a lot of fun stuff with the rest of the nltk package once you get your tokens."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "a lot of fun stuff", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://nltk.googlecode.com/svn/trunk/doc/howto/index.html"}]}], [{"code": "<pre>\n<code>\n join = lambda x: sum(x,[])  # a.k.a. flatten1([[1],[2,3],[4]]) -&gt; [1,2,3,4]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Three-liner:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n fragments = [text]\nfor token in tokens:\n    fragments = join(f.split(token) for f in fragments)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Explanation"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Explanation", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This is what in Haskell is known as the List monad.", "The idea behind the monad is that once \"in the monad\" you \"stay in the monad\" until something takes you out.", "For example in Haskell, say you map the python range(n) -&gt; [1,2,...,n] function over a List.", "If the result is a List, it will be append to the List in-place, so you'd get something like map(range, [3,4,1]) -&gt; [0,1,2,0,1,2,3,0].", "This is known as map-append (or mappend, or maybe something like that).", "The idea here is that you've got this operation you're applying (splitting on a token), and whenever you do that, you join the result into the list."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "range(n) -&gt; [1,2,...,n]", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "map(range, [3,4,1]) -&gt; [0,1,2,0,1,2,3,0]", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["You can abstract this into a function and have tokens=string.punctuation by default. "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "tokens=string.punctuation", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Advantages of this approach:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "This approach (unlike naive regex-based approaches) can work with arbitrary-length tokens (which regex can also do with more advanced syntax).", "tag": "none", "senID": 7}, {"text": "You are not restricted to mere tokens; you could have arbitrary logic in place of each token, for example one of the \"tokens\" could be a function which splits according to how nested parentheses are.", "tag": "none", "senID": 8}]}], [{"text": ["Another quick way to do this without a regexp is to replace the characters first, as below:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 'a;bcd,ef g'.replace(';',' ').replace(',',' ').split()\n['a', 'bcd', 'ef', 'g']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You want Python's RegEx module's findall() method:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "findall()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["http://www.regular-expressions.info/python.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.regular-expressions.info/python.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.regular-expressions.info/python.html"}]}, {"text": ["Example"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Example", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/234512/splitting-strings-in-python"}]}], [{"text": ["got same problem as @ooboo and find this topic\n@ghostdog74 inspired me, maybe someone finds my solution usefull"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n str1='adj:sg:nom:m1.m2.m3:pos'\nsplitat=':.'\n''.join([ s if s not in splitat else ' ' for s in str1]).split()\n</code>\n</pre>\n", "senID": 1}, {"text": ["input something in space place and split using same character if you dont want to split at spaces."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here is my go at a split with multiple deliminaters:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def msplit( str, delims ):\n  w = ''\n  for z in str:\n    if z not in delims:\n        w += z\n    else:\n        if len(w) &gt; 0 :\n            yield w\n        w = ''\n  if len(w) &gt; 0 :\n    yield w\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Use list comprehensions for this stuff...it seems easier"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n data= \"Hey, you - what are you doing here!?\"\ntokens = [c for c in data if c not in (',', ' ', '-', '!', '?')]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I find this easier to comprehend (read..maintain) than using regexp, simply because I am not that good at regexp...which is the case with most of us :) .", "Also if you know what set of separators you might be using, you can keep them in a set.", "With a very huge set, this might be slower...but the 're' module is slow as well."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]