[[{"tag": "ul", "num": 2, "lis": [{"text": ["Mutable default arguments in\nfunctions or methods, like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Mixing tabs and spaces."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]}], [{"tag": "ul", "num": 1, "lis": [{"text": "Using preconditional checking (", "tag": "none", "senID": 0}]}, {"text": ["YES:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "YES", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def safe_divide_2(x, y):\n    try:\n        return x/y\n    except ZeroDivisionError:  \n        print \"Divide-by-0 attempt detected\"\n        return None\n</code>\n</pre>\n", "senID": 2}, {"text": ["NO:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "NO", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def safe_divide_1(x, y):\n    if y==0:\n        print \"Divide-by-0 attempt detected\"\n        return None\n    else:\n        return x/y\n</code>\n</pre>\n", "senID": 4}, {"tag": "ul", "num": 1, "lis": [{"text": "Not using list comprehensions (", "tag": "none", "senID": 5}]}, {"text": ["YES:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "YES", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def double_list(items):\n    return [item * 2 for item in items]\n</code>\n</pre>\n", "senID": 7}, {"text": ["NO:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "NO", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def double_list(items):\n    doubled_items=[]\n    for item in items:\n        doubled_items.append(item*2)\n    return doubled_items\n</code>\n</pre>\n", "senID": 9}, {"tag": "ul", "num": 1, "lis": [{"text": "Returning lists instead of using generators (", "tag": "none", "senID": 10}]}, {"text": ["YES:"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "YES", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def gen():\n    for i in range(10):\n        yield i\n\nfor number in gen():\n    print i #prints 0-9\n</code>\n</pre>\n", "senID": 12}, {"text": ["NO:"], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "NO", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #list comprehension would be used here, but I did a for loop for clarity\ndef gen():\n    numlist=[]\n    for i in range(10):\n        numlist.append(i)\n    return numlist\n\nfor number in gen():\n    print i #prints 0-9\n</code>\n</pre>\n", "senID": 14}], [{"text": ["I would say that programming in Python as if it were some other language is an \"anti-pattern\" i see quite often."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, for Java/C# refugees it is using classes for everything:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Util():\n  @staticmethod\n  def foo():\n    ...\n\n# this should be just a function;\n# it can be placed in 'util' module\ndef foo():\n  ...\n</code>\n</pre>\n", "senID": 2}, {"text": ["Another case:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Pair():\n  def __init__(self, first, second):\n    ...\n\npairs = [Pair(1, 2), Pair(3, 4)]\n\n# usually built-in tuple is enough\npairs = [(1, 2), (3, 4)]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Inappropriate use of isinstance.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "isinstance", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["People coming from static language backgrounds often completely miss the simplicity and flexibility of Python's dynamic polymorphism (aka duck typing)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This answer to another question provides a helpful discussion on Python polymorphism ignorance."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/423823/whats-your-favorite-programmer-ignorance-pet-peeve/423857#423857"}]}], [{"text": ["Using Java-style getters and setters for every field:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def get_field(self): \n   return self.field\ndef set_field(self, val): \n   self.field = val\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's usually better just to access the field directly, and for more advanced usage you can smoothly transition to using property()."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "property()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Excessive (ab)use of the reduce function. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n for i in xrange(len(something)):\n    workwith = something[i]\n    # do things with workwith...\n</code>\n</pre>\n", "senID": 0}, {"text": ["From vartec's answer, but I think it's good (bad?", ") enough to deserve its own answer."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"tag": "ul", "num": 3, "lis": [{"text": "using list where it's possible to use generators;", "tag": "none", "senID": 0}, {"text": "using ", "tag": "none", "senID": 1}, {"text": "excessive [ab]use of lambda functions;", "tag": "none", "senID": 2}]}], [{"text": ["The Decorate-Sort-Undecorate idiom in later versions of Python where you can just use the key parameter. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n deco = [(key(item), i, item) for i, item in enumerate(items)]\ndeco.sort()\nfinal = [item for _, _, item in deco]\n</code>\n</pre>\n", "senID": 1}, {"text": ["versus:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n final = sorted(items, key=key)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["It's mentioned as part of nikow's answer but I thought it deserved a post of its own."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "Mixing tabs and spaces for indentation.", "tag": "none", "senID": 1}]}], [{"text": ["Not using python functions ;)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n value = 0\nfor car in cars:\n    value += car.value\nreturn value\n\n# instead, do\nreturn sum(car.value for car in cars)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using positional arguments to fill keyword parameters."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["e.g.", "given:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def foo(x, a=1, b=2):\n    # etc\n</code>\n</pre>\n", "senID": 2}, {"text": ["calling it as:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n foo(14, 21)\n</code>\n</pre>\n", "senID": 4}, {"text": ["This always bugs me, though maybe it's because I have a short memory and without the clue of the keyword (a=21) I forget what the argument means."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "a=21", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This is particularly prevalent in wxPython code."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["A inexhaustible source of anti-patterns: see the Zope source code and all their contributions to the cheeseshop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Using map() or a list comprehension to perform a repeated operation on a sequence of items, instead of a for loop:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n map(list.sort, list_of_lists)\n[ lst.sort() for lst in list_of_lists ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The telltale sign is that these statements create a list that is not assigned to anything.", "Why not just make your intent clear, that you want to iterate over a sequence and apply an operation to each item:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for lst in list_of_lists:\n    lst.sort()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["not using enumerate."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "enumerate", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#enumerate"}]}, {"text": ["If you need to loop over a sequence, and access its position/index along with the value itself, you should use enumerate."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I've seen weird stuff like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n foo = ['a', 'b', 'c']\n\nfor i, item in zip(range(len(foo)), foo):\n    print i, item\n</code>\n</pre>\n", "senID": 3}, {"text": ["when all you need to do is:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n foo = ['a', 'b', 'c']\n\nfor i, item in enumerate(foo):\n    print i, item\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Am I allowed to add answers for misuse of important standard library tools?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You probably already know not to use print in anything larger than a one-off script; that's what the logging module is for."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "print", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "logging", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Unfortunately, it's far to easy to get into just as big a mess using that module.", "A key insight into using logging effectively is to view it as a producer-consumer interface.", "Producers, which will be the bulk of any system, the part that 'uses' logging, but mainly does the actual application work, only ever call the info(), error(), debug() methods on a logger, and in general just accept whatever logger instance is around.", "The 'consumer' is the program \"entry point\", the part that interprets command line options or reads config files.", "The entry point is the only part that should ever create logging handlers and formatters, or call the setLevel() method on individual loggers or handlers. "], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "info()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "error()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "debug()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "handlers", "childNum": 0, "tag": "em", "pos": 4, "childList": []}, {"text": "formatters", "childNum": 0, "tag": "em", "childList": []}, {"text": "setLevel()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Bad:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import logging\n\nclass Thing(object):\n    def __init__(self):\n        self.logger = logging.getLogger(\"thing\")\n        console = logging.StreamHandler()\n        console.setLevel(logging.INFO)\n        self.logger.addHandler(console)\n        self.logger.setLevel(logging.INFO)\n    def speak(self, message):\n        self.logger.info(\"Oh... um, Hi %s\", message)\n\nmyThing = Thing()\nyourThing = Thing()\n\nprint 'myThing'\nmyThing.speak(\"me\")\nprint 'yourThing'\nyourThing.speak(\"you\")\n</code>\n</pre>\n", "senID": 4}, {"text": ["Good!"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import logging, logging.handlers\n\nclass GoodThing(object):\n    logger = logging.getLogger(\"goodThing\")\n\n    def speak(self, message):\n        self.logger.info(\"Good morning, %s!\", message)\n\nmyThing = GoodThing()\nyourThing = GoodThing()\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    yourHandler = logging.handlers.MemoryHandler(float('inf'))\n    yourLogger = logging.Logger(\"your_thing\")\n    yourLogger.addHandler(yourHandler)\n    yourThing.logger = yourLogger\n\n    print 'myThing'\n    myThing.speak(\"me\")\n    print 'yourThing'\n    yourThing.speak(\"you\")\n\n    print yourHandler.buffer[-1].msg, yourHandler.buffer[-1].args\n</code>\n</pre>\n", "senID": 6}]]