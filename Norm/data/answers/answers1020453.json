[[{"text": ["You are referring to the run-time duck-typing as \"overriding\" inheritance, however I believe inheritance has its own merits as a design and implementation approach, being an integral part of object oriented design.", "In my humble opinion, the question of whether you can achieve something otherwise is not very relevant, because actually you could code Python without classes, functions and more, but the question is how well-designed, robust and readable your code will be."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I can give two examples for where inheritance is the right approach in my opinion, I'm sure there are more. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["First, if you code wisely, your makeSpeak function may want to validate that its input is indeed an Animal, and not only that \"it can speak\", in which case the most elegant method would be to use inheritance.", "Again, you can do it in other ways, but that's the beauty of object oriented design with inheritance - your code will \"really\" check whether the input is an \"animal\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Second, and clearly more straightforward, is Encapsulation - another integral part of object oriented design.", "This becomes relevant when the ancestor has data members and/or non-abstract methods.", "Take the following silly example, in which the ancestor has a function (speak_twice) that invokes a then-abstract function:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Animal(object):\n    def speak(self):\n        raise NotImplementedError()\n\n    def speak_twice(self):\n        self.speak()\n        self.speak()\n\nclass Dog(Animal):\n    def speak(self):\n        print \"woff!\"\n\nclass Cat(Animal):\n    def speak(self):\n        print \"meow\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["Assuming \"speak_twice\" is an important feature, you don't want to code it in both Dog and Cat, and I'm sure you can extrapolate this example.", "Sure, you could implement a Python stand-alone function that will accept some duck-typed object, check whether it has a speak function and invoke it twice, but that's both non-elegant and misses point number 1 (validate it's an Animal).", "Even worse, and to strengthen the Encapsulation example, what if a member function in the descendant class wanted to use \"speak_twice\"?"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "\"speak_twice\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\"speak_twice\"", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["It gets even clearer if the ancestor class has a data member, for example \"number_of_legs\" that is used by non-abstract methods in the ancestor like \"print_number_of_legs\", but is initiated in the descendant class' constructor (e.g.", "Dog would initialize it with 4 whereas Snake would initialize it with 0). "], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "\"number_of_legs\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\"print_number_of_legs\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Again, I'm sure there are endless more examples, but basically every (large enough) software that is based on solid object oriented design will require inheritance."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["In your second example of Python, how do you propose that all instances of Dogs and Cats will be able to speak()?", "Your first example in Python, you're at least trapping this.", "However, your program can stop under the right circumstances, which may or may not be what you want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also, why not consider doing this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Animal(object):\n    def speak(self):\n        raise NotImplementedError()\n\nclass Dog(Animal):\n    def speak(self):\n        print \"woff!\"\n\nclass Cat(Animal):\n    def speak(self):\n        print \"meow\"\n\nd=Dog()\nc=Cat()\n\n# Apply the method directly.\nd.speak()\nc.speak()\n</code>\n</pre>\n", "senID": 2}, {"text": ["The raise in there can cause \"issues\" in your code, although as I said earlier, maybe you don't want that to happen.", "So let's extend this even further:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "raise", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Animal(object):\n    def __init__(self):\n        self.canSpeak = False\n    def speak(self, sound):\n        if self.canSpeak == True:\n            print sound\n\nclass Dog(Animal):\n    def speak(self, sound=\"Woof!\"):\n        Animal.speak(self, sound)\n\nclass Cat(Animal):\n    def __init__(self):\n        self.canSpeak = True\n    def speak(self, sound=\"Meow!\"):\n        Animal.speak(self,sound)\n\nd=Dog()\nc=Cat()\n\n# Apply the method directly.\nd.speak()\nc.speak()\n</code>\n</pre>\n", "senID": 4}, {"text": ["Ah-ha!", "Now your Cat can speak, your Dog won't, but calling speak() for a Dog won't raise an exception because your inheriting speak from Animal, which implements speak() for both Dog and Cat.", "But guess what?", "Goose and Moose drop by and want to have their say too!", "So here's what we have now..."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class Animal(object):\n    def __init__(self):\n        self.canSpeak = False\n    def speak(self, sound):\n        if self.canSpeak == True:\n            print sound\n\nclass Dog(Animal):\n    def speak(self, sound=\"Woof!\"):\n        Animal.speak(self, sound)\n\nclass Cat(Animal):\n    def __init__(self):\n        self.canSpeak = True\n    def speak(self, sound=\"Meow!\"):\n        Animal.speak(self,sound)\n\nclass Goose(Animal):\n    def __init__(self):\n        self.canSpeak = True\n    def speak(self, sound=\"Honk!\"):\n        Animal.speak(self,sound)\n\nclass Moose(Animal):\n    def __init__(self):\n        self.canSpeak = True\n    def speak(self, sound=\"Muhhhh!\"):\n        Animal.speak(self,sound)\n\nd=Dog()\nc=Cat()\ng=Goose()\nm=Moose()\n\n# Apply the method directly.\nd.speak()\nc.speak()\ng.speak()\nm.speak()\n</code>\n</pre>\n", "senID": 6}, {"text": ["Notice that the code is fairly deterministic, as long as it's executing within the scope of the object - .canSpeak is always set to some value, and .speak() is always valid.", "So, it's up to you if you really want to have that raise show up at some point, or if you just want to keep truck'in along by just coding in advance a common method.", "Using the older code you had, you would have to grind out a speak for your Goose or Moose, or worse, if you forgot to crank out a speak(), the whole thing would grind to a halt; but the new code bringsspeak()along for free via inheritance.", "So now Goose, Moose, Cat, and Dog can all speak() (well, sorta, the Dog still needs attention from the Vet^H^H^HCoder, and we're assuming that Goose and Moose will get their .canSpeak set when they __init__() )."], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "raise", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "but the new code bringsspeak()along for free via inheritance", "childNum": 1, "tag": "em", "pos": 2, "childList": [{"text": "speak()", "tag": "code"}]}, {"text": "speak()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "speak()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Inheritance is just another tool, and given that everything in Python - even string literals - are objects, you'll have some need at some time to use this feature."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["I think the point of inheritance in Python is not to make the code compile, it is for the real reason of inheritance which is extending the class into another child class, and to override the logic in the base class.", "However the duck typing in Python makes the \"interface\" concept useless, because you can just check if the method exist before invokation with no need to use an interface to limit the class structure."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I think that it is very difficult to give a meaningful, concrete answer with such abstract examples..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To simplify, there are two types of inheritance: interface and implementation.", "If you need to inherit the implementation, then python is not so different than statically typed OO languages like C++. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Inheritance of interface is where there is a big difference, with fundamental consequences for the design of your software in my experience.", "Languages like Python does not force you to use inheritance in that case, and avoiding inheritance is a good point in most cases, because it is very hard to fix a wrong design choice there later.", "That's a well known point raised in any good OOP book."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["There are cases where using inheritance for interfaces is advisable in Python, for example for plug-ins, etc... For those cases, Python 2.5 and below lacks a \"built-in\" elegant approach, and several big frameworks designed their own solutions (zope, trac, twister).", "Python 2.6 and above has ABC classes to solve this."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "ABC classes to solve this", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3119/#abcs-vs-duck-typing"}]}], [{"text": ["Inheritance in Python is all about code reuse.", "Factorize common functionality into a base class, and implement different functionality in the derived classes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Inheritance in Python is more of a convenience than anything else.", "I find that it's best used to provide a class with \"default behavior."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Indeed, there is a significant community of Python devs who argue against using inheritance at all.", "Whatever you do, don't just don't overdo it.", "Having an overly complicated class hierarchy is a sure way to get labeled a \"Java programmer\", and you just can't have that.", ":-)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["In C++/Java/etc, polymorphism is caused by inheritance.", "Abandon that misbegotten belief, and dynamic languages open up to you."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Essentially, in Python there is no interface so much as \"the understanding that certain methods are callable\".", "Pretty hand-wavy and academic-sounding, no?", "It means that because you call \"speak\" you clearly expect that the object should have a \"speak\" method.", "Simple, huh?", "This is very Liskov-ian in that the users of a class define its interface, a good design concept that leads you into healthier TDD."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So what is left is, as another poster politely managed to avoid saying, a code sharing trick.", "You could write the same behavior into each \"child\" class, but that would be redundant.", "Easier to inherit or mix-in functionality that is invariant across the inheritance hierarchy.", "Smaller, DRY-er code is better in general.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can get around inheritance in Python and pretty much any other language.", "It's all about code reuse and code simplification though.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Just a semantic trick, but after building your classes and base classes, you don't even have to know what's possible with your object to see if you can do it.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Say you have d which is a Dog that subclassed Animal."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n command = raw_input(\"What do you want the dog to do?\")\nif command in dir(d): getattr(d,command)()\n</code>\n</pre>\n", "senID": 3}, {"text": ["If whatever the user typed in is available, the code will run the proper method.  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Using this you can create whatever combination of Mammal/Reptile/Bird hybrid monstrosity you want, and now you can make it say 'Bark!", "' while flying and sticking out its forked tongue and it will handle it properly!", "Have fun with it!"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I don't see much point in inheritance."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Every time I have ever used inheritance in real systems, I got burned because it led to a tangled web of dependencies, or I simply realised in time that I would be a lot better off without it.", "Now, I avoid it as much as possible.", "I simply never have a use for it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Repeat:\n    \"Send a message more than once\"\n    def __init__(repeat, times, do):\n        repeat.times = times\n        repeat.do = do\n\n    def __call__(repeat):\n        for i in xrange(repeat.times):\n             repeat.do()\n\nclass Speak:\n    def __init__(speak, animal):\n        \"\"\"\n        Check that the animal can speak.\n\n        If not we can do something about it (e.g. ignore it).\n        \"\"\"\n        speak.__call__ = animal.speak\n\n    def twice(speak):\n        Repeat(2, speak)()\n\nclass Dog:\n     def speak(dog):\n         print \"Woof\"\n\nclass Cat:\n     def speak(cat):\n         print \"Meow\"\n\n&gt;&gt;&gt; felix = Cat()\n&gt;&gt;&gt; Speak(felix)()\nMeow\n\n&gt;&gt;&gt; fido = Dog()\n&gt;&gt;&gt; speak = Speak(fido)\n&gt;&gt;&gt; speak()\nWoof\n\n&gt;&gt;&gt; speak.twice()\nWoof\n\n&gt;&gt;&gt; speak_twice = Repeat(2, Speak(felix))\n&gt;&gt;&gt; speak_twice()\nMeow\nMeow\n</code>\n</pre>\n", "senID": 2}, {"text": ["James Gosling was once asked at a press conference a question along the lines: \"If you could go back and do Java differently, what would you leave out?\".", "His response was \"Classes\", to which there was laughter.", "However, he was serious and explained that really, it was not classes that were the problem but inheritance."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I kind of view it like a drug dependency - it gives you a quick fix that feels good, but in the end, it messes you up.", "By that I mean that it is a convenient way to reuse code, but it forces an unhealthy coupling between child and parent class.", "Changes to the parent may break the child.", "The child is dependant on the parent for certain functionality and cannot alter that functionality.", "Therefore the functionality provided by the child is also tied to the parent - you can only have both."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Better is to provide one single client facing class for an interface which implements the interface, using the functionality of other objects which are composed at construction time.", "Doing this via properly designed interfaces, all coupling can be eliminated and we provide a highly composable API (This is nothing new - most programmers already do this, just not enough).", "Note that the implementing class must not simply expose functionality, otherwise the client should just use the composed classes directly - it must do something new by combining that functionality."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "must", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["There is the argument from the inheritance camp that pure delegation implementations suffer because they require lots of 'glue' methods which simply pass along values through a delegation 'chain'.", "However, this is simply reinventing an inheritance-like design using delegation.", "Programmers with too many years of exposure to inheritance-based designs are particularly vulnerable to falling into this trap, as, without realising it, they will think of how they would implement something using inheritance and then convert that to delegation."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Proper separation of concerns like the above code doesn't require glue methods, as each step is actually adding value, so they are not really 'glue' methods at all (if they don't add value, the design is flawed)."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "adding value", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["It boils down to this:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["For reusable code, each class should do only one thing\n(and do it well). "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Inheritance creates classes that do\nmore than one thing, because they are\nmixed up with parent classes. "], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Therefore, using inheritance makes classes that are hard to reuse."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}]}], [{"text": ["It's not inheritance that duck-typing makes pointless, it's interfaces \u2014 like the one you chose in creating an all abstract animal class."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you had used an animal class that introduce some real behavior for its descendants to make use of, then dog and cat classes that introduced some additional behavior there would be a reason for both classes.", "It's only in the case of the ancestor class contributing no actual code to the descendant classes that your argument is correct."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Because Python can directly know the capabilities of any object, and because those capabilities are mutable beyond the class definition, the idea of using a pure abstract interface to \"tell\" the program what methods can be called is somewhat pointless.", "But that's not the sole, or even the main, point of inheritance."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Classes in Python are basically just ways of grouping a bunch of functions and data..", "They are different to classes in C++ and such.."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I've mostly seen inheritance used for overriding methods of the super-class.", "For example, perhaps a more Python'ish use of inheritance would be.."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from world.animals import Dog\n\nclass Cat(Dog):\n    def speak(self):\n        print \"meow\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["Of course cats aren't a type of dog, but I have this (third party) Dog class which works perfectly, except the speak method which I want to override - this saves re-implementing  the entire class, just so it meows.", "Again, while Cat isn't a type of Dog, but a cat does inherit a lot of attributes.."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "Dog", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "except", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "speak", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Cat", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Dog", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["A much better (practical) example of overriding a method or attribute is how you change the user-agent for urllib.", "You basically subclass urllib.FancyURLopener and change the version attribute (from the documentation):"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "urllib.FancyURLopener", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://docs.python.org/library/urllib.html#urllib.%5Furlopener", "text": "from the documentation", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n import urllib\n\nclass AppURLopener(urllib.FancyURLopener):\n    version = \"App/1.7\"\n\nurllib._urlopener = AppURLopener()\n</code>\n</pre>\n", "senID": 5}, {"text": ["Another manner exceptions are used is for Exceptions, when inheritance is used in a more \"proper\" way:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n class AnimalError(Exception):\n    pass\n\nclass AnimalBrokenLegError(AnimalError):\n    pass\n\nclass AnimalSickError(AnimalError):\n    pass\n</code>\n</pre>\n", "senID": 7}, {"text": ["..you can then catch AnimalError to catch all exceptions which inherit from it, or a specific one like  AnimalBrokenLegError"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "AnimalError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "AnimalBrokenLegError", "childNum": 0, "tag": "code", "childList": []}]}]]