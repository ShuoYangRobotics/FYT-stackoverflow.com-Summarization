[[{"text": ["fcntl, select, asyncproc won't help in this case."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "fcntl", "tag": "a", "pos": 0, "childList": [{"text": "fcntl", "tag": "code"}], "childNum": 1, "href": "http://stackoverflow.com/questions/375427/non-blocking-read-on-a-stream-in-python/4025909#4025909"}, {"text": "fcntl", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://stackoverflow.com/questions/375427/non-blocking-read-on-a-stream-in-python/375511#375511", "text": "select", "childNum": 1, "tag": "a", "childList": [{"text": "select", "tag": "code"}]}, {"text": "select", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://stackoverflow.com/questions/375427/non-blocking-read-on-a-stream-in-python/437888#437888", "text": "asyncproc", "childNum": 1, "tag": "a", "childList": [{"text": "asyncproc", "tag": "code"}]}, {"text": "asyncproc", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Reliable way to read a stream without blocking on both Windows and Linux is to use Queue.get_nowait():"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Queue.get_nowait()", "tag": "a", "pos": 0, "childList": [{"text": "Queue.get_nowait()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/queue.html#Queue.Queue.get"}, {"text": "Queue.get_nowait()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from __future__ import print_function\nimport sys\nfrom subprocess import PIPE, Popen\nfrom threading  import Thread\n\ntry:\n    from Queue import Queue, Empty\nexcept ImportError:\n    from queue import Queue, Empty  # python 3.x\n\nON_POSIX = 'posix' in sys.builtin_module_names\n\ndef enqueue_output(out, queue):\n    for line in iter(out.readline, ''):\n        queue.put(line)\n    out.close()\n\np = Popen(['myprogram.exe'], stdout=PIPE, bufsize=1, close_fds=ON_POSIX)\nq = Queue()\nt = Thread(target=enqueue_output, args=(p.stdout, q))\nt.daemon = True # thread dies with the program\nt.start()\n\n# ... do other things here\n\n# read line without blocking\ntry:  line = q.get_nowait() # or q.get(timeout=.1)\nexcept Empty:\n    print('no output yet')\nelse: # got line\n    print(line, end='')\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I have often had a similar problem; Python programs I write frequently need to have the ability to execute some primary functionality while simultaneously accepting user input from the command line (stdin).", "Simply putting the user input handling functionality in another thread doesn't solve the problem because readline() blocks and has no timeout.", "If the primary functionality is complete and there is no longer any need to wait for further user input I typically want my program to exit, but it can't because readline() is still blocking in the other thread waiting for a line.", "A solution I have found to this problem is to make stdin a non-blocking file using the fcntl module:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import fcntl\n\n# make stdin a non-blocking file\nfd = sys.stdin.fileno()\nfl = fcntl.fcntl(fd, fcntl.F_GETFL)\nfcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)\n\n# user input handling thread\nwhile mainThreadIsRunning:\n      try: input = sys.stdin.readline()\n      except: continue\n      handleInput(input)\n</code>\n</pre>\n", "senID": 1}, {"text": ["In my opinion this is a bit cleaner than using the select or signal modules to solve this problem but then again it only works on UNIX...", "Cheers,\nJesse"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}], [{"text": ["Try the asyncproc module.", "For example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "asyncproc", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.lysator.liu.se/~bellman/download/asyncproc.py"}]}, {"code": "<pre>\n<code>\n import os\nfrom asyncproc import Process\nmyProc = Process(\"myprogram.app\")\n\nwhile True:\n    # check to see if process has ended\n    poll = myProc.wait(os.WNOHANG)\n    if poll != None:\n        break\n    # print any new output\n    out = myProc.read()\n    if out != \"\":\n        print out\n</code>\n</pre>\n", "senID": 1}, {"text": ["The module takes care of all the threading as suggested by S.Lott."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Jesse's answer is not correct.", "According to Guido, readline doesn't work correctly with non-blocking mode, and it won't before Python 3000."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Jesse's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/375427/non-blocking-read-on-a-stream-in-python/1810703#1810703"}]}, {"text": ["http://bugs.python.org/issue1175#msg56041"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://bugs.python.org/issue1175#msg56041", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bugs.python.org/issue1175#msg56041"}]}, {"text": ["If you want to use fcntl to set the file to non-blocking mode, you have to use the lower-level os.read() and separate out the lines yourself.", "Mixing fcntl with high-level calls that perform line buffering is asking for trouble."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["One solution is to make another process to perform your read of the process, or make a thread of the process with a timeout."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's the threaded version of a timeout function:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://code.activestate.com/recipes/473878/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://code.activestate.com/recipes/473878/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/473878/"}]}, {"text": ["However, do you need to read the stdout as it's coming in?", "Another solution may be to dump the output to a file and wait for the process to finish using p.wait()."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "p.wait()", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n f = open('myprogram_output.txt','w')\np = subprocess.Popen('myprogram.exe', stdout=f)\np.wait()\nf.close()\n\n\nstr = open('myprogram_output.txt','r').read()\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The select module helps you determine where the next useful input is."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "select", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-select.html"}]}, {"text": ["However, you're almost always happier with separate threads.", "One does a blocking read the stdin, another does wherever it is you don't want blocked."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You can do this really easily in Twisted.", "Depending upon your existing code base, this might not be that easy to use, but if you are building a twisted application, than things like this become almost trivial.", "You create a ProcessProtocol class, and override the outReceived() method.", "Twisted (depending upon the reactor used) is usually just a big select() loop with callbacks installed to handle data from different file descriptors (often network sockets).", "So the outReceived() method is simply installing a callback for handling data coming from STDOUT.", "A simple example demonstrating this behavior is as follows:"], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "Twisted", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://twistedmatrix.com/trac/"}, {"text": "ProcessProtocol", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "outReceived()", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "select()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "outReceived()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "STDOUT", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n from twisted.internet import protocol, reactor\n\nclass MyProcessProtocol(protocol.ProcessProtocol):\n\n    def outReceived(self, data):\n        print data\n\nproc = MyProcessProtocol()\nreactor.spawnProcess(proc, './myprogram', ['./myprogram', 'arg1', 'arg2', 'arg3'])\nreactor.run()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The Twisted documentation has some good information on this."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Twisted documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://twistedmatrix.com/documents/current/core/howto/process.html"}]}, {"text": ["If you build your entire application around Twisted, it makes asynchronous communication with other processes, local or remote, really elegant like this.", "On the other hand, if your program isn't built on top of Twisted, this isn't really going to be that helpful.", "Hopefully this can be helpful to other readers, even if it isn't applicable for your particular application."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I have port http://code.google.com/p/subprocdev/ to python 2.5, and it works in Windows"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.google.com/p/subprocdev/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/subprocdev/"}]}], [{"text": ["This allows you to pass a timeout to read()\nhttp://www.pixelbeat.org/libs/subProcess.py"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.pixelbeat.org/libs/subProcess.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.pixelbeat.org/libs/subProcess.py"}]}], [{"text": ["Use select &amp; read(1).  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import subprocess     #no new requirements\ndef readAllSoFar(proc, retVal=''): \n  while (select.select([proc.stdout],[],[],0)[0]!=[]):   \n    retVal+=proc.stdout.read(1)\n  return retVal\np = subprocess.Popen(['/bin/ls'], stdout=subprocess.PIPE)\nwhile not p.poll():\n  print (readAllSoFar(p))\n</code>\n</pre>\n", "senID": 1}, {"text": ["For readline()-like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n lines = ['']\nwhile not p.poll():\n  lines = readAllSoFar(p, lines[-1]).split('\\n')\n  for a in range(len(lines)-1):\n    print a\nlines = readAllSoFar(p, lines[-1]).split('\\n')\nfor a in range(len(lines)-1):\n  print a\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I add this problem to read some subprocess.Popen stdout.", "Here is my non blocking read solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import fcntl\n\ndef non_block_read(output):\n    fd = output.fileno()\n    fl = fcntl.fcntl(fd, fcntl.F_GETFL)\n    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)\n    try:\n        return output.read()\n    except:\n        return \"\"\n\n# Use example\nfrom subprocess import *\nsb = Popen(\"echo test &amp;&amp; sleep 1000\", shell=True, stdout=PIPE)\nsb.kill()\n\n# sb.stdout.read() # &lt;-- This will block\nnon_block_read(sb.stdout)\n'test\\n'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Looks like you want p.communicate() (see the docs)"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "p.communicate()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/subprocess.html#subprocess.Popen.communicate", "text": "docs", "childNum": 0, "tag": "a", "childList": []}]}]]