[[{"text": ["Reflection in python is a lot easier and far more flexible than it is in Java."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I recommend reading this tutorial"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "tutorial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://diveintopython.org/power_of_introspection/index.html"}]}, {"text": ["There's no direct function (that I know of) which takes a fully qualified class name and returns the class, however you have all the pieces needed to build that, and you can connect them together."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["One advice though: don't try to program in Java style when you're in python."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If you can explain what is it that you're trying to do, maybe we can help you find a more pythonic way of doing it."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Here's a function that does what you want:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def get_class( kls ):\n    parts = kls.split('.')\n    module = \".\".join(parts[:-1])\n    m = __import__( module )\n    for comp in parts[1:]:\n        m = getattr(m, comp)            \n    return m\n</code>\n</pre>\n", "senID": 6}, {"text": ["You can use the return value of this function as if it was the class itself."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Here's a usage example:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; D = get_class(\"datetime.datetime\")\n&gt;&gt;&gt; D\n&lt;type 'datetime.datetime'&gt;\n&gt;&gt;&gt; D.now()\ndatetime.datetime(2009, 1, 17, 2, 15, 58, 883000)\n&gt;&gt;&gt; a = D( 2010, 4, 22 )\n&gt;&gt;&gt; a\ndatetime.datetime(2010, 4, 22, 0, 0)\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 9}, {"text": ["How does that work?"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "How does that work?", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["We're using __import__ to import the module that holds the class, which required that we first extract the module name from the fully qualified name.", "Then we import the module:"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "__import__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n m = __import__( module )\n</code>\n</pre>\n", "senID": 12}, {"text": ["In this case, m will only refer to the top level module, "], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "m", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For example, if your class lives in foo.baz module, then m will be the module foo\nWe can easily obtain a reference to foo.baz using getattr( m, 'baz' )"], "childNum": 6, "tag": "p", "senID": 14, "childList": [{"text": "foo.baz", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "m", "childNum": 0, "tag": "code", "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "foo.baz", "childNum": 0, "tag": "code", "childList": []}, {"text": "getattr( m, 'baz' )", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To get from the top level module to the class, have to recursively use gettatr on the parts of the class name"], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "gettatr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Say for example, if you class name is foo.baz.bar.Model then we do this:"], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "foo.baz.bar.Model", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n m = __import__( \"foo.baz.bar\" ) #m is package foo\nm = getattr( m, \"baz\" ) #m is package baz\nm = getattr( m, \"bar\" ) #m is module bar\nm = getattr( m, \"Model\" ) #m is class Model\n</code>\n</pre>\n", "senID": 17}, {"text": ["This is what's happening in this loop:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n for comp in parts[1:]:\n    m = getattr(m, comp)\n</code>\n</pre>\n", "senID": 19}, {"text": ["At the end of the loop, m will be a reference to the class.", "This means that m is actually the class itslef, you can do for instance:"], "childNum": 2, "tag": "p", "senID": 20, "childList": [{"text": "m", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "m", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n a = m() #instantiate a new instance of the class    \nb = m( arg1, arg2 ) # pass arguments to the constructor\n</code>\n</pre>\n", "senID": 21}], [{"text": ["Assuming the class is in your scope:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n globals()['classname'](args, to, constructor)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Otherwise:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n getattr(someModule, 'classname')(args, to, constructor)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit:  Note, you can't give a name like 'foo.bar' to getattr.", "You'll need to split it by .", "and call getattr() on each piece left-to-right.", "This will handle that:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n module, rest = 'foo.bar.baz'.split('.', 1)\nfooBar = reduce(lambda a, b: getattr(a, b), rest.split('.'), globals()[module])\nsomeVar = fooBar(args, to, constructor)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["It seems you're approaching this from the middle instead of the beginning.", "What are you really trying to do?", "Finding the class associated with a given string is a means to an end."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you clarify your problem, which might require your own mental refactoring, a better solution may present itself."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For instance: Are you trying to load a saved object based on its type name and a set of parameters?", "Python spells this unpickling and you should look at the pickle module.", "And even though the unpickling process does exactly what you describe, you don't have to worry about how it works internally:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "pickle module", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/pickle.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class A(object):\n...   def __init__(self, v):\n...     self.v = v\n...   def __reduce__(self):\n...     return (self.__class__, (self.v,))\n&gt;&gt;&gt; a = A(\"example\")\n&gt;&gt;&gt; import pickle\n&gt;&gt;&gt; b = pickle.loads(pickle.dumps(a))\n&gt;&gt;&gt; a.v, b.v\n('example', 'example')\n&gt;&gt;&gt; a is b\nFalse\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Yet another implementation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def import_class(class_string):\n    \"\"\"Returns class object specified by a string.\n\n    Args:\n        class_string: The string representing a class.\n\n    Raises:\n        ValueError if module part of the class is not specified.\n    \"\"\"\n    module_name, _, class_name = class_string.rpartition('.')\n    if module_name == '':\n        raise ValueError('Class name must contain module part.')\n    return getattr(\n        __import__(module_name, globals(), locals(), [class_name], -1),\n        class_name)\n</code>\n</pre>\n", "senID": 1}]]