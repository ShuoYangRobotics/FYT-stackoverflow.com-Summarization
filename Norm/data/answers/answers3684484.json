[[{"text": ["I detected the peaks using a local maximum filter.", "Here is the result on your first dataset of 4 paws:\n"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "local maximum filter", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "img", "pos": 1, "childList": []}]}, {"text": ["I also ran it on the second dataset of 9 paws and it worked as well."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "it worked as well", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://i.stack.imgur.com/4CKCh.png"}]}, {"text": ["Here is how you do it:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import numpy as np\nfrom scipy.ndimage.filters import maximum_filter\nfrom scipy.ndimage.morphology import generate_binary_structure, binary_erosion\nimport matplotlib.pyplot as pp\n\n#for some reason I had to reshape. Numpy ignored the shape header.\npaws_data = np.loadtxt(\"paws.txt\").reshape(4,11,14)\n\n#getting a list of images\npaws = [p.squeeze() for p in np.vsplit(paws_data,4)]\n\n\ndef detect_peaks(image):\n    \"\"\"\n    Takes an image and detect the peaks usingthe local maximum filter.\n    Returns a boolean mask of the peaks (i.e. 1 when\n    the pixel's value is the neighborhood maximum, 0 otherwise)\n    \"\"\"\n\n    # define an 8-connected neighborhood\n    neighborhood = generate_binary_structure(2,2)\n\n    #apply the local maximum filter; all pixel of maximal value \n    #in their neighborhood are set to 1\n    local_max = maximum_filter(image, footprint=neighborhood)==image\n    #local_max is a mask that contains the peaks we are \n    #looking for, but also the background.\n    #In order to isolate the peaks we must remove the background from the mask.\n\n    #we create the mask of the background\n    background = (image==0)\n\n    #a little technicality: we must erode the background in order to \n    #successfully subtract it form local_max, otherwise a line will \n    #appear along the background border (artifact of the local maximum filter)\n    eroded_background = binary_erosion(background, structure=neighborhood, border_value=1)\n\n    #we obtain the final mask, containing only peaks, \n    #by removing the background from the local_max mask\n    detected_peaks = local_max - eroded_background\n\n    return detected_peaks\n\n\n#applying the detection and plotting results\nfor i, paw in enumerate(paws):\n    detected_peaks = detect_peaks(paw)\n    pp.subplot(4,2,(2*i+1))\n    pp.imshow(paw)\n    pp.subplot(4,2,(2*i+2) )\n    pp.imshow(detected_peaks)\n\npp.show()\n</code>\n</pre>\n", "senID": 3}, {"text": ["All you need to do after is use scipy.ndimage.measurements.label on the mask to label all distinct objects.", "Then you'll be able to play with them individually."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "scipy.ndimage.measurements.label", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Note that the method works well because the background is not noisy.", "If it were, you would detect a bunch of other unwanted peaks in the background.", "Another important factor is the size of the neighborhood.", "You will need to adjust it if the peak size changes (the should remain roughly proportional)."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "Note", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "neighborhood", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}], [{"text": ["Data file: paw.txt.", "Source code:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "paw.txt", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pastebin.com/XX3Egq7x"}]}, {"code": "<pre>\n<code>\n from scipy import *\nfrom operator import itemgetter\n\nn = 5  # how many fingers are we looking for\n\nd = loadtxt(\"paw.txt\")\nwidth, height = d.shape\n\n# Create an array where every element is a sum of 2x2 squares.\n\nfourSums = d[:-1,:-1] + d[1:,:-1] + d[1:,1:] + d[:-1,1:]\n\n# Find positions of the fingers.\n\n# Pair each sum with its position number (from 0 to width*height-1),\n\npairs = zip(arange(width*height), fourSums.flatten())\n\n# Sort by descending sum value, filter overlapping squares\n\ndef drop_overlapping(pairs):\n    no_overlaps = []\n    def does_not_overlap(p1, p2):\n        i1, i2 = p1[0], p2[0]\n        r1, col1 = i1 / (width-1), i1 % (width-1)\n        r2, col2 = i2 / (width-1), i2 % (width-1)\n        return (max(abs(r1-r2),abs(col1-col2)) &gt;= 2)\n    for p in pairs:\n        if all(map(lambda prev: does_not_overlap(p,prev), no_overlaps)):\n            no_overlaps.append(p)\n    return no_overlaps\n\npairs2 = drop_overlapping(sorted(pairs, key=itemgetter(1), reverse=True))\n\n# Take the first n with the heighest values\n\npositions = pairs2[:n]\n\n# Print results\n\nprint d, \"\\n\"\n\nfor i, val in positions:\n    row = i / (width-1)\n    column = i % (width-1)\n    print \"sum = %f @ %d,%d (%d)\" % (val, row, column, i)\n    print d[row:row+2,column:column+2], \"\\n\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output without overlapping squares.", "It seems that the same areas are selected as in your example."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Output", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pastebin.com/fgaGrsem"}]}, {"text": ["The tricky part is to calculate sums of all 2x2 squares.", "I assumed you need all of them, so there might be some overlapping.", "I used slices to cut the first/last columns and rows from the original 2D array, and then overlapping them all together and calculating sums."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["To understand it better, imaging a 3x3 array:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = arange(9).reshape(3,3) ; a\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n</code>\n</pre>\n", "senID": 5}, {"text": ["Then you can take its slices:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a[:-1,:-1]\narray([[0, 1],\n       [3, 4]])\n&gt;&gt;&gt; a[1:,:-1]\narray([[3, 4],\n       [6, 7]])\n&gt;&gt;&gt; a[:-1,1:]\narray([[1, 2],\n       [4, 5]])\n&gt;&gt;&gt; a[1:,1:]\narray([[4, 5],\n       [7, 8]])\n</code>\n</pre>\n", "senID": 7}, {"text": ["Now imagine you stack them one above the other and sum elements at the same positions.", "These sums will be exactly the same sums over the 2x2 squares with the top-left corner in the same position:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sums = a[:-1,:-1] + a[1:,:-1] + a[:-1,1:] + a[1:,1:]; sums\narray([[ 8, 12],\n       [20, 24]])\n</code>\n</pre>\n", "senID": 9}, {"text": ["When you have the sums over 2x2 squares, you can use max to find the maximum, or sort, or sorted to find the peaks."], "childNum": 3, "tag": "p", "senID": 10, "childList": [{"text": "max", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sort", "childNum": 0, "tag": "code", "childList": []}, {"text": "sorted", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To remember positions of the peaks I couple every value (the sum) with its ordinal position in a flattened array (see zip).", "Then I calculate row/column position again when I print the results."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I allowed for the 2x2 squares to overlap.", "Edited version filters out some of them such that only non-overlapping squares appear in the results."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Another problem is how to choose what is likely to be fingers out of all the peaks.", "I have an idea which may or may not work.", "I don't have time to implement it right now, so just pseudo-code."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["I noticed that if the front fingers stay on almost a perfect circle, the rear finger should be inside of that circle.", "Also, the front fingers are more or less equally spaced.", "We may try to use these heuristic properties to detect the fingers."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["Pseudo code:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n select the top N finger candidates (not too many, 10 or 12)\nconsider all possible combinations of 5 out of N (use itertools.combinations)\nfor each combination of 5 fingers:\n    for each finger out of 5:\n        fit the best circle to the remaining 4\n        =&gt; position of the center, radius\n        check if the selected finger is inside of the circle\n        check if the remaining four are evenly spread\n        (for example, consider angles from the center of the circle)\n        assign some cost (penalty) to this selection of 4 peaks + a rear finger\n        (consider, probably weighted:\n             circle fitting error,\n             if the rear finger is inside,\n             variance in the spreading of the front fingers,\n             total intensity of 5 peaks)\nchoose a combination of 4 peaks + a rear peak with the lowest penalty\n</code>\n</pre>\n", "senID": 16}, {"text": ["This is a brute-force approach.", "If N is relatively small, then I think it is doable.", "For N=12, there are C_12^5 = 792 combinations, times 5 ways to select a rear finger, so 3960 cases to evaluate for every paw."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}], [{"text": ["This is an image registration problem.", "The general strategy is:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "image registration problem", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Image_registration"}]}, {"tag": "ul", "num": 3, "lis": [{"text": "Have a known example, or some kind of ", "tag": "none", "senID": 1}, {"text": "Fit your data to the example, or fit the example to your data.", "tag": "none", "senID": 2}, {"text": "It helps if your data is ", "tag": "none", "senID": 3}]}, {"text": ["Here's a rough and ready approach, \"the dumbest thing that could possibly work\":"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Here's a rough and ready approach", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "Start with five toe coordinates in roughly the place you expect.", "tag": "none", "senID": 5}, {"text": "With each one, iteratively climb to the top of the hill. i.e. given current position, move to maximum neighbouring pixel, if its value is greater than current pixel. Stop when your toe coordinates have stopped moving.", "tag": "none", "senID": 6}]}, {"text": ["To counteract the orientation problem, you could have 8 or so initial settings for the basic directions (North, North East, etc).", "Run each one individually and throw away any results where two or more toes end up at the same pixel.", "I'll think about this some more, but this kind of thing is still being researched in image processing - there are no right answers!"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Slightly more complex idea: (weighted) K-means clustering.", "It's not that bad."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Slightly more complex idea: (weighted) K-means clustering.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 1, "lis": [{"text": "Start with five toe coordinates, but now these are \"cluster centres\".", "tag": "none", "senID": 9}]}, {"text": ["Then iterate until convergence:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Assign each pixel to the closest cluster (just make a list for each cluster).", "tag": "none", "senID": 11}, {"text": "Calculate the center of mass of each cluster. For each cluster, this is: Sum(coordinate * intensity value)/Sum(coordinate)", "tag": "none", "senID": 12}, {"text": "Move each cluster to the new centre of mass.", "tag": "none", "senID": 13}]}, {"text": ["This method will almost certainly give much better results, and you get the mass of each cluster which may help in identifying the toes."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["(Again, you've specified the number of clusters up front.", "With clustering you have to specify the density one way or another: Either choose the number of clusters, appropriate in this case, or choose a cluster radius and see how many you end up with.", "An example of the latter is mean-shift."], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "mean-shift", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Mean-shift"}]}, {"text": ["Sorry about the lack of implementation details or other specifics.", "I would code this up but I've got a deadline.", "If nothing else has worked by next week let me know and I'll give it a shot."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}], [{"text": ["Just a couple of ideas off the top of my head:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "take the gradient (derivative) of the scan, see if that eliminates the false calls", "tag": "none", "senID": 1}, {"text": "take the maximum of the local maxima", "tag": "none", "senID": 2}]}, {"text": ["You might also want to take a look at OpenCV, it's got a fairly decent Python API and might have some functions you'd find useful."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "OpenCV", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://opencv.willowgarage.com/wiki/"}]}], [{"text": ["Here is an idea: you calculate the (discrete) Laplacian of the image.", "I would expect it to be (negative and) large at maxima, in a way that is more dramatic than in the original images.", "Thus, maxima could be easier to find."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is another idea: if you know the typical size of the high-pressure spots, you can first smooth your image by convoluting it with a Gaussian of the same size.", "This may give you simpler images to process."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This problem has been studied in some depth by physicists.", "There is a good implementation in ROOT.", "Look at the TSpectrum classes (especially TSpectrum2 for your case) and the documentation for them."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "ROOT", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://root.cern.ch/drupal/"}, {"text": "TSpectrum", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://root.cern.ch/root/html526/TSpectrum.html"}, {"href": "http://root.cern.ch/root/html526/TSpectrum2.html", "text": "TSpectrum2", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["References:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["...and for those who don't have access to a subscription to NIM:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": ["Spectrum.doc"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}, {"text": ["SpectrumDec.ps.gz"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}, {"text": ["SpectrumSrc.ps.gz"], "childNum": 0, "tag": "a", "senID": 5, "childList": []}, {"text": ["SpectrumBck.ps.gz"], "childNum": 0, "tag": "a", "senID": 6, "childList": []}]}], [{"text": ["Heres another approach that I used when doing something similar for a large telescope:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["1) Search for the highest pixel.", "Once you have that, search around that for the best fit for 2x2 (maybe maximizing the 2x2 sum), or do a 2d gaussian fit inside the sub region of say 4x4 centered on the highest pixel."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Then set those 2x2 pixels you have found to zero (or maybe 3x3) around the peak center"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["go back to 1) and repeat till the highest peak falls below a noise threshold, or you have all the toes you need"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["It's probably worth to try with neural networks if you are able to create some training data... but this needs many samples annotated by hand."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["a rough outline..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["you'd probably want to use a connected components algorithm to isolate each paw region.", "wiki has a decent description of this (with some code) here: http://en.wikipedia.org/wiki/Connected_Component_Labeling"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://en.wikipedia.org/wiki/Connected_Component_Labeling", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Connected_Component_Labeling"}]}, {"text": ["you'll have to make a decision about whether to use 4 or 8 connectedness.", "personally, for most problems i prefer 6-connectedness.", "anyway, once you've separated out each \"paw print\" as a connected region, it should be easy enough to iterate through the region and find the maxima.", "once you've found the maxima, you could iteratively enlarge the region until you reach a predetermined threshold in order to identify it as a given \"toe\". "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["one subtle problem here is that as soon as you start using computer vision techniques to identify something as a right/left/front/rear paw and you start looking at individual toes, you have to start taking rotations, skews, and translations into account.", "this is accomplished through the analysis of so-called \"moments\".", "there are a few different moments to consider in vision applications: "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["central moments: translation invariant\nnormalized moments: scaling and translation invariant\nhu moments: translation, scale, and rotation invariant "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["more information about moments can be found by searching \"image moments\" on wiki. "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Physicist's solution:\nDefine 5 paw-markers identified by their positions X_i and init them with random positions.", "Define some energy function combining some award for location of markers in paws' positions with some punishment for overlap of markers; let's say:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "X_i", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n E(X_i;S)=-Sum_i(S(X_i))+alfa*Sum_ij (|X_i-Xj|&lt;=2*sqrt(2)?1:0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(S(X_i) is the mean force in 2x2 square around X_i, alfa is a parameter to be peaked experimentally)"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "S(X_i)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "X_i", "childNum": 0, "tag": "code", "childList": []}, {"text": "alfa", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Now time to do some Metropolis-Hastings magic:\n  1.", "Select random marker and move it by one pixel in random direction.", "2.", "Calculate dE, the difference of energy this move caused.", "3.", "Get an uniform random number from 0-1 and call it r.\n  4.", "If dE&lt;0 or exp(-beta*dE)&gt;r, accept the move and go to 1; if not, undo the move and go to 1.", "This should be repeated until the markers will converge to paws.", "Beta controls the scanning to optimizing tradeoff, so it should be also optimized experimentally; it can be also constantly increased with the time of simulation (simulated annealing)."], "childNum": 7, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 3, "childList": []}, {"text": "dE&lt;0", "childNum": 0, "tag": "code", "pos": 6, "childList": []}, {"text": "exp(-beta*dE)&gt;r", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 7, "childList": []}]}], [{"text": ["thanks for the raw data.", "I'm on the train and this is as far as I've gotten (my stop is coming up).", "I massaged your txt file with regexps and have plopped it into a html page with some javascript for visualization.", "I'm sharing it here because some, like myself, might find it more readily hackable than python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I think a good approach will be scale and rotation invariant, and my next step will be to investigate mixtures of gaussians.", "(each paw pad being the center of a gaussian)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &lt;html&gt;\n&lt;head&gt;\n    &lt;script type=\"text/javascript\" src=\"http://vis.stanford.edu/protovis/protovis-r3.2.js\"&gt;&lt;/script&gt; \n    &lt;script type=\"text/javascript\"&gt;\n    var heatmap = [[[0,0,0,0,0,0,0,4,4,0,0,0,0],\n[0,0,0,0,0,7,14,22,18,7,0,0,0],\n[0,0,0,0,11,40,65,43,18,7,0,0,0],\n[0,0,0,0,14,61,72,32,7,4,11,14,4],\n[0,7,14,11,7,22,25,11,4,14,65,72,14],\n[4,29,79,54,14,7,4,11,18,29,79,83,18],\n[0,18,54,32,18,43,36,29,61,76,25,18,4],\n[0,4,7,7,25,90,79,36,79,90,22,0,0],\n[0,0,0,0,11,47,40,14,29,36,7,0,0],\n[0,0,0,0,4,7,7,4,4,4,0,0,0]\n],[\n[0,0,0,4,4,0,0,0,0,0,0,0,0],\n[0,0,11,18,18,7,0,0,0,0,0,0,0],\n[0,4,29,47,29,7,0,4,4,0,0,0,0],\n[0,0,11,29,29,7,7,22,25,7,0,0,0],\n[0,0,0,4,4,4,14,61,83,22,0,0,0],\n[4,7,4,4,4,4,14,32,25,7,0,0,0],\n[4,11,7,14,25,25,47,79,32,4,0,0,0],\n[0,4,4,22,58,40,29,86,36,4,0,0,0],\n[0,0,0,7,18,14,7,18,7,0,0,0,0],\n[0,0,0,0,4,4,0,0,0,0,0,0,0],\n],[\n[0,0,0,4,11,11,7,4,0,0,0,0,0],\n[0,0,0,4,22,36,32,22,11,4,0,0,0],\n[4,11,7,4,11,29,54,50,22,4,0,0,0],\n[11,58,43,11,4,11,25,22,11,11,18,7,0],\n[11,50,43,18,11,4,4,7,18,61,86,29,4],\n[0,11,18,54,58,25,32,50,32,47,54,14,0],\n[0,0,14,72,76,40,86,101,32,11,7,4,0],\n[0,0,4,22,22,18,47,65,18,0,0,0,0],\n[0,0,0,0,4,4,7,11,4,0,0,0,0],\n],[\n[0,0,0,0,4,4,4,0,0,0,0,0,0],\n[0,0,0,4,14,14,18,7,0,0,0,0,0],\n[0,0,0,4,14,40,54,22,4,0,0,0,0],\n[0,7,11,4,11,32,36,11,0,0,0,0,0],\n[4,29,36,11,4,7,7,4,4,0,0,0,0],\n[4,25,32,18,7,4,4,4,14,7,0,0,0],\n[0,7,36,58,29,14,22,14,18,11,0,0,0],\n[0,11,50,68,32,40,61,18,4,4,0,0,0],\n[0,4,11,18,18,43,32,7,0,0,0,0,0],\n[0,0,0,0,4,7,4,0,0,0,0,0,0],\n],[\n[0,0,0,0,0,0,4,7,4,0,0,0,0],\n[0,0,0,0,4,18,25,32,25,7,0,0,0],\n[0,0,0,4,18,65,68,29,11,0,0,0,0],\n[0,4,4,4,18,65,54,18,4,7,14,11,0],\n[4,22,36,14,4,14,11,7,7,29,79,47,7],\n[7,54,76,36,18,14,11,36,40,32,72,36,4],\n[4,11,18,18,61,79,36,54,97,40,14,7,0],\n[0,0,0,11,58,101,40,47,108,50,7,0,0],\n[0,0,0,4,11,25,7,11,22,11,0,0,0],\n[0,0,0,0,0,4,0,0,0,0,0,0,0],\n],[\n[0,0,4,7,4,0,0,0,0,0,0,0,0],\n[0,0,11,22,14,4,0,4,0,0,0,0,0],\n[0,0,7,18,14,4,4,14,18,4,0,0,0],\n[0,4,0,4,4,0,4,32,54,18,0,0,0],\n[4,11,7,4,7,7,18,29,22,4,0,0,0],\n[7,18,7,22,40,25,50,76,25,4,0,0,0],\n[0,4,4,22,61,32,25,54,18,0,0,0,0],\n[0,0,0,4,11,7,4,11,4,0,0,0,0],\n],[\n[0,0,0,0,7,14,11,4,0,0,0,0,0],\n[0,0,0,4,18,43,50,32,14,4,0,0,0],\n[0,4,11,4,7,29,61,65,43,11,0,0,0],\n[4,18,54,25,7,11,32,40,25,7,11,4,0],\n[4,36,86,40,11,7,7,7,7,25,58,25,4],\n[0,7,18,25,65,40,18,25,22,22,47,18,0],\n[0,0,4,32,79,47,43,86,54,11,7,4,0],\n[0,0,0,14,32,14,25,61,40,7,0,0,0],\n[0,0,0,0,4,4,4,11,7,0,0,0,0],\n],[\n[0,0,0,0,4,7,11,4,0,0,0,0,0],\n[0,4,4,0,4,11,18,11,0,0,0,0,0],\n[4,11,11,4,0,4,4,4,0,0,0,0,0],\n[4,18,14,7,4,0,0,4,7,7,0,0,0],\n[0,7,18,29,14,11,11,7,18,18,4,0,0],\n[0,11,43,50,29,43,40,11,4,4,0,0,0],\n[0,4,18,25,22,54,40,7,0,0,0,0,0],\n[0,0,4,4,4,11,7,0,0,0,0,0,0],\n],[\n[0,0,0,0,0,7,7,7,7,0,0,0,0],\n[0,0,0,0,7,32,32,18,4,0,0,0,0],\n[0,0,0,0,11,54,40,14,4,4,22,11,0],\n[0,7,14,11,4,14,11,4,4,25,94,50,7],\n[4,25,65,43,11,7,4,7,22,25,54,36,7],\n[0,7,25,22,29,58,32,25,72,61,14,7,0],\n[0,0,4,4,40,115,68,29,83,72,11,0,0],\n[0,0,0,0,11,29,18,7,18,14,4,0,0],\n[0,0,0,0,0,4,0,0,0,0,0,0,0],\n]\n];\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script type=\"text/javascript+protovis\"&gt;    \n    for (var a=0; a &lt; heatmap.length; a++) {\n    var w = heatmap[a][0].length,\n    h = heatmap[a].length;\nvar vis = new pv.Panel()\n    .width(w * 6)\n    .height(h * 6)\n    .strokeStyle(\"#aaa\")\n    .lineWidth(4)\n    .antialias(true);\nvis.add(pv.Image)\n    .imageWidth(w)\n    .imageHeight(h)\n    .image(pv.Scale.linear()\n        .domain(0, 99, 100)\n        .range(\"#000\", \"#fff\", '#ff0a0a')\n        .by(function(i, j) heatmap[a][j][i]));\nvis.render();\n}\n&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code>\n</pre>\n", "senID": 2}, {"src": "http://i.stack.imgur.com/ZaS9y.png", "tag": "img", "senID": 3}], [{"text": ["Well, here's some simple and not terribly efficient code, but for this size of a data set it is fine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy as np\ngrid = np.array([[0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n              [0,0,0,0,0,0,0,0,0.4,0.4,0.4,0,0,0],\n              [0,0,0,0,0.4,1.4,1.4,1.8,0.7,0,0,0,0,0],\n              [0,0,0,0,0.4,1.4,4,5.4,2.2,0.4,0,0,0,0],\n              [0,0,0.7,1.1,0.4,1.1,3.2,3.6,1.1,0,0,0,0,0],\n              [0,0.4,2.9,3.6,1.1,0.4,0.7,0.7,0.4,0.4,0,0,0,0],\n              [0,0.4,2.5,3.2,1.8,0.7,0.4,0.4,0.4,1.4,0.7,0,0,0],\n              [0,0,0.7,3.6,5.8,2.9,1.4,2.2,1.4,1.8,1.1,0,0,0],\n              [0,0,1.1,5,6.8,3.2,4,6.1,1.8,0.4,0.4,0,0,0],\n              [0,0,0.4,1.1,1.8,1.8,4.3,3.2,0.7,0,0,0,0,0],\n              [0,0,0,0,0,0.4,0.7,0.4,0,0,0,0,0,0]])\n\narr = []\nfor i in xrange(grid.shape[0] - 1):\n    for j in xrange(grid.shape[1] - 1):\n        tot = grid[i][j] + grid[i+1][j] + grid[i][j+1] + grid[i+1][j+1]\n        arr.append([(i,j),tot])\n\nbest = []\n\narr.sort(key = lambda x: x[1])\n\nfor i in xrange(5):\n    best.append(arr.pop())\n    badpos = set([(best[-1][0][0]+x,best[-1][0][1]+y)\n                  for x in [-1,0,1] for y in [-1,0,1] if x != 0 or y != 0])\n    for j in xrange(len(arr)-1,-1,-1):\n        if arr[j][0] in badpos:\n            arr.pop(j)\n\n\nfor item in best:\n    print grid[item[0][0]:item[0][0]+2,item[0][1]:item[0][1]+2]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I basically just make an array with the position of the upper-left and the sum of each 2x2 square and sort it by the sum.", "I then take the 2x2 square with the highest sum out of contention, put it in the best array, and remove all other 2x2 squares that used any part of this just removed 2x2 square."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "best", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["It seems to work fine except with the last paw (the one with the smallest sum on the far right in your first picture), it turns out that there are two other eligible 2x2 squares with a larger sum (and they have an equal sum to each other).", "One of them is still selects one square from your 2x2 square, but the other is off to the left.", "Fortunately, by luck we see to be choosing more of the one that you would want, but this may require some other ideas to be used to get what you actually want all of the time."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["It seems you can cheat a bit using jetxee's algorithm.", "He is finding the first three toes fine, and you should be able to guess where the fourth is based off that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Perhaps you can use something like Gaussian Mixture Models.", "Here's a Python package for doing GMMs (just did a Google search)\nhttp://www.ar.media.kyoto-u.ac.jp/members/david/softwares/em/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.ar.media.kyoto-u.ac.jp/members/david/softwares/em/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.ar.media.kyoto-u.ac.jp/members/david/softwares/em/"}]}], [{"text": ["Interesting problem.", "The solution I would try is the following."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This should give you the maximal positions without having multiple candidates which are close together.", "Just to clarify, the radius of the mask in step 1 should also be similar to the radius used in step 2.", "This radius could be selectable, or the vet could explicitly measure it beforehand (it will vary with age/breed/etc)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Some of the solutions suggested (mean shift, neural nets, and so on) probably will work to some degree, but are overly complicated and probably not ideal."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Maybe a naive approach is sufficient here: Build a list of all 2x2 squares on your plane, order them by their sum (in descending order). "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First, select the highest-valued square into your \"paw list\".", "Then, iteratively pick 4 of the next-best squares that don't intersect with any of the previously found squares. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["What if you proceed step by step: you first locate the global maximum, process if needed the surrounding points given their value, then set the found region to zero, and repeat for the next one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I am not sure this answers the question, but it seems like you can just look for the n highest peaks that don't have neighbors."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is the gist.", "Note that it's in Ruby, but the idea should be clear."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://gist.github.com/574052"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://gist.github.com/574052", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://gist.github.com/574052"}]}]]