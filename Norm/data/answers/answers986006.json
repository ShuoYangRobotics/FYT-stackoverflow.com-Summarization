[[{"text": ["Parameters are passed by value.", "The reason people are confused by the behaviour is twofold:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So, if you pass a mutable object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object.", "If out pass an immutable object to a method, you still can't rebind the outer reference, and you can't even mutate the object."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Okay, this is a little confusing.", "Let's have some examples. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["List - a mutable type"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"text": ["Let's try to modify the list that was passed to a method:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Let's try to modify the list that was passed to a method:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def try_to_change_list_contents(the_list):\n    print 'got', the_list\n    the_list.append('four')\n    print 'changed to', the_list\n\nouter_list = ['one', 'two', 'three']\n\nprint 'before, outer_list =', outer_list\ntry_to_change_list_contents(outer_list)\nprint 'after, outer_list =', outer_list\n</code>\n</pre>\n", "senID": 5}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n before, outer_list = ['one', 'two', 'three']\ngot ['one', 'two', 'three']\nchanged to ['one', 'two', 'three', 'four']\nafter, outer_list = ['one', 'two', 'three', 'four']\n</code>\n</pre>\n", "senID": 7}, {"text": ["Since the parameter passed in is a reference to outer_list, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "outer_list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Now let's see what happens when we try to change the reference that was passed in as a parameter:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Now let's see what happens when we try to change the reference that was passed in as a parameter:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def try_to_change_list_reference(the_list):\n    print 'got', the_list\n    the_list = ['and', 'we', 'can', 'not', 'lie']\n    print 'set to', the_list\n\nouter_list = ['we', 'like', 'proper', 'English']\n\nprint 'before, outer_list =', outer_list\ntry_to_change_list_reference(outer_list)\nprint 'after, outer_list =', outer_list\n</code>\n</pre>\n", "senID": 10}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n before, outer_list = ['we', 'like', 'proper', 'English']\ngot ['we', 'like', 'proper', 'English']\nset to ['and', 'we', 'can', 'not', 'lie']\nafter, outer_list = ['we', 'like', 'proper', 'English']\n</code>\n</pre>\n", "senID": 12}, {"text": ["Since the the_list parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see.", "The the_list was a copy of the outer_list reference, and we had the_list point to a new list, but there was no way to change where outer_list pointed."], "childNum": 5, "tag": "p", "senID": 13, "childList": [{"text": "the_list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "the_list", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "outer_list", "childNum": 0, "tag": "code", "childList": []}, {"text": "the_list", "childNum": 0, "tag": "code", "childList": []}, {"text": "outer_list", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["String - an immutable type"], "childNum": 0, "tag": "h2", "senID": 14, "childList": []}, {"text": ["It's immutable, so there's nothing we can do to change the contents of the string"], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "It's immutable, so there's nothing we can do to change the contents of the string", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Now, let's try to change the reference"], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "Now, let's try to change the reference", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def try_to_change_string_reference(the_string):\n    print 'got', the_string\n    the_string = 'In a kingdom by the sea'\n    print 'set to', the_string\n\nouter_string = 'It was many and many a year ago'\n\nprint 'before, outer_string =', outer_string\ntry_to_change_string_reference(outer_string)\nprint 'after, outer_string =', outer_string\n</code>\n</pre>\n", "senID": 17}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n before, outer_string = It was many and many a year ago\ngot It was many and many a year ago\nset to In a kingdom by the sea\nafter, outer_string = It was many and many a year ago\n</code>\n</pre>\n", "senID": 19}, {"text": ["Again, since the the_string parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see.", "The the_string was a copy of the outer_string reference, and we had the_string point to a new list, but there was no way to change where outer_string pointed."], "childNum": 5, "tag": "p", "senID": 20, "childList": [{"text": "the_string", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "the_string", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "outer_string", "childNum": 0, "tag": "code", "childList": []}, {"text": "the_string", "childNum": 0, "tag": "code", "childList": []}, {"text": "outer_string", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I hope this clears things up a little."], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"text": ["EDIT: It's been noted that this doesn't answer the question that @David originally asked, \"Is there something I can do to pass the variable by actual reference?\".", "Let's work on that."], "childNum": 1, "tag": "p", "senID": 22, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["How do we get around this?"], "childNum": 0, "tag": "h2", "senID": 23, "childList": []}, {"text": ["As @Andrea's answer shows, you could return the new value.", "This doesn't change the way things are passed in, but does let you get the information you want back out:"], "childNum": 1, "tag": "p", "senID": 24, "childList": [{"text": "Andrea", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "#986031"}]}, {"code": "<pre>\n<code>\n def return_a_whole_new_string(the_string):\n    new_string = something_to_do_with_the_old_string(the_string)\n    return new_string\n\n# then you could call it like\nmy_string = return_a_whole_new_string(my_string)\n</code>\n</pre>\n", "senID": 25}, {"text": ["If you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:"], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"code": "<pre>\n<code>\n def use_a_wrapper_to_simulate_pass_by_reference(stuff_to_change):\n    new_string = something_to_do_with_the_old_string(stuff_to_change[0])\n    stuff_to_change[0] = new_string\n\n# then you could call it like\nwrapper = [my_string]\nuse_a_wrapper_to_simulate_pass_by_reference(wrapper)\n\ndo_something_with(wrapper[0])\n</code>\n</pre>\n", "senID": 27}, {"text": ["Although this seems a little cumbersome."], "childNum": 0, "tag": "p", "senID": 28, "childList": []}], [{"text": ["It is neither pass-by-value or pass-by-reference - it is call-by-object.", "See this, by Fredrik Lundh: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://effbot.org/zone/call-by-object.htm"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://effbot.org/zone/call-by-object.htm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/call-by-object.htm"}]}], [{"text": ["Think of stuff being passed by assignment instead of by reference/by value.", "That way, it is allways clear, what is happening as long as you understand what happens during normal assignment."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "by assignment", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["So, when passing a list to a function/method, the list is assigned to the parameter name.", "Appending to the list will result in the list being modified.", "Reassigning the list inside the function will not change the original list, since:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "inside", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n a = [1, 2, 3]\nb = a\nb.append(4)\nb = ['a', 'b']\nprint a, b      # prints [1, 2, 3, 4] ['a', 'b']\n</code>\n</pre>\n", "senID": 2}, {"text": ["Since immutable types cannot be modified, they seem like being passed by value - passing an int into a function means assigning the int to the functions parameter.", "You can only ever reassign that, but it won't change the originial variables value."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "seem", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["If my understanding is correct, then I think it is important to note that the current highest point post (by Blair Conrad) is correct in its' result but misleading, bordering on incorrect in its definitions.", "For anyone who is accustomed to C (or many other languages) that fall into the pass by reference or pass by value classifications, Python is not either of those."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["David Cournapeau's answer points to the real answer which explains why the behavior in Blair Conrad's post is what it is, while the definitions are not."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["To the extent that Python is pass by value, all languages are pass by value since some piece of data (be it a \"value\" or a \"reference\") must be sent.", "However, that does not mean that Python is pass by value in the sense that a C programmer would think of it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["All that to say if you want the behavior, Blair Conrad's answer is fine.", "If you want to know the nuts and bolts of why Python is neither pass by value or reference, read David Cournapeau's answer."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If I have misunderstood the way Python works, any corrections would be appreciated."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["For a short explanation/clarification see the first answer to this stackoverflow question.", "As strings are immutable, they won't be changed and a new variable will be created, thus the \"outer\" variable still has the same value."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this stackoverflow question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/534375/passing-values-in-python"}]}], [{"text": ["You got some really good answers here."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\nx = [ 2, 4, 4, 5, 5 ]\nprint x  # 2, 4, 4, 5, 5\n\ndef go( li ) :\n  li = [ 5, 6, 7, 8 ]  # re-assigning what li POINTS TO, does not\n  # change the value of the ORIGINAL variable x\n\ngo( x ) \nprint x  # 2, 4, 4, 5, 5  [ STILL! ]\n\n\nraw_input( 'press any key to continue' )\n</pre>\n", "senID": 1}], [{"text": ["In this case the variable titled var in the method Change is assigned a reference to self.variable, and you immediately assign a string to var.", "It's no longer pointing to self.variable.", "The following code snippet shows what would happen if you modify the data structure pointed to by var and self.variable, in this case a list:"], "childNum": 7, "tag": "p", "senID": 0, "childList": [{"text": "var", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Change", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "self.variable", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "var", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "self.variable", "childNum": 0, "tag": "code", "childList": []}, {"text": "var", "childNum": 0, "tag": "code", "childList": []}, {"text": "self.variable", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class PassByReference:\n...     def __init__(self):\n...         self.variable = ['Original']\n...         self.change(self.variable)\n...         print self.variable\n...         \n...     def change(self, var):\n...         var.append('Changed')\n... \n&gt;&gt;&gt; q = PassByReference()\n['Original', 'Changed']\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm sure someone else could clarify this further."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A simple trick I normally use is to just wrap it in a list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def Change(self, var):\n    var[0] = 'Changed'\n\nvariable = ['Original']\nself.Change(variable)      \nprint variable[0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Yeah I know this can be inconvenient, but sometimes it is simple enough to do this."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["i usually modify some variable by making it global rather than pass the value by reference"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class test:\n    def __init__(self):\n        global variable\n        variable='Original'\n        print variable\n        self.ChangeTheVariable()\n        print variable\n    def ChangeTheVariable(self):\n        global variable\n        variable='Changed'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Python string are immutable so any assignment sets a reference to a new string object in the memory.", "You can go around it by using MutableString and [:] assignment in your example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from UserString import MutableString\n\nclass PassByReference:\n    def __init__(self):\n        self.variable = MutableString('Original')\n        self.Change(self.variable)\n        print self.variable\n\n    def Change(self, var):\n        var[:] = 'Changed'\n</code>\n</pre>\n", "senID": 1}]]