[[{"text": ["Try the rstrip method."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 'test string\\n'.rstrip()\n'test string'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that Python's rstrip method strips all kinds of whitespace by default, not just newlines as Perl does with chomp.", "To strip only newlines:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "all", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 'test string \\n'.rstrip('\\n')\n'test string '\n</code>\n</pre>\n", "senID": 3}, {"text": ["There is also the lstrip and strip methods."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "lstrip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "strip", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = \" \\n  abc   def   \"\n&gt;&gt;&gt; s.strip()\n'abc   def'\n&gt;&gt;&gt; s.rstrip()\n' \\n  abc   def'\n&gt;&gt;&gt; s.lstrip()\n'abc   def   '\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 5}], [{"text": ["And I would say the \"pythonic\" way to get lines without trailing newline characters is splitlines()."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; text = \"line 1\\nline 2\\r\\nline 3\\nline 4\"\n&gt;&gt;&gt; text.splitlines()\n['line 1', 'line 2', 'line 3', 'line 4']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The canonical way to strip end-of-line (EOL) characters is to use the string rstrip() method removing any trailing \\r or \\n.", "Here are examples for Mac, Windows, and Unix EOL characters."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 'Mac EOL\\r'.rstrip('\\r\\n')\n'Mac EOL'\n&gt;&gt;&gt; 'Windows EOL\\r\\n'.rstrip('\\r\\n')\n'Windows EOL'\n&gt;&gt;&gt; 'Unix EOL\\n'.rstrip('\\r\\n')\n'Unix EOL'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Using '\\r\\n' as the parameter to rstrip means that it will strip out any trailing combination of '\\r' or '\\n'.", "That's why it works in all three cases above."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This nuance matters in rare cases.", "For example, I once had to process a text file which contained an HL7 message.", "The HL7 standard requires a trailing '\\r' as its EOL character.", "The Windows machine on which I was using this message had appended its own '\\r\\n' EOL character.", "Therefore, the end of each line looked like '\\r\\r\\n'.", "Using rstrip('\\r\\n') would have taken off the entire '\\r\\r\\n' which is not what I wanted.", "In that case, I simply sliced off the last two characters instead."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Note that rstrip doesn't act exactly like Perl's chomp() because it doesn't modify the string.", "That is, in Perl:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $x=\"a\\n\";\n\nchomp $x\n</code>\n</pre>\n", "senID": 1}, {"text": ["results in $x being \"a\"."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "$x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\"a\"", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["but in Python:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n x=\"a\\n\"\n\nx.rstrip()\n</code>\n</pre>\n", "senID": 4}, {"text": ["will mean that the value of x is still \"a\\n\".", "You need to write x=x.rstrip() to get the equivalent behavior."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "still", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "\"a\\n\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "x=x.rstrip()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I might use something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\ns = s.rstrip(os.linesep)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think the problem with rstrip(\"\\n\") is that you'll probably want to make sure the line separator is portable.", "(some antiquated systems are rumored to use \"\\r\\n\") Hopefully os.linesep will contain the right characters.", "the above works for me."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "rstrip(\"\\n\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\"\\r\\n\"", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "os.linesep", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["I don't program in Python, but I came across an FAQ at python.org advocating S.rstrip(\"\\r\\n\") for python 2.2 or later."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "FAQ", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/faq/programming/#is-there-an-equivalent-to-perl-s-chomp-for-removing-trailing-newlines-from-strings"}]}, {"text": ["Alternatively, switch to Ruby.", "It has chomp."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Careful with \"foo\".rstrip(os.linesep): That will only chomp the newline characters for the platform where your Python is being executed.", "Imagine you're chimping the lines of a Windows file under Linux, for instance:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\"foo\".rstrip(os.linesep)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ python\nPython 2.7.1 (r271:86832, Mar 18 2011, 09:09:48) \n[GCC 4.5.0 20100604 [gcc-4_5-branch revision 160292]] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import os, sys\n&gt;&gt;&gt; sys.platform\n'linux2'\n&gt;&gt;&gt; \"foo\\r\\n\".rstrip(os.linesep)\n'foo\\r'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Use \"foo\".rstrip(\"\\r\\n\") instead, as Mike says above."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "\"foo\".rstrip(\"\\r\\n\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["rstrip doesn't do the same thing as chomp, on so many levels.", "Read http://perldoc.perl.org/functions/chomp.html and see that chomp is very complex indeed."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://perldoc.perl.org/functions/chomp.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://perldoc.perl.org/functions/chomp.html"}]}, {"text": ["However, my main point is that chomp removes at most 1 line ending, whereas rstrip will remove as many as it can."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here you can see rstrip removing all the newlines:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 'foo\\n\\n'.rstrip(os.linesep)\n'foo'\n</code>\n</pre>\n", "senID": 3}, {"text": ["A much closer approximation of typical Perl chomp usage can be accomplished with re.sub, like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; re.sub(os.linesep + r'\\Z','','foo\\n\\n')\n'foo\\n'\n</code>\n</pre>\n", "senID": 5}]]