[[{"text": ["Similar question here.", "You can't mix iteration and readline so you need to use one or the other."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/826493/python-mixing-files-and-loops"}]}, {"code": "<pre>\n<code>\n while True:\n    line1 = f.readline()\n    line2 = f.readline()\n    if not line2: break  # EOF\n    ...\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import itertools\nwith open('a') as f:\n    for line1,line2 in itertools.izip_longest(*[f]*2):\n        print(line1,line2)\n</code>\n</pre>\n", "senID": 0}, {"text": ["izip_longest returns an iterator, so it should work well even if the file is very large."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If there are an odd number of lines, then line2 gets the value None on the last iteration."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["izip_longest is in itertools if you have python 2.6 or later.", "If you use a prior version, you can pick up a python implementation of izip_longest here: "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.izip_longest"}]}, {"text": ["In the comments, it has been asked if this solution reads the whole file first, and then iterates over the file a second time.", "I believe that it does not.", "The with open('a') as f line opens a file handle, but does not read the file.", "f is an iterator, so its contents are not read until requested.", "izip_longest takes iterators as arguments, and returns an iterator. "], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "with open('a') as f", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["izip_longest is indeed fed the same iterator, f, twice.", "But what ends up happening is that f.next() (or next(f) in Python3) is called on the first argument and then on the second argument.", "Since next() is being called on the same underlying iterator, successive lines are yielded.", "This is very different than reading in the whole file.", "Indeed the purpose of using iterators is precisely to avoid reading in the whole file."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I therefore believe the solution works as desired -- the file is only read once by the for-loop."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["To corroborate this, I ran the izip_longest solution versus a solution using f.readlines().", "I put a raw_input() at the end to pause the scripts, and ran ps axuw on each:"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "f.readlines()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ps axuw", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n % ps axuw | grep izip_longest_method.py\n</code>\n</pre>\n", "senID": 8}, {"text": ["unutbu   11119  2.2  0.2 4520  2712 pts/0    S+   21:14   0:00 python /home/unutbu/pybin/izip_longest_method.py bigfile"], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "unutbu   11119  2.2  0.2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "4520  2712", "childNum": 0, "tag": "strong", "childList": []}, {"text": "pts/0    S+   21:14   0:00 python /home/unutbu/pybin/izip_longest_method.py bigfile", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n % ps axuw | grep readlines_method.py\n</code>\n</pre>\n", "senID": 10}, {"text": ["unutbu   11317  6.5  8.8 93908 91680 pts/0    S+   21:16   0:00 python /home/unutbu/pybin/readlines_method.py bigfile"], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "unutbu   11317  6.5  8.8", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "93908 91680", "childNum": 0, "tag": "strong", "childList": []}, {"text": "pts/0    S+   21:16   0:00 python /home/unutbu/pybin/readlines_method.py bigfile", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The readlines clearly reads in the whole file at once.", "Since the izip_longest_method uses much less memory, I think it is safe to conclude it is not reading in the whole file at once."], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "readlines", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "izip_longest_method", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["use line.next(), eg"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f=open(\"file\")\nfor line in f:\n    print line\n    nextline=f.next()\n    print \"next line\", nextline\n    ....\nf.close()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would proceed in a similar way as ghostdog74, only with the try outside and a few modifications:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ghostdog74", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1657299/how-do-i-read-two-lines-from-a-file-at-a-time-using-python/1657337#1657337"}]}, {"code": "<pre>\n<code>\n try:\n    with open(filename) as f:\n        for line1 in f:\n            line2 = f.next()\n            # process line1 and line2 here\nexcept StopIteration:\n    print \"(End)\" # do whatever you need to do with line1 alone\n</code>\n</pre>\n", "senID": 1}, {"text": ["This keeps the code simple and yet robust.", "Using the with closes the file if something else happens, or just closes the resources once you have exhausted it and exit the loop."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "with", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Note that with needs 2.6, or 2.5 with the with_statement feature enabled."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "with", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "with_statement", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Works for even and odd-length files.", "It just ignores the unmatched last line."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f=file(\"file\")\n\nlines = f.readlines()\nfor even, odd in zip(lines[0::2], lines[1::2]):\n    print \"even : \", even\n    print \"odd : \", odd\n    print \"end cycle\"\nf.close()\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you have large files, this is not the correct approach.", "You are loading all the file in memory with readlines().", "I once wrote a class that read the file saving the fseek position of each start of line.", "This allows you to get specific lines without having all the file in memory, and you can also go forward and backward."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I paste it here.", "License is Public domain, meaning, do what you want with it.", "Please note that this class has been written 6 years ago and I haven't touched or checked it since.", "I think it's not even file compliant.", "Caveat emptor.", "Also, note that this is overkill for your problem.", "I'm not claiming you should definitely go this way, but I had this code and I enjoy sharing it if you need more complex access."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Caveat emptor", "childNum": 0, "tag": "em", "pos": 4, "childList": []}]}, {"code": "<pre>\n<code>\n import string\nimport re\n\nclass FileReader:\n    \"\"\" \n    Similar to file class, but allows to access smoothly the lines \n    as when using readlines(), with no memory payload, going back and forth,\n    finding regexps and so on.\n    \"\"\"\n    def __init__(self,filename): # fold&gt;&gt;\n        self.__file=file(filename,\"r\")\n        self.__currentPos=-1\n        # get file length\n        self.__file.seek(0,0)\n        counter=0\n        line=self.__file.readline()\n        while line != '':\n            counter = counter + 1\n            line=self.__file.readline()\n        self.__length = counter\n        # collect an index of filedescriptor positions against\n        # the line number, to enhance search\n        self.__file.seek(0,0)\n        self.__lineToFseek = []\n\n        while True:\n            cur=self.__file.tell()\n            line=self.__file.readline()\n            # if it's not null the cur is valid for\n            # identifying a line, so store\n            self.__lineToFseek.append(cur)\n            if line == '':\n                break\n    # &lt;&lt;fold\n    def __len__(self): # fold&gt;&gt;\n        \"\"\"\n        member function for the operator len()\n        returns the file length\n        FIXME: better get it once when opening file\n        \"\"\"\n        return self.__length\n        # &lt;&lt;fold\n    def __getitem__(self,key): # fold&gt;&gt;\n        \"\"\" \n        gives the \"key\" line. The syntax is\n\n        import FileReader\n        f=FileReader.FileReader(\"a_file\")\n        line=f[2]\n\n        to get the second line from the file. The internal\n        pointer is set to the key line\n        \"\"\"\n\n        mylen = self.__len__()\n        if key &lt; 0:\n            self.__currentPos = -1\n            return ''\n        elif key &gt; mylen:\n            self.__currentPos = mylen\n            return ''\n\n        self.__file.seek(self.__lineToFseek[key],0)\n        counter=0\n        line = self.__file.readline()\n        self.__currentPos = key\n        return line\n        # &lt;&lt;fold\n    def next(self): # fold&gt;&gt;\n        if self.isAtEOF():\n            raise StopIteration\n        return self.readline()\n    # &lt;&lt;fold\n    def __iter__(self): # fold&gt;&gt;\n        return self\n    # &lt;&lt;fold\n    def readline(self): # fold&gt;&gt;\n        \"\"\"\n        read a line forward from the current cursor position.\n        returns the line or an empty string when at EOF\n        \"\"\"\n        return self.__getitem__(self.__currentPos+1)\n        # &lt;&lt;fold\n    def readbackline(self): # fold&gt;&gt;\n        \"\"\"\n        read a line backward from the current cursor position.\n        returns the line or an empty string when at Beginning of\n        file.\n        \"\"\"\n        return self.__getitem__(self.__currentPos-1)\n        # &lt;&lt;fold\n    def currentLine(self): # fold&gt;&gt;\n        \"\"\"\n        gives the line at the current cursor position\n        \"\"\"\n        return self.__getitem__(self.__currentPos)\n        # &lt;&lt;fold\n    def currentPos(self): # fold&gt;&gt;\n        \"\"\" \n        return the current position (line) in the file\n        or -1 if the cursor is at the beginning of the file\n        or len(self) if it's at the end of file\n        \"\"\"\n        return self.__currentPos\n        # &lt;&lt;fold\n    def toBOF(self): # fold&gt;&gt;\n        \"\"\"\n        go to beginning of file\n        \"\"\"\n        self.__getitem__(-1)\n        # &lt;&lt;fold\n    def toEOF(self): # fold&gt;&gt;\n        \"\"\"\n        go to end of file\n        \"\"\"\n        self.__getitem__(self.__len__())\n        # &lt;&lt;fold\n    def toPos(self,key): # fold&gt;&gt;\n        \"\"\"\n        go to the specified line\n        \"\"\"\n        self.__getitem__(key)\n        # &lt;&lt;fold\n    def isAtEOF(self): # fold&gt;&gt;\n        return self.__currentPos == self.__len__()\n        # &lt;&lt;fold\n    def isAtBOF(self): # fold&gt;&gt;\n        return self.__currentPos == -1\n        # &lt;&lt;fold\n    def isAtPos(self,key): # fold&gt;&gt;\n        return self.__currentPos == key\n        # &lt;&lt;fold\n\n    def findString(self, thestring, count=1, backward=0): # fold&gt;&gt;\n        \"\"\"\n        find the count occurrence of the string str in the file\n        and return the line catched. The internal cursor is placed\n        at the same line.\n        backward is the searching flow.\n        For example, to search for the first occurrence of \"hello\n        starting from the beginning of the file do:\n\n        import FileReader\n        f=FileReader.FileReader(\"a_file\")\n        f.toBOF()\n        f.findString(\"hello\",1,0)\n\n        To search the second occurrence string from the end of the\n        file in backward movement do:\n\n        f.toEOF()\n        f.findString(\"hello\",2,1)\n\n        to search the first occurrence from a given (or current) position\n        say line 150, going forward in the file \n\n        f.toPos(150)\n        f.findString(\"hello\",1,0)\n\n        return the string where the occurrence is found, or an empty string\n        if nothing is found. The internal counter is placed at the corresponding\n        line number, if the string was found. In other case, it's set at BOF\n        if the search was backward, and at EOF if the search was forward.\n\n        NB: the current line is never evaluated. This is a feature, since\n        we can so traverse occurrences with a\n\n        line=f.findString(\"hello\")\n        while line == '':\n            line.findString(\"hello\")\n\n        instead of playing with a readline every time to skip the current\n        line.\n        \"\"\"\n        internalcounter=1\n        if count &lt; 1:\n            count = 1\n        while 1:\n            if backward == 0:\n                line=self.readline()\n            else:\n                line=self.readbackline()\n\n            if line == '':\n                return ''\n            if string.find(line,thestring) != -1 :\n                if count == internalcounter:\n                    return line\n                else:\n                    internalcounter = internalcounter + 1\n                    # &lt;&lt;fold\n    def findRegexp(self, theregexp, count=1, backward=0): # fold&gt;&gt;\n        \"\"\"\n        find the count occurrence of the regexp in the file\n        and return the line catched. The internal cursor is placed\n        at the same line.\n        backward is the searching flow.\n        You need to pass a regexp string as theregexp.\n        returns a tuple. The fist element is the matched line. The subsequent elements\n        contains the matched groups, if any.\n        If no match returns None\n        \"\"\"\n        rx=re.compile(theregexp)\n        internalcounter=1\n        if count &lt; 1:\n            count = 1\n        while 1:\n            if backward == 0:\n                line=self.readline()\n            else:\n                line=self.readbackline()\n\n            if line == '':\n                return None\n            m=rx.search(line)\n            if m != None :\n                if count == internalcounter:\n                    return (line,)+m.groups()\n                else:\n                    internalcounter = internalcounter + 1\n    # &lt;&lt;fold\n    def skipLines(self,key): # fold&gt;&gt;\n        \"\"\"\n        skip a given number of lines. Key can be negative to skip\n        backward. Return the last line read.\n        Please note that skipLines(1) is equivalent to readline()\n        skipLines(-1) is equivalent to readbackline() and skipLines(0)\n        is equivalent to currentLine()\n        \"\"\"\n        return self.__getitem__(self.__currentPos+key)\n    # &lt;&lt;fold\n    def occurrences(self,thestring,backward=0): # fold&gt;&gt;\n        \"\"\"\n        count how many occurrences of str are found from the current\n        position (current line excluded... see skipLines()) to the\n        begin (or end) of file.\n        returns a list of positions where each occurrence is found,\n        in the same order found reading the file.\n        Leaves unaltered the cursor position.\n        \"\"\"\n        curpos=self.currentPos()\n        list = []\n        line = self.findString(thestring,1,backward)\n        while line != '':\n            list.append(self.currentPos())\n            line = self.findString(thestring,1,backward)\n        self.toPos(curpos)\n        return list\n        # &lt;&lt;fold\n    def close(self): # fold&gt;&gt;\n        self.__file.close()\n    # &lt;&lt;fold\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\nfile_name = 'your_file_name'\nfile_open = open(file_name, 'r')\n\ndef handler(line_one, line_two):\n    print(line_one, line_two)\n\nwhile file_open:\n    try:\n        one = file_open.next()\n        two = file_open.next() \n        handler(one, two)\n    except(StopIteration):\n        file_open.close()\n        break\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n def readnumlines(file, num=2):\n    f = iter(file)\n    while True:\n        lines = [None] * num\n        for i in range(num):\n            try:\n                lines[i] = f.next()\n            except StopIteration: # EOF or not enough lines available\n                return\n        yield lines\n\n# use like this\nf = open(\"thefile.txt\", \"r\")\nfor line1, line2 in readnumlines(f):\n    # do something with line1 and line2\n\n# or\nfor line1, line2, line3, ..., lineN in readnumlines(f, N):\n    # do something with N lines\n</code>\n</pre>\n", "senID": 0}], [{"text": ["My idea is to create a generator that reads two lines from the file at a time, and returns this as a 2-tuple, This means you can then iterate over the results."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from cStringIO import StringIO\n\ndef read_2_lines(src):   \n    while True:\n        line1 = src.readline()\n        if not line1: break\n        line2 = src.readline()\n        if not line2: break\n        yield (line1, line2)\n\n\ndata = StringIO(\"line1\\nline2\\nline3\\nline4\\n\")\nfor read in read_2_lines(data):\n    print read\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you have an odd number of lines, it won't work perfectly, but this should give you a good outline."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I have worked on a similar problem last month.", "I tried a while loop with f.readline() as well as f.readlines().", "My data file is not huge, so I finally chose f.readlines(), which gives me more control of the index, otherwise\nI have to use f.seek() to move back and forth the file pointer."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["My case is more complicated than OP.", "Because my data file is more flexible on how many lines to be parsed each time, so\nI have to check a few conditions before I can parse the data."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Another problem I found out about f.seek() is that it doesn't handle utf-8 very well when I use codecs.open('', 'r', 'utf-8'), (not exactly sure about the culprit, eventually I gave up this approach."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Simple little reader.", "It will pull lines in pairs of two and return them as a tuple as you iterate over the object.", "You can close it manually or it will close itself when it falls out of scope."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class doublereader:\n    def __init__(self,filename):\n        self.f = open(filename, 'r')\n    def __iter__(self):\n        return self\n    def next(self):\n        return self.f.next(), self.f.next()\n    def close(self):\n        if not self.f.closed:\n            self.f.close()\n    def __del__(self):\n        self.close()\n\n#example usage one\nr = doublereader(r\"C:\\file.txt\")\nfor a, h in r:\n    print \"x:%s\\ny:%s\" % (a,h)\nr.close()\n\n#example usage two\nfor x,y in doublereader(r\"C:\\file.txt\"):\n    print \"x:%s\\ny:%s\" % (x,y)\n#closes itself as soon as the loop goes out of scope\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import linecache  \nfilename = \"ooxx.txt\"  \nprint(linecache.getline(filename,2))\n</code>\n</pre>\n", "senID": 0}]]