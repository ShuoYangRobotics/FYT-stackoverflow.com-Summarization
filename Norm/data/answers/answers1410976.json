[[{"text": ["The most flexible way is to use the subprocess module:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "subprocess", "tag": "a", "pos": 0, "childList": [{"text": "subprocess", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/subprocess.html"}, {"text": "subprocess", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import subprocess\n\nproc = subprocess.Popen([\"cat\", \"/tmp/baz\"], stdout=subprocess.PIPE, shell=True)\n(out, err) = proc.communicate()\nprint \"program output:\", out\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n os.popen('cat /tmp/baz').read()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["sth is right.", "You can also use os.popen(), but where available (Python 2.4+) subprocess is generally preferable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, unlike some languages that encourage it, it's generally considered bad form to spawn a subprocess where you can do the same job inside the language.", "It's slower, less reliable and platform-dependent.", "Your example would be better off as:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n foo= open('/tmp/baz').read()\n</code>\n</pre>\n", "senID": 2}, {"text": ["eta:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["cat on a directory gets me an error."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If you want a list of files:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import os\nfoo= os.listdir('/tmp/baz')\n</code>\n</pre>\n", "senID": 6}, {"text": ["If you want the contents of all files in a directory, something like:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n contents= []\nfor leaf in os.listdir('/tmp/baz'):\n    path= os.path.join('/tmp/baz', leaf)\n    if os.path.isfile(path):\n        contents.append(open(path, 'rb').read())\nfoo= ''.join(contents)\n</code>\n</pre>\n", "senID": 8}, {"text": ["or, if you can be sure there are no directories in there, you could fit it in a one-liner:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n path= '/tmp/baz'\nfoo= ''.join(open(os.path.join(path, child), 'rb').read() for child in os.listdir(path))\n</code>\n</pre>\n", "senID": 10}], [{"code": "<pre>\n<code>\n import os\nfoo = os.popen('cat /tmp/baz', 'r').read()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If you use subprocess.Popen, remember to specify bufsize.", "The default is 0, which means \"unbuffered\", not \"choose a reasonable default\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I'm using"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One of the examples above is:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import subprocess\nproc = subprocess.Popen([\"cat\", \"/tmp/baz\"], stdout=subprocess.PIPE, shell=True)\n(out, err) = proc.communicate()\nprint \"program output:\", out\n</code>\n</pre>\n", "senID": 2}, {"text": ["For me, this failed to access the directory /tmp.", "After looking at the doc string for subprocess I replaced "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["with "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["and got the shell expansion behavior that was desired (a la Perl's `prog arg`)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I quit using python a while back because I was annoyed with the difficulty of of doing the equivalent of perl `cmd ...`.", "I'm glad to find Python has made this reasonable."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"code": "<pre>\n<code>\n foo = subprocess.check_output([\"cat\", \"/tmp/baz\"])\n</code>\n</pre>\n", "senID": 0}]]