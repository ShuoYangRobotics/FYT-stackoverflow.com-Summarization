[[{"code": "<pre>\n<code>\n import itertools\na = [[\"a\",\"b\"], [\"c\"]]\nprint list(itertools.chain(*a))\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n x = [[\"a\",\"b\"], [\"c\"]]\n\nresult = sum(x, [])\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If you're only going one level deep, a nested comprehension will also work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = [[\"a\",\"b\"], [\"c\"]]\n&gt;&gt;&gt; [inner\n...     for outer in x\n...         for inner in outer]\n['a', 'b', 'c']\n</code>\n</pre>\n", "senID": 1}, {"text": ["On one line, that becomes:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [j for i in x for j in i]\n['a', 'b', 'c']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This is known as flattening, and there are a LOT of implementations out there:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["More on python flatten"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["Python tricks"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}, {"text": ["Flattening lists in Python"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}]}, {"text": ["How about this, although it will only work for 1 level deep nesting:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = [[\"a\",\"b\"], [\"c\"]]\n&gt;&gt;&gt; for el in sum(x, []):\n...     print el\n...\na\nb\nc\n</code>\n</pre>\n", "senID": 5}, {"text": ["From those links, apparently the most complete-fast-elegant-etc implementation is the following:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def flatten(l, ltypes=(list, tuple)):\n    ltype = type(l)\n    l = list(l)\n    i = 0\n    while i &lt; len(l):\n        while isinstance(l[i], ltypes):\n            if not l[i]:\n                l.pop(i)\n                i -= 1\n                break\n            else:\n                l[i:i + 1] = l[i]\n        i += 1\n    return ltype(l)\n</code>\n</pre>\n", "senID": 7}], [{"text": ["This works recursively for infinitely nested elements:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def iterFlatten(root):\n    if isinstance(root, (list, tuple)):\n        for element in root:\n            for e in iterFlatten(element)\n                yield e\n    else:\n        yield root\n</code>\n</pre>\n", "senID": 1}, {"text": ["Result:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n>>> b = [[\"a\", (\"b\", \"c\")], \"d\"]\n>>> list(iterFlatten(b))\n['a', 'b', 'c', 'd']\n</pre>\n", "senID": 3}], [{"text": ["What you're describing is known as flattening a list, and with this new knowledge you'll be able to find many solutions to this on Google (there is no built-in flatten method).", "Here is one of them, from http://www.daniel-lemire.com/blog/archives/2006/05/10/flattening-lists-in-python/:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "flattening", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "http://www.daniel-lemire.com/blog/archives/2006/05/10/flattening-lists-in-python/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.daniel-lemire.com/blog/archives/2006/05/10/flattening-lists-in-python/"}]}, {"code": "<pre>\n<code>\n def flatten(x):\n    flat = True\n    ans = []\n    for i in x:\n        if ( i.__class__ is list):\n            ans = flatten(i)\n        else:\n            ans.append(i)\n    return ans\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There's always reduce (being deprecated to functools):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = [ [ 'a', 'b'], ['c'] ]\n&gt;&gt;&gt; for el in reduce(lambda a,b: a+b, x, []):\n...  print el\n...\n__main__:1: DeprecationWarning: reduce() not supported in 3.x; use functools.reduce()\na\nb\nc\n&gt;&gt;&gt; import functools\n&gt;&gt;&gt; for el in functools.reduce(lambda a,b: a+b, x, []):\n...   print el\n...\na\nb\nc\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Unfortunately the plus operator for list concatenation can't be used as a function -- or fortunate, if you prefer lambdas to be ugly for improved visibility."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Or a recursive operation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def flatten(input):\n    ret = []\n    if not isinstance(input, (list, tuple)):\n        return [input]\n    for i in input:\n        if isinstance(i, (list, tuple)):\n            ret.extend(flatten(i))\n        else:\n            ret.append(i)\n    return ret\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Sadly, Python doesn't have a simple way to flatten lists.", "Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def flatten(some_list):\n    for element in some_list:\n        if type(element) in (tuple, list):\n            for item in flatten(element):\n                yield item\n        else:\n            yield element\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which will recursively flatten a list; you can then do"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n result = []\n[ result.extend(el) for el in x] \n\nfor el in flatten(result):\n      print el\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n l = []\nmap(l.extend, list_of_lists)\n</code>\n</pre>\n", "senID": 0}, {"text": ["shortest!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I think this is the most readable way to do it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\nx = [[\"a\",\"b\"], [\"c\"]]\nresult = reduce(operator.add, x) #[\"a\", \"b\", \"c\"]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This only goes one level deep, though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Late to the party but ... "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I'm new to python and come from a lisp background.", "This is what I came up with (check out the var names for lulz):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def flatten(lst):\n    if lst:\n        car,*cdr=lst\n        if isinstance(car,(list,tuple)):\n            if cdr: return flatten(car) + flatten(cdr)\n            return flatten(car)\n        if cdr: return [car] + flatten(cdr)\n        return [car]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Seems to work.", "Test:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n flatten((1,2,3,(4,5,6,(7,8,(((1,2)))))))\n</code>\n</pre>\n", "senID": 4}, {"text": ["returns:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n [1, 2, 3, 4, 5, 6, 7, 8, 1, 2]\n</code>\n</pre>\n", "senID": 6}], [{"text": ["If you meant using \"join\":"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["print '\\n'.join(map(str, listOfLists or listOfTuples))"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "print '\\n'.join(map(str, listOfLists or listOfTuples))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]