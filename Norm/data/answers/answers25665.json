[[{"text": ["The PDFMiner package has changed since codeape posted.  "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "PDFMiner", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.unixuser.org/~euske/python/pdfminer/index.html"}, {"href": "http://stackoverflow.com/users/3571/codeape", "text": "codeape", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["EDIT (again)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "EDIT (again)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["PDFMiner has been updated again in version 20100213"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "20100213", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You can check the version you have installed with the following:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import pdfminer\n&gt;&gt;&gt; pdfminer.__version__\n'20100213'\n</code>\n</pre>\n", "senID": 4}, {"text": ["Here's the updated version (with comments on what I changed/added):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def pdf_to_csv(filename):\n    from cStringIO import StringIO  #&lt;-- added so you can copy/paste this to try it\n    from pdfminer.converter import LTTextItem, TextConverter\n    from pdfminer.pdfparser import PDFDocument, PDFParser\n    from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter\n\n    class CsvConverter(TextConverter):\n        def __init__(self, *args, **kwargs):\n            TextConverter.__init__(self, *args, **kwargs)\n\n        def end_page(self, i):\n            from collections import defaultdict\n            lines = defaultdict(lambda : {})\n            for child in self.cur_item.objs:\n                if isinstance(child, LTTextItem):\n                    (_,_,x,y) = child.bbox                   #&lt;-- changed\n                    line = lines[int(-y)]\n                    line[x] = child.text.encode(self.codec)  #&lt;-- changed\n\n            for y in sorted(lines.keys()):\n                line = lines[y]\n                self.outfp.write(\";\".join(line[x] for x in sorted(line.keys())))\n                self.outfp.write(\"\\n\")\n\n    # ... the following part of the code is a remix of the \n    # convert() function in the pdfminer/tools/pdf2text module\n    rsrc = PDFResourceManager()\n    outfp = StringIO()\n    device = CsvConverter(rsrc, outfp, codec=\"utf-8\")  #&lt;-- changed \n        # becuase my test documents are utf-8 (note: utf-8 is the default codec)\n\n    doc = PDFDocument()\n    fp = open(filename, 'rb')\n    parser = PDFParser(fp)       #&lt;-- changed\n    parser.set_document(doc)     #&lt;-- added\n    doc.set_parser(parser)       #&lt;-- added\n    doc.initialize('')\n\n    interpreter = PDFPageInterpreter(rsrc, device)\n\n    for i, page in enumerate(doc.get_pages()):\n        outfp.write(\"START PAGE %d\\n\" % i)\n        interpreter.process_page(page)\n        outfp.write(\"END PAGE %d\\n\" % i)\n\n    device.close()\n    fp.close()\n\n    return outfp.getvalue()\n</code>\n</pre>\n", "senID": 6}, {"text": ["Edit (yet again):"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Edit (yet again):", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Here is an update for the latest version in pypi, 20100619p1.", "In short I replaced LTTextItem with LTChar and passed an instance of LAParams to the CsvConverter constructor."], "childNum": 4, "tag": "p", "senID": 8, "childList": [{"text": "pypi", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/pdfminer/"}, {"text": "20100619p1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "LTTextItem", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "LTChar", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def pdf_to_csv(filename):\n    from cStringIO import StringIO  \n    from pdfminer.converter import LTChar, TextConverter    #&lt;-- changed\n    from pdfminer.layout import LAParams\n    from pdfminer.pdfparser import PDFDocument, PDFParser\n    from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter\n\n    class CsvConverter(TextConverter):\n        def __init__(self, *args, **kwargs):\n            TextConverter.__init__(self, *args, **kwargs)\n\n        def end_page(self, i):\n            from collections import defaultdict\n            lines = defaultdict(lambda : {})\n            for child in self.cur_item.objs:\n                if isinstance(child, LTChar):               #&lt;-- changed\n                    (_,_,x,y) = child.bbox                   \n                    line = lines[int(-y)]\n                    line[x] = child.text.encode(self.codec)\n\n            for y in sorted(lines.keys()):\n                line = lines[y]\n                self.outfp.write(\";\".join(line[x] for x in sorted(line.keys())))\n                self.outfp.write(\"\\n\")\n\n    # ... the following part of the code is a remix of the \n    # convert() function in the pdfminer/tools/pdf2text module\n    rsrc = PDFResourceManager()\n    outfp = StringIO()\n    device = CsvConverter(rsrc, outfp, codec=\"utf-8\", laparams=LAParams())  #&lt;-- changed\n        # becuase my test documents are utf-8 (note: utf-8 is the default codec)\n\n    doc = PDFDocument()\n    fp = open(filename, 'rb')\n    parser = PDFParser(fp)       \n    parser.set_document(doc)     \n    doc.set_parser(parser)       \n    doc.initialize('')\n\n    interpreter = PDFPageInterpreter(rsrc, device)\n\n    for i, page in enumerate(doc.get_pages()):\n        outfp.write(\"START PAGE %d\\n\" % i)\n        if page is not None:\n            interpreter.process_page(page)\n        outfp.write(\"END PAGE %d\\n\" % i)\n\n    device.close()\n    fp.close()\n\n    return outfp.getvalue()\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Try PDFMiner.", "It can extract text from PDF files as HTML, SGML or \"Tagged PDF\" format."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.unixuser.org/~euske/python/pdfminer/index.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.unixuser.org/~euske/python/pdfminer/index.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.unixuser.org/~euske/python/pdfminer/index.html"}]}, {"text": ["The Tagged PDF format seems to be the cleanest, and stripping out the XML tags leaves just the bare text."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can also quite easily use pdfminer as a library.", "You have access to the pdf's content model, and can create your own text extraction.", "I did this to convert pdf contents to semi-colon separated text, using the code below."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The function simply sorts the TextItem content objects according to their y and x coordinates, and outputs items with the same y coordinate as one text line, separating the objects on the same line with ';' characters."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Using this approach, I was able to extract text from a pdf that no other tool was able to extract content suitable for further parsing from.", "Other tools I tried include pdftotext, ps2ascii and the online tool pdftextonline.com."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["pdfminer is an invaluable tool for pdf-scraping."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def pdf_to_csv(filename):\n    from pdflib.page import TextItem, TextConverter\n    from pdflib.pdfparser import PDFDocument, PDFParser\n    from pdflib.pdfinterp import PDFResourceManager, PDFPageInterpreter\n\n    class CsvConverter(TextConverter):\n        def __init__(self, *args, **kwargs):\n            TextConverter.__init__(self, *args, **kwargs)\n\n        def end_page(self, i):\n            from collections import defaultdict\n            lines = defaultdict(lambda : {})\n            for child in self.cur_item.objs:\n                if isinstance(child, TextItem):\n                    (_,_,x,y) = child.bbox\n                    line = lines[int(-y)]\n                    line[x] = child.text\n\n            for y in sorted(lines.keys()):\n                line = lines[y]\n                self.outfp.write(\";\".join(line[x] for x in sorted(line.keys())))\n                self.outfp.write(\"\\n\")\n\n    # ... the following part of the code is a remix of the \n    # convert() function in the pdfminer/tools/pdf2text module\n    rsrc = PDFResourceManager()\n    outfp = StringIO()\n    device = CsvConverter(rsrc, outfp, \"ascii\")\n\n    doc = PDFDocument()\n    fp = open(filename, 'rb')\n    parser = PDFParser(doc, fp)\n    doc.initialize('')\n\n    interpreter = PDFPageInterpreter(rsrc, device)\n\n    for i, page in enumerate(doc.get_pages()):\n        outfp.write(\"START PAGE %d\\n\" % i)\n        interpreter.process_page(page)\n        outfp.write(\"END PAGE %d\\n\" % i)\n\n    device.close()\n    fp.close()\n\n    return outfp.getvalue()\n</code>\n</pre>\n", "senID": 4}, {"text": ["UPDATE:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "UPDATE", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The code above is written against an old version of the API, see my comment below."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["pyPDF works fine (assuming that you're working with well-formed PDFs).", "If all you want is the text (with spaces), you can just do:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pyPDF", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pybrary.net/pyPdf/"}]}, {"code": "<pre>\n<code>\n import pyPdf\npdf = pyPdf.PdfFileReader(open(filename, \"rb\"))\nfor page in pdf.pages:\n    print page.extractText()\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can also easily get access to the metadata, image data, and so forth."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["A comment in the extractText code notes:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Whether or not this is a problem depends on what you're doing with the text (e.g.", "if the order doesn't matter, it's fine, or if the generator adds text to the stream in the order it will be displayed, it's fine).", "I have pyPdf extraction code in daily use, without any problems."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Pdftotext An open source program (part of Xpdf) which you could call from python (not what you asked for but might be useful).", "I've used it with no problems.", "I think google use it in google desktop."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Pdftotext", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Pdftotext"}]}], [{"text": ["Repurposing the pdf2txt.py code that comes with pdfminer; you can make a function that will take a path to the pdf; optionally, an outtype (txt|html|xml|tag) and opts like the commandline pdf2txt {'-o': '/path/to/outfile.txt' ...}.", "By default, you can call:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n convert_pdf(path)\n</code>\n</pre>\n", "senID": 1}, {"text": ["A text file will be created, a sibling on the filesystem to the original pdf."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def convert_pdf(path, outtype='txt', opts={}):\n    import sys\n    from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter, process_pdf\n    from pdfminer.converter import XMLConverter, HTMLConverter, TextConverter, TagExtractor\n    from pdfminer.layout import LAParams\n    from pdfminer.pdfparser import PDFDocument, PDFParser\n    from pdfminer.pdfdevice import PDFDevice\n    from pdfminer.cmapdb import CMapDB\n\n    outfile = path[:-3] + outtype\n    outdir = '/'.join(path.split('/')[:-1])\n\n    debug = 0\n    # input option\n    password = ''\n    pagenos = set()\n    maxpages = 0\n    # output option\n    codec = 'utf-8'\n    pageno = 1\n    scale = 1\n    showpageno = True\n    laparams = LAParams()\n    for (k, v) in opts:\n        if k == '-d': debug += 1\n        elif k == '-p': pagenos.update( int(x)-1 for x in v.split(',') )\n        elif k == '-m': maxpages = int(v)\n        elif k == '-P': password = v\n        elif k == '-o': outfile = v\n        elif k == '-n': laparams = None\n        elif k == '-A': laparams.all_texts = True\n        elif k == '-D': laparams.writing_mode = v\n        elif k == '-M': laparams.char_margin = float(v)\n        elif k == '-L': laparams.line_margin = float(v)\n        elif k == '-W': laparams.word_margin = float(v)\n        elif k == '-O': outdir = v\n        elif k == '-t': outtype = v\n        elif k == '-c': codec = v\n        elif k == '-s': scale = float(v)\n    #\n    CMapDB.debug = debug\n    PDFResourceManager.debug = debug\n    PDFDocument.debug = debug\n    PDFParser.debug = debug\n    PDFPageInterpreter.debug = debug\n    PDFDevice.debug = debug\n    #\n    rsrcmgr = PDFResourceManager()\n    if not outtype:\n        outtype = 'txt'\n        if outfile:\n            if outfile.endswith('.htm') or outfile.endswith('.html'):\n                outtype = 'html'\n            elif outfile.endswith('.xml'):\n                outtype = 'xml'\n            elif outfile.endswith('.tag'):\n                outtype = 'tag'\n    if outfile:\n        outfp = file(outfile, 'w')\n    else:\n        outfp = sys.stdout\n    if outtype == 'txt':\n        device = TextConverter(rsrcmgr, outfp, codec=codec, laparams=laparams)\n    elif outtype == 'xml':\n        device = XMLConverter(rsrcmgr, outfp, codec=codec, laparams=laparams, outdir=outdir)\n    elif outtype == 'html':\n        device = HTMLConverter(rsrcmgr, outfp, codec=codec, scale=scale, laparams=laparams, outdir=outdir)\n    elif outtype == 'tag':\n        device = TagExtractor(rsrcmgr, outfp, codec=codec)\n    else:\n        return usage()\n\n    fp = file(path, 'rb')\n    process_pdf(rsrcmgr, device, fp, pagenos, maxpages=maxpages, password=password)\n    fp.close()\n    device.close()\n\n    outfp.close()\n    return\n</code>\n</pre>\n", "senID": 3}], [{"text": ["slate is a project that makes it very simple to use PDFMiner from a library:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "slate", "tag": "a", "pos": 0, "childList": [{"text": "slate", "tag": "code"}], "childNum": 1, "href": "http://pypi.python.org/pypi/slate"}, {"text": "slate", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; with open('example.pdf') as f:\n...    doc = slate.PDF(f)\n...\n&gt;&gt;&gt; doc\n[..., ..., ...]\n&gt;&gt;&gt; doc[1]\n'Text from page 2...'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Additionally there is PDFTextStream which is a commercial Java library that can also be used from Python."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PDFTextStream", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://snowtide.com/PDFTextStream"}]}], [{"text": ["I have used pdftohtml with the '-xml' argument, read the result with subprocess.Popen(), that will give you x coord, y coord, width, height, and font, of every 'snippet' of text in the pdf.", "I think this is what 'evince' probably uses too because the same error messages spew out. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you need to process columnar data, it gets slightly more complicated as you have to invent an algorithm that suits your pdf file.", "The problem is that the programs that make PDF files don't really necessarily lay out the text in any logical format.", "You can try simple sorting algorithms and it works sometimes, but there can be little 'stragglers' and 'strays', pieces of text that don't get put in the order you thought they would... so you have to get creative. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It took me about 5 hours to figure out one for the pdf's i was working on.", "But it works pretty good now.", "Good luck. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["PDFminer gave me perhaps one line [page 1 of 7...] on every page of a pdf file I tried with it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The best answer I have so far is pdftoipe, or the c++ code it's based on Xpdf."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["see my question for what the output of pdftoipe looks like."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "my question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/25550/whats-the-best-way-to-importread-data-from-pdf-files"}]}], [{"text": ["In my pdf to text conversion projects, I had excellent result with pdftotext (open source) like Jamie mentioned in this forum."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Found that solution today.", "Works great for me.", "Even rendering PDF pages to PNG images.", "http://www.swftools.org/gfx_tutorial.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.swftools.org/gfx_tutorial.html", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://www.swftools.org/gfx_tutorial.html"}]}]]