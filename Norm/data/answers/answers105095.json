[[{"text": ["You will still need locks if you share state between threads.", "The GIL only protects the interpreter internally.", "You can still have inconsistent updates in your own code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nimport threading\n\nshared_balance = 0\n\nclass Deposit(threading.Thread):\n    def run(self):\n        for _ in xrange(1000000):\n            global shared_balance\n            balance = shared_balance\n            balance += 100\n            shared_balance = balance\n\nclass Withdraw(threading.Thread):\n    def run(self):\n        for _ in xrange(1000000):\n            global shared_balance\n            balance = shared_balance\n            balance -= 100\n            shared_balance = balance\n\nthreads = [Deposit(), Withdraw()]\n\nfor thread in threads:\n    thread.start()\n\nfor thread in threads:\n    thread.join()\n\nprint shared_balance\n</code>\n</pre>\n", "senID": 2}, {"text": ["Here, your code can be interrupted between reading the shared state (balance = shared_balance) and writing the changed result back (shared_balance = balance), causing a lost update.", "The result is a random value for the shared state."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "balance = shared_balance", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "shared_balance = balance", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["To make the updates consistent, run methods would need to lock the shared state around the read-modify-write sections (inside the loops) or have some way to detect when the shared state had changed since it was read."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "some way to detect when the shared state had changed since it was read", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Software_transactional_memory"}]}], [{"text": ["No - the GIL just protects python internals from multiple threads altering their state.", "This is a very low-level of locking, sufficient only to keep python's own structures in a consistent state.", "It doesn't cover the application level locking you'll need to do to cover thread safety in your own code."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "application", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["The essence of locking is to ensure that a particular block of code is only executed by one thread.", "The GIL enforces this for blocks the size of a single bytecode, but usually you want the lock to span a larger block of code than this."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "block", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["The Global Interpreter Lock prevents threads from accessing the interpreter simultaneously (thus CPython only ever uses one core).", "However, as I understand it, the threads are still interrupted and scheduled preemptively, which means you still need locks on shared data structures, lest your threads stomp on each other's toes."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "interpreter", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "preemptively", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["The answer I've encountered time and time again is that multithreading in Python is rarely worth the overhead, because of this.", "I've heard good things about the PyProcessing project, which makes running multiple processes as \"simple\" as multithreading, with shared data structures, queues, etc.", "(PyProcessing will be introduced into the standard library of the upcoming Python 2.6 as the multiprocessing module.", ") This gets you around the GIL, as each process has its own interpreter."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "PyProcessing", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pyprocessing.berlios.de/"}, {"text": "multiprocessing", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0371/"}]}], [{"text": ["This post describes the GIL at a fairly high-level:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": ["http://www.pyzine.com/Issue001/Section_Articles/article_ThreadingGlobalInterpreter.html"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}]}, {"text": ["Of particular interest are these quotes:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["and "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["It sounds like the GIL just provides fewer possible instances for a context switch, and makes multi-core/processor systems behave as a single core, with respect to each python interpreter instance, so yes, you still need to use synchronization mechanisms."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Adding to the discussion:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Because the GIL exists, some operations are atomic in Python and do not need a lock. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://www.python.org/doc/faq/library/#what-kinds-of-global-value-mutation-are-thread-safe"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.python.org/doc/faq/library/#what-kinds-of-global-value-mutation-are-thread-safe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/faq/library/#what-kinds-of-global-value-mutation-are-thread-safe"}]}, {"text": ["As stated by the other answers, however, you still need to use locks whenever the application logic requires them (such as in a Producer/Consumer problem)."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "still", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["You still need to use locks (your code could be interrupted at any time to execute another thread and this can cause data inconsistencies).", "The problem with GIL is that it prevents Python code from using more cores at the same time (or multiple processors if they are available)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["A little bit of update from Will Harris's example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Withdraw(threading.Thread):  \ndef run(self):            \n    for _ in xrange(1000000):  \n        global shared_balance  \n        if shared_balance &gt;= 100:\n          balance = shared_balance\n          balance -= 100  \n          shared_balance = balance\n</code>\n</pre>\n", "senID": 1}, {"text": ["Put a value check statement in the withdraw and I don't see negative anymore and updates seems consistent.", "My question is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If GIL prevents only one thread can be executed at any atomic time, then where would be the stale value?", "If no stale value, why we need lock?", "(Assuming we only talk about pure python code)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If I understand correctly, the above condition check wouldn't work in a real threading environment.", "When more than one threads are executing concurrently, stale value can be created hence the inconsistency of the share state, then you really need a lock.", "But if python really only allows just one thread at any time (time slicing threading), then there shouldn't be possible for stale value to exist, right?"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "real", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Think of it this way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["On a single processor computer, multithreading happens by suspending one thread and starting another fast enough to make it appear to be running at the same time.", "This is like Python with the GIL: only one thread is ever actually running."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The problem is that the thread can be suspended anywhere, for example, if I want to compute b = (a + b) * 3, this might produce instructions something like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 1    a += b\n2    a *= 3\n3    b = a\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now, lets say that is running in a thread and that thread is suspended after either line 1 or 2 and then another thread kicks in and runs:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n b = 5\n</code>\n</pre>\n", "senID": 5}, {"text": ["Then when the other thread resumes, b is overwritten by the old computed values, which is probably not what was expected."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["So you can see that even though they're not ACTUALLY running at the same time, you still need locking."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]]