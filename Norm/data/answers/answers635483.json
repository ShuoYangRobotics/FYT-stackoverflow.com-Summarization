[[{"code": "<pre>\n<code>\n class AutoVivification(dict):\n    \"\"\"Implementation of perl's autovivification feature.\"\"\"\n    def __getitem__(self, item):\n        try:\n            return dict.__getitem__(self, item)\n        except KeyError:\n            value = self[item] = type(self)()\n            return value\n</code>\n</pre>\n", "senID": 0}, {"text": ["Testing:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a = AutoVivification()\n\na[1][2][3] = 4\na[1][3][3] = 5\na[1][2]['test'] = 6\n\nprint a\n</code>\n</pre>\n", "senID": 2}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n {1: {2: {'test': 6, 3: 4}, 3: {3: 5}}}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You could create a YAML file and read it in using PyYaml."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PyYaml", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyyaml.org/"}]}, {"text": ["Step 1:  Create a YAML file, \"employment.yml\":"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n new jersey:\n  mercer county:\n    pumbers: 3\n    programmers: 81\n  middlesex county:\n    salesmen: 62\n    programmers: 81\nnew york:\n  queens county:\n    plumbers: 9\n    salesmen: 36\n</code>\n</pre>\n", "senID": 2}, {"text": ["Step 2:  Read it in Python"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import yaml\nfile_handle = open(\"employment.yml\")\nmy_shnazzy_dictionary = yaml.safe_load(file_handle)\nfile_handle.close()\n</code>\n</pre>\n", "senID": 4}, {"text": ["and now my_shnazzy_dictionary has all your values.", "If you needed to do this on the fly, you can create the YAML as a string and feed that into yaml.safe_load(...)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Since you have a star-schema design, you might want to structure it more like a relational table and less like a dictionary."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import collections\n\nclass Jobs( object ):\n    def __init__( self, state, county, title, count ):\n        self.state= state\n        self.count= county\n        self.title= title\n        self.count= count\n\nfacts = [\n    Jobs( 'new jersey', 'mercer county', 'plumbers', 3 ),\n    ...\n\ndef groupBy( facts, name ):\n    total= collections.defaultdict( int )\n    for f in facts:\n        key= getattr( f, name )\n        total[key] += f.count\n</code>\n</pre>\n", "senID": 1}, {"text": ["That kind of thing can go a long way to creating a data warehouse-like design without the SQL overheads."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If the number of nesting levels is small, I use collections.defaultdict for this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\nfrom collections import defaultdict\n\ndef nested_dict_factory(): \n  return defaultdict(int)\ndef nested_dict_factory2(): \n  return defaultdict(nested_dict_factory)\ndb = defaultdict(nested_dict_factory2)\n\ndb['new jersey']['mercer county']['plumbers'] = 3\ndb['new jersey']['mercer county']['programmers'] = 81\n</pre>\n", "senID": 1}, {"text": ["Using defaultdict like this avoids a lot of messy setdefault(), get(), etc."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I find 'setdefault' quite useful - it checks if a key is present and adds it if not:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d = {}\nd.setdefault('new jersey', {}).setdefault('mercer county', {})['plumbers'] = 3\n</code>\n</pre>\n", "senID": 1}, {"text": ["setdefault always returns the relevant key, so you are actually updating the values of 'd' in place."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["When it comes to iterating,  I'm sure you could write a generator easily enough if one doesn't already exist in Python:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def iterateStates(d):\n    # Let's count up the total number of \"plumbers\" / \"dentists\" / etc.\n    # across all counties and states\n    job_totals = {}\n\n    # I guess this is the annoying nested stuff you were talking about?\n    for (state, counties) in d.iteritems():\n        for (county, jobs) in counties.iteritems():\n            for (job, num) in jobs.iteritems():\n                # If job isn't already in job_totals, default it to zero\n                job_totals[job] = job_totals.get(job, 0) + num\n\n    # Now return an iterator of (job, number) tuples\n    return job_totals.iteritems()\n\n# Display all jobs\nfor (job, num) in iterateStates(d):\n    print \"There are %d %s in total\" % (job, num)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["As for \"obnoxious try/catch blocks\":"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d = {}\nd.setdefault('key',{}).setdefault('inner key',{})['inner inner key'] = 'value'\nprint d\n</code>\n</pre>\n", "senID": 1}, {"text": ["yields"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {'key': {'inner key': {'inner inner key': 'value'}}}\n</code>\n</pre>\n", "senID": 3}, {"text": ["You can use this to convert from your flat dictionary format to structured format:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n fd = {('new jersey', 'mercer county', 'plumbers'): 3,\n ('new jersey', 'mercer county', 'programmers'): 81,\n ('new jersey', 'middlesex county', 'programmers'): 81,\n ('new jersey', 'middlesex county', 'salesmen'): 62,\n ('new york', 'queens county', 'plumbers'): 9,\n ('new york', 'queens county', 'salesmen'): 36}\n\nfor (k1,k2,k3), v in fd.iteritems():\n    d.setdefault(k1, {}).setdefault(k2, {})[k3] = v\n</code>\n</pre>\n", "senID": 5}], [{"text": ["As others have suggested, a relational database could be more useful to you.", "You can use a in-memory sqlite3 database as a data structure to create tables and then query them."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sqlite3\n\nc = sqlite3.Connection(':memory:')\nc.execute('CREATE TABLE jobs (state, county, title, count)')\n\nc.executemany('insert into jobs values (?, ?, ?, ?)', [\n    ('New Jersey', 'Mercer County',    'Programmers', 81),\n    ('New Jersey', 'Mercer County',    'Plumbers',     3),\n    ('New Jersey', 'Middlesex County', 'Programmers', 81),\n    ('New Jersey', 'Middlesex County', 'Salesmen',    62),\n    ('New York',   'Queens County',    'Salesmen',    36),\n    ('New York',   'Queens County',    'Plumbers',     9),\n])\n\n# some example queries\nprint list(c.execute('SELECT * FROM jobs WHERE county = \"Queens County\"'))\nprint list(c.execute('SELECT SUM(count) FROM jobs WHERE title = \"Programmers\"'))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is just a simple example.", "You could define separate tables for states, counties and job titles."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I like the idea of wrapping this in a class and implementing __getitem__ and __setitem__ such that they implemented a simple query language:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d['new jersey/mercer county/plumbers'] = 3\n&gt;&gt;&gt; d['new jersey/mercer county/programmers'] = 81\n&gt;&gt;&gt; d['new jersey/mercer county/programmers']\n81\n&gt;&gt;&gt; d['new jersey/mercer country']\n&lt;view which implicitly adds 'new jersey/mercer county' to queries/mutations&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you wanted to get fancy you could also implement something like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d['*/*/programmers']\n&lt;view which would contain 'programmers' entries&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["... but mostly I think such a thing would be really fun to implement :D "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n class JobDb(object):\n    def __init__(self):\n        self.data = []\n        self.all = set()\n        self.free = []\n        self.index1 = {}\n        self.index2 = {}\n        self.index3 = {}\n\n    def _indices(self,(key1,key2,key3)):\n        indices = self.all.copy()\n        wild = False\n        for index,key in ((self.index1,key1),(self.index2,key2),\n                                             (self.index3,key3)):\n            if key is not None:\n                indices &amp;= index.setdefault(key,set())\n            else:\n                wild = True\n        return indices, wild\n\n    def __getitem__(self,key):\n        indices, wild = self._indices(key)\n        if wild:\n            return dict(self.data[i] for i in indices)\n        else:\n            values = [self.data[i][-1] for i in indices]\n            if values:\n                return values[0]\n\n    def __setitem__(self,key,value):\n        indices, wild = self._indices(key)\n        if indices:\n            for i in indices:\n                self.data[i] = key,value\n        elif wild:\n            raise KeyError(k)\n        else:\n            if self.free:\n                index = self.free.pop(0)\n                self.data[index] = key,value\n            else:\n                index = len(self.data)\n                self.data.append((key,value))\n                self.all.add(index)\n            self.index1.setdefault(key[0],set()).add(index)\n            self.index2.setdefault(key[1],set()).add(index)\n            self.index3.setdefault(key[2],set()).add(index)\n\n    def __delitem__(self,key):\n        indices,wild = self._indices(key)\n        if not indices:\n            raise KeyError\n        self.index1[key[0]] -= indices\n        self.index2[key[1]] -= indices\n        self.index3[key[2]] -= indices\n        self.all -= indices\n        for i in indices:\n            self.data[i] = None\n        self.free.extend(indices)\n\n    def __len__(self):\n        return len(self.all)\n\n    def __iter__(self):\n        for key,value in self.data:\n            yield key\n</code>\n</pre>\n", "senID": 0}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; db = JobDb()\n&gt;&gt;&gt; db['new jersey', 'mercer county', 'plumbers'] = 3\n&gt;&gt;&gt; db['new jersey', 'mercer county', 'programmers'] = 81\n&gt;&gt;&gt; db['new jersey', 'middlesex county', 'programmers'] = 81\n&gt;&gt;&gt; db['new jersey', 'middlesex county', 'salesmen'] = 62\n&gt;&gt;&gt; db['new york', 'queens county', 'plumbers'] = 9\n&gt;&gt;&gt; db['new york', 'queens county', 'salesmen'] = 36\n\n&gt;&gt;&gt; db['new york', None, None]\n{('new york', 'queens county', 'plumbers'): 9,\n ('new york', 'queens county', 'salesmen'): 36}\n\n&gt;&gt;&gt; db[None, None, 'plumbers']\n{('new jersey', 'mercer county', 'plumbers'): 3,\n ('new york', 'queens county', 'plumbers'): 9}\n\n&gt;&gt;&gt; db['new jersey', 'mercer county', None]\n{('new jersey', 'mercer county', 'plumbers'): 3,\n ('new jersey', 'mercer county', 'programmers'): 81}\n\n&gt;&gt;&gt; db['new jersey', 'middlesex county', 'programmers']\n81\n\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["Edit: Now returning dictionaries when querying with wild cards (None), and single values otherwise."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["For easy iterating over your nested dictionary, why not just write a simple generator?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def each_job(my_dict):\n    for state, a in my_dict.items():\n        for county, b in a.items():\n            for job, value in b.items():\n                yield {\n                    'state'  : state,\n                    'county' : county,\n                    'job'    : job,\n                    'value'  : value\n                }\n</code>\n</pre>\n", "senID": 1}, {"text": ["So then, if you have your compilicated nested dictionary, iterating over it becomes simple:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for r in each_job(my_dict):\n    print \"There are %d %s in %s, %s\" % (r['value'], r['job'], r['county'], r['state'])\n</code>\n</pre>\n", "senID": 3}, {"text": ["Obviously your generator can yield whatever format of data is useful to you."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Why are you using try catch blocks to read the tree?", "It's easy enough (and probably safer) to query whether a key exists in a dict before trying to retrieve it.", "A function using guard clauses might look like this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n if not my_dict.has_key('new jersey'):\n    return False\n\nnj_dict = my_dict['new jersey']\n...\n</code>\n</pre>\n", "senID": 6}, {"text": ["Or, a perhaps somewhat verbose method, is to use the get method:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n value = my_dict.get('new jersey', {}).get('middlesex county', {}).get('salesmen', 0)\n</code>\n</pre>\n", "senID": 8}, {"text": ["But for a somewhat more succinct way, you might want to look at using a collections.defaultdict, which is part of the standard library since python 2.5."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "collections.defaultdict", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html#collections.defaultdict"}]}, {"code": "<pre>\n<code>\n import collections\n\ndef state_struct(): return collections.defaultdict(county_struct)\ndef county_struct(): return collections.defaultdict(job_struct)\ndef job_struct(): return 0\n\nmy_dict = collections.defaultdict(state_struct)\n\nprint my_dict['new jersey']['middlesex county']['salesmen']\n</code>\n</pre>\n", "senID": 10}, {"text": ["I'm making assumptions about the meaning of your data structure here, but it should be easy to adjust for what you actually want to do."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["Unless your dataset is going to stay pretty small, you might want to consider using a relational database.", "It will do exactly what you want: make it easy to add counts, selecting subsets of counts, and even aggregate counts by state, county, occupation, or any combination of these."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["collections.defaultdict can be subclassed to make a nested dict.", "Then add any useful iteration methods to that class."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import defaultdict\n&gt;&gt;&gt; class nesteddict(defaultdict):\n    def __init__(self):\n        defaultdict.__init__(self, nesteddict)\n    def walk(self):\n        for key, value in self.iteritems():\n            if isinstance(value, nesteddict):\n                for tup in value.walk():\n                    yield (key,) + tup\n            else:\n                yield key, value\n\n\n&gt;&gt;&gt; nd = nesteddict()\n&gt;&gt;&gt; nd['new jersey']['mercer county']['plumbers'] = 3\n&gt;&gt;&gt; nd['new jersey']['mercer county']['programmers'] = 81\n&gt;&gt;&gt; nd['new jersey']['middlesex county']['programmers'] = 81\n&gt;&gt;&gt; nd['new jersey']['middlesex county']['salesmen'] = 62\n&gt;&gt;&gt; nd['new york']['queens county']['plumbers'] = 9\n&gt;&gt;&gt; nd['new york']['queens county']['salesmen'] = 36\n&gt;&gt;&gt; for tup in nd.walk():\n    print tup\n\n\n('new jersey', 'mercer county', 'programmers', 81)\n('new jersey', 'mercer county', 'plumbers', 3)\n('new jersey', 'middlesex county', 'programmers', 81)\n('new jersey', 'middlesex county', 'salesmen', 62)\n('new york', 'queens county', 'salesmen', 36)\n('new york', 'queens county', 'plumbers', 9)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["defaultdict() is your friend!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I didn't come up with this (see link)  but for a two dimensional dictionary you can do:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["d = defaultdict(defaultdict)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["d[1][2] = 3"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["For more dimensions you can: "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["d = defaultdict(lambda :defaultdict(defaultdict))\nd[1][2][3] = 4"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Original solution at:\nhttp://slacy.com/blog/2010/05/python-multi-dimensional-dicts-using-defaultdict/"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "http://slacy.com/blog/2010/05/python-multi-dimensional-dicts-using-defaultdict/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://slacy.com/blog/2010/05/python-multi-dimensional-dicts-using-defaultdict/"}]}], [{"text": ["just because i haven't seen one this small, here's a dict that gets as nested as you like, no sweat"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # yo dawg, i heard you liked dicts                                                                      \ndef yodict():\n    return defaultdict(yodict)\n</code>\n</pre>\n", "senID": 1}]]