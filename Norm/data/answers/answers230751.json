[[{"code": "<pre>\n<code>\n import sys\nsys.stdout.flush()\n</code>\n</pre>\n", "senID": 0}, {"text": ["print by default prints to sys.stdout"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["References:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["http://docs.python.org/reference/simple_stmts.html#the-print-statement"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}, {"text": ["http://docs.python.org/library/sys.html"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}, {"text": ["http://docs.python.org/library/stdtypes.html#file-objects"], "childNum": 0, "tag": "a", "senID": 5, "childList": []}]}], [{"text": ["Running python -h, I see a command line option:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "python -h", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "command line option", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Here is the relevant doc."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "relevant doc", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/using/cmdline.html#cmdoption-u"}]}], [{"text": ["Dan's idea doesn't quite work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nclass flushfile(file):\n    def __init__(self, f):\n        self.f = f\n    def write(self, x):\n        self.f.write(x)\n        self.f.flush()\n\nimport sys\nsys.stdout = flushfile(sys.stdout)\n\nprint \"foo\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["The result:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Traceback (most recent call last):\n  File \"./passpersist.py\", line 12, in &lt;module&gt;\n    print \"foo\"\nValueError: I/O operation on closed file\n</code>\n</pre>\n", "senID": 3}, {"text": ["I believe the problem is that it inherits from the file class, which actually isn't necessary.", "According to the docs for sys.stdout:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["so changing"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class flushfile(file):\n</code>\n</pre>\n", "senID": 6}, {"text": ["to"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n class flushfile(object):\n</code>\n</pre>\n", "senID": 8}, {"text": ["makes it work just fine."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["Using the -u command-line switch works, but it is a little bit clumsy in my opinion.", "I usually use a custom stdout, like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "-u", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class flushfile(file):\n  def __init__(self, f):\n    self.f = f\n  def write(self, x)\n    self.f.write(x)\n    self.f.flush()\n\nimport sys\nsys.stdout = flushfile(sys.stdout)\n</code>\n</pre>\n", "senID": 1}, {"text": ["... Now all your print calls (which use sys.stdout implicitly), will be automatically flushed."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "print", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sys.stdout", "childNum": 0, "tag": "code", "childList": []}, {"text": "flush", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Why not try using an unbuffered file?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["f = open('xyz.log', 'a', 0)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["OR"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["sys.stdout = open('out.log', 'a' 0)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Loved Dan's solution!", "For python3 do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import io,sys\nclass flushfile(io.TextIOWrapper):\n    def __init__(self, f):\n        self.f = f\n    def write(self, x):\n        self.f.write(x)\n        self.f.flush()\nsys.stdout = flushfile(sys.stdout)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is my version, which provides writelines() and fileno(), too:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Flushfile(object):\n    def __init__(self, fd):\n        self.fd = fd\n\n    def write(self, x):\n        ret=self.fd.write(x)\n        self.fd.flush()\n        return ret\n\n    def writelines(self, lines):\n        ret=self.writelines(line)\n        self.fd.flush()\n        return ret\n\n    def flush(self):\n        return self.fd.flush\n\n    def close(self):\n        return self.fd.close()\n\n    def fileno(self):\n        return self.fd.fileno()\n</code>\n</pre>\n", "senID": 1}]]