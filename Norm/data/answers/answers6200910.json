[[{"text": ["Last time I checked it, the scipy __init__ method executes a"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from numpy import *\n</code>\n</pre>\n", "senID": 1}, {"text": ["so that the whole numpy namespace is included into scipy when the scipy module is imported."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The log10 behaviour you are describing is interesting, because both versions are coming from numpy.", "One is a ufunc, the other is a numpy.lib function.", "Why scipy is preferring the library function over the ufunc, I don't know off the top of my head."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "both", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "ufunc", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "numpy.lib", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "ufunc", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["EDIT: In fact, I can answer the log10 question.", "Looking in the scipy __init__ method I see this:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n # Import numpy symbols to scipy name space\nimport numpy as _num\nfrom numpy import oldnumeric\nfrom numpy import *\nfrom numpy.random import rand, randn\nfrom numpy.fft import fft, ifft\nfrom numpy.lib.scimath import *\n</code>\n</pre>\n", "senID": 5}, {"text": ["The log10 function you get in scipy comes from numpy.lib.scimath.", "Looking at that code, it says:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n \"\"\"\nWrapper functions to more user-friendly calling of certain math functions\nwhose output data-type is different than the input data-type in certain\ndomains of the input.\n\nFor example, for functions like log() with branch cuts, the versions in this\nmodule provide the mathematically valid answers in the complex plane:\n\n&gt;&gt;&gt; import math\n&gt;&gt;&gt; from numpy.lib import scimath\n&gt;&gt;&gt; scimath.log(-math.exp(1)) == (1+1j*math.pi)\nTrue\n\nSimilarly, sqrt(), other base logarithms, power() and trig functions are\ncorrectly handled.  See their respective docstrings for specific examples.\n\"\"\"\n</code>\n</pre>\n", "senID": 7}, {"text": ["It seems that module overlays the base numpy ufuncs for sqrt, log, log2, logn, log10, power, arccos, arcsin, and arctanh.", "That explains the behaviour you are seeing.", "The underlying design reason why it is done like that is probably buried in a mailing list post somewhere."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["From the SciPy Reference Guide:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The intention is for users not to have to know the distinction between the scipy and numpy namespaces, though apparently you've found an exception. "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "scipy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "numpy", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["There is a short comment at the end of the introduction to SciPy documentation:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "introduction to SciPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/scipy/reference/tutorial/general.html"}]}, {"text": ["I think this will allow someone with enough knowledge of all the packages involved to pick apart exactly what the differences are between some scipy and numpy functions (it didn't help me with the log10 question at all).", "I definitely don't have that knowledge but source does indicate that scipy.linalg.solve and numpy.linalg.solve interact with lapack in different ways;"], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "some", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "source", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "scipy.linalg.solve", "childNum": 0, "tag": "code", "childList": []}, {"text": "numpy.linalg.solve", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n Python 2.4.3 (#1, May  5 2011, 18:44:23) \n[GCC 4.1.2 20080704 (Red Hat 4.1.2-50)] on linux2\n&gt;&gt;&gt; import scipy\n&gt;&gt;&gt; import scipy.linalg\n&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; scipy.source(scipy.linalg.solve)\nIn file: /usr/lib64/python2.4/site-packages/scipy/linalg/basic.py\n\ndef solve(a, b, sym_pos=0, lower=0, overwrite_a=0, overwrite_b=0,\n          debug = 0):\n    \"\"\" solve(a, b, sym_pos=0, lower=0, overwrite_a=0, overwrite_b=0) -&gt; x\n\n    Solve a linear system of equations a * x = b for x.\n\n    Inputs:\n\n      a -- An N x N matrix.\n      b -- An N x nrhs matrix or N vector.\n      sym_pos -- Assume a is symmetric and positive definite.\n      lower -- Assume a is lower triangular, otherwise upper one.\n               Only used if sym_pos is true.\n      overwrite_y - Discard data in y, where y is a or b.\n\n    Outputs:\n\n      x -- The solution to the system a * x = b\n    \"\"\"\n    a1, b1 = map(asarray_chkfinite,(a,b))\n    if len(a1.shape) != 2 or a1.shape[0] != a1.shape[1]:\n        raise ValueError, 'expected square matrix'\n    if a1.shape[0] != b1.shape[0]:\n        raise ValueError, 'incompatible dimensions'\n    overwrite_a = overwrite_a or (a1 is not a and not hasattr(a,'__array__'))\n    overwrite_b = overwrite_b or (b1 is not b and not hasattr(b,'__array__'))\n    if debug:\n        print 'solve:overwrite_a=',overwrite_a\n        print 'solve:overwrite_b=',overwrite_b\n    if sym_pos:\n        posv, = get_lapack_funcs(('posv',),(a1,b1))\n        c,x,info = posv(a1,b1,\n                        lower = lower,\n                        overwrite_a=overwrite_a,\n                        overwrite_b=overwrite_b)\n    else:\n        gesv, = get_lapack_funcs(('gesv',),(a1,b1))\n        lu,piv,x,info = gesv(a1,b1,\n                             overwrite_a=overwrite_a,\n                             overwrite_b=overwrite_b)\n\n    if info==0:\n        return x\n    if info&gt;0:\n        raise LinAlgError, \"singular matrix\"\n    raise ValueError,\\\n          'illegal value in %-th argument of internal gesv|posv'%(-info)\n\n&gt;&gt;&gt; scipy.source(numpy.linalg.solve)\nIn file: /usr/lib64/python2.4/site-packages/numpy/linalg/linalg.py\n\ndef solve(a, b):\n    \"\"\"\n    Solve the equation ``a x = b`` for ``x``.\n\n    Parameters\n    ----------\n    a : array_like, shape (M, M)\n        Input equation coefficients.\n    b : array_like, shape (M,)\n        Equation target values.\n\n    Returns\n    -------\n    x : array, shape (M,)\n\n    Raises\n    ------\n    LinAlgError\n        If `a` is singular or not square.\n\n    Examples\n    --------\n    Solve the system of equations ``3 * x0 + x1 = 9`` and ``x0 + 2 * x1 = 8``:\n\n    &gt;&gt;&gt; a = np.array([[3,1], [1,2]])\n    &gt;&gt;&gt; b = np.array([9,8])\n    &gt;&gt;&gt; x = np.linalg.solve(a, b)\n    &gt;&gt;&gt; x\n    array([ 2.,  3.])\n\n    Check that the solution is correct:\n\n    &gt;&gt;&gt; (np.dot(a, x) == b).all()\n    True\n\n    \"\"\"\n    a, _ = _makearray(a)\n    b, wrap = _makearray(b)\n    one_eq = len(b.shape) == 1\n    if one_eq:\n        b = b[:, newaxis]\n    _assertRank2(a, b)\n    _assertSquareness(a)\n    n_eq = a.shape[0]\n    n_rhs = b.shape[1]\n    if n_eq != b.shape[0]:\n        raise LinAlgError, 'Incompatible dimensions'\n    t, result_t = _commonType(a, b)\n#    lapack_routine = _findLapackRoutine('gesv', t)\n    if isComplexType(t):\n        lapack_routine = lapack_lite.zgesv\n    else:\n        lapack_routine = lapack_lite.dgesv\n    a, b = _fastCopyAndTranspose(t, a, b)\n    pivots = zeros(n_eq, fortran_int)\n    results = lapack_routine(n_eq, n_rhs, a, n_eq, pivots, b, n_eq, 0)\n    if results['info'] &gt; 0:\n        raise LinAlgError, 'Singular matrix'\n    if one_eq:\n        return wrap(b.ravel().astype(result_t))\n    else:\n        return wrap(b.transpose().astype(result_t))\n</code>\n</pre>\n", "senID": 2}, {"text": ["This is also my first post so if I should change something here please let me know."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["From Wikipedia ( http://en.wikipedia.org/wiki/NumPy#History ):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://en.wikipedia.org/wiki/NumPy#History", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/NumPy#History"}]}, {"text": ["scipy depends on numpy and imports many numpy functions into its namespace for convenience."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "scipy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "numpy", "childNum": 0, "tag": "code", "childList": []}, {"text": "numpy", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Regarding the linalg package - the scipy functions will call lapack and blas, which are available in highly optimised versions on many platforms and offer very good performance, particularly for operations on reasonably large dense matrices.", "On the other hand, they are not easy libraries to compile, requiring a fortran compiler and many platform specific tweaks to get full performance.", "Therefore, numpy provides simple implementations of many common linear algebra functions which are often good enough for many purposes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]