[[{"text": ["You want split, from the shlex module."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import shlex\n&gt;&gt;&gt; shlex.split('this is \"a test\"')\n['this', 'is', 'a test']\n</code>\n</pre>\n", "senID": 1}, {"text": ["This should do exactly what you want."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Have a look at the shlex module, particularly shlex.split."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "shlex", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "shlex.split", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I see regex approaches here that look complex and/or wrong.", "This surprises me, because regex syntax can easily describe \"whitespace or thing-surrounded-by-quotes\", and most regex engines (including Python's) can split on a regex.", "So if you're going to use regexes, why not just say exactly what you mean?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n test = 'this is \"a test\"'  # or \"this is 'a test'\"\n# pieces = [p for p in re.split(\"( |[\\\\\\\"'].*[\\\\\\\"'])\", test) if p.strip()]\n# From comments, use this:\npieces = [p for p in re.split(\"( |\\\\\\\".*?\\\\\\\"|'.*?')\", test) if p.strip()]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Explanation:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [\\\\\\\"'] = double-quote or single-quote\n.* = anything\n( |X) = space or X\n.strip() = remove space and empty-string separators\n</code>\n</pre>\n", "senID": 3}, {"text": ["shlex probably provides more features, though."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Since this question is tagged with regex, I decided to try a regex approach.", "I first replace all the spaces in the quotes parts with \\x00, then split by spaces, then replace the \\x00 back to spaces in each part."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Both versions do the same thing, but splitter is a bit more readable then splitter2."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ns = 'this is \"a test\" some text \"another test\"'\n\ndef splitter(s):\n    def replacer(m):\n        return m.group(0).replace(\" \", \"\\x00\")\n    parts = re.sub('\".+?\"', replacer, s).split()\n    parts = [p.replace(\"\\x00\", \" \") for p in parts]\n    return parts\n\ndef splitter2(s):\n    return [p.replace(\"\\x00\", \" \") for p in re.sub('\".+?\"', lambda m: m.group(0).replace(\" \", \"\\x00\"), s).split()]\n\nprint splitter2(s)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Depending on your use case, you may also want to check out the csv module:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import csv\nlines = ['this is \"a string\"', 'and more \"stuff\"']\nfor row in csv.reader(lines, delimiter=\" \"):\n    print row\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output: "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ['this', 'is', 'a string']\n['and', 'more', 'stuff']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def adamsplit(s):\n    result = []\n    inquotes = False\n    for substring in s.split('\"'):\n      if not inquotes:\n        result.append(substring.split())\n      else:\n        result.append(substring)\n      inquotes = not inquotes\n    return result\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you don't care about sub strings than a simple"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 'a short sized string with spaces '.split()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Performance:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = \" ('a short sized string with spaces '*100).split() \"\n&gt;&gt;&gt; t = timeit.Timer(stmt=s)\n&gt;&gt;&gt; print \"%.2f usec/pass\" % (1000000 * t.timeit(number=100000)/100000)\n171.39 usec/pass\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or string module"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from string import split as stringsplit; \n&gt;&gt;&gt; stringsplit('a short sized string with spaces '*100)\n</code>\n</pre>\n", "senID": 5}, {"text": ["Performance: String module seems to perform better than string methods"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = \"stringsplit('a short sized string with spaces '*100)\"\n&gt;&gt;&gt; t = timeit.Timer(s, \"from string import split as stringsplit\")\n&gt;&gt;&gt; print \"%.2f usec/pass\" % (1000000 * t.timeit(number=100000)/100000)\n154.88 usec/pass\n</code>\n</pre>\n", "senID": 7}, {"text": ["Or you can use RE engine"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from re import split as resplit\n&gt;&gt;&gt; regex = '\\s+'\n&gt;&gt;&gt; medstring = 'a short sized string with spaces '*100\n&gt;&gt;&gt; resplit(regex, medstring)\n</code>\n</pre>\n", "senID": 9}, {"text": ["Performance"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = \"resplit(regex, medstring)\"\n&gt;&gt;&gt; t = timeit.Timer(s, \"from re import split as resplit; regex='\\s+'; medstring='a short sized string with spaces '*100\")\n&gt;&gt;&gt; print \"%.2f usec/pass\" % (1000000 * t.timeit(number=100000)/100000)\n540.21 usec/pass\n</code>\n</pre>\n", "senID": 11}, {"text": ["For very long strings you should not load the entire string into memory and instead either split the lines or use an iterative loop"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["Hmm, can't seem to find the \"Reply\" button... anyway, this answer is based on the approach by Kate, but correctly splits strings with substrings containing escaped quotes and also removes the start and end quotes of the substrings:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [i.strip('\"').strip(\"'\") for i in re.split(r'(\\s+|(?&lt;!\\\\)\".*?(?&lt;!\\\\)\"|(?&lt;!\\\\)\\'.*?(?&lt;!\\\\)\\')', string) if i.strip()]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This works on strings like 'This is \" a \\\\\\\"test\\\\\\\"\\\\\\'s substring\"' (the insane markup is unfortunately necessary to keep Python from removing the escapes)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "'This is \" a \\\\\\\"test\\\\\\\"\\\\\\'s substring\"'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If the resulting escapes in the strings in the returned list are not wanted, you can use this slightly altered version of the function:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n [i.strip('\"').strip(\"'\").decode('string_escape') for i in re.split(r'(\\s+|(?&lt;!\\\\)\".*?(?&lt;!\\\\)\"|(?&lt;!\\\\)\\'.*?(?&lt;!\\\\)\\')', string) if i.strip()]\n</code>\n</pre>\n", "senID": 4}]]