[[{"text": ["Use the reload builtin:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://docs.python.org/library/functions.html#reload"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/functions.html#reload", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#reload"}]}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # Make a simple function that prints \"version 1\"\nshell1$ echo 'def x(): print \"version 1\"' &gt; mymodule.py\n\n# Run the module\nshell2$ python\n&gt;&gt;&gt; import mymodule\n&gt;&gt;&gt; mymodule.x()\nversion 1\n\n# Change mymodule to print \"version 2\" (without exiting the python REPL)\nshell2$ echo 'def x(): print \"version 2\"' &gt; mymodule.py\n\n# Back in that same python session\n&gt;&gt;&gt; reload(mymodule)\n&lt;module 'mymodule' from 'mymodule.pyc'&gt;\n&gt;&gt;&gt; mymodule.x()\nversion 2\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Yes, just saying \u2018import\u2019 again gives you the existing copy of the module from sys.modules."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can say \u2018reload(module)\u2019 to update sys.modules and get a new copy of that single module, but if any other modules have a reference to the original module or any object from the original module, they will keep their old references and Very Confusing Things will happen."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "or any object from the original module", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["So if you've got a module \u2018a\u2019, which depends on module \u2018b\u2019, and b changes, you have to \u2018reload b\u2019 followed by \u2018reload a\u2019.", "If you've got two modules which depend on each other, which is extremely common when those modules are part of the same package, you can't reload them both: if you reload \u2018p.a\u2019 it'll get a reference to the old \u2018p.b\u2019, and vice versa.", "The only way to do it is to unload them both at once by deleting their items from sys.modules, before importing them again.", "This is icky and has some practical pitfalls to do with modules entries being None as a failed-relative-import marker."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["And if you've got a module which passes references to its objects to system modules\u2009\u2014\u2009for example it registers a codec, or adds a warnings handler\u2009\u2014\u2009you're stuck; you can't reload the system module without confusing the rest of the Python environment."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["In summary: for all but the simplest case of one self-contained module being loaded by one standalone script, reload() is very tricky to get right; if, as you imply, you are using a \u2018package\u2019, you will probably be better off continuing to cycle the interpreter."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["See here for a good explanation of how your dependent modules won't be reloaded and the effects that can have:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://pyunit.sourceforge.net/notes/reloading.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://pyunit.sourceforge.net/notes/reloading.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyunit.sourceforge.net/notes/reloading.html"}]}, {"text": ["The way pyunit solved it was to track dependent modules by overriding __import__ then to delete each of them from sys.modules and re-import.", "They probably could've just reload'ed them, though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Basically reload as in allyourcode's asnwer.", "But it won't change underlying the code of already instantiated object or referenced functions.", "Extending from his answer:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "reload", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#reload"}]}, {"code": "<pre>\n<code>\n #Make a simple function that prints \"version 1\"\nshell1$ echo 'def x(): print \"version 1\"' &gt; mymodule.py\n\n# Run the module\nshell2$ python\n&gt;&gt;&gt; import mymodule\n&gt;&gt;&gt; mymodule.x()\nversion 1\n&gt;&gt;&gt; x = mymodule.x\n&gt;&gt;&gt; x()\nversion 1\n&gt;&gt;&gt; x is mymodule.x\nTrue\n\n\n# Change mymodule to print \"version 2\" (without exiting the python REPL)\nshell2$ echo 'def x(): print \"version 2\"' &gt; mymodule.py\n\n# Back in that same python session\n&gt;&gt;&gt; reload(mymodule)\n&lt;module 'mymodule' from 'mymodule.pyc'&gt;\n&gt;&gt;&gt; mymodule.x()\nversion 2\n&gt;&gt;&gt; x()\nversion 1\n&gt;&gt;&gt; x is mymodule.x\nFalse\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Not sure if this does all expected things, but you can do just like that:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; del mymodule\n&gt;&gt;&gt; import mymodule\n</code>\n</pre>\n", "senID": 1}]]