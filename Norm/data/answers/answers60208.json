[[{"text": ["You could use a dictionary:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f(x):\n    return {\n        'a': 1,\n        'b': 2,\n    }[x]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you'd like defaults you could use the dictionary \"get\" method:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f(x):\n    return {\n        'a': 1,\n        'b': 2,\n        }.get(x, 9)    # 9 is default if x not found\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I've always liked doing it this way"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n result = {\n  'a': lambda x: x * 5,\n  'b': lambda x: x + 7,\n  'c': lambda x: x - 2\n}[value](x)\n</code>\n</pre>\n", "senID": 1}, {"text": ["From here"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "From here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://simonwillison.net/2004/May/7/switch/"}]}], [{"text": ["Python Cookbook has several recipes (implementations and corresponding discussions) for switch statement.", "Please visit the following links:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python Cookbook", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.activestate.com/ASPN/Python/Cookbook/"}]}], [{"text": ["There's a pattern that I learned from Twisted Python code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class SMTP:\n    def lookupMethod(self, command):\n        return getattr(self, 'do_' + command.upper(), None)\n    def do_HELO(self, rest):\n        return 'Howdy ' + rest\n    def do_QUIT(self, rest):\n        return 'Bye'\n\nSMTP().lookupMethod('HELO')('foo.bar.com') # =&gt; 'Howdy foo.bar.com'\nSMTP().lookupMethod('QUIT')('') # =&gt; 'Bye'\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can use it any time you need to dispatch on a token and execute extended piece of code.", "In a state machine you would have state_ methods, and dispatch on self.state.", "This switch can be cleanly extended by inheriting from base class and defining your own do_ methods.", "Often times you won't even have do_ methods in the base class."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "state_", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "self.state", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "do_", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "do_", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Edit: how exactly is that used"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit: how exactly is that used", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["In case of SMTP you will receive HELO from the wire.", "The relevant code (from twisted/mail/smtp.py, modified for our case) looks like this"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "HELO", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "twisted/mail/smtp.py", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class SMTP:\n    # ...\n\n    def do_UNKNOWN(self, rest):\n        raise NotImplementedError, 'received unknown command'\n\n    def state_COMMAND(self, line):\n        line = line.strip()\n        parts = line.split(None, 1)\n        if parts:\n            method = self.lookupMethod(parts[0]) or self.do_UNKNOWN\n            if len(parts) == 2:\n                return method(parts[1])\n            else:\n                return method('')\n        else:\n            raise SyntaxError, 'bad syntax'\n\nSMTP().state_COMMAND('   HELO   foo.bar.com  ') # =&gt; Howdy foo.bar.com\n</code>\n</pre>\n", "senID": 5}, {"text": ["You'll receive '  HELO   foo.bar.com ' (or you might get 'QUIT' or 'RCPT TO: foo').", "This is tokenized into parts as ['HELO', 'foo.bar.com'].", "The actual method lookup name is taken from parts[0]."], "childNum": 6, "tag": "p", "senID": 6, "childList": [{"text": "'  HELO   foo.bar.com '", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'QUIT'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "'RCPT TO: foo'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "parts", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "['HELO', 'foo.bar.com']", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "parts[0]", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["(The original method is also called state_COMMAND, because it uses the same pattern to implement a state machine, i.e.", "getattr(self, 'state_' + self.mode))"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "state_COMMAND", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "getattr(self, 'state_' + self.mode)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["In addition to the dictionary methods (which I really like, BTW), you can also use if-elif-else to obtain the switch/case/default functionality:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if x=='a':\n    # Do the thing\nelif x=='b':\n    # Do the other thing\nelse:\n    # Do the default\n</code>\n</pre>\n", "senID": 1}, {"text": ["This of course is not identical to switch/case - you cannot have fall-through as easily as leaving off the break; statement, but you can have a more complicated test.", "It's formatting is nicer than a series of nested ifs, even though functionally that's what it is closer to."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Let's say you don't want to just return a value, but want to use methods that change something on an object.", "Using the approach stated here would be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n result = {\n  'a': obj.increment(x),\n  'b': obj.decrement(x)\n}.get(value, obj.default(x))\n</code>\n</pre>\n", "senID": 1}, {"text": ["What happens here is that python evaluates all methods in the dictionary.", "So even if your value is 'a', the object will get incremented and decremented by x."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "and", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["Solution:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n func, args = {\n  'a' : (obj.increment, (x,)),\n  'b' : (obj.decrement, (x,)),\n}.get(value, (obj.default, (x,)))\n\nresult = func(*args)\n</code>\n</pre>\n", "senID": 4}, {"text": ["So you get a list containing a function and its arguments.", "This way, only the function pointer and the argument list get returned, not evaluated.", "'result' then evaluates the returned function call."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["expanding on the \"dict as switch\" idea.", "if you want to use a default value for your switch:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f(x):\n    try:\n        return {\n            'a': 1,\n            'b': 2,\n        }[x]\n    except KeyError:\n        return 'default'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A true switch/case in Python is going to be more difficult than a dictionary method or if/elif/else methods because the simple versions do not support fall through.", "Another downfall of the if/elif/else method is the need for repeated comparisons.", "The C implementation of a switch/case has a performance benefit over if/else if/else in that only a single comparison is needed.", "The result of that comparison is used as an offset into a jump table (in the underlying asm generated).", "To mimicking the true functionality in Python would be a pain.", "Does any one have an implementation that would allow for fall through while only using a single comparison?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you are really just returning a predetermined, fixed value, you could create a dictionary with all possible input indexes as the keys, along with their corresponding values.", "Also, you might not really want a function to do this - unless you're computing the return value somehow."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Oh, and if you feel like doing something switch-like, see here."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.mustap.com/pythonzone_post_224_python-switch-statement"}]}], [{"text": ["I would just use if/elif/else statements.", "I think that it's good enough to replace the switch statement."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I have made a (relatively) flexible and re-usable solution for this.", "It can be found at GitHub as this gist.", "If the result of the switch function is callable, it is automatically called."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this gist", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://gist.github.com/raw/23036/fd1fb6f05d4c654ff136a9f2545b9f83e9273fcc/switch.py"}]}], [{"text": ["The solutions I use: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A combination of 2 of the solutions posted here, which is relatively easy to read and supports defaults."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["result = {\n  'a': lambda x: x * 5,\n  'b': lambda x: x + 7,\n  'c': lambda x: x - 2\n}.get(whatToUse, lambda x: x - 22)(value)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "result = {\n  'a': lambda x: x * 5,\n  'b': lambda x: x + 7,\n  'c': lambda x: x - 2\n}.get(whatToUse, lambda x: x - 22)(value)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["where\n.get('c', lambda x: x - 22)(23)\n-> looks up \"lambda x: x - 2\" in the dict and uses it with x=23 "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": [".get('xxx', lambda x: x - 22)(44)\n-> doesn\u00b4t find it in the dict and uses the default \"lambda x: x - 22\" with x=44"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If you're searching extra-statement, as \"switch\", I built a python module that extends Python.It's called ESPY as Enhanced Structure for Python and it's available for both Python 2.x and Python 3.x."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, in this case, a switch statement could be performed by the following code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n macro switch(arg1):\n    while True:\n        cont=False\n        val=%arg1%\n        socket case(arg2):\n            if val==%arg2% or cont:\n                cont=True\n                socket\n        socket else:\n            socket\n        break\n</code>\n</pre>\n", "senID": 2}, {"text": ["that can be used like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n a=3\nswitch(a):\n    case(0):\n        print(\"Zero\")\n    case(1):\n        print(\"Smaller than 2\"):\n        break\n    else:\n        print (\"greater than 1\")\n</code>\n</pre>\n", "senID": 4}, {"text": ["so espy translate it in Python as:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n a=3\nwhile True:\n    cont=False\n    if a==0 or cont:\n        cont=True\n        print (\"Zero\")\n    if a==1 or cont:\n        cont=True\n        print (\"Smaller than 2\")\n        break\n    print (\"greater than 1\")\n    break\n</code>\n</pre>\n", "senID": 6}, {"text": ["You can find and test ESPY in this page:\nelp.chronocv.fr/?lng=en"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "elp.chronocv.fr/?lng=en", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://elp.chronocv.fr/?lng=en"}]}, {"text": ["Eric LE PAPE"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"code": "<pre>\n<code>\n class switch( object ):\n    value = None\n    def __new__( class_, value ):\n        class_.value = value\n        return True\n\ndef case( *args ):\n    return any( ( arg == switch.value for arg in args ) )\n</code>\n</pre>\n", "senID": 0}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n while switch( n ):\n    if case( 0 ):\n        print \"You typed zero.\"\n        break\n    if case( 1, 4, 9 ):\n        print \"n is a perfect square.\"\n        break\n    if case( 2 ):\n        print \"n is an even number.\"\n    if case( 2, 3, 5, 7 ):\n        print \"n is a prime number.\"\n        break\n    if case( 6, 8 ):\n        print \"n is an even number.\"\n        break\n    print \"Only single-digit numbers are allowed.\"\n    break\n</code>\n</pre>\n", "senID": 2}, {"text": ["Tests:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n n = 2\n#Result:\n#n is an even number.\n#n is a prime number.\nn = 11\n#Result:\n#Only single-digit numbers are allowed.\n</code>\n</pre>\n", "senID": 4}], [{"text": ["My favorite one is a really nice recipe.", "You'll really like it.", "It's the closest one I've seen to actual switch case statements, especially in features."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "recipe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/410692/"}]}, {"text": ["Here's an example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # The following example is pretty much the exact use-case of a dictionary,\n# but is included for its simplicity. Note that you can include statements\n# in each suite.\nv = 'ten'\nfor case in switch(v):\n    if case('one'):\n        print 1\n        break\n    if case('two'):\n        print 2\n        break\n    if case('ten'):\n        print 10\n        break\n    if case('eleven'):\n        print 11\n        break\n    if case(): # default, could also just omit condition or 'if True'\n        print \"something else!\"\n        # No need to break here, it'll stop anyway\n\n# break is used here to look as much like the real thing as possible, but\n# elif is generally just as good and more concise.\n\n# Empty suites are considered syntax errors, so intentional fall-throughs\n# should contain 'pass'\nc = 'z'\nfor case in switch(c):\n    if case('a'): pass # only necessary if the rest of the suite is empty\n    if case('b'): pass\n    # ...\n    if case('y'): pass\n    if case('z'):\n        print \"c is lowercase!\"\n        break\n    if case('A'): pass\n    # ...\n    if case('Z'):\n        print \"c is uppercase!\"\n        break\n    if case(): # default\n        print \"I dunno what c was!\"\n\n# As suggested by Pierre Quentel, you can even expand upon the\n# functionality of the classic 'case' statement by matching multiple\n# cases in a single shot. This greatly benefits operations such as the\n# uppercase/lowercase example above:\nimport string\nc = 'A'\nfor case in switch(c):\n    if case(*string.lowercase): # note the * for unpacking as arguments\n        print \"c is lowercase!\"\n        break\n    if case(*string.uppercase):\n        print \"c is uppercase!\"\n        break\n    if case('!', '?', '.'): # normal argument passing style also applies\n        print \"c is a sentence terminator!\"\n        break\n    if case(): # default\n        print \"I dunno what c was!\"\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The switch statement is just syntactical sugar which is probably why Python doesn't have it.", "You can use if else statements for this functionality easily."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Like Matthew Schinckel said, you can use if and elif and else."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It is also a simple matter to have \"fall-through\" capabilities like most switch statements.", "All you have to do is not  use elif."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if x == 1:\n    # 1\nif x == 2:\n    # fall-through\nelif x == 3:\n    # not fall-through\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n def f(x):    \n  return {'a': 1,'b': 2,}.get(x) or \"Default\"\n</code>\n</pre>\n", "senID": 0}]]