[[{"text": ["I believe that a memory mapped file will be the fastest solution.", "I tried four functions: the function posted by the OP (opcount); a simple iteration over the lines in the file (simplecount); readline with a memory-mapped filed (mmap) (mapcount); and the buffer read solution offered by Mykola Kharechko (bufcount)."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "opcount", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "simplecount", "childNum": 0, "tag": "code", "childList": []}, {"text": "mapcount", "childNum": 0, "tag": "code", "childList": []}, {"text": "bufcount", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I ran each function five times, and calculated the average run-time for a 1.2 million-line text file."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Windows XP, Python 2.5, 2GB RAM, 2 GHz AMD processor"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here are my results:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n mapcount : 0.465599966049\nsimplecount : 0.756399965286\nbufcount : 0.546800041199\nopcount : 0.718600034714\n</code>\n</pre>\n", "senID": 4}, {"text": ["Edit: numbers for Python 2.6:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n mapcount : 0.471799945831\nsimplecount : 0.634400033951\nbufcount : 0.468800067902\nopcount : 0.602999973297\n</code>\n</pre>\n", "senID": 6}, {"text": ["So the buffer read strategy seems to be the fastest for Windows/Python 2.6"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Here is the code:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, \"r+\")\n    buf = mmap.mmap(f.fileno(), 0)\n    lines = 0\n    readline = buf.readline\n    while readline():\n        lines += 1\n    return lines\n\ndef simplecount(filename):\n    lines = 0\n    for line in open(filename):\n        lines += 1\n    return lines\n\ndef bufcount(filename):\n    f = open(filename)                  \n    lines = 0\n    buf_size = 1024 * 1024\n    read_f = f.read # loop optimization\n\n    buf = read_f(buf_size)\n    while buf:\n        lines += buf.count('\\n')\n        buf = read_f(buf_size)\n\n    return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\n    return i + 1\n\n\ncounts = defaultdict(list)\n\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\n        assert func(\"big_file.txt\") == 1209138\n        counts[func].append(time.time() - start_time)\n\nfor key, vals in counts.items():\n    print key.__name__, \":\", sum(vals) / float(len(vals))\n</code>\n</pre>\n", "senID": 9}], [{"text": ["You can't get any better than that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["After all, any solution will have to read the entire file, figure out how many \\n you have, and return that result."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "\\n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Do you have a better way of doing that without reading the entire file?", "Not sure...", "The best solution will always be I/O-bound, best you can do is make sure you don't use unnecessary memory, but it looks like you have that covered."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could execute a subprocess and run wc -l filename"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "wc -l filename", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import subprocess\n\ndef file_len(fname):\n    p = subprocess.Popen(['wc', '-l', fname], stdout=subprocess.PIPE, \n                                              stderr=subprocess.PIPE)\n    result, err = p.communicate()\n    if p.returncode != 0:\n        raise IOError(err)\n    return int(result.strip().split()[0])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["One line, probably pretty fast:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n num_lines = sum(1 for line in open('myfile.txt'))\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def file_len(full_path):\n  \"\"\" Count number of lines in a file.\"\"\"\n  f = open(full_path)\n  nr_of_lines = sum(1 for line in f)\n  f.close()\n  return nr_of_lines\n</code>\n</pre>\n", "senID": 0}], [{"text": ["As for me this variant will be the fastest:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\ndef main():\n    f = open('filename')                  \n    lines = 0\n    buf_size = 1024 * 1024\n    read_f = f.read # loop optimization\n\n    buf = read_f(buf_size)\n    while buf:\n        lines += buf.count('\\n')\n        buf = read_f(buf_size)\n\n    print lines\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n", "senID": 1}, {"text": ["reasons: buffering faster than reading line by line and string.count is also very fast"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "string.count", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["What about this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def file_len(fname):\n  counts = itertools.count()\n  with open(fname) as f: \n    for _ in f: counts.next()\n  return counts.next()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Just to complete the above methods I tried a variant with the fileinput module:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import fileinput as fi   \ndef filecount(fname):\n        for line in fi.input(fname):\n            pass\n        return fi.lineno()\n</code>\n</pre>\n", "senID": 1}, {"text": ["And passed a 60mil lines file to all the above stated methods:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n mapcount : 6.1331050396\nsimplecount : 4.588793993\nopcount : 4.42918205261\nfilecount : 43.2780818939\nbufcount : 0.170812129974\n</code>\n</pre>\n", "senID": 3}, {"text": ["It's a little surprise to me that fileinput is that bad and scales far worse than all the other methods..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Why not read the first 100 and the last 100 lines and estimate the average line length, then divide the total file size through that numbers?", "If you don't need a exact value this could work."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["what about this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.stdin=open('fname','r')\n&gt;&gt;&gt; data=sys.stdin.readlines()\n&gt;&gt;&gt; print \"counted\",len(data),\"lines\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Why wouldn't the following work?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\n\n# input comes from STDIN\nfile = sys.stdin\ndata = file.readlines()\n\n# get total number of lines in file\nlines = len(data)\n\nprint lines\n</code>\n</pre>\n", "senID": 1}, {"text": ["In this case, the len function uses the input lines as a means of determining the length."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["count = max(enumerate(open(filename)))[0]"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "count = max(enumerate(open(filename)))[0]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["How about this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import fileinput\nimport sys\n\ncounter=0\nfor line in fileinput.input([sys.argv[1]]):\n    counter+=1\n\nfileinput.close()\nprint counter\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is a python function to use mpi (pypar) to distribute the line counting across machines/cores.", "My test improves counting a 20mil line file from 26 seconds to 7 seconds using an 8 core windows 64 server."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import pypar, os, logging, sys\n\ndef getFileLineCount( file1 ):\n    m1 = open(file1, \"r\")\n\n    #work out file size\n    #divide up to farm out line counting\n\n    fSize = os.stat(file1).st_size \n    chunk = (fSize / pypar.size()) + 1\n\n    lines = 0\n\n    #first get max width of each field and the names\n    seekStart = chunk * (pypar.rank())\n    seekEnd = chunk * (pypar.rank()+1)\n    if seekEnd &gt; fSize:\n        seekEnd = fSize\n\n    #find where to start\n    if pypar.rank() &gt; 0:\n        m1.seek( seekStart )\n        #read next line\n        l1 = m1.readline()\n        seekStart = m1.tell()\n\n    #tell previous rank my seek start to make their seek end\n    if pypar.rank() &gt; 0:\n        pypar.send( seekStart, pypar.rank()-1 )\n    if pypar.rank() &lt; pypar.size()-1:\n        seekEnd = pypar.receive( pypar.rank()+1 )\n\n    m1.seek( seekStart )    \n    l1 = m1.readline()\n    while len(l1) &gt; 0:\n        lines += 1\n        l1 = m1.readline()\n        if m1.tell() &gt; seekEnd or len(l1) == 0:\n            break\n\n    if pypar.rank() == 0:\n        for p in range(1,pypar.size()):\n            lines += pypar.receive( p )\n\n        for p in range(1,pypar.size()):\n            pypar.send( lines, p )\n    else:\n        pypar.send( lines,0 )\n        lines = pypar.receive(0)\n\n    m1.close()\n    return lines\n</code>\n</pre>\n", "senID": 1}], [{"text": ["the result of opening a file is an iterator, which can be converted to a sequence, which has a length:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n with open(filename) as f:\n   return len(list(f))\n</code>\n</pre>\n", "senID": 1}, {"text": ["this is more concise than your explicit loop, and avoids the enumerate."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "enumerate", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]