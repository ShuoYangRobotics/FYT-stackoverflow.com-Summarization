[[{"text": ["I'm not going to speak to why multiple tuple unpacking isn't part of Python, but I will point out that you're not matching your class to your data in your example."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You have the following code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n point = (1, 2)\nsize = (2, 3)\ncolor = 'red'\n\nclass Rect(object):\n    def __init__(self, x, y, width, height, color):\n        self.x = x\n        self.y = y\n        self.width = width\n        self.height = height\n        self.color = color\n</code>\n</pre>\n", "senID": 2}, {"text": ["but a better way to express your Rect object would be as follows:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Rect:\n    def __init__(self, point, size, color):\n        self.point = point\n        self.size = size\n        self.color = color\n\nr = Rect(point, size, color)\n</code>\n</pre>\n", "senID": 4}, {"text": ["In general, if your data is in tuples, have your constructor take tuples.", "If your data is in a dict, have your constructor take a dict.", "If your data is an object, have your constructor take an object, etc."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["In general, you want to work with the idioms of the language, rather than try to work around them."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["EDIT\nSeeing how popular this question is, I'll give you an decorator that allows you to call the constructor however you like."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n class Pack(object):\n\n    def __init__(self, *template):\n        self.template = template\n\n    def __call__(self, f):\n        def pack(*args):\n            args = list(args)\n            for i, tup in enumerate(self.template):\n                if type(tup) != tuple:\n                    continue\n                for j, typ in enumerate(tup):\n                    if type(args[i+j]) != typ:\n                        break\n                else:\n                    args[i:i+j+1] = [tuple(args[i:i+j+1])]\n            f(*args)\n        return pack    \n\n\nclass Rect:\n    @Pack(object, (int, int), (int, int), str)\n    def __init__(self, point, size, color):\n        self.point = point\n        self.size = size\n        self.color = color\n</code>\n</pre>\n", "senID": 8}, {"text": ["Now you can initialize your object any way you like."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n r1 = Rect(point, size, color)\nr2 = Rect((1,2), size, color)\nr3 = Rect(1, 2, size, color)\nr4 = Rect((1, 2), 2, 3, color)\nr5 = Rect(1, 2, 2, 3, color)\n</code>\n</pre>\n", "senID": 10}, {"text": ["While I wouldn't recommend using this in practice (it violates the principle that you should have only one way to do it), it does serve to demonstrate that there's usually a way to do anything in Python."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["As far as I know, it was a design choice, but there seems to be a logic behind it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["EDIT: the *args notation in a function call was designed so you could pass in a tuple of variables of an arbitrary length that could change between calls.", "In that case, having something like f(*a, *b, c) doesn't make sense as a call, as if a changes length all the elements of b get assigned to the wrong variables, and c isn't in the right place either."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "*args", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Keeping the language simple, powerful, and standardized is a good thing.", "Keeping it in sync with what actually goes on in processing the arguments is also a very good thing.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Think about how the language unpacks your function call.", "If multiple *arg are allowed in any order like Rect(*point, *size, color), note that all that matters to properly unpack is that point and size have a total of four elements.", "So point=(), size=(1,2,2,3), andcolor='red') would allow Rect(*point, *size, color) to work as a proper call.", "Basically, the language when it parses the *point and *size is treating it as one combined *arg tuple, so Rect(*(point + size), color=color) is more faithful representation.  "], "childNum": 8, "tag": "p", "senID": 3, "childList": [{"text": "*arg", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Rect(*point, *size, color)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "point=()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "size=(1,2,2,3)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "color='red')", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Rect(*point, *size, color)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "*arg", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "Rect(*(point + size), color=color)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["There never needs to be two tuples of arguments passed in the form  *args, you can always represent it as one.", "Since assignment of parameters is only dependent on the order in this combined *arg list, it makes sense to define it as such.  "], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "*args", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "*arg", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If you can make function calls like f(*a, *b), the language almost begs to allow you to define functions with multiple *args in the parameter list, and those couldn't be processed.", "E.g.,"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def f(*a, *b): \n     return (sum(a), 2*sum(b))\n</code>\n</pre>\n", "senID": 6}, {"text": ["How would f(1,2,3,4) be processed?"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "f(1,2,3,4)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I think this is why for syntactical concreteness, the language forces function calls and definitions to be in the following specific form; like f(a,b,x=1,y=2,*args,**kwargs) which is order dependent."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "f(a,b,x=1,y=2,*args,**kwargs)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Everything there has a specific meaning in a function definition and function call.", "a and b are parameters defined without default values, next x and y are parameters defined with default values (that could be skipped; so come after the no default parameters).", "Next, *args is populated as a tuple with all the args filled with the rest of the parameters from a function call that weren't keyword parameters.", "This comes after the others, as this could change length, and you don't want something that could change length between calls to affect assignment of variables.", "At the end **kwargs takes all the keyword arguments that weren't defined elsewhere.", "With these concrete definitions you never need to have multiple *args or **kwargs."], "childNum": 7, "tag": "p", "senID": 9, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "*args", "childNum": 0, "tag": "code", "pos": 5, "childList": []}, {"text": "*args", "childNum": 0, "tag": "code", "childList": []}, {"text": "**kwargs", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["*point says that you are passing in a whole sequence of items - something like all the elements in a list, but not as a list."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "*point", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In this case, you cannot limit how many elements are being passed in.", "Therefore, there is no way for the interpreter to know which elements of the sequence are part of *points and which are of *size"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "*points", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "*size", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For example, if you passed the following as input: 2, 5, 3, 4, 17, 87, 4, 0, can you tell me, which of those numbers are represented by *points and which by *size?", "This is the same problem that the interpreter would face as well"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "2, 5, 3, 4, 17, 87, 4, 0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "*points", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "*size", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Hope this helps"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Python is full of these subtle glitches.", "For example you can do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n first, second, last = (1, 2, 3)\n</code>\n</pre>\n", "senID": 1}, {"text": ["And you can't do:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n first, *others = (1, 2, 3)\n</code>\n</pre>\n", "senID": 3}, {"text": ["But in Python 3 you now can. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Your suggestion probably is going to be suggested in a PEP and integrated or rejected one day."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Well, in Python 2, you can say:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n point = 1, 2\nsize = 2, 3\ncolor = 'red'\n\nclass Rect(object):\n    def __init__(self, (x, y), (width, height), color):\n        pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you can say:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a_rect= Rect(point, size, color)\n</code>\n</pre>\n", "senID": 3}, {"text": ["taking care that the first two arguments are sequences of len == 2.", "NB: This capability has been removed from Python 3."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}]]