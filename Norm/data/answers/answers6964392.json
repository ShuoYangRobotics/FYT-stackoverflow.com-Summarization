[[{"text": ["Using GHC 7.0.3, gcc 4.4.6, Linux 2.6.29 on an x86_64 Core2 Duo (2.5GHz) machine, compiling using ghc -O2 -fllvm -fforce-recomp for Haskell and gcc -O3 -lm for C."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "GHC 7.0.3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "gcc 4.4.6", "childNum": 0, "tag": "code", "childList": []}, {"text": "Linux 2.6.29", "childNum": 0, "tag": "code", "childList": []}, {"text": "ghc -O2 -fllvm -fforce-recomp", "childNum": 0, "tag": "code", "childList": []}, {"text": "gcc -O3 -lm", "childNum": 0, "tag": "code", "childList": []}]}, {"tag": "ul", "num": 6, "lis": [{"text": "Your C routine runs in 8.4 seconds (faster than your run probably because of ", "tag": "none", "senID": 1}, {"text": "The Haskell solution runs in 36 seconds (due to the ", "tag": "none", "senID": 2}, {"text": "Your ", "tag": "none", "senID": 3}, {"text": "in ", "tag": "none", "senID": 4}, {"text": "You used ", "tag": "none", "senID": 5}, {"text": ["factorCount' is constantly applying two extra arguments that never change (candidate, sqrt).", "A worker/wrapper transformation gives us:"], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "factorCount'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "candidate", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sqrt", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}]}, {"text": ["That's right, 7.95 seconds.", "Consistently half a second faster than the C solution.", "Without the -fllvm flag I'm still getting 8.182 seconds, so the NCG backend is doing well in this case too."], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "7.95 seconds", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "half a second faster than the C solution", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "-fllvm", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "8.182 seconds", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Conclusion: Haskell is awesome."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Resulting Code"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Resulting Code", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre class=\"lang-hs prettyprint-override\">\n<code>\n factorCount number = factorCount' number isquare 1 0 - (fromEnum $ square == fromIntegral isquare)\n    where square = sqrt $ fromIntegral number\n          isquare = floor square\n\nfactorCount' :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int\nfactorCount' number sqrt candidate0 count0 = go candidate0 count0\n  where\n  go candidate count\n    | candidate &gt; sqrt = count\n    | number `rem` candidate == 0 = go (candidate + 1) (count + 2)\n    | otherwise = go (candidate + 1) count\n\nnextTriangle index triangle\n    | factorCount triangle &gt; 1000 = triangle\n    | otherwise = nextTriangle (index + 1) (triangle + index + 1)\n\nmain = print $ nextTriangle 1 1\n</code>\n</pre>\n", "senID": 10}, {"text": ["EDIT: So now that we've explored that, lets address the questions"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["In Haskell, using Integer is slower than Int but how much slower depends on the computations performed.", "Luckily (for 64 bit machines) Int is sufficient.", "For portability sake you should probably rewrite my code to use Int64 or Word64 (C isn't the only language with a long)."], "childNum": 6, "tag": "p", "senID": 12, "childList": [{"text": "Integer", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Int", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "Int64", "childNum": 0, "tag": "code", "childList": []}, {"text": "Word64", "childNum": 0, "tag": "code", "childList": []}, {"text": "long", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["That was what I answered above.", "The answer was 0) Use optimization via -O2 1) Specialization (avoid unneeded polymorphism) 2) rem not mod (a frequently forgotten optimization) and 3) worker/wrapper transformation (perhaps the most common optimization)."], "childNum": 3, "tag": "p", "senID": 13, "childList": [{"text": "-O2", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "rem", "childNum": 0, "tag": "code", "childList": []}, {"text": "mod", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Yes, that wasn't the issue.", "Good work and glad you considered this."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}], [{"text": ["There are some problems with the Erlang implementation.", "As baseline for the following, my measured execution time for your unmodified Erlang program was 47.6 seconds, compared to 12.7 seconds for the C code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The first thing you should do if you want to run computationally intensive Erlang code is to use native code.", "Compiling with \"erlc +native euler12\" got the time down to 41.3 seconds.", "This is however a much lower speedup (just 15%) than expected from native compilation on this kind of code, and the problem is your use of \"-compile(export_all)\".", "This is useful for experimentation, but the fact that all functions are potentially reachable from the outside causes the native compiler to be very conservative.", "(The normal BEAM emulator is not that much affected.", ") Replacing this declaration with \"-export([solve/0]).", "\" gives a much better speedup: 31.5 seconds (almost 35% from the baseline)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["But the code itself has a problem: for each iteration in the factorCount loop, you perform this test:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "each iteration", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n factorCount (_, Sqrt, Candidate, Count) when Candidate == Sqrt -&gt; Count + 1;\n</code>\n</pre>\n", "senID": 3}, {"text": ["The C code doesn't do this.", "In general, it can be tricky to make a fair comparison between different implementations of the same code, and in particular if the algorithm is numerical, because you need to be sure that they are actually doing the same thing.", "A slight rounding error in one implementation due to some typecast somewhere may cause it to do many more iterations than the other even though both eventually reach the same result."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["To eliminate this possible error source (and get rid of the extra test in each iteration), I rewrote the factorCount function as follows, closely modelled on the C code:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n factorCount (N) -&gt;\n    Sqrt = math:sqrt (N),\n    ISqrt = trunc(Sqrt),\n    if ISqrt == Sqrt -&gt; factorCount (N, ISqrt, 1, -1);\n       true          -&gt; factorCount (N, ISqrt, 1, 0)\n    end.\n\nfactorCount (_N, ISqrt, Candidate, Count) when Candidate &gt; ISqrt -&gt; Count;\nfactorCount ( N, ISqrt, Candidate, Count) -&gt;\n    case N rem Candidate of\n        0 -&gt; factorCount (N, ISqrt, Candidate + 1, Count + 2);\n        _ -&gt; factorCount (N, ISqrt, Candidate + 1, Count)\n    end.\n</code>\n</pre>\n", "senID": 6}, {"text": ["This rewrite, no \"export_all\", and native compilation, gave me the following run time:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n $ erlc +native euler12.erl\n$ time erl -noshell -s euler12 solve\n842161320\n\nreal    0m19.468s\nuser    0m19.450s\nsys 0m0.010s\n</code>\n</pre>\n", "senID": 8}, {"text": ["which is not too bad compared to the C code:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n $ time ./a.out \n842161320\n\nreal    0m12.755s\nuser    0m12.730s\nsys 0m0.020s\n</code>\n</pre>\n", "senID": 10}, {"text": ["considering that Erlang is not at all geared towards writing numerical code, being only 50% slower than C on a program like this is pretty good."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Finally, regarding your questions:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Question 1: Do erlang, python and haskell loose speed due to using arbitrary length integers or \ndon't they as long as the values are less than MAXINT?"], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "Question 1: Do erlang, python and haskell loose speed due to using arbitrary length integers or \ndon't they as long as the values are less than MAXINT?", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Yes, somewhat.", "In Erlang, there is no way of saying \"use 32/64-bit arithmetic with wrap-around\", so unless the compiler can prove some bounds on your integers (and it usually can't), it must check all computations to see if they can fit in a single tagged word or if it has to turn them into heap-allocated bignums.", "Even if no bignums are ever used in practice at runtime, these checks will have to be performed.", "On the other hand, that means you know that the algorithm will never fail because of an unexpected integer wraparound if you suddenly give it larger inputs than before."], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "know", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"text": ["Question 4: Do my functional implementations permit LCO and hence avoid adding unnecessary frames onto the call stack?"], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "Question 4: Do my functional implementations permit LCO and hence avoid adding unnecessary frames onto the call stack?", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Yes, your Erlang code is correct with respect to last call optimization."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}], [{"text": ["Take a look at this blog.", "Over the past year or so he's done a few of the Project Euler problems in Haskell and Python, and he's generally found Haskell to be much faster.", "I think that between those languages it has more to do with your fluency and coding style."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "this blog", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://scrollingtext.org/"}, {"text": "Haskell", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["When it comes to Python speed, you're using the wrong implementation!", "Try PyPy, and for things like this you'll find it to be much, much faster."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "PyPy", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pypy.org/"}]}], [{"text": ["In regards to Python optimization, in addition to using PyPy (for pretty impressive speed-ups with zero change to your code), you could use PyPy's translation toolchain to compile an RPython-compliant version, or Cython to build an extension module, both of which are faster than the C version in my testing, with the Cython module nearly twice as fast.", "For reference I include C and PyPy benchmark results as well:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "translation toolchain", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://codespeak.net/pypy/dist/pypy/doc/translation.html"}, {"text": "Cython", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.cython.org/src/quickstart/overview.html"}, {"text": "nearly twice as fast", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["C (compiled withgcc -O3 -lm)"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "C (compiled withgcc -O3 -lm)", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "gcc -O3 -lm", "tag": "code"}]}, {"text": "gcc -O3 -lm", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n % time ./euler12-c \n842161320\n./euler12-c  11.95s user 0.00s system 99% cpu 11.959 total\n</code>\n</pre>\n", "senID": 2}, {"text": ["PyPy 1.5"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "PyPy 1.5", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n % time pypy euler12.py\n842161320\npypy euler12.py  16.44s user 0.01s system 99% cpu 16.449 total\n</code>\n</pre>\n", "senID": 4}, {"text": ["RPython (using latest PyPy revision,c2f583445aee)"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "RPython (using latest PyPy revision,c2f583445aee)", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "c2f583445aee", "tag": "code"}]}, {"text": "c2f583445aee", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n % time ./euler12-rpython-c\n842161320\n./euler12-rpy-c  10.54s user 0.00s system 99% cpu 10.540 total\n</code>\n</pre>\n", "senID": 6}, {"text": ["Cython 0.15"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Cython 0.15", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n % time python euler12-cython.py\n842161320\npython euler12-cython.py  6.27s user 0.00s system 99% cpu 6.274 total\n</code>\n</pre>\n", "senID": 8}, {"text": ["The RPython version has a couple of key changes.", "To translate into a standalone program you need to define your target, which in this case is the main function.", "It's expected to accept sys.argv as it's only argument, and is required to return an int.", "You can translate it by using translate.py, % translate.py euler12-rpython.py which translates to C and compiles it for you."], "childNum": 4, "tag": "p", "senID": 9, "childList": [{"text": "target", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "main", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sys.argv", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "% translate.py euler12-rpython.py", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n # euler12-rpython.py\n\nimport math, sys\n\ndef factorCount(n):\n    square = math.sqrt(n)\n    isquare = int(square)\n    count = -1 if isquare == square else 0\n    for candidate in xrange(1, isquare + 1):\n        if not n % candidate: count += 2\n    return count\n\ndef main(argv):\n    triangle = 1\n    index = 1\n    while factorCount(triangle) &lt; 1001:\n        index += 1\n        triangle += index\n    print triangle\n    return 0\n\nif __name__ == '__main__':\n    main(sys.argv)\n\ndef target(*args):\n    return main, None\n</code>\n</pre>\n", "senID": 10}, {"text": ["The Cython version was rewritten as an extension module _euler12.pyx, which I import and call from a normal python file.", "The _euler12.pyx is essentially the same as your version, with some additional static type declarations.", "The setup.py has the normal boilerplate to build the extension, using python setup.py build_ext --inplace."], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "_euler12.pyx", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "_euler12.pyx", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "python setup.py build_ext --inplace", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n # _euler12.pyx\nfrom libc.math cimport sqrt\n\ncdef int factorCount(int n):\n    cdef int candidate, isquare, count\n    cdef double square\n    square = sqrt(n)\n    isquare = int(square)\n    count = -1 if isquare == square else 0\n    for candidate in range(1, isquare + 1):\n        if not n % candidate: count += 2\n    return count\n\ncpdef main():\n    cdef int triangle = 1, index = 1\n    while factorCount(triangle) &lt; 1001:\n        index += 1\n        triangle += index\n    print triangle\n\n# euler12-cython.py\nimport _euler12\n_euler12.main()\n\n# setup.py\nfrom distutils.core import setup\nfrom distutils.extension import Extension\nfrom Cython.Distutils import build_ext\n\next_modules = [Extension(\"_euler12\", [\"_euler12.pyx\"])]\n\nsetup(\n  name = 'Euler12-Cython',\n  cmdclass = {'build_ext': build_ext},\n  ext_modules = ext_modules\n)\n</code>\n</pre>\n", "senID": 12}, {"text": ["I honestly have very little experience with either RPython or Cython, and was pleasantly surprised at the results.", "If you are using CPython, writing your CPU-intensive bits of code in a Cython extension module seems like a really easy way to optimize your program."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["This is unlikely.", "I cannot say much about Erlang and Haskell (well, maybe a bit about Haskell below) but I can point a lot of other bottlenecks in Python.", "Every time the program tries to execute an operation with some values in Python, it should verify whether the values are from the proper type, and it costs a bit of time.", "Your factorCount function just allocates a list with range (1, isquare + 1) various times, and runtime, malloc-styled memory allocation is way slower than iterating on a range with a counter as you do in C. Notably, the factorCount() is called multiple times and so allocates a lot of lists.", "Also, let us not forget that Python is interpreted and the CPython interpreter has no great focus on being optimized."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "factorCount", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "range (1, isquare + 1)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "malloc", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "factorCount()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["EDIT: oh, well, I note that you are using Python 3 so range() does not return a list, but a generator.", "In this case, my point about allocating lists is half-wrong: the function just allocates range objects, which are inefficient nonetheless but not as inefficient as allocating a list with a lot of items."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "range()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "range", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Are you using Hugs?", "Hugs is a considerably slow interpreter.", "If you are using it, maybe you can get a better time with GHC - but I am only cogitating hypotesis, the kind of stuff a good Haskell compiler does under the hood is pretty fascinating and way beyond my comprehension :)"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Hugs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.haskell.org/hugs/"}, {"text": "GHC", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.haskell.org/ghc/"}]}, {"text": ["I'd say you are playing an unfunny game.", "The best part of knowing various languages is to use them the most different way possible :) But I digress, I just do not have any recommendation for this point.", "Sorry, I hope someone can help you in this case :)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["As far as I remember, you just need to make sure that your recursive call is the last command before returning a value.", "In other words, a function like the one below could use such optimization:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def factorial(n, acc=1):\n    if n &gt; 1:\n        acc = acc * n\n        n = n - 1\n        return factorial(n, acc)\n    else:\n        return acc\n</code>\n</pre>\n", "senID": 5}, {"text": ["However, you would not have such optimization if your function were such as the one below, because there is an operation (multiplication) after the recursive call:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def factorial2(n):\n    if n &gt; 1:\n        f = factorial2(n-1)\n        return f*n\n    else:\n        return 1\n</code>\n</pre>\n", "senID": 7}, {"text": ["I separated the operations in some local variables for make it clear which operations are executed.", "However, the most usual is to see these functions as below, but they are equivalent for the point I am making:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def factorial(n, acc=1):\n    if n &gt; 1:\n        return factorial(n-1, acc*n)\n    else:\n        return acc\n\ndef factorial2(n):\n    if n &gt; 1:\n        return n*factorial(n-1)\n    else:\n        return 1\n</code>\n</pre>\n", "senID": 9}, {"text": ["Note that it is up to the compiler/interpreter to decide if it will make tail recursion.", "For example, the Python interpreter does not do it if I remember well (I used Python in my example only because of its fluent syntax).", "Anyway, if you find strange stuff such as factorial functions with two parameters (and one of the parameters has names such as acc, accumulator etc.", ") now you know why people do it :) "], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "acc", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "accumulator", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["The C implementation is suboptimal (as hinted at by Thomas M. DuBuisson), the version uses 64-bit integers (i.e.", "long datatype).", "I'll investigate the assembly listing later, but with an educated guess, there are some memory accesses going on in the compiled code, which make using 64-bit integers significantly slower.", "It's that or generated code (be it the fact that you can fit less 64-bit ints in a SSE register or round a double to a 64-bit integer is slower)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "long", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["Here is the modified code (simply replace long with int and I explicitly inlined factorCount, although I do not think that this is necessary with gcc -O3):"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "long", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "int", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n #include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nstatic inline int factorCount(int n)\n{\n    double square = sqrt (n);\n    int isquare = (int)square;\n    int count = isquare == square ? -1 : 0;\n    int candidate;\n    for (candidate = 1; candidate &lt;= isquare; candidate ++)\n        if (0 == n % candidate) count += 2;\n    return count;\n}\n\nint main ()\n{\n    int triangle = 1;\n    int index = 1;\n    while (factorCount (triangle) &lt; 1001)\n    {\n        index++;\n        triangle += index;\n    }\n    printf (\"%d\\n\", triangle);\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["Running + timing it gives:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n $ gcc -O3 -lm -o euler12 euler12.c; time ./euler12\n842161320\n./euler12  2.95s user 0.00s system 99% cpu 2.956 total\n</code>\n</pre>\n", "senID": 4}, {"text": ["For reference, the haskell implementation by Thomas in the earlier answer gives:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n $ ghc -O2 -fllvm -fforce-recomp euler12.hs; time ./euler12                                                                                      [9:40]\n[1 of 1] Compiling Main             ( euler12.hs, euler12.o )\nLinking euler12 ...\n842161320\n./euler12  9.43s user 0.13s system 99% cpu 9.602 total\n</code>\n</pre>\n", "senID": 6}, {"text": ["Conclusion: Taking nothing away from ghc, its a great compiler, but gcc normally generates faster code."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Looking at your Erlang implementation.", "The timing has included the start up of the entire virtual machine, running your program and halting the virtual machine.", "Am pretty sure that setting up and halting the erlang vm takes some time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If the timing was done within the erlang virtual machine itself, results would be different as in that case we would have the actual time for only the program in question.", "Otherwise, i believe that the total time taken by the process of starting and loading of the Erlang Vm plus that of halting it (as you put it in your program) are all included in the total time which the method you are using to time the program is outputting.", "Consider using the erlang timing itself which we use when we want to time our programs within the virtual machine itself\ntimer:tc/1 or timer:tc/2 or timer:tc/3.", "In this way, the results from erlang will exclude the time taken to start and stop/kill/halt the virtual machine.", "That is my reasoning there, think about it, and then try your bench mark again."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "timer:tc/1 or timer:tc/2 or timer:tc/3", "tag": "a", "pos": 2, "childList": [{"text": "timer:tc/1 or timer:tc/2 or timer:tc/3", "tag": "b"}, {"text": "timer:tc/1 or timer:tc/2 or timer:tc/3", "tag": "code"}], "childNum": 2, "href": "http://www.erlang.org/doc/man/timer.html#tc-1"}, {"text": "timer:tc/1 or timer:tc/2 or timer:tc/3", "childNum": 1, "tag": "b", "pos": -1, "childList": [{"text": "timer:tc/1 or timer:tc/2 or timer:tc/3", "tag": "code"}]}, {"text": "timer:tc/1 or timer:tc/2 or timer:tc/3", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["I actually suggest that we try to time the program (for languages that have a runtime), within the runtime of those languages in order to get a precise value.", "C for example has no overhead of starting and shutting down a runtime system as does Erlang, Python and Haskell (98% sure of this - i stand correction).", "So (based on this reasoning) i conclude by saying that this benchmark wasnot precise /fair enough for languages running on top of a runtime system.", "Lets do it again with these changes."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: besides even if all the languages had runtime systems, the overhead of starting each and halting it would differ.", "so i suggest we time from within the runtime systems (for the languages for which this applies).", "The Erlang VM is known to have considerable overhead at start up!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["C is fast, but parallelized Haskell can be faster.", "See Haskell in 5 Steps."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Haskell in 5 Steps", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.haskell.org/haskellwiki/Haskell_in_5_steps"}]}], [{"text": ["There is a webpage associated solely to showing the speed differences in languages.", "Based on your data versus the shootout page, I would say that your algorithm is not as good as some of the others used in the shootout page."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "webpage", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://shootout.alioth.debian.org/u32/which-programming-languages-are-fastest.php?gcc=on&ghc=on&hipe=on&python3=on&calc=chart"}]}]]