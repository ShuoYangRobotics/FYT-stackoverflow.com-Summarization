[[{"text": ["Duck typing"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    iterator = iter(theElement)\nexcept TypeError:\n    # not iterable\nelse:\n    # iterable\n\n# for obj in iterator:\n#     pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["Type checking"], "childNum": 0, "tag": "h2", "senID": 2, "childList": []}, {"text": ["Use the Abstract Base Classes.", "They need at least Python 2.6 and work only for new-style classes."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Abstract Base Classes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/abc.html"}]}, {"code": "<pre>\n<code>\n import collections\n\nif isinstance(theElement, collections.Iterable):\n    # iterable\nelse:\n    # not iterable\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I Checking for __iter__ works on sequence types, but it would fail on e.g.", "strings.", "I would like to know the right answer too, until then, here is one possibility (which would work on strings, too):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "I", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "__iter__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n try:\n    some_object_iterator = iter(some_object)\nexcept TypeError, te:\n    print some_object, 'is not iterable'\n</code>\n</pre>\n", "senID": 1}, {"text": ["The iter built-in:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "iter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; help(iter)\n 1 Help on built-in function iter in module __builtin__:\n 2 \n 3 iter(...)\n 4     iter(collection) -&gt; iterator\n 5     iter(callable, sentinel) -&gt; iterator\n 6     \n 7     Get an iterator from an object.  In the first form, the argument must\n 8     supply its own iterator, or be a sequence.\n 9     In the second form, the callable is called until it returns the sentinel.\n</code>\n</pre>\n", "senID": 3}, {"text": ["II Another general pythonic approach is to assume an iterable, then fail gracefully if it does not work on the given object.", "The python glossary:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "II", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["..."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n try:\n    [ e for e in my_object]\nexcept TypeError:\n    print my_object, 'is not iterable'\n</code>\n</pre>\n", "senID": 6}, {"text": ["III The collections module provides some abstract base classes, which allow to ask classes or instances if they provide particular functionality, for example:"], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "III", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/collections.html#abcs-abstract-base-classes", "text": "collections", "childNum": 1, "tag": "a", "childList": [{"text": "collections", "tag": "code"}]}, {"text": "collections", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import collections\n\nif isinstance(e, collections.Iterable):\n    # e is iterable\n</code>\n</pre>\n", "senID": 8}], [{"text": ["This isn't sufficient: the object returned by __iter__ must implement the iteration protocol (i.e.", "next method).", "See the relevant section in the documentation."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__iter__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "next", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "documentation", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#iterator-types"}]}, {"text": ["In Python, a good practice is to \" try and see \" instead of \"checking\"."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You could try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def iterable(a):\n    try:\n        (x for x in a)\n        return True\n    except TypeError:\n        return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["If we can make a generator that iterates over it (but never use the generator so it doesn't take up space), it's iterable.", "Seems like a \"duh\" kind of thing.", "Why do you need to determine if a variable is iterable in the first place?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n try:\n  #treat object as iterable\nexcept TypeError, e:\n  #object is not actually iterable\n</code>\n</pre>\n", "senID": 0}, {"text": ["Don't run checks to see if your duck really is a duck to see if it is iterable or not, treat it as if it was and complain if it wasn't."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "if your duck really is a duck", "childNum": 0, "tag": "s", "pos": 0, "childList": []}]}], [{"text": ["On python &lt;= 2.5, you can't and shouldn't - iterable was an \"informal\" interface."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But since python2.6 and 3.0 you can leverage the new ABC (abstract base class) infrastructure along with some builtin ABCs which are available in the collections module:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from collections import Iterable\n\nclass MyObject(object):\n    pass\n\nmo = MyObject()\nprint isinstance(mo, Iterable)\nIterable.register(MyObject)\nprint isinstance(mo, Iterable)\n\nprint isinstance(\"abc\", Iterable)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now, whether this is desiderable or actually works, is just a matter of conventions.", "As you can see, you can register a non-iterable object as Iterable - and it will raise an exception at runtime.", "Hence, isinstance acquires a \"new\" meaning - it just checks for \"declared\" type compatibility, which is a good way to go in Python."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "can", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["On the other hand, if your object does not satifsy the interface you need, what are you going to do?", "take the following example:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from collections import Iterable\nfrom traceback import print_exc\n\ndef check_and_raise(x):\n    if not isinstance(x, Iterable):\n        raise TypeError, \"%s is not iterable\" % x\n    else:\n        for i in x:\n            print i\n\ndef just_iter(x):\n    for i in x:\n        print i\n\n\nclass NotIterable(object):\n    pass\n\nif __name__ == \"__main__\":\n    try:\n        check_and_raise(5)\n    except:\n        print_exc()\n        print\n\n    try:\n        just_iter(5)\n    except:\n        print_exc()\n        print\n\n\n\n    try:\n        Iterable.register(NotIterable)\n        ni = NotIterable()\n        check_and_raise(ni)\n    except:\n        print_exc()\n        print\n</code>\n</pre>\n", "senID": 5}, {"text": ["If the object doesn't satifsy what you expect, you just throw a TypeError, but if the proper ABC has been registered, your check is unuseful.", "On the contrary, if the __iter__ method is available python will automatically recognize object of that class as being Iterable."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "__iter__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["So, if you just expect an iterable, iterate over it and forget it.", "On the other hand, if you need to do different things depending on input type, you might find the ABC infrastracture pretty useful."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["The best solution I've found so far:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["hasattr(obj, '__contains__')"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "hasattr(obj, '__contains__')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["which basically checks if the object implements the in operator."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "in", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Advantages (none of the other solutions has all three):"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Advantages", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "it is an expression (works as a ", "tag": "none", "senID": 4}, {"text": "it is (should be) implemented by all iterables, including ", "tag": "none", "senID": 5}, {"text": "works on any Python >= 2.5", "tag": "none", "senID": 6}]}, {"text": ["Notes: "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "the Python philosophy of \"ask for forgiveness, not permission\" doesn't work well when e.g. in a list you have both iterables and non-iterables and you need to treat each element differently according to it's type (treating iterables on try and non-iterables on except ", "tag": "none", "senID": 8}, {"text": "solutions to this problem which attempt to actually iterate over the object (e.g. [x for x in obj]) to check if it's iterable may induce significant performance penalties for large iterables (especially if you just need the first few elements of the iterable, for example) and should be avoided", "tag": "none", "senID": 9}]}], [{"text": ["Found a nice solution here:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bytes.com/topic/python/answers/514838-how-test-if-object-sequence-iterable"}]}, {"code": "<pre>\n<code>\n isiterable = lambda obj: isinstance(obj, basestring) \\\n    or getattr(obj, '__iter__', False)\n</code>\n</pre>\n", "senID": 1}]]