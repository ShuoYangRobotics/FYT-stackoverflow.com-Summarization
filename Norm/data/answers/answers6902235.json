[[{"text": ["Hmm.. that's not quite right;  although I can see how you might think that.", "In other languages, a slice assignment, something like: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a[b:c] = d\n</code>\n</pre>\n", "senID": 1}, {"text": ["is equivalent to "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n tmp = a.operator[](slice(b, c)) # which returns some sort of reference\ntmp.operator=(d)        # which has a special meaning for the reference type.\n</code>\n</pre>\n", "senID": 3}, {"text": ["But in python, the first statement is actually converted to this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n a.__setitem__(slice(b, c), d)\n</code>\n</pre>\n", "senID": 5}, {"text": ["Which is to say that an item assignment is actually specially recognized in python to have a special meaning, separate from item lookup and assignment; they may be unrelated.", "This is consistent with python as a whole, because python doesn't have concepts like the \"lvalues\" found in C/C++;  There's no way to overload the assignment operator itself; only specific cases when the left side of the assignment is not a plain identifier.    "], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "and assignment", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "\"lvalues\"", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Suppose lists did have views;  And you tried to use it:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "did", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n myView = myList[1:10]\nyourList = [1, 2, 3, 4]\nmyView = yourList\n</code>\n</pre>\n", "senID": 8}, {"text": ["In languages besides python, there might be a way to shove yourList into myList, but in python, since the name myView appears as a bare identifier, it can only mean a variable assignemnt;  the view is lost.  "], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "yourList", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "myList", "childNum": 0, "tag": "code", "childList": []}, {"text": "myView", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Well it seems I found a lot of the reasoning behind the views decision, going by the thread starting with http://mail.python.org/pipermail/python-3000/2006-August/003224.html (it's primarily about slicing strings, but at least one e-mail in the thread mentions mutable objects like lists), and also some things from:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://mail.python.org/pipermail/python-3000/2006-August/003224.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-3000/2006-August/003224.html"}]}, {"text": ["http://mail.python.org/pipermail/python-3000/2007-February/005739.html\nhttp://mail.python.org/pipermail/python-dev/2008-May/079692.html and following e-mails in the thread"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "http://mail.python.org/pipermail/python-3000/2007-February/005739.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-3000/2007-February/005739.html"}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"href": "http://mail.python.org/pipermail/python-dev/2008-May/079692.html", "text": "http://mail.python.org/pipermail/python-dev/2008-May/079692.html", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Looks like the advantages of switching to this style for base Python would be vastly outweighed by the induced complexity and various undesirable edge cases.", "Oh well."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["...And as I then started wondering about the possibility of just replacing the current way slice objects are worked with with an iterable form a la itertools.islice, just as zip, map, etc.", "all return iterables instead of lists in Python 3, I started realizing all the unexpected behavior and possible problems that could come out of that.", "Looks like this might be a dead end for now."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "slice", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools.islice", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "zip", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["On the plus side, numpy's arrays are fairly flexible, so in situations where this sort of thing might be necessary, it wouldn't be too hard to use one-dimensional ndarrays instead of lists.", "However, it seems ndarrays don't support using slicing to insert additional items within arrays, as happens with Python lists:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [0, 0]\n&gt;&gt;&gt; a[:1] = [2, 3]\n&gt;&gt;&gt; a\n[2, 3, 0]\n</code>\n</pre>\n", "senID": 5}, {"text": ["I think the numpy equivalent would instead be something like this:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = np.array([0, 0])  # or a = np.zeros([2]), but that's not important here\n&gt;&gt;&gt; a = np.hstack(([2, 3], a[1:]))\n&gt;&gt;&gt; a\narray([2, 3, 0])\n</code>\n</pre>\n", "senID": 7}, {"text": ["A slightly more complicated case:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [1, 2, 3, 4]\n&gt;&gt;&gt; a[1:3] = [0, 0, 0]\n&gt;&gt;&gt; a\n[1, 0, 0, 0, 4]\n</code>\n</pre>\n", "senID": 9}, {"text": ["versus"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = np.array([1, 2, 3, 4])\n&gt;&gt;&gt; a = np.hstack((a[:1], [0, 0, 0], a[3:]))\n&gt;&gt;&gt; a\narray([1, 0, 0, 0, 4])\n</code>\n</pre>\n", "senID": 11}, {"text": ["And, of course, the above numpy examples don't store the result in the original array as happens with the regular Python list expansion."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}]]