[[{"text": ["Alex summarized well but, surprisingly, was too succinct."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First, let me reiterate the main points in Alex\u2019s post:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "The default implementation is useless (it\u2019s hard to think of one which wouldn\u2019t be, but yeah)", "tag": "none", "senID": 2}, {"text": ["__repr__"], "childNum": 0, "tag": "code", "senID": 3, "childList": []}, {"text": ["__str__"], "childNum": 0, "tag": "code", "senID": 4, "childList": []}, {"text": "Container\u2019s ", "tag": "none", "senID": 5}]}, {"text": ["Default implementation is useless"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Default implementation is useless", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This is mostly a surprise because Python\u2019s defaults tend to be fairly useful.", "However, in this case, having a default for __repr__ which would act like:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "__repr__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n return \u201c%s(%r)\u201d % (self.__class__, self.__dict__)*\n</code>\n</pre>\n", "senID": 8}, {"text": ["would have been too dangerous (for example, too easy to get into infinite recursion if objects reference each other).", "So Python cops out.", "Note that there is one default which is true: if __repr__ is defined, and __str__ is not, the object will behave as though __str__=__repr__."], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "__repr__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__str__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__str__=__repr__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This means, in simple terms: almost every object you implement should have a functional __repr__ that\u2019s usable for understanding the object.", "Implementing __str__ is optional: do that if you need a \u201cpretty print\u201d functionality (for example, used by a report generator)."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "__repr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__str__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The goal of__repr__is to be unambiguous"], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "The goal of__repr__is to be unambiguous", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "__repr__", "tag": "code"}]}, {"text": "__repr__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Let me come right out and say it \u2014 I do not believe in debuggers.", "I don\u2019t really know how to use any debugger, and have never used one seriously.", "Furthermore, I believe that the big fault in debuggers is their basic nature \u2014 most failures I debug happened a long long time ago, in a galaxy far far away.", "This means that I do believe, with religious fervor, in logging.", "Logging is the lifeblood of any decent fire-and-forget server system.", "Python makes it easy to log: with maybe some project specific wrappers, all you need is a"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n log(INFO, \u201cI am in the weird function and a is\u201d, a, \u201cand\u201d, b, \u201cis\u201d, b, \u201cbut I got a null C \u2014 using default\u201d, default_c)\n</code>\n</pre>\n", "senID": 13}, {"text": ["But you have to do the last step \u2014 make sure every object you implement has a useful repr, so code like that can just work.", "This is why the \u201ceval\u201d thing comes up: if you have enough information so \u201ceval(repr(c))==c\u201d, that means you know everything there is to know about c. If that\u2019s easy enough, at least in a fuzzy way, do it.", "If not, make sure you have enough information about c anyway.", "I usually use an eval-like format: \u201cMyClass(this=%r,that=%r)\u201d % (self.this,self.that).", "It does not mean that you can actually construct MyClass, or that those are the right constructor arguments \u2014 but it is a useful form to express \u201cthis is everything you need to know about this instance\u201d."], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "eval(repr(c))==c", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Note: I used %r above, not %s.", "You always want to use repr() [or %r formatting character, equivalently] inside repr implementation, or you\u2019re defeating the goal of repr.", "You want to be able to differentiate MyClass(3) and MyClass(\u201c3\u2033)."], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "repr", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["The goal of__str__is to be readable"], "childNum": 2, "tag": "p", "senID": 16, "childList": [{"text": "The goal of__str__is to be readable", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "__str__", "tag": "code"}]}, {"text": "__str__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Specifically, it is not intended to be unambiguous \u2014 notice that str(3)==str(\u201c3\u2033).", "Likewise, if you implement an IP abstraction, having the str of it look like 192.168.1.1 is just fine.", "When implementing a date/time abstraction, the str can be \u201c2010/4/12 15:35:22\u2033, etc.", "The goal is to represent it in a way that a user, not a programmer, would want to read it.", "Chop off useless digits, pretend to be some other class \u2014 as long is it supports readability, it is an improvement."], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "str(3)==str(\u201c3\u2033)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Container\u2019s__str__uses contained objects\u2019__repr__"], "childNum": 3, "tag": "p", "senID": 18, "childList": [{"text": "Container\u2019s__str__uses contained objects\u2019__repr__", "childNum": 2, "tag": "strong", "pos": 0, "childList": [{"text": "__str__", "tag": "code"}, {"text": "__repr__", "tag": "code"}]}, {"text": "__str__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__repr__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This seems surprising, doesn\u2019t it?", "It is a little, but how readable would"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"code": "<pre>\n<code>\n [moshe is, 3, hello\nworld, this is a list, oh I don't know, containing just 4 elements]\n</code>\n</pre>\n", "senID": 20}, {"text": ["be?", "Not very.", "Specifically, the strings in a container would find it way too easy to disturb its string representation.", "In the face of ambiguity, remember, Python resists the temptation to guess.", "If you want the above behavior when you\u2019re printing a list, just"], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"code": "<pre>\n<code>\n print \u201c[\"+\", \".join(l)+\"]\u201c\n</code>\n</pre>\n", "senID": 22}, {"text": ["(you can probably also figure out what to do about dictionaries."], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"text": ["Summary"], "childNum": 1, "tag": "p", "senID": 24, "childList": [{"text": "Summary", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Implement __repr__ for any class you implement.", "This should be second nature.", "Implement __str__ if you think it would be useful to have a string version which errs on the side of more readability in favor of more ambiguity."], "childNum": 2, "tag": "p", "senID": 25, "childList": [{"text": "__repr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__str__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["__repr__: representation of python object usually eval will convert it back to that object"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__repr__", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "__repr__", "tag": "code"}]}, {"text": "__repr__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["__str__: is whatever you think is that object in text form"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "__str__", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "__str_", "tag": "code"}]}, {"text": "__str_", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["e.g."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s=\"\"\"w'o\"w\"\"\"\n&gt;&gt;&gt; repr(s)\n'\\'w\\\\\\'o\"w\\''\n&gt;&gt;&gt; str(s)\n'w\\'o\"w'\n&gt;&gt;&gt; eval(str(s))==s\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;string&gt;\", line 1\n    w'o\"w\n       ^\nSyntaxError: EOL while scanning single-quoted string\n&gt;&gt;&gt; eval(repr(s))==s\nTrue\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Unless you specifically act to ensure otherwise, most classes don't have helpful results for either:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class Sic(object): pass\n... \n&gt;&gt;&gt; print str(Sic())\n&lt;__main__.Sic object at 0x8b7d0&gt;\n&gt;&gt;&gt; print repr(Sic())\n&lt;__main__.Sic object at 0x8b7d0&gt;\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["As you see -- no difference, and no info beyond the class and object's id.", "If you only override one of the two...:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "id", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class Sic(object): \n...   def __repr__(object): return 'foo'\n... \n&gt;&gt;&gt; print str(Sic())\nfoo\n&gt;&gt;&gt; print repr(Sic())\nfoo\n&gt;&gt;&gt; class Sic(object):\n...   def __str__(object): return 'foo'\n... \n&gt;&gt;&gt; print str(Sic())\nfoo\n&gt;&gt;&gt; print repr(Sic())\n&lt;__main__.Sic object at 0x2617f0&gt;\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["as you see, if you override __repr__, that's ALSO used for __str__, but not vice versa."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "__repr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__str__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Other crucial tidbits to know: __str__ on a built-on container uses the __repr__, NOT the __str__, for the items it contains.", "And, despite the words on the subject found in typical docs, hardly anybody bothers making the __repr__ of objects be a string that eval may use to build an equal object (it's just too hard, AND not knowing how the relevant module was actually imported makes it actually flat out impossible)."], "childNum": 5, "tag": "p", "senID": 5, "childList": [{"text": "__str__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__repr__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__str__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__repr__", "childNum": 0, "tag": "code", "childList": []}, {"text": "eval", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So, my advice: focus on making __str__ reasonably human-readable, and __repr__ as unambiguous as you possibly can, even if that interferes with the fuzzy unattainable goal of making __repr__'s returned value acceptable as input to __eval__!"], "childNum": 4, "tag": "p", "senID": 6, "childList": [{"text": "__str__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__repr__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__repr__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__eval__", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["My rule of thumb:  __repr__ is for developers, __str__ is for customers."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__repr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__str__", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["From http://pyref.infogami.com/%5F%5Fstr%5F%5F by effbot:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://pyref.infogami.com/%5F%5Fstr%5F%5F", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyref.infogami.com/%5F%5Fstr%5F%5F"}]}, {"text": ["__str__ \"computes the \"informal\" string representation of an object.", "This differs from __repr__ in that it does not have to be a valid Python expression: a more convenient or concise representation may be used instead."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "__str__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__repr__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["This mailing list archive gives a nice view"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "This", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.eros-os.org/pipermail/e-lang/2002-June/006813.html"}]}]]