[[{"text": ["Actually None is much better for \"magic\" values:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Cheese():\n    def __init__(self, num_holes = None):\n    if(num_holes is None):\n     ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["No if you want complete freedom of adding more parameters"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Cheese():\n    def __init__(self, *args, **kwargs):\n    #args -- tuple of anonymous arguments\n    #kwargs -- dictionary of named arguments\n    self.num_holes = kwargs.get('num_holes',random_holes())\n</code>\n</pre>\n", "senID": 3}, {"text": ["to explain better concept of *args and **kwargs (you can actually change these names):"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "*args", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "**kwargs", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def f(*args, **kwargs):\n   print 'args: ', args, ' kwargs: ', kwargs\n\n&gt;&gt;&gt; f('a')\nargs:  ('a',)  kwargs:  {}\n&gt;&gt;&gt; f(ar='a')\nargs:  ()  kwargs:  {'ar': 'a'}\n&gt;&gt;&gt; f(1,2,param=3)\nargs:  (1, 2)  kwargs:  {'param': 3}\n</code>\n</pre>\n", "senID": 5}, {"text": ["http://docs.python.org/reference/expressions.html#calls"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "http://docs.python.org/reference/expressions.html#calls", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/expressions.html#calls"}]}], [{"text": ["Using num_holes=None as the default is fine, as others have pointed out."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "num_holes=None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you want multiple, independent \"constructors\", you can provide these as class methods.", "These are usually called factory methods."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Cheese(object):\n    def __init__(self):\n        # create the basic object\n\n    @classmethod\n    def random(cls):\n        obj = cls()\n        obj.set_holes(random())\n\n        return obj\n\n\n    @classmethod\n    def fixed(cls, num):\n        obj = cls()\n        obj.set_holes(num)\n\n        return obj\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now create object like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n gouda = Cheese.fixed(0)\nemmentaler = Cheese.random()\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Use num_holes=None as a default, instead.", "Then check for whether num_holes is None, and if so, randomize.", "That's what I generally see, anyway."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "num_holes=None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "num_holes is None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["More radically different construction methods may warrant a classmethod that returns an instance of cls."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "cls", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Why do you think your solution is \"clunky\"?", "Personally I would prefer one constructor with default values over multiple overloaded constructors in situations like yours (Python does not support method overloading anyway):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def __init__(self, num_holes=None):\n    if num_holes is None:\n        # Construct a gouda\n    else:\n        # custom cheese\n    # common initialization\n</code>\n</pre>\n", "senID": 1}, {"text": ["For really complex cases with lots of different constructors, it might be cleaner to use different factory functions instead:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n @classmethod\ndef create_gouda(cls):\n    c = Cheese()\n    # ...\n    return c\n\n@classmethod\ndef create_cheddar(cls):\n    # ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["In your cheese example you might want to use a Gouda subclass of Cheese though..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["All of these answers are excellent if you want to use optional parameters, but another Pythonic possibility is to use a classmethod to generate a factory-style pseudo-constructor:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def __init__(self, num_holes):\n\n  # do stuff with the number\n\n@classmethod\ndef fromRandom(cls):\n\n  return cls( # some-random-number )\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The best answer is the one above about default arguments, but I had fun writing this, and it certainly does fit the bill for \"multiple constructors\".", "Use at your own risk."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What about the new method."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "new", "tag": "a", "pos": 0, "childList": [{"text": "new", "tag": "strong"}], "childNum": 1, "href": "http://docs.python.org/reference/datamodel.html#object.%5F%5Fnew%5F%5F"}, {"text": "new", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["\"Typical implementations create a new instance of the class by invoking the superclass\u2019s new() method using super(currentclass, cls).new(cls[, ...]) with appropriate arguments and then modifying the newly-created instance as necessary before returning it."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "new", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "new", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["So you can have the new method modify your class definition by attaching the appropriate constructor method."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "new", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Cheese(object):\n    def __new__(cls, *args, **kwargs):\n\n        obj = super(Cheese, cls).__new__(cls)\n        num_holes = kwargs.get('num_holes', random_holes())\n\n        if num_holes == 0:\n            cls.__init__ = cls.foomethod\n        else:\n            cls.__init__ = cls.barmethod\n\n        return obj\n\n    def foomethod(self, *args, **kwargs):\n        print \"foomethod called as __init__ for Cheese\"\n\n    def barmethod(self, *args, **kwargs):\n        print \"barmethod called as __init__ for Cheese\"\n\nif __name__ == \"__main__\":\n    parm = Cheese(num_holes=5)\n</code>\n</pre>\n", "senID": 4}]]