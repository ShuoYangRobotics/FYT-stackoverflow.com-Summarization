<h3>Question (ID-3217673):</h3><h2>Why use argparse rather than optparse?</h2><p>I noticed that the Python 2.7 documentation includes yet another command-line parsing module.  In addition to <code>getopt</code> and <code>optparse</code> we now have <code>argparse</code>.</p>

<p>Why has yet another command-line parsing module been created?  Why should I use it instead of <code>optparse</code>?  Are their new features I should know about?</p>
<br /><h3>Answers (Total-3):</h3><b>#0</b><br /><p>As of 2.7, optparse is deprecated, and will hopefully go away in the future.</p>

<p>argparse is better for all the reasons listed listed on its original page ( <a href="http://code.google.com/p/argparse/" rel="nofollow">http://code.google.com/p/argparse/</a> ):</p>

<ul>
<li>handling positional arguments</li>
<li>supporting sub-commands</li>
<li>allowing alternative option prefixes like + and /</li>
<li>handling zero-or-more and one-or-more style arguments</li>
<li>producing more informative usage messages</li>
<li>providing a much simpler interface for custom types and actions</li>
</ul>

<p>More information is also in PEP 389 ( <a href="http://www.python.org/dev/peps/pep-0389/" rel="nofollow">http://www.python.org/dev/peps/pep-0389/</a> ), which is the vehicle by which argparse made it into the standard library.</p>
<br /><b>#1</b><br /><blockquote>
  <p>Why should I use it instead of
  optparse? Are their new features I
  should know about?</p>
</blockquote>

<p>@Nicholas's answer covers this well, I think, but not the more "meta" question you start with:</p>

<blockquote>
  <p>Why has yet another command-line
  parsing module been created?</p>
</blockquote>

<p>That's the dilemma number one when any useful module is added to the standard library: what do you do when a substantially better, but backwards-incompatible, way to provide the same kind of functionality emerges?</p>

<p>Either you stick with the old and admittedly surpassed way (typically when we're talking about complicated packages: asyncore vs twisted, tkinter vs wx or Qt, ...) or you end up with multiple incompatible ways to do the same thing (XML parsers, IMHO, are an even better example of this than command-line parsers -- but the <code>email</code> package vs the myriad old ways to deal with similar issues isn't too far away either;-).</p>

<p>You may make threatening grumbles in the docs about the old ways being "deprecated", but (as long as you need to keep backwards compatibility) you can't really take them away without stopping large, important applications from moving to newer Python releases.</p>

<p>(Dilemma number two, not directly related to your question, is summarized in the old saying "the standard library is where good packages go to die"... with releases every year and a half or so, packages that aren't very, <strong>very</strong> stable, <strong>not</strong> needing releases any more often than that, can actually suffer substantially by being "frozen" in the standard library... but, that's really a different issue).</p>
<br /><b>#2</b><br /><p>The best source for rationale for a Python addition would be its PEP: <a href="http://www.python.org/dev/peps/pep-0389/" rel="nofollow">PEP 389: argparse - New Command Line Parsing Module</a>, in particular, the section entitled, <a href="http://www.python.org/dev/peps/pep-0389/#why-aren-t-getopt-and-optparse-enough" rel="nofollow">Why aren't getopt and optparse enough?</a></p>
<br />