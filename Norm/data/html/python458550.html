<h3>Question (ID-458550):</h3><h2>Standard way to embed version into python package?</h2><p>Is there a standard way to associate version string with a python package in such way that I could do the following?</p>

<pre><code>import foo
print foo.version
</code></pre>

<p>I would imagine there's some way to retrieve that data without any extra hardcoding, since minor/major strings are specified in <code>setup.py</code> already. Alternative solution that I found was to have <code>import __version__</code> in my <code>foo/__init__.py</code> and then have <code>__version__.py</code> generated by <code>setup.py</code> </p>

<p>Thanks,</p>
<br /><h3>Answers (Total-7):</h3><b>#0</b><br /><p>Not directly an answer to your question, but you should consider naming it <code>__version__</code>, not <code>version</code>.</p>

<p>This is almost a quasi-standard. Many modules in the standard library use <code>__version__</code>, and this is also used in <a href="http://www.google.com/codesearch?as%5Fq=%5F%5Fversion%5F%5F&amp;btnG=Search+Code&amp;hl=en&amp;as%5Flang=python&amp;as%5Flicense%5Frestrict=i&amp;as%5Flicense=&amp;as%5Fpackage=&amp;as%5Ffilename=&amp;as%5Fcase=" rel="nofollow">lots</a> of 3rd-party modules, so it's the quasi-standard. It's also mentioned in <a href="http://www.python.org/dev/peps/pep-3001/" rel="nofollow">PEP 3001</a></p>

<p>Usually, <code>__version__</code> is a string, but sometimes it's also a float or tuple.</p>

<p>Edit: as mentioned by S.Lott (Thank you!), <a href="http://www.python.org/dev/peps/pep-0008/" rel="nofollow">PEP 8</a> says it explicitly:</p>

<blockquote>
  <p>Version Bookkeeping</p>
  
  <p>If you have to have Subversion, CVS, or RCS crud in your source file,
  do it as follows.</p>

<pre><code>    __version__ = "$Revision: 63990 $"
    # $Source$
</code></pre>
  
  <p>These lines should be included after the module's docstring, before
  any other code, separated by a blank line above and below.</p>
</blockquote>
<br /><b>#1</b><br /><p>Though this is probably far too late, there is a slightly simpler alternative to the previous answer:</p>

<pre><code>__version_info__ = ('1', '2', '3')
__version__ = '.'.join(__version_info__)
</code></pre>

<p>(And it would be fairly simple to convert auto-incrementing portions of version numbers to a string using <code>str()</code>.)</p>

<p>Of course, from what I've seen, people tend to use something like the previously-mentioned version when using <code>__version_info__</code>, and as such store it as a tuple of ints; however, I don't quite see the point in doing so, as I doubt there are situations where you would perform mathematical operations such as addition and subtraction on portions of version numbers for any purpose besides curiosity or auto-incrementation (and even then, <code>int()</code> and <code>str()</code> can be used fairly easily), and comparison operations can be performed just as easily on string numerals as on integers. (On the other hand, there is the possibility of someone else's code expecting a numerical tuple rather than a string tuple and thus failing.)</p>

<p>This is, of course, my own view, and I would gladly like others' input on using a numerical tuple.</p>
<br /><b>#2</b><br /><p>Here is how I do this. Advantages of the following method:</p>

<ol>
<li><p>It provides a <code>__version__</code> attribute.</p></li>
<li><p>It provides the standard metadata version. Therefore it will be detected by <code>pkg_resources</code> or other tools that parse the package metadata (EGG-INFO and/or PKG-INFO, PEP 0345).</p></li>
<li><p>It doesn't import your package (or anything else) when building your package, which can cause problems in some situations.</p></li>
<li><p>There is only one place that the version number is written down, so there is only one place to change it when the version number changes, and there is less chance of inconsistent versions.</p></li>
</ol>

<p>Here is how it works: the "one canonical place" to store the version number is a .py file, named "_version.py" which is in your Python package, for example in <code>myniftyapp/_version.py</code>. This file is a Python module, but your setup.py doesn't import it! (That would defeat feature 3.) Instead your setup.py knows that the contents of this file is very simple, something like:</p>

<pre><code>__version__ = "3.6.5"
</code></pre>

<p>And so your setup.py opens the file and parses it, with code like:</p>

<pre><code>verstrline = open(VERSIONFILE, "rt").read()
VSRE = r"^__version__ = ['\"]([^'\"]*)['\"]"
mo = re.search(VSRE, verstrline, re.M)
if mo:
    verstr = mo.group(1)
else:
    raise RuntimeError("Unable to find version string in %s." % (VERSIONFILE,))
</code></pre>

<p>Then your setup.py passes that string as the value of the "version" argument to <code>setup()</code>, thus satisfying feature 2.</p>

<p>To satisfy feature 1, you can have your package (at run-time, not at setup time!) import the _version file from <code>myniftyapp/__init__.py</code> like this:</p>

<pre><code>from _version import __version__
</code></pre>

<p>Here is <a href="http://tahoe-lafs.org/trac/zfec/browser/trunk/zfec/setup.py?annotate=blame&amp;rev=390" rel="nofollow">an example of this technique</a> that I've been using for years.</p>

<p>The code in that example is a bit more complicated, but the simplified example that I wrote into this comment should be a complete implementation.</p>

<p>Here is <a href="http://tahoe-lafs.org/trac/zfec/browser/trunk/zfec/zfec/__init__.py?annotate=blame&amp;rev=363" rel="nofollow">example code of importing the version</a>.</p>

<p>If you see anything wrong with this approach, please let me know: zooko at zooko dot com. If you don't see anything wrong with this approach then please vote this answer up! Because the more packages come with their version numbers in the expected places the better!</p>
<br /><b>#3</b><br /><p>There doesn't seem to be a standard way to embed a version string in a python package. Most packages I've seen use some variant of your solution, i.e. eitner</p>

<ol>
<li><p>Embed the version in <code>setup.py</code> and have <code>setup.py</code> generate a module (e.g. <code>version.py</code>) containing only version info,  that's imported by your package, or</p></li>
<li><p>The reverse: put the version info in your package itself, and import <em>that</em> to set the version in  <code>setup.py</code> </p></li>
</ol>
<br /><b>#4</b><br /><p>Also worth noting is that as well as <code>__version__</code> being a semi-std. in python so is <code>__version_info__</code> which is a tuple, in the simple cases you can just do something like:</p>

<pre><code>__version__ = '1.2.3'
__version_info__ = tuple([ int(num) for num in __version__.split('.')])
</code></pre>

<p>...and you can get the <code>__version__</code> string from a file, or whatever.</p>
<br /><b>#5</b><br /><p>I also saw another style:</p>

<pre><code>&gt;&gt;&gt; django.VERSION
(1, 1, 0, 'final', 0)
</code></pre>
<br /><b>#6</b><br /><p>For what it's worth, if you're using NumPy distutils, <code>numpy.distutils.misc_util.Configuration</code> has a <a href="http://docs.scipy.org/doc/numpy/reference/distutils.html#numpy.distutils.misc_util.Configuration.make_svn_version_py" rel="nofollow"><code>make_svn_version_py()</code></a> method that embeds the revision number inside <code>package.__svn_version__</code> in the variable <code>version</code> .</p>
<br />