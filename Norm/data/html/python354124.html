<h3>Question (ID-354124):</h3><h2>Are there statistical studies that indicates that Python is "more productive"?</h2><p>If I do a google search with the string  "python productive" the first results is a page <a href="http://www.ferg.org/projects/python_java_side-by-side.html" rel="nofollow">http://www.ferg.org/projects/python_java_side-by-side.html</a> claiming that "python is more productive of Java". Many Python programmers that I have talked with claim that Python is "more productive", and most of them report the arguments listed in the above cited article.</p>

<p>The article could be summarized in these stametements:</p>

<ol>
<li>Python allow you write terser code  </li>
<li>A more terser is written in lesser time </li>
<li><strong>Then</strong> Python is more productive</li>
</ol>

<p>But the article does not reports any statisticals evidences that support the hypothesis that a more terse code could be developed (not written) in lesser time.</p>

<p>Do you know if there any article that reports statistical evidences that Python is more productive of something else?</p>

<h2>Update:</h2>

<p>I'm not interested in adovacy arguments. Please do not tell why something <em>should</em> be more productive of something else. I'm interested in studies that measures that the use of something is related or not related to the productivity.</p>

<p>I'm interested in statisticals evidences. If you claim that the productivity depends from many other factors then there should be a statistical study that proves that the language choiche is not statistically correlated to the productivity.</p>
<br /><h3>Answers (Total-10):</h3><b>#0</b><br /><p>Yes, and there are also statistical studies that prove that dogs are more productive than cats. Both are equally valid. ;-)</p>

<p>by popular demand, here are a couple of "studies" - take them with a block of salt!</p>

<ol>
<li><a href="http://page.mi.fu-berlin.de/prechelt/Biblio/jccpprt_computer2000.pdf" rel="nofollow">An empirical comparison of C, C++, Java, Perl, Python, Rexx, and Tcl</a> PDF warning!</li>
<li><a href="http://www.connellybarnes.com/documents/language_productivity.pdf" rel="nofollow">Programming Language Productivity</a> PDF warning! Note that these statistics are for a "string processing problem", so one might expect the winner to be...Perl of course!</li>
</ol>

<p>and <a href="http://www.codinghorror.com/blog/archives/000365.html" rel="nofollow">Jeff Atwood's musings</a> are interesting as well</p>

<p>the issues of programmer productivity are far more complex than what language is being used. Productivity among programmers can vary wildly, and is affected by the problem domain plus many other factors. Thus no "study" can ever be "definitive". See <a href="http://www.usc.edu/dept/ATRIUM/Papers/Software_Productivity.html" rel="nofollow">Understanding Software Productivity</a> and <a href="http://forums.construx.com/blogs/stevemcc/archive/2008/03/27/productivity-variations-among-software-developers-and-teams-the-origin-of-quot-10x-quot.aspx" rel="nofollow">Productivity Variations Among Software Developers and Teams</a> for additional information.</p>

<p>Finally, <strong>the right tool for the right job</strong> is still the rule. No exceptions.</p>
<br /><b>#1</b><br /><p>Yes, there's an excellent paper by Lutz Prechelt on this subject:</p>

<p><a href="http://page.mi.fu-berlin.de/prechelt/Biblio//jccpprt_computer2000.pdf" rel="nofollow">An Empirical Comparison of Seven Programming Languages</a></p>

<p>Of course, this paper doesn’t “prove” the superiority of any particular language. But it probably comes as close as any scientific study <em>can</em> come to the truth. On the other hand, the data of this study is very dated, and in the fast-developing world of software engineering this actually plays an important role since both the languages and the tools have vastly improved over time.</p>
<br /><b>#2</b><br /><p>All evidence is anecdotal.</p>

<p>You can't ever find published studies that show the general superiority of one language over another because there are too many confounds:</p>

<ul>
<li>Individual programmers differ greatly in ability</li>
<li>Some tasks are more amenable to a given language/library than others (what constitues representative set of tasks?)</li>
<li>Different languages have different core libraries</li>
<li>Different languages have different tool chains</li>
<li>Interaction of two or more of the above (e.g. familiarity of programmer X with tools Y)</li>
<li>etc. the list goes on and on and on</li>
</ul>

<p>Even though you can design experiments to control for some of these, the variability still requires a huge amount of statistical power to get any meaningful result, and no one ever does studies where like 1000 programmers do the exact same task in different languages, so there's never anything definitive.</p>

<p>The upshot is, each of us knows what the best languages/tools are, and so we can advocate them without fear of being shot down by a published study.  :)</p>
<br /><b>#3</b><br /><p>General claims about productivity do not necessarily make sense. A good software engineer (or project manager) knows what language to pick based on the nature of the project, the requirements of the customer, and the skills of his team.</p>

<p>There is generally no "one language to rule them all", though there are clearly languages that are better for certain domains. I would not write distributed enterprise applications or device drivers in perl, or games in prolog, but there are great uses for them.</p>

<p>Productivity also depends on tool support (e.g., are there good Python IDEs?), on skills, and on the possibility for practitioners to mess up. I am generally wary of functional programming in the hands of the average programmer. </p>

<p>If Python automates or simplifies tasks that Java developers building the same applications would frequently have to do, then yes, it may be more productive, but any evidence you get would still be anecdotal.</p>
<br /><b>#4</b><br /><p>You can't measure it, but if you're experienced with Java, and then you learn python and try to do stuff with it, you will realize it by yourself. </p>

<p>It's one of those things that can't be quantified, and frankly even if there was a statistical study, I wouldn't be convinced by it. You can bring a Java guru and a python newbie and give them a task that is better done with java (maybe because there's a specific library or even built-in functionality for it), and <em>maybe</em> in that case the Java guru will be "more productive" than the python newbie.</p>

<p>Some people mention IDEs, in my opinion, you can be productive with python even without an IDE, specially without a beast like Eclipse. You don't have cheked exceptions in python, so you don't need a tool to help you deal with that. Because everything in python is dynamic, you don't have "virtual" methods (although you can mimic them if you really want), so you don't need a tool to help you deal with writing stubs and whatnot. etc. Many things in Java that require an IDE are simply not applicable to python. The only useful thing an IDE in python would do is auto-complete and maybe an interactive shell in the same editor window.</p>

<p>OK, here's the thing about the "terse" argument: Java has so much clutter overhead, i.e. public static void main! System.stdout.writeln (or what the hell was it?), remind me again how do you get input from the user? Yea, there's no specific way, you <em>always</em> end up writing a wrapper class around it!! Remind me again how do you read a file? which library do you have to import? oh, go read the API docs and browse through tons of stream readers and writers, while in python, it's just <code>open('filename')</code>. You can run through all lines of a text file by simply: <code>for line in open('filename'):</code>.</p>

<p>In Java there's so much overhead of words it just clutters your mind and diverts your attention from your main task. This overhead is a real hindrance, there's only about 7 items you could hold in your short term memory, <code>for line in file</code> fills one item; how many items do you need to fill if you use Java IOStream classes for that task? How many slots do you have left for thing related to the actual task you're doing?</p>
<br /><b>#5</b><br /><p>I think it really is going to depend on the programmer and what you want to do.  It's subjective.  Someone who is a Java God will outperform someone who is only good at python.  Any study that tries to blanketly state that will be far too broad in what it tries to accomplish.</p>
<br /><b>#6</b><br /><p>It's a poorly-conceived question, and as such can't be meaningfully answered.  If you came to me with a project proposal and asked me what language would be the most productive, the <em>last thing in the world</em> I would look at was a "scientific" comparison of how random programmers did implementing an algorithm in different languages.</p>

<p>I'd ask:</p>

<ul>
<li>What does the software have to do?</li>
<li>What technical constraints are there on the software?</li>
<li>Who will develop the software?</li>
<li>What methodology will they use?</li>
<li>How will the software be supported?</li>
<li>Who will maintain the software?</li>
</ul>

<p>At some stage of the game, I'd rely on "non-scientific" or "anecdotal" evidence to guide my decision-making.  I don't need a scientific study to tell me that I shouldn't be developing device drivers in a scripting language.  Nor do I need one to tell me that a team of C++ programmers is probably going to be able to implement a small project in C++ faster than they'd be able to in Python.</p>

<p>If at any point in this process, I reached for a study that demonstrated that some developers implemented a specific algorithm in Python twice as fast as other developers implemented it in Java, you'd fire me and get someone else to run the project, if you had any brains.</p>
<br /><b>#7</b><br /><p>I think the point about IDEs is a particularly strong one.  For example, is there a Python IDE on par with Eclipse, offering the same refactoring capabilities?  Conversely, does an IDE with strong refactoring capabilities promote less intelligent up-front design?</p>

<p>This just highlights the difficulty (or, rather the futility) of declaring one language more/less productive than another.</p>
<br /><b>#8</b><br /><p>Well, the very same google search points also a link to an <a href="http://www.artima.com/intv/speed.html" rel="nofollow">interview to GvR</a>, where he explain the reasons for the productivity gain. He lists, in particular:</p>

<ul>
<li>terser language, hence less typing</li>
<li>built-in data types</li>
<li>duck typing</li>
<li>rich set of standard libraries</li>
</ul>

<p>About the first point, some further data comes from Code Complete, where Python has an index of 6 equivalent lines of C code , while Java and C++ are on 2.5.</p>

<p>Whatever those numbers mean, something I personally like very much with python is the idea of pythonicity. Once you get it, the language is very coherent, and rarely you get the feeling that it gets in your way. This helps really a lot in focusing on the problem, instead of the implementation, and therefore achieving an higher development speed.</p>
<br /><b>#9</b><br /><p>I think there are cases where one or the other may be more productive, but the question I always ask is how would this language perform on a mixed team involving people who were not good at programming and would cause more problems than they solve, people who think they know everything and like to write tricky code using all the neat language features available, family oriented programmers who just want to go home at 5:00, etc.</p>

<p>I keep hearing these phrases like "if the programmer wants to shoot himself in the foot, let him", as though the speaker has never been on a team.</p>

<p>When on a project team like the one I just described, I would not consider a language that allowed me to "Shoot myself in the foot" if it also meant that any of my teammates could also shoot me in the foot.</p>

<p>The thing is, by definition most projects will either fail or, eventually, be maintained by a team of widely varying talents--so as far as I'm concerned, I have to assume that of all non-trivial projects.</p>
<br />