<h3>Question (ID-1710363):</h3><h2>What do you wish you'd known about when you started learning Python?</h2><p>I've decided to learn Python 3. For those that have gone before, what did you find most useful along the way and wish you'd known about sooner? </p>
<br /><h3>Answers (Total-29):</h3><b>#0</b><br /><p>I learned Python back before the 1.5.2 release, so the things that were key for me back then may not be the key things today.</p>

<p>That being said, a crucial thing that took me a little bit to realize, but I now consider crucial: much functionality that other languages would make intrinsic is actually made available by the standard library and the built-ins.</p>

<p>The language itself is small and simple, but until you're familiar with the built-ins and the "core parts" of the standard library (e.g., nowadays, <code>sys</code>, <code>itertools</code>, <code>collections</code>, <code>copy</code>, ...), you'll be reinventing the wheel over and over. So, the more time you invest in getting familiar with those parts, the smoother your progress will be.  Every time you have a task you want to do, that doesn't seem to be directly supported by the language, first ask yourself: what built-ins or modules in the standard library will make the task much simpler, or even do it all for me?  Sometimes there won't be any, but more often than not you'll find excellent solutions by proceeding with this mindset.</p>
<br /><b>#1</b><br /><p>List comprehension (makes a list cleanly):</p>

<pre><code>[x for x in y if x &gt; z]
</code></pre>

<p>Generator expansion (same as list comprehension but doesn't evaluate until it is used):</p>

<pre><code>(x for x in y if x &gt; z)
</code></pre>
<br /><b>#2</b><br /><ol>
<li>I wished I didn't know Java.</li>
<li>More functional programming. (see itertools module, list comprehension, map(), reduce() or filter())</li>
</ol>
<br /><b>#3</b><br /><p>Two brain-cramping things.  One of which doesn't apply to Python 3.</p>

<pre><code>a = 095
</code></pre>

<p>Doesn't work.  Why?  The leading zero is an octal literal.  The 9 is not valid in an octal literal.</p>

<pre><code>def foo( bar=[] ):
    bar.append( 1 )
    return bar
</code></pre>

<p>Doesn't work.  Why?  The mutable default object gets reused.</p>
<br /><b>#4</b><br /><p>Learn how to use  <a href="http://ipython.scipy.org/moin/" rel="nofollow">iPython</a>
It's got Tab completion.
View all the elements in your namespace with 'whos'.</p>

<p>After you import a module, it's easy to view the code:</p>

<pre><code>&gt;&gt;&gt; import os
&gt;&gt;&gt; os?? # this display the actual source of the method
&gt;&gt;&gt; help() # Python's interactive help. Fantastic!
</code></pre>

<p>Most Python modules are well documented; in theory, you could learn iPython and the rest of what you'd need to know could be learned through the same tool.</p>

<p>iPython also has a debug mode, pdb().
Finally, you can even use iPython as a python enabled command line. The basic UNIX commands work as %magic methods. Any commands that aren't magic command can be executed:</p>

<pre><code>&gt;&gt;&gt; os.system('cp file1 file2')
</code></pre>
<br /><b>#5</b><br /><p>Don't have variable names that are types. For example, don't name a variable "file" or "dict"</p>
<br /><b>#6</b><br /><p>Decorators.  Writing your own is not something you might want to do right away, but knowing that <code>@staticmethod</code> and <code>@classmethod</code> are available from the beginning (and the difference between what they do) is a real plus.</p>
<br /><b>#7</b><br /><ul>
<li>What <code>enumerate</code> is for.</li>
<li>That <code>seq = seq.append(item)</code> and <code>seq = seq.sort()</code> both set <code>seq</code> to <code>None</code>.</li>
<li>Using <code>set</code> to remove duplicates.</li>
<li>Pretty much everything in the <code>itertools</code> and <code>collections</code> modules.</li>
<li>How the <code>*</code> and <code>**</code> prefixes for function arguments work.</li>
<li>How default arguments to functions work internally (i.e. what <code>f.func_defaults</code> is).</li>
<li>How (why, really) to design functions so that they are useful in conjunction with <code>map</code> and <code>zip</code>.</li>
<li>The role of <code>__dict__</code> in classes.</li>
<li>What <code>import</code> actually does.</li>
</ul>
<br /><b>#8</b><br /><ul>
<li>using <code>help()</code> in the shell on any object, class or path</li>
<li>you can run <code>import code;
code.interact(local=locals())</code> anywhere in your code and it will start a python shell at that exact point</li>
<li>you can run <code>python -i yourscript.py</code> to start a shell at the end of yourscript.py</li>
</ul>
<br /><b>#9</b><br /><p>Most helpful: <a href="http://www.diveintopython.org/" rel="nofollow">Dive Into Python</a>. As a commenter points out, if you're learning Python 3, <a href="http://diveintopython3.org/" rel="nofollow">Dive Into Python 3</a> is more applicable.</p>

<p>Known about sooner: <a href="http://pypi.python.org/pypi/virtualenv" rel="nofollow">virtualenv</a>.</p>
<br /><b>#10</b><br /><p><a href="http://docs.python.org/tutorial/datastructures.html#list-comprehensions" rel="nofollow">List comprehensions</a>, if you're coming to Python fresh (not from an earlier version). </p>
<br /><b>#11</b><br /><p>I implemented plenty of recursive directory walks by hand before I learned about os.walk()</p>
<br /><b>#12</b><br /><p>Closures. Clean and concise, without having to resort to using a Strategy Pattern unlike languages such as Java</p>
<br /><b>#13</b><br /><p>Lambda functions</p>

<p><a href="http://www.diveintopython.org/power%5Fof%5Fintrospection/lambda%5Ffunctions.html" rel="nofollow">http://www.diveintopython.org/power_of_introspection/lambda_functions.html</a></p>
<br /><b>#14</b><br /><p>If you learn from a good book, it will not only teach you the language, it will teach you the common idioms.  The idioms are valuable.</p>

<p>For example, here is the standard idiom for initializing a class instance with a list:</p>

<pre><code>class Foo(object):
    def __init__(self, lst=None):
        if lst is None:
            self.lst = []
        else:
            self.lst = lst
</code></pre>

<p>If you learn this as an idiom from a book, you don't have to learn the hard way <em>why</em> this is the standard idiom.  @S.Lott already explained this one: if you try to make the default initializer be an empty list, the empty list gets evaluated just once (at compile time) and every default-initialized instance of your class gets the <em>same</em> list instance, which was not what was intended here.</p>

<p>Some idioms protect you from non-intended effects; some help you get best performance out of the language; and some are just small points of style, which help other Python fans understand your code better.</p>

<p>I learned out of the book <a href="http://www.rmi.net/~lutz/about-lp.html" rel="nofollow">Learning Python</a> and it introduced me to some of the idioms.</p>

<p>Here's a web page devoted to idioms:  <a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html" rel="nofollow">http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html</a></p>

<p>P.S. Python code that follows the best-practice Python idioms often is called "Pythonic" code.</p>
<br /><b>#15</b><br /><p>That a tuple of a single item must end with a comma, or it won't be interpreted as a tuple. </p>

<p>pprint() is very handy (yes, 2 p's) </p>

<p>reload() is useful when you're re-testing a module while making lots of rapid changes to a dependent module. </p>

<p>And learn as many common "idioms" as you can, otherwise you'll bang your head looking for a better way to do something, when the idiom really is regarded as the best way (e.g. ugly expressions like ' '.join(), 
or the answer to why there is no isInt(string) function.... the answer is you can just wrap the usage of a "possible" integer with a try: and then catch the exception if it's not a valid int.  The solution works well, but it sounds like a terrible answer when you first encounter it, so you can waste a lot of time convincing yourself it really is a good approach. </p>

<p>Those are some things that wasted several hours of my time to determine that my first draft of some code which felt wrong, really was acceptable. </p>

<p>Readings from python.org:</p>

<p><a href="http://wiki.python.org/moin/BeginnerErrorsWithPythonProgramming" rel="nofollow">http://wiki.python.org/moin/BeginnerErrorsWithPythonProgramming</a>
<a href="http://wiki.python.org/moin/PythonWarts" rel="nofollow">http://wiki.python.org/moin/PythonWarts</a></p>
<br /><b>#16</b><br /><p>One of the coolest things I learned about recently was the commands module:</p>

<pre><code>&gt;&gt;&gt; import commands
&gt;&gt;&gt; commands.getoutput('uptime')
'18:24  up 10:22, 7 users, load averages: 0.37 0.45 0.41'
</code></pre>

<p>It's like os.popen or os.system but without all of the DeprecationWarnings.</p>

<p>And let's not forget PDB (Python Debugger):</p>

<pre><code>% python -m pdb poop.py
</code></pre>
<br /><b>#17</b><br /><p>When I started with python, started out with main methods from the examples. This was because I didn't know better, after that I found <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=4829" rel="nofollow">this</a> on how to create a better main method.</p>
<br /><b>#18</b><br /><p>Sequential imports overwrite:</p>

<p>If you import two files like this:</p>

<pre><code>from foo import *
from bar import *
</code></pre>

<p>If both foo.py and bar.py have a function named fubar(), having imported the files this way, when you call fubar, fubar as defined in bar.py will be executed. The best way to avoid this is to do this:</p>

<pre><code>import foo
import bar
</code></pre>

<p>and then call foo.fubar or bar.fubar. This way, you ALWAYS know which file's definition of fubar will be executed.</p>
<br /><b>#19</b><br /><p>I wish I'd known right off the bat how to code idiomatically in Python. You can pick up any language you like and start coding in it like it's C, Java, etc. but ideally you'll learn to code in "the spirit" of the language. Python is particularly relevant, as I think it has a definite style of its own.</p>

<p>While I found it a little later in my Python career than I would have liked, this excellent article wraps up many Python idioms and the little tricks that make it special. Several of the things people have mentioned in their answers so far are contained within:
<a href="http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html" rel="nofollow">Code Like a Pythonista: Idiomatic Python</a>.</p>

<p>Enjoy!</p>
<br /><b>#20</b><br /><p>Dropping into interactive mode in IPython</p>

<pre><code>from IPython.Shell import IPShellEmbed
ipshell = IPShellEmbed()
ipshell()
</code></pre>
<br /><b>#21</b><br /><p>Pretty printing:</p>

<pre><code>&gt;&gt;&gt; print "%s world" %('hello')
hello world
</code></pre>

<p>%s for string</p>

<p>%d for integer</p>

<p>%f for float</p>

<p>%.xf for exactly x many decimal places of a float. If the float has lesser decimals that indicated, then 0s are added</p>
<br /><b>#22</b><br /><p>Maybe a touch more advanced, but I wish I'd known that you don't use threads to take advantage of multiple cores in (C)python.  You use the <code>multiprocessing</code> library.</p>
<br /><b>#23</b><br /><p>Tab completion and general readline support, including histories, even in the regular python shell.</p>

<pre><code>$ cat ~/.pythonrc.py 
#!/usr/bin/env python

try:
    import readline
except ImportError:
    print("Module readline not available.")
else:
    import rlcompleter
    readline.parse_and_bind("tab: complete")

    import os
    histfile = os.path.join(os.environ["HOME"], ".pyhist")
    try:
        readline.read_history_file(histfile)
    except IOError:
        pass
    import atexit
    atexit.register(readline.write_history_file, histfile)
    del os, histfile
</code></pre>

<p>and then add a line to your .bashrc</p>

<pre><code>export PYTHONSTARTUP=~/.pythonrc.py
</code></pre>

<p>These two things lead to an exploratory programming style of "it looks like this library might do what I want", so then I fire up the python shell and then poke around using tab-completion and the help() command until I find what I need.</p>

<p>Generators and list comprehensions are more useful than you might think.  Don't just ignore them.</p>
<br /><b>#24</b><br /><p>I really like list comprehension and all other semifunctional constructs. I wish I had known those when I was in my first Python project.</p>
<br /><b>#25</b><br /><p>What I really liked: List comprehensions, closures (and high-order functions), tuples, lambda functions, painless bignumbers.</p>

<p>What I wish I had known about sooner: The fact that using Python idioms in code (e.g. list comprehensions instead of loops over lists) was faster.</p>
<br /><b>#26</b><br /><p>I wish I knew well a functional language. After playing a bit with Clojure, I realized that lots of Python's functional ideas are borrowed from Lisp or other functional langs</p>
<br /><b>#27</b><br /><p>That multi-core was the future.  Still love Python.  It's writes a fair bit of my code for me.</p>
<br /><b>#28</b><br /><p>Functional programming tools, like <code>all</code> and <code>any</code></p>
<br />