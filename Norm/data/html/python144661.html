<h3>Question (ID-144661):</h3><h2>Python Vs. Ruby for Metaprogramming</h2><p>I'm currently primarily a D programmer and am looking to add another language to my toolbox, preferably one that supports the metaprogramming hacks that just can't be done in a statically compiled language like D.  I've read up on Lisp a little and I would love to find a language that allows some of the cool stuff that Lisp does, but without the strange syntax, etc. of Lisp.  I don't want to start a language flame war, and I'm sure both Ruby and Python have their tradeoffs, so I'll list what's important to me personally.  Please tell me whether Ruby, Python, or some other language would be best for me.</p>

<p>Important:</p>

<ol>
<li>Good metaprogramming.  Ability to create classes, methods, functions, etc. at runtime.  Preferably, minimal distinction between code and data, Lisp style.</li>
<li>Nice, clean, sane syntax and consistent, intuitive semantics.  Basically a well thought-out, fun to use, modern language.</li>
<li>Multiple paradigms.  No one paradigm is right for every project, or even every small subproblem within a project.</li>
<li>An interesting language that actually affects the way one thinks about programming.</li>
</ol>

<p>Somewhat important:</p>

<ol>
<li>Performance.  It would be nice if performance was decent, but when performance is a real priority, I'll use D instead.</li>
<li>Well-documented.  </li>
</ol>

<p>Not important:</p>

<ol>
<li>Community size, library availability, etc.  None of these are characteristics of the language itself, and all can change very quickly.</li>
<li>Job availability.  I am not a full-time, professional programmer.  I am a grad student and programming is tangentially relevant to my research.</li>
<li>Any features that are primarily designed with very large projects worked on by a million code monkeys in mind.</li>
</ol>
<br /><h3>Answers (Total-30):</h3><b>#0</b><br /><p>" I've read up on Lisp a little and I would love to find a language that allows some of the cool stuff that Lisp does, but without the strange syntax, etc. of Lisp."</p>

<p>Wouldn't we all.  </p>

<p>"minimal distinction between code and data, Lisp style"</p>

<p>Sadly, the minimal distinction between code and data and "strange" syntax are consequences of each other.</p>

<p>If you want easy-to-read syntax, you have Python.  However, the code is <em>not</em> represented in any of the commonly-used built-in data structures.  It fails -- as most languages do -- in item #1 of your 'important' list.  That makes it difficult to provide useful help.</p>

<p>You can't have it all.  Remember, you aren't the first to have this thought.  If something like your ideal language existed, we'd all be using it.  Since the real world falls short of your ideals, you'll have to re-prioritize your wishlist.  The "important" section has to be rearranged to identify what's <em>really</em> important to you.</p>
<br /><b>#1</b><br /><p>Disclaimer: I only dabble in either language, but I have at least written small working programs (not just quick scripts, for which I use Perl, bash or GNU make) in both.</p>

<p>Ruby can be really nice for the "multiple paradigms" point 3, because it works hard to make it easy to create domain-specific languages. For example, browse online and look at a couple of bits of Ruby on Rails code, and a couple of bits of Rake code. They're both Ruby, and you can see the similarities, but they don't look like what you'd normally think of as the same language.</p>

<p>Python seems to me to be a bit more predictable (possibly correlated to 'clean' and 'sane' point 2), but I don't really know whether that's because of the language itself or just that it's typically used by people with different values. I have never attempted deep magic in Python. I would certainly say that both languages are well thought out.</p>

<p>Both score well in 1 and 4. [Edit: actually 1 is pretty arguable - there is "eval" in both, as common in interpreted languages, but they're hardly conceptually pure. You can define closures, assign methods to objects, and whatnot. Not sure whether this goes as far as you want.]</p>

<p>Personally I find Ruby more fun, but in part that's because it's easier to get distracted thinking of cool ways to do things. I've actually used Python more. Sometimes you don't want cool, you want to get on with it so it's done before bedtime...</p>

<p>Neither of them is difficult to get into, so you could just decide to do your next minor task in one, and the one after that in the other. Or pick up an introductory book on each from the library, skim-read them both and see what grabs you.</p>
<br /><b>#2</b><br /><p>Honestly, as far as metaprogramming facilities go, Ruby and Python are a lot more similar than some of their adherent like to admit.  This review of both language offers a pretty good comparison/review:</p>

<ul>
<li><a href="http://regebro.wordpress.com/2009/07/12/python-vs-ruby/" rel="nofollow">http://regebro.wordpress.com/2009/07/12/python-vs-ruby/</a></li>
</ul>

<p>So, just pick one based on some criteria.  Maybe you like Rails and want to study that code.  Maybe SciPy is your thing.  Look at the ecosystem of libraries, community, etc, and pick one.  You certainly won't lose out on some metaprogramming nirvana based on your choice of either.</p>
<br /><b>#3</b><br /><p>Have you considered Smalltalk? It offers a very simple, clear and extensible syntax with reflectivity and introspection capabilities and a fully integrated development environment that takes advantage of those capabilities. Have a look at <a href="http://squeak.org/Features/Research/" rel="nofollow">some of the work being done</a> in <a href="http://squeak.org/" rel="nofollow">Squeak Smalltalk</a> for instance. A lot of researchers using Squeak hang out on the <a href="http://lists.squeakfoundation.org/pipermail/squeak-dev/" rel="nofollow">Squeak mailing list</a> and #squeak on freenode, so you can get help on complex issues very easily.</p>

<p>Other indicators of its current relevance: it runs on any platform you'd care to name (including the <a href="http://isqueak.org/HomePage" rel="nofollow">iPhone</a>); Gilad Bracha is basing his Newspeak work on Squeak; the V8 team cut their teeth on <a href="http://astares.blogspot.com/2008/09/google-chrome-javascript-and-smalltalk.html" rel="nofollow">Smalltalk VMs</a>; and Dan Ingalls and Randal Schwartz have recently returned to Smalltalk work after years in the wilderness.</p>

<p>Best of luck with your search - let us know what you decide in the end.</p>
<br /><b>#4</b><br /><p>You are describing Ruby.</p>

<blockquote>
  <ul>
  <li>Good metaprogramming. Ability to create classes, methods, functions,
  etc. at runtime. Preferably, minimal
  distinction between code and data,
  Lisp style.</li>
  </ul>
</blockquote>

<p>It's very easy to extend <em>and</em> modify existing primitives at runtime. In ruby everything is an object, strings, integers, even functions.</p>

<p>You can also construct shortcuts for syntactic sugar, for example with <a href="http://www.neeraj.name/blog/articles/235" rel="nofollow">class_eval</a>.</p>

<blockquote>
  <ul>
  <li>Nice, clean, sane syntax and consistent, intuitive semantics.
  Basically a well thought-out, fun to
  use, modern language.</li>
  </ul>
</blockquote>

<p>Ruby follows the <a href="http://en.wikipedia.org/wiki/Principle_of_least_surprise" rel="nofollow">principle of less surprise</a>, and when comparing Ruby code vs the equivalent in other language many people consider it more "beautiful".</p>

<blockquote>
  <ul>
  <li>Multiple paradigms. No one paradigm is right for every project,
  or even every small subproblem within
  a project.</li>
  </ul>
</blockquote>

<p>You can follow imperative, object oriented, functional and reflective.</p>

<blockquote>
  <ul>
  <li>An interesting language that actually affects the way one thinks
  about programming.</li>
  </ul>
</blockquote>

<p>That's very subjective, but from my point of view the ability to use many paradigms at the same time allows for very interesting ideas.</p>

<p>I've tried Python and it doesn't fit your important points.</p>
<br /><b>#5</b><br /><p>Lisp satisfies all your criteria, including performance, and it is the only language that doesn't have (strange) syntax. If you eschew it on such an astoundingly ill-informed/wrong-headed basis and consequently miss out on the experience of using e.g. Emacs+SLIME+CL, you'll be doing yourself a great disservice.</p>
<br /><b>#6</b><br /><p>Your 4 "important" points lead to Ruby exactly, while the 2 "somewhat important" points ruled by Python. So be it.</p>
<br /><b>#7</b><br /><p>There's not really a huge difference between python and ruby at least at an ideological level.  For the most part, they're just different flavors of the same thing.  Thus, I would recommend seeing which one matches your programming style more.</p>
<br /><b>#8</b><br /><p>Compare <a href="http://news.ycombinator.com/item?id=408030" rel="nofollow">code examples</a> that do the same thing (join with a newline non-empty descriptions of items from a <code>myList</code> list) in different languages (languages are arranged in reverse-alphabetic order):</p>

<p><strong>Ruby</strong>:</p>

<pre><code>myList.collect { |f| f.description }.select { |d| d != "" }.join("\n")
</code></pre>

<p>Or</p>

<pre><code>myList.map(&amp;:description).reject(&amp;:empty?).join("\n")
</code></pre>

<p><strong>Python</strong>:</p>

<pre><code>descriptions = (f.description() for f in mylist)
"\n".join(filter(len, descriptions))
</code></pre>

<p>Or</p>

<pre><code>"\n".join(f.description() for f in mylist if f.description())
</code></pre>

<p><strong>Perl</strong>:</p>

<pre><code>join "\n", grep { $_ } map { $_-&gt;description } @myList;
</code></pre>

<p>Or</p>

<pre><code>join "\n", grep /./, map { $_-&gt;description } @myList;
</code></pre>

<p><strong>Javascript</strong>:</p>

<pre><code>myList.map(function(e) e.description())
      .filter(function(e) e).join("\n")
</code></pre>

<p><strong>Io</strong>:</p>

<pre><code>myList collect(description) select(!="") join("\n")
</code></pre>

<p>Here's an <a href="http://www.iolanguage.com/scm/git/checkout/Io/docs/IoGuide.html" rel="nofollow">Io guide</a>.</p>
<br /><b>#9</b><br /><p>Ruby would be better than Lisp in terms of being "mainstream" (whatever that <em>really</em> means, but one realistic concern is how easy it would be to find answers to your questions on Lisp programming if you were to go with that.)  In any case, I found Ruby very easy to pick up.  In the same amount of time that I had spent first learning Python (or other languages for that matter), I was soon writing <em>better</em> code much <em>more efficiently</em> than I ever had before.  That's just one person's opinion, though; take it with a grain of salt, I guess.  I know much more about Ruby at this point than I do Python or Lisp, but you should know that I was a Python person for quite a while before I switched.</p>

<p>Lisp is definitely quite cool and worth looking into; as you said, the size of community, etc. can change quite quickly.  That being said, the size itself isn't as important as the <em>quality</em> of the community.  For example, the <code>#ruby-lang</code> channel is still filled with some incredibly smart people.  Lisp seems to attract some really smart people too.  I can't speak much about the Python community as I don't have a lot of firsthand experience, but it seems to be "too big" sometimes.  (I remember people being quite rude on their IRC channel, and from what I've heard from friends that are really into Python, that seems to be the rule rather than the exception.)</p>

<p>Anyway, some resources that you might find useful are:</p>

<p>1) The Pragmatic Programmers Ruby Metaprogramming series (<a href="http://www.pragprog.com/screencasts/v-dtrubyom/the-ruby-object-model-and-metaprogramming" rel="nofollow">http://www.pragprog.com/screencasts/v-dtrubyom/the-ruby-object-model-and-metaprogramming</a>) -- not free, but the later episodes are quite intriguing.  (The code is free, if you want to download it and see what you'd be learning about.)</p>

<p>2) On Lisp by Paul Graham (<a href="http://www.paulgraham.com/onlisp.html" rel="nofollow">http://www.paulgraham.com/onlisp.html</a>).  It's a little old, but it's a classic (and downloadable for free).</p>
<br /><b>#10</b><br /><p>I am using Python for many projects and I think Python does provide all the features you asked for. </p>

<p>important:</p>

<ol>
<li>Metaprogramming: Python supports metaclasses and runtime class/method generation etc</li>
<li>Syntax: Well thats somehow subjective. I like Pythons syntax for its simplicity, but some People complain that Python is whitespace-sensitive.</li>
<li>Paradigms: Python supports procedural, object-oriented and basic functional programming. </li>
<li>I think Python has a very practical oriented style, it was very inspiring for me.</li>
</ol>

<p>Somewhat important:</p>

<ol>
<li>Performance: Well its a scripting language. But writing C extensions for Python is a common optimization practice. </li>
<li>Documentation: I cannot complain. Its not that detailed as someone may know from Java, but its good enough.</li>
</ol>

<p>As you are grad student you may want to read this paper claiming that <a href="http://openwetware.org/wiki/Julius_B._Lucks/Projects/Python_All_A_Scientist_Needs" rel="nofollow">Python is all a scientist needs</a>.
Unfortunately I cannot compare Python to Ruby, since I never used that language. </p>

<p>Regards,
Dennis</p>
<br /><b>#11</b><br /><p>Well, if you don't like the lisp syntax perhaps assembler is the way to go. :-)</p>

<p>It certainly has minimal distinction between code and data, is multi-paradigm (or maybe that is no-paradigm) and it's a mind expanding (if tedious) experience both in terms of the learning and the tricks you can do.</p>
<br /><b>#12</b><br /><p>Io satisfies all of your "Important" points. I don't think there's a better language out there for doing crazy meta hackery.</p>
<br /><b>#13</b><br /><blockquote>
  <p>one that supports the metaprogramming hacks that just <strong>can't be done in a statically compiled language</strong></p>
  
  <p>I would love to find a language that allows some of the cool stuff that <strong>Lisp</strong> does</p>
</blockquote>

<p>Lisp can be compiled.</p>
<br /><b>#14</b><br /><p>There isn't really a lot to separate Python and Ruby.  I'd say the Python community is larger and more mature than the Ruby community, and that's really important for me.  Ruby is a more flexible language, which has positive and negative repercussions.  However, I'm sure there will be plenty of people to go into detail on both these languages, so I'll throw a third option into the ring.  How about JavaScript?</p>

<p>JavaScript was originally designed to be Scheme for the web, and it's prototype-based, which is an advantage over Python and Ruby as far as multi-paradigm and metaprogramming is concerned.  The syntax isn't as nice as the other two, but it is probably the most widely deployed language in existence, and performance is getting better every day.</p>
<br /><b>#15</b><br /><p>If you like the lisp-style code-is-data concept, but don't like the Lispy syntax, maybe <a href="http://sics.se/sicstus" rel="nofollow">Prolog</a> would be a good choice.</p>

<p>Whether that qualifies as a "fun to use, modern language", I'll leave to others to judge. ;-)</p>
<br /><b>#16</b><br /><p>I've use Python a very bit, but much more Ruby. However I'd argue they both provide what you asked for. </p>

<p>If I see all your four points then you may at least check:
<a href="http://www.iolanguage.com/" rel="nofollow">http://www.iolanguage.com/</a></p>

<p>And Mozart/Oz may be interesting for you also:
<a href="http://www.mozart-oz.org/" rel="nofollow">http://www.mozart-oz.org/</a></p>

<p>Regards
Friedrich</p>
<br /><b>#17</b><br /><p>Ruby is my choice after exploring Python, Smalltalk, and Ruby.</p>
<br /><b>#18</b><br /><h2>What about OCaml ?</h2>

<p>OCaml features: a static type system, type inference, parametric polymorphism, tail recursion, pattern matching, first class lexical closures, functors (parametric modules), exception handling, and incremental generational automatic garbage collection.</p>

<p>I think that it satisfies the following:</p>

<blockquote>
  <p>Important:</p>
  
  <ol>
  <li>Nice, clean, sane syntax and consistent, intuitive semantics. Basically a well thought-out, fun to use, modern language.</li>
  <li>Multiple paradigms. No one paradigm is right for every project, or even every small subproblem within a project.</li>
  <li>An interesting language that actually affects the way one thinks about programming.</li>
  </ol>
  
  <p>Somewhat important:</p>
  
  <ol>
  <li>Performance. It would be nice if performance was decent, but when performance is a real priority, I'll use D instead.</li>
  <li>Well-documented.</li>
  </ol>
</blockquote>
<br /><b>#19</b><br /><p>For python-style syntax and lisp-like macros (macros that are real code) and good DSL see <a href="http://convergepl.org/" rel="nofollow">converge</a>.</p>
<br /><b>#20</b><br /><p>I'm not sure that Python would fulfill all things you desire (especially the point about the minimal distinction between code and data), but there is one argument in favour of python. There is a project out there which makes it easy for you to program extensions for python in D, so you can have the best of both worlds. <a href="http://pyd.dsource.org/celerid.html" rel="nofollow">http://pyd.dsource.org/celerid.html</a></p>
<br /><b>#21</b><br /><p>Did you try Rebol?</p>
<br /><b>#22</b><br /><p>I suggest that you try out both languages and pick the one that appeals to you. Both Python and Ruby can do what you want.</p>

<p>Also read <a href="http://stackoverflow.com/questions/143586/what-scripting-language-to-learn-after-perl">this thread</a>.</p>
<br /><b>#23</b><br /><p>if you love the rose, you have to learn to live with the thorns :)</p>
<br /><b>#24</b><br /><p>Go with JS just check out AJS (Alternative JavaScript Syntax) at my github <a href="http://github.com/visionmedia" rel="nofollow">http://github.com/visionmedia</a>  it will give you some cleaner looking closures etc :D</p>
<br /><b>#25</b><br /><p>Concerning your main-point (meta-programming):
Version 1.6 of Groovy has AST (Abstract Syntax Tree) programming built-in as a standard and integrated feature.
Ruby has RubyParser, but it's an add-on. </p>
<br /><b>#26</b><br /><p>Do not to mix Ruby Programming Language with Ruby Implementations, thinking that POSIX threads are not possible in ruby.</p>

<p>You can simply compile with pthread support, and <a href="http://blogs.sun.com/prashant/entry/ruby_and_enable_pthreads" rel="nofollow">this was already possible at the time this thread was created</a>, if you pardon the pun.</p>

<p>The answer to this question is simple. If you like lisp, you will probably prefer ruby. Or, whatever you like.</p>
<br /><b>#27</b><br /><p>I recommend Ruby because it corresponds well to your requirements. About Python there is little I can say, because ruby is enough for most tasks.
In Python I like indentation-sensitive and "there should be one—and preferably only one—obvious way to do it". It is very convenient.</p>
<br /><b>#28</b><br /><p>@Jason I respectively disagree. There are differences that make Ruby superior to Python for metaprogramming - both philosophical and pragmatic. For starters, <a href="http://techoctave.com/c7/posts/46-object-oriented-ruby-classes-mixins-and-jedi" rel="nofollow">Ruby gets inheritance right with Single Inheritance and Mixins</a>. And when it comes to metaprogramming you simply need to understand that it's all about the <em>self</em>. The canonical difference here is that in Ruby you have access to the <em>self</em> object at runtime - in Python you do not!</p>

<p>Unlike Python, in Ruby there is no separate compile or runtime phase. In Ruby, every line of code is executed against a particular <em>self</em> object. In Ruby every class inherits from both object and a hidden metaclass. This makes for some interesting dynamics:</p>

<pre><code>class Ninja
  def rank
    puts "Orange Clan"
  end

  self.name #=&gt; "Ninja"
end
</code></pre>

<p>Using <em>self.name</em> accesses the Ninja classes' metaclass <em>name</em> method to return the class name of Ninja. Does metaprogramming flower so beautiful in Python? I sincerely doubt it!</p>
<br /><b>#29</b><br /><p>On the subject of Ruby vs Python: as far as Linux administration goes - Python wins, hands down.  Try spawning real POSIX threads in Ruby.... umm I didn't think so.  Try implementing a true POSIX daemon in Ruby.... I didn't think so.  Try integrating C modules with Ruby or writing your own C extensions... Python is way better for that.  Having said all of this, Ruby has a very expressive syntax, and Rails is a great web application framework.  But so is Django for Python!</p>
<br />