<h3>Question (ID-2573135):</h3><h2>Python progression path - From apprentice to guru</h2><p>I've been learning, working, and playing with Python for a year and a half now. As a biologist slowly making the turn to bio-informatics, this language has been a the very core of all the major contributions I have made in the lab. I more or less fell in love with the way Python permits me to express beautiful solutions and also with the semantics of the language that allows such a natural flow from thoughts to workable code.</p>

<p>What I would like to know is your answer to a kind of question I have seldom seen in this or other forums. This question seems central to me for anyone on the path to Python improvement but who wonders what his next steps should be.</p>

<p>Let me sum up what I do NOT want to ask first ;)</p>

<ul>
<li>I don't want to know how to QUICKLY learn Python</li>
<li>Nor do I want to find out the best way to get acquainted with the language</li>
<li>Finally, I don't want to know a 'one trick that does it all' approach.</li>
</ul>

<p>What I do want to know your opinion about, is:</p>

<p><strong>What are the steps YOU would recommend to a Python journeyman, from apprenticeship to guru status (feel free to stop wherever your expertise dictates it), in order that one IMPROVES CONSTANTLY, becoming a better and better Python coder, one step at a time. Some of the people on SO almost seem worthy of worship for their Python prowess, please enlighten us :)</strong></p>

<p>The kind of answers I would enjoy (but feel free to surprise the readership :P ), is formatted more or less like this:</p>

<ul>
<li>Read this (eg: python tutorial), pay attention to that kind of details</li>
<li>Code for so manytime/problems/lines of code</li>
<li>Then, read this (eg: this or that book), but this time, pay attention to this</li>
<li>Tackle a few real-life problems</li>
<li>Then, proceed to reading Y.</li>
<li>Be sure to grasp these concepts</li>
<li>Code for X time</li>
<li>Come back to such and such basics or move further to...</li>
<li>(you get the point :)</li>
</ul>

<p>I really care about knowing your opinion on what exactly one should pay attention to, at various stages, in order to progress CONSTANTLY (with due efforts, of course). If you come from a specific field of expertise, discuss the path you see as appropriate in this field.</p>

<p>EDIT: Thanks to your great input, I'm back on the Python improvement track! I really appreciate!</p>
<br /><h3>Answers (Total-19):</h3><b>#0</b><br /><p>I thought the process of Python mastery went something like:</p>

<ol>
<li>Discover <a href="http://en.wikipedia.org/wiki/List_comprehension#Python" rel="nofollow">list comprehensions</a></li>
<li>Discover <a href="http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Generators" rel="nofollow">generators</a></li>
<li>Incorporate <a href="http://docs.python.org/library/functions.html" rel="nofollow">map, reduce, filter, iter, range, xrange</a> often into your code</li>
<li>Discover <a href="http://wiki.python.org/moin/PythonDecorators" rel="nofollow">Decorators</a></li>
<li>Write recursive functions, a lot</li>
<li>Discover <a href="http://docs.python.org/library/itertools.html" rel="nofollow">itertools</a> and <a href="http://docs.python.org/library/functools.html" rel="nofollow">functools</a></li>
<li>Read <a href="http://rads.stackoverflow.com/amzn/click/0596514980" rel="nofollow">Real World Haskell</a></li>
<li>Rewrite all your old Python code with tons of higher order functions, recursion, and whatnot.</li>
<li>Annoy your cubicle mates every time they present you with a Python class.  Claim it could be "better" implemented as a dictionary plus some functions.  Embrace functional programming.</li>
<li>Rediscover the <a href="http://en.wikipedia.org/wiki/Strategy_pattern#Python" rel="nofollow">Strategy</a> pattern and then <a href="http://rads.stackoverflow.com/amzn/click/0596007124" rel="nofollow">all those things</a> from imperative code you tried so hard to forget after Haskell.</li>
<li>Find a balance.</li>
</ol>
<br /><b>#1</b><br /><p>One good way to further your Python knowledge is to <strong>dig into the source code of the libraries, platforms, and frameworks you use already.</strong></p>

<p>For example if you're building a site on <a href="http://www.djangoproject.com/" rel="nofollow">Django</a>, many questions that might stump you can be answered by looking at how Django implements the feature in question.</p>

<p>This way you'll continue to <strong>pick up new idioms, coding styles, and Python tricks</strong>.  (Some will be good and some will be bad.)</p>

<p>And when you see something Pythony that you don't understand in the source, <strong>hop over to the #python IRC channel</strong> and you'll find plenty of "language lawyers" happy to explain.</p>

<p>An accumulation of these little clarifications over years leads to a much deeper understanding of the language and all of its ins and outs.</p>
<br /><b>#2</b><br /><p><strong>Understand (more deeply) Python's data types and their roles with regards to memory mgmt</strong></p>

<p>As some of you in the community are aware, <a href="http://cyberwebconsulting.com" rel="nofollow">I teach Python courses</a>, the most popular ones being the comprehensive Intro+Intermediate course as well as an "advanced" course which introduces a variety of areas of application development.</p>

<p>Quite often, I get asked a question quite similar to, "Should I take your intro or advanced course? I've already been programming Python for 1-2 years, and I think the intro one is too simple for me so I'd like to jump straight to the advanced... which course would <em>you</em> recommend?"</p>

<p>To answer their question, I probe to see how strong they are in this area -- not that it's really the best way to measure whether they're ready for any advanced course, but to see how well their basic knowledge is of Python's objects and memory model, which is a cause of <em>many</em> Python bugs written by those who are not only beginners but those who have gone beyond that.</p>

<p>To do this, I point them at this simple 2-part quiz question:
<img src="http://imgur.com/6dxRh.png" alt="Ex1: x=42; y=x; x+=1; print x,y Ex2: x=[1,2,3];y=x;x[0]=4;print x,y"></p>

<p>Many times, they are able to get the output, but the <em>why</em> is more difficult and much more important of an response... I would weigh the output as 20% of the answer while the "why" gets 80% credit. If they can't get the why, regardless how Python experience they have, I will always steer people to the comprehensive intro+intermediate course because I spend one lecture on objects and memory management to the point where you should be able to answer with the output and the why with sufficient confidence. (Just because you know Python's syntax after 1-2 years doesn't make you ready to move beyond a "beginner" label until you have a much better understanding as far as how Python works under the covers.)</p>

<p>A succeeding inquiry requiring a similar answer is even tougher, e.g.,</p>

<p><strong>Example 3</strong></p>

<pre><code>x = ['foo', [1,2,3], 10.4]
y = list(x) # or x[:]
y[0] = 'fooooooo'
y[1][0] = 4
print x
print y
</code></pre>

<p>The next topics I recommend are to understanding reference counting well, learning what "interning" means (but not necessarily using it), learning about shallow and deep copies (as in Example 3 above), and finally, the interrelationships between the various types and constructs in the language, i.e. lists vs. tuples, dicts vs. sets, list comprehensions vs. generator expressions, iterators vs. generators, etc.; however all those other suggestions are another post for another time. Hope this helps in the meantime! :-)</p>

<p>ps. I agree with the other responses for getting more intimate with introspection as well as studying other projects' source code and add a strong "+1" to both suggestions!</p>

<p>pps. Great question BTW. I wish I was smart enough in the beginning to have asked something like this, but that was a long time ago, and now I'm trying to help others with my many years of full-time Python programming!!</p>
<br /><b>#3</b><br /><p><strong>Understand Introspection</strong></p>

<ul>
<li>write a <code>dir()</code> equivalent</li>
<li>write a <code>type()</code> equivalent</li>
<li>figure out how to <a href="http://en.wikipedia.org/wiki/Monkey_patch" rel="nofollow">"monkey-patch"</a></li>
<li>use the <code>dis</code> module to see how various language constructs work</li>
</ul>

<p>Doing these things will</p>

<ul>
<li>give you some good theoretical knowledge about how python is implemented</li>
<li>give you some good practical experience in lower-level programming</li>
<li>give you a good intuitive feel for python data structures</li>
</ul>
<br /><b>#4</b><br /><p>Check out Peter Norvig's essay on becoming a master programmer in 10 years: <a href="http://norvig.com/21-days.html" rel="nofollow">http://norvig.com/21-days.html</a>. I'd wager it holds true for any language. </p>
<br /><b>#5</b><br /><p>I'll give you the simplest and most effective piece of advice I think anybody could give you: <strong>code</strong>.</p>

<p>You can only be better at using a language (which implies understanding it) by <em>coding</em>. You have to actively enjoy coding, be inspired, ask questions, and find answers by yourself.</p>

<p>Got a an hour to spare? Write code that will reverse a string, and find out the most optimum solution. A free evening? Why not try some web-scraping. Read other peoples code. See how they do things. Ask yourself what you would do.</p>

<p>When I'm bored at my computer, I open my IDE and code-storm. I jot down ideas that sound interesting, and challenging. An URL shortener? Sure, I can do that. Oh, I learnt how to convert numbers from one base to another as a side effect!</p>

<p>This is valid whatever your skill level. <em>You never stop learning.</em> By actively coding in your spare time you will, with little additional effort, come to understand the language, and ultimately, become a guru. You will build up knowledge and reusable code and memorise idioms.</p>
<br /><b>#6</b><br /><pre><code>def apprentice():
  read(diveintopython)
  experiment(interpreter)
  read(python_tutorial)
  experiment(interpreter, modules/files)
  watch(pycon)

def master():
  refer(python-essential-reference)
  refer(PEPs/language reference)
  experiment()
  read(good_python_code) # Eg. twisted, other libraries
  write(basic_library)   # reinvent wheel and compare to existing wheels
  if have_interesting_ideas:
     give_talk(pycon)

def guru():
  pass # Not qualified to comment. Fix the GIL perhaps?
</code></pre>
<br /><b>#7</b><br /><p>Google just recently released an online Python class ("class" as in "a course of study").</p>

<p><a href="http://code.google.com/edu/languages/google-python-class/" rel="nofollow">http://code.google.com/edu/languages/google-python-class/</a></p>

<p>I know this doesn't answer your full question, but I think it's a great place to start!</p>
<br /><b>#8</b><br /><p>Download <a href="http://twistedmatrix.com/trac/wiki/Downloads" rel="nofollow">Twisted</a> and look at the source code. They employ some pretty advanced techniques.</p>
<br /><b>#9</b><br /><p><strong>Thoroughly Understand All Data Types and Structures</strong></p>

<p>For every type and structure, write a series of demo programs that exercise every aspect of the type or data structure.  If you do this, it might be worthwhile to blog notes on each one... it might be useful to lots of people!</p>
<br /><b>#10</b><br /><p>I learned python first by myself over a summer just by doing the tutorial on the python site (sadly, I don't seem to be able to find that anymore, so I can't post a link). </p>

<p>Later, python was taught to me in one of my first year courses at university. In the summer that followed, I practiced with <a href="http://www.pythonchallenge.com/" rel="nofollow">PythonChallenge</a> and with problems from <a href="http://code.google.com/codejam/" rel="nofollow">Google Code Jam</a>.
Solving these problems help from an algorithmic perspective as well as from the perspective of learning what Python can do as well as how to manipulate it to get the fullest out of python.</p>

<p>For similar reasons, I have heard that <a href="http://codegolf.com/" rel="nofollow">code golf</a> works as well, but i have never tried it for myself.</p>
<br /><b>#11</b><br /><p>Have you seen the book "<a href="http://oreilly.com/catalog/9780596154516/" rel="nofollow">Bioinformatics Programming using Python</a>"? Looks like you're an exact member of its focus group.</p>
<br /><b>#12</b><br /><p>If you're in and using python for science (which it seems you are)  part of that will be learning and understanding scientific libraries, for me these would be </p>

<p>numpy
scipy
matplotlib
mayavi/mlab
chaco
Cython</p>

<p>knowing how to use the right libraries and vectorize your code is essential for scientific computing.</p>

<p>I wanted to add that, handling large numeric datasets in common pythonic ways(object oriented approaches, lists, iterators) can be extremely inefficient.  In scientific computing, it can be necessary to structure your code in ways that differ drastically from how most conventional python coders approach data. </p>
<br /><b>#13</b><br /><p>Not precisely what you're asking for, but I think it's good advice.</p>

<p>Learn another language, doesn't matter too much which.  Each language has it's own ideas and conventions that you can learn from.  Learn about the differences in the languages and more importantly <code>why</code> they're different.  Try a purely functional language like Haskell and see some of the benefits (and challenges) of functions free of side-effects.  See how you can apply some of the things you learn from other languages to Python.  </p>
<br /><b>#14</b><br /><h2>Learning algorithms/maths/file IO/Pythonic optimisation</h2>

<p>This won't get you guru-hood but to start out, try working through the <a href="http://projecteuler.net/" rel="nofollow">Project Euler problems</a> 
The first 50 or so shouldn't tax you if you have decent high-school mathematics and know how to Google. When you solve one you get into the forum where you can look through other people's solutions which will teach you even more. Be decent though and don't post up your solutions as the idea is to encourage people to work it out for themselves. </p>

<p>Forcing yourself to work in Python will be unforgiving if you use brute-force algorithms.
This will teach you how to lay out large datasets in memory and access them efficiently with the fast language features such as dictionaries.</p>

<p><strong>From doing this myself I learnt:</strong></p>

<ul>
<li>File IO</li>
<li>Algorithms and techniques such as Dynamic Programming</li>
<li>Python data layout
<ul>
<li>Dictionaries/hashmaps</li>
<li>Lists</li>
<li>Tuples</li>
<li>Various combinations thereof, e.g. dictionaries to lists of tuples</li>
</ul></li>
<li>Generators</li>
<li>Recursive functions</li>
<li>Developing Python libraries 
<ul>
<li>Filesystem layout</li>
<li>Reloading them during an interpreter session</li>
</ul></li>
</ul>

<p><strong>And also very importantly</strong></p>

<ul>
<li>When to give up and use C or C++!</li>
</ul>

<p><strong>All of this should be relevant to Bioinformatics</strong></p>

<p>Admittedly I didn't learn about the OOP features of Python from that experience.</p>
<br /><b>#15</b><br /><p>You already have a lot of reading material, but if you can handle more, I recommend you
learn about the evolution of python by reading the Python Enhancement Proposals,  especially the "Finished" PEPs and the "Deferred, Abandoned, Withdrawn, and Rejected" PEPs.</p>

<p>By seeing how the language has changed, the decisions that were made and their rationales, you will absorb the philosophy of Python and understand how "idiomatic Python" comes about.</p>

<p><a href="http://www.python.org/dev/peps/" rel="nofollow">http://www.python.org/dev/peps/</a></p>
<br /><b>#16</b><br /><p>I recommend starting with something that forces you to explore the expressive power of the syntax. Python allows many different ways of writing the same functionality, but there is often a single most elegant and fastest approach. If you're used to the idioms of other languages, you might never otherwise find or accept these better ways. I spent a weekend trudging through the first 20 or so Project Euler (http://projecteuler.net/) problems and made a simple webapp with Django on Google App Engine. This will only take you from apprentice to novice, maybe, but you can then continue to making somewhat more advanced webapps and solve more advanced Project Euler problems. After a few months I went back and solved the first 20 PE problems from scratch in an hour instead of a weekend.</p>
<br /><b>#17</b><br /><p>Teaching to someone else who is starting to learn Python is always a great way to get your ideas clear and sometimes, I usually get a lot of neat questions from students that have me to re-think conceptual things about Python.</p>
<br /><b>#18</b><br /><p>Go back on a regular basis to the <a href="http://www.pythonchallenge.com/" rel="nofollow">Python challenge</a>. You'll get better.</p>
<br />