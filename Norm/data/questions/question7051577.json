[{"text": ["Alternative implementations of python/setuptools entry points (extensions) in other languages/applications"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["While this question has a python backend, the question is not tied to python itself, but rather about extension mechanisms and how to register/lookup for plugins."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "not", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["In python, the concept of entrypoints was introduced by setuptools, and is tied to the metadata of installed python distributions (called packages in other packaging systems)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["As of my understanding, one of the features provided by entrypoints is to allows an application to define a place where others can put things in, so any application wanting to use an entrypoint can get a list of registered classes/functions there.", "Let's take an example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Foo defines the entrypoint \"entrypoint1\" and look for plugins registered under this name.", "tag": "none", "senID": 4}, {"text": "Bar register a callable (", "tag": "none", "senID": 5}, {"text": "Any python script is then able to list ", "tag": "none", "senID": 6}]}, {"text": ["With setuptools, applications registers entrypoints at install time and the information is stored in metadata related to packaging, called .egginfo (which usually contain information about the distribution name, its dependencies, and some more metadata about packaging)."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["I have the feeling that packaging metadata is not the right place to store this kind of information, as I don't get why this information is tied to packaging."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["I'm curious to hear about such entrypoints/extensions/plugins features in other languages, and especially if the concept is tied to metadata and packaging or not.", "And so the question is\u2026"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Do you have examples I should look at?", "Could you explain why the design choices have been made that way?"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Do you have examples I should look at? Could you explain why the design choices have been made that way?", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Can you see different ways to handle this problem?", "Do you know how this problem has already been solved in different tools?", "What are the downsides and the advantages of the current python implementation over others?"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Thanks!"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["What I've foundso far"], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "What I've foundso far", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "so far", "tag": "em"}]}, {"text": "so far", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["I've found in different projects, a way to create and to distribute \"plugins\", which are especially taking care about the \"how do we make plugins\". "], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["For instance, libpeas (the gobject plugin framework) defines a set of ways to extend a default behavior by specifying plugins.", "While this is interesting, I am just interested by the \"registering and finding\" (and eventually loading) part of it."], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "libpeas", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://live.gnome.org/Libpeas"}]}, {"text": ["Here are some of my findings so far:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["Libpeas defines its own metadata file (*.plugin), which stores information about the type of the callable (it is possible to have different plugins in different languages).", "The main information here is the name of the module to load."], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "its own metadata file", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://git.gnome.org/browse/libpeas/tree/peas-demo/plugins/pythonhello/pythonhello.plugin"}]}, {"text": ["Maven have a design document containing information on how stuff is managed there.", "Maven manages plugins with their dependencies and metadata so it seems like an interesting place to look for how they implemented things."], "childNum": 2, "tag": "p", "senID": 18, "childList": [{"text": "a design document", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://github.com/apache/maven-3/blob/trunk/maven-core/plugin-manager.txt"}, {"text": "how they implemented things", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "https://github.com/apache/maven-3/tree/trunk/maven-core/src/main/java/org/apache/maven/plugin"}]}, {"text": ["As specified in their documentation, maven plugins are using annotations (@goal) on the classes, which is then used to find all the plugins registered with a particular @goal.", "While this approach is possible in static languages, it is not in interpreted languages as we only know what are all the possible classes / callables at one given point of the time, which may change."], "childNum": 3, "tag": "p", "senID": 19, "childList": [{"text": "maven plugins are using annotations", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://maven.apache.org/guides/plugin/guide-java-plugin-development.html"}, {"text": "@goal", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "@goal", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Mercurial uses a central configuration file (~/.hgrc), containing a mapping of the name of the plugin to the path it can be found."], "childNum": 2, "tag": "p", "senID": 20, "childList": [{"text": "a central configuration file", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mercurial.selenic.com/wiki/UsingExtensions"}, {"text": "~/.hgrc", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Some more thoughts"], "childNum": 1, "tag": "p", "senID": 21, "childList": [{"text": "Some more thoughts", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["While that's not an answer to this question, it is also interesting to note how setuptools entrypoints are implemented, and how they compare in term of performance, with the mercurial ones."], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"text": ["When you ask for a particular entry point with setuptools, all the metadata are read at run time and a list is built that way.", "This means this reading can take some time if you have a lot of python distributions on your path.", "Mercurial on the other side hardcode this information into a single file, which means you have to specify the complete path to your callable there, then registered callables are not \"discovered\" but \"read\" directly from the configuration file.", "This allows finer grained configuration on what's should be available and what should not be and seems faster. "], "childNum": 2, "tag": "p", "senID": 23, "childList": [{"text": "all the metadata are read at run time and a list is built that way", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://bitbucket.org/tarek/distribute/src/b825c6440dc6/pkg_resources.py#cl-2583"}, {"text": "hardcode", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["On the other side, as the python path can be changed at runtime, this means that callables provided on such a way would have to be checked against the path in order to know if they should be returned or not in all situations."], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"text": ["Why entrypoints are currently tied to packaging"], "childNum": 1, "tag": "p", "senID": 25, "childList": [{"text": "Why entrypoints are currently tied to packaging", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["It is also interesting to understand why entrypoints are tied to packaging in setuptools.", "The main reason is that it seems useful that python distributions can register part of themselves as extending an entrypoint at installation time: then installing means also registering the entrypoints: no need for an extra registration step."], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"text": ["While this works fairly well in a large majority of cases (when python distributions are actually being installed) it doesn't when they are not installed or simply not packaged.", "In other words, from what I understand, you can't register an entrypoint at runtime, without having an .egg-info file."], "childNum": 0, "tag": "p", "senID": 27, "childList": []}]