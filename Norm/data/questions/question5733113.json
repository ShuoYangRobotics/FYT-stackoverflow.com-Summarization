[{"text": ["SQLAlchemy versioning cares about class import order"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I was following the guide here:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://www.sqlalchemy.org/docs/orm/examples.html?highlight=versioning#versioned-objects"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.sqlalchemy.org/docs/orm/examples.html?highlight=versioning#versioned-objects", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sqlalchemy.org/docs/orm/examples.html?highlight=versioning#versioned-objects"}]}, {"text": ["and have come across an issue.", "I have defined my relationships like:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n generic_ticker = relation('MyClass', backref=backref(\"stuffs\"))\n</code>\n</pre>\n", "senID": 4}, {"text": ["with strings so it doesn't care about the import order of my model modules.", "This all works fine normally, but when I use the versioning meta I get the following error:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I tracked down the error to:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n File \"/home/nick/workspace/gm3/gm3/lib/history_meta.py\", line 90, in __init__\n    mapper = class_mapper(cls)\n  File \"/home/nick/venv/tg2env/lib/python2.6/site-packages/sqlalchemy/orm/util.py\", line 622, in class_mapper\n    mapper = mapper.compile()\n</code>\n</pre>\n", "senID": 7}, {"code": "<pre>\n<code>\n class VersionedMeta(DeclarativeMeta):\n    def __init__(cls, classname, bases, dict_):\n        DeclarativeMeta.__init__(cls, classname, bases, dict_)\n\n        try:\n            mapper = class_mapper(cls)\n            _history_mapper(mapper)\n        except UnmappedClassError:\n            pass\n</code>\n</pre>\n", "senID": 8}, {"text": ["I fixed the problem by putting the try: except stuff in a lambda and running them all after all the imports have happened.", "This works but seems a bit rubbish, any ideas of how to fix this is a better way?"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Thanks!"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Update"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The problem is not actually about import order.", "The versioning example is designed such that mapper requires compilation in costructor of each versioned class.", "And compilation fails when related classes are not yet defined.", "In case of circular relations there is no way to make it working by changing definition order of mapped classes."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Update 2"], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "Update 2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["As the above update states (I didn't know you could edit other people's posts on here :)) this is likely due to circular references.", "In which case may be someone will find my hack useful (I'm using it with turbogears) (Replace VersionedMeta and add in create_mappers global in history_meta)"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n create_mappers = []\nclass VersionedMeta(DeclarativeMeta):\n    def __init__(cls, classname, bases, dict_):\n        DeclarativeMeta.__init__(cls, classname, bases, dict_)\n        #I added this code in as it was crashing otherwise\n        def make_mapper():\n            try:\n                mapper = class_mapper(cls)\n                _history_mapper(mapper)\n            except UnmappedClassError:\n                pass\n\n        create_mappers.append(lambda: make_mapper())\n</code>\n</pre>\n", "senID": 15}, {"text": ["Then you can do something like the following in your models __init__.py"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n # Import your model modules here.\nfrom myproj.lib.history_meta import create_mappers\n\nfrom myproj.model.misc import *\nfrom myproj.model.actor import *\nfrom myproj.model.stuff1 import *\nfrom myproj.model.instrument import *\nfrom myproj.model.stuff import *\n\n#setup the history\n[func() for func in create_mappers]\n</code>\n</pre>\n", "senID": 17}, {"text": ["That way it create the mappers only after all the classes have been defined."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["Update 3\nSlightly unrelated but I came across a duplicate primary key error in some circumstances (committing 2 changes to the same object in one go).", "My workaround has been to add a new primary auto-incrementing key.", "Of course you can't have more than 1 with mysql so I had to de-primary key the existing stuff used to create the history table.", "Check out my overall code (including a hist_id and getting rid of the foreign key constraint):"], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "Update 3", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n \"\"\"Stolen from the offical sqlalchemy recpies\n\"\"\"\nfrom sqlalchemy.ext.declarative import DeclarativeMeta\nfrom sqlalchemy.orm import mapper, class_mapper, attributes, object_mapper\nfrom sqlalchemy.orm.exc import UnmappedClassError, UnmappedColumnError\nfrom sqlalchemy import Table, Column, ForeignKeyConstraint, Integer\nfrom sqlalchemy.orm.interfaces import SessionExtension\nfrom sqlalchemy.orm.properties import RelationshipProperty\nfrom sqlalchemy.types import DateTime\nimport datetime\nfrom sqlalchemy.orm.session import Session\n\ndef col_references_table(col, table):\n    for fk in col.foreign_keys:\n        if fk.references(table):\n            return True\n    return False\n\ndef _history_mapper(local_mapper):\n    cls = local_mapper.class_\n\n    # set the \"active_history\" flag\n    # on on column-mapped attributes so that the old version\n    # of the info is always loaded (currently sets it on all attributes)\n    for prop in local_mapper.iterate_properties:\n        getattr(local_mapper.class_, prop.key).impl.active_history = True\n\n    super_mapper = local_mapper.inherits\n    super_history_mapper = getattr(cls, '__history_mapper__', None)\n\n    polymorphic_on = None\n    super_fks = []\n    if not super_mapper or local_mapper.local_table is not super_mapper.local_table:\n        cols = []\n        for column in local_mapper.local_table.c:\n            if column.name == 'version':\n                continue\n\n            col = column.copy()\n            col.unique = False\n\n            #don't auto increment stuff from the normal db\n            if col.autoincrement:\n                col.autoincrement = False\n            #sqllite falls over with auto incrementing keys if we have a composite key\n            if col.primary_key:\n                col.primary_key = False\n\n            if super_mapper and col_references_table(column, super_mapper.local_table):\n                super_fks.append((col.key, list(super_history_mapper.base_mapper.local_table.primary_key)[0]))\n\n            cols.append(col)\n\n            if column is local_mapper.polymorphic_on:\n                polymorphic_on = col\n\n        #if super_mapper:\n        #    super_fks.append(('version', super_history_mapper.base_mapper.local_table.c.version))\n\n        cols.append(Column('hist_id', Integer, primary_key=True, autoincrement=True))\n        cols.append(Column('version', Integer))\n        cols.append(Column('changed', DateTime, default=datetime.datetime.now))\n\n        if super_fks:\n            cols.append(ForeignKeyConstraint(*zip(*super_fks)))\n\n        table = Table(local_mapper.local_table.name + '_history', local_mapper.local_table.metadata,\n                      *cols, mysql_engine='InnoDB')\n    else:\n        # single table inheritance.  take any additional columns that may have\n        # been added and add them to the history table.\n        for column in local_mapper.local_table.c:\n            if column.key not in super_history_mapper.local_table.c:\n                col = column.copy()\n                super_history_mapper.local_table.append_column(col)\n        table = None\n\n    if super_history_mapper:\n        bases = (super_history_mapper.class_,)\n    else:\n        bases = local_mapper.base_mapper.class_.__bases__\n    versioned_cls = type.__new__(type, \"%sHistory\" % cls.__name__, bases, {})\n\n    m = mapper(\n            versioned_cls, \n            table, \n            inherits=super_history_mapper, \n            polymorphic_on=polymorphic_on,\n            polymorphic_identity=local_mapper.polymorphic_identity\n            )\n    cls.__history_mapper__ = m\n\n    if not super_history_mapper:\n        cls.version = Column('version', Integer, default=1, nullable=False)\n\ncreate_mappers = []\n\nclass VersionedMeta(DeclarativeMeta):\n    def __init__(cls, classname, bases, dict_):\n        DeclarativeMeta.__init__(cls, classname, bases, dict_)\n        #I added this code in as it was crashing otherwise\n        def make_mapper():\n            try:\n                mapper = class_mapper(cls)\n                _history_mapper(mapper)\n            except UnmappedClassError:\n                pass\n\n        create_mappers.append(lambda: make_mapper())\n\ndef versioned_objects(iter):\n    for obj in iter:\n        if hasattr(obj, '__history_mapper__'):\n            yield obj\n\ndef create_version(obj, session, deleted = False):\n    obj_mapper = object_mapper(obj)\n    history_mapper = obj.__history_mapper__\n    history_cls = history_mapper.class_\n\n    obj_state = attributes.instance_state(obj)\n\n    attr = {}\n\n    obj_changed = False\n\n    for om, hm in zip(obj_mapper.iterate_to_root(), history_mapper.iterate_to_root()):\n        if hm.single:\n            continue\n\n        for hist_col in hm.local_table.c:\n            if hist_col.key == 'version' or hist_col.key == 'changed' or hist_col.key == 'hist_id':\n                continue\n\n            obj_col = om.local_table.c[hist_col.key]\n\n            # get the value of the\n            # attribute based on the MapperProperty related to the\n            # mapped column.  this will allow usage of MapperProperties\n            # that have a different keyname than that of the mapped column.\n            try:\n                prop = obj_mapper.get_property_by_column(obj_col)\n            except UnmappedColumnError:\n                # in the case of single table inheritance, there may be \n                # columns on the mapped table intended for the subclass only.\n                # the \"unmapped\" status of the subclass column on the \n                # base class is a feature of the declarative module as of sqla 0.5.2.\n                continue\n\n            # expired object attributes and also deferred cols might not be in the\n            # dict.  force it to load no matter what by using getattr().\n            if prop.key not in obj_state.dict:\n                getattr(obj, prop.key)\n\n            a, u, d = attributes.get_history(obj, prop.key)\n\n            if d:\n                attr[hist_col.key] = d[0]\n                obj_changed = True\n            elif u:\n                attr[hist_col.key] = u[0]\n            else:\n                # if the attribute had no value.\n                attr[hist_col.key] = a[0]\n                obj_changed = True\n\n    if not obj_changed:\n        # not changed, but we have relationships.  OK\n        # check those too\n        for prop in obj_mapper.iterate_properties:\n            if isinstance(prop, RelationshipProperty) and \\\n                attributes.get_history(obj, prop.key).has_changes():\n                obj_changed = True\n                break\n\n    if not obj_changed and not deleted:\n        return\n\n    attr['version'] = obj.version\n    hist = history_cls()\n    for key, value in attr.iteritems():\n        setattr(hist, key, value)\n\n    obj.version += 1\n    session.add(hist)\n\nclass VersionedListener(SessionExtension):\n    def before_flush(self, session, flush_context, instances):\n        for obj in versioned_objects(session.dirty):\n            create_version(obj, session)\n        for obj in versioned_objects(session.deleted):\n            create_version(obj, session, deleted = True)\n</code>\n</pre>\n", "senID": 20}]