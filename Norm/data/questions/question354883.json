[{"text": ["How do you return multiple values in Python?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["The canonical way to return multiple values in languages that support it is often tupling. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "tupling", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/38508/whats-the-best-way-to-return-multiple-values-from-a-function-in-python"}]}, {"text": ["Consider this trivial example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def f(x):\n  y0 = x + 1\n  y1 = x * 3\n  y2 = y0 ** y3\n  return (y0,y1,y2)\n</code>\n</pre>\n", "senID": 3}, {"text": ["However, this quickly gets problematic as the number of values returned increases.", "What if you want to return four or five values?", "Sure, you could keep tupling them, but it gets easy to forget which value is where.", "It's also rather ugly to unpack them wherever you want to receive them."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The next logical step seems to be to introduce some sort of 'record notation'.", "In python, the obvious way to do this is by means of a dict. "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Consider the following:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def g(x):\n  y0 = x + 1\n  y1 = x * 3\n  y2 = y0 ** y3\n  return {'y0':y0, 'y1':y1 ,'y2':y2 }\n</code>\n</pre>\n", "senID": 7}, {"text": ["(edit- Just to be clear, y0, y1 and y2 are just meant as abstract identifiers.", "As pointed out, in practice you'd use meaningful identifiers)"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Now, we have a mechanism whereby we can project out a particular member of the returned object.", "For example, "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n result['y0']\n</code>\n</pre>\n", "senID": 10}, {"text": ["However, there is another option.", "We could instead return a specialized structure.", "I've framed this in the context of Python, but I'm sure it applies to other languages as well.", "Indeed, if you were working in C this might very well be your only option.", "Here goes:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n class ReturnValue(object):\n  def __init__(y0, y1, y2):\n     self.y0 = y0\n     self.y1 = y1\n     self.y2 = y2\n\ndef g(x):\n  y0 = x + 1\n  y1 = x * 3\n  y2 = y0 ** y3\n  return ReturnValue(y0, y1, y2)\n</code>\n</pre>\n", "senID": 12}, {"text": ["In python the previous two are perhaps very similar in terms of plumbing- After all { y0, y1, y2 } just end up being entries in the internal __dict__ of the ResultValue."], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "{ y0, y1, y2 }", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__dict__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["There is one additional feature provided by Python though for tiny objects, the __slots__ attribute.", "The class could be expressed as:"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class ReturnValue(object):\n  __slots__ = [\"y0\", \"y1\", \"y2\"]\n  def __init__(y0, y1, y2):\n     self.y0 = y0\n     self.y1 = y1\n     self.y2 = y2\n</code>\n</pre>\n", "senID": 15}, {"text": ["\"The __slots__ declaration takes a sequence of instance variables and reserves just enough space in each instance to hold a value for each variable.", "Space is saved because __dict__ is not created for each instance.", "\" Python reference manual."], "childNum": 3, "tag": "p", "senID": 16, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__dict__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Python reference manual", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.network-theory.co.uk/docs/pylang/__slots__.html"}]}, {"text": ["Another suggestion which I'd overlooked comes from Bill the Lizard:\n    def h(x):\n      result = [x + 1]\n      result.append(x * 3)\n      result.append(y0 ** y3)\n      return result"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["This is my least favorite method though.", "I suppose I'm tainted by exposure to Haskell, but the idea of mixed-type lists has always felt uncomfortable to me.", "In this particular example the list is -not- mixed type, but it conceivably could be.", "A list used in this way really doesn't gain anything with respect to the tuple as far as I can tell.", "The only real difference between lists and tuples in Python is that lists are mutable, wheras tuples are not.", "I personally tend to carry over the conventions from functional programming: use lists for any number of elements of the same type, and tuples for a fixed number of elements of predetermined types."], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "mutable", "tag": "a", "pos": 4, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#typesseq-mutable"}]}, {"text": ["After the lengthy preamble, comes the inevitable question.", "Which method (do you think) is best?"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["I've typically found myself going the dictionary route because it involves less set-up work.", "From a types perspective however, you might be better off going the class route, since that may help you avoid confusing what a dictionary represents.", "On the other hand, there are some in"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}]