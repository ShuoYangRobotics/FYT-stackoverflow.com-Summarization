Question (ID-458550): Standard way to embed version into python package? Is there a standard way to associate version string with a python package in such way that I could do the following? 

 import foo
print foo.version
 

 I would imagine there's some way to retrieve that data without any extra hardcoding, since minor/major strings are specified in setup.py already. Alternative solution that I found was to have import __version__ in my foo/__init__.py and then have __version__.py generated by setup.py 

 Thanks, 
 Answers (Total-7): #0 Not directly an answer to your question, but you should consider naming it __version__ , not version . 

 This is almost a quasi-standard. Many modules in the standard library use __version__ , and this is also used in lots of 3rd-party modules, so it's the quasi-standard. It's also mentioned in PEP 3001 

 Usually, __version__ is a string, but sometimes it's also a float or tuple. 

 Edit: as mentioned by S.Lott (Thank you!), PEP 8 says it explicitly: 

 
 Version Bookkeeping 
 
 If you have to have Subversion, CVS, or RCS crud in your source file,
 do it as follows. 

  __version__ = "$Revision: 63990 $"
 # $Source$
 
 
 These lines should be included after the module's docstring, before
 any other code, separated by a blank line above and below. 
 
 #1 Though this is probably far too late, there is a slightly simpler alternative to the previous answer: 

 __version_info__ = ('1', '2', '3')
__version__ = '.'.join(__version_info__)
 

 (And it would be fairly simple to convert auto-incrementing portions of version numbers to a string using str() .) 

 Of course, from what I've seen, people tend to use something like the previously-mentioned version when using __version_info__ , and as such store it as a tuple of ints; however, I don't quite see the point in doing so, as I doubt there are situations where you would perform mathematical operations such as addition and subtraction on portions of version numbers for any purpose besides curiosity or auto-incrementation (and even then, int() and str() can be used fairly easily), and comparison operations can be performed just as easily on string numerals as on integers. (On the other hand, there is the possibility of someone else's code expecting a numerical tuple rather than a string tuple and thus failing.) 

 This is, of course, my own view, and I would gladly like others' input on using a numerical tuple. 
 #2 Here is how I do this. Advantages of the following method: 

 
 It provides a __version__ attribute. 
 It provides the standard metadata version. Therefore it will be detected by pkg_resources or other tools that parse the package metadata (EGG-INFO and/or PKG-INFO, PEP 0345). 
 It doesn't import your package (or anything else) when building your package, which can cause problems in some situations. 
 There is only one place that the version number is written down, so there is only one place to change it when the version number changes, and there is less chance of inconsistent versions. 
 

 Here is how it works: the "one canonical place" to store the version number is a .py file, named "_version.py" which is in your Python package, for example in myniftyapp/_version.py . This file is a Python module, but your setup.py doesn't import it! (That would defeat feature 3.) Instead your setup.py knows that the contents of this file is very simple, something like: 

 __version__ = "3.6.5"
 

 And so your setup.py opens the file and parses it, with code like: 

 verstrline = open(VERSIONFILE, "rt").read()
VSRE = r"^__version__ = ['\"]([^'\"]*)['\"]"
mo = re.search(VSRE, verstrline, re.M)
if mo:
 verstr = mo.group(1)
else:
 raise RuntimeError("Unable to find version string in %s." % (VERSIONFILE,))
 

 Then your setup.py passes that string as the value of the "version" argument to setup() , thus satisfying feature 2. 

 To satisfy feature 1, you can have your package (at run-time, not at setup time!) import the _version file from myniftyapp/__init__.py like this: 

 from _version import __version__
 

 Here is an example of this technique that I've been using for years. 

 The code in that example is a bit more complicated, but the simplified example that I wrote into this comment should be a complete implementation. 

 Here is example code of importing the version . 

 If you see anything wrong with this approach, please let me know: zooko at zooko dot com. If you don't see anything wrong with this approach then please vote this answer up! Because the more packages come with their version numbers in the expected places the better! 
 #3 There doesn't seem to be a standard way to embed a version string in a python package. Most packages I've seen use some variant of your solution, i.e. eitner 

 
 Embed the version in setup.py and have setup.py generate a module (e.g. version.py ) containing only version info, that's imported by your package, or 
 The reverse: put the version info in your package itself, and import that to set the version in setup.py 
 
 #4 Also worth noting is that as well as __version__ being a semi-std. in python so is __version_info__ which is a tuple, in the simple cases you can just do something like: 

 __version__ = '1.2.3'
__version_info__ = tuple([ int(num) for num in __version__.split('.')])
 

 ...and you can get the __version__ string from a file, or whatever. 
 #5 I also saw another style: 

 &gt;&gt;&gt; django.VERSION
(1, 1, 0, 'final', 0)
 
 #6 For what it's worth, if you're using NumPy distutils, numpy.distutils.misc_util.Configuration has a make_svn_version_py() method that embeds the revision number inside package.__svn_version__ in the variable version .