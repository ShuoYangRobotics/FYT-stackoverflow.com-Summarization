<h3>Question ( ID-1916218 ) : </h3><h2>Find the <span style="background-color:yellow;">longest</span> common <span style="background-color:yellow;">starting</span> <span style="background-color:yellow;">substring</span> <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">set</span> of <span style="background-color:yellow;">strings</span> </h2><p>This <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">challenge</span> to come up with the <span style="background-color:yellow;">most</span> <span style="background-color:yellow;">elegant</span> JavaScript , Ruby or <span style="background-color:yellow;">other</span> <span style="background-color:yellow;">solution</span> to <span style="background-color:yellow;">a</span> relatively trivial problem . </p>
<p>This problem <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">more</span> <span style="background-color:yellow;">specific</span> case of the Longest common <span style="background-color:yellow;">substring</span> problem . I need to only <span style="background-color:yellow;">find</span> the <span style="background-color:yellow;">longest</span> common <span style="background-color:yellow;">starting</span> <span style="background-color:yellow;">substring</span> <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">array.</span> This greatly <span style="background-color:yellow;">simplifies</span> the problem . </p>
<p>For <span style="background-color:yellow;">example</span> , the <span style="background-color:yellow;">longest</span> <span style="background-color:yellow;">substring</span> <span style="background-color:yellow;">in</span> [ <span style="background-color:yellow;">interspecies</span> , <span style="background-color:yellow;">interstelar</span> , <span style="background-color:yellow;">interstate</span> ] <span style="background-color:yellow;">is</span> " <span style="background-color:yellow;">inters</span> " . However , I <span style="background-color:yellow;">do</span> n't need to <span style="background-color:yellow;">find</span> " <span style="background-color:yellow;">ific</span> " <span style="background-color:yellow;">in</span> [ <span style="background-color:yellow;">specifics</span> , terrific ] . </p>
<p>I 've <span style="background-color:yellow;">solved</span> the problem by quickly coding up <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">solution</span> <span style="background-color:yellow;">in</span> JavaScript <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> part of <span style="background-color:yellow;">my</span> <span style="background-color:yellow;">answer</span> <span style="background-color:yellow;">about</span> <span style="background-color:yellow;">shell-like</span> tab-completion ( test page here ) . Here <span style="background-color:yellow;">is</span> that <span style="background-color:yellow;">solution</span> , <span style="background-color:yellow;">slightly</span> tweaked : </p>
<pre><code>function common_substring(data) {
  var i, ch, memo, idx = 0
  do {
    memo = null
    for (i=0; i < data.length; i++) {
      ch = data[i].charAt(idx)
      if (!ch) break
      if (!memo) memo = ch
      else if (ch != memo) break
    }
  } while (i == data.length && idx < data.length && ++idx)

  return (data[0] || '').slice(0, idx)
}
</code></pre>
<p>This code <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">available</span> <span style="background-color:yellow;">in</span> this Gist <span style="background-color:yellow;">along</span> with <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">similar</span> <span style="background-color:yellow;">solution</span> <span style="background-color:yellow;">in</span> Ruby. You can clone the gist <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> git repo to try <span style="background-color:yellow;">it</span> out : </p>
<pre><code>$ git clone git://gist.github.com/257891.git substring-challenge
</code></pre>
<p>I'm not very happy with those solutions. I have a feeling they might be solved with more elegance and less execution complexity—that's why I'm posting this challenge.</p>
<p>I'm going to accept as an answer the solution I find the most elegant or concise. Here is for instance a crazy Ruby hack I come up with—defining the <code>&</code> operator on String:</p>
<pre><code># works with Ruby 1.8.7 and above
class String
  def &(other)
    difference = other.to_str.each_char.with_index.find { |ch, idx|
      self[idx].nil? or ch != self[idx].chr
    }
    difference ? self[0, difference.last] : self
  end
end

class Array
  def common_substring
    self.inject(nil) { |memo, str| memo.nil? ? str : memo & str }.to_s
  end
end
</code></pre>
<p>Solutions <span style="background-color:yellow;">in</span> JavaScript or Ruby <span style="background-color:yellow;">are</span> preferred , but you can <span style="background-color:yellow;">show</span> off clever <span style="background-color:yellow;">solution</span> <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">other</span> <span style="background-color:yellow;">languages</span> <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">long</span> <span style="background-color:yellow;">as</span> you <span style="background-color:yellow;">explain</span> what 's going on. Only code <span style="background-color:yellow;">from</span> <span style="background-color:yellow;">standard</span> <span style="background-color:yellow;">library</span> please . </p>
<h3>Update : <span style="background-color:yellow;">my</span> <span style="background-color:yellow;">favorite</span> <span style="background-color:yellow;">solutions</span> </h3>
<p>I 've <span style="background-color:yellow;">chosen</span> the JavaScript <span style="background-color:yellow;">sorting</span> <span style="background-color:yellow;">solution</span> by kennebec <span style="background-color:yellow;">as</span> the " <span style="background-color:yellow;">answer</span> " because <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">struck</span> <span style="background-color:yellow;">me</span> <span style="background-color:yellow;">as</span> both unexpected <span style="background-color:yellow;">and</span> genius. If we <span style="background-color:yellow;">disregard</span> the complexity of <span style="background-color:yellow;">actual</span> <span style="background-color:yellow;">sorting</span> ( <span style="background-color:yellow;">let</span> 's <span style="background-color:yellow;">imagine</span> <span style="background-color:yellow;">it</span> 's <span style="background-color:yellow;">infinitely</span> optimized by the <span style="background-color:yellow;">language</span> <span style="background-color:yellow;">implementation</span> ) , the complexity of the <span style="background-color:yellow;">solution</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">just</span> comparing two <span style="background-color:yellow;">strings</span> . </p>
<p>Other great <span style="background-color:yellow;">solutions</span> : </p>
<ul>
<li><a href="/questions/1916218/find-the-longest-common-starting-substring-in-a-set-of-strings/1922153#1922153">"regex greed"</a> by FM takes a minute or two to grasp, but then the elegance of it hits you. Yehuda Katz also made <a href="/questions/1916218/find-the-longest-common-starting-substring-in-a-set-of-strings/1916398#1916398">a regex solution</a>, but it's more complex</li>
<li><a href="/questions/1916218/find-the-longest-common-starting-substring-in-a-set-of-strings/1916632#1916632"><code>commonprefix</code> in Python</a> — Roberto Bonvallet used a feature made for handling filesystem paths to solve this problem</li>
<li><a href="/questions/1916218/find-the-longest-common-starting-substring-in-a-set-of-strings/1918438#1918438">Haskell one-liner</a> is short as if it were compressed, and beautiful</li>
<li><a href="/questions/1916218/find-the-longest-common-starting-substring-in-a-set-of-strings/1916480#1916480">the straightforward Ruby one-liner</a></li>
</ul>
<p>Thanks <span style="background-color:yellow;">for</span> participating ! <span style="background-color:yellow;">As</span> you can <span style="background-color:yellow;">see</span> <span style="background-color:yellow;">from</span> the comments , I <span style="background-color:yellow;">learned</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">lot</span> ( <span style="background-color:yellow;">even</span> <span style="background-color:yellow;">about</span> Ruby ) . </p>
<br /><h3><span style="background-color:yellow;">Answers</span> ( Total-22 ) : </h3><b><span style="background-color:yellow;">#</span> <span style="background-color:yellow;">0</span> </b><br /><p>In Python : </p>
<pre><code>>>> from os.path import commonprefix
>>> commonprefix('interspecies interstelar interstate'.split())
'inters'
</code></pre>
<br /><b><span style="background-color:yellow;">#</span> <span style="background-color:yellow;">1</span> </b><br /><p>It 's <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">matter</span> of taste , but this <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">simple</span> <span style="background-color:yellow;">javascript</span> version : It <span style="background-color:yellow;">sorts</span> the <span style="background-color:yellow;">array</span> , <span style="background-color:yellow;">and</span> then <span style="background-color:yellow;">looks</span> <span style="background-color:yellow;">just</span> <span style="background-color:yellow;">at</span> the <span style="background-color:yellow;">first</span> <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">last</span> <span style="background-color:yellow;">items</span> . </p>
<pre><code>function sharedStart(A){
    var tem1, tem2, s, A= A.slice(0).sort();
    tem1= A[0];
    s= tem1.length;
    tem2= A.pop();
    while(s && tem2.indexOf(tem1)== -1){
    	tem1= tem1.substring(0, --s);

    }
    return tem1;
}
</code></pre>
<p>var <span style="background-color:yellow;">A</span> = [ 'interspecies ' , 'interstelar ' , 'interstate ' ] ; </p>
<p><span style="background-color:yellow;">alert</span> ( <span style="background-color:yellow;">sharedStart</span> ( <span style="background-color:yellow;">A</span> ) ) </p>
<br /><b><span style="background-color:yellow;">#</span> 2 </b><br /><p>Ruby one-liner : </p>
<pre><code>l=strings.inject{|l,s| l=l.chop while l!=s[0...l.length];l}
</code></pre>
<br /><b><span style="background-color:yellow;">#</span> 3 </b><br /><p>You <span style="background-color:yellow;">just</span> need to traverse <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">strings</span> until they <span style="background-color:yellow;">differ</span> , then take the <span style="background-color:yellow;">substring</span> up to this point . </p>
<p>Pseudocode : </p>
<pre><code>loop for i upfrom 0
     while all strings[i] are equal
     finally return substring[0..i]
</code></pre>
<p>Common Lisp : </p>
<pre><code>(defun longest-common-starting-substring (&rest strings)
  (loop for i from 0 below (apply #'min (mapcar #'length strings))
     while (apply #'char=
                  (mapcar (lambda (string) (aref string i))
                          strings))
     finally (return (subseq (first strings) 0 i))))
</code></pre>
<br /><b><span style="background-color:yellow;">#</span> 4 </b><br /><p>My Haskell one-liner : </p>
<pre><code>import Data.List

commonPre :: [String] -> String
commonPre = map head . takeWhile (\(x:xs)-> all (==x) xs) . transpose
</code></pre>
<p>EDIT : barkmadley gave <span style="background-color:yellow;">a</span> good <span style="background-color:yellow;">explanation</span> of the code below. I 'd <span style="background-color:yellow;">also</span> <span style="background-color:yellow;">add</span> that haskell uses <span style="background-color:yellow;">lazy</span> <span style="background-color:yellow;">evaluation</span> , <span style="background-color:yellow;">so</span> we can be <span style="background-color:yellow;">lazy</span> <span style="background-color:yellow;">about</span> our use of transpose ; <span style="background-color:yellow;">it</span> will only transpose our <span style="background-color:yellow;">lists</span> <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">far</span> <span style="background-color:yellow;">as</span> necessary to <span style="background-color:yellow;">find</span> the <span style="background-color:yellow;">end</span> of the common prefix . </p>
<br /><b><span style="background-color:yellow;">#</span> 5 </b><br /><p>Yet <span style="background-color:yellow;">another</span> way to <span style="background-color:yellow;">do</span> <span style="background-color:yellow;">it</span> : use regex greed . </p>
<pre><code>words = %w(interspecies interstelar interstate)
j = '='
str = ['', *words].join(j)
re = "[^#{j}]*"

str =~ /^
    (?: #{j} ( #{re} ) #{re} )
    (?: #{j}    \1     #{re} )*
$/x

p $1
</code></pre>
<p><span style="background-color:yellow;">And</span> the one-liner , courtesy of <span style="background-color:yellow;">mislav</span> ( 50 <span style="background-color:yellow;">characters</span> ) : </p>
<pre><code>p ARGV.join(' ').match(/^(\w*)\w*(?: \1\w*)*$/)[1]
</code></pre>
<br /><b><span style="background-color:yellow;">#</span> 6 </b><br /><p>This <span style="background-color:yellow;">is</span> probably not the <span style="background-color:yellow;">most</span> concise <span style="background-color:yellow;">solution</span> ( <span style="background-color:yellow;">depends</span> <span style="background-color:yellow;">if</span> you <span style="background-color:yellow;">already</span> have <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">library</span> <span style="background-color:yellow;">for</span> this ) , but one <span style="background-color:yellow;">elegant</span> <span style="background-color:yellow;">method</span> <span style="background-color:yellow;">is</span> to use <span style="background-color:yellow;">a</span> trie. I use tries <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">implementing</span> tab completion <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">my</span> Scheme <span style="background-color:yellow;">interpreter</span> : </p>
<p>http : //github.com/jcoglan/heist/blob/master/lib/trie.rb </p>
<p>For <span style="background-color:yellow;">example</span> : </p>
<pre><code>tree = Trie.new
%w[interspecies interstelar interstate].each { |s| tree[s] = true }
tree.longest_prefix('')
#=> "inters"
</code></pre>
<p>I <span style="background-color:yellow;">also</span> use them <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">matching</span> <span style="background-color:yellow;">channel</span> names with wildcards <span style="background-color:yellow;">for</span> the Bayeux protocol ; <span style="background-color:yellow;">see</span> these : </p>
<p>http : //github.com/jcoglan/faye/blob/master/client/channel.js </p>
<p>http : //github.com/jcoglan/faye/blob/master/lib/faye/channel.rb </p>
<br /><b><span style="background-color:yellow;">#</span> 7 </b><br /><pre><code>Python 2.6 (r26:66714, Oct  4 2008, 02:48:43) 

>>> a = ['interspecies', 'interstelar', 'interstate']

>>> print a[0][:max(
        [i for i in range(min(map(len, a))) 
            if len(set(map(lambda e: e[i], a))) == 1]
        ) + 1]

inters
</code></pre>
<ul><span style="background-color:yellow;">i</span> <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">i</span> <span style="background-color:yellow;">in</span> range ( <span style="background-color:yellow;">min</span> ( <span style="background-color:yellow;">map</span> ( <span style="background-color:yellow;">len</span> , <span style="background-color:yellow;">a</span> ) ) ) , number of <span style="background-color:yellow;">maximum</span> <span style="background-color:yellow;">lookups</span> ca n't be greater than the <span style="background-color:yellow;">length</span> of the <span style="background-color:yellow;">shortest</span> <span style="background-color:yellow;">string</span> ; <span style="background-color:yellow;">in</span> this <span style="background-color:yellow;">example</span> this would <span style="background-color:yellow;">evaluate</span> to [ <span style="background-color:yellow;">0</span> , <span style="background-color:yellow;">1</span> , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] <span style="background-color:yellow;">len</span> ( <span style="background-color:yellow;">set</span> ( <span style="background-color:yellow;">map</span> ( <span style="background-color:yellow;">lambda</span> <span style="background-color:yellow;">e</span> : <span style="background-color:yellow;">e</span> [ <span style="background-color:yellow;">i</span> ] , <span style="background-color:yellow;">a</span> ) ) ) , <span style="background-color:yellow;">1</span> ) create <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">array</span> of the <span style="background-color:yellow;">i-th</span> <span style="background-color:yellow;">character</span> <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">each</span> <span style="background-color:yellow;">string</span> <span style="background-color:yellow;">in</span> the <span style="background-color:yellow;">list</span> ; 2 ) <span style="background-color:yellow;">make</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">set</span> out of <span style="background-color:yellow;">it</span> ; 3 ) <span style="background-color:yellow;">determine</span> the <span style="background-color:yellow;">size</span> of the <span style="background-color:yellow;">set</span> [ <span style="background-color:yellow;">i</span> <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">i</span> <span style="background-color:yellow;">in</span> range ( <span style="background-color:yellow;">min</span> ( <span style="background-color:yellow;">map</span> ( <span style="background-color:yellow;">len</span> , <span style="background-color:yellow;">a</span> ) ) ) <span style="background-color:yellow;">if</span> <span style="background-color:yellow;">len</span> ( <span style="background-color:yellow;">set</span> ( <span style="background-color:yellow;">map</span> ( <span style="background-color:yellow;">lambda</span> <span style="background-color:yellow;">e</span> : <span style="background-color:yellow;">e</span> [ <span style="background-color:yellow;">i</span> ] , <span style="background-color:yellow;">a</span> ) ) ) = = <span style="background-color:yellow;">1</span> ] , <span style="background-color:yellow;">include</span> <span style="background-color:yellow;">just</span> the <span style="background-color:yellow;">characters</span> , <span style="background-color:yellow;">for</span> which the <span style="background-color:yellow;">size</span> of the <span style="background-color:yellow;">set</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">1</span> ( <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">characters</span> <span style="background-color:yellow;">at</span> that position were the <span style="background-color:yellow;">same</span> .. ) ; here <span style="background-color:yellow;">it</span> would <span style="background-color:yellow;">evaluate</span> to [ <span style="background-color:yellow;">0</span> , <span style="background-color:yellow;">1</span> , 2 , 3 , 4 , 5 ] <span style="background-color:yellow;">finally</span> take the <span style="background-color:yellow;">max</span> , <span style="background-color:yellow;">add</span> one , <span style="background-color:yellow;">and</span> get the <span style="background-color:yellow;">substring</span> .. . </ul>
<p>Note : the <span style="background-color:yellow;">above</span> <span style="background-color:yellow;">does</span> not work <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">a</span> = [ 'intersyate ' , 'intersxate ' , 'interstate ' , 'intersrate ' ] , but this would : </p>
<pre><code> >>> index = len(
         filter(lambda l: l[0] == l[1], 
             [ x for x in enumerate(
                 [i for i in range(min(map(len, a))) 
                     if len(set(map(lambda e: e[i], a))) == 1]
         )]))
 >>> a[0][:index]
 inters
</code></pre>
<br /><b><span style="background-color:yellow;">#</span> 8 </b><br /><p>Does n't <span style="background-color:yellow;">seem</span> that complicated <span style="background-color:yellow;">if</span> you 're not too concerned <span style="background-color:yellow;">about</span> ultimate performance : </p>
<pre><code>def common_substring(data)
  data.inject { |m, s| s[0,(0..m.length).find { |i| m[i] != s[i] }.to_i] }
end
</code></pre>
<p>One of the useful <span style="background-color:yellow;">features</span> of <span style="background-color:yellow;">inject</span> <span style="background-color:yellow;">is</span> the <span style="background-color:yellow;">ability</span> to pre-seed with the <span style="background-color:yellow;">first</span> <span style="background-color:yellow;">element</span> of the <span style="background-color:yellow;">array</span> being <span style="background-color:yellow;">interated</span> over. This <span style="background-color:yellow;">avoids</span> the <span style="background-color:yellow;">nil</span> <span style="background-color:yellow;">memo</span> <span style="background-color:yellow;">check</span> . </p>
<pre><code>puts common_substring(%w[ interspecies interstelar interstate ]).inspect
# => "inters"
puts common_substring(%w[ feet feel feeble ]).inspect
# => "fee"
puts common_substring(%w[ fine firkin fail ]).inspect
# => "f"
puts common_substring(%w[ alpha bravo charlie ]).inspect
# => ""
puts common_substring(%w[ fork ]).inspect
# => "fork"
puts common_substring(%w[ fork forks ]).inspect
# => "fork"
</code></pre>
<p>Update : If golf <span style="background-color:yellow;">is</span> the game here , then 67 <span style="background-color:yellow;">characters</span> : </p>
<pre><code>def f(d)d.inject{|m,s|s[0,(0..m.size).find{|i|m[i]!=s[i]}.to_i]}end
</code></pre>
<br /><b><span style="background-color:yellow;">#</span> 9 </b><br /><p>This one <span style="background-color:yellow;">is</span> very <span style="background-color:yellow;">similar</span> to Roberto Bonvallet 's <span style="background-color:yellow;">solution</span> , <span style="background-color:yellow;">except</span> <span style="background-color:yellow;">in</span> ruby . </p>
<pre><code>chars = %w[interspecies interstelar interstate].map {|w| w.split('') }
chars[0].zip(*chars[1..-1]).map { |c| c.uniq }.take_while { |c| c.size == 1 }.join
</code></pre>
<p>The <span style="background-color:yellow;">first</span> <span style="background-color:yellow;">line</span> replaces <span style="background-color:yellow;">each</span> <span style="background-color:yellow;">word</span> with <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">array</span> of <span style="background-color:yellow;">chars.</span> Next , I use zip to create this <span style="background-color:yellow;">data</span> <span style="background-color:yellow;">structure</span> : </p>
<p>[ [ " <span style="background-color:yellow;">i</span> " , " <span style="background-color:yellow;">i</span> " , " <span style="background-color:yellow;">i</span> " ] , [ " n " , " n " , " n " ] , [ " t " , " t " , " t " ] , .. . </p>
<p><span style="background-color:yellow;">map</span> <span style="background-color:yellow;">and</span> uniq reduce this to [ [ " <span style="background-color:yellow;">i</span> " ] , [ " n " ] , [ " t " ] , .. . </p>
<p>take_while pulls the <span style="background-color:yellow;">chars</span> off the <span style="background-color:yellow;">array</span> until <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">finds</span> one where the <span style="background-color:yellow;">size</span> <span style="background-color:yellow;">is</span> n't one ( <span style="background-color:yellow;">meaning</span> not <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">chars</span> were the <span style="background-color:yellow;">same</span> ) . Finally , I <span style="background-color:yellow;">join</span> them back together . </p>
<br /><b><span style="background-color:yellow;">#</span> <span style="background-color:yellow;">10</span> </b><br /><p>Here 's <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">solution</span> using regular <span style="background-color:yellow;">expressions</span> <span style="background-color:yellow;">in</span> Ruby : </p>
<pre><code>def build_regex(string)
  arr = []
  arr << string.dup while string.chop!
  Regexp.new("^(#{arr.join("|")})")
end

def substring(first, *strings)
  strings.inject(first) do |accum, string|
    build_regex(accum).match(string)[0]
  end
end
</code></pre>
<br /><b><span style="background-color:yellow;">#</span> <span style="background-color:yellow;">11</span> </b><br /><p>I would <span style="background-color:yellow;">do</span> the <span style="background-color:yellow;">following</span> : </p>
<ol>Take the <span style="background-color:yellow;">first</span> <span style="background-color:yellow;">string</span> of the <span style="background-color:yellow;">array</span> <span style="background-color:yellow;">as</span> the <span style="background-color:yellow;">initial</span> <span style="background-color:yellow;">starting</span> <span style="background-color:yellow;">substring</span> . Take the next <span style="background-color:yellow;">string</span> of the <span style="background-color:yellow;">array</span> <span style="background-color:yellow;">and</span> compare the <span style="background-color:yellow;">characters</span> until the <span style="background-color:yellow;">end</span> of one of the <span style="background-color:yellow;">strings</span> <span style="background-color:yellow;">is</span> reached or <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">mismatch</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">found.</span> If <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">mismatch</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">found</span> , reduce <span style="background-color:yellow;">starting</span> <span style="background-color:yellow;">substring</span> to the <span style="background-color:yellow;">length</span> where the <span style="background-color:yellow;">mismatch</span> was <span style="background-color:yellow;">found</span> . Repeat <span style="background-color:yellow;">step</span> 2 until <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">strings</span> have been tested . </ol>
<p>Here’s a JavaScript implementation:</p>
<pre><code>var array = ["interspecies", "interstelar", "interstate"],
    prefix = array[0],
    len = prefix.length;
for (i=1; i<array.length; i++) {
    for (j=0, len=Math.min(len,array[j].length); j<len; j++) {
        if (prefix[j] != array[i][j]) {
            len = j;
            prefix = prefix.substr(0, len);
            break;
        }
    }
}
</code></pre>
<br /><b><span style="background-color:yellow;">#</span> <span style="background-color:yellow;">12</span> </b><br /><p>In Python I would n't use <span style="background-color:yellow;">anything</span> but the <span style="background-color:yellow;">existing</span> commonprefix <span style="background-color:yellow;">function</span> I <span style="background-color:yellow;">showed</span> <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">another</span> <span style="background-color:yellow;">answer</span> , but I could n't help to reinvent the wheel : P . This <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">my</span> <span style="background-color:yellow;">iterator-based</span> <span style="background-color:yellow;">approach</span> : </p>
<pre><code>>>> a = 'interspecies interstelar interstate'.split()
>>>
>>> from itertools import takewhile, chain, izip as zip, imap as map
>>> ''.join(chain(*takewhile(lambda s: len(s) == 1, map(set, zip(*a)))))
'inters'
</code></pre>
<p>Edit : Explanation of how this works . </p>
<p>zip generates tuples of <span style="background-color:yellow;">elements</span> taking one of <span style="background-color:yellow;">each</span> <span style="background-color:yellow;">item</span> of <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">at</span> <span style="background-color:yellow;">a</span> time : </p>
<pre><code>In [6]: list(zip(*a))  # here I use list() to expand the iterator
Out[6]:
[('i', 'i', 'i'),
 ('n', 'n', 'n'),
 ('t', 't', 't'),
 ('e', 'e', 'e'),
 ('r', 'r', 'r'),
 ('s', 's', 's'),
 ('p', 't', 't'),
 ('e', 'e', 'a'),
 ('c', 'l', 't'),
 ('i', 'a', 'e')]
</code></pre>
<p>By <span style="background-color:yellow;">mapping</span> <span style="background-color:yellow;">set</span> over these <span style="background-color:yellow;">items</span> , I get <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">series</span> of unique <span style="background-color:yellow;">letters</span> : </p>
<pre><code>In [7]: list(map(set, _))  # _ means the result of the last statement above
Out[7]:
[set(['i']),
 set(['n']),
 set(['t']),
 set(['e']),
 set(['r']),
 set(['s']),
 set(['p', 't']),
 set(['a', 'e']),
 set(['c', 'l', 't']),
 set(['a', 'e', 'i'])]
</code></pre>
<p><span style="background-color:yellow;">takewhile</span> ( predicate , <span style="background-color:yellow;">items</span> ) takes <span style="background-color:yellow;">elements</span> <span style="background-color:yellow;">from</span> this while the predicate <span style="background-color:yellow;">is</span> True ; <span style="background-color:yellow;">in</span> this particular case , when the <span style="background-color:yellow;">set</span> <span style="background-color:yellow;">s</span> have one <span style="background-color:yellow;">element</span> , <span style="background-color:yellow;">i.e.</span> <span style="background-color:yellow;">all</span> the <span style="background-color:yellow;">words</span> have the <span style="background-color:yellow;">same</span> <span style="background-color:yellow;">letter</span> <span style="background-color:yellow;">at</span> that position : </p>
<pre><code>In [8]: list(takewhile(lambda s: len(s) == 1, _))
Out[8]:
[set(['i']),
 set(['n']), 
 set(['t']), 
 set(['e']), 
 set(['r']), 
 set(['s'])]
</code></pre>
<p><span style="background-color:yellow;">At</span> this point we have <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterable</span> of <span style="background-color:yellow;">sets</span> , <span style="background-color:yellow;">each</span> containing one <span style="background-color:yellow;">letter</span> of the prefix we were <span style="background-color:yellow;">looking</span> <span style="background-color:yellow;">for.</span> To construct the <span style="background-color:yellow;">string</span> , we <span style="background-color:yellow;">chain</span> them <span style="background-color:yellow;">into</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">single</span> <span style="background-color:yellow;">iterable</span> , <span style="background-color:yellow;">from</span> which we get the <span style="background-color:yellow;">letters</span> to <span style="background-color:yellow;">join</span> <span style="background-color:yellow;">into</span> the <span style="background-color:yellow;">final</span> <span style="background-color:yellow;">string</span> . </p>
<p>The <span style="background-color:yellow;">magic</span> of using <span style="background-color:yellow;">iterators</span> <span style="background-color:yellow;">is</span> that <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">items</span> <span style="background-color:yellow;">are</span> generated on <span style="background-color:yellow;">demand</span> , <span style="background-color:yellow;">so</span> when <span style="background-color:yellow;">takewhile</span> <span style="background-color:yellow;">stops</span> <span style="background-color:yellow;">asking</span> <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">items</span> , the zipping <span style="background-color:yellow;">stops</span> <span style="background-color:yellow;">at</span> that point <span style="background-color:yellow;">and</span> no unnecessary work <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">done.</span> Each <span style="background-color:yellow;">function</span> call <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">my</span> one-liner has <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">implicit</span> <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">implicit</span> break . </p>
<br /><b><span style="background-color:yellow;">#</span> <span style="background-color:yellow;">13</span> </b><br /><p>Just <span style="background-color:yellow;">for</span> the <span style="background-color:yellow;">fun</span> of <span style="background-color:yellow;">it</span> , here 's <span style="background-color:yellow;">a</span> version written <span style="background-color:yellow;">in</span> ( SWI- ) PROLOG : </p>
<pre><code>common_pre([[C|Cs]|Ss], [C|Res]) :-
  maplist(head_tail(C), [[C|Cs]|Ss], RemSs), !,
  common_pre(RemSs, Res).
common_pre(_, []).

head_tail(H, [H|T], T).
</code></pre>
<p>Running : </p>
<pre><code>?- S=["interspecies", "interstelar", "interstate"], common_pre(S, CP), string_to_list(CPString, CP).
</code></pre>
<p>Gives : </p>
<pre><code>CP = [105, 110, 116, 101, 114, 115],
CPString = "inters".
</code></pre>
<p>Explanation : </p>
<p>( SWI- ) PROLOG treats <span style="background-color:yellow;">strings</span> <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">lists</span> of <span style="background-color:yellow;">character</span> codes ( numbers ) . <span style="background-color:yellow;">All</span> the predicate common_pre/2 <span style="background-color:yellow;">does</span> <span style="background-color:yellow;">is</span> recursively pattern-match to <span style="background-color:yellow;">select</span> the <span style="background-color:yellow;">first</span> code ( C ) <span style="background-color:yellow;">from</span> the head of the <span style="background-color:yellow;">first</span> <span style="background-color:yellow;">list</span> ( <span style="background-color:yellow;">string</span> , [ C | Cs ] ) <span style="background-color:yellow;">in</span> the <span style="background-color:yellow;">list</span> of <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">lists</span> ( <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">strings</span> , [ [ C | Cs ] | Ss ] ) , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">appends</span> the <span style="background-color:yellow;">matching</span> code C to the result <span style="background-color:yellow;">iff</span> <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">is</span> common to <span style="background-color:yellow;">all</span> ( remaining ) heads of <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">lists</span> ( <span style="background-color:yellow;">strings</span> ) , <span style="background-color:yellow;">else</span> <span style="background-color:yellow;">it</span> terminates . </p>
<p>Nice , clean , <span style="background-color:yellow;">simple</span> <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">efficient...</span> : ) </p>
<br /><b><span style="background-color:yellow;">#</span> <span style="background-color:yellow;">14</span> </b><br /><p>This <span style="background-color:yellow;">is</span> by no <span style="background-color:yellow;">means</span> <span style="background-color:yellow;">elegant</span> , but <span style="background-color:yellow;">if</span> you want concise : </p>
<h2>Ruby , 71 <span style="background-color:yellow;">chars</span> </h2>
<pre><code>def f(a)b=a[0];b[0,(0..b.size).find{|n|a.any?{|i|i[0,n]!=b[0,n]}}-1]end
</code></pre>
<p>If you want that unrolled <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">looks</span> <span style="background-color:yellow;">like</span> this : </p>
<pre><code>def f(words)
  first_word = words[0];
  first_word[0, (0..(first_word.size)).find { |num_chars|
    words.any? { |word| word[0, num_chars] != first_word[0, num_chars] }
  } - 1]
end
</code></pre>
<br /><b><span style="background-color:yellow;">#</span> <span style="background-color:yellow;">15</span> </b><br /><p>Javascript clone of <span style="background-color:yellow;">AShelly</span> 's <span style="background-color:yellow;">excellent</span> <span style="background-color:yellow;">answer</span> . </p>
<p>Requires <span style="background-color:yellow;">Array</span> <span style="background-color:yellow;">#</span> reduce which <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">supported</span> only <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">firefox</span> . </p>
<pre><code>var strings = ["interspecies", "intermediate", "interrogation"]
var sub = strings.reduce(function(l,r) { 
    while(l!=r.slice(0,l.length)) {  
        l = l.slice(0, -1);
    }
    return l;
});
</code></pre>
<br /><b><span style="background-color:yellow;">#</span> <span style="background-color:yellow;">16</span> </b><br /><p>It 's not code golf , but you <span style="background-color:yellow;">asked</span> <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">somewhat</span> <span style="background-color:yellow;">elegant</span> , <span style="background-color:yellow;">and</span> I tend to think recursion <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">fun.</span> Java . </p>
<pre><code>/** Recursively find the common prefix. */
public String findCommonPrefix(String[] strings) {

    int minLength = findMinLength(strings);

    if (isFirstCharacterSame(strings)) {
    	return strings[0].charAt(0) + findCommonPrefix(removeFirstCharacter(strings));
    } else {
    	return "";
    }
}

/** Get the minimum length of a string in strings[]. */
private int findMinLength(final String[] strings) {
    int length = strings[0].size();
    for (String string : strings) {
    	if (string.size() < length) {
    		length = string.size();
    	}
    }
    return length;
}

/** Compare the first character of all strings. */
private boolean isFirstCharacterSame(String[] strings) {
    char c = string[0].charAt(0);
    for (String string : strings) {
    	if (c != string.charAt(0)) return false;
    }

    return true;
}

/** Remove the first character of each string in the array, 
    and return a new array with the results. */
private String[] removeFirstCharacter(String[] source) {
    String[] result = new String[source.length];
    for (int i=0; i<result.length; i++) {
    	result[i] = source[i].substring(1);	
    }
    return result;
}
</code></pre>
<br /><b><span style="background-color:yellow;">#</span> <span style="background-color:yellow;">17</span> </b><br /><p><span style="background-color:yellow;">A</span> ruby version based on @ Svante 's <span style="background-color:yellow;">algorithm.</span> Runs ~ 3x <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">fast</span> <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">my</span> <span style="background-color:yellow;">first</span> one . </p>
<pre><code> def common_prefix set 
   i=0
   rest=set[1..-1]
   set[0].each_byte{|c|
     rest.each{|e|return set[0][0...i] if e[i]!=c}
     i+=1
   }
   set
 end
</code></pre>
<br /><b><span style="background-color:yellow;">#</span> <span style="background-color:yellow;">18</span> </b><br /><p><span style="background-color:yellow;">A</span> <span style="background-color:yellow;">javascript</span> version based on @ Svante 's <span style="background-color:yellow;">algorithm</span> : </p>
<pre><code>function commonSubstring(words){
    var iChar, iWord,
        refWord = words[0],
        lRefWord = refWord.length,
        lWords = words.length;
    for (iChar = 0; iChar < lRefWord; iChar += 1) {
        for (iWord = 1; iWord < lWords; iWord += 1) {
            if (refWord[iChar] !== words[iWord][iChar]) {
                return refWord.substring(0, iChar);
            }
        }
    }
    return refWord;
}
</code></pre>
<br /><b><span style="background-color:yellow;">#</span> <span style="background-color:yellow;">19</span> </b><br /><p>Instead of <span style="background-color:yellow;">sorting</span> , you could <span style="background-color:yellow;">just</span> get the <span style="background-color:yellow;">min</span> <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">max</span> of the <span style="background-color:yellow;">strings</span> . </p>
<p>To <span style="background-color:yellow;">me</span> , <span style="background-color:yellow;">elegance</span> <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">a</span> computer program <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> balance of <span style="background-color:yellow;">speed</span> <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">simplicity</span> . It <span style="background-color:yellow;">should</span> not <span style="background-color:yellow;">do</span> unnecessary computation , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">should</span> be <span style="background-color:yellow;">simple</span> <span style="background-color:yellow;">enough</span> to <span style="background-color:yellow;">make</span> <span style="background-color:yellow;">its</span> correctness <span style="background-color:yellow;">evident</span> . </p>
<p>I could call the <span style="background-color:yellow;">sorting</span> <span style="background-color:yellow;">solution</span> " clever " , but not " <span style="background-color:yellow;">elegant</span> " . </p>
<br /><b><span style="background-color:yellow;">#</span> 20 </b><br /><p>Combining <span style="background-color:yellow;">answers</span> by kennebec , Florian F <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">jberryman</span> yields the <span style="background-color:yellow;">following</span> Haskell one-liner : </p>
<pre><code>commonPrefix l = map fst . takeWhile (uncurry (==)) $ zip (minimum l) (maximum l)
</code></pre>
<p>With Control.Arrow one can get <span style="background-color:yellow;">a</span> point-free <span style="background-color:yellow;">form</span> : </p>
<pre><code>commonPrefix = map fst . takeWhile (uncurry (==)) . uncurry zip . (minimum &&& maximum)
</code></pre>
<br /><b><span style="background-color:yellow;">#</span> 21 </b><br /><p>Oftentimes <span style="background-color:yellow;">it</span> 's <span style="background-color:yellow;">more</span> <span style="background-color:yellow;">elegant</span> to use <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">mature</span> open <span style="background-color:yellow;">source</span> <span style="background-color:yellow;">library</span> <span style="background-color:yellow;">instead</span> of rolling your own. Then , <span style="background-color:yellow;">if</span> <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">does</span> n't completely <span style="background-color:yellow;">suit</span> your needs , you can <span style="background-color:yellow;">extend</span> <span style="background-color:yellow;">it</span> or <span style="background-color:yellow;">modify</span> <span style="background-color:yellow;">it</span> to <span style="background-color:yellow;">improve</span> <span style="background-color:yellow;">it</span> , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">let</span> the community <span style="background-color:yellow;">decide</span> <span style="background-color:yellow;">if</span> that belongs <span style="background-color:yellow;">in</span> the <span style="background-color:yellow;">library</span> . </p>
<p><span style="background-color:yellow;">diff-lcs</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> good Ruby gem <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">least</span> common <span style="background-color:yellow;">substring</span> . </p>
<br />