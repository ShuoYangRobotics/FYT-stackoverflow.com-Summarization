<h3>Question ( ID-4740172 ) : </h3><h2>How do you a double <span style="background-color:yellow;">factorial</span> in python ? </h2><p>I 've been stucked on this question for a really long time . I 've managed to do a single recursive <span style="background-color:yellow;">factorial</span> . </p>
<pre><code>def factorial(n):
     if n == 0:
         return 1
     else:
         return n * factorial(n-1)
</code></pre>
<p>Double <span style="background-color:yellow;">factorial</span> For an even integer <span style="background-color:yellow;">n</span> , the double <span style="background-color:yellow;">factorial</span> is the product of all even positive integers less than or equal to <span style="background-color:yellow;">n.</span> For an odd integer p , the double <span style="background-color:yellow;">factorial</span> is the product of all odd positive integers less than or equal to p . </p>
<p>If <span style="background-color:yellow;">n</span> is even , then <span style="background-color:yellow;">n</span> ! ! = <span style="background-color:yellow;">n</span> * ( <span style="background-color:yellow;">n</span> - 2 ) * ( <span style="background-color:yellow;">n</span> - 4 ) * ( <span style="background-color:yellow;">n</span> - 6 ) * ... * 4 * 2 </p>
<p>If p is odd , then p ! ! = p * ( p - 2 ) * ( p - 4 ) * ( p - 6 ) * ... * 3 * 1 </p>
<p>But I have <span style="background-color:yellow;">no</span> idea to do a double <span style="background-color:yellow;">factorial.</span> Any help ? </p>
<br /><h3>Answers ( Total-7 ) : </h3><b># 0 </b><br /><pre><code>reduce(int.__mul__,range(n,0,-2))
</code></pre>
<br /><b># 1 </b><br /><p>Is <span style="background-color:yellow;">n't</span> that just the same as the <span style="background-color:yellow;">factorial</span> with a different ending condition and a different parameter to the recursion call ? </p>
<pre><code>def doublefactorial(n):
     if n <= 0:
         return 1
     else:
         return n * doublefactorial(n-2)
</code></pre>
<p>If <span style="background-color:yellow;">n</span> is even , then it will halt when <span style="background-color:yellow;">n</span> = = 0 . If <span style="background-color:yellow;">n</span> is odd , then it will halt when <span style="background-color:yellow;">n</span> = = -1 . </p>
<br /><b># 2 </b><br /><pre><code>def double_fact(number):
    if number==0 or number==1:
        return 1
    else:
        return number*double_fact(number-2)
</code></pre>
<p>I think this should work for you . </p>
<br /><b># 3 </b><br /><pre><code>def doublefactorial(n):
     if n <= 0:
         return 1
     else:
         return n * doublefactorial(n-2)
</code></pre>
<p>That should do it. Unless I 'm misunderstanding </p>
<br /><b># 4 </b><br /><pre><code>def doublefactorial(n):
     if n in (0, 1):
         return 1
     else:
         return n * doublefactorial(n-2)
</code></pre>
<p>should do it . </p>
<br /><b># 5 </b><br /><p>I hope I understand it correctly , but will this work </p>
<pre><code> def factorial(n):
 if n == 0 or n == 1:
     return 1
 else:
     return n * factorial(n-2)
</code></pre>
<br /><b># 6 </b><br /><p>reduce ( lambda x,y : y * x , range ( <span style="background-color:yellow;">n,1,-2</span> ) ) </p>
<p>Which is basically the same as the simple iterative version : </p>
<pre><code>x = n
for y in range(n-2, 1, -2):
    x*=y
</code></pre>
<p>Obviously you can also do it recursively , but what 's the point ? This kind of example implemented using recursivity are fine when using all recursive languages , but with imperative language it 's always making simple tools like recursivity looking more complex than <span style="background-color:yellow;">necessary</span> , while recursivity can be a real simplifier when dealing with fundamentally recursive structures like trees . </p>
<br />