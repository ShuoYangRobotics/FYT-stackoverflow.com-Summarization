<h3>Question ( ID-370357 ) : </h3><h2>Python variable scope question </h2><p>I 've <span style="background-color:yellow;">been</span> programming <span style="background-color:yellow;">for</span> many years , <span style="background-color:yellow;">and</span> recently started learning Python. The <span style="background-color:yellow;">following</span> <span style="background-color:yellow;">code</span> works <span style="background-color:yellow;">as</span> expected in <span style="background-color:yellow;">both</span> python 2.5 <span style="background-color:yellow;">and</span> 3.0 ( on OS X if that matters ) : </p>
<pre><code>a, b, c = (1, 2, 3)

print(a, b, c)

def test():
    print(a)
    print(b)
    print(c)    # (A)
    #c+=1       # (B)
test()
</code></pre>
<p>However , when I uncomment line ( <span style="background-color:yellow;">B</span> ) , I get <span style="background-color:yellow;">an</span> UnboundLocalError : 'c ' not <span style="background-color:yellow;">assigned</span> <span style="background-color:yellow;">at</span> line ( A ) . The values of <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">b</span> <span style="background-color:yellow;">are</span> printed <span style="background-color:yellow;">correctly.</span> This has me <span style="background-color:yellow;">completely</span> <span style="background-color:yellow;">baffled</span> <span style="background-color:yellow;">for</span> two reasons : </p>
<p><span style="background-color:yellow;">1</span> ) Why is there <span style="background-color:yellow;">an</span> runtime error thrown <span style="background-color:yellow;">at</span> line ( A ) <span style="background-color:yellow;">because</span> of <span style="background-color:yellow;">a</span> later statement on line ( <span style="background-color:yellow;">B</span> ) ? </p>
<p>2 ) Why <span style="background-color:yellow;">are</span> variables <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">b</span> printed <span style="background-color:yellow;">as</span> expected , while <span style="background-color:yellow;">c</span> raises <span style="background-color:yellow;">an</span> error ? </p>
<p>The only explanation I <span style="background-color:yellow;">can</span> <span style="background-color:yellow;">come</span> up with is that <span style="background-color:yellow;">a</span> local variable <span style="background-color:yellow;">c</span> is <span style="background-color:yellow;">created</span> <span style="background-color:yellow;">by</span> the <span style="background-color:yellow;">assignment</span> <span style="background-color:yellow;">c</span> + = <span style="background-color:yellow;">1</span> , which takes precedent over the " global " variable <span style="background-color:yellow;">c</span> even <span style="background-color:yellow;">before</span> the local variable is <span style="background-color:yellow;">created.</span> Of <span style="background-color:yellow;">course</span> , it does n't make sense <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">a</span> variable to " steal " scope <span style="background-color:yellow;">before</span> it exists . </p>
<p>Could someone please explain this <span style="background-color:yellow;">behavior</span> ? Thank you very much , <span style="background-color:yellow;">brainfsck</span> </p>
<br /><h3>Answers ( Total-7 ) : </h3><b># 0 </b><br /><p>Python treats variables in <span style="background-color:yellow;">functions</span> differently depending on whether you <span style="background-color:yellow;">assign</span> values to them <span style="background-color:yellow;">from</span> within the <span style="background-color:yellow;">function</span> or not. If you <span style="background-color:yellow;">assign</span> <span style="background-color:yellow;">any</span> value to <span style="background-color:yellow;">a</span> variable , it is treated <span style="background-color:yellow;">by</span> default <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> local variable. Therefore , when you uncomment the line , you <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">attempting</span> to reference <span style="background-color:yellow;">a</span> local variable <span style="background-color:yellow;">before</span> <span style="background-color:yellow;">any</span> value has <span style="background-color:yellow;">been</span> <span style="background-color:yellow;">assigned</span> to it . </p>
<p>If you want the variable <span style="background-color:yellow;">c</span> to refer to the global <span style="background-color:yellow;">c</span> put </p>
<pre><code>global c
</code></pre>
<p><span style="background-color:yellow;">as</span> the <span style="background-color:yellow;">first</span> line of the <span style="background-color:yellow;">function</span> . </p>
<p>As of python 3 , there is now </p>
<pre><code>nonlocal c
</code></pre>
<p>that you <span style="background-color:yellow;">can</span> use to refer to the nearest enclosing ( not necessarily global ) scope . </p>
<br /><b># <span style="background-color:yellow;">1</span> </b><br /><p>okay , here 's the deal. Python is <span style="background-color:yellow;">a</span> little weird , in that it keeps everything in <span style="background-color:yellow;">a</span> dictionary <span style="background-color:yellow;">for</span> the various scopes. The original <span style="background-color:yellow;">a,b,c</span> <span style="background-color:yellow;">are</span> in the uppermost scope <span style="background-color:yellow;">and</span> so in that uppermost dictionary. The <span style="background-color:yellow;">function</span> has its own dictionary. When you reach the print ( <span style="background-color:yellow;">a</span> ) <span style="background-color:yellow;">and</span> print ( <span style="background-color:yellow;">b</span> ) statements , there 's nothing <span style="background-color:yellow;">by</span> that name in the dictionary , so Python looks up the list <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">finds</span> them in the <span style="background-color:yellow;">clobal</span> dictionary . </p>
<p>Now we get to <span style="background-color:yellow;">c</span> + = <span style="background-color:yellow;">1</span> , which is , of <span style="background-color:yellow;">course</span> , equivalent to <span style="background-color:yellow;">c</span> = <span style="background-color:yellow;">c</span> + <span style="background-color:yellow;">1</span> . When Python scans that line , it says " <span style="background-color:yellow;">ahah</span> , there 's <span style="background-color:yellow;">a</span> variable named <span style="background-color:yellow;">c</span> , I 'll put it into my local scope dictionary. " Then when it goes looking <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">a</span> value <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">c</span> <span style="background-color:yellow;">for</span> the <span style="background-color:yellow;">c</span> on the right hand side of the <span style="background-color:yellow;">assignment</span> , it <span style="background-color:yellow;">finds</span> its local variable named <span style="background-color:yellow;">c</span> , which has no value yet , <span style="background-color:yellow;">and</span> so throws the error . </p>
<p>The statement global <span style="background-color:yellow;">c</span> mentioned <span style="background-color:yellow;">above</span> simply tells the parser that it uses the <span style="background-color:yellow;">c</span> <span style="background-color:yellow;">from</span> the global scope <span style="background-color:yellow;">and</span> so does n't need <span style="background-color:yellow;">a</span> new one . </p>
<p>The reason it says there 's <span style="background-color:yellow;">an</span> issue on the line it does is <span style="background-color:yellow;">because</span> it is effectively looking <span style="background-color:yellow;">for</span> the names <span style="background-color:yellow;">before</span> it tries to generate <span style="background-color:yellow;">code</span> , <span style="background-color:yellow;">and</span> so in some sense does n't think it 's really doing that line yet. I 'd <span style="background-color:yellow;">argue</span> that is <span style="background-color:yellow;">a</span> useability <span style="background-color:yellow;">bug</span> , <span style="background-color:yellow;">but</span> it 's generally <span style="background-color:yellow;">a</span> good practice to just learn not to take <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">compiler</span> 's messages too seriously . </p>
<p>If it 's <span style="background-color:yellow;">any</span> <span style="background-color:yellow;">comfort</span> , I spent probably <span style="background-color:yellow;">a</span> day digging <span style="background-color:yellow;">and</span> experimenting with this same issue <span style="background-color:yellow;">before</span> I <span style="background-color:yellow;">found</span> something Guido had written <span style="background-color:yellow;">about</span> the dictionaries that Explained Everything . </p>
<h3>Update , see <span style="background-color:yellow;">comments</span> : </h3>
<p>It does n't scan the <span style="background-color:yellow;">code</span> twice , <span style="background-color:yellow;">but</span> it does scan the <span style="background-color:yellow;">code</span> in two phases , lexing <span style="background-color:yellow;">and</span> parsing . </p>
<p>Consider how the parse of this <span style="background-color:yellow;">cline</span> of <span style="background-color:yellow;">code</span> works. The lexer reads the source text <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">breaks</span> it into lexemes , the " smallest <span style="background-color:yellow;">components</span> " of the grammar. So when it hits the line </p>
<pre><code>c+=1
</code></pre>
<p>it <span style="background-color:yellow;">breaks</span> it up into something like </p>
<pre><code>SYMBOL(c) OPERATOR(+=) DIGIT(1)
</code></pre>
<p>The parser eventually wants to make this into <span style="background-color:yellow;">a</span> parse tree <span style="background-color:yellow;">and</span> execute it , <span style="background-color:yellow;">but</span> since it 's <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">assignment</span> , <span style="background-color:yellow;">before</span> it does , it looks <span style="background-color:yellow;">for</span> the name <span style="background-color:yellow;">c</span> in the local dictionary , does n't see it , <span style="background-color:yellow;">and</span> inserts it in the dictionary , marking it <span style="background-color:yellow;">as</span> uninitialized. In <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">fullly</span> <span style="background-color:yellow;">compiled</span> language , it would just go into the symbol table <span style="background-color:yellow;">and</span> wait <span style="background-color:yellow;">for</span> the parse , <span style="background-color:yellow;">but</span> since it WO N'T have the luxury of <span style="background-color:yellow;">a</span> second pass , the lexer does <span style="background-color:yellow;">a</span> little extra work to make life easier later on. Only , then it sees the OPERATOR , sees that the rules say " if you have <span style="background-color:yellow;">an</span> operator + = the left hand side must have <span style="background-color:yellow;">been</span> initialized " <span style="background-color:yellow;">and</span> says " whoops ! " </p>
<p>The point here is that it has n't really started the parse of the line yet . This is <span style="background-color:yellow;">all</span> happening sort of preparatory to the <span style="background-color:yellow;">actual</span> parse , so the line <span style="background-color:yellow;">counter</span> has n't <span style="background-color:yellow;">advanced</span> to the next line. Thus when it signals the error , it still thinks its on the previous line . </p>
<p>As I say , you <span style="background-color:yellow;">could</span> <span style="background-color:yellow;">argue</span> it 's <span style="background-color:yellow;">a</span> usability <span style="background-color:yellow;">bug</span> , <span style="background-color:yellow;">but</span> its <span style="background-color:yellow;">actually</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">fairly</span> <span style="background-color:yellow;">common</span> thing. Some <span style="background-color:yellow;">compilers</span> <span style="background-color:yellow;">are</span> more honest <span style="background-color:yellow;">about</span> it <span style="background-color:yellow;">and</span> say " error on or <span style="background-color:yellow;">around</span> line XXX " , <span style="background-color:yellow;">but</span> this one does n't . </p>
<br /><b># 2 </b><br /><p>Taking <span style="background-color:yellow;">a</span> look <span style="background-color:yellow;">at</span> the <span style="background-color:yellow;">disassembly</span> may <span style="background-color:yellow;">clarify</span> what is happening : </p>
<pre><code>>>> def f():
...    print a
...    print b
...    a = 1

>>> import dis
>>> dis.dis(f)

  2           0 LOAD_FAST                0 (a)
              3 PRINT_ITEM
              4 PRINT_NEWLINE

  3           5 LOAD_GLOBAL              0 (b)
              8 PRINT_ITEM
              9 PRINT_NEWLINE

  4          10 LOAD_CONST               1 (1)
             13 STORE_FAST               0 (a)
             16 LOAD_CONST               0 (None)
             19 RETURN_VALUE
</code></pre>
<p>As you <span style="background-color:yellow;">can</span> see , the <span style="background-color:yellow;">bytecode</span> <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">accessing</span> <span style="background-color:yellow;">a</span> is LOAD_FAST , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">b</span> , LOAD_GLOBAL . This is <span style="background-color:yellow;">because</span> the <span style="background-color:yellow;">compiler</span> has identified that <span style="background-color:yellow;">a</span> is <span style="background-color:yellow;">assigned</span> to within the <span style="background-color:yellow;">function</span> , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">classified</span> it <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> local variable. The <span style="background-color:yellow;">access</span> mechanism <span style="background-color:yellow;">for</span> locals is <span style="background-color:yellow;">fundamentally</span> different <span style="background-color:yellow;">for</span> globals - they <span style="background-color:yellow;">are</span> statically <span style="background-color:yellow;">assigned</span> <span style="background-color:yellow;">an</span> offset in the <span style="background-color:yellow;">frame</span> 's variables table , meaning lookup is <span style="background-color:yellow;">a</span> quick index , rather than the more expensive dict lookup <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">for</span> globals. <span style="background-color:yellow;">Because</span> of this , Python is reading the print <span style="background-color:yellow;">a</span> line <span style="background-color:yellow;">as</span> " get the value of local variable 'a ' held in slot 0 , <span style="background-color:yellow;">and</span> print it " , <span style="background-color:yellow;">and</span> when it detects that this variable is still uninitialised , raises <span style="background-color:yellow;">an</span> exception . </p>
<br /><b># 3 </b><br /><p>Python has rather interesting <span style="background-color:yellow;">behavior</span> when you try traditional global variable semantics. I do n't remember the details , <span style="background-color:yellow;">but</span> you <span style="background-color:yellow;">can</span> read the value of <span style="background-color:yellow;">a</span> variable declared in 'global ' scope just <span style="background-color:yellow;">fine</span> , if you want to modify it , you have to use the global keyword. Try <span style="background-color:yellow;">changing</span> <span style="background-color:yellow;">test</span> ( ) to this : </p>
<pre><code>def test():
    global c
    print(a)
    print(b)
    print(c)    # (A)
    c+=1       # (B)
</code></pre>
<p>Also , the reason you <span style="background-color:yellow;">are</span> getting this error is <span style="background-color:yellow;">because</span> you <span style="background-color:yellow;">can</span> <span style="background-color:yellow;">also</span> declare <span style="background-color:yellow;">a</span> new variable inside that <span style="background-color:yellow;">function</span> with the same name <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> 'global ' one , <span style="background-color:yellow;">and</span> it would <span style="background-color:yellow;">be</span> <span style="background-color:yellow;">completely</span> separate. The interpreter thinks you <span style="background-color:yellow;">are</span> trying to make <span style="background-color:yellow;">a</span> new variable in this scope <span style="background-color:yellow;">called</span> 'c ' <span style="background-color:yellow;">and</span> modify it <span style="background-color:yellow;">all</span> in one operation , which is n't <span style="background-color:yellow;">allowed</span> in python <span style="background-color:yellow;">because</span> this new 'c ' was n't initialized . </p>
<br /><b># 4 </b><br /><p>This is not <span style="background-color:yellow;">a</span> direct <span style="background-color:yellow;">answer</span> to your question , <span style="background-color:yellow;">but</span> it is <span style="background-color:yellow;">closely</span> related , <span style="background-color:yellow;">as</span> it 's <span style="background-color:yellow;">another</span> gotcha <span style="background-color:yellow;">caused</span> <span style="background-color:yellow;">by</span> the relationship <span style="background-color:yellow;">between</span> <span style="background-color:yellow;">augmented</span> <span style="background-color:yellow;">assignment</span> <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">function</span> scopes . </p>
<p>In most <span style="background-color:yellow;">cases</span> , you tend to think of <span style="background-color:yellow;">augmented</span> <span style="background-color:yellow;">assignment</span> ( <span style="background-color:yellow;">a</span> + = <span style="background-color:yellow;">b</span> ) <span style="background-color:yellow;">as</span> exactly equivalent to simple <span style="background-color:yellow;">assignment</span> ( <span style="background-color:yellow;">a</span> = <span style="background-color:yellow;">a</span> + <span style="background-color:yellow;">b</span> ) . It is possible to get into some trouble with this though , in one <span style="background-color:yellow;">corner</span> <span style="background-color:yellow;">case.</span> Let me explain : </p>
<p>The way python 's simple <span style="background-color:yellow;">assignment</span> works means that if <span style="background-color:yellow;">a</span> is passed into <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">function</span> ( like <span style="background-color:yellow;">func</span> ( <span style="background-color:yellow;">a</span> ) ; note that python is <span style="background-color:yellow;">always</span> pass-by-reference ) , then <span style="background-color:yellow;">a</span> = <span style="background-color:yellow;">a</span> + <span style="background-color:yellow;">b</span> will not modify the <span style="background-color:yellow;">a</span> that is passed in. Instead , it will just modify the local pointer to <span style="background-color:yellow;">a</span> . </p>
<p><span style="background-color:yellow;">But</span> if you use <span style="background-color:yellow;">a</span> + = <span style="background-color:yellow;">b</span> , then it is sometimes implemented <span style="background-color:yellow;">as</span> : </p>
<pre><code>a = a + b
</code></pre>
<p>or sometimes ( if the method exists ) <span style="background-color:yellow;">as</span> : </p>
<pre><code>a.__iadd__(b)
</code></pre>
<p>In the <span style="background-color:yellow;">first</span> <span style="background-color:yellow;">case</span> ( <span style="background-color:yellow;">as</span> long <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> is not declared global ) , there <span style="background-color:yellow;">are</span> no side-effects outside local scope , <span style="background-color:yellow;">as</span> the <span style="background-color:yellow;">assignment</span> to " <span style="background-color:yellow;">a</span> " is just <span style="background-color:yellow;">a</span> pointer update . </p>
<p>In the second <span style="background-color:yellow;">case</span> , <span style="background-color:yellow;">a</span> will <span style="background-color:yellow;">actually</span> modify itself , so <span style="background-color:yellow;">all</span> references to <span style="background-color:yellow;">a</span> will point to the modified version. This is demonstrated <span style="background-color:yellow;">by</span> the <span style="background-color:yellow;">following</span> <span style="background-color:yellow;">code</span> : </p>
<pre><code>def copy_on_write(a):
      a = a + a
def inplace_add(a):
      a += a
a = [1]
copy_on_write(a)
print a # [1]
inplace_add(a)
print a # [1, 1]
b = 1
copy_on_write(b)
print b # [1]
inplace_add(b)
print b # 1
</code></pre>
<p>So the trick is to <span style="background-color:yellow;">avoid</span> <span style="background-color:yellow;">augmented</span> <span style="background-color:yellow;">assignment</span> on <span style="background-color:yellow;">function</span> <span style="background-color:yellow;">arguments</span> ( I try to only use it <span style="background-color:yellow;">for</span> local/loop variables ) . Use simple <span style="background-color:yellow;">assignment</span> , <span style="background-color:yellow;">and</span> you will <span style="background-color:yellow;">be</span> safe <span style="background-color:yellow;">from</span> <span style="background-color:yellow;">ambiguous</span> <span style="background-color:yellow;">behaviour</span> . </p>
<br /><b># 5 </b><br /><p>Here <span style="background-color:yellow;">are</span> two links that may help </p>
<p><span style="background-color:yellow;">1</span> : docs.python.org/3.1/faq/programming.html ? highlight = nonlocal # why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value </p>
<p>2 : docs.python.org/3.1/faq/programming.html ? highlight = nonlocal # how-do-i-write-a-function-with-output-parameters-call-by-reference </p>
<p>link one describes the error UnboundLocalError. Link two <span style="background-color:yellow;">can</span> help with with re-writing your <span style="background-color:yellow;">test</span> <span style="background-color:yellow;">function.</span> <span style="background-color:yellow;">Based</span> on link two , the original problem <span style="background-color:yellow;">could</span> <span style="background-color:yellow;">be</span> rewritten <span style="background-color:yellow;">as</span> : </p>
<pre><code>>>> a, b, c = (1, 2, 3)
>>> print (a, b, c)
(1, 2, 3)
>>> def test (a, b, c):
...     print (a)
...     print (b)
...     print (c)
...     c += 1
...     return a, b, c
...
>>> a, b, c = test (a, b, c)
1
2
3
>>> print (a, b ,c)
(1, 2, 4)
</code></pre>
<br /><b># 6 </b><br /><p>The Python interpreter will read <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">function</span> <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">complete</span> unit. I think of it <span style="background-color:yellow;">as</span> reading it in two passes , once to gather its <span style="background-color:yellow;">closure</span> ( the local variables ) , then <span style="background-color:yellow;">again</span> to turn it into <span style="background-color:yellow;">byte-code</span> . </p>
<p>As I 'm sure you were <span style="background-color:yellow;">already</span> <span style="background-color:yellow;">aware</span> , <span style="background-color:yellow;">any</span> name used on the left of <span style="background-color:yellow;">a</span> ' = ' is implicitly <span style="background-color:yellow;">a</span> local variable. More than once I 've <span style="background-color:yellow;">been</span> <span style="background-color:yellow;">caught</span> out <span style="background-color:yellow;">by</span> <span style="background-color:yellow;">changing</span> <span style="background-color:yellow;">a</span> variable <span style="background-color:yellow;">access</span> to <span style="background-color:yellow;">a</span> + = <span style="background-color:yellow;">and</span> it 's suddenly <span style="background-color:yellow;">a</span> different variable . </p>
<p>I <span style="background-color:yellow;">also</span> wanted to point out it 's not really <span style="background-color:yellow;">anything</span> to do with global scope specifically. You get the same <span style="background-color:yellow;">behaviour</span> with nested <span style="background-color:yellow;">functions</span> . </p>
<br />