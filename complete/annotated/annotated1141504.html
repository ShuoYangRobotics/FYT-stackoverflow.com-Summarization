<h3>Question ( ID-1141504 ) : </h3><h2>Name this python/ruby language construct ( using <span style="background-color:yellow;">array</span> values to satisfy function parameters ) </h2><p>What is this language construct called ? </p>
<p>In Python I can say : </p>
<pre><code>def a(b,c): return b+c
a(*[4,5])
</code></pre>
<p><span style="background-color:yellow;">and</span> get 9. Likewise in Ruby : </p>
<pre><code>def a(b,c) b+c end
a(*[4,5])
</code></pre>
<p>What is this called , when one passes <span style="background-color:yellow;">a</span> single <span style="background-color:yellow;">array</span> to <span style="background-color:yellow;">a</span> function which otherwise requires multiple <span style="background-color:yellow;">arguments</span> ? </p>
<p>What is the name of the * operator ? </p>
<p>What other languages support this cool feature ? </p>
<p>Thanks ! </p>
<br /><h3>Answers ( Total-7 ) : </h3><b># 0 </b><br /><p>The Python docs call this Unpacking Argument Lists . It 's <span style="background-color:yellow;">a</span> pretty handy feature. In Python , you can <span style="background-color:yellow;">also</span> use <span style="background-color:yellow;">a</span> double <span style="background-color:yellow;">asterisk</span> ( * * ) to unpack <span style="background-color:yellow;">a</span> dictionary ( hash ) into keyword <span style="background-color:yellow;">arguments.</span> They <span style="background-color:yellow;">also</span> work in reverse. I can define <span style="background-color:yellow;">a</span> function like this : </p>
<pre><code>def sum(*args):
    result = 0
    for a in args:
        result += a
    return result

sum(1,2)
sum(9,5,7,8)
sum(1.7,2.3,8.9,3.4)
</code></pre>
<p>To pack <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">arguments</span> into <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">arbitrarily</span> sized list . </p>
<br /><b># 1 </b><br /><p>In ruby , it is often called " splat " . </p>
<p>Also in ruby , you can use it to mean 'all of the other elements in the list' . </p>
<pre><code>a, *rest = [1,2,3,4,5,6]
a     # => 1
rest  # => [2, 3, 4, 5, 6]
</code></pre>
<p>It can <span style="background-color:yellow;">also</span> <span style="background-color:yellow;">appear</span> on either side of the <span style="background-color:yellow;">assignment</span> operator : </p>
<pre><code>a  = d, *e
</code></pre>
<p>In this usage , it is <span style="background-color:yellow;">a</span> bit like scheme 's cdr , <span style="background-color:yellow;">although</span> it need n't be <span style="background-color:yellow;">all</span> but the head of the list . </p>
<br /><b># 2 </b><br /><p>I 've been calling it " list expansion " , but I do n't think that 's standard terminology ( I do n't think there 's <span style="background-color:yellow;">any...</span> ) . Lisp in <span style="background-color:yellow;">all</span> versions ( Scheme included ) , <span style="background-color:yellow;">and</span> Haskell <span style="background-color:yellow;">and</span> other functional languages , can do it easily enough , but I do n't think it 's easy to do in " mainstream " languages ( maybe you can pull it off <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> " reflection " stunt in some ! - ) . </p>
<br /><b># 3 </b><br /><p>The typical terminology for this is called " <span style="background-color:yellow;">applying</span> <span style="background-color:yellow;">a</span> function to <span style="background-color:yellow;">a</span> list " , or " <span style="background-color:yellow;">apply</span> " for short . </p>
<p>See http : //en.wikipedia.org/wiki/Apply </p>
<p>It has been in LISP since pretty much its inception back in 1960 odd . Glad python rediscovered it : - } </p>
<p>Apply is typically on <span style="background-color:yellow;">a</span> list or <span style="background-color:yellow;">a</span> representation of <span style="background-color:yellow;">a</span> list such <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">array.</span> However , one can <span style="background-color:yellow;">apply</span> functions to <span style="background-color:yellow;">arguments</span> that come from other palces , such <span style="background-color:yellow;">as</span> structs. Our PARLANSE language has fixed types ( int , float , string , ... ) <span style="background-color:yellow;">and</span> structures . Oddly enough , <span style="background-color:yellow;">a</span> function <span style="background-color:yellow;">argument</span> list looks <span style="background-color:yellow;">a</span> lot like <span style="background-color:yellow;">a</span> structure definintion , <span style="background-color:yellow;">and</span> in PARLANSE , it is <span style="background-color:yellow;">a</span> structure definition , <span style="background-color:yellow;">and</span> you can " <span style="background-color:yellow;">apply</span> " <span style="background-color:yellow;">a</span> PARLANSE function to <span style="background-color:yellow;">a</span> compatible structure . You can " make " structure instances , too , thus : </p>
<pre>

 (define S
    (structure [t integer]
               [f float]
               [b (array boolean 1 3)]
    )structure
 )define s

  (= A (array boolean 1 3 ~f ~F ~f))

  (= s (make S -3 19.2 (make (array boolean 1 3) ~f ~t ~f))


  (define foo (function string S) ...)

  (foo +17 3e-2 A) ; standard function call

  (foo s) ; here's the "apply"

</pre>
<p>PARLANSE looks like lisp but is n't . </p>
<br /><b># 4 </b><br /><p>ruby calls it 'splat ' , though david black has <span style="background-color:yellow;">also</span> come up with the neat " unar { ,ra } y operator " ( i.e. 'unary unarray operator ' ) </p>
<br /><b># 5 </b><br /><p>The majority of the questions have already been answered, but as to the question "What is the name of the * operator?": the technical term is "asterisk" (comes from the Latin word <em>asteriscum</em>, meaning "little star", which, in turn, comes from the Greek <em>ἀστερίσκος</em>). Often, though, it will be referred to as "star" or, as stated above, "splat".</p>
<br /><b># 6 </b><br /><p>Haskell has it too ( for pairs ) , with the uncurry function : </p>
<pre><code>ghci> let f x y = 2*x + y
f :: (Num a) => a -> a -> a
ghci> f 1 2
4
ghci> f 10 3
23
ghci> uncurry f (1,2)
4
ghci> uncurry f (10,3)
23
</code></pre>
<p>You can <span style="background-color:yellow;">also</span> make it into <span style="background-color:yellow;">an</span> operator , so it 's more splat-like : </p>
<pre><code>ghci> f `uncurry` (1,2)
4
ghci> let (***) = uncurry
(***) :: (a -> b -> c) -> (a, b) -> c
ghci> f *** (10,3)
23
</code></pre>
<p>And though it 'd be easy to define similar functions for the 3-tuple , 4-tuple , etc cases , there is n't <span style="background-color:yellow;">any</span> general function for n -tuples ( like splat works in other languages ) because of Haskell 's strict typing . </p>
<br />