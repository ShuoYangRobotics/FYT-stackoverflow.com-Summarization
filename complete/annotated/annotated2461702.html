<h3>Question ( ID-2461702 ) : </h3><h2>Why is IoC / DI not common in Python ? </h2><p>In Java IoC / DI is <span style="background-color:yellow;">a</span> very common practice which is extensively used in web <span style="background-color:yellow;">applications</span> , nearly <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">available</span> frameworks <span style="background-color:yellow;">and</span> Java EE. On the other hand , there <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">also</span> lots of big Python web <span style="background-color:yellow;">applications</span> , but beside of Zope ( which I 've heard should be really horrible to code ) IoC does n't seem to be very common in the Python world. ( Please name some examples if you think that I 'm wrong ) . </p>
<p>There <span style="background-color:yellow;">are</span> of course several clones of popular Java IoC frameworks <span style="background-color:yellow;">available</span> for Python , springpython for example. But none of them seems to get used practically. At least , I 've never stumpled upon <span style="background-color:yellow;">a</span> Django or sqlalchemy + &lt ; insert your favorite wsgi toolkit here&gt ; based web <span style="background-color:yellow;">application</span> which uses something like that . </p>
<p>In my opinion IoC has reasonable advantages and would make it easy to replace the django-default-user-model for example, but extensive usage of interface classes and IoC in Python looks a bit odd and not »pythonic«. But maybe someone has a better explanation, why IoC isn't widely used in Python.</p>
<br /><h3>Answers ( Total-8 ) : </h3><b># 0 </b><br /><p>I do n't <span style="background-color:yellow;">actually</span> think that DI/IoC <span style="background-color:yellow;">are</span> that uncommon in Python. What is uncommon , however , <span style="background-color:yellow;">are</span> DI/IoC frameworks/containers . </p>
<p>Think <span style="background-color:yellow;">about</span> it : what does <span style="background-color:yellow;">a</span> DI container do ? It <span style="background-color:yellow;">allows</span> you to </p>
<ol>wire together independent components into <span style="background-color:yellow;">a</span> complete <span style="background-color:yellow;">application</span> .. . ... <span style="background-color:yellow;">at</span> runtime . </ol>
<p>We have names for " wiring together " <span style="background-color:yellow;">and</span> " <span style="background-color:yellow;">at</span> runtime " : </p>
<ol>scripting dynamic </ol>
<p>So , <span style="background-color:yellow;">a</span> DI container is nothing but <span style="background-color:yellow;">an</span> interpreter for <span style="background-color:yellow;">a</span> dynamic scripting language. Actually , let me rephrase that : <span style="background-color:yellow;">a</span> typical Java/.NET DI container is nothing but <span style="background-color:yellow;">a</span> crappy interpreter for <span style="background-color:yellow;">a</span> really bad dynamic scripting language with butt-ugly , often XML-based , syntax . </p>
<p>When you program in Python , why would you want to use <span style="background-color:yellow;">an</span> ugly , bad scripting language when you have <span style="background-color:yellow;">a</span> beautiful , brilliant scripting language <span style="background-color:yellow;">at</span> your disposal ? Actually , that 's <span style="background-color:yellow;">a</span> more general question : when you program in pretty much <span style="background-color:yellow;">any</span> language , why would you want to use <span style="background-color:yellow;">an</span> ugly , bad scripting language when you have Jython <span style="background-color:yellow;">and</span> IronPython <span style="background-color:yellow;">at</span> your disposal ? </p>
<p>So , to recap : the practice of DI/IoC is just <span style="background-color:yellow;">as</span> important in Python <span style="background-color:yellow;">as</span> it is in Java , for exactly the same reasons. The implementation of DI/IoC however , is built into the language <span style="background-color:yellow;">and</span> often so lightweight that it completely vanishes. ( Here 's <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">analogy</span> : in <span style="background-color:yellow;">assembly</span> , <span style="background-color:yellow;">a</span> subroutine call is <span style="background-color:yellow;">a</span> pretty major deal - you have to save your local variables <span style="background-color:yellow;">and</span> registers to memory , save your return <span style="background-color:yellow;">address</span> somewhere , change the instruction pointer to the subroutine you <span style="background-color:yellow;">are</span> calling , <span style="background-color:yellow;">arrange</span> for it to somehow jump back into your subroutine when it is finished , put the <span style="background-color:yellow;">arguments</span> somewhere where the callee can find them , <span style="background-color:yellow;">and</span> so on. IOW : in <span style="background-color:yellow;">assembly</span> , " subroutine call " is <span style="background-color:yellow;">a</span> Design Pattern , <span style="background-color:yellow;">and</span> before there were languages like Fortran which had subroutine calls built in , people were building their own " subroutine frameworks " . Would you say that subroutine calls <span style="background-color:yellow;">are</span> " uncommon " in Python , just because you do n't use subroutine frameworks ? ) </p>
<p>BTW : for <span style="background-color:yellow;">an</span> example of what it looks like to take DI to its logical conclusion , take <span style="background-color:yellow;">a</span> look <span style="background-color:yellow;">at</span> Gilad Bracha 's Newspeak Programming Language <span style="background-color:yellow;">and</span> his writings on the subject : </p>
<ul>Constructors Considered Harmful Lethal Injection A Ban on Imports ( continued ) </ul>
<br /><b># 1 </b><br /><p>Part of it is the way the module system works in Python. You can get <span style="background-color:yellow;">a</span> sort of " singleton " for free , just by importing it from <span style="background-color:yellow;">a</span> module. Define <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">actual</span> instance of <span style="background-color:yellow;">an</span> object in <span style="background-color:yellow;">a</span> module , <span style="background-color:yellow;">and</span> then <span style="background-color:yellow;">any</span> client code can import it <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">actually</span> get <span style="background-color:yellow;">a</span> working , fully constructed / populated object . </p>
<p>This is in contrast to Java , where you do n't import <span style="background-color:yellow;">actual</span> instances of objects. This means you <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">always</span> having to instantiate them yourself , ( or use some sort of IoC/DI style <span style="background-color:yellow;">approach</span> ) . You can mitigate the hassle of having to instantiate everything yourself by having static factory methods ( or <span style="background-color:yellow;">actual</span> factory classes ) , but then you still incur the resource overhead of <span style="background-color:yellow;">actually</span> creating new ones each time . </p>
<br /><b># 2 </b><br /><p>In my opinion , things like dependency injection <span style="background-color:yellow;">are</span> symptoms of <span style="background-color:yellow;">a</span> rigid <span style="background-color:yellow;">and</span> over-complex framework. When the main body of code becomes much too weighty to change easily , you find yourself having to pick small parts of it , define interfaces for them , <span style="background-color:yellow;">and</span> then <span style="background-color:yellow;">allowing</span> people to change behaviour via the objects that plug into those interfaces. That 's <span style="background-color:yellow;">all</span> well <span style="background-color:yellow;">and</span> good , but it 's better to <span style="background-color:yellow;">avoid</span> that sort of complexity in the first place . </p>
<p>It 's <span style="background-color:yellow;">also</span> the symptom of <span style="background-color:yellow;">a</span> statically-typed language. When the only tool you have to express <span style="background-color:yellow;">abstraction</span> is inheritance , then that 's pretty much what you use everywhere. Having said that , C + + is pretty similar but never picked up the fascination with Builders <span style="background-color:yellow;">and</span> Interfaces everywhere that Java developers did. It is easy to get over-exuberant with the dream of being flexible <span style="background-color:yellow;">and</span> extensible <span style="background-color:yellow;">at</span> the cost of writing far too much generic code with little real benefit . I think it 's <span style="background-color:yellow;">a</span> cultural thing . </p>
<p>Typically I think Python people <span style="background-color:yellow;">are</span> used to picking the right tool for the job , which is <span style="background-color:yellow;">a</span> coherent <span style="background-color:yellow;">and</span> simple whole , rather than the One True Tool ( With A Thousand Possible Plugins ) that can do <span style="background-color:yellow;">anything</span> but offers <span style="background-color:yellow;">a</span> bewildering <span style="background-color:yellow;">array</span> of possible configuration permutations. There <span style="background-color:yellow;">are</span> still interchangeable parts where necessary , but with no need for the big formalism of defining fixed interfaces , due to the flexibility of duck-typing <span style="background-color:yellow;">and</span> the relative simplicity of the language . </p>
<br /><b># 3 </b><br /><p>Have n't used Python in several years , but I would say that it has more to do with it being <span style="background-color:yellow;">a</span> dynamically typed language than <span style="background-color:yellow;">anything</span> else. For <span style="background-color:yellow;">a</span> simple example , in Java , if I wanted to test that something wrote to standard out <span style="background-color:yellow;">appropriately</span> I could use DI <span style="background-color:yellow;">and</span> pass in <span style="background-color:yellow;">any</span> PrintStream to capture the text being written <span style="background-color:yellow;">and</span> verify it. When I 'm working in Ruby , however , I can dynamically replace the 'puts ' method on STDOUT to do the verify , leaving DI completely out of the picture. If the only reason I 'm creating <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">abstraction</span> is to test the class that 's using it ( think File system operations or the clock in Java ) then DI/IoC creates unnecessary complexity in the solution . </p>
<br /><b># 4 </b><br /><p>Django makes great use of inversion of control. For instance , the database server is selected by the configuration file , then the framework provides <span style="background-color:yellow;">appropriate</span> database wrapper instances to database clients . </p>
<p>The difference is that Python has first-class types. Data types , including classes , <span style="background-color:yellow;">are</span> themselves objects. If you want something to use <span style="background-color:yellow;">a</span> particular class , simply name the class. For example : </p>
<pre><code>if config_dbms_name == 'postgresql':
    import psycopg
    self.database_interface = psycopg
elif config_dbms_name == 'mysql':
    ...
</code></pre>
<p>Later code can then create <span style="background-color:yellow;">a</span> database interface by writing : </p>
<pre><code>my_db_connection = self.database_interface()
# Do stuff with database.
</code></pre>
<p>Instead of the boilerplate factory functions that Java <span style="background-color:yellow;">and</span> C + + need , Python does it with one or two lines of ordinary code. This is the strength of functional versus imperative programming . </p>
<br /><b># 5 </b><br /><p>Actually , it is quite easy to write sufficiently clean <span style="background-color:yellow;">and</span> compact code with DI ( I wonder , will it be/stay pythonic then , but <span style="background-color:yellow;">anyway</span> : ) ) , for example I <span style="background-color:yellow;">actually</span> perefer this way of coding : </p>
<pre><code>def polite(name_str):
    return "dear " + name_str

def rude(a):
    return name_str + ", you, moron"

def greet(name_str, call=polite):
    print "Hello, " + call(name_str) + "!"
</code></pre>
<p>_ </p>
<pre><code>>>greet("Peter")
Hello, dear Peter!
>>greet("Jack", rude)
Hello, Jack, you, moron!
</code></pre>
<p>Yes , this can be viewed <span style="background-color:yellow;">as</span> just <span style="background-color:yellow;">a</span> simple form of parameterizing functions/classes , but it does its work. So , maybe Python 's default-included batteries <span style="background-color:yellow;">are</span> enough here too . </p>
<p>P.S. I have <span style="background-color:yellow;">also</span> posted <span style="background-color:yellow;">a</span> larger example of this naive <span style="background-color:yellow;">approach</span> <span style="background-color:yellow;">at</span> Dynamically evaluating simple boolean logic in Python . </p>
<br /><b># 6 </b><br /><p>I back "Jörg W Mittag" answer: "The Python implementation of DI/IoC is so lightweight that it completely vanishes".</p>
<p>To back up this statement , take <span style="background-color:yellow;">a</span> look <span style="background-color:yellow;">at</span> the famous Martin Fowler 's example ported from Java to Python : Python : Design_Patterns : Inversion_of_Control </p>
<p>As you can see from the <span style="background-color:yellow;">above</span> link , <span style="background-color:yellow;">a</span> " <span style="background-color:yellow;">Container</span> " in Python can be written in 8 lines of code : </p>
<pre><code>class Container:
    def __init__(self, system_data):
        for component_name, component_class, component_args in system_data:
            if type(component_class) == types.ClassType:
                args = [self.__dict__[arg] for arg in component_args]
                self.__dict__[component_name] = component_class(*args)
            else:
                self.__dict__[component_name] = component_class
</code></pre>
<br /><b># 7 </b><br /><p>I use IoC with Ruby , here 's my thoughts <span style="background-color:yellow;">about</span> why it 's not widely spread </p>
<p>http : //ruby-lang.info/blog/you-underestimate-the-power-of-ioc-3fh </p>
<br />