<h3>Question ( ID-231767 ) : </h3><h2>The Python yield keyword explained </h2><p>What <span style="background-color:yellow;">is</span> the use of the yield keyword <span style="background-color:yellow;">in</span> Python ? What does <span style="background-color:yellow;">it</span> do ? </p>
<p>For example , I 'm trying to understand this code ( * * ) : </p>
<pre><code>def node._get_child_candidates(self, distance, min_dist, max_dist):
    if self._leftchild and distance - max_dist < self._median:
        yield self._leftchild
    if self._rightchild and distance + max_dist >= self._median:
        yield self._rightchild  
</code></pre>
<p>And this <span style="background-color:yellow;">is</span> the caller : </p>
<pre><code>result, candidates = list(), [self]
while candidates:
    node = candidates.pop()
    distance = node._get_dist(obj)
    if distance <= max_dist and distance >= min_dist:
        result.extend(node._values)
        candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))
        return result
</code></pre>
<p>What happens when the method _get_child_candidates <span style="background-color:yellow;">is</span> called ? A <span style="background-color:yellow;">list</span> <span style="background-color:yellow;">is</span> returned ? A single element <span style="background-color:yellow;">is</span> returned ? Is <span style="background-color:yellow;">it</span> called <span style="background-color:yellow;">again</span> ? When subsequent calls do stop ? </p>
<p>* * The code comes <span style="background-color:yellow;">from</span> Jochen Schulz ( jrschulz ) , who made <span style="background-color:yellow;">a</span> great Python library <span style="background-color:yellow;">for</span> metric spaces. This <span style="background-color:yellow;">is</span> the link to the complete source : http : //well-adjusted.de/ ~ jrschulz/mspace/ . </p>
<br /><h3>Answers ( Total-10 ) : </h3><b># 0 </b><br /><h2>Iterables </h2>
<p>To understand what yield does , you must understand what <span style="background-color:yellow;">generators</span> <span style="background-color:yellow;">are.</span> And <span style="background-color:yellow;">before</span> <span style="background-color:yellow;">generators</span> come <span style="background-color:yellow;">iterables.</span> When you create <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> , you can read <span style="background-color:yellow;">its</span> <span style="background-color:yellow;">items</span> one <span style="background-color:yellow;">by</span> one , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">it</span> 's called <span style="background-color:yellow;">iteration</span> : </p>
<pre><code>>>> mylist = [1, 2, 3]
>>> for i in mylist :
...    print(i)
1
2
3
</code></pre>
<p>Mylist <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterable.</span> When you use <span style="background-color:yellow;">a</span> comprehension <span style="background-color:yellow;">list</span> , you create <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> , <span style="background-color:yellow;">and</span> so <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterable</span> : </p>
<pre><code>>>> mylist = [x*x for x in range(3)]
>>> for i in mylist :
...    print(i)
0
1
4
</code></pre>
<p>Everything you can use " <span style="background-color:yellow;">for...</span> <span style="background-color:yellow;">in...</span> " on <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterable</span> : <span style="background-color:yellow;">lists</span> , strings , <span style="background-color:yellow;">files..</span> . These <span style="background-color:yellow;">iterables</span> <span style="background-color:yellow;">are</span> handy <span style="background-color:yellow;">because</span> you can read them <span style="background-color:yellow;">as</span> much <span style="background-color:yellow;">as</span> you wish , <span style="background-color:yellow;">but</span> you store <span style="background-color:yellow;">all</span> the values <span style="background-color:yellow;">in</span> memory <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">it</span> 's <span style="background-color:yellow;">not</span> <span style="background-color:yellow;">always</span> what you want when you have <span style="background-color:yellow;">a</span> lot of values . </p>
<h2>Generators </h2>
<p>Generators <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">iterables</span> , <span style="background-color:yellow;">but</span> you can only read them once . It 's <span style="background-color:yellow;">because</span> they do <span style="background-color:yellow;">not</span> store <span style="background-color:yellow;">all</span> the values <span style="background-color:yellow;">in</span> memory , they generate the values on the <span style="background-color:yellow;">fly</span> : </p>
<pre><code>>>> mygenerator = (x*x for x in range(3))
>>> for i in mygenerator :
...    print(i)
0
1
4
</code></pre>
<p>It just the same except you used ( ) <span style="background-color:yellow;">instead</span> of [ ] . BUT , you can <span style="background-color:yellow;">not</span> perform <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">i</span> <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">mygenerator</span> <span style="background-color:yellow;">a</span> second time since <span style="background-color:yellow;">generators</span> can only <span style="background-color:yellow;">be</span> used once : they calculate 0 , then <span style="background-color:yellow;">forget</span> <span style="background-color:yellow;">about</span> <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">and</span> calculate 1 <span style="background-color:yellow;">and</span> ends calculating <span style="background-color:yellow;">4</span> , one <span style="background-color:yellow;">by</span> one . </p>
<h2>Yield </h2>
<p>Yield <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> keyword that <span style="background-color:yellow;">is</span> used like return , except the <span style="background-color:yellow;">function</span> will return <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> . </p>
<pre><code>>>> def createGenerator() :
...    mylist = range(3)
...    for i in mylist :
...        yield i*i
...
>>> mygenerator = createGenerator() # create a generator
>>> print(mygenerator) # mygenerator is an object !
<generator object createGenerator at 0xb7555c34>
>>> for i in mygenerator:
...     print(i)
0
1
4
</code></pre>
<p>Here <span style="background-color:yellow;">it</span> 's <span style="background-color:yellow;">a</span> useless example , <span style="background-color:yellow;">but</span> <span style="background-color:yellow;">it</span> 's handy when you know your <span style="background-color:yellow;">function</span> will return <span style="background-color:yellow;">a</span> huge set of values that you will only <span style="background-color:yellow;">need</span> to read once . </p>
<p>To master yield , you must understand that when you call the <span style="background-color:yellow;">function</span> , the code you have written <span style="background-color:yellow;">in</span> the <span style="background-color:yellow;">function</span> <span style="background-color:yellow;">body</span> does <span style="background-color:yellow;">not</span> run. The <span style="background-color:yellow;">function</span> only returns the <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">object</span> , this <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">bit</span> tricky : - ) </p>
<p>Then , your code will <span style="background-color:yellow;">be</span> run each time the <span style="background-color:yellow;">for</span> uses the <span style="background-color:yellow;">generator</span> . </p>
<p>Now the hard part : </p>
<p>The <span style="background-color:yellow;">first</span> time your <span style="background-color:yellow;">function</span> will run , <span style="background-color:yellow;">it</span> will run <span style="background-color:yellow;">from</span> the <span style="background-color:yellow;">beginning</span> until <span style="background-color:yellow;">it</span> hits yield , then <span style="background-color:yellow;">it</span> 'll return the <span style="background-color:yellow;">first</span> value of the loop. Then , each other call will run the loop you have written <span style="background-color:yellow;">in</span> the <span style="background-color:yellow;">function</span> one more time , <span style="background-color:yellow;">and</span> return the <span style="background-color:yellow;">next</span> value , until there <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">no</span> value to return . </p>
<p>The <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">is</span> considered empty once the <span style="background-color:yellow;">function</span> runs <span style="background-color:yellow;">but</span> does <span style="background-color:yellow;">not</span> hit yield <span style="background-color:yellow;">anymore.</span> It can <span style="background-color:yellow;">be</span> <span style="background-color:yellow;">because</span> the loop had come to ends , or <span style="background-color:yellow;">because</span> you do <span style="background-color:yellow;">not</span> satisfy <span style="background-color:yellow;">a</span> " <span style="background-color:yellow;">if/else</span> " <span style="background-color:yellow;">anymore</span> . </p>
<h2>Your code explained </h2>
<p>Generator : </p>
<pre><code># Here you create the method of the node object that will return the generator
def node._get_child_candidates(self, distance, min_dist, max_dist):

  # Here is the code that will be called each time you use the generator object :

  # If there is still a child of the node object on its left
  # AND if distance is ok, return the next child
  if self._leftchild and distance - max_dist < self._median:
                yield self._leftchild

  # If there is still a child of the node object on its right
  # AND if distance is ok, return the next child
  if self._rightchild and distance + max_dist >= self._median:
                yield self._rightchild

  # If the function arrives here, the generator will be considered empty
  # there is no more than two values : the left and the right children
</code></pre>
<p>Caller : </p>
<pre><code># Create an empty list and a list with the current object reference
result, candidates = list(), [self]

# Loop on candidates (they contain only one element at the beginning) 
while candidates:

    # Get the last candidate and remove it from the list
    node = candidates.pop()

    # Get the distance between obj and the candidate
    distance = node._get_dist(obj)

    # If distance is ok, then you can fill the result
    if distance <= max_dist and distance >= min_dist:
        result.extend(node._values)

    # Add the children of the candidate in the candidates list 
    # so the loop will keep running until it will have looked
    # at all the children of the children of the children, etc. of the candidate
    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))

return result
</code></pre>
<p>This code contains several smart parts : </p>
<ul>The loop <span style="background-color:yellow;">iterate</span> on <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> <span style="background-color:yellow;">but</span> the <span style="background-color:yellow;">list</span> expends while the loop <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">been</span> <span style="background-color:yellow;">iterated</span> : - ) It 's <span style="background-color:yellow;">a</span> concise way to go through <span style="background-color:yellow;">all</span> these <span style="background-color:yellow;">nested</span> data even <span style="background-color:yellow;">if</span> <span style="background-color:yellow;">it</span> 's <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">bit</span> dangerous since you can end up with <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">infinite</span> loop. In this case , candidates.extend ( <span style="background-color:yellow;">node._get_child_candidates</span> ( distance , min_dist , max_dist ) ) exhausts <span style="background-color:yellow;">all</span> the values of the <span style="background-color:yellow;">generator</span> , <span style="background-color:yellow;">but</span> while keep creating <span style="background-color:yellow;">new</span> <span style="background-color:yellow;">generators</span> <span style="background-color:yellow;">object</span> which will produce different values <span style="background-color:yellow;">from</span> the previous ones since <span style="background-color:yellow;">it</span> 's <span style="background-color:yellow;">not</span> <span style="background-color:yellow;">applied</span> on the same <span style="background-color:yellow;">node</span> . The <span style="background-color:yellow;">extend</span> ( ) method <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> <span style="background-color:yellow;">object</span> method that expects <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterable</span> <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">adds</span> <span style="background-color:yellow;">its</span> values to the <span style="background-color:yellow;">list</span> . </ul>
<p>Usually we pass <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> to <span style="background-color:yellow;">it</span> : </p>
<pre><code>>>> a = [1, 2]
>>> b = [3, 4]
>>> a.extend(b)
>>> print(a)
[1, 2, 3, 4]
</code></pre>
<p>But <span style="background-color:yellow;">in</span> your code <span style="background-color:yellow;">it</span> gets <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> , which <span style="background-color:yellow;">is</span> good <span style="background-color:yellow;">because</span> : </p>
<ol>You do <span style="background-color:yellow;">n't</span> <span style="background-color:yellow;">need</span> to read the values twice . You can have <span style="background-color:yellow;">a</span> lot of children <span style="background-color:yellow;">and</span> you do <span style="background-color:yellow;">n't</span> want them <span style="background-color:yellow;">all</span> stored <span style="background-color:yellow;">in</span> memory . </ol>
<p>And <span style="background-color:yellow;">it</span> works <span style="background-color:yellow;">because</span> Python does <span style="background-color:yellow;">not</span> care <span style="background-color:yellow;">if</span> the <span style="background-color:yellow;">argument</span> of <span style="background-color:yellow;">a</span> method <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> or <span style="background-color:yellow;">not.</span> Python expects <span style="background-color:yellow;">iterables</span> so <span style="background-color:yellow;">it</span> will work with strings , <span style="background-color:yellow;">lists</span> , tuples <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">generators</span> ! This <span style="background-color:yellow;">is</span> called duck typing <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">is</span> one of the reason why Python <span style="background-color:yellow;">is</span> so cool. But this <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">another</span> story , <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">another</span> question.. . </p>
<p>You can stop here , or read <span style="background-color:yellow;">a</span> little <span style="background-color:yellow;">bit</span> to see <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">advanced</span> use of <span style="background-color:yellow;">generator</span> : </p>
<h2>Controlling <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> exhaustion </h2>
<pre><code>>>> class Bank(): # let's create a bank, building ATMs
...    crisis = False
...    def create_atm(self) :
...        while not self.crisis :
...            yield "$100"
>>> hsbc = Bank() # when everything is fine, you can get as much money as you want from an ATM
>>> corner_street_atm = hsbc.create_atm()
>>> print(corner_street_atm.next())
$100
>>> print(corner_street_atm.next())
$100
>>> print([corner_street_atm.next() for cash in range(5)])
['$100', '$100', '$100', '$100', '$100']
>>> hsbc.crisis = True # crisis is coming, no more money !
>>> print(corner_street_atm.next())
<type 'exceptions.StopIteration'>
>>> wall_street_atm = hsbc.create_atm() # but it's true even for newly built ATM
>>> print(wall_street_atm.next())
<type 'exceptions.StopIteration'>
>>> hsbc.crisis = False # trouble is, when the crisis is off, the ATM are still empty...
>>> print(corner_street_atm.next())
<type 'exceptions.StopIteration'>
>>> brand_new_atm = hsbc.create_atm() # but if you build new ones, you're in business again !
>>> for cash in brand_new_atm :
...    print cash
$100
$100
$100
$100
$100
$100
$100
$100
$100
...
</code></pre>
<p>It can <span style="background-color:yellow;">be</span> useful <span style="background-color:yellow;">for</span> various things like controlling <span style="background-color:yellow;">access</span> to <span style="background-color:yellow;">a</span> resource . </p>
<h2>Itertools , your <span style="background-color:yellow;">best</span> <span style="background-color:yellow;">friend</span> </h2>
<p>The <span style="background-color:yellow;">itertools</span> module contains special <span style="background-color:yellow;">functions</span> to manipulate <span style="background-color:yellow;">iterables.</span> Ever wish to duplicate <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> ? Chain <span style="background-color:yellow;">a</span> two <span style="background-color:yellow;">generators</span> ? Groups values <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">nested</span> <span style="background-color:yellow;">list</span> with <span style="background-color:yellow;">a</span> one liner ? Map / Zip without creating <span style="background-color:yellow;">another</span> <span style="background-color:yellow;">list</span> ? </p>
<p>Then just <span style="background-color:yellow;">import</span> <span style="background-color:yellow;">itertools</span> . </p>
<p>An example ? Let 's see the possible orders of <span style="background-color:yellow;">arrival</span> <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">4</span> <span style="background-color:yellow;">horses</span> race : </p>
<pre><code>>>> horses = [1, 2, 3, 4]
>>> races = itertools.permutations(horses)
>>> print(races)
<itertools.permutations object at 0xb754f1dc>
>>> print(list(itertools.permutations(horses)))
[(1, 2, 3, 4),
 (1, 2, 4, 3),
 (1, 3, 2, 4),
 (1, 3, 4, 2),
 (1, 4, 2, 3),
 (1, 4, 3, 2),
 (2, 1, 3, 4),
 (2, 1, 4, 3),
 (2, 3, 1, 4),
 (2, 3, 4, 1),
 (2, 4, 1, 3),
 (2, 4, 3, 1),
 (3, 1, 2, 4),
 (3, 1, 4, 2),
 (3, 2, 1, 4),
 (3, 2, 4, 1),
 (3, 4, 1, 2),
 (3, 4, 2, 1),
 (4, 1, 2, 3),
 (4, 1, 3, 2),
 (4, 2, 1, 3),
 (4, 2, 3, 1),
 (4, 3, 1, 2),
 (4, 3, 2, 1)]
</code></pre>
<h2>Understanding the <span style="background-color:yellow;">inner</span> mechanisms of <span style="background-color:yellow;">iteration</span> </h2>
<p>Iteration <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> process <span style="background-color:yellow;">implying</span> <span style="background-color:yellow;">iterables</span> ( <span style="background-color:yellow;">implementing</span> the <span style="background-color:yellow;">__iter__</span> ( ) method ) <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">iterators</span> ( <span style="background-color:yellow;">implementing</span> the __next__ ( ) method ) . Iterables <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">any</span> <span style="background-color:yellow;">objects</span> you can get <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterator</span> <span style="background-color:yellow;">from.</span> Iterators <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">objects</span> that let you <span style="background-color:yellow;">iterate</span> on <span style="background-color:yellow;">iterables</span> . </p>
<p>More <span style="background-color:yellow;">about</span> <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">in</span> this <span style="background-color:yellow;">article</span> <span style="background-color:yellow;">about</span> how does the <span style="background-color:yellow;">for</span> loop work . </p>
<p>Oh , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">if</span> you liked this <span style="background-color:yellow;">answer</span> , you 'll probably like my explanation <span style="background-color:yellow;">for</span> decorators <span style="background-color:yellow;">and</span> metaclasses . </p>
<br /><b># 1 </b><br /><h2>Shortcut to Grokking yield </h2>
<p>When you see <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">function</span> with yield statements , <span style="background-color:yellow;">apply</span> this easy trick to understand what will happen : </p>
<ol>Insert <span style="background-color:yellow;">a</span> line result = [ ] <span style="background-color:yellow;">at</span> the start of the <span style="background-color:yellow;">function</span> . Replace each yield expr with result.append ( expr ) . Insert <span style="background-color:yellow;">a</span> line return result <span style="background-color:yellow;">at</span> the <span style="background-color:yellow;">bottom</span> of the <span style="background-color:yellow;">function</span> . Yay - <span style="background-color:yellow;">no</span> more yield statements ! Read <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">figure</span> out code . Revert <span style="background-color:yellow;">function</span> to original definition . </ol>
<p>This trick may give you <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">idea</span> of the logic <span style="background-color:yellow;">behind</span> the <span style="background-color:yellow;">function</span> , <span style="background-color:yellow;">but</span> what <span style="background-color:yellow;">actually</span> happens with yield <span style="background-color:yellow;">is</span> significantly different that what happens <span style="background-color:yellow;">in</span> the <span style="background-color:yellow;">list</span> <span style="background-color:yellow;">based</span> <span style="background-color:yellow;">approach.</span> In many cases the yield <span style="background-color:yellow;">approach</span> will <span style="background-color:yellow;">be</span> <span style="background-color:yellow;">a</span> lot more memory efficient <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">faster</span> too. In other cases this trick will get you stuck <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">infinite</span> loop , even though the original <span style="background-color:yellow;">function</span> works just <span style="background-color:yellow;">fine.</span> Read on to learn more.. . </p>
<h2>Do <span style="background-color:yellow;">n't</span> confuse your Iterables , Iterators <span style="background-color:yellow;">and</span> Generators </h2>
<p>First , the <span style="background-color:yellow;">iterator</span> protocol - when you write </p>
<pre><code>for x in mylist:
    ...loop body...
</code></pre>
<p>Python performs the <span style="background-color:yellow;">following</span> two steps : </p>
<ol>Gets <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterator</span> <span style="background-color:yellow;">for</span> mylist : Call <span style="background-color:yellow;">iter</span> ( mylist ) -&gt ; this returns <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">object</span> with <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">next</span> ( ) method . [ This <span style="background-color:yellow;">is</span> the step most people <span style="background-color:yellow;">forget</span> to tell you <span style="background-color:yellow;">about</span> ] Uses the <span style="background-color:yellow;">iterator</span> to loop over <span style="background-color:yellow;">items</span> : Keep calling the <span style="background-color:yellow;">next</span> ( ) method on the <span style="background-color:yellow;">iterator</span> returned <span style="background-color:yellow;">from</span> step 1. The return value <span style="background-color:yellow;">from</span> <span style="background-color:yellow;">next</span> ( ) <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">assigned</span> to <span style="background-color:yellow;">x</span> <span style="background-color:yellow;">and</span> the loop <span style="background-color:yellow;">body</span> <span style="background-color:yellow;">is</span> executed. If <span style="background-color:yellow;">an</span> exception StopIteration <span style="background-color:yellow;">is</span> raised <span style="background-color:yellow;">from</span> within <span style="background-color:yellow;">next</span> ( ) , <span style="background-color:yellow;">it</span> means there <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">no</span> more values <span style="background-color:yellow;">in</span> the <span style="background-color:yellow;">iterator</span> <span style="background-color:yellow;">and</span> the loop <span style="background-color:yellow;">is</span> exited . </ol>
<p>The truth <span style="background-color:yellow;">is</span> Python performs the <span style="background-color:yellow;">above</span> two steps <span style="background-color:yellow;">anytime</span> <span style="background-color:yellow;">it</span> wants to loop over the contents of <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">object</span> - so <span style="background-color:yellow;">it</span> could <span style="background-color:yellow;">be</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">for</span> loop , <span style="background-color:yellow;">but</span> <span style="background-color:yellow;">it</span> could <span style="background-color:yellow;">also</span> <span style="background-color:yellow;">be</span> code like otherlist.extend ( mylist ) ( where otherlist <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> Python <span style="background-color:yellow;">list</span> ) . </p>
<p>Here mylist <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterable</span> <span style="background-color:yellow;">because</span> <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">implements</span> the <span style="background-color:yellow;">iterator</span> protocol. In <span style="background-color:yellow;">a</span> user defined class , you can <span style="background-color:yellow;">implement</span> the <span style="background-color:yellow;">__iter__</span> ( ) method to make <span style="background-color:yellow;">instances</span> of your class <span style="background-color:yellow;">iterable.</span> This method should return <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterator</span> . An <span style="background-color:yellow;">iterator</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">object</span> with <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">next</span> ( ) method. It <span style="background-color:yellow;">is</span> possible to <span style="background-color:yellow;">implement</span> <span style="background-color:yellow;">both</span> <span style="background-color:yellow;">__iter__</span> ( ) <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">next</span> ( ) on the same class , <span style="background-color:yellow;">and</span> have <span style="background-color:yellow;">__iter__</span> ( ) return <span style="background-color:yellow;">self</span> . This will work <span style="background-color:yellow;">for</span> simple cases , <span style="background-color:yellow;">but</span> <span style="background-color:yellow;">not</span> when you want two <span style="background-color:yellow;">iterators</span> looping over the same <span style="background-color:yellow;">object</span> <span style="background-color:yellow;">at</span> the same time . </p>
<p>So that 's the <span style="background-color:yellow;">iterator</span> protocol , many <span style="background-color:yellow;">objects</span> <span style="background-color:yellow;">implement</span> this protocol : </p>
<ol>Built-in <span style="background-color:yellow;">lists</span> , dictionaries , tuples , sets , <span style="background-color:yellow;">files</span> . User defined classes that <span style="background-color:yellow;">implement</span> <span style="background-color:yellow;">__iter__</span> ( ) . Generators . </ol>
<p>Note that <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">for</span> loop does <span style="background-color:yellow;">n't</span> know what kind of <span style="background-color:yellow;">object</span> <span style="background-color:yellow;">it</span> 's dealing with - <span style="background-color:yellow;">it</span> just <span style="background-color:yellow;">follows</span> the <span style="background-color:yellow;">iterator</span> protocol , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">is</span> happy to get <span style="background-color:yellow;">item</span> <span style="background-color:yellow;">after</span> <span style="background-color:yellow;">item</span> <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">it</span> calls <span style="background-color:yellow;">next</span> ( ) . Built-in <span style="background-color:yellow;">lists</span> return their <span style="background-color:yellow;">items</span> one <span style="background-color:yellow;">by</span> one , dictionaries return the keys one <span style="background-color:yellow;">by</span> one , <span style="background-color:yellow;">files</span> return the lines one <span style="background-color:yellow;">by</span> one , etc. And <span style="background-color:yellow;">generators</span> return... well that 's where yield comes <span style="background-color:yellow;">in</span> : </p>
<pre><code>def f123():
    yield 1
    yield 2
    yield 3

for item in f():
    print item
</code></pre>
<p>Instead of yield statements , <span style="background-color:yellow;">if</span> you had three return statements <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">f123</span> ( ) only the <span style="background-color:yellow;">first</span> would get executed , <span style="background-color:yellow;">and</span> the <span style="background-color:yellow;">function</span> would exit. But <span style="background-color:yellow;">f123</span> ( ) <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">no</span> ordinary <span style="background-color:yellow;">function.</span> When <span style="background-color:yellow;">f123</span> ( ) <span style="background-color:yellow;">is</span> called , <span style="background-color:yellow;">it</span> does <span style="background-color:yellow;">not</span> return <span style="background-color:yellow;">any</span> of the values <span style="background-color:yellow;">in</span> the yield statements ! It returns <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">object.</span> Also , the <span style="background-color:yellow;">function</span> does <span style="background-color:yellow;">not</span> really exit - <span style="background-color:yellow;">it</span> goes <span style="background-color:yellow;">into</span> <span style="background-color:yellow;">a</span> suspended state. When the <span style="background-color:yellow;">for</span> loop tries to loop over the <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">object</span> , the <span style="background-color:yellow;">function</span> resumes <span style="background-color:yellow;">from</span> <span style="background-color:yellow;">its</span> suspended state , runs until the <span style="background-color:yellow;">next</span> yield statement <span style="background-color:yellow;">and</span> returns that <span style="background-color:yellow;">as</span> the <span style="background-color:yellow;">next</span> <span style="background-color:yellow;">item.</span> This happens until the <span style="background-color:yellow;">function</span> exits , <span style="background-color:yellow;">at</span> which point the <span style="background-color:yellow;">generator</span> raises StopIteration , <span style="background-color:yellow;">and</span> the loop exits . </p>
<p>So the <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">object</span> <span style="background-color:yellow;">is</span> sort of like <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">adapter</span> - <span style="background-color:yellow;">at</span> one end <span style="background-color:yellow;">it</span> exhibits the <span style="background-color:yellow;">iterator</span> protocol , <span style="background-color:yellow;">by</span> exposing <span style="background-color:yellow;">__iter__</span> ( ) <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">next</span> ( ) methods to keep the <span style="background-color:yellow;">for</span> loop happy. At the other end however , <span style="background-color:yellow;">it</span> runs the <span style="background-color:yellow;">function</span> just enough to get the <span style="background-color:yellow;">next</span> value out of <span style="background-color:yellow;">it</span> , <span style="background-color:yellow;">and</span> puts <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">back</span> <span style="background-color:yellow;">in</span> suspended mode . </p>
<h2>Why Use Generators ? </h2>
<p>Usually you can write code that does <span style="background-color:yellow;">n't</span> use <span style="background-color:yellow;">generators</span> <span style="background-color:yellow;">but</span> <span style="background-color:yellow;">implements</span> the same logic. One option <span style="background-color:yellow;">is</span> to use the temporary <span style="background-color:yellow;">list</span> 'trick ' I mentioned <span style="background-color:yellow;">before.</span> That will <span style="background-color:yellow;">not</span> work <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">all</span> cases , <span style="background-color:yellow;">for</span> e.g. <span style="background-color:yellow;">if</span> you have <span style="background-color:yellow;">infinite</span> loops , or <span style="background-color:yellow;">it</span> may make <span style="background-color:yellow;">inefficient</span> use of memory when you have <span style="background-color:yellow;">a</span> really long <span style="background-color:yellow;">list.</span> The other <span style="background-color:yellow;">approach</span> <span style="background-color:yellow;">is</span> to <span style="background-color:yellow;">implement</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">new</span> <span style="background-color:yellow;">iterable</span> class SomethingIter that keeps state <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">instance</span> members <span style="background-color:yellow;">and</span> performs the <span style="background-color:yellow;">next</span> logical step <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">it</span> 's <span style="background-color:yellow;">next</span> ( ) method. Depending on the logic , the code <span style="background-color:yellow;">inside</span> the <span style="background-color:yellow;">next</span> ( ) method may end up looking very complex <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">be</span> prone to <span style="background-color:yellow;">bugs.</span> Here <span style="background-color:yellow;">generators</span> provide <span style="background-color:yellow;">a</span> clean <span style="background-color:yellow;">and</span> easy solution . </p>
<br /><b># 2 </b><br /><p>Think of <span style="background-color:yellow;">it</span> this way : </p>
<p>An <span style="background-color:yellow;">iterator</span> <span style="background-color:yellow;">is</span> just <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">fancy</span> sounding term <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">object</span> that has <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">next</span> ( ) method. So <span style="background-color:yellow;">a</span> yield-ed <span style="background-color:yellow;">function</span> ends up <span style="background-color:yellow;">being</span> something like this : </p>
<p>Original version : </p>
<pre><code>def some_function():
    for i in xrange(4):
        yield i

for i in some_function():
    print i
</code></pre>
<p>This <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">basically</span> what the python <span style="background-color:yellow;">interpreter</span> does with the <span style="background-color:yellow;">above</span> code : </p>
<pre><code>class it:
    def __init__(self):
        #start at -1 so that we get 0 when we add 1 below.
        self.count = -1
    #the __iter__ method will be called once by the for loop.
    #the rest of the magic happens on the object returned by this method.
    #in this case it is the object itself.
    def __iter__(self):
        return self
    #the next method will be called repeatedly by the for loop
    #until it raises StopIteration.
    def next(self):
        self.count += 1
        if self.count < 4:
            return self.count
        else:
            #a StopIteration exception is raised
            #to signal that the iterator is done.
            #This is caught implicitly by the for loop.
            raise StopIteration 

def some_func():
    return it()

for i in some_func():
    print i
</code></pre>
<p>For more <span style="background-color:yellow;">insight</span> <span style="background-color:yellow;">as</span> to what 's happening <span style="background-color:yellow;">behind</span> the scenes , the <span style="background-color:yellow;">for</span> loop can <span style="background-color:yellow;">be</span> rewritten to this : </p>
<pre><code>iterator = some_func()
try:
    while 1:
        print iterator.next()
except StopIteration:
    pass
</code></pre>
<p>Does that make more sense or just confuse you more ? : ) </p>
<p>EDIT : I should <span style="background-color:yellow;">note</span> that this IS <span style="background-color:yellow;">an</span> oversimplification <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">illustrative</span> purposes. : ) </p>
<p>EDIT 2 : Forgot to throw the StopIteration exception </p>
<br /><b># <span style="background-color:yellow;">3</span> </b><br /><p>I <span style="background-color:yellow;">feel</span> like I post <span style="background-color:yellow;">a</span> link to this presentation every day : David M. Beazly 's Generator Tricks <span style="background-color:yellow;">for</span> Systems Programmers . If you 're <span style="background-color:yellow;">a</span> Python programmer <span style="background-color:yellow;">and</span> you 're <span style="background-color:yellow;">not</span> extremely <span style="background-color:yellow;">familiar</span> with <span style="background-color:yellow;">generators</span> , you should read this. It 's <span style="background-color:yellow;">a</span> very clear explanation of what <span style="background-color:yellow;">generators</span> <span style="background-color:yellow;">are</span> , how they work , what the yield statement does , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">answers</span> the question " Do you really want to mess <span style="background-color:yellow;">around</span> with this obscure language <span style="background-color:yellow;">feature</span> ? " </p>
<p>SPOILER ALERT. The <span style="background-color:yellow;">answer</span> <span style="background-color:yellow;">is</span> : Yes. Yes , you do . </p>
<br /><b># <span style="background-color:yellow;">4</span> </b><br /><p>yield <span style="background-color:yellow;">is</span> just like return. It returns whatever you tell <span style="background-color:yellow;">it</span> to. The only difference <span style="background-color:yellow;">is</span> that the <span style="background-color:yellow;">next</span> time you call the <span style="background-color:yellow;">function</span> , execution starts <span style="background-color:yellow;">from</span> the last call to the yield statement . </p>
<p>In the case of your code , the <span style="background-color:yellow;">function</span> get_child_candidates <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">acting</span> like <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterator</span> so that when you <span style="background-color:yellow;">extend</span> your <span style="background-color:yellow;">list</span> , <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">adds</span> one element <span style="background-color:yellow;">at</span> <span style="background-color:yellow;">a</span> time to the <span style="background-color:yellow;">new</span> <span style="background-color:yellow;">list</span> . </p>
<p><span style="background-color:yellow;">list.extend</span> calls <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterator</span> until <span style="background-color:yellow;">it</span> 's exhausted. In the case of the code sample you posted , <span style="background-color:yellow;">it</span> would <span style="background-color:yellow;">be</span> much clearer to just return <span style="background-color:yellow;">a</span> tuple <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">append</span> that to the <span style="background-color:yellow;">list</span> . </p>
<br /><b># <span style="background-color:yellow;">5</span> </b><br /><p>There 's one extra thing to mention : <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">function</span> that yields does <span style="background-color:yellow;">n't</span> <span style="background-color:yellow;">actually</span> have to terminate. I 've written code like this : </p>
<pre><code>def fib():
    yield 1
    yield 1
    cur = 1
    last = 1
    while True:
        cur, last = cur+last, cur
        yield cur
</code></pre>
<p>Then I can use <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">in</span> other code like this : </p>
<pre><code>for f in fib():
    if some_condition: break
    coolfuncs(f);
</code></pre>
<p>It really helps simplify some problems , <span style="background-color:yellow;">and</span> makes some things easier to work with . </p>
<br /><b># 6 </b><br /><p>An example <span style="background-color:yellow;">in</span> plain language. I will provide <span style="background-color:yellow;">a</span> correspondence <span style="background-color:yellow;">between</span> high-level human concepts to low-level python concepts . </p>
<p>I want to operate on <span style="background-color:yellow;">a</span> sequence of <span style="background-color:yellow;">numbers</span> , <span style="background-color:yellow;">but</span> I do <span style="background-color:yellow;">n't</span> want to <span style="background-color:yellow;">bother</span> my <span style="background-color:yellow;">self</span> with the creation of that sequence , I want only to <span style="background-color:yellow;">focus</span> on the operation I want to do. So , I do the <span style="background-color:yellow;">following</span> : </p>
<ul>
<li>I call you and tell you that I want a sequence of numbers which is produced in a specific way, and I let you know what the algorithm is.<br />
<b>This step corresponds to <code>def</code>ining the generator function, i.e. the function containing a <code>yield</code>.</b></li>
<li>Sometime later, I tell you, "ok, get ready to tell me the sequence of numbers".<br />
<b>This step corresponds to calling the generator function which returns a generator object.</b> Note that you don't tell me any numbers yet, you just grab your paper and pencil.</li>
<li>I ask you, "tell me the next number", and you tell me the first number; after that, you wait for me to ask you for the next number. It's your job to remember where you were, what numbers you have already said, what is the next number. I don't care about the details.<br />
<b>This step corresponds to calling <code>.next()</code> on the generator object.</b></li>
<li>â€Ś repeat previous step, untilâ€Ś</li>
<li>eventually, you might come to an end. You don't tell me a number, you just shout, "hold your horses! I'm done! No more numbers!"<br />
<b>This step corresponds to the generator object ending its job, and raising a <code>StopIteration</code> exception</b> The generator function does not need to raise the exception, it's raised automatically when the function ends or issues a <code>return</code>.</li>
</ul>
<p>This <span style="background-color:yellow;">is</span> what <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> does ( <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">function</span> that contains <span style="background-color:yellow;">a</span> yield ) ; <span style="background-color:yellow;">it</span> starts executing , pauses whenever <span style="background-color:yellow;">it</span> does <span style="background-color:yellow;">a</span> yield , <span style="background-color:yellow;">and</span> when <span style="background-color:yellow;">asked</span> <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">a</span> .next ( ) value <span style="background-color:yellow;">it</span> continues <span style="background-color:yellow;">from</span> the point <span style="background-color:yellow;">it</span> was last. It <span style="background-color:yellow;">fits</span> perfectly <span style="background-color:yellow;">by</span> design with the <span style="background-color:yellow;">iterator</span> protocol of python , which describes how to sequentially request <span style="background-color:yellow;">for</span> values . </p>
<p>The most <span style="background-color:yellow;">famous</span> user of the <span style="background-color:yellow;">iterator</span> protocol <span style="background-color:yellow;">is</span> the <span style="background-color:yellow;">for</span> command <span style="background-color:yellow;">in</span> python. So , whenever you do <span style="background-color:yellow;">a</span> : </p>
<pre><code>for item in sequence:
</code></pre>
<p><span style="background-color:yellow;">it</span> does <span style="background-color:yellow;">n't</span> matter <span style="background-color:yellow;">if</span> sequence <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> , <span style="background-color:yellow;">a</span> string , <span style="background-color:yellow;">a</span> dictionary or <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">object</span> like described <span style="background-color:yellow;">above</span> ; the result <span style="background-color:yellow;">is</span> the same : you read <span style="background-color:yellow;">items</span> off <span style="background-color:yellow;">a</span> sequence one <span style="background-color:yellow;">by</span> one . </p>
<p>Note that def <span style="background-color:yellow;">ining</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">function</span> which contains <span style="background-color:yellow;">a</span> yield keyword <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">not</span> the only way to create <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> ; <span style="background-color:yellow;">it</span> 's just the easiest way to create one . </p>
<p>For more <span style="background-color:yellow;">accurate</span> <span style="background-color:yellow;">information</span> , read <span style="background-color:yellow;">about</span> <span style="background-color:yellow;">iterator</span> types , the yield statement <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">generators</span> <span style="background-color:yellow;">in</span> the Python documentation . </p>
<br /><b># 7 </b><br /><p>The yield keyword reduced to 2 simple <span style="background-color:yellow;">facts</span> : </p>
<ol>If the compiler detects the yield keyword <span style="background-color:yellow;">anywhere</span> <span style="background-color:yellow;">inside</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">function</span> , that <span style="background-color:yellow;">function</span> <span style="background-color:yellow;">no</span> longer returns via the return statement. INSTEAD , <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">immediately</span> returns <span style="background-color:yellow;">a</span> lazy " pending <span style="background-color:yellow;">list</span> " <span style="background-color:yellow;">object</span> called <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> A <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">iterable.</span> What <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterable</span> ? --It 's <span style="background-color:yellow;">anything</span> like <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> or set or <span style="background-color:yellow;">range</span> or dict-view , with <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">built-in</span> protocol <span style="background-color:yellow;">for</span> visiting each element <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">a</span> certain order . </ol>
<p>In <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">nutshell</span> : <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> lazy , <span style="background-color:yellow;">incrementally-pending</span> <span style="background-color:yellow;">list</span> , <span style="background-color:yellow;">and</span> yield statements <span style="background-color:yellow;">allow</span> you to use <span style="background-color:yellow;">function</span> <span style="background-color:yellow;">notation</span> to program the <span style="background-color:yellow;">list</span> values the <span style="background-color:yellow;">generator</span> should <span style="background-color:yellow;">incrementally</span> spit out . </p>
<pre><code>generator = myYieldingFunction(...)
x = list(generator)

   generator
       v
[x[0], ..., ???]

         generator
             v
[x[0], x[1], ..., ???]

               generator
                   v
[x[0], x[1], x[2], ..., ???]

                       StopIteration exception
[x[0], x[1], x[2]]     done

list==[x[0], x[1], x[2]]
</code></pre>
<hr />
<h2>Example </h2>
<p>Let 's define <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">function</span> <span style="background-color:yellow;">makeRange</span> that 's just like python 's <span style="background-color:yellow;">range</span> . Calling <span style="background-color:yellow;">makeRange</span> ( <span style="background-color:yellow;">n</span> ) RETURNS A GENERATOR : </p>
<pre><code>def makeRange(n):
    # return 0,1,2,...,n-1
    i = 0
    while i < n:
        yield i
        i += 1

>>> makeRange(5)
<generator object makeRange at 0x19e4aa0>
</code></pre>
<p>To <span style="background-color:yellow;">force</span> the <span style="background-color:yellow;">generator</span> to <span style="background-color:yellow;">immediately</span> return <span style="background-color:yellow;">its</span> pending values , you can pass <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">into</span> <span style="background-color:yellow;">list</span> ( ) ( just like you could <span style="background-color:yellow;">any</span> <span style="background-color:yellow;">iterable</span> ) : </p>
<pre><code>>>> list(makeRange(5))
[0, 1, 2, 3, 4]
</code></pre>
<hr />
<h2>Comparing example to " just returning <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> " </h2>
<p>The <span style="background-color:yellow;">above</span> example can <span style="background-color:yellow;">be</span> thought of <span style="background-color:yellow;">as</span> merely creating <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> which you <span style="background-color:yellow;">append</span> to <span style="background-color:yellow;">and</span> return : </p>
<pre><code># list-version                   #  # generator-version
def makeRange(n):                #  def makeRange(n):
    """return [0,1,2,...,n-1]""" #~     """return 0,1,2,...,n-1"""
    TO_RETURN = []               #>     
    i = 0                        #      i = 0
    while i < n:                 #      while i < n:
        TO_RETURN += [i]         #~         yield i
        i += 1                   #      i += 1
    return TO_RETURN             #> 

>>> makeRange(5)
[0, 1, 2, 3, 4]
</code></pre>
<p>There <span style="background-color:yellow;">is</span> one major difference though ; see the last section . </p>
<hr />
<h2>How you might use <span style="background-color:yellow;">generators</span> </h2>
<p>An <span style="background-color:yellow;">iterable</span> <span style="background-color:yellow;">is</span> the last part of <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> comprehension , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">generators</span> <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">iterable</span> , so they 're often used like so : </p>
<pre><code>#                   _ITERABLE_
>>> [x+10 for x in makeRange(5)]
[10, 11, 12, 13, 14]
</code></pre>
<p>To get <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">better</span> <span style="background-color:yellow;">feel</span> <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">generators</span> , you can play <span style="background-color:yellow;">around</span> with the <span style="background-color:yellow;">itertools</span> module ( <span style="background-color:yellow;">be</span> sure to use chain.from_iterable rather than chain when warranted ) . For example , you might even use <span style="background-color:yellow;">generators</span> to <span style="background-color:yellow;">implement</span> <span style="background-color:yellow;">infinitely-long</span> lazy <span style="background-color:yellow;">lists</span> like <span style="background-color:yellow;">itertools.count</span> ( ) . You could <span style="background-color:yellow;">implement</span> your own def enumerate ( <span style="background-color:yellow;">iterable</span> ) : zip ( count ( ) , <span style="background-color:yellow;">iterable</span> ) , or <span style="background-color:yellow;">alternatively</span> do so with the yield keyword <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">a</span> while-loop . </p>
<p>Please <span style="background-color:yellow;">note</span> : <span style="background-color:yellow;">generators</span> can <span style="background-color:yellow;">actually</span> <span style="background-color:yellow;">be</span> used <span style="background-color:yellow;">for</span> many more things , such <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">implementing</span> coroutines http : //www.dabeaz.com/coroutines/index.html or <span style="background-color:yellow;">non-deterministic</span> programming or other elegant things. However , the " lazy <span style="background-color:yellow;">lists</span> " viewpoint I present here <span style="background-color:yellow;">is</span> the most common use you will <span style="background-color:yellow;">find</span> . </p>
<hr />
<h2>Behind the scenes </h2>
<p>This <span style="background-color:yellow;">is</span> how the " python <span style="background-color:yellow;">iteration</span> protocol " works , <span style="background-color:yellow;">i.e.</span> what <span style="background-color:yellow;">is</span> going on when you do <span style="background-color:yellow;">list</span> ( <span style="background-color:yellow;">makeRange</span> ( <span style="background-color:yellow;">5</span> ) ) . This <span style="background-color:yellow;">is</span> what I describe earlier <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> " lazy , <span style="background-color:yellow;">incremental</span> <span style="background-color:yellow;">list</span> " . </p>
<pre><code>>>> x=iter(range(5))
>>> next(x)
0
>>> next(x)
1
>>> next(x)
2
>>> next(x)
3
>>> next(x)
4
>>> next(x)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
</code></pre>
<p>The <span style="background-color:yellow;">built-in</span> <span style="background-color:yellow;">function</span> <span style="background-color:yellow;">next</span> ( ) just calls the <span style="background-color:yellow;">objects</span> .next ( ) <span style="background-color:yellow;">function</span> , which <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> part of the " <span style="background-color:yellow;">iteration</span> protocol " <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">found</span> on <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">iterators.</span> You can manually use the <span style="background-color:yellow;">next</span> ( ) <span style="background-color:yellow;">function</span> ( <span style="background-color:yellow;">and</span> other parts of the <span style="background-color:yellow;">iteration</span> protocol ) to <span style="background-color:yellow;">implement</span> <span style="background-color:yellow;">fancy</span> things , usually <span style="background-color:yellow;">at</span> the expense of readability , so try to <span style="background-color:yellow;">avoid</span> doing that.. . </p>
<hr />
<h2>Minutiae </h2>
<p>Normally most people would <span style="background-color:yellow;">not</span> care <span style="background-color:yellow;">about</span> the <span style="background-color:yellow;">following</span> distinctions <span style="background-color:yellow;">and</span> probably want to stop reading here . </p>
<p>In python-speak , <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterable</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">any</span> <span style="background-color:yellow;">object</span> which " understands the concept of <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">for-loop</span> " like <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> [ 1,2,3 ] , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterator</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> specific <span style="background-color:yellow;">instance</span> of the requested <span style="background-color:yellow;">for-loop</span> like [ 1,2,3 ] .__iter__ ( ) . A <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">is</span> exactly the same <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">any</span> <span style="background-color:yellow;">iterator</span> , except <span style="background-color:yellow;">for</span> the way <span style="background-color:yellow;">it</span> was written ( with <span style="background-color:yellow;">function</span> syntax ) . </p>
<p>When you request <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterator</span> <span style="background-color:yellow;">from</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> , <span style="background-color:yellow;">it</span> creates <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">new</span> <span style="background-color:yellow;">iterator.</span> However , when you request <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterator</span> <span style="background-color:yellow;">from</span> <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterator</span> ( which you would rarely do ) , <span style="background-color:yellow;">it</span> just gives you <span style="background-color:yellow;">a</span> copy of <span style="background-color:yellow;">itself</span> . </p>
<p>Thus , <span style="background-color:yellow;">in</span> the unlikely event that you <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">failing</span> to do something like this.. . </p>
<pre><code>> x = myRange(5)
> list(x)
[0, 1, 2, 3, 4]
> list(x)
[]
</code></pre>
<p>... then remember that <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">iterator</span> ; that <span style="background-color:yellow;">is</span> , <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">is</span> one-time-use. If you want to reuse <span style="background-color:yellow;">it</span> , you should call myRange ( ... ) <span style="background-color:yellow;">again.</span> Those who <span style="background-color:yellow;">absolutely</span> <span style="background-color:yellow;">need</span> to clone <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> ( e.g. who <span style="background-color:yellow;">are</span> doing terrifyingly hackish metaprogramming ) can use <span style="background-color:yellow;">itertools.tee</span> <span style="background-color:yellow;">if</span> <span style="background-color:yellow;">absolutely</span> <span style="background-color:yellow;">necessary</span> , since the copyable <span style="background-color:yellow;">iterator</span> python PEP standards proposal has <span style="background-color:yellow;">been</span> deferred . </p>
<br /><b># 8 </b><br /><p>It 's returning <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator.</span> I 'm <span style="background-color:yellow;">not</span> particularly <span style="background-color:yellow;">familiar</span> with Python , <span style="background-color:yellow;">but</span> I <span style="background-color:yellow;">believe</span> <span style="background-color:yellow;">it</span> 's the same kind of thing <span style="background-color:yellow;">as</span> C # 's <span style="background-color:yellow;">iterator</span> <span style="background-color:yellow;">blocks</span> <span style="background-color:yellow;">if</span> you 're <span style="background-color:yellow;">familiar</span> with those . </p>
<p>There 's <span style="background-color:yellow;">an</span> IBM <span style="background-color:yellow;">article</span> which explains <span style="background-color:yellow;">it</span> reasonably well ( <span style="background-color:yellow;">for</span> Python ) <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">far</span> <span style="background-color:yellow;">as</span> I can see . </p>
<p>The key <span style="background-color:yellow;">idea</span> <span style="background-color:yellow;">is</span> that the compiler/interpreter/whatever does some trickery so that <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">far</span> <span style="background-color:yellow;">as</span> the caller <span style="background-color:yellow;">is</span> concerned , they can keep calling <span style="background-color:yellow;">next</span> ( ) <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">it</span> will keep returning values - <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">if</span> the <span style="background-color:yellow;">generator</span> method was paused . Now obviously you ca <span style="background-color:yellow;">n't</span> really " pause " <span style="background-color:yellow;">a</span> method , so the compiler <span style="background-color:yellow;">builds</span> <span style="background-color:yellow;">a</span> state machine <span style="background-color:yellow;">for</span> you to remember where you currently <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">and</span> what the local variables etc look like. This <span style="background-color:yellow;">is</span> much easier than writing <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterator</span> yourself . </p>
<br /><b># 9 </b><br /><p>From The Python Reference Manual : </p>
<blockquote>The yield statement <span style="background-color:yellow;">is</span> only used when defining <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">function</span> , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">is</span> only used <span style="background-color:yellow;">in</span> the <span style="background-color:yellow;">body</span> of the <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">function.</span> Using <span style="background-color:yellow;">a</span> yield statement <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">function</span> definition <span style="background-color:yellow;">is</span> sufficient to cause that definition to create <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">function</span> <span style="background-color:yellow;">instead</span> of <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">normal</span> <span style="background-color:yellow;">function</span> . When <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">function</span> <span style="background-color:yellow;">is</span> called , <span style="background-color:yellow;">it</span> returns <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">iterator</span> known <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">iterator</span> , or more commonly , <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">generator.</span> The <span style="background-color:yellow;">body</span> of the <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">function</span> <span style="background-color:yellow;">is</span> executed <span style="background-color:yellow;">by</span> calling the <span style="background-color:yellow;">generator</span> 's <span style="background-color:yellow;">next</span> ( ) method repeatedly until <span style="background-color:yellow;">it</span> raises <span style="background-color:yellow;">an</span> exception . When <span style="background-color:yellow;">a</span> yield statement <span style="background-color:yellow;">is</span> executed , the state of the <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">frozen</span> <span style="background-color:yellow;">and</span> the value of expression_list <span style="background-color:yellow;">is</span> returned to <span style="background-color:yellow;">next</span> ( ) 's caller. By ` ` <span style="background-color:yellow;">frozen'</span> ' we mean that <span style="background-color:yellow;">all</span> local state <span style="background-color:yellow;">is</span> retained , <span style="background-color:yellow;">including</span> the current <span style="background-color:yellow;">bindings</span> of local variables , the <span style="background-color:yellow;">instruction</span> pointer , <span style="background-color:yellow;">and</span> the <span style="background-color:yellow;">internal</span> evaluation stack : enough <span style="background-color:yellow;">information</span> <span style="background-color:yellow;">is</span> saved so that the <span style="background-color:yellow;">next</span> time <span style="background-color:yellow;">next</span> ( ) <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">invoked</span> , the <span style="background-color:yellow;">function</span> can proceed exactly <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">if</span> the yield statement were just <span style="background-color:yellow;">another</span> external call . </blockquote>
<p>Do you have the entire <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">function</span> <span style="background-color:yellow;">listed</span> ? It does <span style="background-color:yellow;">n't</span> look complete . </p>
<p>My guess <span style="background-color:yellow;">from</span> the <span style="background-color:yellow;">incomplete</span> code <span style="background-color:yellow;">is</span> that you set the parameters , <span style="background-color:yellow;">and</span> every time you call the <span style="background-color:yellow;">function</span> <span style="background-color:yellow;">it</span> returns the <span style="background-color:yellow;">next</span> child <span style="background-color:yellow;">node</span> that <span style="background-color:yellow;">fits</span> the parameters. The yield <span style="background-color:yellow;">allows</span> you to easily write <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">function</span> ( <span style="background-color:yellow;">generator</span> <span style="background-color:yellow;">function</span> ) that <span style="background-color:yellow;">is</span> called repeatedly to gather 'chunks ' of <span style="background-color:yellow;">information</span> , <span style="background-color:yellow;">by</span> 'pausing ' the <span style="background-color:yellow;">function</span> , returning the value , <span style="background-color:yellow;">and</span> then continuing the <span style="background-color:yellow;">function</span> where <span style="background-color:yellow;">it</span> was paused when <span style="background-color:yellow;">next</span> called . </p>
<br />