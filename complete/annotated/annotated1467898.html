<h3>Question ( ID-1467898 ) : </h3><h2>What language could I use for fast execution of this database summarization task ? </h2><p>So I wrote <span style="background-color:yellow;">a</span> Python program to handle <span style="background-color:yellow;">a</span> little data processing task . </p>
<p>Here 's <span style="background-color:yellow;">a</span> very brief specification in <span style="background-color:yellow;">a</span> made-up language of the computation I want : </p>
<pre><code>parse "%s %lf %s" aa bb cc | group_by aa | quickselect --key=bb 0:5 | \
    flatten | format "%s %lf %s" aa bb cc
</code></pre>
<p>That is , for each line , parse out <span style="background-color:yellow;">a</span> word , <span style="background-color:yellow;">a</span> floating-point number , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">another</span> word. Think of them <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> player ID , <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">score</span> , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">a</span> date. I want the <span style="background-color:yellow;">top</span> five <span style="background-color:yellow;">scores</span> <span style="background-color:yellow;">and</span> dates for each player. The data size is not trivial , but not huge ; <span style="background-color:yellow;">about</span> 630 megabytes . </p>
<p>I want to know what <span style="background-color:yellow;">real</span> , executable language I should have written it in to get it to be similarly short ( <span style="background-color:yellow;">as</span> the Python below ) but much faster . </p>
<pre><code>#!/usr/bin/python
# -*- coding: utf-8; -*-
import sys

top_5 = {}

for line in sys.stdin:
    aa, bb, cc = line.split()

    # We want the top 5 for each distinct value of aa.  There are
    # hundreds of thousands of values of aa.
    bb = float(bb)
    if aa not in top_5: top_5[aa] = []
    current = top_5[aa]
    current.append((bb, cc))

    # Every once in a while, we drop the values that are not in
    # the top 5, to keep our memory footprint down, because some
    # values of aa have thousands of (bb, cc) pairs.
    if len(current) > 10:
        current.sort()
        current[:-5] = []

for aa in top_5:
    current = top_5[aa]
    current.sort()
    for bb, cc in current[-5:]:
        print aa, bb, cc
</code></pre>
<p></p>
<pre><code>3 1.5 a
3 1.6 b
3 0.8 c
3 0.9 d
4 1.2 q
3 1.5 e
3 1.8 f
3 1.9 g
</code></pre>
<p></p>
<pre><code>3 1.5 a
3 1.5 e
3 1.6 b
3 1.8 f
3 1.9 g
4 1.2 q
</code></pre>
<p>There are seven values for <code>3</code>, and so we drop the <code>c</code> and <code>d</code> values
because their <code>bb</code> value puts them out of the top 5. Because <code>4</code> has
only one value, its “top 5” consists of just that one value.</p>
<p>This runs faster than doing the same queries in MySQL (at least, the
way we’ve found to do the queries) but I’m pretty sure it's spending
most of its time in the Python bytecode interpreter. I think that in
another language, I could probably get it to process hundreds of
thousands of rows per second instead of per minute. So I’d like to
write it in a language that has a faster implementation.</p>
<p></p>
<p>I haven’t been able to figure out how to express this as a single query in SQL, and
actually I’m really unimpressed with MySQL’s ability even to merely
<code>select * from foo into outfile 'bar';</code> the input data.</p>
<p>C is an obvious choice, but things like <code>line.split()</code>, sorting a list
of 2-tuples, and making a hash table require writing some code that’s
not in the standard library, so I would end up with 100 lines of code
or more instead of 14.</p>
<p>C + + seems like it might be <span style="background-color:yellow;">a</span> better choice ( it has strings , maps , pairs , <span style="background-color:yellow;">and</span> vectors in the standard library ) but it seems like the code would be <span style="background-color:yellow;">a</span> lot messier with STL . </p>
<p>OCaml would be fine , but does it have <span style="background-color:yellow;">an</span> equivalent of line.split ( ) , <span style="background-color:yellow;">and</span> will I be sad <span style="background-color:yellow;">about</span> the performance of its map ? </p>
<p>Common Lisp might work ? </p>
<p>Is there some equivalent of Matlab for database computation like this that lets me push the loops down <span style="background-color:yellow;">into</span> fast code ? Has <span style="background-color:yellow;">anybody</span> tried Pig ? </p>
<p>( Edit : <span style="background-color:yellow;">responded</span> to davethegr8 's comment by providing some sample input <span style="background-color:yellow;">and</span> output data , <span style="background-color:yellow;">and</span> fixed <span style="background-color:yellow;">a</span> bug in the Python program ! ) </p>
<p>( <span style="background-color:yellow;">Additional</span> edit : Wow , this comment thread is <span style="background-color:yellow;">really</span> excellent so far. Thanks , everybody ! ) </p>
<p>Edit : </p>
<p>There was <span style="background-color:yellow;">an</span> eerily similar question <span style="background-color:yellow;">asked</span> on sbcl-devel in 2007 ( thanks , Rainer ! ) , <span style="background-color:yellow;">and</span> here 's <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">awk</span> script from Will Hartung for producing some test data ( <span style="background-color:yellow;">although</span> it does n't have the Zipfian distribution of the <span style="background-color:yellow;">real</span> data ) : </p>
<pre><code>BEGIN {
 for (i = 0; i < 27000000; i++) {
  v = rand();
  k = int(rand() * 100);
  print k " " v " " i;
 }
 exit;
}
</code></pre>
<br /><h3><span style="background-color:yellow;">Answers</span> ( Total-18 ) : </h3><b># 0 </b><br /><p>I have <span style="background-color:yellow;">a</span> hard <span style="background-color:yellow;">time</span> believing that <span style="background-color:yellow;">any</span> script without <span style="background-color:yellow;">any</span> prior knowledge of the data ( unlike MySql which has such info pre-loaded ) , would be faster than <span style="background-color:yellow;">a</span> SQL <span style="background-color:yellow;">approach</span> . </p>
<p><span style="background-color:yellow;">Aside</span> from the <span style="background-color:yellow;">time</span> spent parsing the input , the script needs to " keep " sorting the order by <span style="background-color:yellow;">array</span> etc.. . </p>
<p>The following is <span style="background-color:yellow;">a</span> first guess <span style="background-color:yellow;">at</span> what should work decently fast in SQL , <span style="background-color:yellow;">assuming</span> <span style="background-color:yellow;">a</span> index ( * ) on the table 's <span style="background-color:yellow;">aa</span> , <span style="background-color:yellow;">bb</span> , <span style="background-color:yellow;">cc</span> columns , in that order. ( <span style="background-color:yellow;">A</span> possible <span style="background-color:yellow;">alternative</span> would be <span style="background-color:yellow;">an</span> " <span style="background-color:yellow;">aa</span> , <span style="background-color:yellow;">bb</span> DESC , <span style="background-color:yellow;">cc</span> " index </p>
<p>( * ) This index could be clustered or not , not <span style="background-color:yellow;">affecting</span> the following query. Choice of clustering or not , <span style="background-color:yellow;">and</span> of needing <span style="background-color:yellow;">an</span> " <span style="background-color:yellow;">aa,bb,cc</span> " separate index depends on use case , on the size of the <span style="background-color:yellow;">rows</span> in table etc. etc . </p>
<pre><code>SELECT T1.aa, T1.bb, T1.cc , COUNT(*)
FROM tblAbc T1
LEFT OUTER JOIN tblAbc T2 ON T1.aa = T2.aa AND 
         (T1.bb < T2.bb OR(T1.bb = T2.bb AND T1.cc < T2.cc))
GROUP BY T1.aa, T1.bb, T1.cc
HAVING COUNT(*) < 5  -- trick, remember COUNT(*) goes 1,1,2,3,...
ORDER BY T1.aa, T1.bb, T1.cc, COUNT(*) DESC
</code></pre>
<p>The idea is to get <span style="background-color:yellow;">a</span> count of how many <span style="background-color:yellow;">records</span> , within <span style="background-color:yellow;">a</span> given <span style="background-color:yellow;">aa</span> value <span style="background-color:yellow;">are</span> smaller than self. There is <span style="background-color:yellow;">a</span> small trick however : we need to use LEFT OUTER join , lest we discard the <span style="background-color:yellow;">record</span> with the biggest <span style="background-color:yellow;">bb</span> value or the last one ( which may happen to be one of the <span style="background-color:yellow;">top</span> 5 ) . <span style="background-color:yellow;">As</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">result</span> of left joining it , the COUNT ( * ) value counts 1 , 1 , 2 , 3 , 4 etc. <span style="background-color:yellow;">and</span> the HAVING test therefore is " &lt ; 5 " to effectively pick the <span style="background-color:yellow;">top</span> 5 . </p>
<p>To emulate the sample output of the OP , the ORDER BY uses DESC on the COUNT ( ) , which could be <span style="background-color:yellow;">removed</span> to get <span style="background-color:yellow;">a</span> more traditional <span style="background-color:yellow;">top</span> 5 type of <span style="background-color:yellow;">listing.</span> <span style="background-color:yellow;">Also</span> , the COUNT ( ) in the select <span style="background-color:yellow;">list</span> can be <span style="background-color:yellow;">removed</span> if so desired , this does n't impact the logic of the query <span style="background-color:yellow;">and</span> the <span style="background-color:yellow;">ability</span> to properly sort . </p>
<p><span style="background-color:yellow;">Also</span> note that this query is deterministic in terms of the dealing with ties , i,e , when <span style="background-color:yellow;">a</span> given set of <span style="background-color:yellow;">records</span> have <span style="background-color:yellow;">a</span> same value for <span style="background-color:yellow;">bb</span> ( within <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">aa</span> group ) ; I think the Python program may provide slightly different outputs when the order of the input data is changed , that is because of its occasional truncating of the sorting dictionary . </p>
<p>Real solution : <span style="background-color:yellow;">A</span> SQL-based procedural <span style="background-color:yellow;">approach</span> </p>
<p>The self-join <span style="background-color:yellow;">approach</span> described <span style="background-color:yellow;">above</span> demonstrates how declarative statements can be used to express the OP 's <span style="background-color:yellow;">requirement.</span> However this <span style="background-color:yellow;">approach</span> is naive in <span style="background-color:yellow;">a</span> sense that its performance is <span style="background-color:yellow;">roughly</span> bound to the sum of the squares of <span style="background-color:yellow;">record</span> counts within each <span style="background-color:yellow;">aa</span> 'category'. ( not O ( n ^ 2 ) but <span style="background-color:yellow;">roughly</span> O ( ( n/a ) ^ 2 ) where <span style="background-color:yellow;">a</span> is the number of different values for the <span style="background-color:yellow;">aa</span> column ) In other words it performs well with data such that on <span style="background-color:yellow;">average</span> the number of <span style="background-color:yellow;">records</span> <span style="background-color:yellow;">associated</span> with <span style="background-color:yellow;">a</span> given <span style="background-color:yellow;">aa</span> value does n't exceed <span style="background-color:yellow;">a</span> few dozens. If the data is such that the <span style="background-color:yellow;">aa</span> column is not selective , the following <span style="background-color:yellow;">approach</span> is much -much ! - better suited. It leverages SQL 's efficient sorting framework , while implementing <span style="background-color:yellow;">a</span> simple <span style="background-color:yellow;">algorithm</span> that would be hard to express in declarative fashion. This <span style="background-color:yellow;">approach</span> could further be improved for datasets with particularly huge number of <span style="background-color:yellow;">records</span> each/most <span style="background-color:yellow;">aa</span> 'categories ' by <span style="background-color:yellow;">introducing</span> <span style="background-color:yellow;">a</span> simple binary search of the next <span style="background-color:yellow;">aa</span> value , by looking <span style="background-color:yellow;">ahead</span> ( <span style="background-color:yellow;">and</span> sometimes back... ) in the cursor. For cases where the number of <span style="background-color:yellow;">aa</span> 'categories ' <span style="background-color:yellow;">relative</span> to the overall <span style="background-color:yellow;">row</span> count in tblAbc is low , see yet <span style="background-color:yellow;">another</span> <span style="background-color:yellow;">approach</span> , <span style="background-color:yellow;">after</span> this next one . </p>
<pre><code>DECLARE @aa AS VARCHAR(10), @bb AS INT, @cc AS VARCHAR(10)
DECLARE @curAa AS VARCHAR(10)
DECLARE @Ctr AS INT

DROP TABLE  tblResults;
CREATE TABLE tblResults
(  aa VARCHAR(10),
   bb INT,
   cc VARCHAR(10)
);

DECLARE abcCursor CURSOR 
  FOR SELECT aa, bb, cc
  FROM tblABC
  ORDER BY aa, bb DESC, cc
  FOR READ ONLY;

OPEN abcCursor;

SET @curAa = ''

FETCH NEXT FROM abcCursor INTO @aa, @bb, @cc;
WHILE @@FETCH_STATUS = 0
BEGIN
    IF @curAa <> @aa
    BEGIN
       SET @Ctr = 0
       SET @curAa = @aa
    END
    IF @Ctr < 5
    BEGIN
       SET @Ctr = @Ctr + 1;
       INSERT tblResults VALUES(@aa, @bb, @cc);
    END
    FETCH NEXT FROM AbcCursor INTO @aa, @bb, @cc;
END;

CLOSE abcCursor;
DEALLOCATE abcCursor;

SELECT * from tblResults
ORDER BY aa, bb, cc    -- OR .. bb DESC ... for a more traditional order.
</code></pre>
<p><span style="background-color:yellow;">Alternative</span> to the <span style="background-color:yellow;">above</span> for cases when <span style="background-color:yellow;">aa</span> is very unselective. In other words , when we have <span style="background-color:yellow;">relatively</span> few <span style="background-color:yellow;">aa</span> 'categories'. The idea is to go through the <span style="background-color:yellow;">list</span> of distinct categories <span style="background-color:yellow;">and</span> to <span style="background-color:yellow;">run</span> <span style="background-color:yellow;">a</span> " LIMIT " ( MySql ) " TOP " ( MSSQL ) query for each of these values . For <span style="background-color:yellow;">reference</span> purposes , the following <span style="background-color:yellow;">ran</span> in 63 seconds for tblAbc of 61 Million <span style="background-color:yellow;">records</span> divided in 45 <span style="background-color:yellow;">aa</span> values , on MSSQL 8.0 , on <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">relatively</span> old/weak host . </p>
<pre><code>DECLARE @aa AS VARCHAR(10)
DECLARE @aaCount INT

DROP TABLE  tblResults;
CREATE TABLE tblResults
(  aa VARCHAR(10),
   bb INT,
   cc VARCHAR(10)
);

DECLARE aaCountCursor CURSOR 
  FOR SELECT aa, COUNT(*)
  FROM tblABC
  GROUP BY aa
  ORDER BY aa
  FOR READ ONLY;
OPEN aaCountCursor;


FETCH NEXT FROM aaCountCursor INTO @aa, @aaCount
WHILE @@FETCH_STATUS = 0
BEGIN
    INSERT tblResults 
       SELECT TOP 5 aa, bb, cc
       FROM tblproh
       WHERE aa = @aa
       ORDER BY aa, bb DESC, cc

    FETCH NEXT FROM aaCountCursor INTO @aa, @aaCount;
END;

CLOSE aaCountCursor
DEALLOCATE aaCountCursor

SELECT * from tblResults
ORDER BY aa, bb, cc    -- OR .. bb DESC ... for a more traditional order.
</code></pre>
<p>On the question of needing <span style="background-color:yellow;">an</span> index or not . ( cf OP 's <span style="background-color:yellow;">remark</span> ) When merely <span style="background-color:yellow;">running</span> <span style="background-color:yellow;">a</span> " SELECT * FROM myTable " , <span style="background-color:yellow;">a</span> table scan is effectively the fastest <span style="background-color:yellow;">appraoch</span> , no need to bother with indexes. However , the main <span style="background-color:yellow;">reason</span> why SQL is typically better suited for this kind of things ( <span style="background-color:yellow;">aside</span> from being the <span style="background-color:yellow;">repository</span> where the data has been <span style="background-color:yellow;">accumulating</span> in the first place , whereas <span style="background-color:yellow;">any</span> external solution needs to <span style="background-color:yellow;">account</span> for the <span style="background-color:yellow;">time</span> to export the <span style="background-color:yellow;">relevant</span> data ) , is that it can <span style="background-color:yellow;">rely</span> on indexes to <span style="background-color:yellow;">avoid</span> scanning. Many general purpose languages <span style="background-color:yellow;">are</span> far better suited to handle <span style="background-color:yellow;">raw</span> processing , but they <span style="background-color:yellow;">are</span> fighting <span style="background-color:yellow;">an</span> unfair battle with SQL because they need to <span style="background-color:yellow;">rebuilt</span> <span style="background-color:yellow;">any</span> prior knowledge of the data which SQL has gathered in the course of its data collection / import phase. Since sorting is <span style="background-color:yellow;">a</span> typically <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">time</span> <span style="background-color:yellow;">and</span> sometimes space consuming task , SQL <span style="background-color:yellow;">and</span> its <span style="background-color:yellow;">relatively</span> slower processing power often ends up <span style="background-color:yellow;">ahead</span> of <span style="background-color:yellow;">alternative</span> solutions . </p>
<p><span style="background-color:yellow;">Also</span> , even without pre-built indexes , modern query optimizers may decide on <span style="background-color:yellow;">a</span> plan that involves the creation of <span style="background-color:yellow;">a</span> temporary index. <span style="background-color:yellow;">And</span> , because sorting is <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">intrinsic</span> part of DDMS , the SQL servers <span style="background-color:yellow;">are</span> generally efficient in that <span style="background-color:yellow;">area</span> . </p>
<p>So... Is SQL better ? </p>
<p>This said , if we <span style="background-color:yellow;">are</span> trying to compare SQL <span style="background-color:yellow;">and</span> other languages for pure ETL jobs , i.e. for dealing with heaps ( unindexed tables ) <span style="background-color:yellow;">as</span> its input to perform various transformations <span style="background-color:yellow;">and</span> filtering , it is likely that multi-thread-able <span style="background-color:yellow;">utilities</span> written in say C , <span style="background-color:yellow;">and</span> leveraging efficient sorting libaries , would likely be faster. The determining question to decide on <span style="background-color:yellow;">a</span> SQL vs. Non-SQL <span style="background-color:yellow;">approach</span> is where the data is located <span style="background-color:yellow;">and</span> where should it eventually <span style="background-color:yellow;">reside.</span> If we merely to convert <span style="background-color:yellow;">a</span> file to be supplied down " the chain " external programs <span style="background-color:yellow;">are</span> better suited. If we have or need the data in <span style="background-color:yellow;">a</span> SQL server , there <span style="background-color:yellow;">are</span> only <span style="background-color:yellow;">rare</span> cases that make it worthwhile exporting <span style="background-color:yellow;">and</span> processing externally . </p>
<br /><b># 1 </b><br /><p>You could use smarter data structures <span style="background-color:yellow;">and</span> still use python . I 've <span style="background-color:yellow;">ran</span> your <span style="background-color:yellow;">reference</span> implementation <span style="background-color:yellow;">and</span> my python implementation on my machine <span style="background-color:yellow;">and</span> even compared the output to be sure in <span style="background-color:yellow;">results</span> . </p>
<p>This is yours : </p>
<pre><code>$ time python ./ref.py  < data-large.txt  > ref-large.txt

real 1m57.689s
user 1m56.104s
sys 0m0.573s
</code></pre>
<p>This is mine : </p>
<pre><code>$ time python ./my.py  < data-large.txt  > my-large.txt

real 1m35.132s
user 1m34.649s
sys 0m0.261s
$ diff my-large.txt ref-large.txt 
$ echo $?
0
</code></pre>
<p><span style="background-color:yellow;">And</span> this is the source : </p>
<pre><code>#!/usr/bin/python
# -*- coding: utf-8; -*-
import sys
import heapq

top_5 = {}

for line in sys.stdin:
    aa, bb, cc = line.split()

    # We want the top 5 for each distinct value of aa.  There are
    # hundreds of thousands of values of aa.
    bb = float(bb)
    if aa not in top_5: top_5[aa] = []
    current = top_5[aa]
    if len(current) < 5:
        heapq.heappush(current, (bb, cc))
    else:
        if current[0] < (bb, cc):
            heapq.heapreplace(current, (bb, cc))

for aa in top_5:
    current = top_5[aa]
    while len(current) > 0:
        bb, cc = heapq.heappop(current)
        print aa, bb, cc
</code></pre>
<p>Update : Know your limits . I 've <span style="background-color:yellow;">also</span> <span style="background-color:yellow;">timed</span> <span style="background-color:yellow;">a</span> noop code , to know the fastest possible python solution with code similar to the original : </p>
<pre><code>$ time python noop.py < data-large.txt  > noop-large.txt

real    1m20.143s
user    1m19.846s
sys 0m0.267s
</code></pre>
<p><span style="background-color:yellow;">And</span> the noop.py itself : </p>
<pre><code>#!/usr/bin/python
# -*- coding: utf-8; -*-
import sys
import heapq

top_5 = {}

for line in sys.stdin:
    aa, bb, cc = line.split()

    bb = float(bb)
    if aa not in top_5: top_5[aa] = []
    current = top_5[aa]
    if len(current) < 5:
        current.append((bb, cc))

for aa in top_5:
    current = top_5[aa]
    current.sort()
    for bb, cc in current[-5:]:
        print aa, bb, cc
</code></pre>
<br /><b># 2 </b><br /><p>This is <span style="background-color:yellow;">a</span> sketch in Common Lisp </p>
<p>Note that for long files there is <span style="background-color:yellow;">a</span> penalty for using READ-LINE , because it conses <span style="background-color:yellow;">a</span> fresh string for each line. Then use one of the derivatives of READ-LINE that <span style="background-color:yellow;">are</span> floating <span style="background-color:yellow;">around</span> that <span style="background-color:yellow;">are</span> using <span style="background-color:yellow;">a</span> line buffer. <span style="background-color:yellow;">Also</span> you might check if you want the hash table be case sensitive or not . </p>
<p>second version </p>
<p>Splitting the string is no longer needed , because we do it here. It is low level code , in the hope that some speed gains will be possible. It checks for one or more spaces <span style="background-color:yellow;">as</span> field delimiter <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">also</span> tabs . </p>
<pre><code>(defun read-a-line (stream)
  (let ((line (read-line stream nil nil)))
    (flet ((delimiter-p (c)
             (or (char= c #\space) (char= c #\tab))))
      (when line
        (let* ((s0 (position-if     #'delimiter-p line))
               (s1 (position-if-not #'delimiter-p line :start s0))
               (s2 (position-if     #'delimiter-p line :start (1+ s1)))
               (s3 (position-if     #'delimiter-p line :from-end t)))
          (values (subseq line 0 s0)
                  (list (read-from-string line nil nil :start s1 :end s2)
                        (subseq line (1+ s3)))))))))
</code></pre>
<p><span style="background-color:yellow;">Above</span> function <span style="background-color:yellow;">returns</span> two values : the <span style="background-color:yellow;">key</span> <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> of the <span style="background-color:yellow;">rest</span> . </p>
<pre><code>(defun dbscan (top-5-table stream)
   "get triples from each line and put them in the hash table"
  (loop with aa = nil and bbcc = nil do
    (multiple-value-setq (aa bbcc) (read-a-line stream))
    while aa do
    (setf (gethash aa top-5-table)
          (let ((l (merge 'list (gethash aa top-5-table) (list bbcc)
                          #'> :key #'first)))
             (or (and (nth 5 l) (subseq l 0 5)) l)))))


(defun dbprint (table output)
  "print the hashtable contents"
  (maphash (lambda (aa value)
              (loop for (bb cc) in value
                    do (format output "~a ~a ~a~%" aa bb cc)))
           table))

(defun dbsum (input &optional (output *standard-output*))
  "scan and sum from a stream"
  (let ((top-5-table (make-hash-table :test #'equal)))
    (dbscan top-5-table input)
    (dbprint top-5-table output)))


(defun fsum (infile outfile)
   "scan and sum a file"
   (with-open-file (input infile :direction :input)
     (with-open-file (output outfile
                      :direction :output :if-exists :supersede)
       (dbsum input output))))
</code></pre>
<p>some test data </p>
<pre><code>(defun create-test-data (&key (file "/tmp/test.data") (n-lines 100000))
  (with-open-file (stream file :direction :output :if-exists :supersede)
    (loop repeat n-lines
          do (format stream "~a ~a ~a~%"
                     (random 1000) (random 100.0) (random 10000)))))
</code></pre>
<p>; ( create-test-data ) </p>
<pre><code>(defun test ()
  (time (fsum "/tmp/test.data" "/tmp/result.data")))
</code></pre>
<p>third version , LispWorks </p>
<p>Uses some SPLIT-STRING <span style="background-color:yellow;">and</span> PARSE-FLOAT functions , otherwise generic CL . </p>
<pre><code>(defun fsum (infile outfile)
  (let ((top-5-table (make-hash-table :size 50000000 :test #'equal)))
    (with-open-file (input infile :direction :input)
      (loop for line = (read-line input nil nil)
            while line do
            (destructuring-bind (aa bb cc) (split-string '(#\space #\tab) line)
              (setf bb (parse-float bb))
              (let ((v (gethash aa top-5-table)))
                (unless v
                  (setf (gethash aa top-5-table)
                        (setf v (make-array 6 :fill-pointer 0))))
                (vector-push (cons bb cc) v)
                (when (> (length v) 5)
                  (setf (fill-pointer (sort v #'> :key #'car)) 5))))))
    (with-open-file (output outfile :direction :output :if-exists :supersede)
      (maphash (lambda (aa value)
                 (loop for (bb . cc) across value do
                       (format output "~a ~f ~a~%" aa bb cc)))
               top-5-table))))
</code></pre>
<br /><b># 3 </b><br /><p>This took 45.7s on my machine with 27M <span style="background-color:yellow;">rows</span> of data that looked like this : </p>
<pre><code>42 0.49357 0
96 0.48075 1
27 0.640761 2
8 0.389128 3
75 0.395476 4
24 0.212069 5
80 0.121367 6
81 0.271959 7
91 0.18581 8
69 0.258922 9
</code></pre>
<p>Your script took 1m42 on this data , the c + + example too 1m46 ( g + + t.cpp -o t to compile it , I do n't know <span style="background-color:yellow;">anything</span> <span style="background-color:yellow;">about</span> c + + ) . </p>
<p>Java 6 , not that it matters <span style="background-color:yellow;">really.</span> Output is n't perfect , but it 's easy to fix . </p>
<pre><code>package top5;

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.Arrays;
import java.util.Map;
import java.util.TreeMap;

public class Main {

    public static void main(String[] args) throws Exception {
        long start  = System.currentTimeMillis();
        Map<String, Pair[]> top5map = new TreeMap<String, Pair[]>();
        BufferedReader br = new BufferedReader(new FileReader("/tmp/file.dat"));

        String line = br.readLine();
        while(line != null) {
            String parts[] = line.split(" ");

            String key = parts[0];
            double score = Double.valueOf(parts[1]);
            String value = parts[2];
            Pair[] pairs = top5map.get(key);

            boolean insert = false;
            Pair p = null;
            if (pairs != null) {
                insert = (score > pairs[pairs.length - 1].score) || pairs.length < 5;
            } else {
                insert = true;
            }
            if (insert) {
                p = new Pair(score, value);
                if (pairs == null) {
                    pairs = new Pair[1];
                    pairs[0] = new Pair(score, value);
                } else {
                    if (pairs.length < 5) {
                        Pair[] newpairs = new Pair[pairs.length + 1];
                        System.arraycopy(pairs, 0, newpairs, 0, pairs.length);
                        pairs = newpairs;
                    }
                    int k = 0;
                    for(int i = pairs.length - 2; i >= 0; i--) {
                        if (pairs[i].score <= p.score) {
                            pairs[i + 1] = pairs[i];
                        } else {
                            k = i + 1;
                            break;
                        }
                    }
                    pairs[k] = p;
                }
                top5map.put(key, pairs);
            }
            line = br.readLine();
        }
        for(Map.Entry<String, Pair[]> e : top5map.entrySet()) {
            System.out.print(e.getKey());
            System.out.print(" ");
            System.out.println(Arrays.toString(e.getValue()));
        }
        System.out.println(System.currentTimeMillis() - start);
    }

    static class Pair {
        double score;
        String value;

        public Pair(double score, String value) {
            this.score = score;
            this.value = value;
        }

        public int compareTo(Object o) {
            Pair p = (Pair) o;
            return (int)Math.signum(score - p.score);
        }

        public String toString() {
            return String.valueOf(score) + ", " + value;
        }
    }
}
</code></pre>
<p><span style="background-color:yellow;">AWK</span> script to fake the data : </p>
<pre><code>BEGIN {
 for (i = 0; i < 27000000; i++) {
  v = rand();
  k = int(rand() * 100);
  print k " " v " " i;
 }
 exit;
}
</code></pre>
<br /><b># 4 </b><br /><p>Pretty straightforward Caml ( 27 * <span style="background-color:yellow;">10</span> ^ 6 <span style="background-color:yellow;">rows</span> -- 27 sec , C + + by hrnt -- 29 sec ) </p>
<pre><code>open Printf
open ExtLib

let (>>) x f = f x
let cmp x y = compare (fst x : float) (fst y)
let wsp = Str.regexp "[ \t]+"

let () =
  let all = Hashtbl.create 1024 in
  Std.input_lines stdin >> Enum.iter (fun line ->
    let [a;b;c] = Str.split wsp line in
    let b = float_of_string b in
    try
      match Hashtbl.find all a with
      | [] -> assert false
      | (bmin,_) as prev::tl -> if b > bmin then
        begin
          let m = List.sort ~cmp ((b,c)::tl) in
          Hashtbl.replace all a (if List.length tl < 4 then prev::m else m)
        end
    with Not_found -> Hashtbl.add all a [b,c]
  );
  all >> Hashtbl.iter (fun a -> List.iter (fun (b,c) -> printf "%s %f %s\n" a b c))
</code></pre>
<br /><b># 5 </b><br /><p>Here is <span style="background-color:yellow;">a</span> C + + solution. I did n't have <span style="background-color:yellow;">a</span> lot of data to test it with , however , so I do n't know how fast it <span style="background-color:yellow;">actually</span> is . </p>
<p>[ edit ] Thanks to the test data provided by the <span style="background-color:yellow;">awk</span> script in this thread , I managed to clean up <span style="background-color:yellow;">and</span> speed up the code <span style="background-color:yellow;">a</span> bit. I <span style="background-color:yellow;">am</span> not trying to find out the fastest possible version - the <span style="background-color:yellow;">intent</span> is to provide <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">reasonably</span> fast version that is n't <span style="background-color:yellow;">as</span> ugly <span style="background-color:yellow;">as</span> people seem to think STL solutions can be . </p>
<p>This version should be <span style="background-color:yellow;">about</span> twice <span style="background-color:yellow;">as</span> fast <span style="background-color:yellow;">as</span> the first version ( goes through 27 million lines in <span style="background-color:yellow;">about</span> 35 seconds ) . Gcc users , <span style="background-color:yellow;">remember</span> to compile this with -O2 . </p>
<pre><code>#include <map>
#include <iostream>
#include <functional>
#include <utility>
#include <string>
int main() {
  using namespace std;
  typedef std::map<string, std::multimap<double, string> > Map;
  Map m;
  string aa, cc;
  double bb;
  std::cin.sync_with_stdio(false); // Dunno if this has any effect, but anyways.

  while (std::cin >> aa >> bb >> cc)
    {
      if (m[aa].size() == 5)
        {
          Map::mapped_type::iterator iter = m[aa].begin();
          if (bb < iter->first)
            continue;
          m[aa].erase(iter);
        }
      m[aa].insert(make_pair(bb, cc));
    }
  for (Map::const_iterator iter = m.begin(); iter != m.end(); ++iter)
    for (Map::mapped_type::const_iterator iter2 = iter->second.begin();
         iter2 != iter->second.end();
         ++iter2)
      std::cout << iter->first << " " << iter2->first << " " << iter2->second <<
 std::endl;

}
</code></pre>
<br /><b># 6 </b><br /><p>Interestingly , the original Python solution is by far the cleanest looking ( <span style="background-color:yellow;">although</span> the C + + example comes close ) . </p>
<p>How <span style="background-color:yellow;">about</span> using Pyrex or Psyco on your original code ? </p>
<br /><b># 7 </b><br /><p>Of <span style="background-color:yellow;">all</span> the programs in this thread that I 've tested so far , the OCaml version is the fastest <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">also</span> <span style="background-color:yellow;">among</span> the shortest . ( Line-of-code-based measurements <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">a</span> little fuzzy , but it 's not clearly longer than the Python version or the C or C + + versions , <span style="background-color:yellow;">and</span> it is clearly faster. ) </p>
<blockquote>Note : I figured out why my earlier <span style="background-color:yellow;">runtimes</span> were so nondeterministic ! My CPU heatsink was clogged with dust <span style="background-color:yellow;">and</span> my CPU was overheating <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">result.</span> Now I <span style="background-color:yellow;">am</span> getting nice deterministic benchmark <span style="background-color:yellow;">times.</span> I think I 've now <span style="background-color:yellow;">redone</span> <span style="background-color:yellow;">all</span> the timing measurements in this thread now that I have <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">reliable</span> way to <span style="background-color:yellow;">time</span> things . </blockquote>
<p>Here <span style="background-color:yellow;">are</span> the timings for the different versions so far , <span style="background-color:yellow;">running</span> on <span style="background-color:yellow;">a</span> 27-million-row 630-megabyte input data file. I 'm on Ubuntu Intrepid Ibex on <span style="background-color:yellow;">a</span> dual-core 1.6GHz Celeron , <span style="background-color:yellow;">running</span> <span style="background-color:yellow;">a</span> 32-bit version of the OS ( the Ethernet driver was broken in the 64-bit version ) . I <span style="background-color:yellow;">ran</span> each program five <span style="background-color:yellow;">times</span> <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">report</span> the <span style="background-color:yellow;">range</span> of <span style="background-color:yellow;">times</span> those five tries took. I 'm using Python 2.5.2 , OpenJDK 1.6.0.0 , OCaml 3.10.2 , GCC 4.3.2 , SBCL 1.0.8.debian , <span style="background-color:yellow;">and</span> Octave 3.0.1 . </p>
<ul>
<li>SquareCog's Pig version: not yet tested (because I can't just <code>apt-get install pig</code>), <em>7</em> lines of code.</li>
<li>mjv's pure SQL version: not yet tested, but I predict a runtime of several days; <em>7</em> lines of code.</li>
<li>ygrek's OCaml version: <strong>68.7 seconds</strong> ±0.9 in <em>15</em> lines of code.</li>
<li>My Python version: <strong>169 seconds</strong> ±4 or <strong>86 seconds</strong> ±2 with Psyco, in <em>16</em> lines of code.</li>
<li>abbot's heap-based Python version: <strong>177 seconds</strong> ±5 in <em>18</em> lines of code, or <strong>83 seconds</strong> ±5 with Psyco.</li>
<li>My C version below, composed with GNU <code>sort -n</code>: <strong>90 + 5.5 seconds</strong> (±3, ±0.1), but gives the wrong answer because of a deficiency in GNU <code>sort</code>, in <em>22</em> lines of code (including one line of shell.)</li>
<li>hrnt's C++ version: <strong>217 seconds</strong> ±3 in <em>25</em> lines of code.</li>
<li>mjv's alternative SQL-based procedural approach: not yet tested, <em>26</em> lines of code.</li>
<li>mjv's first SQL-based procedural approach: not yet tested, <em>29</em> lines of code.</li>
<li>peufeu's <a href="http://gist.github.com/194877" rel="nofollow" title="My modified version as a gist">Python version with Psyco</a>: <strong>181 seconds</strong> ±4, somewhere around <em>30</em> lines of code.</li>
<li>Rainer Joswig's Common Lisp version: <strong>478 seconds</strong> (only run once) in <em>42</em> lines of code.</li>
<li>abbot's <code>noop.py</code>, which intentionally gives incorrect results to establish a lower bound: not yet tested, <em>15</em> lines of code.</li>
<li>Will Hartung's Java version: <strong>96 seconds</strong> ±10 in, according to David A. Wheeler’s SLOCCount, <em>74</em> lines of code.</li>
<li>Greg's Matlab version: doesn't work.</li>
<li>Schuyler Erle's suggestion of using Pyrex on one of the Python versions: not yet tried.</li>
</ul>
<p>I supect abbot's version comes out relatively worse for me than for them because the real dataset has a highly nonuniform distribution: as I said, some <code>aa</code> values (“players”) have thousands of lines, while others only have one.</p>
<p><span style="background-color:yellow;">About</span> Psyco : I <span style="background-color:yellow;">applied</span> Psyco to my original code ( <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">abbot</span> 's version ) by putting it in <span style="background-color:yellow;">a</span> main function , which by itself cut the <span style="background-color:yellow;">time</span> down to <span style="background-color:yellow;">about</span> 140 seconds , <span style="background-color:yellow;">and</span> calling psyco.full ( ) before calling main ( ) . This <span style="background-color:yellow;">added</span> <span style="background-color:yellow;">about</span> four lines of code . </p>
<p>I can <span style="background-color:yellow;">almost</span> solve the problem using GNU sort , <span style="background-color:yellow;">as</span> follows : </p>
<pre><code>kragen@inexorable:~/devel$ time LANG=C sort -nr infile -o sorted

real    1m27.476s
user    0m59.472s
sys 0m8.549s
kragen@inexorable:~/devel$ time ./top5_sorted_c < sorted > outfile

real    0m5.515s
user    0m4.868s
sys 0m0.452s
</code></pre>
<p>Here <span style="background-color:yellow;">top5_sorted_c</span> is this short C program : </p>
<pre><code>#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

enum { linesize = 1024 };

char buf[linesize];
char key[linesize];             /* last key seen */

int main() {
  int n = 0;
  char *p;

  while (fgets(buf, linesize, stdin)) {
    for (p = buf; *p && !isspace(*p); p++) /* find end of key on this line */
      ;
    if (p - buf != strlen(key) || 0 != memcmp(buf, key, p - buf)) 
      n = 0;                    /* this is a new key */
    n++;

    if (n <= 5)               /* copy up to five lines for each key */
      if (fputs(buf, stdout) == EOF) abort();

    if (n == 1) {               /* save new key in `key` */
      memcpy(key, buf, p - buf);
      key[p-buf] = '\0';
    }
  }
  return 0;
}
</code></pre>
<p>I first tried writing that program in C++ as follows, and I got runtimes which were substantially slower, at 33.6±2.3 seconds instead of 5.5±0.1 seconds:</p>
<pre><code>#include <map>
#include <iostream>
#include <string>

int main() {
  using namespace std;
  int n = 0;
  string prev, aa, bb, cc;

  while (cin >> aa >> bb >> cc) {
    if (aa != prev) n = 0;
    ++n;
    if (n <= 5) cout << aa << " " << bb << " " << cc << endl;
    prev = aa;
  }
  return 0;
}
</code></pre>
<p>I did say <span style="background-color:yellow;">almost</span> . The problem is that sort -n does okay for most of the data , but it fails when it 's trying to compare 0.33 with 3.78168e-05 . So to get this kind of performance <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">actually</span> solve the problem , I need <span style="background-color:yellow;">a</span> better sort . </p>
<p>Anyway, I kind of feel like I'm whining, but the sort-and-filter approach is about 5× faster than the Python program, while the elegant STL program from hrnt is actually a little slower — there seems to be some kind of gross inefficiency in <code><iostream></code>. I don't know where the other 83% of the runtime is going in that little C++ version of the filter, but it isn't going anywhere useful, which makes me suspect I don't know where it's going in hrnt's <code>std::map</code> version either. Could that version be sped up 5× too? Because that would be pretty cool. Its working set <em>might</em> be bigger than my L2 cache, but as it happens it probably isn't.</p>
<p>Some investigation with callgrind says my filter program in C++ is executing 97% of its instructions inside of <code>operator >></code>. I can identify at least 10 function calls per input byte, and <code>cin.sync_with_stdio(false);</code> doesn’t help. This probably means I could get hrnt’s C program to run substantially faster by parsing input lines more efficiently.</p>
<p>Edit: kcachegrind claims that hrnt’s program executes 62% of its instructions (on a small 157000 line input file) extracting <code>double</code>s from an <code>istream</code>. A substantial part of this is because the istreams library apparently executes about 13 function calls per input byte when trying to parse a <code>double</code>. Insane. Could I be misunderstanding kcachegrind's output?</p>
<p><span style="background-color:yellow;">Anyway</span> , <span style="background-color:yellow;">any</span> other suggestions ? </p>
<br /><b># 8 </b><br /><p>Has <span style="background-color:yellow;">anybody</span> tried doing this problem with just <span style="background-color:yellow;">awk.</span> Specifically 'mawk ' ? It should be faster than even Java <span style="background-color:yellow;">and</span> C + + , <span style="background-color:yellow;">according</span> to this blog post : http : //anyall.org/blog/2009/09/dont-mawk-awk-the-fastest-and-most-elegant-big-data-munging-language/ </p>
<p>EDIT : Just wanted to clarify that the only claim being made in that blog post is that for <span style="background-color:yellow;">a</span> certain class of problems that <span style="background-color:yellow;">are</span> specifically suited to <span style="background-color:yellow;">awk-style</span> processing , the mawk virtual machine can beat 'vanilla ' implementations in Java <span style="background-color:yellow;">and</span> C + + . </p>
<br /><b># 9 </b><br /><p>Since you <span style="background-color:yellow;">asked</span> <span style="background-color:yellow;">about</span> Matlab , here 's how I did something like what you 're <span style="background-color:yellow;">asking</span> for. I tried to do it without <span style="background-color:yellow;">any</span> for loops , but I do have one because I did n't care to take <span style="background-color:yellow;">a</span> long <span style="background-color:yellow;">time</span> with it. If you were worried <span style="background-color:yellow;">about</span> memory then you could pull data from the stream in chunks with fscanf <span style="background-color:yellow;">rather</span> than <span style="background-color:yellow;">reading</span> the entire buffer . </p>
<pre><code>fid = fopen('fakedata.txt','r');
tic
A=fscanf(fid,'%d %d %d\n');
A=reshape(A,3,length(A)/3)';  %Matlab reads the data into one long column'
Names = unique(A(:,1));
for i=1:length(Names)
    indices = find(A(:,1)==Names(i));   %Grab all instances of key i
    [Y,I] = sort(A(indices,2),1,'descend'); %sort in descending order of 2nd record
    A(indices(I(1:min([5,length(indices(I))]))),:) %Print the top five
end
toc
fclose(fid)
</code></pre>
<br /><b># <span style="background-color:yellow;">10</span> </b><br /><p>Speaking of lower bounds on compute <span style="background-color:yellow;">time</span> : </p>
<p>Let 's <span style="background-color:yellow;">analyze</span> my <span style="background-color:yellow;">algo</span> <span style="background-color:yellow;">above</span> : </p>
<pre><code>for each row (key,score,id) :
    create or fetch a list of top scores for the row's key
    if len( this list ) < N
        append current
    else if current score > minimum score in list
        replace minimum of list with current row
        update minimum of all lists if needed
</code></pre>
<p>Let N be the N in <span style="background-color:yellow;">top-N</span> Let R be the number of <span style="background-color:yellow;">rows</span> in your data set Let K be the number of distinct <span style="background-color:yellow;">keys</span> </p>
<p>What <span style="background-color:yellow;">assumptions</span> can we make ? </p>
<p>R * sizeof ( <span style="background-color:yellow;">row</span> ) &gt ; RAM or <span style="background-color:yellow;">at</span> least it 's big enough that we do n't want to load it <span style="background-color:yellow;">all</span> , use <span style="background-color:yellow;">a</span> hash to group by <span style="background-color:yellow;">key</span> , <span style="background-color:yellow;">and</span> sort each bin. For the same <span style="background-color:yellow;">reason</span> we do n't sort the whole stuff . </p>
<p>Kragen likes hashtables , so K * sizeof ( per-key state ) &lt ; &lt ; RAM , most probably it fits in L2/3 cache </p>
<p>Kragen is not sorting , so K * N &lt ; &lt ; R ie each <span style="background-color:yellow;">key</span> has much more than N entries </p>
<p>( note : <span style="background-color:yellow;">A</span> &lt ; &lt ; B means <span style="background-color:yellow;">A</span> is small <span style="background-color:yellow;">relative</span> to B ) </p>
<p>If the data has <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">random</span> distribution , then </p>
<p><span style="background-color:yellow;">after</span> <span style="background-color:yellow;">a</span> small number of <span style="background-color:yellow;">rows</span> , the majority of <span style="background-color:yellow;">rows</span> will be <span style="background-color:yellow;">rejected</span> by the per-key minimum condition , the cost is 1 comparison per <span style="background-color:yellow;">row</span> . </p>
<p>So the cost per <span style="background-color:yellow;">row</span> is 1 hash lookup + 1 comparison + epsilon * ( <span style="background-color:yellow;">list</span> <span style="background-color:yellow;">insertion</span> + ( N + 1 ) comparisons for the minimum ) </p>
<p>If the <span style="background-color:yellow;">scores</span> have <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">random</span> distribution ( say between 0 <span style="background-color:yellow;">and</span> 1 ) <span style="background-color:yellow;">and</span> the conditions <span style="background-color:yellow;">above</span> hold , both epsilons will be very small . </p>
<p>Experimental proof : </p>
<p>The 27 million <span style="background-color:yellow;">rows</span> dataset <span style="background-color:yellow;">above</span> produces 5933 <span style="background-color:yellow;">insertions</span> <span style="background-color:yellow;">into</span> the <span style="background-color:yellow;">top-N</span> <span style="background-color:yellow;">lists.</span> <span style="background-color:yellow;">All</span> other <span style="background-color:yellow;">rows</span> <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">rejected</span> by <span style="background-color:yellow;">a</span> simple <span style="background-color:yellow;">key</span> lookup <span style="background-color:yellow;">and</span> comparison. epsilon = 0.0001 </p>
<p>So <span style="background-color:yellow;">roughly</span> , the cost is 1 lookup + coparison per <span style="background-color:yellow;">row</span> , which takes <span style="background-color:yellow;">a</span> few nanoseconds . </p>
<p>On <span style="background-color:yellow;">current</span> hardware , there is no way this is not going to be negligible versus IO cost <span style="background-color:yellow;">and</span> especially parsing costs . </p>
<br /><b># 11 </b><br /><p>Here is one more OCaml version - targeted for speed - with custom parser on Streams. Too long , but parts of the parser <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">reusable.</span> Thanks peufeu for triggering competition : ) </p>
<p>Speed : </p>
<ul>simple ocaml - 27 sec ocaml with Stream parser - 15 sec c with manual parser - 5 sec </ul>
<p>Compile with : </p>
<pre><code>ocamlopt -pp camlp4o code.ml -o caml
</code></pre>
<p>Code : </p>
<pre><code>open Printf

let cmp x y = compare (fst x : float) (fst y)
let digit c = Char.code c - Char.code '0'

let rec parse f = parser
  | [< a=int; _=spaces; b=float; _=spaces; 
       c=rest (Buffer.create 100); t >] -> f a b c; parse f t
  | [< >] -> ()
and int = parser
  | [< ''0'..'9' as c; t >] -> int_ (digit c) t
  | [< ''-'; ''0'..'9' as c; t >] -> - (int_ (digit c) t)
and int_ n = parser
  | [< ''0'..'9' as c; t >] -> int_ (n * 10 + digit c) t
  | [< >] -> n
and float = parser
  | [< n=int; t=frem; e=fexp >] -> (float_of_int n +. t) *. (10. ** e)
and frem = parser
  | [< ''.'; r=frem_ 0.0 10. >] -> r
  | [< >] -> 0.0
and frem_ f base = parser
  | [< ''0'..'9' as c; t >] -> 
      frem_ (float_of_int (digit c) /. base +. f) (base *. 10.) t
  | [< >] -> f
and fexp = parser
  | [< ''e'; e=int >] -> float_of_int e
  | [< >] -> 0.0
and spaces = parser
  | [< '' '; t >] -> spaces t
  | [< ''\t'; t >] -> spaces t
  | [< >] -> ()
and crlf = parser
  | [< ''\r'; t >] -> crlf t
  | [< ''\n'; t >] -> crlf t
  | [< >] -> ()
and rest b = parser
  | [< ''\r'; _=crlf >] -> Buffer.contents b
  | [< ''\n'; _=crlf >] -> Buffer.contents b
  | [< 'c; t >] -> Buffer.add_char b c; rest b t
  | [< >] -> Buffer.contents b

let () =
  let all = Array.make 200 [] in
  let each a b c =
    assert (a >= 0 && a < 200);
    match all.(a) with
    | [] -> all.(a) <- [b,c]
    | (bmin,_) as prev::tl -> if b > bmin then
      begin
        let m = List.sort cmp ((b,c)::tl) in
        all.(a) <- if List.length tl < 4 then prev::m else m
      end
  in
  parse each (Stream.of_channel stdin);
  Array.iteri 
    (fun a -> List.iter (fun (b,c) -> printf "%i %f %s\n" a b c))
    all
</code></pre>
<br /><b># 12 </b><br /><p>Is n't this just <span style="background-color:yellow;">as</span> simple <span style="background-color:yellow;">as</span> </p>
<pre><code> SELECT DISTINCT aa, bb, cc FROM tablename ORDER BY bb DESC LIMIT 5
</code></pre>
<p>? </p>
<p>Of course , it 's hard to tell what would be fastest without testing it <span style="background-color:yellow;">against</span> the data. <span style="background-color:yellow;">And</span> if this is something you need to <span style="background-color:yellow;">run</span> very fast , it might make sense to optimize your database to make the query faster , <span style="background-color:yellow;">rather</span> than optimizing the query . </p>
<p><span style="background-color:yellow;">And</span> , of course , if you need the flat file <span style="background-color:yellow;">anyway</span> , you might <span style="background-color:yellow;">as</span> well use that . </p>
<br /><b># 13 </b><br /><p>The Pig version would go something like this ( untested ) : </p>
<pre><code> Data = LOAD '/my/data' using PigStorage() as (aa:int, bb:float, cc:chararray);
 grp = GROUP Data by aa;
 topK = FOREACH grp (
     sorted = ORDER Data by bb DESC;
     lim = LIMIT sorted 5;
     GENERATE group as aa, lim;
)
STORE topK INTO '/my/output' using PigStorage();
</code></pre>
<p>Pig is n't optimized for performance ; it 's goal is to enable processing of multi-terabyte datasets using parallel execution frameworks. It does have <span style="background-color:yellow;">a</span> local mode , so you can try it , but I doubt it will beat your script . </p>
<br /><b># 14 </b><br /><p>That was <span style="background-color:yellow;">a</span> nice lunch break challenge , he , he . </p>
<p>Top-N is <span style="background-color:yellow;">a</span> well-known database killer. <span style="background-color:yellow;">As</span> shown by the post <span style="background-color:yellow;">above</span> , there is no way to efficiently express it in common SQL . </p>
<p><span style="background-color:yellow;">As</span> for the various implementations , you got to keep in mind that the slow part in this is not the sorting or the <span style="background-color:yellow;">top-N</span> , it 's the parsing of text. Have you looked <span style="background-color:yellow;">at</span> the source code for glibc 's strtod ( ) lately ? </p>
<p>For instance , I get , using Python : </p>
<pre><code>Read data : 80.5  s
My TopN   : 34.41 s
HeapTopN  : 30.34 s
</code></pre>
<p>It is quite likely that you 'll never get very fast timings , no matter what language you use , unless your data is in some format that is <span style="background-color:yellow;">a</span> lot faster to parse than text. For instance , loading the test data <span style="background-color:yellow;">into</span> postgres takes 70 s , <span style="background-color:yellow;">and</span> the majority of that is text parsing , too . </p>
<p>If the N in your <span style="background-color:yellow;">topN</span> is small , like 5 , <span style="background-color:yellow;">a</span> C implementation of my <span style="background-color:yellow;">algorithm</span> below would probably be the fastest. If N can be larger , heaps <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">a</span> much better option . </p>
<p>So , since your data is probably in <span style="background-color:yellow;">a</span> database , <span style="background-color:yellow;">and</span> your problem is getting <span style="background-color:yellow;">at</span> the data , not the <span style="background-color:yellow;">actual</span> processing , if you 're <span style="background-color:yellow;">really</span> in need of <span style="background-color:yellow;">a</span> super fast TopN engine , what you should do is write <span style="background-color:yellow;">a</span> C module for your database of choice. Since postgres is faster for <span style="background-color:yellow;">about</span> <span style="background-color:yellow;">anything</span> , I suggest using postgres , plus it is n't difficult to write <span style="background-color:yellow;">a</span> C module for it . </p>
<p>Here 's my Python code : </p>
<pre><code>import random, sys, time, heapq

ROWS = 27000000

def make_data( fname ):
    f = open( fname, "w" )
    r = random.Random()
    for i in xrange( 0, ROWS, 10000 ):
        for j in xrange( i,i+10000 ):
            f.write( "%d    %f    %d\n" % (r.randint(0,100), r.uniform(0,1000), j))
        print ("write: %d\r" % i),
        sys.stdout.flush()
    print

def read_data( fname ):
    for n, line in enumerate( open( fname ) ):
        r = line.strip().split()
        yield int(r[0]),float(r[1]),r[2]
        if not (n % 10000 ):
            print ("read: %d\r" % n),
            sys.stdout.flush()
    print

def topn( ntop, data ):
    ntop -= 1
    assert ntop > 0
    min_by_key = {}
    top_by_key = {}
    for key,value,label in data:
        tup = (value,label)
        if key not in top_by_key:
            # initialize
            top_by_key[key] = [ tup ]
        else:
            top = top_by_key[ key ]
            l    = len( top )
            if l > ntop:
                # replace minimum value in top if it is lower than current value
                idx = min_by_key[ key ]
                if top[idx] < tup:
                    top[idx] = tup
                    min_by_key[ key ] = top.index( min( top ) )
            elif l < ntop:
                # fill until we have ntop entries
                top.append( tup )
            else:
                # we have ntop entries in list, we'll have ntop+1
                top.append( tup )
                # initialize minimum to keep
                min_by_key[ key ] = top.index( min( top ) )

    # finalize:
    return dict( (key, sorted( values, reverse=True )) for key,values in top_by_key.iteritems() )

def grouptopn( ntop, data ):
    top_by_key = {}
    for key,value,label in data:
        if key in top_by_key:
            top_by_key[ key ].append( (value,label) )
        else:
            top_by_key[ key ] = [ (value,label) ]

    return dict( (key, sorted( values, reverse=True )[:ntop]) for key,values in top_by_key.iteritems() )

def heaptopn( ntop, data ):
    top_by_key = {}
    for key,value,label in data:
        tup = (value,label)
        if key not in top_by_key:
            top_by_key[ key ] = [ tup ]
        else:
            top = top_by_key[ key ]
            if len(top) < ntop:
                heapq.heappush(top, tup)
            else:
                if top[0] < tup:
                    heapq.heapreplace(top, tup)

    return dict( (key, sorted( values, reverse=True )) for key,values in top_by_key.iteritems() )

def dummy( data ):
    for row in data:
        pass

make_data( "data.txt" )

t = time.clock()
dummy( read_data( "data.txt" ) )
t_read = time.clock() - t

t = time.clock()
top_result = topn( 5, read_data( "data.txt" ) )
t_topn = time.clock() - t

t = time.clock()
htop_result = heaptopn( 5, read_data( "data.txt" ) )
t_htopn = time.clock() - t

# correctness checking :
for key in top_result:
    print key, " : ", "        ".join (("%f:%s"%(value,label)) for (value,label) in    top_result[key])
    print key, " : ", "        ".join (("%f:%s"%(value,label)) for (value,label) in htop_result[key])

print
print "Read data :", t_read
print "TopN :     ", t_topn - t_read
print "HeapTopN : ", t_htopn - t_read

for key in top_result:
    assert top_result[key] == htop_result[key]
</code></pre>
<br /><b># 15 </b><br /><p>Well , please grab <span style="background-color:yellow;">a</span> coffee <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">read</span> the source code for strtod -- it 's mindboggling , but needed , if you want to float -&gt ; text -&gt ; float to give back the same float you started with.... <span style="background-color:yellow;">really..</span> . </p>
<p>Parsing <span style="background-color:yellow;">integers</span> is <span style="background-color:yellow;">a</span> lot faster ( not so much in python , though , but in C , yes ) . </p>
<p><span style="background-color:yellow;">Anyway</span> , putting the data in <span style="background-color:yellow;">a</span> Postgres table : </p>
<pre><code>SELECT count( key ) FROM the dataset in the above program
</code></pre>
<p>= &gt ; 7 s ( so it takes 7 s to <span style="background-color:yellow;">read</span> the 27M <span style="background-color:yellow;">records</span> ) </p>
<pre><code>CREATE INDEX topn_key_value ON topn( key, value );
</code></pre>
<p>191 s </p>
<pre><code>CREATE TEMPORARY TABLE topkeys AS SELECT key FROM topn GROUP BY key;
</code></pre>
<p>12 s </p>
<p>( You can use the index to get distinct values of 'key ' faster too but it <span style="background-color:yellow;">requires</span> some light plpgsql hacking ) </p>
<pre><code>CREATE TEMPORARY TABLE top AS SELECT (r).* FROM (SELECT (SELECT b AS r FROM topn b WHERE b.key=a.key ORDER BY value DESC LIMIT 1) AS r FROM topkeys a) foo;
</code></pre>
<p>Temps : 15,310 ms </p>
<pre><code>INSERT INTO top SELECT (r).* FROM (SELECT (SELECT b AS r FROM topn b WHERE b.key=a.key ORDER BY value DESC LIMIT 1 OFFSET 1) AS r FROM topkeys a) foo;
</code></pre>
<p>Temps : 17,853 ms </p>
<pre><code>INSERT INTO top SELECT (r).* FROM (SELECT (SELECT b AS r FROM topn b WHERE b.key=a.key ORDER BY value DESC LIMIT 1 OFFSET 2) AS r FROM topkeys a) foo;
</code></pre>
<p>Temps : 13,983 ms </p>
<pre><code>INSERT INTO top SELECT (r).* FROM (SELECT (SELECT b AS r FROM topn b WHERE b.key=a.key ORDER BY value DESC LIMIT 1 OFFSET 3) AS r FROM topkeys a) foo;
</code></pre>
<p>Temps : 16,860 ms </p>
<pre><code>INSERT INTO top SELECT (r).* FROM (SELECT (SELECT b AS r FROM topn b WHERE b.key=a.key ORDER BY value DESC LIMIT 1 OFFSET 4) AS r FROM topkeys a) foo;
</code></pre>
<p>Temps : 17,651 ms </p>
<pre><code>INSERT INTO top SELECT (r).* FROM (SELECT (SELECT b AS r FROM topn b WHERE b.key=a.key ORDER BY value DESC LIMIT 1 OFFSET 5) AS r FROM topkeys a) foo;
</code></pre>
<p>Temps : 19,216 ms </p>
<pre><code>SELECT * FROM top ORDER BY key,value;
</code></pre>
<p><span style="background-color:yellow;">As</span> you can see computing the <span style="background-color:yellow;">top-n</span> is extremely fast ( provided n is small ) but creating the ( mandatory ) index is extremely slow because it involves <span style="background-color:yellow;">a</span> full sort . </p>
<p>Your best bet is to use <span style="background-color:yellow;">a</span> format that is fast to parse ( either binary , or write <span style="background-color:yellow;">a</span> custom C <span style="background-color:yellow;">aggregate</span> for your database , which would be the best choice IMHO ) . The <span style="background-color:yellow;">runtime</span> in the C program should n't be more than 1s if python can do it in 1 s . </p>
<br /><b># 16 </b><br /><p>I love lunch break challenges. Here 's <span style="background-color:yellow;">a</span> 1 hour implementation . </p>
<p>OK , when you do n't want do some extremely exotic crap like <span style="background-color:yellow;">additions</span> , nothing stops you from using <span style="background-color:yellow;">a</span> custom base-10 floating point format whose only implemented operator is comparison , <span style="background-color:yellow;">right</span> ? lol . </p>
<p>I had some fast-atoi code lying <span style="background-color:yellow;">around</span> from <span style="background-color:yellow;">a</span> previous project , so I just imported that . </p>
<p>http : //www.copypastecode.com/11541/ </p>
<p>This C source code takes <span style="background-color:yellow;">about</span> 6.6 seconds to parse the 580MB of input text ( 27 million lines ) , half of that <span style="background-color:yellow;">time</span> is fgets , lol. Then it takes <span style="background-color:yellow;">approximately</span> 0.05 seconds to compute the <span style="background-color:yellow;">top-n</span> , but I do n't know for sure , since the <span style="background-color:yellow;">time</span> it takes for the <span style="background-color:yellow;">top-n</span> is less than the <span style="background-color:yellow;">timer</span> noise . </p>
<p>You 'll be the one to test it for correctness though XDDDDDDDDDDD </p>
<p>Interesting huh ? </p>
<br /><b># 17 </b><br /><p>Pick " <span style="background-color:yellow;">top</span> 5 " would look something like this. Note that there 's no sorting. Nor does <span style="background-color:yellow;">any</span> <span style="background-color:yellow;">list</span> in the <span style="background-color:yellow;">top_5</span> dictionary ever grow beyond 5 elements . </p>
<pre><code>from collections import defaultdict
import sys

def keep_5( aList, aPair ):
    minbb= min( bb for bb,cc in aList )
    bb, cc = aPair
    if bb < minbb: return aList
    aList.append( aPair )
    min_i= 0
    for i in xrange(1,6):
        if aList[i][0] < aList[min_i][0]
            min_i= i
    aList.pop(min_i)
    return aList


top_5= defaultdict(list)
for row in sys.stdin:
    aa, bb, cc = row.split()
    bb = float(bb)
    if len(top_5[aa]) < 5:
        top_5[aa].append( (bb,cc) )
    else:
        top_5[aa]= keep_5( top_5[aa], (bb,cc) )
</code></pre>
<br />