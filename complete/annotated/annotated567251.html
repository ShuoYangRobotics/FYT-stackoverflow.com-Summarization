<h3>Question ( ID-567251 ) : </h3><h2>What <span style="background-color:yellow;">are</span> the important language <span style="background-color:yellow;">features</span> ( idioms ) of Python to learn early on </h2><p>I would be interested in knowing what the StackOverflow <span style="background-color:yellow;">community</span> thinks <span style="background-color:yellow;">are</span> the important language <span style="background-color:yellow;">features</span> ( idioms ) of Python. Features that would define <span style="background-color:yellow;">a</span> programmer <span style="background-color:yellow;">as</span> Pythonic . </p>
<p>Python ( pythonic ) idiom - " <span style="background-color:yellow;">code</span> expression " that is <span style="background-color:yellow;">natural</span> or <span style="background-color:yellow;">characteristic</span> to the language Python . </p>
<p>Plus , Which idioms should <span style="background-color:yellow;">all</span> Python programmers learn early on ? </p>
<p>Thanks in <span style="background-color:yellow;">advance</span> </p>
<p>Related : </p>
<ul>Code Like <span style="background-color:yellow;">a</span> Pythonista : Idiomatic Python Python : Am I <span style="background-color:yellow;">missing</span> something ? </ul>
<br /><h3>Answers ( Total-13 ) : </h3><b># <span style="background-color:yellow;">0</span> </b><br /><p>Python is <span style="background-color:yellow;">a</span> language that <span style="background-color:yellow;">can</span> be described <span style="background-color:yellow;">as</span> : </p>
<blockquote>" rules you <span style="background-color:yellow;">can</span> <span style="background-color:yellow;">fit</span> in the palm of your hand with <span style="background-color:yellow;">a</span> huge bag of hooks " . </blockquote>
<p>Nearly everything in python <span style="background-color:yellow;">follows</span> the same simple standards. Everything is <span style="background-color:yellow;">accessible</span> , <span style="background-color:yellow;">changeable</span> , <span style="background-color:yellow;">and</span> tweakable. There <span style="background-color:yellow;">are</span> very <span style="background-color:yellow;">few</span> language level elements . </p>
<p>Take <span style="background-color:yellow;">for</span> example , the len ( data ) builtin <span style="background-color:yellow;">function.</span> len ( data ) works by simply <span style="background-color:yellow;">checking</span> <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">a</span> data.__len__ ( ) <span style="background-color:yellow;">method</span> , <span style="background-color:yellow;">and</span> then <span style="background-color:yellow;">calls</span> it <span style="background-color:yellow;">and</span> returns the value. That way , len ( ) <span style="background-color:yellow;">can</span> work on <span style="background-color:yellow;">any</span> object that implements <span style="background-color:yellow;">a</span> __len__ ( ) <span style="background-color:yellow;">method</span> . </p>
<p></p>
<p>Start by learning <span style="background-color:yellow;">about</span> the types <span style="background-color:yellow;">and</span> basic syntax : </p>
<ol>Dynamic Strongly Typed Languages bool , int , <span style="background-color:yellow;">float</span> , string , list , tuple , dict , set statements , indenting , " everything is <span style="background-color:yellow;">an</span> object " basic <span style="background-color:yellow;">function</span> definitions </ol>
<p>Then <span style="background-color:yellow;">move</span> on to learning <span style="background-color:yellow;">about</span> how python works : </p>
<ol>imports <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">modules</span> ( really simple ) the python path ( sys.path ) the dir ( ) <span style="background-color:yellow;">function</span> __builtins__ </ol>
<p>Once you have <span style="background-color:yellow;">an</span> understanding of how to <span style="background-color:yellow;">fit</span> pieces together , go back <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">cover</span> some of the <span style="background-color:yellow;">more</span> <span style="background-color:yellow;">advanced</span> language <span style="background-color:yellow;">features</span> : </p>
<ol>iterators overrides like __len__ ( there <span style="background-color:yellow;">are</span> tons of these ) list <span style="background-color:yellow;">comprehensions</span> <span style="background-color:yellow;">and</span> generators <span style="background-color:yellow;">classes</span> <span style="background-color:yellow;">and</span> objects ( <span style="background-color:yellow;">again</span> , really simple once you know <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">couple</span> rules ) python inheritance rules </ol>
<p>And once you have <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">comfort</span> level with these items ( with <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">focus</span> on what <span style="background-color:yellow;">makes</span> them pythonic ) , look <span style="background-color:yellow;">at</span> <span style="background-color:yellow;">more</span> specific items : </p>
<ol>Threading in python ( <span style="background-color:yellow;">note</span> the Global Interpreter Lock ) <span style="background-color:yellow;">context</span> <span style="background-color:yellow;">managers</span> database <span style="background-color:yellow;">access</span> <span style="background-color:yellow;">file</span> IO sockets etc.. . </ol>
<p></p>
<p>And <span style="background-color:yellow;">never</span> <span style="background-color:yellow;">forget</span> The Zen of Python ( by Tim Peters ) </p>
<pre><code>Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
</code></pre>
<br /><b># <span style="background-color:yellow;">1</span> </b><br /><p>This page <span style="background-color:yellow;">covers</span> <span style="background-color:yellow;">all</span> the <span style="background-color:yellow;">major</span> python idioms : http : //python.net/ ~ goodger/projects/pycon/2007/idiomatic/handout.html </p>
<br /><b># <span style="background-color:yellow;">2</span> </b><br /><p>Decorators get <span style="background-color:yellow;">my</span> vote. Where else <span style="background-color:yellow;">can</span> you write something like : </p>
<pre><code>def trace(num_args=0):
  def wrapper(func):
    def new_f(*a,**k):
      print_args = ''
      if num_args > 0:
        print_args = str.join(',', [str(x) for x in a[0:num_args]])
      print('entering %s(%s)' %(f.__name__,print_args))
      rc = f(*a,**k)
      if rc is not None:
        print('exiting %s(%s)=%s' %(f.__name__,str(rc)))
      else:
        print('exiting %s(%s)' %(f.__name__))
      return rc
    return new_f
  return wrapper

@trace(1)
def factorial(n):
  if n < 2:
    return 1
  return n * factorial(n-1)
factorial(5)
</code></pre>
<p><span style="background-color:yellow;">and</span> get output like : </p>
<pre><code>entering factorial(5)
entering factorial(4)
entering factorial(3)
entering factorial(2)
entering factorial(1)
entering factorial(0)
exiting factorial(0)=1
exiting factorial(1)=1
exiting factorial(2)=2
exiting factorial(3)=6
exiting factorial(4)=24
exiting factorial(5)=120
</code></pre>
<br /><b># <span style="background-color:yellow;">3</span> </b><br /><p>An important idiom in Python is docstrings . </p>
<p>Every object has <span style="background-color:yellow;">a</span> __doc__ <span style="background-color:yellow;">attribute</span> that <span style="background-color:yellow;">can</span> be used to get help on that object. You <span style="background-color:yellow;">can</span> set the __doc__ <span style="background-color:yellow;">attribute</span> on <span style="background-color:yellow;">modules</span> , <span style="background-color:yellow;">classes</span> , <span style="background-color:yellow;">methods</span> , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">functions</span> like this : </p>
<pre><code># this is m.py
""" module docstring """

class c:
    """class docstring"""
    def m(self):
        """method docstring"""
        pass

def f(a):
    """function f docstring"""
    return
</code></pre>
<p>Now , when you type help ( <span style="background-color:yellow;">m</span> ) , help ( <span style="background-color:yellow;">m.f</span> ) etc. it will print the docstring <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> help <span style="background-color:yellow;">message</span> . </p>
<p>Because it 's just part of <span style="background-color:yellow;">normal</span> object introspection this <span style="background-color:yellow;">can</span> be used by documention generating systems like epydoc or used <span style="background-color:yellow;">for</span> testing purposes by unittest . </p>
<p>It <span style="background-color:yellow;">can</span> <span style="background-color:yellow;">also</span> be put to <span style="background-color:yellow;">more</span> unconventional ( i.e. <span style="background-color:yellow;">non-idiomatic</span> ) uses such <span style="background-color:yellow;">as</span> grammars in Dparser . </p>
<p>Where it gets even <span style="background-color:yellow;">more</span> interesting to <span style="background-color:yellow;">me</span> is that , even though doc is <span style="background-color:yellow;">a</span> read-only <span style="background-color:yellow;">attribute</span> on <span style="background-color:yellow;">most</span> objects , you <span style="background-color:yellow;">can</span> use them <span style="background-color:yellow;">anywhere</span> like this : </p>
<pre><code>x = 5
""" pseudo docstring for x """
</code></pre>
<p><span style="background-color:yellow;">and</span> documentation tools like epydoc <span style="background-color:yellow;">can</span> pick them up <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">format</span> them properly ( <span style="background-color:yellow;">as</span> opposed to <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">normal</span> <span style="background-color:yellow;">comment</span> which stays inside the <span style="background-color:yellow;">code</span> <span style="background-color:yellow;">formatting</span> . </p>
<br /><b># <span style="background-color:yellow;">4</span> </b><br /><p>Everything <span style="background-color:yellow;">connected</span> to list usage . Comprehensions , generators , etc . </p>
<br /><b># <span style="background-color:yellow;">5</span> </b><br /><p>Here 's one that <span style="background-color:yellow;">can</span> help. What 's the difference between : </p>
<pre><code>[ foo(x) for x in range(0, 5) ][0]
</code></pre>
<p><span style="background-color:yellow;">and</span> </p>
<pre><code>( foo(x) for x in range(0, 5) ).next()
</code></pre>
<p><span style="background-color:yellow;">answer</span> : in the second example , <span style="background-color:yellow;">foo</span> is <span style="background-color:yellow;">called</span> only once. This <span style="background-color:yellow;">may</span> be important if <span style="background-color:yellow;">foo</span> has <span style="background-color:yellow;">a</span> side effect , or if the iterable being used to <span style="background-color:yellow;">construct</span> the list is large . </p>
<br /><b># 6 </b><br /><p>Two things that struck <span style="background-color:yellow;">me</span> <span style="background-color:yellow;">as</span> especially Pythonic were dynamic typing <span style="background-color:yellow;">and</span> the various <span style="background-color:yellow;">flavors</span> of lists used in Python , particularly tuples . </p>
<p>Python 's list obsession <span style="background-color:yellow;">could</span> be said to be LISP-y , but it 's got its own unique <span style="background-color:yellow;">flavor.</span> A line like : </p>
<pre><code>return HandEvaluator.StraightFlush, (PokerCard.longFaces[index + 4], 
  PokerCard.longSuits[flushSuit]), []
</code></pre>
<p>or even </p>
<pre><code>return False, False, False
</code></pre>
<p>just looks like Python <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">nothing</span> else. ( Technically , you 'd see the latter in Lua <span style="background-color:yellow;">as</span> well , but Lua is pretty Pythonic in general. ) </p>
<br /><b># 7 </b><br /><p>From <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">more</span> <span style="background-color:yellow;">advanced</span> viewpoint , understanding how dictionaries <span style="background-color:yellow;">are</span> used internally by Python. Classes , <span style="background-color:yellow;">functions</span> , <span style="background-color:yellow;">modules</span> , references <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">all</span> just properties on <span style="background-color:yellow;">a</span> dictionary. Once this is understood it 's easy to understand how to <span style="background-color:yellow;">monkey</span> patch <span style="background-color:yellow;">and</span> use the powerful __gettattr__ , __setattr__ , <span style="background-color:yellow;">and</span> __call__ <span style="background-color:yellow;">methods</span> . </p>
<br /><b># 8 </b><br /><p>In <span style="background-color:yellow;">addition</span> to CTT 's link , I have <span style="background-color:yellow;">another</span> good one in <span style="background-color:yellow;">my</span> bookmarks : </p>
<p>http : //jaynes.colorado.edu/PythonIdioms.html </p>
<br /><b># 9 </b><br /><p>Using string substitutions : </p>
<pre><code>name = "Joe"
age = 12
print "My name is %s, I am %s" % (name, age)
</code></pre>
<p>When I 'm <span style="background-color:yellow;">not</span> programming in python , that simple use is what I <span style="background-color:yellow;">miss</span> <span style="background-color:yellow;">most</span> . </p>
<br /><b># <span style="background-color:yellow;">10</span> </b><br /><p>Personally , I really like Python syntax defining <span style="background-color:yellow;">code</span> blocks by using indentation , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">not</span> by the words " BEGIN " <span style="background-color:yellow;">and</span> " END " ( <span style="background-color:yellow;">as</span> in Microsoft 's Basic <span style="background-color:yellow;">and</span> Visual Basic - I do <span style="background-color:yellow;">n't</span> like these ) or by using left- <span style="background-color:yellow;">and</span> right-braces ( <span style="background-color:yellow;">as</span> in C , C + + , Java , Perl - I like these ) . </p>
<p>This really surprised <span style="background-color:yellow;">me</span> because , <span style="background-color:yellow;">although</span> indentation has <span style="background-color:yellow;">always</span> been very important to <span style="background-color:yellow;">me</span> , I did <span style="background-color:yellow;">n't</span> <span style="background-color:yellow;">make</span> to <span style="background-color:yellow;">much</span> " <span style="background-color:yellow;">noise</span> " <span style="background-color:yellow;">about</span> it - I lived with it , <span style="background-color:yellow;">and</span> it is <span style="background-color:yellow;">considered</span> <span style="background-color:yellow;">a</span> skill to be <span style="background-color:yellow;">able</span> to read other peoples , " spaghetti " <span style="background-color:yellow;">code.</span> Furthermore , I <span style="background-color:yellow;">never</span> heard <span style="background-color:yellow;">another</span> programmer suggest <span style="background-color:yellow;">making</span> indentation <span style="background-color:yellow;">a</span> part of <span style="background-color:yellow;">a</span> language. Until Python ! I only wish I had realized this idea <span style="background-color:yellow;">first</span> . </p>
<p>To <span style="background-color:yellow;">me</span> , it is <span style="background-color:yellow;">as</span> if Python 's syntax <span style="background-color:yellow;">forces</span> you to write good , readable <span style="background-color:yellow;">code</span> . </p>
<p>Okay , I 'll get off <span style="background-color:yellow;">my</span> soap-box. ; - ) </p>
<br /><b># <span style="background-color:yellow;">11</span> </b><br /><p>listening <span style="background-color:yellow;">comprehension</span> </p>
<br /><b># <span style="background-color:yellow;">12</span> </b><br /><p>Another thing you <span style="background-color:yellow;">can</span> <span style="background-color:yellow;">not</span> start early enough is probably testing. Here especially doctests <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">a</span> great way of testing your <span style="background-color:yellow;">code</span> by explaining it <span style="background-color:yellow;">at</span> the same time . </p>
<p>doctests <span style="background-color:yellow;">are</span> simple text <span style="background-color:yellow;">file</span> <span style="background-color:yellow;">containing</span> <span style="background-color:yellow;">an</span> interactive interpreter session plus text like this : </p>
<pre><code>Let's instantiate our class::

>>> a=Something(text="yes")
>>> a.text
yes

Now call this method and check the results::

>>> a.canify()
>>> a.text
yes, I can
</code></pre>
<p>If e.g. <span style="background-color:yellow;">a.text</span> returns something different the test will <span style="background-color:yellow;">fail</span> . </p>
<p>doctests <span style="background-color:yellow;">can</span> be inside docstrings or standalone textfiles <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">are</span> executed by using the doctests <span style="background-color:yellow;">module</span> . Of <span style="background-color:yellow;">course</span> the <span style="background-color:yellow;">more</span> known unit tests <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">also</span> <span style="background-color:yellow;">available</span> . </p>
<br />