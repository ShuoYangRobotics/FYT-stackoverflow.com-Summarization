<h3>Question ( ID-1269795 ) : </h3><h2>Unusual Speed Difference between Python and C + + </h2><p>I recently wrote a <span style="background-color:yellow;">short</span> algorithm to calculate <span style="background-color:yellow;">happy</span> <span style="background-color:yellow;">numbers</span> <span style="background-color:yellow;">in</span> python. The program allows you to pick an upper bound and <span style="background-color:yellow;">it</span> will determine all the <span style="background-color:yellow;">happy</span> <span style="background-color:yellow;">numbers</span> below <span style="background-color:yellow;">it.</span> For a <span style="background-color:yellow;">speed</span> comparison I decided to make the most direct translation of the algorithm I knew of from python to c + + . </p>
<p>Surprisingly , the c + + version runs <span style="background-color:yellow;">significantly</span> <span style="background-color:yellow;">slower</span> than the python version. Accurate <span style="background-color:yellow;">speed</span> tests between the execution <span style="background-color:yellow;">times</span> for discovering the first <span style="background-color:yellow;">10,000</span> <span style="background-color:yellow;">happy</span> <span style="background-color:yellow;">numbers</span> <span style="background-color:yellow;">indicate</span> the python program runs on average <span style="background-color:yellow;">in</span> 0.59 <span style="background-color:yellow;">seconds</span> and the c + + version runs on average <span style="background-color:yellow;">in</span> 8.5 <span style="background-color:yellow;">seconds</span> . </p>
<p>I would attribute this <span style="background-color:yellow;">speed</span> difference to the fact that I had to write helper functions for parts of the calculations ( for example determining <span style="background-color:yellow;">if</span> an element <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">in</span> a list/array/vector ) <span style="background-color:yellow;">in</span> the c + + version which were already built <span style="background-color:yellow;">in</span> to the python language . </p>
<p>Firstly , <span style="background-color:yellow;">is</span> this the <span style="background-color:yellow;">true</span> reason for <span style="background-color:yellow;">such</span> an absurd <span style="background-color:yellow;">speed</span> difference , and <span style="background-color:yellow;">secondly</span> , how can I change the c + + version to execute more quickly than the python version ( the way <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">should</span> be <span style="background-color:yellow;">in</span> my opinion ) . </p>
<p>The two pieces of code , with <span style="background-color:yellow;">speed</span> testing are here : Python Version , C + + Version . Thanks for the help . </p>
<pre><code>#include <iostream>
#include <vector>
#include <string>
#include <ctime>
#include <windows.h>

using namespace std;

bool inVector(int inQuestion, vector<int> known);
int sum(vector<int> given);
int pow(int given, int power);
void calcMain(int upperBound);

int main()
{
    while(true)
    {
    	int upperBound;
    	cout << "Pick an upper bound: ";
    	cin >> upperBound;
    	long start, end;
    	start = GetTickCount();
    	calcMain(upperBound);
    	end = GetTickCount();
    	double seconds = (double)(end-start) / 1000.0;
    	cout << seconds << " seconds." << endl << endl;
    }
    return 0;
}

void calcMain(int upperBound)
{
    vector<int> known;
    for(int i = 0; i <= upperBound; i++)
    {
    	bool next = false;
    	int current = i;
    	vector<int> history;
    	while(!next)
    	{
    		char* buffer = new char[10];
    		itoa(current, buffer, 10);
    		string digits = buffer;
    		delete buffer;
    		vector<int> squares;
    		for(int j = 0; j < digits.size(); j++)
    		{
    			char charDigit = digits[j];
    			int digit = atoi(&charDigit);
    			int square = pow(digit, 2);
    			squares.push_back(square);
    		}
    		int squaresum = sum(squares);
    		current = squaresum;
    		if(inVector(current, history))
    		{
    			next = true;
    			if(current == 1)
    			{
    				known.push_back(i);
    				//cout << i << "\t";
    			}
    		}
    		history.push_back(current);
    	}
    }
    //cout << "\n\n";
}

bool inVector(int inQuestion, vector<int> known)
{
    for(vector<int>::iterator it = known.begin(); it != known.end(); it++)
    	if(*it == inQuestion)
    		return true;
    return false;
}

int sum(vector<int> given)
{
    int sum = 0;
    for(vector<int>::iterator it = given.begin(); it != given.end(); it++)
    	sum += *it;
    return sum;
}

int pow(int given, int power)
{
    int original = given;
    int current = given;
    for(int i = 0; i < power-1; i++)
    	current *= original;
    return current;
}
</code></pre>
<p></p>
<pre><code>#!/usr/bin/env python

import timeit

upperBound = 0

def calcMain():
    known = []
    for i in range(0,upperBound+1):
        next = False
        current = i
        history = []
        while not next:
            digits = str(current)
            squares = [pow(int(digit), 2) for digit in digits]
            squaresum = sum(squares)
            current = squaresum
            if current in history:
                next = True
                if current == 1:
                    known.append(i)
                    ##print i, "\t",
            history.append(current)
    ##print "\nend"

while True:    
    upperBound = input("Pick an upper bound: ")
    result = timeit.Timer(calcMain).timeit(1)
    print result, "seconds.\n"
</code></pre>
<br /><h3>Answers ( Total-16 ) : </h3><b># 0 </b><br /><p>For <span style="background-color:yellow;">100000</span> elements , the Python code took 6.9 <span style="background-color:yellow;">seconds</span> while the C + + originally took above 37 <span style="background-color:yellow;">seconds</span> . </p>
<p>I did <span style="background-color:yellow;">some</span> basic optimizations on your code and managed to get the C + + code above <span style="background-color:yellow;">100</span> <span style="background-color:yellow;">times</span> faster than the Python <span style="background-color:yellow;">implementation.</span> It now does <span style="background-color:yellow;">100000</span> elements <span style="background-color:yellow;">in</span> 0.06 <span style="background-color:yellow;">seconds.</span> That <span style="background-color:yellow;">is</span> 617 faster than the original C + + code . </p>
<p>The most <span style="background-color:yellow;">important</span> thing <span style="background-color:yellow;">is</span> to compile <span style="background-color:yellow;">in</span> Release mode , with all optimizations. This code <span style="background-color:yellow;">is</span> literally orders of magnitude <span style="background-color:yellow;">slower</span> <span style="background-color:yellow;">in</span> Debug mode . </p>
<p>Next , I will explain the optimizations I did . </p>
<ul>Moved all vector declarations outside of the loop ; replaced them by a clear ( ) operation , which <span style="background-color:yellow;">is</span> much faster than calling the constructor . Replaced the call to pow ( value , 2 ) by a multiplication : value * value . Instead of having a <span style="background-color:yellow;">squares</span> vector and calling <span style="background-color:yellow;">sum</span> on <span style="background-color:yellow;">it</span> , I <span style="background-color:yellow;">sum</span> the values <span style="background-color:yellow;">in-place</span> using just an <span style="background-color:yellow;">integer</span> . Avoided all <span style="background-color:yellow;">string</span> operations , which are very <span style="background-color:yellow;">slow</span> compared to <span style="background-color:yellow;">integer</span> operations. For <span style="background-color:yellow;">instance</span> , <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">is</span> possible to compute the <span style="background-color:yellow;">squares</span> of each digit by repeatedly dividing by <span style="background-color:yellow;">10</span> and fetching the modulus <span style="background-color:yellow;">10</span> of the resulting value , <span style="background-color:yellow;">instead</span> of converting the value to a <span style="background-color:yellow;">string</span> and then each character back to <span style="background-color:yellow;">int</span> . Avoided all vector copies , first by replacing passing by value with passing by reference , and finally by eliminating the helper functions completely . Eliminated a few temporary variables . And probably many <span style="background-color:yellow;">small</span> details I forgot. Compare your code and mine <span style="background-color:yellow;">side-by-side</span> to <span style="background-color:yellow;">see</span> exactly what I did . </ul>
<p>It may be possible to optimize the code even more by using pre-allocated arrays <span style="background-color:yellow;">instead</span> of vectors , but this would be a bit more work and I 'll leave <span style="background-color:yellow;">it</span> as an exercise to the reader. : P </p>
<p>Here 's the optimized code : </p>
<pre><code>#include <iostream>
#include <vector>
#include <string>
#include <ctime>
#include <algorithm>
#include <windows.h>

using namespace std;

void calcMain(int upperBound, vector<int>& known);

int main()
{
    while(true)
    {
        vector<int> results;
        int upperBound;
        cout << "Pick an upper bound: ";
        cin >> upperBound;
        long start, end;
        start = GetTickCount();
        calcMain(upperBound, results);
        end = GetTickCount();
        for (size_t i = 0; i < results.size(); ++i) {
            cout << results[i] << ", ";
        }
        cout << endl;
        double seconds = (double)(end-start) / 1000.0;
        cout << seconds << " seconds." << endl << endl;
    }
    return 0;
}

void calcMain(int upperBound, vector<int>& known)
{
    vector<int> history;
    for(int i = 0; i <= upperBound; i++)
    {
        int current = i;
        history.clear();
        while(true)
        {
                int temp = current;
                int sum = 0;
                while (temp > 0) {
                    sum += (temp % 10) * (temp % 10);
                    temp /= 10;
                }
                current = sum;
                if(find(history.begin(), history.end(), current) != history.end())
                {
                        if(current == 1)
                        {
                                known.push_back(i);
                        }
                        break;
                }
                history.push_back(current);
        }
    }
}
</code></pre>
<br /><b># <span style="background-color:yellow;">1</span> </b><br /><p>There 's a new , radically faster version as a <span style="background-color:yellow;">separate</span> answer , <span style="background-color:yellow;">so</span> this answer <span style="background-color:yellow;">is</span> deprecated . </p>
<p></p>
<p>I rewrote your algorithm making <span style="background-color:yellow;">it</span> cache whenever <span style="background-color:yellow;">it</span> finds the <span style="background-color:yellow;">number</span> to be <span style="background-color:yellow;">happy</span> or unhappy. I also tried to make <span style="background-color:yellow;">it</span> as pythonic as I could , for example by creating <span style="background-color:yellow;">separate</span> functions <span style="background-color:yellow;">digits</span> ( ) and <span style="background-color:yellow;">happy</span> ( ) . Sorry for using Python 3 , but I get to <span style="background-color:yellow;">show</span> off a couple a useful things from <span style="background-color:yellow;">it</span> as well . </p>
<p>This version <span style="background-color:yellow;">is</span> much faster , though <span style="background-color:yellow;">since</span> I 'm <span style="background-color:yellow;">in</span> the middle of doing <span style="background-color:yellow;">some</span> other work and my MacBook <span style="background-color:yellow;">is</span> busy , I did n't do exact measures. It runs at <span style="background-color:yellow;">1.7s</span> which <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">10</span> <span style="background-color:yellow;">times</span> faster than your original program that takes <span style="background-color:yellow;">18s</span> ( well , my MacBook <span style="background-color:yellow;">is</span> quite old and <span style="background-color:yellow;">slow</span> : ) ) </p>
<p>( FYI , I 've been rewriting this thing for a while and this <span style="background-color:yellow;">is</span> like the 5th version : ) ) </p>
<pre><code>#!/usr/bin/env python3

from timeit import Timer
from itertools import count

print_numbers = False
upperBound = 10**5  # Default value, can be overidden by user.


def digits(x:'nonnegative number') -> "yields number's digits":
    if not (x >= 0): raise ValueError('Number should be nonnegative')
    while x:
        yield x % 10
        x //= 10


def happy(number, known = {1}, happies = {1}) -> 'True/None':
    '''This function tells if the number is happy or not, caching results.

    It uses two static variables, parameters known and happies; the
    first one contains known happy and unhappy numbers; the second 
    contains only happy ones.

    If you want, you can pass your own known and happies arguments. If
    you do, you should keep the assumption commented out on the 1 line.

    '''

#        assert 1 in known and happies <= known  # <= is expensive

    if number in known:
        return number in happies

    history = set()
    while True:
        history.add(number)
        number = sum(x**2 for x in digits(number))
        if number in known or number in history:
            break

    known.update(history)
    if number in happies:
        happies.update(history)
        return True


def calcMain():
    happies = {x for x in range(upperBound) if happy(x) }
    if print_numbers:
        print(happies)


if __name__ == '__main__':
    upperBound = eval(
            input("Pick an upper bound [default {0}]: "
                    .format(upperBound)).strip()
            or repr(upperBound))
    result = Timer(calcMain).timeit(1)
    print ('This computation took {0} seconds'.format(result))
</code></pre>
<br /><b># 2 </b><br /><p>It looks like you 're passing vectors by value to other functions. This will be a <span style="background-color:yellow;">significant</span> <span style="background-color:yellow;">slowdown</span> because the program will actually make a full copy of your vector before <span style="background-color:yellow;">it</span> passes <span style="background-color:yellow;">it</span> to your function. To get around this , pass a constant reference to the vector <span style="background-color:yellow;">instead</span> of a copy. So <span style="background-color:yellow;">instead</span> of : </p>
<pre><code>int sum(vector<int> given)</code></pre>
<p>Use : </p>
<pre><code>int sum(const vector<int>& given)</code></pre>
<p>When you do this , you 'll no longer be able to use the vector : : <span style="background-color:yellow;">iterator</span> because <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">is</span> not constant. You 'll need to replace <span style="background-color:yellow;">it</span> with vector : : const_iterator . </p>
<p>You can also pass <span style="background-color:yellow;">in</span> non-constant references , but <span style="background-color:yellow;">in</span> this case , you do n't need to modify the parameter at all . </p>
<br /><b># 3 </b><br /><p>I can <span style="background-color:yellow;">see</span> that you have quite a few heap allocations that are unnecessary </p>
<p>For example : </p>
<pre><code>while(!next)
    	{
    		char* buffer = new char[10];
</code></pre>
<p>This does n't look very optimized. So , you probably want to have the array pre-allocated and using <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">inside</span> your loop. This <span style="background-color:yellow;">is</span> a basic optimizing technique which <span style="background-color:yellow;">is</span> easy to <span style="background-color:yellow;">spot</span> and to do. It might become <span style="background-color:yellow;">into</span> a mess too , <span style="background-color:yellow;">so</span> be careful with that . </p>
<p>You are also using the atoi ( ) function , which I do n't really know <span style="background-color:yellow;">if</span> <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">is</span> really optimized. Maybe doing a modulus <span style="background-color:yellow;">10</span> and getting the digit might be better ( you have to measure thou , I did n't test this ) . </p>
<p>The fact that you have a linear <span style="background-color:yellow;">search</span> ( <span style="background-color:yellow;">inVector</span> ) might be bad. Replacing the vector data <span style="background-color:yellow;">structure</span> with a <span style="background-color:yellow;">std</span> : : <span style="background-color:yellow;">set</span> might <span style="background-color:yellow;">speed</span> things up. A hash_set could do the trick too . </p>
<p>But I think that the worst problem <span style="background-color:yellow;">is</span> the <span style="background-color:yellow;">string</span> and this allocation of <span style="background-color:yellow;">stuff</span> on the heap <span style="background-color:yellow;">inside</span> that loop. That does n't look good. I would try at those places first . </p>
<br /><b># 4 </b><br /><p>This <span style="background-color:yellow;">is</span> my <span style="background-color:yellow;">second</span> answer ; which caches things like <span style="background-color:yellow;">sum</span> of <span style="background-color:yellow;">squares</span> for values &lt ; = <span style="background-color:yellow;">10</span> * * 6 : </p>
<pre><code>        happy_list[sq_list[x%happy_base] + sq_list[x//happy_base]]
</code></pre>
<p>That <span style="background-color:yellow;">is,</span> </p>
<ul>the <span style="background-color:yellow;">number</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">split</span> <span style="background-color:yellow;">into</span> 3 <span style="background-color:yellow;">digits</span> + 3 <span style="background-color:yellow;">digits</span> the precomputed table <span style="background-color:yellow;">is</span> used to get <span style="background-color:yellow;">sum</span> of <span style="background-color:yellow;">squares</span> for both parts these two results are added the precomputed table <span style="background-color:yellow;">is</span> consulted to get the happiness of <span style="background-color:yellow;">number</span> : </ul>
<p>I do n't think Python version can be made much faster than that ( ok , <span style="background-color:yellow;">if</span> you throw away fallback to old version , that <span style="background-color:yellow;">is</span> try : overhead , <span style="background-color:yellow;">it</span> 's <span style="background-color:yellow;">10</span> % faster ) . </p>
<p>I think this <span style="background-color:yellow;">is</span> an excellent question which <span style="background-color:yellow;">shows</span> that , <span style="background-color:yellow;">indeed,</span> </p>
<ul>things that have to be fast <span style="background-color:yellow;">should</span> be written <span style="background-color:yellow;">in</span> C however , usually you do n't need things to be fast ( even <span style="background-color:yellow;">if</span> you needed the program to run for a day , <span style="background-color:yellow;">it</span> would be less then the combined <span style="background-color:yellow;">time</span> of programmers optimizing <span style="background-color:yellow;">it</span> ) <span style="background-color:yellow;">it</span> 's easier and faster to write programs <span style="background-color:yellow;">in</span> Python but for <span style="background-color:yellow;">some</span> problems , especially computational ones , a C + + <span style="background-color:yellow;">solution</span> , like the ones above , are actually more readable and more beautiful than an attempt to optimize Python program . </ul>
<p></p>
<p>Ok , here <span style="background-color:yellow;">it</span> goes ( 2nd version now... ) : </p>
<pre><code>#!/usr/bin/env python3
'''Provides slower and faster versions of a function to compute happy numbers.

slow_happy() implements the algorithm as in the definition of happy
numbers (but also caches the results).

happy() uses the precomputed lists of sums of squares and happy numbers
to return result in just 3 list lookups and 3 arithmetic operations for
numbers less than 10**6; it falls back to slow_happy() for big numbers.

Utilities: digits() generator, my_timeit() context manager.

'''


from time import time  # For my_timeit.
from random import randint # For example with random number.

upperBound = 10**5  # Default value, can be overridden by user.


class my_timeit:
    '''Very simple timing context manager.'''

    def __init__(self, message):
        self.message = message
        self.start = time()

    def __enter__(self):
        return self

    def __exit__(self, *data):
        print(self.message.format(time() - self.start))


def digits(x:'nonnegative number') -> "yields number's digits":
    if not (x >= 0): raise ValueError('Number should be nonnegative')
    while x:
        yield x % 10
        x //= 10


def slow_happy(number, known = {1}, happies = {1}) -> 'True/None':
    '''Tell if the number is happy or not, caching results.

    It uses two static variables, parameters known and happies; the
    first one contains known happy and unhappy numbers; the second 
    contains only happy ones.

    If you want, you can pass your own known and happies arguments. If
    you do, you should keep the assumption commented out on the 1 line.

    '''
    # This is commented out because <= is expensive.
    # assert {1} <= happies <= known 

    if number in known:
        return number in happies

    history = set()
    while True:
        history.add(number)
        number = sum(x**2 for x in digits(number))
        if number in known or number in history:
            break

    known.update(history)
    if number in happies:
        happies.update(history)
        return True


# This will define new happy() to be much faster ------------------------.

with my_timeit('Preparation time was {0} seconds.\n'):

    LogAbsoluteUpperBound = 6 # The maximum possible number is 10**this.
    happy_list = [slow_happy(x)
                  for x in range(81*LogAbsoluteUpperBound + 1)]
    happy_base = 10**((LogAbsoluteUpperBound + 1)//2)
    sq_list = [sum(d**2 for d in digits(x))
               for x in range(happy_base + 1)]

    def happy(x):
        '''Tell if the number is happy, optimized for smaller numbers.

        This function works fast for numbers <= 10**LogAbsoluteUpperBound.

        '''
        try:
            return happy_list[sq_list[x%happy_base] + sq_list[x//happy_base]]
        except IndexError:
            return slow_happy(x)

# End of happy()'s redefinition -----------------------------------------.


def calcMain(print_numbers, upper_bound):
    happies = [x for x in range(upper_bound + 1) if happy(x)]
    if print_numbers:
        print(happies)


if __name__ == '__main__':
    while True:

        upperBound = eval(input(
            "Pick an upper bound [{0} default, 0 ends, negative number prints]: "
            .format(upperBound)).strip() or repr(upperBound))
        if not upperBound:
            break

        with my_timeit('This computation took {0} seconds.'):
            calcMain(upperBound < 0, abs(upperBound))

        single = 0
        while not happy(single):
            single = randint(1, 10**12)
        print('FYI, {0} is {1}.\n'.format(single,
                    'happy' if happy(single) else 'unhappy')) 

    print('Nice to see you, goodbye!')
</code></pre>
<br /><b># 5 </b><br /><p>Well , I also gave <span style="background-color:yellow;">it</span> a once-over. I did n't test or even compile , though . </p>
<p>General rules for numerical programs : </p>
<ul>Never process <span style="background-color:yellow;">numbers</span> as text. That 's what makes lesser languages than Python <span style="background-color:yellow;">slow</span> , <span style="background-color:yellow;">so</span> <span style="background-color:yellow;">if</span> you do <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">in</span> C , the program will be <span style="background-color:yellow;">slower</span> than Python . Do n't use data <span style="background-color:yellow;">structures</span> <span style="background-color:yellow;">if</span> you can avoid them. You were building an array just to add the <span style="background-color:yellow;">numbers</span> up. Better keep a running total . Keep a copy of the STL reference open <span style="background-color:yellow;">so</span> you can use <span style="background-color:yellow;">it</span> rather than writing your own functions . </ul>
<p></p>
<pre><code>void calcMain(int upperBound)
{
    vector<int> known;
    for(int i = 0; i <= upperBound; i++)
    {
    	int current = i;
    	vector<int> history;
    	do
    	{
    		squaresum = 0
    		for ( ; current; current /= 10 )
    		{
    			int digit = current % 10;
    			squaresum += digit * digit;
    		}
    		current = squaresum;
    		history.push_back(current);
    	} while ( ! count(history.begin(), history.end() - 1, current) );

    	if(current == 1)
    	{
    		known.push_back(i);
    		//cout << i << "\t";
    	}

    }
    //cout << "\n\n";
}
</code></pre>
<br /><b># 6 </b><br /><p>Just to get a little more closure on this <span style="background-color:yellow;">issue</span> by <span style="background-color:yellow;">seeing</span> how fast I could <span style="background-color:yellow;">truely</span> find these <span style="background-color:yellow;">numbers</span> , I wrote a multithreaded C + + <span style="background-color:yellow;">implementation</span> of Dr_Asik 's algorithm. There are two things that are <span style="background-color:yellow;">important</span> to realize about the fact that this <span style="background-color:yellow;">implementation</span> <span style="background-color:yellow;">is</span> multithreaded . </p>
<ol>More threads does not necessarily lead to better execution <span style="background-color:yellow;">times</span> , there <span style="background-color:yellow;">is</span> a <span style="background-color:yellow;">happy</span> medium for every <span style="background-color:yellow;">situation</span> depending on the volume of <span style="background-color:yellow;">numbers</span> you want to calculate . If you compare the <span style="background-color:yellow;">times</span> between this version running with one thread and the original version , the only factors that could cause a difference <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">time</span> are the overhead from <span style="background-color:yellow;">starting</span> the thread and variable <span style="background-color:yellow;">system</span> performance <span style="background-color:yellow;">issues.</span> Otherwise , the algorithm <span style="background-color:yellow;">is</span> the <span style="background-color:yellow;">same</span> . </ol>
<p>The code for this <span style="background-color:yellow;">implementation</span> ( all credit for the algorithm goes to Dr_Asik ) <span style="background-color:yellow;">is</span> here . Also , I wrote <span style="background-color:yellow;">some</span> <span style="background-color:yellow;">speed</span> tests with a <span style="background-color:yellow;">double</span> check for each test to help back up those 3 points . </p>
<p>Calculation of the first <span style="background-color:yellow;">100,000,000</span> <span style="background-color:yellow;">happy</span> <span style="background-color:yellow;">numbers</span> : </p>
<p>Original - 39.061 / 39.000 ( Dr_Asik 's original <span style="background-color:yellow;">implementation</span> ) <span style="background-color:yellow;">1</span> Thread - 39.000 / 39.079 2 Threads - <span style="background-color:yellow;">19.750</span> / <span style="background-color:yellow;">19.890</span> <span style="background-color:yellow;">10</span> Threads - <span style="background-color:yellow;">11.872</span> / <span style="background-color:yellow;">11.888</span> 30 Threads - <span style="background-color:yellow;">10.764</span> / <span style="background-color:yellow;">10.827</span> 50 Threads - <span style="background-color:yellow;">10.624</span> / <span style="background-color:yellow;">10.561</span> &lt ; -- <span style="background-color:yellow;">100</span> Threads - <span style="background-color:yellow;">11.060</span> / <span style="background-color:yellow;">11.216</span> 500 Threads - <span style="background-color:yellow;">13.385</span> / <span style="background-color:yellow;">12.527</span> </p>
<p>From these results <span style="background-color:yellow;">it</span> looks like our <span style="background-color:yellow;">happy</span> medium <span style="background-color:yellow;">is</span> about 50 threads , plus or minus ten or <span style="background-color:yellow;">so</span> . </p>
<br /><b># 7 </b><br /><p>I am not an expert at C + + optimization , but I believe the <span style="background-color:yellow;">speed</span> difference may be due to the fact that Python lists have preallocated more <span style="background-color:yellow;">space</span> at the beginning while your C + + vectors must reallocate and possibly copy every <span style="background-color:yellow;">time</span> <span style="background-color:yellow;">it</span> grows . </p>
<p>As for GMan 's comment about find , I believe that the Python " <span style="background-color:yellow;">in</span> " operator <span style="background-color:yellow;">is</span> also a linear <span style="background-color:yellow;">search</span> and <span style="background-color:yellow;">is</span> the <span style="background-color:yellow;">same</span> <span style="background-color:yellow;">speed</span> . </p>
<p>Edit </p>
<p>Also I just noticed that you rolled your own pow function. There <span style="background-color:yellow;">is</span> no need to do that and the <span style="background-color:yellow;">stdlib</span> <span style="background-color:yellow;">is</span> likely faster . </p>
<br /><b># 8 </b><br /><p>Here <span style="background-color:yellow;">is</span> another way that relies on memorising all the <span style="background-color:yellow;">numbers</span> already explored . I obtain a factor <span style="background-color:yellow;">x4-5</span> , which <span style="background-color:yellow;">is</span> oddly <span style="background-color:yellow;">stable</span> against DrAsik 's code for <span style="background-color:yellow;">1000</span> and <span style="background-color:yellow;">1000000</span> , I expected the cache to be more efficient the more <span style="background-color:yellow;">numbers</span> we were exploring. Otherwise , the <span style="background-color:yellow;">same</span> kind of classic optimizations have been applied. BTW , <span style="background-color:yellow;">if</span> the compiler accepts NRVO ( /RNVO ? I never remember the exact term ) or rvalue references , we would n't need to pass the vector as an out parameter . </p>
<p>NB : micro-optimizations are <span style="background-color:yellow;">still</span> possible IMHO , and moreover the caching <span style="background-color:yellow;">is</span> naive as <span style="background-color:yellow;">it</span> allocates much more memory than really needed . </p>
<pre><code>enum Status {
    never_seen,
    being_explored,
    happy,
    unhappy
};

char const* toString[] = { "never_seen", "being_explored", "happy", "unhappy" };


inline size_t sum_squares(size_t i) {
    size_t s = 0;
    while (i) {
        const size_t digit = i%10;
        s += digit * digit;
        i /= 10;
    }
    return s ;
}

struct Cache {
    Cache(size_t dim) : m_cache(dim, never_seen) {}
    void set(size_t n, Status status) {
        if (m_cache.size() <= n) {
            m_cache.resize(n+1, never_seen);
        }
        m_cache[n] = status;
        // std::cout << "(c[" << n << "]<-"<<toString[status] << ")";
    }
    Status operator[](size_t n) const {
        if (m_cache.size() <= n) {
            return never_seen;
        } else {
            return m_cache[n];
        }
    }

private:
    std::vector<Status> m_cache;
};

void search_happy_lh(size_t upper_bound, std::vector<size_t> & happy_numbers)
{
    happy_numbers.clear();
    happy_numbers.reserve(upper_bound); // it doesn't improve much the performances

    Cache cache(upper_bound+1);
    std::vector<size_t> current_stack;

    cache.set(1,happy);
    happy_numbers.push_back(1);
    for (size_t i = 2; i<=upper_bound ; ++i) {
        // std::cout << "\r" << i << std::flush;
        current_stack.clear();
        size_t s= i;
        while ( s != 1 && cache[s]==never_seen)
        {
            current_stack.push_back(s);
            cache.set(s, being_explored);
            s = sum_squares(s);
            // std::cout << " - " << s << std::flush;
        }
        const Status update_with = (cache[s]==being_explored ||cache[s]==unhappy) ? unhappy : happy;
        // std::cout << " => " << s << ":" << toString[update_with] << std::endl;
        for (size_t j=0; j!=current_stack.size(); ++j) {
            cache.set(current_stack[j], update_with);
        }
        if (cache[i] == happy) {
            happy_numbers.push_back(i);
        }
    }
}
</code></pre>
<br /><b># 9 </b><br /><p>Other optimizations : by using arrays and direct access using the loop <span style="background-color:yellow;">index</span> rather than <span style="background-color:yellow;">searching</span> <span style="background-color:yellow;">in</span> a vector , and by caching prior <span style="background-color:yellow;">sums</span> , the following code ( <span style="background-color:yellow;">inspired</span> by Dr Asik 's answer but probably not optimized at all ) runs 2445 <span style="background-color:yellow;">times</span> faster than the original C + + code , about 400 <span style="background-color:yellow;">times</span> faster than the Python code . </p>
<pre><code>#include <iostream>
#include <windows.h>
#include <vector>

void calcMain(int upperBound, std::vector<int>& known)
{
    int tempDigitCounter = upperBound;
    int numDigits = 0;
    while (tempDigitCounter > 0)
    {
    	numDigits++;
    	tempDigitCounter /= 10;
    }
    int maxSlots = numDigits * 9 * 9;
    int* history = new int[maxSlots + 1];

    int* cache = new int[upperBound+1];
    for (int jj = 0; jj <= upperBound; jj++)
    {
    	cache[jj] = 0;
    }

    int current, sum, temp;
    for(int i = 0; i <= upperBound; i++)
    {
        current = i;
    	while(true)
        {
    		sum = 0;
    		temp = current;

    		bool inRange = temp <= upperBound;
    		if (inRange)
    		{
    			int cached = cache[temp];
    			if (cached)
    			{
    				sum = cached;
    			}
    		}

    		if (sum == 0)
    		{
    			while (temp > 0)
    			{
    				int tempMod = temp % 10;
    				sum += tempMod * tempMod;
    				temp /= 10;
    			}
    			if (inRange)
    			{
    				cache[current] = sum;
    			}
    		}
    		current = sum;
        	if(history[current] == i)
        	{
        		if(current == 1)
        		{
    				known.push_back(i);
        		}
        		break;
    		}
        	history[current] = i;
        }
    }
}

int main()
{
    while(true)
    {
        int upperBound;
    	std::vector<int> known;
    	std::cout << "Pick an upper bound: ";
    	std::cin >> upperBound;
    	long start, end;
    	start = GetTickCount();
        calcMain(upperBound, known);
    	end = GetTickCount();
    	for (size_t i = 0; i < known.size(); ++i) {
    		std::cout << known[i] << ", ";
        }   			
    	double seconds = (double)(end-start) / 1000.0;
    	std::cout << std::endl << seconds << " seconds." << std::endl << std::endl;
    }
    return 0;
}
</code></pre>
<br /><b># <span style="background-color:yellow;">10</span> </b><br /><p>Here 's <span style="background-color:yellow;">some</span> food for thought : If given the choice of running a <span style="background-color:yellow;">1979</span> algorithm for finding prime <span style="background-color:yellow;">numbers</span> <span style="background-color:yellow;">in</span> a 2009 computer or a 2009 algorithm on a <span style="background-color:yellow;">1979</span> computer , which would you choose ? </p>
<p>The new algorithm on ancient hardware would be the better choice by a huge margin. Have a look at your " helper " functions . </p>
<br /><b># <span style="background-color:yellow;">11</span> </b><br /><p>There are quite a few optimizations possible : </p>
<p>( <span style="background-color:yellow;">1</span> ) Use const references </p>
<pre><code>bool inVector(int inQuestion, const vector<int>& known)
{
    for(vector<int>::const_iterator it = known.begin(); it != known.end(); ++it)
    	if(*it == inQuestion)
    		return true;
    return false;
}

int sum(const vector<int>& given)
{
    int sum = 0;
    for(vector<int>::const_iterator it = given.begin(); it != given.end(); ++it)
    	sum += *it;
    return sum;
}
</code></pre>
<p>( 2 ) Use <span style="background-color:yellow;">counting</span> down loops </p>
<pre><code>int pow(int given, int power)
{
    int current = 1;
    while(power--)
    	current *= given;
    return current;
}
</code></pre>
<p>Or , as others have <span style="background-color:yellow;">said</span> , use the <span style="background-color:yellow;">standard</span> library code . </p>
<p>( 3 ) Do n't allocate buffers where not required </p>
<pre><code>		vector<int> squares;
		for (int temp = current; temp != 0; temp /= 10)
		{
			squares.push_back(pow(temp % 10, 2));
		}
</code></pre>
<br /><b># <span style="background-color:yellow;">12</span> </b><br /><p>With <span style="background-color:yellow;">similar</span> optimizations as PotatoSwatter I got <span style="background-color:yellow;">time</span> for <span style="background-color:yellow;">10000</span> <span style="background-color:yellow;">numbers</span> down from <span style="background-color:yellow;">1.063</span> <span style="background-color:yellow;">seconds</span> to 0.062 <span style="background-color:yellow;">seconds</span> ( except I replaced <span style="background-color:yellow;">itoa</span> with <span style="background-color:yellow;">standard</span> <span style="background-color:yellow;">sprintf</span> <span style="background-color:yellow;">in</span> the original ) . </p>
<p>With all the memory optimizations ( do n't pass containers by value - <span style="background-color:yellow;">in</span> C + + you have to explicitly decide whether you want a copy or a reference ; move operations that allocate memory out of <span style="background-color:yellow;">inner</span> loops ; <span style="background-color:yellow;">if</span> you already have the <span style="background-color:yellow;">number</span> <span style="background-color:yellow;">in</span> a char buffer , what 's the point of copying <span style="background-color:yellow;">it</span> to <span style="background-color:yellow;">std</span> : : <span style="background-color:yellow;">string</span> etc ) I got <span style="background-color:yellow;">it</span> down to 0.532 . </p>
<p>The rest of the <span style="background-color:yellow;">time</span> came from using % <span style="background-color:yellow;">10</span> to access <span style="background-color:yellow;">digits</span> , rather than converting <span style="background-color:yellow;">numbers</span> to <span style="background-color:yellow;">string</span> . </p>
<p>I <span style="background-color:yellow;">suppose</span> there might be another algorithmic level optimization ( <span style="background-color:yellow;">numbers</span> that you have encountered while finding a <span style="background-color:yellow;">happy</span> <span style="background-color:yellow;">number</span> are themselves also <span style="background-color:yellow;">happy</span> <span style="background-color:yellow;">numbers</span> ? ) but I do n't know how much that gains ( there <span style="background-color:yellow;">is</span> not that many <span style="background-color:yellow;">happy</span> <span style="background-color:yellow;">numbers</span> <span style="background-color:yellow;">in</span> the first place ) and this optimization <span style="background-color:yellow;">is</span> not <span style="background-color:yellow;">in</span> the Python version either . </p>
<p>By the way , by not using <span style="background-color:yellow;">string</span> conversion and a list to <span style="background-color:yellow;">square</span> <span style="background-color:yellow;">digits</span> , I got the Python version from 0.825 <span style="background-color:yellow;">seconds</span> down to 0.33 too . </p>
<br /><b># <span style="background-color:yellow;">13</span> </b><br /><p>Here 's a C # version : </p>
<pre><code>using System;
using System.Collections.Generic;
using System.Text;

namespace CSharp
{
  class Program
  {
    static void Main (string [] args)
    {
      while (true)
      {
        Console.Write ("Pick an upper bound: ");

        String
          input = Console.ReadLine ();

        uint
          upper_bound;

        if (uint.TryParse (input, out upper_bound))
        {
          DateTime
            start = DateTime.Now;

          CalcHappyNumbers (upper_bound);

          DateTime
            end = DateTime.Now;

          TimeSpan
            span = end - start;

          Console.WriteLine ("Time taken = " + span.TotalSeconds + " seconds.");
        }
        else
        {
          Console.WriteLine ("Error in input, unable to parse '" + input + "'.");
        }
      }
    }

    enum State
    {
      Happy,
      Sad,
      Unknown
    }

    static void CalcHappyNumbers (uint upper_bound)
    {
      SortedDictionary<uint, State>
        happy = new SortedDictionary<uint, State> ();

      SortedDictionary<uint, bool>
        happy_numbers = new SortedDictionary<uint, bool> ();

      happy [1] = State.Happy;
      happy_numbers [1] = true;

      for (uint current = 2 ; current < upper_bound ; ++current)
      {
        FindState (ref happy, ref happy_numbers, current);
      }

      //foreach (KeyValuePair<uint, bool> pair in happy_numbers)
      //{
      //  Console.Write (pair.Key.ToString () + ", ");
      //}

      //Console.WriteLine ("");
    }

    static State FindState (ref SortedDictionary<uint, State> happy, ref SortedDictionary<uint,bool> happy_numbers, uint value)
    {
      State
        current_state;

      if (happy.TryGetValue (value, out current_state))
      {
        if (current_state == State.Unknown)
        {
          happy [value] = State.Sad;
        }
      }
      else
      {
        happy [value] = current_state = State.Unknown;

        uint
          new_value = 0;

        for (uint i = value ; i != 0 ; i /= 10)
        {
          uint
            lsd = i % 10;

          new_value += lsd * lsd;
        }

        if (new_value == 1)
        {
          current_state = State.Happy;
        }
        else
        {
          current_state = FindState (ref happy, ref happy_numbers, new_value);
        }

        if (current_state == State.Happy)
        {
          happy_numbers [value] = true;
        }

        happy [value] = current_state;
      }

      return current_state;
    }
  }
}
</code></pre>
<p>I compared <span style="background-color:yellow;">it</span> against Dr_Asik 's C + + code. For an upper bound of <span style="background-color:yellow;">100000</span> the C + + version ran <span style="background-color:yellow;">in</span> about 2.9 <span style="background-color:yellow;">seconds</span> and the C # version <span style="background-color:yellow;">in</span> 0.35 <span style="background-color:yellow;">seconds.</span> Both were compiled using Dev Studio 2005 using default release build options and both were executed from a command prompt . </p>
<p>Skizz </p>
<br /><b># <span style="background-color:yellow;">14</span> </b><br /><pre><code>
#!/usr/bin/env python

import timeit

upperBound = 0

def calcMain():
    known = set()
    for i in xrange(0,upperBound+1):
        next = False
        current = i
        history = set()
        while not next:
            squaresum=0
            while current > 0:
                current, digit = divmod(current, 10)
                squaresum += digit * digit
            current = squaresum
            if current in history:
                next = True
                if current == 1:
                    known.add(i)
            history.add(current)

while True:
    upperBound = input("Pick an upper bound: ")
    result = timeit.Timer(calcMain).timeit(1)
    print result, "seconds.\n"
</code></pre>
<p>I made a couple of minor changes to your original python code example that make a better than <span style="background-color:yellow;">16x</span> <span style="background-color:yellow;">improvement</span> to the performance of the code . The changes I made took the <span style="background-color:yellow;">100,000</span> case from about 9.64 <span style="background-color:yellow;">seconds</span> to about 3.38 <span style="background-color:yellow;">seconds</span> . </p>
<p>The major change was to make the mod <span style="background-color:yellow;">10</span> and accumulator changes to run <span style="background-color:yellow;">in</span> a while loop. I made a couple of other changes that <span style="background-color:yellow;">improved</span> execution <span style="background-color:yellow;">time</span> <span style="background-color:yellow;">in</span> only fractions of hundredths of <span style="background-color:yellow;">seconds.</span> The first minor change was changing the main for loop from a range list comprehension to an <span style="background-color:yellow;">xrange</span> <span style="background-color:yellow;">iterator.</span> The <span style="background-color:yellow;">second</span> minor change was <span style="background-color:yellow;">substituting</span> the <span style="background-color:yellow;">set</span> class for the list class for both the known and <span style="background-color:yellow;">history</span> variables . I also experimented with <span style="background-color:yellow;">iterator</span> comprehensions and precalculating the <span style="background-color:yellow;">squares</span> but they both had negative effects on the efficiency . I <span style="background-color:yellow;">seem</span> to be running a <span style="background-color:yellow;">slower</span> version of python or on a <span style="background-color:yellow;">slower</span> processor than <span style="background-color:yellow;">some</span> of the other contributers. I would be <span style="background-color:yellow;">interest</span> <span style="background-color:yellow;">in</span> the results of <span style="background-color:yellow;">someone</span> else 's timing comparison of my python code against one of the optimized C + + versions of the <span style="background-color:yellow;">same</span> algorithm . I also tried using the python -O and -OO optimizations but they had the reverse of the <span style="background-color:yellow;">intended</span> effect . </p>
<br /><b># <span style="background-color:yellow;">15</span> </b><br /><p>Why <span style="background-color:yellow;">is</span> everyone using a vector <span style="background-color:yellow;">in</span> the c + + version ? Lookup <span style="background-color:yellow;">time</span> <span style="background-color:yellow;">is</span> O ( N ) . </p>
<p>Even though <span style="background-color:yellow;">it</span> 's not as efficient as the python <span style="background-color:yellow;">set</span> , use <span style="background-color:yellow;">std</span> : : <span style="background-color:yellow;">set.</span> Lookup <span style="background-color:yellow;">time</span> <span style="background-color:yellow;">is</span> O ( log ( N ) ) . </p>
<br />