<h3>Question ( ID-1735561 ) : </h3><h2>oneliner scramble program </h2><p>It 's that time of year <span style="background-color:yellow;">again</span> that programmers want to <span style="background-color:yellow;">shuffle</span> <span style="background-color:yellow;">a</span> list such that <span style="background-color:yellow;">no</span> element <span style="background-color:yellow;">resides</span> on its original position ( <span style="background-color:yellow;">at</span> least in the Netherlands , we celebrate Sinterklaas <span style="background-color:yellow;">and</span> pick straws for deciding who writes who <span style="background-color:yellow;">a</span> poem ) . Does <span style="background-color:yellow;">anyone</span> have <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">nice</span> Python single statement for that ? </p>
<p>So , input example : <span style="background-color:yellow;">range</span> ( <span style="background-color:yellow;">10</span> ) </p>
<p>Output example : [ 2,8,4,1,3,7,5,9,6,0 ] </p>
<p>Wrong output would be [ 2,8,4,1,3,5,7,9,6,0 ] because the 5 is <span style="background-color:yellow;">at</span> its original position. This would mean that person 5 must write <span style="background-color:yellow;">a</span> poem to himself <span style="background-color:yellow;">and</span> that is less fun . </p>
<p>edit Many people repeat the <span style="background-color:yellow;">assignment</span> just <span style="background-color:yellow;">as</span> long <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">needed</span> to get lucky <span style="background-color:yellow;">and</span> find that in fact the solution is satisfactory. This is <span style="background-color:yellow;">a</span> bad <span style="background-color:yellow;">approach</span> <span style="background-color:yellow;">as</span> in theory this can take infinitely long. The better <span style="background-color:yellow;">approach</span> is indeed suggested by Bart , but I ca <span style="background-color:yellow;">n't</span> get that into <span style="background-color:yellow;">a</span> oneliner for one reason or <span style="background-color:yellow;">another..</span> . </p>
<p>edit By oneliner , I mean single statement . As it <span style="background-color:yellow;">appears</span> , Python is <span style="background-color:yellow;">also</span> <span style="background-color:yellow;">able</span> to compress multiple statements on <span style="background-color:yellow;">a</span> single line. I did <span style="background-color:yellow;">n't</span> know that. There <span style="background-color:yellow;">are</span> currently very <span style="background-color:yellow;">nice</span> solutions only <span style="background-color:yellow;">using</span> the semicolon to mimic multiline behaviour on <span style="background-color:yellow;">a</span> single line. Hence : " can you do it in <span style="background-color:yellow;">a</span> single statement ? " </p>
<br /><h3>Answers ( Total-11 ) : </h3><b># <span style="background-color:yellow;">0</span> </b><br /><p>I found <span style="background-color:yellow;">shuffle</span> can be <span style="background-color:yellow;">abused</span> into solving this </p>
<pre><code>from random import shuffle
L=["Anne","Beth","Cath","Dave","Emma"]
shuffle(L,int=lambda n:int(n-1))
print L
</code></pre>
<p>The distribution is <span style="background-color:yellow;">not</span> <span style="background-color:yellow;">uniform</span> however this was <span style="background-color:yellow;">not</span> <span style="background-color:yellow;">a</span> requirement . </p>
<pre><code>#For 100,000 samples

(('Beth', 'Cath', 'Dave', 'Emma', 'Anne'), 13417)
(('Beth', 'Cath', 'Emma', 'Anne', 'Dave'), 6572)
(('Beth', 'Dave', 'Anne', 'Emma', 'Cath'), 3417)
(('Beth', 'Dave', 'Emma', 'Cath', 'Anne'), 6581)
(('Beth', 'Emma', 'Anne', 'Cath', 'Dave'), 3364)
(('Beth', 'Emma', 'Dave', 'Anne', 'Cath'), 6635)
(('Cath', 'Anne', 'Dave', 'Emma', 'Beth'), 1703)
(('Cath', 'Anne', 'Emma', 'Beth', 'Dave'), 1705)
(('Cath', 'Dave', 'Beth', 'Emma', 'Anne'), 6583)
(('Cath', 'Dave', 'Emma', 'Anne', 'Beth'), 3286)
(('Cath', 'Emma', 'Beth', 'Anne', 'Dave'), 3325)
(('Cath', 'Emma', 'Dave', 'Beth', 'Anne'), 3421)
(('Dave', 'Anne', 'Beth', 'Emma', 'Cath'), 1653)
(('Dave', 'Anne', 'Emma', 'Cath', 'Beth'), 1664)
(('Dave', 'Cath', 'Anne', 'Emma', 'Beth'), 3349)
(('Dave', 'Cath', 'Emma', 'Beth', 'Anne'), 6727)
(('Dave', 'Emma', 'Anne', 'Beth', 'Cath'), 3319)
(('Dave', 'Emma', 'Beth', 'Cath', 'Anne'), 3323)
(('Emma', 'Anne', 'Beth', 'Cath', 'Dave'), 1682)
(('Emma', 'Anne', 'Dave', 'Beth', 'Cath'), 1656)
(('Emma', 'Cath', 'Anne', 'Beth', 'Dave'), 3276)
(('Emma', 'Cath', 'Dave', 'Anne', 'Beth'), 6638)
(('Emma', 'Dave', 'Anne', 'Cath', 'Beth'), 3358)
(('Emma', 'Dave', 'Beth', 'Anne', 'Cath'), 3346)
</code></pre>
<p>For <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">uniform</span> distribution , this ( longer ) version can be <span style="background-color:yellow;">used</span> </p>
<pre><code>from random import shuffle,randint
L=["Anne","Beth","Cath","Dave","Emma"]
shuffle(L,random=lambda:1,int=lambda n:randint(0,n-2))
print L

# For 100,000 samples

(('Beth', 'Cath', 'Dave', 'Emma', 'Anne'), 4157)
(('Beth', 'Cath', 'Emma', 'Anne', 'Dave'), 4155)
(('Beth', 'Dave', 'Anne', 'Emma', 'Cath'), 4099)
(('Beth', 'Dave', 'Emma', 'Cath', 'Anne'), 4141)
(('Beth', 'Emma', 'Anne', 'Cath', 'Dave'), 4243)
(('Beth', 'Emma', 'Dave', 'Anne', 'Cath'), 4208)
(('Cath', 'Anne', 'Dave', 'Emma', 'Beth'), 4219)
(('Cath', 'Anne', 'Emma', 'Beth', 'Dave'), 4087)
(('Cath', 'Dave', 'Beth', 'Emma', 'Anne'), 4117)
(('Cath', 'Dave', 'Emma', 'Anne', 'Beth'), 4127)
(('Cath', 'Emma', 'Beth', 'Anne', 'Dave'), 4198)
(('Cath', 'Emma', 'Dave', 'Beth', 'Anne'), 4210)
(('Dave', 'Anne', 'Beth', 'Emma', 'Cath'), 4179)
(('Dave', 'Anne', 'Emma', 'Cath', 'Beth'), 4119)
(('Dave', 'Cath', 'Anne', 'Emma', 'Beth'), 4143)
(('Dave', 'Cath', 'Emma', 'Beth', 'Anne'), 4203)
(('Dave', 'Emma', 'Anne', 'Beth', 'Cath'), 4252)
(('Dave', 'Emma', 'Beth', 'Cath', 'Anne'), 4159)
(('Emma', 'Anne', 'Beth', 'Cath', 'Dave'), 4193)
(('Emma', 'Anne', 'Dave', 'Beth', 'Cath'), 4177)
(('Emma', 'Cath', 'Anne', 'Beth', 'Dave'), 4087)
(('Emma', 'Cath', 'Dave', 'Anne', 'Beth'), 4150)
(('Emma', 'Dave', 'Anne', 'Cath', 'Beth'), 4268)
(('Emma', 'Dave', 'Beth', 'Anne', 'Cath'), 4109)
</code></pre>
<p>How it works </p>
<p>Here is the code for <span style="background-color:yellow;">random.shuffle</span> ( ) </p>
<pre><code>def shuffle(self, x, random=None, int=int):
    """x, random=random.random -> shuffle list x in place; return None.

    Optional arg random is a 0-argument function returning a random
    float in [0.0, 1.0); by default, the standard random.random.
    """

    if random is None:
        random = self.random
    for i in reversed(xrange(1, len(x))):
        # pick an element in x[:i+1] with which to exchange x[i]
        j = int(random() * (i+1))
        x[i], x[j] = x[j], x[i]
</code></pre>
<p>Both solutions work by targeting the line j = int ( <span style="background-color:yellow;">random</span> ( ) * ( i + 1 ) ) </p>
<p>The first ( <span style="background-color:yellow;">non</span> <span style="background-color:yellow;">uniform</span> ) effectively makes the line work like this </p>
<pre><code>j = int(random() *(i+1)-1)
</code></pre>
<p>So instead of <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">range</span> of ( 1..i ) we obtain ( <span style="background-color:yellow;">0..i-1</span> ) </p>
<p>The second solution replaces <span style="background-color:yellow;">random</span> ( ) with <span style="background-color:yellow;">a</span> function that <span style="background-color:yellow;">always</span> returns 1 , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">uses</span> <span style="background-color:yellow;">randint</span> instead of int. So the line <span style="background-color:yellow;">now</span> works like this </p>
<pre><code>j = randint(0,i-1)
</code></pre>
<br /><b># 1 </b><br /><p>After shuffling the list of <span style="background-color:yellow;">numbers</span> , let the [ i ] th person write <span style="background-color:yellow;">a</span> poem ( <span style="background-color:yellow;">and</span> buy <span style="background-color:yellow;">a</span> present ! ) for the [ i + 1 ] th person in the list : that way , there can <span style="background-color:yellow;">never</span> be someone who draws him- or herself. Of course , the last one should point to the first.. . </p>
<br /><b># 2 </b><br /><p>Shifting every element in the list by one in <span style="background-color:yellow;">a</span> circular manner , <span style="background-color:yellow;">as</span> suggested by Bart , is easy : </p>
<pre><code>>>> def shift(seq):
...     return seq[-1:] + seq[:-1]
... 
>>> shift(range(10))
[9, 0, 1, 2, 3, 4, 5, 6, 7, 8]
</code></pre>
<p>As for <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">random</span> solution : in this case the request for <span style="background-color:yellow;">a</span> one-liner is <span style="background-color:yellow;">not</span> such <span style="background-color:yellow;">a</span> good idea , since the obvious function to <span style="background-color:yellow;">use</span> , <span style="background-color:yellow;">namely</span> <span style="background-color:yellow;">random.shuffle</span> , performs its task in place. In other words : it has <span style="background-color:yellow;">a</span> side effect , something one <span style="background-color:yellow;">usually</span> tries to <span style="background-color:yellow;">avoid</span> in list comprehensions. There is <span style="background-color:yellow;">a</span> way <span style="background-color:yellow;">around</span> this though , <span style="background-color:yellow;">as</span> Paul points out , <span style="background-color:yellow;">namely</span> by <span style="background-color:yellow;">using</span> <span style="background-color:yellow;">random.sample</span> . The following code shows two one-liners which <span style="background-color:yellow;">use</span> these functions ( <span style="background-color:yellow;">note</span> the <span style="background-color:yellow;">use</span> of <span style="background-color:yellow;">not</span> <span style="background-color:yellow;">shuffle</span> , to work <span style="background-color:yellow;">around</span> the fact that <span style="background-color:yellow;">shuffle</span> returns None ... ) : </p>
<pre><code>>>> from itertools import repeat
>>> from random import shuffle
>>> def shake_it(seq):
...     return next(c for c in repeat(seq[::]) if not shuffle(c) and all(a != b for a, b in zip(seq, c)))
... 
>>> shake_it(range(10))
[7, 9, 0, 2, 6, 8, 5, 1, 4, 3]
>>> 
>>> from itertools import count
>>> from random import sample
>>> def shake_it(seq):
...     return next(c for c in (sample(seq, len(seq)) for _ in count()) if all(a != b for a, b in zip(seq, c)))
... 
>>> shake_it(range(10))
[1, 3, 9, 5, 2, 6, 8, 4, 0, 7]
</code></pre>
<p>Myself , I 'd go with this one : </p>
<pre><code>>>> def shake_it(seq):
...     res = seq[::]
...     while any(a == b for a, b in zip(res, seq)):
...         shuffle(res)
...     return res
... 
>>> shake_it(range(10))
[5, 7, 9, 2, 6, 8, 3, 0, 4, 1]
</code></pre>
<br /><b># 3 </b><br /><p>My first Python program in <span style="background-color:yellow;">a</span> long while. Unlike many of the <span style="background-color:yellow;">above</span> programs , this one takes O ( <span style="background-color:yellow;">n</span> ) time . </p>
<pre><code>s = set(range(10))
r = list()
for i in range(10):
    s2 = s - set([i])
    val = s2.pop()
    r.append(val)
    s.discard(val)

print r
</code></pre>
<p>UPDATE : Paul showed that the <span style="background-color:yellow;">above</span> program was incorrect. Thanks , Paul. Here 's <span style="background-color:yellow;">a</span> different , better version of the same program : </p>
<pre><code>s = range(10)
for i in range(9):
    r = random.randrange(i+1, 10)
    s[i], s[r] = s[r], s[i]

print s
</code></pre>
<br /><b># 4 </b><br /><p>Here is how you do it with O ( <span style="background-color:yellow;">n</span> ) time <span style="background-color:yellow;">and</span> O ( 1 ) extra memory : </p>
<p>Comprehensible code : </p>
<pre><code>def shuffle(a)
  n = a.length
  (0..n - 2).each do |i|
    r = rand(n - i - 1) + i + 1
    a[r], a[i] = a[i], a[r]
  end
  a
end
</code></pre>
<p>A one-liner ( <span style="background-color:yellow;">assumes</span> " <span style="background-color:yellow;">a</span> " is the <span style="background-color:yellow;">array</span> ) : </p>
<pre><code>n = a.length and (0..n - 2).each {|i| r = rand(n - i - 1) + i + 1; a[r], a[i] = a[i], a[r]}
</code></pre>
<p>The code is in ruby , but without <span style="background-color:yellow;">any</span> doubt it 's easily translatable to python </p>
<p>Cheers </p>
<p>P.S. : The solution modifies the <span style="background-color:yellow;">array</span> . </p>
<br /><b># 5 </b><br /><p>" One-liner " in fixed O ( <span style="background-color:yellow;">n</span> ) time : </p>
<pre><code>import random; a=range(10)  # setup (could read in names instead)
for i in range(len(a)-1,0,-1): j=random.randint(0,i-1); a[j],a[i]=a[i],a[j]
print a  # output
</code></pre>
<p>The loop picks elements from the maximum index ( <span style="background-color:yellow;">len</span> ( <span style="background-color:yellow;">a</span> ) -1 ) down to the <span style="background-color:yellow;">next-smallest</span> ( 1 ) . The choice pool for element k only includes indices from <span style="background-color:yellow;">0</span> to k-1 ; once picked , <span style="background-color:yellow;">an</span> element will <span style="background-color:yellow;">not</span> be moved <span style="background-color:yellow;">again</span> . </p>
<p>After the scramble , <span style="background-color:yellow;">no</span> element can <span style="background-color:yellow;">reside</span> in its original position , because : </p>
<ul>if element j is picked for some slot i&gt ; j , it will stay there otherwise , element j will be swapped with some other element from slot i&lt ; j , which will stay there except for the element in slot <span style="background-color:yellow;">0</span> , which will be swapped <span style="background-color:yellow;">unconditionally</span> with the element in slot 1 ( in the final iteration of the loop ) if it has <span style="background-color:yellow;">not</span> <span style="background-color:yellow;">already</span> been displaced . </ul>
<p>[ edit : this is logically equivalent to the Ruby <span style="background-color:yellow;">answer</span> , I think ] </p>
<br /><b># 6 </b><br /><p>This one is O ( N ) . Having the import in the loops is <span style="background-color:yellow;">a</span> bit silly , but you wanted <span style="background-color:yellow;">a</span> one liner </p>
<pre><code>L=range(10)
for i in range(1,len(L)):import random;r=random.randint(0,i-1);L[i],L[r]=L[r],L[i]
print L
</code></pre>
<p>Here is the output distribution when <span style="background-color:yellow;">L</span> = <span style="background-color:yellow;">range</span> ( 5 ) for <span style="background-color:yellow;">100000</span> samples </p>
<pre><code>((1, 2, 3, 4, 0), 4231)
((1, 2, 4, 0, 3), 4115)
((1, 3, 0, 4, 2), 4151)
((1, 3, 4, 2, 0), 4108)
((1, 4, 0, 2, 3), 4254)
((1, 4, 3, 0, 2), 4101)
((2, 0, 3, 4, 1), 4158)
((2, 0, 4, 1, 3), 4177)
((2, 3, 1, 4, 0), 4190)
((2, 3, 4, 0, 1), 4117)
((2, 4, 1, 0, 3), 4194)
((2, 4, 3, 1, 0), 4205)
((3, 0, 1, 4, 2), 4325)
((3, 0, 4, 2, 1), 4109)
((3, 2, 0, 4, 1), 4131)
((3, 2, 4, 1, 0), 4153)
((3, 4, 0, 1, 2), 4081)
((3, 4, 1, 2, 0), 4118)
((4, 0, 1, 2, 3), 4294)
((4, 0, 3, 1, 2), 4167)
((4, 2, 0, 1, 3), 4220)
((4, 2, 3, 0, 1), 4179)
((4, 3, 0, 2, 1), 4090)
((4, 3, 1, 0, 2), 4132)
</code></pre>
<br /><b># 7 </b><br /><p>Sorry this is <span style="background-color:yellow;">n't</span> <span style="background-color:yellow;">a</span> one-liner , but this works </p>
<pre><code>import random
def sinterklaas(n):
    l=[]
    for a in range(n):
        l.append(-1)

    i = 0
    while i < 10:
        index = random.randint(0,n-1)
        if l[index] == -1 and index != i:
        l[index] = i
            i += 1
</code></pre>
<p>Cheers </p>
<br /><b># 8 </b><br /><pre><code>import random; u = range(10)
while sum(u[i]==i for i in range(10)): random.shuffle(u)
</code></pre>
<p>( Ok , I have <span style="background-color:yellow;">a</span> line <span style="background-color:yellow;">0</span> in there too... ) </p>
<br /><b># <span style="background-color:yellow;">9</span> </b><br /><p>For one in O ( <span style="background-color:yellow;">n</span> ) : </p>
<pre><code>u=range(10); random.shuffle(u); v=[ u[u[i]] for i in range(10) ]; return [ v[(u[i]+1)%10] for i in u ]
</code></pre>
<p><span style="background-color:yellow;">u</span> is the inverse of function v , so v [ <span style="background-color:yellow;">u</span> [ i ] + 1 ] is effectively the element following i in <span style="background-color:yellow;">array</span> v . </p>
<br /><b># <span style="background-color:yellow;">10</span> </b><br /><p>Here 's Stephan202 's circular <span style="background-color:yellow;">shift</span> implemented <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> one-liner with <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">randomly-chosen</span> <span style="background-color:yellow;">shift</span> increment : </p>
<pre><code>from random import randrange; s = range(10); r = randrange(1,len(s)-1); print s[-r:] + s[:-r]
</code></pre>
<br />