<h3>Question ( ID-997322 ) : </h3><h2>Why <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">my</span> <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">in</span> Python so slow ? </h2><p>I have the following code thats use <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort</span> to <span style="background-color:yellow;">invert</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> <span style="background-color:yellow;">and</span> has <span style="background-color:yellow;">a</span> worst <span style="background-color:yellow;">time</span> performance : </p>
<pre><code>for i in xrange(len(l)):
    for j in xrange(len(l)):
        if l[i]>l[j]:
            l[i], l[j] = l[j], l[i]
</code></pre>
<p>In some cases ( when <span style="background-color:yellow;">len</span> ( <span style="background-color:yellow;">l</span> ) = <span style="background-color:yellow;">100000</span> ) the code spend <span style="background-color:yellow;">more</span> then 2h to complete execute , I think <span style="background-color:yellow;">its</span> so strange , please correct <span style="background-color:yellow;">my</span> code or give some suggestions. <span style="background-color:yellow;">numpy</span> <span style="background-color:yellow;">and</span> numarray solutions <span style="background-color:yellow;">are</span> welcome . </p>
<br /><h3>Answers ( Total-19 ) : </h3><b># 0 </b><br /><p>Bubble <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> horrible <span style="background-color:yellow;">algorithm</span> to <span style="background-color:yellow;">sort</span> with. That <span style="background-color:yellow;">is</span> quite possibly the reason. If speed <span style="background-color:yellow;">is</span> necessary , I would try <span style="background-color:yellow;">another</span> <span style="background-color:yellow;">algorithm</span> <span style="background-color:yellow;">like</span> quick <span style="background-color:yellow;">sort</span> or <span style="background-color:yellow;">merge</span> <span style="background-color:yellow;">sort</span> . </p>
<br /><b># 1 </b><br /><p>That 's not quite <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort...</span> unless I 've <span style="background-color:yellow;">made</span> <span style="background-color:yellow;">a</span> trivial error , this would <span style="background-color:yellow;">be</span> closer to <span style="background-color:yellow;">a</span> python <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort</span> : </p>
<pre><code>swapped = True
while swapped:
  swapped = False
  for i in xrange(len(l)-1):
    if l[i] > l[i+1]:
      l[i],l[i+1] = l[i+1],l[i]
      swapped = True
</code></pre>
<p>Note that the whole <span style="background-color:yellow;">idea</span> <span style="background-color:yellow;">is</span> that the " <span style="background-color:yellow;">bubble</span> " <span style="background-color:yellow;">moves</span> <span style="background-color:yellow;">along</span> the <span style="background-color:yellow;">array</span> , swapping <span style="background-color:yellow;">adjacent</span> values until <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">moves</span> through the <span style="background-color:yellow;">list</span> , with nothing swapped. There <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">a</span> few optimizations that can <span style="background-color:yellow;">be</span> <span style="background-color:yellow;">made</span> ( such <span style="background-color:yellow;">as</span> shrinking the size of the <span style="background-color:yellow;">inner</span> <span style="background-color:yellow;">loop</span> ) , <span style="background-color:yellow;">but</span> they <span style="background-color:yellow;">are</span> usually only worth <span style="background-color:yellow;">bothering</span> with when you <span style="background-color:yellow;">are</span> " homework oriented " . </p>
<p>Edit : Fixed <span style="background-color:yellow;">length</span> ( ) -&gt ; <span style="background-color:yellow;">len</span> ( ) </p>
<br /><b># 2 </b><br /><p>Bubble <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">may</span> <span style="background-color:yellow;">be</span> horrible <span style="background-color:yellow;">and</span> slow etc , <span style="background-color:yellow;">but</span> would you rather have <span style="background-color:yellow;">an</span> O ( N ^ 2 ) <span style="background-color:yellow;">algorithm</span> over 100 <span style="background-color:yellow;">items</span> , or O ( 1 ) one that required <span style="background-color:yellow;">a</span> dial-up connection ? </p>
<p>And <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">list</span> of 100 <span style="background-color:yellow;">itmes</span> shouldnt take 2 hours. I do n't know python , <span style="background-color:yellow;">but</span> <span style="background-color:yellow;">are</span> you <span style="background-color:yellow;">by</span> <span style="background-color:yellow;">any</span> chance copying entire <span style="background-color:yellow;">lists</span> when you <span style="background-color:yellow;">make</span> those <span style="background-color:yellow;">assignments</span> ? </p>
<p>Here 's <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">in</span> Python from Google : </p>
<pre><code>def bubbleSort(theList, max):
    for n in range(0,max): #upper limit varies based on size of the list
        temp = 0
        for i in range(1, max): #keep this for bounds purposes
            temp = theList[i]
            if theList[i] < theList[i-1]:
                theList[i] = theList[i-1]
                theList[i-1] = temp
</code></pre>
<p><span style="background-color:yellow;">and</span> <span style="background-color:yellow;">another</span> , from wikipedia : </p>
<pre><code>def bubblesort(l):
    "Sorts l in place and returns it."
    for passesLeft in range(len(l)-1, 0, -1):
        for index in range(passesLeft):
            if l[index] < l[index + 1]:
               l[index], l[index + 1] = l[index + 1], l[index]
    return l
</code></pre>
<p>The order of <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">is</span> N ( N-1 ) . This <span style="background-color:yellow;">is</span> essentially N ^ 2 , <span style="background-color:yellow;">because</span> for every element you require to scan the <span style="background-color:yellow;">list</span> <span style="background-color:yellow;">and</span> compare every element . </p>
<p>By the way , you will probably find C + + to <span style="background-color:yellow;">be</span> the <span style="background-color:yellow;">fastest</span> , then Java , then Python . </p>
<br /><b># 3 </b><br /><p>What do you <span style="background-color:yellow;">mean</span> <span style="background-color:yellow;">by</span> <span style="background-color:yellow;">numpy</span> solution ? Numpy has some <span style="background-color:yellow;">sort</span> facilities , which <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">instantenous</span> for those reasonably small <span style="background-color:yellow;">arrays</span> : </p>
<pre><code>import numpy as np
a = np.random.randn(100000)
# Take a few ms on a decent computer
np.sort(a)
</code></pre>
<p>There <span style="background-color:yellow;">are</span> 3 <span style="background-color:yellow;">sorts</span> of <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">algorithms</span> <span style="background-color:yellow;">available</span> , <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">are</span> Nlog ( N ) on <span style="background-color:yellow;">average</span> . </p>
<br /><b># 4 </b><br /><p>I <span style="background-color:yellow;">believe</span> you <span style="background-color:yellow;">mentioned</span> that you were trying to use that <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">benchmark</span> to compare speeds . </p>
<p>I think generally Python <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">bit</span> <span style="background-color:yellow;">faster</span> than Ruby , <span style="background-color:yellow;">but</span> not really near Java/C/C + + /C # . Java <span style="background-color:yellow;">is</span> within 2x of the C 's , <span style="background-color:yellow;">but</span> <span style="background-color:yellow;">all</span> the <span style="background-color:yellow;">interpreted</span> <span style="background-color:yellow;">languages</span> were <span style="background-color:yellow;">around</span> 100x slower . </p>
<p>You <span style="background-color:yellow;">might</span> Google " Programming Language Game " for <span style="background-color:yellow;">a</span> LOT of comparisons of <span style="background-color:yellow;">apps/languages/etc.</span> Check out <span style="background-color:yellow;">a</span> Python JIT for possibly <span style="background-color:yellow;">better</span> performance . </p>
<p>You <span style="background-color:yellow;">might</span> <span style="background-color:yellow;">also</span> compare <span style="background-color:yellow;">it</span> to Ruby to see <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">more</span> fair test . </p>
<p>Edit : Just for fun ( nothing to do with the question ) check this-- </p>
<pre><code>public class Test {
    public static void main(String[]s) {
        int size=Integer.valueOf(s[0]).intValue();
        Random r=new Random();
        int[] l=new int[size];
        for(int i=0;i<size;i++)
            l[i]=r.nextInt();
        long ms=(new Date()).getTime();
        System.out.println("built");
        if(fast) {
            Arrays.sort(l);
        else {
            int temp;
            for(int i=0;i<size;i++)
                for(int j=0;j<size;j++)
                    if(l[i]>l[j]) {                        
                        temp=l[i];
                        l[j]=l[i];
                        l[j]=temp;                        
                    }
            }
        ms=(new Date()).getTime()-ms;
        System.out.println("done in "+ms/1000);
    }
}
</code></pre>
<p>The fun thing <span style="background-color:yellow;">about</span> this : The Java run <span style="background-color:yellow;">times</span> <span style="background-color:yellow;">are</span> on the order of : </p>
<pre>
Array size  Slow Time   Fast time
 100k         2s          0s
  1M         23s          0s
 10M         39m          2s
100M         NO          23s
</pre>
<p>Not that this <span style="background-color:yellow;">addition</span> has <span style="background-color:yellow;">anything</span> to do with the question , <span style="background-color:yellow;">but</span> holy cow the <span style="background-color:yellow;">built-in</span> <span style="background-color:yellow;">impelemntation</span> <span style="background-color:yellow;">is</span> FAST. I think <span style="background-color:yellow;">it</span> took <span style="background-color:yellow;">longer</span> to generate than <span style="background-color:yellow;">sort</span> ( Guess that <span style="background-color:yellow;">makes</span> sense with calls to Random <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">memory</span> <span style="background-color:yellow;">allocation.</span> ) </p>
<p>Had to go <span style="background-color:yellow;">into</span> the CLI <span style="background-color:yellow;">and</span> -Xmx1000M to get that <span style="background-color:yellow;">last</span> one to even run . </p>
<br /><b># 5 </b><br /><p>For one , you 're doing too <span style="background-color:yellow;">many</span> <span style="background-color:yellow;">loops.</span> Your <span style="background-color:yellow;">inner</span> <span style="background-color:yellow;">loop</span> should proceed from <span style="background-color:yellow;">i</span> + 1 to the end of the <span style="background-color:yellow;">list</span> , not from 0. Secondly , <span style="background-color:yellow;">as</span> noted <span style="background-color:yellow;">by</span> others , <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort</span> has <span style="background-color:yellow;">a</span> O ( N ^ 2 ) complexity so for <span style="background-color:yellow;">100000</span> elements , you <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">looping</span> 10,000,000,000 <span style="background-color:yellow;">times.</span> This <span style="background-color:yellow;">is</span> compounded <span style="background-color:yellow;">by</span> the fact that <span style="background-color:yellow;">looping</span> <span style="background-color:yellow;">is</span> one of the <span style="background-color:yellow;">areas</span> where <span style="background-color:yellow;">interpreted</span> <span style="background-color:yellow;">languages</span> have the worst performance. It <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">adds</span> up to <span style="background-color:yellow;">incredibly</span> poor performance. This <span style="background-color:yellow;">is</span> why <span style="background-color:yellow;">any</span> computations that require such tight <span style="background-color:yellow;">looping</span> <span style="background-color:yellow;">are</span> usually written <span style="background-color:yellow;">in</span> C/C + + <span style="background-color:yellow;">and</span> wrapped for use <span style="background-color:yellow;">by</span> <span style="background-color:yellow;">languages</span> <span style="background-color:yellow;">like</span> Python . </p>
<br /><b># 6 </b><br /><p>Here some code I put together to compare <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">base</span> <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">against</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">more</span> streamlined version ( <span style="background-color:yellow;">base</span> vs <span style="background-color:yellow;">modified</span> ) - the <span style="background-color:yellow;">modified</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">about</span> 2-3 <span style="background-color:yellow;">times</span> <span style="background-color:yellow;">faster</span> , still <span style="background-color:yellow;">a</span> slow <span style="background-color:yellow;">sort</span> , <span style="background-color:yellow;">but</span> <span style="background-color:yellow;">faster</span> </p>
<pre><code>from array import *
from random import *
from time import *

def randarray(typecode, numElements, minValue, maxValue):
    a = array(typecode)
    for i in xrange(0, numElements):
        a.append(randint(minValue, maxValue))
    return a

def basesort(l):
    for i in xrange(len(l)):
        for j in xrange(len(l)):
            if l[i]<l[j]:
                l[i], l[j] = l[j], l[i]
    return l

def modifiedsort(l):
    NotComplete = True
    i = 0
    arange = xrange(len(l))
    while NotComplete:
        NotComplete = False
        for j in xrange(len(l) - i):
            if l[i]<l[j]:
                l[i], l[j] = l[j], l[i]
                NotComplete = True
        i += 1

Num = 1000
b = randarray('i', Num, 1, 100000)
m = b[:]

print 'perform base bubble sort'
t = time()
basesort(b)
basetime =  time() - t
print basetime
#print a
print 'complete'

print 'perform modified bubble sort'
t = time()
modifiedsort(m)
modtime =  time() - t
print modtime
#print a
print 'complete'

print 'mod sort is ', basetime / modtime,' fast then base sort'
</code></pre>
<br /><b># 7 </b><br /><p>I think that you <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">basically</span> wasting your <span style="background-color:yellow;">time</span> using <span style="background-color:yellow;">bubble</span> on such <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">large</span> dataset. There <span style="background-color:yellow;">are</span> 3 reasons why <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">is</span> slow : </p>
<p>1 ) Python <span style="background-color:yellow;">is</span> slow 2 ) Bubble <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">is</span> slow 3 ) The <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">listed</span> <span style="background-color:yellow;">is</span> coded <span style="background-color:yellow;">incorrectly/inefficiently</span> . </p>
<p>Regardless of how <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">is</span> coded , <span style="background-color:yellow;">it</span> will <span style="background-color:yellow;">be</span> O ( N ^ 2 ) . Why not use <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">merge/tree</span> <span style="background-color:yellow;">sort</span> ..or <span style="background-color:yellow;">if</span> you want to try quicksort ( <span style="background-color:yellow;">also</span> worst case O ( N ^ 2 ) ) <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">might</span> <span style="background-color:yellow;">be</span> <span style="background-color:yellow;">faster</span> for your particular dataset. I <span style="background-color:yellow;">believe</span> quicksort <span style="background-color:yellow;">is</span> empirically <span style="background-color:yellow;">faster</span> <span style="background-color:yellow;">if</span> the data <span style="background-color:yellow;">already</span> has <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">lot</span> of ordering <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">it</span> . </p>
<br /><b># 8 </b><br /><p>Bubblesort <span style="background-color:yellow;">in</span> general does not scale well to <span style="background-color:yellow;">most</span> possible <span style="background-color:yellow;">inputs</span> <span style="background-color:yellow;">as</span> the number of elements <span style="background-color:yellow;">in</span> the <span style="background-color:yellow;">input</span> grows. ( I.e. , <span style="background-color:yellow;">it</span> 's O ( N ^ 2 ) . ) </p>
<p>As N grows , given <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">random</span> <span style="background-color:yellow;">input</span> <span style="background-color:yellow;">array</span> of size N , you <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">much</span> <span style="background-color:yellow;">less</span> <span style="background-color:yellow;">likely</span> to get <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">array</span> that <span style="background-color:yellow;">sorts</span> quickly with <span style="background-color:yellow;">bubblesort</span> ( e.g. , <span style="background-color:yellow;">almost</span> <span style="background-color:yellow;">sorted</span> <span style="background-color:yellow;">arrays</span> ) . You <span style="background-color:yellow;">are</span> far <span style="background-color:yellow;">more</span> <span style="background-color:yellow;">likely</span> to get <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">array</span> that takes <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">long</span> <span style="background-color:yellow;">time</span> to <span style="background-color:yellow;">sort</span> . </p>
<p>However , the real kicker here <span style="background-color:yellow;">is</span> that the code you posted <span style="background-color:yellow;">is</span> not <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort.</span> Traditionally , <span style="background-color:yellow;">bubblesort</span> will terminate early <span style="background-color:yellow;">if</span> no swaps were <span style="background-color:yellow;">made</span> <span style="background-color:yellow;">as</span> well <span style="background-color:yellow;">as</span> not <span style="background-color:yellow;">attempt</span> to swap values that <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">already</span> <span style="background-color:yellow;">sorted.</span> ( After P number of passes , the P <span style="background-color:yellow;">last</span> <span style="background-color:yellow;">items</span> will <span style="background-color:yellow;">be</span> <span style="background-color:yellow;">in</span> the correct order , so you do n't need to process them. ) The <span style="background-color:yellow;">actual</span> code posted will <span style="background-color:yellow;">always</span> examine every pair <span style="background-color:yellow;">in</span> the <span style="background-color:yellow;">array</span> , so <span style="background-color:yellow;">it</span> will <span style="background-color:yellow;">always</span> run the <span style="background-color:yellow;">inner</span> <span style="background-color:yellow;">loop</span> N ^ 2 <span style="background-color:yellow;">times.</span> For <span style="background-color:yellow;">100000</span> elements , that 's <span style="background-color:yellow;">10000000000</span> <span style="background-color:yellow;">iterations</span> . </p>
<br /><b># 9 </b><br /><p>Bubble <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">makes</span> O ( N 2 ) compare operations ( or <span style="background-color:yellow;">iterations</span> ) . For N = 100,000 , that <span style="background-color:yellow;">means</span> that there will <span style="background-color:yellow;">be</span> 10,000,000,000 <span style="background-color:yellow;">iterations.</span> If that takes 2 hours ( call <span style="background-color:yellow;">it</span> 10,000 seconds ) , then <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">means</span> you get 1,000,000 <span style="background-color:yellow;">iterations</span> per second - or 1 <span style="background-color:yellow;">microsecond</span> per <span style="background-color:yellow;">iteration.</span> That 's not great speed , <span style="background-color:yellow;">but</span> <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">is</span> n't too <span style="background-color:yellow;">bad.</span> And I 'm waving hands <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">ignoring</span> constant <span style="background-color:yellow;">multiplication</span> factors . </p>
<p>If you used <span style="background-color:yellow;">a</span> quicksort , then you 'd get Nlog ( N ) <span style="background-color:yellow;">iterations</span> , which would <span style="background-color:yellow;">mean</span> <span style="background-color:yellow;">about</span> 1,000,000 <span style="background-color:yellow;">iterations</span> , which would take 1 second <span style="background-color:yellow;">in</span> total. ( <span style="background-color:yellow;">log</span> 10 ( N ) <span style="background-color:yellow;">is</span> 5 ; I rounded <span style="background-color:yellow;">it</span> up to 10 for simplicity. ) </p>
<p>So , you have just <span style="background-color:yellow;">amply</span> demonstrated why <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">inappropriate</span> for <span style="background-color:yellow;">large</span> data sets , <span style="background-color:yellow;">and</span> 100,000 <span style="background-color:yellow;">items</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">large</span> enough to demonstrate that . </p>
<br /><b># 10 </b><br /><p>If you 're <span style="background-color:yellow;">interested</span> <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">making</span> your own <span style="background-color:yellow;">sort</span> , you can change <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort</span> to <span style="background-color:yellow;">a</span> comb <span style="background-color:yellow;">sort</span> with just <span style="background-color:yellow;">a</span> couple <span style="background-color:yellow;">lines</span> of code. Comb <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">is</span> nearly <span style="background-color:yellow;">as</span> good <span style="background-color:yellow;">as</span> the <span style="background-color:yellow;">best</span> <span style="background-color:yellow;">sorts.</span> Of course , <span style="background-color:yellow;">making</span> your own <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">best</span> <span style="background-color:yellow;">left</span> <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">learning</span> exercise . </p>
<blockquote>Comb <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">improves</span> on <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort</span> , <span style="background-color:yellow;">and</span> rivals <span style="background-color:yellow;">in</span> speed <span style="background-color:yellow;">more</span> complex <span style="background-color:yellow;">algorithms</span> <span style="background-color:yellow;">like</span> Quicksort . </blockquote>
<p>http : //en.wikipedia.org/wiki/Comb_sort </p>
<br /><b># 11 </b><br /><p>That does n't <span style="background-color:yellow;">look</span> <span style="background-color:yellow;">like</span> <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort</span> to <span style="background-color:yellow;">me</span> , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">if</span> <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">is</span> , <span style="background-color:yellow;">it</span> 's <span style="background-color:yellow;">a</span> very <span style="background-color:yellow;">inefficient</span> <span style="background-color:yellow;">implementation</span> of <span style="background-color:yellow;">it</span> . </p>
<br /><b># 12 </b><br /><p>Because <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">is</span> going execute the comparison <span style="background-color:yellow;">and</span> possibly the swap 100,000 <span style="background-color:yellow;">x</span> 100,000 <span style="background-color:yellow;">times.</span> If the computer <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">fast</span> enough to execute the <span style="background-color:yellow;">innermost</span> statement 1,000,000 <span style="background-color:yellow;">times</span> per second , that still <span style="background-color:yellow;">is</span> 167 <span style="background-color:yellow;">minutes</span> which <span style="background-color:yellow;">is</span> slightly short of 3 hours . </p>
<p>On <span style="background-color:yellow;">a</span> side note , why <span style="background-color:yellow;">are</span> there so <span style="background-color:yellow;">many</span> of these <span style="background-color:yellow;">inane</span> questions on SO ? Is n't <span style="background-color:yellow;">being</span> <span style="background-color:yellow;">able</span> to do simple <span style="background-color:yellow;">algebra</span> <span style="background-color:yellow;">a</span> prerequisite for programming ? ; - ) </p>
<br /><b># 13 </b><br /><p>First of <span style="background-color:yellow;">all</span> , for the purpose of this reply , I 'm <span style="background-color:yellow;">assuming</span> - since you claim <span style="background-color:yellow;">it</span> yourself - that you 're only doing this to <span style="background-color:yellow;">benchmark</span> different <span style="background-color:yellow;">languages.</span> So I wo n't go <span style="background-color:yellow;">into</span> " <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">is</span> just slow " territory. The real question <span style="background-color:yellow;">is</span> why <span style="background-color:yellow;">it</span> 's so <span style="background-color:yellow;">much</span> slower <span style="background-color:yellow;">in</span> Python . </p>
<p>The <span style="background-color:yellow;">answer</span> <span style="background-color:yellow;">is</span> that Python <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">inherently</span> <span style="background-color:yellow;">much</span> slower than C + + or even Java. You do n't see <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">a</span> typical event-driven or I/O-bound <span style="background-color:yellow;">application</span> , since there <span style="background-color:yellow;">most</span> <span style="background-color:yellow;">time</span> <span style="background-color:yellow;">is</span> spent either <span style="background-color:yellow;">idling</span> while waiting for <span style="background-color:yellow;">input</span> , or waiting for I/O calls to complete. In your case , however , the <span style="background-color:yellow;">algorithm</span> <span style="background-color:yellow;">is</span> entirely CPU <span style="background-color:yellow;">bound</span> , <span style="background-color:yellow;">and</span> thus you <span style="background-color:yellow;">are</span> directly <span style="background-color:yellow;">measuring</span> the performance of Python <span style="background-color:yellow;">bytecode</span> <span style="background-color:yellow;">interpreter.</span> Which , <span style="background-color:yellow;">by</span> some estimates , <span style="background-color:yellow;">is</span> 20-30x slower than executing the corresponding native code , which <span style="background-color:yellow;">is</span> what happens with <span style="background-color:yellow;">both</span> C + + <span style="background-color:yellow;">and</span> Java . </p>
<p>In general , <span style="background-color:yellow;">any</span> <span style="background-color:yellow;">time</span> you write <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">long-running</span> CPU-bound <span style="background-color:yellow;">loop</span> <span style="background-color:yellow;">in</span> Python , you should expect this kind of performance. The only way to fix this <span style="background-color:yellow;">is</span> to <span style="background-color:yellow;">move</span> the entire <span style="background-color:yellow;">loop</span> <span style="background-color:yellow;">into</span> C. Moving just the <span style="background-color:yellow;">body</span> ( e.g. using NumPy ) wo n't help you <span style="background-color:yellow;">much</span> , since <span style="background-color:yellow;">loop</span> <span style="background-color:yellow;">iteration</span> <span style="background-color:yellow;">itself</span> will still <span style="background-color:yellow;">be</span> executed <span style="background-color:yellow;">by</span> Python <span style="background-color:yellow;">intepreter</span> . </p>
<br /><b># 14 </b><br /><p>Like the other posts say , <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort</span> <span style="background-color:yellow;">is</span> horrible. It pretty <span style="background-color:yellow;">much</span> should <span style="background-color:yellow;">be</span> <span style="background-color:yellow;">avoided</span> <span style="background-color:yellow;">at</span> <span style="background-color:yellow;">all</span> costs due to the <span style="background-color:yellow;">bad</span> proformance , <span style="background-color:yellow;">like</span> you 're experiencing . Luckily for you there <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">lots</span> of other <span style="background-color:yellow;">sorting</span> <span style="background-color:yellow;">algorithms</span> , http : //en.wikipedia.org/wiki/Sorting_algorithm , for examples . </p>
<p>In <span style="background-color:yellow;">my</span> experience <span style="background-color:yellow;">in</span> school <span style="background-color:yellow;">is</span> that quicksort <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">mergesort</span> <span style="background-color:yellow;">are</span> the other two <span style="background-color:yellow;">basic</span> <span style="background-color:yellow;">sorting</span> <span style="background-color:yellow;">algorithms</span> <span style="background-color:yellow;">introduced</span> with , or shortly <span style="background-color:yellow;">after</span> , <span style="background-color:yellow;">bubble</span> <span style="background-color:yellow;">sort.</span> So I would recommend you <span style="background-color:yellow;">look</span> <span style="background-color:yellow;">into</span> those for <span style="background-color:yellow;">learning</span> <span style="background-color:yellow;">more</span> effective ways to <span style="background-color:yellow;">sort</span> . </p>
<br /><b># 15 </b><br /><p>If you <span style="background-color:yellow;">must</span> code your own , use <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">insertion</span> <span style="background-color:yellow;">sort.</span> Its <span style="background-color:yellow;">about</span> the same <span style="background-color:yellow;">amount</span> of code , <span style="background-color:yellow;">but</span> several <span style="background-color:yellow;">times</span> <span style="background-color:yellow;">faster</span> . </p>
<br /><b># 16 </b><br /><p>I forgot to <span style="background-color:yellow;">add</span> , <span style="background-color:yellow;">if</span> you have some <span style="background-color:yellow;">idea</span> of the size of the dataset <span style="background-color:yellow;">and</span> the distribution of keys then you can use <span style="background-color:yellow;">a</span> radix <span style="background-color:yellow;">sort</span> which would <span style="background-color:yellow;">be</span> O ( N ) . To get the <span style="background-color:yellow;">idea</span> of radix <span style="background-color:yellow;">sort</span> , consider the case where you <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">sorting</span> say numbers <span style="background-color:yellow;">more</span> or <span style="background-color:yellow;">less</span> distributed <span style="background-color:yellow;">between</span> 0 , 100,000. Then you just create something similar to <span style="background-color:yellow;">a</span> hash table , say <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">array</span> of 100,000 <span style="background-color:yellow;">lists</span> , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">add</span> each number to the <span style="background-color:yellow;">bucket.</span> Here 's <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">implementation</span> I wrote <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">a</span> few <span style="background-color:yellow;">minutes</span> that generates some <span style="background-color:yellow;">random</span> data , <span style="background-color:yellow;">sorts</span> <span style="background-color:yellow;">it</span> , <span style="background-color:yellow;">and</span> prints out <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">random</span> segment. The <span style="background-color:yellow;">time</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">less</span> than 1 sec to execute for <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">array</span> of 100,000 <span style="background-color:yellow;">integers</span> . </p>
<p>Option Strict On Option Explicit On </p>
<p>Module Module1 </p>
<pre><code>Private Const MAX_SIZE As Integer = 100000
Private m_input(MAX_SIZE) As Integer
Private m_table(MAX_SIZE) As List(Of Integer)
Private m_randomGen As New Random()
Private m_operations As Integer = 0

Private Sub generateData()
    ' fill with random numbers between 0 and MAX_SIZE - 1
    For i = 0 To MAX_SIZE - 1
        m_input(i) = m_randomGen.Next(0, MAX_SIZE - 1)
    Next

End Sub

Private Sub sortData()
    For i As Integer = 0 To MAX_SIZE - 1
        Dim x = m_input(i)
        If m_table(x) Is Nothing Then
            m_table(x) = New List(Of Integer)
        End If
        m_table(x).Add(x)
        ' clearly this is simply going to be MAX_SIZE -1
        m_operations = m_operations + 1
    Next
End Sub

 Private Sub printData(ByVal start As Integer, ByVal finish As Integer)
    If start < 0 Or start > MAX_SIZE - 1 Then
        Throw New Exception("printData - start out of range")
    End If
    If finish < 0 Or finish > MAX_SIZE - 1 Then
        Throw New Exception("printData - finish out of range")
    End If
    For i As Integer = start To finish
        If m_table(i) IsNot Nothing Then
            For Each x In m_table(i)
                Console.WriteLine(x)
            Next
        End If
    Next
End Sub

' run the entire sort, but just print out the first 100 for verification purposes
Private Sub test()
    m_operations = 0
    generateData()
    Console.WriteLine("Time started = " & Now.ToString())
    sortData()
    Console.WriteLine("Time finished = " & Now.ToString & " Number of operations = " & m_operations.ToString())
    ' print out a random 100 segment from the sorted array
    Dim start As Integer = m_randomGen.Next(0, MAX_SIZE - 101)
    printData(start, start + 100)
End Sub

Sub Main()
    test()
    Console.ReadLine()
End Sub
</code></pre>
<p>End Module Time started = 6/15/2009 4 : 04 : 08 PM Time finished = 6/15/2009 4 : 04 : 08 PM Number of operations = <span style="background-color:yellow;">100000</span> 21429 21430 21430 21431 21431 21432 21433 21435 21435 21435 21436 21437 21437 21439 21441 .. . </p>
<br /><b># 17 </b><br /><p>You can do </p>
<pre><code>l.reverse()
</code></pre>
<p>Script ee.py : </p>
<pre><code>l = []
for i in xrange(100000):
    l.append(i)

l.reverse()
</code></pre>
<p><span style="background-color:yellow;">lyrae</span> @ <span style="background-color:yellow;">localhost</span> : ~ /Desktop $ <span style="background-color:yellow;">time</span> python ee.py </p>
<pre><code>real    0m0.047s
user    0m0.044s
sys    0m0.004s
</code></pre>
<br /><b># 18 </b><br /><p>Basically you <span style="background-color:yellow;">are</span> just <span style="background-color:yellow;">looping</span> 10 <span style="background-color:yellow;">billion</span> <span style="background-color:yellow;">times</span> , <span style="background-color:yellow;">and</span> that 's going to <span style="background-color:yellow;">be</span> slow <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">any</span> <span style="background-color:yellow;">interpreted</span> <span style="background-color:yellow;">language</span> . </p>
<p>The reason why we do n't do everything <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">assembly</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">because</span> speed <span style="background-color:yellow;">is</span> traded <span style="background-color:yellow;">against</span> clarity , pre-written <span style="background-color:yellow;">libraries</span> , <span style="background-color:yellow;">and</span> ease of <span style="background-color:yellow;">implementing</span> specific <span style="background-color:yellow;">algorithms</span> or concepts . </p>
<p>None of which <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">applicable</span> to simply <span style="background-color:yellow;">looping</span> 10 <span style="background-color:yellow;">billion</span> <span style="background-color:yellow;">times</span> while <span style="background-color:yellow;">maybe</span> swapping <span style="background-color:yellow;">a</span> couple of values . </p>
<p>If you 're <span style="background-color:yellow;">actually</span> wanting <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">faster</span> python <span style="background-color:yellow;">implementation</span> of this , then use one of the JIT versions ( PyPy , Psyco ) , they should speed this up considerably . </p>
<p>But really , you 're testing <span style="background-color:yellow;">is</span> flawed : you 're testing the wrong thing. There 's no room for tradeoffs of speed vs utility <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">a</span> simple <span style="background-color:yellow;">loop.</span> So , no oppurtunity to say the performance hit of <span style="background-color:yellow;">a</span> higher <span style="background-color:yellow;">level</span> <span style="background-color:yellow;">language</span> <span style="background-color:yellow;">is</span> worth <span style="background-color:yellow;">it</span> : code <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">assembly</span> or <span style="background-color:yellow;">at</span> <span style="background-color:yellow;">least</span> C . </p>
<br />