<h3>Question ( ID-100003 ) : </h3><h2>What is a metaclass in Python ? </h2><p>I 've mastered almost all the Python concepts ( well , let 's say there are just OO concepts : - ) ) but this <span style="background-color:yellow;">one</span> is tricky . </p>
<p>I know it has something to do with introspection but it 's still unclear to me . </p>
<p>So what are metaclasses ? What do you use them <span style="background-color:yellow;">for</span> ? </p>
<p>Concrete examples , including snippets , much appreciated ! </p>
<br /><h3>Answers ( Total-9 ) : </h3><b># 0 </b><br /><p>Now that I know better , and due to demands in the answers <span style="background-color:yellow;">on</span> the yield keyword and the decorators , I 'm going to answer this question with a lot <span style="background-color:yellow;">of</span> detail . </p>
<p>Disclaimer : very long post . </p>
<h1>Classes as <span style="background-color:yellow;">objects</span> </h1>
<p>Before understanding metaclasses , you need to master classes in Python. And Python has a very peculiar idea <span style="background-color:yellow;">of</span> what classes are , borrowed <span style="background-color:yellow;">from</span> the Smalltalk language . </p>
<p>In most languages , classes are just pieces <span style="background-color:yellow;">of</span> code that describe how to produce an <span style="background-color:yellow;">object.</span> That 's kinda true in Python too : </p>
<pre><code>  >>> class ObjectCreator(object):
  ...       pass
  ... 

  >>> my_object = ObjectCreator()
  >>> print my_object
  <__main__.ObjectCreator object at 0x8974f2c>
</code></pre>
<p>But classes are more than that in Python. Classes are <span style="background-color:yellow;">objects</span> too . </p>
<p>Yes , <span style="background-color:yellow;">objects</span> . </p>
<p>As soon as you use the keyword class , Python executes it and creates an OBJECT. The instruction </p>
<pre><code>  >>> class ObjectCreator(object):
  ...       pass
  ... 
</code></pre>
<p>creates in memory an <span style="background-color:yellow;">object</span> with the <span style="background-color:yellow;">name</span> <span style="background-color:yellow;">ObjectCreator</span> . </p>
<p>This <span style="background-color:yellow;">object</span> ( the class ) is itself capable <span style="background-color:yellow;">of</span> creating <span style="background-color:yellow;">objects</span> ( the instances ) , and this is why it 's a class . </p>
<p>But still , it 's an <span style="background-color:yellow;">object</span> , and therefore : </p>
<ul>you can assign it to a variable you can copy it you can <span style="background-color:yellow;">add</span> attributes to it you can pass it as a <span style="background-color:yellow;">function</span> parameter </ul>
<p>e.g. : </p>
<pre><code>  >>> print ObjectCreator # you can print a class because it's an object
  <class '__main__.ObjectCreator'>
  >>> def echo(o):
  ...       print o
  ... 
  >>> echo(ObjectCreator) # you can pass a class as a parameter
  <class '__main__.ObjectCreator'>
  >>> print hasattr(ObjectCreator, 'new_attribute')
  False
  >>> ObjectCreator.new_attribute = 'foo' # you can add attributes to a class
  >>> print hasattr(ObjectCreator, 'new_attribute')
  True
  >>> print ObjectCreator.new_attribute
  foo
  >>> ObjectCreatorMirror = ObjectCreator # you can assign a class to a variable
  >>> print ObjectCreatorMirror.new_attribute
  foo
  >>> print ObjectCreatorMirror()
  <__main__.ObjectCreator object at 0x8997b4c>
</code></pre>
<h1>Creating classes dynamically </h1>
<p>Since classes are <span style="background-color:yellow;">objects</span> , you can create them <span style="background-color:yellow;">on</span> the <span style="background-color:yellow;">fly</span> , like any <span style="background-color:yellow;">object</span> . </p>
<p>First , you can create a class in a <span style="background-color:yellow;">function</span> using class : </p>
<pre><code>  >>> def choose_class(name):
  ...     if name == 'foo':
  ...         class Foo(object):
  ...             pass
  ...         return Foo # return the class, not an instance
  ...     else:
  ...         class Bar(object):
  ...             pass
  ...         return Bar
  ...     
  >>> MyClass = choose_class('foo') 
  >>> print MyClass # the function returns a class, not an instance
  <class '__main__.Foo'>
  >>> print MyClass() # you can create an object from this class
  <__main__.Foo object at 0x89c6d4c>
</code></pre>
<p>But it 's not so dynamic , since you still have to write the whole class yourself . </p>
<p>Since classes are <span style="background-color:yellow;">objects</span> , they must be generated by something . </p>
<p>When you use the class keyword , Python creates this <span style="background-color:yellow;">object</span> automatically. But as with most things in Python , it gives you a way to do it manually . </p>
<p>Remember the <span style="background-color:yellow;">function</span> <span style="background-color:yellow;">type</span> ? The good <span style="background-color:yellow;">old</span> <span style="background-color:yellow;">function</span> that lets you know what <span style="background-color:yellow;">type</span> an <span style="background-color:yellow;">object</span> is : </p>
<pre><code>>>> print type(1)
<type 'int'>
>>> print type("1")
<type 'str'>
>>> print type(ObjectCreator)
<type 'type'>
>>> print type(ObjectCreator())
<class '__main__.ObjectCreator'>
</code></pre>
<p>Well , <span style="background-color:yellow;">type</span> has a completely different ability , it can also create classes <span style="background-color:yellow;">on</span> the <span style="background-color:yellow;">fly.</span> <span style="background-color:yellow;">type</span> can take the description <span style="background-color:yellow;">of</span> a class as parameters , and return a class . </p>
<p>( I know , it 's silly that the same <span style="background-color:yellow;">function</span> can have two completely different uses according to the parameters you pass to it. It 's an issue due to backwards compatibility in Python ) </p>
<p><span style="background-color:yellow;">type</span> works this way : </p>
<pre><code>  type(name of the class, 
       tuple of the parent class (for inheritance, can be empty), 
       dictionary containing attributes names and values)
</code></pre>
<p>e.g. : </p>
<pre><code>>>> class MyShinyClass(object):
...       pass
</code></pre>
<p>can be created manually this way : </p>
<pre><code>  >>> MyShinyClass = type('MyShinyClass', (), {}) # returns a class object
  >>> print MyShinyClass
  <class '__main__.MyShinyClass'>
  >>> print MyShinyClass() # create an instance with the class
  <__main__.MyShinyClass object at 0x8997cec>
</code></pre>
<p>You 'll notice that we use " <span style="background-color:yellow;">MyShinyClass</span> " as the <span style="background-color:yellow;">name</span> <span style="background-color:yellow;">of</span> the class and as the variable to hold the class reference. They can be different , but there is no reason to complicate things . </p>
<p><span style="background-color:yellow;">type</span> accepts a <span style="background-color:yellow;">dictionary</span> to define the attributes <span style="background-color:yellow;">of</span> the class. So : </p>
<pre><code>>>> class Foo(object):
...       bar = True
</code></pre>
<p>Can be translated to : </p>
<pre><code>  >>> Foo = type('Foo', (), {'bar':True})
</code></pre>
<p>And used as a normal class : </p>
<pre><code>  >>> print Foo
  <class '__main__.Foo'>
  >>> print Foo.bar
  True
  >>> f = Foo()
  >>> print f
  <__main__.Foo object at 0x8a9b84c>
  >>> print f.bar
  True
</code></pre>
<p>And <span style="background-color:yellow;">of</span> course , you can inherit <span style="background-color:yellow;">from</span> it , so : </p>
<pre><code>  >>>   class FooChild(Foo):
  ...         pass
</code></pre>
<p>would be : </p>
<pre><code>  >>> FooChild = type('FooChild', (Foo,), {})
  >>> print FooChild
  <class '__main__.FooChild'>
  >>> print FooChild.bar # bar is inherited from Foo
  True
</code></pre>
<p>Eventually you 'll want to <span style="background-color:yellow;">add</span> methods to your class. Just define a <span style="background-color:yellow;">function</span> with the proper signature and assign it as an attribute . </p>
<pre><code>>>> def echo_bar(self):
...       print self.bar
... 
>>> FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})
>>> hasattr(Foo, 'echo_bar')
>>> hasattr(FooChild, 'echo_bar')
True
>>> my_foo = FooChild()
>>> my_foo.echo_bar()
True
</code></pre>
<p>You see where we are going : in Python , classes are <span style="background-color:yellow;">objects</span> , and you can create a class <span style="background-color:yellow;">on</span> the <span style="background-color:yellow;">fly</span> , dynamically . </p>
<p>This is what Python does when you use the keyword class , and it does so by using a metaclass . </p>
<h1>What are metaclasses ( <span style="background-color:yellow;">finally</span> ) </h1>
<p>Metaclasses are the 'stuff ' that creates classes . </p>
<p>You define classes in <span style="background-color:yellow;">order</span> to create <span style="background-color:yellow;">objects</span> , right ? </p>
<p>But we learned that Python classes are <span style="background-color:yellow;">objects</span> . </p>
<p>Well , metaclasses are what create these <span style="background-color:yellow;">objects.</span> There are the classes ' classes , you can picture them this way : </p>
<pre><code>  MyClass = MetaClass()
  MyObject = MyClass()
</code></pre>
<p>You 've seen that <span style="background-color:yellow;">type</span> lets you do something like this : </p>
<pre><code>  MyClass = type('MyClass', (), {})
</code></pre>
<p>It 's because the <span style="background-color:yellow;">function</span> <span style="background-color:yellow;">type</span> is in <span style="background-color:yellow;">fact</span> a metaclass. <span style="background-color:yellow;">type</span> is the metaclass Python uses to create all classes behind the scenes . </p>
<p>Now you wonder why the heck is it written in lowercase , and not Type ? </p>
<p>Well , I guess it 's a matter <span style="background-color:yellow;">of</span> consistency with str , the class that creates strings <span style="background-color:yellow;">objects</span> , and int the class that creates integer <span style="background-color:yellow;">objects.</span> <span style="background-color:yellow;">type</span> is just the class that creates class <span style="background-color:yellow;">objects</span> . </p>
<p>You see that by checking the __class__ attribute . </p>
<p>Everything , and I mean everything , is an <span style="background-color:yellow;">object</span> in Python. That includes ints , strings , <span style="background-color:yellow;">functions</span> and classes. All <span style="background-color:yellow;">of</span> them are <span style="background-color:yellow;">objects.</span> And all <span style="background-color:yellow;">of</span> them have been created <span style="background-color:yellow;">from</span> a class : </p>
<pre><code>  >>> age = 35
  >>> age.__class__
  <type 'int'>
  >>> name = 'bob'
  >>> name.__class__
  <type 'str'>
  >>> def foo(): pass
  >>> foo.__class__
  <type 'function'>
  >>> class Bar(object): pass
  >>> b = Bar()
  >>> b.__class__
  <class '__main__.Bar'>
</code></pre>
<p>Now , what is the __class__ <span style="background-color:yellow;">of</span> any __class__ ? </p>
<pre><code>  >>> a.__class__.__class__
  <type 'type'>
  >>> age.__class__.__class__
  <type 'type'>
  >>> foo.__class__.__class__
  <type 'type'>
  >>> b.__class__.__class__
  <type 'type'>
</code></pre>
<p>So , a metaclass is just the stuff that creates class <span style="background-color:yellow;">objects</span> . </p>
<p>You can call it a 'class <span style="background-color:yellow;">factory</span> ' if you wish . </p>
<p><span style="background-color:yellow;">type</span> is the built-in metaclass Python uses , but <span style="background-color:yellow;">of</span> course , you can create your <span style="background-color:yellow;">own</span> metaclass . </p>
<h1>The __metaclass__ attribute </h1>
<p>You can <span style="background-color:yellow;">add</span> a __metaclass__ attribute when you write a class : </p>
<pre><code>class Foo(object):
  __metaclass__ = something...
  [...]
</code></pre>
<p>If you do so , Python will use the metaclass to create the class <span style="background-color:yellow;">Foo</span> . </p>
<p>Careful , it 's tricky . </p>
<p>You write class <span style="background-color:yellow;">Foo</span> ( <span style="background-color:yellow;">object</span> ) <span style="background-color:yellow;">first</span> , but the class <span style="background-color:yellow;">object</span> <span style="background-color:yellow;">Foo</span> is not created in memory yet . </p>
<p>Python will look <span style="background-color:yellow;">for</span> __metaclass__ in the class definition. If it <span style="background-color:yellow;">finds</span> it , if will use it to create the <span style="background-color:yellow;">object</span> class <span style="background-color:yellow;">Foo</span> . If it does n't , it will use <span style="background-color:yellow;">type</span> to create the class . </p>
<p>Read that several times . </p>
<p>When you do : </p>
<pre><code>class Foo(Bar):
  pass
</code></pre>
<p>Python does the <span style="background-color:yellow;">following</span> : </p>
<p>Is there a __metaclass__ attribute in <span style="background-color:yellow;">Foo</span> ? </p>
<p>If yes , create in memory a class <span style="background-color:yellow;">object</span> ( I said a class <span style="background-color:yellow;">object</span> , stay with me here ) , with the <span style="background-color:yellow;">name</span> <span style="background-color:yellow;">Foo</span> by using what is in __metaclass__ . </p>
<p>If Python ca n't <span style="background-color:yellow;">find</span> __metaclass__ , it will look <span style="background-color:yellow;">for</span> a __metaclass__ in <span style="background-color:yellow;">Bar</span> ( the parent class ) , and try to do the same . </p>
<p>If Python ca n't <span style="background-color:yellow;">find</span> __metaclass__ in any parent , it will look <span style="background-color:yellow;">for</span> a __metaclass__ at the MODULE level , and try to do the same . </p>
<p>Then if it ca n't <span style="background-color:yellow;">find</span> any __metaclass__ at all , it will use <span style="background-color:yellow;">type</span> to create the class <span style="background-color:yellow;">object</span> . </p>
<p>Now the big question is , what can you put in __metaclass__ ? </p>
<p>The answer is : something that can create a class . </p>
<p>And what can create a class ? <span style="background-color:yellow;">type</span> , <span style="background-color:yellow;">or</span> anything that subclasses <span style="background-color:yellow;">or</span> uses it . </p>
<h1>Custom metaclasses </h1>
<p>The main purpose <span style="background-color:yellow;">of</span> a metaclass is to change the class automatically , when it 's created . </p>
<p>You usually do this <span style="background-color:yellow;">for</span> APIs , where you want to create classes matching the current context . </p>
<p>Imagine a stupid example , where you decide that all classes in your module should have their attributes written in uppercase. There are several ways to do this , but <span style="background-color:yellow;">one</span> way is to set __metaclass__ at the module level . </p>
<p>This way , all classes <span style="background-color:yellow;">of</span> this module will be created using this metaclass , and we just have to tell the metaclass to turn all attributes to uppercase . </p>
<p>Luckily , __metaclass__ can actually be any callable , it does n't need to be a <span style="background-color:yellow;">formal</span> class ( I know , something with 'class ' in its <span style="background-color:yellow;">name</span> does n't need to be a class , go <span style="background-color:yellow;">figure...</span> but it 's helpful ) . </p>
<p>So we will start with a simple example , by using a <span style="background-color:yellow;">function</span> . </p>
<pre><code># the metaclass will automatically get passed the same argument
# that you usually pass to `type`
def upper_attr(future_class_name, future_class_parents, future_class_attr):
  """
    Return a class object, with the list of its attribute turned 
    into uppercase.
  """

  # pick up any attribute that doesn't start with '__'
  attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))
  # turn them into uppercase
  uppercase_attr = dict((name.upper(), value) for name, value in attrs)

  # let `type` do the class creation
  return type(future_class_name, future_class_parents, uppercase_attr)

__metaclass__ = upper_attr # this will affect all classes in the module

class Foo(object): 
  # we can define __metaclass__ here instead to affect only this class
  bar = 'bip'

print hasattr(Foo, 'bar')
# Out: False
print hasattr(Foo, 'BAR')
# Out: True

f = Foo()
print f.BAR
# Out: 'bip'
</code></pre>
<p>Now , let 's do exactly the same , but using a real class <span style="background-color:yellow;">for</span> a metaclass : </p>
<pre><code># remember that `type` is actually a class like `str` and `int`
# so you can inherit from it
class UpperAttrMetaclass(type): 
    # __new__ is the method called before __init__
    # it's the method that creates the object and returns it
    # while __init__ just initializes the object passed as parameter
    # you rarely use __new__, except when you want to control how the object
    # is created.
    # here the created object is the class, and we want to customize it
    # so we override __new__
    # you can do some stuff in __init__ too if you wish
    # some advanced use involves overriding __call__ as well, but we won't
    # see this
    def __new__(upperattr_metaclass, future_class_name, 
                future_class_parents, future_class_attr):

        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)

        return type(future_class_name, future_class_parents, uppercase_attr)
</code></pre>
<p>But this is not really OOP. We call <span style="background-color:yellow;">type</span> directly and we do n't <span style="background-color:yellow;">override</span> call the parent <span style="background-color:yellow;">__new__</span> . Let 's do it : </p>
<pre><code>class UpperAttrMetaclass(type): 

    def __new__(upperattr_metaclass, future_class_name, 
                future_class_parents, future_class_attr):

        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)

        # reuse the type.__new__ method
        # this is basic OOP, nothing magic in there
        return type.__new__(upperattr_metaclass, future_class_name, 
                            future_class_parents, uppercase_attr)
</code></pre>
<p>You may have noticed the extra argument upperattr_metaclass . There is nothing special about it : a method always receives the current instance as <span style="background-color:yellow;">first</span> parameter. Just like you have <span style="background-color:yellow;">self</span> <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">ordinary</span> methods . </p>
<p>Of course , the <span style="background-color:yellow;">names</span> I used here are long <span style="background-color:yellow;">for</span> the sake <span style="background-color:yellow;">of</span> clarity , but like <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">self</span> , all the arguments have conventional <span style="background-color:yellow;">names.</span> So a real production metaclass would look like this : </p>
<pre><code>class UpperAttrMetaclass(type): 

    def __new__(cls, name, bases, dct):

        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)

        return type.__new__(cls, name, bases, uppercase_attr)
</code></pre>
<p>We can make it even cleaner by using super , which will ease inheritance ( because yes , you can have metaclasses , inheriting <span style="background-color:yellow;">from</span> metaclasses , inheriting <span style="background-color:yellow;">from</span> <span style="background-color:yellow;">type</span> ) : </p>
<pre><code>class UpperAttrMetaclass(type): 

    def __new__(cls, name, bases, dct):

        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)

        return super(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)
</code></pre>
<p>That 's it. There is really nothing more about metaclasses . </p>
<p>The reason behind the complexity <span style="background-color:yellow;">of</span> the code using metaclasses is not because <span style="background-color:yellow;">of</span> metaclasses , it 's because you usually use metaclasses to do twisted stuff relying <span style="background-color:yellow;">on</span> introspection , manipulating inheritance , vars such as __dict__ , etc . </p>
<p>Indeed , metaclasses are especially useful to do black magic , and therefore complicated sutff. But by themselves , they are simple : </p>
<ul>intercept a class creation modify the class return the modified class </ul>
<h1>Why would you use metaclasses classes instead <span style="background-color:yellow;">of</span> <span style="background-color:yellow;">functions</span> ? </h1>
<p>Since __metaclass__ can accept any callable , why would you use a class since it 's <span style="background-color:yellow;">obviously</span> more complicated ? </p>
<p>There are several reasons to do so : </p>
<ul>The intention is clear. When you read <span style="background-color:yellow;">UpperAttrMetaclass</span> ( <span style="background-color:yellow;">type</span> ) , you know what 's going to <span style="background-color:yellow;">follow</span> You can use OOP. Metaclass can inherit <span style="background-color:yellow;">from</span> metaclass , <span style="background-color:yellow;">override</span> parent methods . Metaclasses can even use metaclasses . You can structure your code better. You never use metaclasses <span style="background-color:yellow;">for</span> something as trivial as the above example. It 's usually <span style="background-color:yellow;">for</span> something complicated. Having the ability to make several methods and group them in <span style="background-color:yellow;">one</span> class is very useful to make the code easier to read . You can hook <span style="background-color:yellow;">on</span> <span style="background-color:yellow;">__new__</span> , <span style="background-color:yellow;">__init__</span> and <span style="background-color:yellow;">__call__</span> . Which will allow you to do different stuff. Even if usually you can do it all in <span style="background-color:yellow;">__new__</span> , some people are just more comfortable using <span style="background-color:yellow;">__init__</span> . These are called metaclasses , damn it ! It must mean something ! </ul>
<h1>Why the hell would you use metaclasses ? </h1>
<p>Now the big question. Why would use some <span style="background-color:yellow;">obscure</span> error prone <span style="background-color:yellow;">feature</span> ? </p>
<p>Well , usually you do n't : </p>
<blockquote>Metaclasses are deeper magic than 99 % <span style="background-color:yellow;">of</span> users should ever worry about . If you wonder whether you need them , you do n't ( the people who actually need them know with certainty that they need them , and do n't need an explanation about why ) . </blockquote>
<p>Python Guru Tim Peters </p>
<p>The main use case <span style="background-color:yellow;">for</span> a metaclass is creating an API. A typical example <span style="background-color:yellow;">of</span> this is the Django ORM . </p>
<p>It allows you to define something like this : </p>
<pre><code>  class Person(models.Model):
    name = models.CharField(max_length=30)
    age = models.IntegerField()
</code></pre>
<p>But if you do this : </p>
<pre><code>  guy = Person(name='bob', age='35')
  print guy.age
</code></pre>
<p>It wo n't return an IntegerField <span style="background-color:yellow;">object.</span> It will return an int , and can even take it directly <span style="background-color:yellow;">from</span> the database . </p>
<p>This is possible because models.Model defines __metaclass__ and it uses some magic that will turn the <span style="background-color:yellow;">Person</span> you just defined with simple statements into a complex hook to a database <span style="background-color:yellow;">field</span> . </p>
<p>Django makes something complex look simple by exposing a simple API and using metaclasses , recreating code <span style="background-color:yellow;">from</span> this API to do the real job behind the scenes . </p>
<h1>The last word </h1>
<p>First , you know that classes are <span style="background-color:yellow;">objects</span> that can create instances . </p>
<p>Well in <span style="background-color:yellow;">fact</span> , classes are themselves instances. Of metaclasses . </p>
<pre><code>  >>> class Foo(object): pass
  >>> id(Foo)
  142630324
</code></pre>
<p>Everything is an <span style="background-color:yellow;">object</span> in Python , and they are all either instances <span style="background-color:yellow;">of</span> classes <span style="background-color:yellow;">or</span> instances <span style="background-color:yellow;">of</span> metaclasses . </p>
<p>Except <span style="background-color:yellow;">for</span> <span style="background-color:yellow;">type</span> . </p>
<p><span style="background-color:yellow;">type</span> is actually its <span style="background-color:yellow;">own</span> metaclass. This is not something you could reproduce in pure Python , and is done by cheating a little bit at the implementation level . </p>
<p>Secondly , metaclasses are complicated. You may not want to use them <span style="background-color:yellow;">for</span> very simple class alterations. You can change classes by using two different techniques : </p>
<ul>monkey patching class decorators </ul>
<p>99 % <span style="background-color:yellow;">of</span> the time you need class alteration , you are better <span style="background-color:yellow;">off</span> using these . </p>
<p>But 99 % <span style="background-color:yellow;">of</span> the time , you do n't need class alteration at all : - ) </p>
<br /><b># <span style="background-color:yellow;">1</span> </b><br /><p>A metaclass is the class <span style="background-color:yellow;">of</span> a class. Like a class defines how an instance <span style="background-color:yellow;">of</span> the class behaves , a metaclass defines how a class behaves. A class is an instance <span style="background-color:yellow;">of</span> a metaclass . </p>
<p>While in Python you can use arbitrary callables <span style="background-color:yellow;">for</span> metaclasses ( like Jerub shows ) , the more useful approach is actually to make it an actual class itself. 'type ' is the usual metaclass in Python. In case you 're wondering , yes , 'type ' is itself a class , and it is its <span style="background-color:yellow;">own</span> <span style="background-color:yellow;">type.</span> You wo n't be able to recreate something like 'type ' purely in Python , but Python cheats a little. To create your <span style="background-color:yellow;">own</span> metaclass in Python you really just want to subclass 'type' . </p>
<p>A metaclass is most commonly used as a class-factory. Like you create an instance <span style="background-color:yellow;">of</span> the class by calling the class , Python creates a new class ( when it executes the 'class ' statement ) by calling the metaclass. Combined with the normal <span style="background-color:yellow;">__init__</span> and <span style="background-color:yellow;">__new__</span> methods , metaclasses therefor allow you to do 'extra things ' when creating a class , like registering the new class with some registry , <span style="background-color:yellow;">or</span> even replace the class with something else entirely . </p>
<p>When the 'class ' statement is executed , Python <span style="background-color:yellow;">first</span> executes the body <span style="background-color:yellow;">of</span> the 'class ' statement as a normal block <span style="background-color:yellow;">of</span> code. The resulting <span style="background-color:yellow;">namespace</span> ( a <span style="background-color:yellow;">dict</span> ) holds the attributes <span style="background-color:yellow;">of</span> the class-to-be. The metaclass is determined by looking at the baseclasses <span style="background-color:yellow;">of</span> the class-to-be ( metaclasses are inherited ) , at the __metaclass__ attribute <span style="background-color:yellow;">of</span> the class-to-be ( if any ) <span style="background-color:yellow;">or</span> the '__metaclass__ ' global variable. The metaclass is then called with the <span style="background-color:yellow;">name</span> , bases and attributes <span style="background-color:yellow;">of</span> the class to instantiate it . </p>
<p>However , metaclasses actually define the <span style="background-color:yellow;">type</span> <span style="background-color:yellow;">of</span> a class , not just a <span style="background-color:yellow;">factory</span> <span style="background-color:yellow;">for</span> it , so you can do much more with them. You can , <span style="background-color:yellow;">for</span> instance , define normal methods <span style="background-color:yellow;">on</span> the metaclass. These metaclass-methods are like classmethods , in that they can be called <span style="background-color:yellow;">on</span> the class without an instance , but they are also not like classmethods in that they can not be called <span style="background-color:yellow;">on</span> an instance <span style="background-color:yellow;">of</span> the class. <span style="background-color:yellow;">type.__subclasses__</span> ( ) is an example <span style="background-color:yellow;">of</span> a method <span style="background-color:yellow;">on</span> the 'type ' metaclass. You can also define the normal 'magic ' methods , like <span style="background-color:yellow;">__add__</span> , __iter__ and __getattr__ , to implement <span style="background-color:yellow;">or</span> change how the class behaves . </p>
<p>Here 's an aggregated example <span style="background-color:yellow;">of</span> the bits and pieces : </p>
<pre><code>def make_hook(f):
    """Decorator to turn 'foo' method into '__foo__'"""
    f.is_hook = 1
    return f

class MyType(type):
    def __new__(cls, name, bases, attrs):

        if name.startswith('None'):
            return None

        # Go over attributes and see if they should be renamed.
        newattrs = {}
        for attrname, attrvalue in attrs.iteritems():
            if getattr(attrvalue, 'is_hook', 0):
                newattrs['__%s__' % attrname] = attrvalue
            else:
                newattrs[attrname] = attrvalue

        return super(MyType, cls).__new__(cls, name, bases, newattrs)

    def __init__(self, name, bases, attrs):
        super(MyType, self).__init__(name, bases, attrs)

        # classregistry.register(self, self.interfaces)
        print "Would register class %s now." % self

    def __add__(self, other):
        class AutoClass(self, other):
            pass
        return AutoClass
        # Alternatively, to autogenerate the classname as well as the class:
        # return type(self.__name__ + other.__name__, (self, other), {})

    def unregister(self):
        # classregistry.unregister(self)
        print "Would unregister class %s now." % self

class MyObject:
    __metaclass__ = MyType


class NoneSample(MyObject):
    pass

# Will print "NoneType None"
print type(NoneSample), repr(NoneSample)

class Example(MyObject):
    def __init__(self, value):
        self.value = value
    @make_hook
    def add(self, other):
        return self.__class__(self.value + other.value)

# Will unregister the class
Example.unregister()

inst = Example(10)
# Will fail with an AttributeError
#inst.unregister()

print inst + inst
class Sibling(MyObject):
    pass

ExampleSibling = Example + Sibling
# ExampleSibling is now a subclass of both Example and Sibling (with no
# content of its own) although it will believe it's called 'AutoClass'
print ExampleSibling
print ExampleSibling.__mro__
</code></pre>
<br /><b># 2 </b><br /><p>Metaclasses are the secret sauce that make 'class ' work. The default metaclass <span style="background-color:yellow;">for</span> a new style <span style="background-color:yellow;">object</span> is called 'type' . </p>
<blockquote>class <span style="background-color:yellow;">type</span> ( <span style="background-color:yellow;">object</span> ) | <span style="background-color:yellow;">type</span> ( <span style="background-color:yellow;">object</span> ) -&gt ; the <span style="background-color:yellow;">object</span> 's <span style="background-color:yellow;">type</span> | <span style="background-color:yellow;">type</span> ( <span style="background-color:yellow;">name</span> , bases , <span style="background-color:yellow;">dict</span> ) -&gt ; a new <span style="background-color:yellow;">type</span> </blockquote>
<p>Metaclasses take 3 args. ' <span style="background-color:yellow;">name</span> ' , ' bases ' and ' <span style="background-color:yellow;">dict</span> ' </p>
<p>Here is where the secret starts. Look <span style="background-color:yellow;">for</span> where <span style="background-color:yellow;">name</span> , bases and the <span style="background-color:yellow;">dict</span> come <span style="background-color:yellow;">from</span> in this example class definition . </p>
<pre><code>class ThisIsTheName(Bases, Are, Here):
    All_the_code_here
    def doesIs(create, a):
        dict
</code></pre>
<p>Lets define a metaclass that will demonstrate how ' class : ' calls it . </p>
<pre><code>def test_metaclass(name, bases, dict):
    print 'The Class Name is', name
    print 'The Class Bases are', bases
    print 'The dict has', len(dict), 'elems, the keys are', dict.keys()

    return "yellow"

class TestName(object, None, int, 1):
    __metaclass__ = test_metaclass
    foo = 1
    def baz(self, arr):
        pass

print 'TestName = ', repr(TestName)

# output => 
The Class Name is TestName
The Class Bases are (<type 'object'>, None, <type 'int'>, 1)
The dict has 4 elems, the keys are ['baz', '__module__', 'foo', '__metaclass__']
TestName =  'yellow'
</code></pre>
<p>And now , an example that actually means something , this will automatically make the variables in the list " attributes " set <span style="background-color:yellow;">on</span> the class , and set to None . </p>
<pre><code>def init_attributes(name, bases, dict):
    if 'attributes' in dict:
        for attr in dict['attributes']:
            dict[attr] = None

    return type(name, bases, dict)

class Initialised(object):
    __metaclass__ = init_attributes
    attributes = ['foo', 'bar', 'baz']

print 'foo =>', Initialised.foo
# output=>
foo => None
</code></pre>
<p>Note that the magic behaviour that 'Initalised ' gains by having the metaclass <span style="background-color:yellow;">init_attributes</span> is not passed <span style="background-color:yellow;">onto</span> a subclass <span style="background-color:yellow;">of</span> Initalised . </p>
<p>Here is an even more concrete example , showing how you can subclass 'type ' to make a metaclass that performs an action when the class is created. This is quite tricky : </p>
<pre><code>class MetaSingleton(type):
    instance = None
    def __call__(cls, *args, **kw):
        if cls.instance is None:
            cls.instance = super(MetaSingleton, cls).__call__(*args, **kw)
        return cls.instance

 class Foo(object):
     __metaclass__ = MetaSingleton

 a = Foo()
 b = Foo()
 assert a is b
</code></pre>
<br /><b># 3 </b><br /><p>One use <span style="background-color:yellow;">for</span> metaclasses is <span style="background-color:yellow;">adding</span> new properties and methods to an instance automatically . </p>
<p>For example , if you look at Django models , their definition looks a bit confusing. It looks as if you are <span style="background-color:yellow;">only</span> defining class properties : </p>
<pre><code>class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
</code></pre>
<p>However , at runtime the <span style="background-color:yellow;">Person</span> <span style="background-color:yellow;">objects</span> are <span style="background-color:yellow;">filled</span> with all sorts <span style="background-color:yellow;">of</span> useful methods. See the source <span style="background-color:yellow;">for</span> some amazing metaclassery . </p>
<br /><b># 4 </b><br /><p>I think the ONLamp introduction to metaclass programming is well written and gives a really good introduction to the topic despite being several years <span style="background-color:yellow;">old</span> already . </p>
<p>http : //www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html </p>
<p>In short : A class is a blueprint <span style="background-color:yellow;">for</span> the creation <span style="background-color:yellow;">of</span> an instance , a metaclass is a blueprint <span style="background-color:yellow;">for</span> the creation <span style="background-color:yellow;">of</span> a class. It can be easily seen that in Python classes need to be <span style="background-color:yellow;">first-class</span> <span style="background-color:yellow;">objects</span> too to enable this behavior . </p>
<p>I 've never written <span style="background-color:yellow;">one</span> myself , but I think <span style="background-color:yellow;">one</span> <span style="background-color:yellow;">of</span> the nicest uses <span style="background-color:yellow;">of</span> metaclasses can be seen in the Django <span style="background-color:yellow;">framework</span> . The model classes use a metaclass approach to enable a declarative style <span style="background-color:yellow;">of</span> writing new models <span style="background-color:yellow;">or</span> <span style="background-color:yellow;">form</span> classes. While the metaclass is creating the class , all members get the possibility to customize the class itself . </p>
<ul>Creating a new model The metaclass enabling this </ul>
<p>The thing that 's left to say is : If you do n't know what metaclasses are , the probability that you will not need them is 99 % . </p>
<br /><b># 5 </b><br /><p>Here are a list <span style="background-color:yellow;">of</span> sites that helped me learn more about metaclasses : </p>
<ul>A conservative metaclass Stupid Metaclass and Template Tricks Metaclass programming in Python ( ibm.com ) : Part <span style="background-color:yellow;">1</span> ibm.com Metaclass programming in Python ( ibm.com ) : Part 2 ibm.com Metaclass programming in Python ( ibm.com ) : Part 3 ibm.com </ul>
<br /><b># 6 </b><br /><p>Others have explained how metaclasses work and how they <span style="background-color:yellow;">fit</span> into the Python <span style="background-color:yellow;">type</span> system. Here 's an example <span style="background-color:yellow;">of</span> what they can be used <span style="background-color:yellow;">for.</span> In a script I wrote , I wanted to keep track <span style="background-color:yellow;">of</span> the <span style="background-color:yellow;">order</span> in which classes were defined , so that I could later instantiate them in this <span style="background-color:yellow;">order.</span> I <span style="background-color:yellow;">found</span> it easiest to do this using a metaclass . </p>
<pre><code>class MyMeta(type):

    counter = 0

    def __init__(cls, name, bases, dic):
        type.__init__(cls, name, bases, dic)
        cls._order = MyMeta.counter
        MyMeta.counter += 1

class MyType(object):

    __metaclass__ = MyMeta
</code></pre>
<p>Anything that 's a subclass <span style="background-color:yellow;">of</span> <span style="background-color:yellow;">MyType</span> then gets a class attribute _order that records the <span style="background-color:yellow;">order</span> in which the classes were defined . </p>
<br /><b># 7 </b><br /><p>The best metaclass explanation I have read is " Metaclasses Demystified " http : //cleverdevil.org/computing/78/ , which <span style="background-color:yellow;">originally</span> appeared in Python Magazine . </p>
<br /><b># 8 </b><br /><p>Short and useful example using metaclass 6 - 8 line complete Plugin <span style="background-color:yellow;">framework</span> </p>
<p>http : //djangosnippets.org/snippets/542/ </p>
<br />