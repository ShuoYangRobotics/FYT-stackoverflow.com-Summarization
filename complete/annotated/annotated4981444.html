<h3>Question ( ID-4981444 ) : </h3><h2>What 's the best way to handle output redirection ? </h2><p>I want my program by default to stdout , but give the option of writing it to a <span style="background-color:yellow;">file.</span> Should I create my own print <span style="background-color:yellow;">function</span> and call that testing that there is an output <span style="background-color:yellow;">file</span> or is there a better way ? That seems inefficient to me , but every way I can think of calls an additional if test <span style="background-color:yellow;">for</span> every print call. I know this really does n't matter in the long run probably , at least of this script , but I 'm just trying to learn good habits . </p>
<br /><h3>Answers ( Total-6 ) : </h3><b># 0 </b><br /><p>Just write to standard out using print. If the user wants to redirect the output to a <span style="background-color:yellow;">file</span> they can do that : </p>
<pre><code>python foo.py > output.txt
</code></pre>
<br /><b># <span style="background-color:yellow;">1</span> </b><br /><p>Write to a <span style="background-color:yellow;">file</span> object , and when the program starts either have that object point to <span style="background-color:yellow;">sys.stdout</span> or to a <span style="background-color:yellow;">file</span> specified by the user . </p>
<p>Mark Byers ' answer is more unix-like , where most command line tools just use stdin and stdout and let the user do redirection as they see <span style="background-color:yellow;">fit</span> . </p>
<br /><b># 2 </b><br /><p>No , you do n't need to create separate print <span style="background-color:yellow;">function.</span> In Python 2.6 you have this syntax : </p>
<pre><code># suppose f is an open file
print >> f, "hello"

# now sys.stdout is file too
print >> sys.stdout, "hello"
</code></pre>
<p>In Python 3.x : </p>
<pre><code>print("hello", file=f)
# or
print("hello", file=sys.stdout)
</code></pre>
<p>So you really do n't have to differentiate <span style="background-color:yellow;">files</span> and stdout. They are the same . </p>
<p>A toy example , which outputs " hello " the way you want : </p>
<pre><code>#!/usr/bin/env python3
import sys

def produce_output(fobj):
    print("hello", file=fobj)
    # this can also be
    # fobj.write("hello\n")

if __name__=="__main__":
    if len(sys.argv) > 2:
        print("Too many arguments", file=sys.stderr)
        exit(1)

    f = open(argv[1], "a") if len(argv)==2 else sys.stdout
    produce_output(f)
</code></pre>
<p>Note that the printing procedure is abstracted of whether it is working with stdout or a <span style="background-color:yellow;">file</span> . </p>
<br /><b># 3 </b><br /><p>I recommend you using the logging module and logging.handlers... stream , output <span style="background-color:yellow;">files</span> , etc. . </p>
<br /><b># 4 </b><br /><p>If you using <span style="background-color:yellow;">subprocess</span> module , then based on an option you take <span style="background-color:yellow;">from</span> your command line , you can have the stdout option to an open <span style="background-color:yellow;">file</span> object. This way , <span style="background-color:yellow;">from</span> within the program you can redirect to a <span style="background-color:yellow;">file</span> . </p>
<pre><code>import subprocess
with open('somefile','w') as f:
    proc = subprocess.Popen(['myprog'],stdout=f,stderr=subprocess.PIPE)
    out,err = proc.communicate()
    print 'output redirected to somefile'
</code></pre>
<br /><b># 5 </b><br /><p>My reaction would be to output to a temp <span style="background-color:yellow;">file</span> , then either dump that to stdio , or move it to where they requested . </p>
<br />