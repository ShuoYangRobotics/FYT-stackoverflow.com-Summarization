<h3>Question ( ID-1819124 ) : </h3><h2><span style="background-color:yellow;">Image</span> comparison <span style="background-color:yellow;">algorithm</span> </h2><p>I 'm trying to compare <span style="background-color:yellow;">images</span> to each other to find out whether they <span style="background-color:yellow;">are</span> different. First I tried to make <span style="background-color:yellow;">a</span> Pearson correleation of the RGB values , which works <span style="background-color:yellow;">also</span> quite <span style="background-color:yellow;">good</span> unless the pictures <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">a</span> litte <span style="background-color:yellow;">bit</span> shifted. So <span style="background-color:yellow;">if</span> <span style="background-color:yellow;">a</span> have <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">100</span> % <span style="background-color:yellow;">identical</span> <span style="background-color:yellow;">images</span> <span style="background-color:yellow;">but</span> one <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> little <span style="background-color:yellow;">bit</span> moved , I <span style="background-color:yellow;">get</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">bad</span> correlation value . </p>
<p>Any suggestions for <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">better</span> <span style="background-color:yellow;">algorithm</span> ? </p>
<p>BTW , I 'm talking <span style="background-color:yellow;">about</span> to compare thousand of <span style="background-color:yellow;">imgages..</span> . </p>
<p>Edit : Here <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">an</span> example of my pictures ( microscopic ) : </p>
<p><span style="background-color:yellow;">im1</span> : http : //www.freeimagehosting.net/uploads/c603225337.jpg </p>
<p><span style="background-color:yellow;">im2</span> : http : //www.freeimagehosting.net/uploads/9b78f22f42.jpg </p>
<p><span style="background-color:yellow;">im3</span> : http : //www.freeimagehosting.net/uploads/854dcd81eb.jpg </p>
<p><span style="background-color:yellow;">im1</span> <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">im2</span> <span style="background-color:yellow;">are</span> the same <span style="background-color:yellow;">but</span> <span style="background-color:yellow;">a</span> little <span style="background-color:yellow;">bit</span> shifted/cutted , <span style="background-color:yellow;">im3</span> should <span style="background-color:yellow;">be</span> recognized <span style="background-color:yellow;">as</span> completly different.. . </p>
<p>Edit : Problem <span style="background-color:yellow;">is</span> solved with the suggestions of Peter Hansen ! Works very well ! Thanks to <span style="background-color:yellow;">all</span> <span style="background-color:yellow;">answers</span> ! Some results can <span style="background-color:yellow;">be</span> found here http : //www.file-upload.net/download-2054026/image % 5Fcomparision.pdf.html </p>
<br /><h3>Answers ( Total-7 ) : </h3><b># 0 </b><br /><p>A similar question was <span style="background-color:yellow;">asked</span> <span style="background-color:yellow;">a</span> year <span style="background-color:yellow;">ago</span> <span style="background-color:yellow;">and</span> has numerous responses , <span style="background-color:yellow;">including</span> one regarding pixelizing the <span style="background-color:yellow;">images</span> , which I was <span style="background-color:yellow;">going</span> to suggest <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">at</span> least <span style="background-color:yellow;">a</span> pre-qualification step ( <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">it</span> would exclude very non-similar <span style="background-color:yellow;">images</span> quite quickly ) . </p>
<p>There <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">also</span> links there to still-earlier questions which have even more references <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">good</span> <span style="background-color:yellow;">answers</span> . </p>
<p>Here 's <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">implementation</span> using some of the <span style="background-color:yellow;">ideas</span> with Scipy , using your <span style="background-color:yellow;">above</span> three <span style="background-color:yellow;">images</span> ( saved <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">im1.jpg</span> , <span style="background-color:yellow;">im2.jpg</span> , <span style="background-color:yellow;">im3.jpg</span> , respectively ) . The final output shows <span style="background-color:yellow;">im1</span> compared with <span style="background-color:yellow;">itself</span> , <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">baseline</span> , <span style="background-color:yellow;">and</span> then each <span style="background-color:yellow;">image</span> compared with the others . </p>
<pre><code>>>> import scipy as sp
>>> from scipy.misc import imread
>>> from scipy.signal.signaltools import correlate2d as c2d
>>>
>>> def get(i):
...     # get JPG image as Scipy array, RGB (3 layer)
...     data = imread('im%s.jpg' % i)
...     # convert to grey-scale using W3C luminance calc
...     data = sp.inner(data, [299, 587, 114]) / 1000.0
...     # normalize per http://en.wikipedia.org/wiki/Cross-correlation
...     return (data - data.mean()) / data.std()
...
>>> im1 = get(1)
>>> im2 = get(2)
>>> im3 = get(3)
>>> im1.shape
(105, 401)
>>> im2.shape
(109, 373)
>>> im3.shape
(121, 457)
>>> c11 = c2d(im1, im1, mode='same')  # baseline
>>> c12 = c2d(im1, im2, mode='same')
>>> c13 = c2d(im1, im3, mode='same')
>>> c23 = c2d(im2, im3, mode='same')
>>> c11.max(), c12.max(), c13.max(), c23.max()
(42105.00000000259, 39898.103896795357, 16482.883608327804, 15873.465425120798)
</code></pre>
<p>So note that <span style="background-color:yellow;">im1</span> compared with <span style="background-color:yellow;">itself</span> <span style="background-color:yellow;">gives</span> <span style="background-color:yellow;">a</span> score of 42105 , <span style="background-color:yellow;">im2</span> compared with <span style="background-color:yellow;">im1</span> <span style="background-color:yellow;">is</span> not far off that , <span style="background-color:yellow;">but</span> <span style="background-color:yellow;">im3</span> compared with either of the others <span style="background-color:yellow;">gives</span> well under half that value. You 'd have to experiment with other <span style="background-color:yellow;">images</span> to see how well this might perform <span style="background-color:yellow;">and</span> how you might <span style="background-color:yellow;">improve</span> <span style="background-color:yellow;">it</span> . </p>
<p>Run time <span style="background-color:yellow;">is</span> long... several minutes on my machine. I would try some pre-filtering to <span style="background-color:yellow;">avoid</span> wasting time comparing very dissimilar <span style="background-color:yellow;">images</span> , maybe with the " compare jpg file size " trick mentioned <span style="background-color:yellow;">in</span> responses to the other question , or with pixelization. The fact that you have <span style="background-color:yellow;">images</span> of different sizes complicates things , <span style="background-color:yellow;">but</span> you did n't <span style="background-color:yellow;">give</span> enough <span style="background-color:yellow;">information</span> <span style="background-color:yellow;">about</span> the extent of <span style="background-color:yellow;">butchering</span> one might expect , so <span style="background-color:yellow;">it</span> 's hard to <span style="background-color:yellow;">give</span> <span style="background-color:yellow;">a</span> specific <span style="background-color:yellow;">answer</span> that takes that <span style="background-color:yellow;">into</span> <span style="background-color:yellow;">account</span> . </p>
<br /><b># <span style="background-color:yellow;">1</span> </b><br /><p>I have one done this with <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">image</span> histogram comparison. My <span style="background-color:yellow;">basic</span> <span style="background-color:yellow;">algorithm</span> was this : </p>
<ol>Split <span style="background-color:yellow;">image</span> <span style="background-color:yellow;">into</span> red , <span style="background-color:yellow;">green</span> <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">blue</span> Create normalized histograms for red , <span style="background-color:yellow;">green</span> <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">blue</span> channel <span style="background-color:yellow;">and</span> concatenate them <span style="background-color:yellow;">into</span> <span style="background-color:yellow;">a</span> vector ( r0...rn , <span style="background-color:yellow;">g0...gn</span> , <span style="background-color:yellow;">b0...bn</span> ) where n <span style="background-color:yellow;">is</span> the number of " <span style="background-color:yellow;">buckets</span> " , <span style="background-color:yellow;">256</span> should <span style="background-color:yellow;">be</span> enough subtract this histogram from the histogram of <span style="background-color:yellow;">another</span> <span style="background-color:yellow;">image</span> <span style="background-color:yellow;">and</span> calculate the distance </ol>
<p>here <span style="background-color:yellow;">is</span> some code with <span style="background-color:yellow;">numpy</span> <span style="background-color:yellow;">and</span> pil </p>
<pre><code>r = numpy.asarray(im.convert( "RGB", (1,0,0,0, 1,0,0,0, 1,0,0,0) ))
g = numpy.asarray(im.convert( "RGB", (0,1,0,0, 0,1,0,0, 0,1,0,0) ))
b = numpy.asarray(im.convert( "RGB", (0,0,1,0, 0,0,1,0, 0,0,1,0) ))
hr, h_bins = numpy.histogram(r, bins=256, new=True, normed=True)
hg, h_bins = numpy.histogram(g, bins=256, new=True, normed=True)
hb, h_bins = numpy.histogram(b, bins=256, new=True, normed=True)
hist = numpy.array([hr, hg, hb]).ravel()
</code></pre>
<p><span style="background-color:yellow;">if</span> you have two histograms , you can <span style="background-color:yellow;">get</span> the distance like this : </p>
<pre><code>diff = hist1 - hist2
distance = numpy.sqrt(numpy.dot(diff, diff))
</code></pre>
<p>If the two <span style="background-color:yellow;">images</span> <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">identical</span> , the distance <span style="background-color:yellow;">is</span> 0 , the more they diverge , the <span style="background-color:yellow;">greater</span> the distance . </p>
<p>It worked quite well for photos for me <span style="background-color:yellow;">but</span> failed on <span style="background-color:yellow;">graphics</span> like texts <span style="background-color:yellow;">and</span> logos . </p>
<br /><b># <span style="background-color:yellow;">2</span> </b><br /><p>If your problem <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">about</span> shifted pixels , maybe you should compare <span style="background-color:yellow;">against</span> <span style="background-color:yellow;">a</span> frequency transform . </p>
<p>The FFT should <span style="background-color:yellow;">be</span> OK ( <span style="background-color:yellow;">numpy</span> has <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">implementation</span> for <span style="background-color:yellow;">2D</span> matrices ) , <span style="background-color:yellow;">but</span> I 'm <span style="background-color:yellow;">always</span> hearing that Wavelets <span style="background-color:yellow;">are</span> <span style="background-color:yellow;">better</span> for this kind of tasks ^ _ ^ </p>
<p>About the performance , <span style="background-color:yellow;">if</span> <span style="background-color:yellow;">all</span> the <span style="background-color:yellow;">images</span> <span style="background-color:yellow;">are</span> of the same size , <span style="background-color:yellow;">if</span> I remember well , the FFTW package created <span style="background-color:yellow;">an</span> specialised function for each FFT <span style="background-color:yellow;">input</span> size , so you can <span style="background-color:yellow;">get</span> <span style="background-color:yellow;">a</span> nice performance <span style="background-color:yellow;">boost</span> reusing the same code... I do n't know <span style="background-color:yellow;">if</span> <span style="background-color:yellow;">numpy</span> <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">based</span> on FFTW , <span style="background-color:yellow;">but</span> <span style="background-color:yellow;">if</span> <span style="background-color:yellow;">it</span> 's not maybe you could try to <span style="background-color:yellow;">investigate</span> <span style="background-color:yellow;">a</span> little <span style="background-color:yellow;">bit</span> there . </p>
<p>Here you have <span style="background-color:yellow;">a</span> prototype... you can play <span style="background-color:yellow;">a</span> little <span style="background-color:yellow;">bit</span> with <span style="background-color:yellow;">it</span> to see which threshold fits with your <span style="background-color:yellow;">images</span> . </p>
<pre><code>import Image
import numpy
import sys

def main():
    img1 = Image.open(sys.argv[1])
    img2 = Image.open(sys.argv[2])

    if img1.size != img2.size or img1.getbands() != img2.getbands():
    	return -1

    s = 0
    for band_index, band in enumerate(img1.getbands()):
    	m1 = numpy.fft.fft2(numpy.array([p[band_index] for p in img1.getdata()]).reshape(*img1.size))
    	m2 = numpy.fft.fft2(numpy.array([p[band_index] for p in img2.getdata()]).reshape(*img2.size))
    	s += numpy.sum(numpy.abs(m1-m2))
    print s

if __name__ == "__main__":
    sys.exit(main())
</code></pre>
<p>Another way to proceed might <span style="background-color:yellow;">be</span> <span style="background-color:yellow;">blurring</span> the <span style="background-color:yellow;">images</span> , then subtracting the pixel values from the two <span style="background-color:yellow;">images.</span> If the difference <span style="background-color:yellow;">is</span> non nil , then you can shift one of the <span style="background-color:yellow;">images</span> <span style="background-color:yellow;">1</span> px <span style="background-color:yellow;">in</span> each direction <span style="background-color:yellow;">and</span> compare <span style="background-color:yellow;">again</span> , <span style="background-color:yellow;">if</span> the difference <span style="background-color:yellow;">is</span> lower than <span style="background-color:yellow;">in</span> the previous step , you can repeat shifting <span style="background-color:yellow;">in</span> the direction of the <span style="background-color:yellow;">gradient</span> <span style="background-color:yellow;">and</span> subtracting until the difference <span style="background-color:yellow;">is</span> lower than <span style="background-color:yellow;">a</span> certain threshold or <span style="background-color:yellow;">increases</span> <span style="background-color:yellow;">again.</span> That should work <span style="background-color:yellow;">if</span> the radius of the <span style="background-color:yellow;">blurring</span> kernel <span style="background-color:yellow;">is</span> larger than the shift of the <span style="background-color:yellow;">images</span> . </p>
<p>Also , you can try with some of the tools that <span style="background-color:yellow;">are</span> commonly used <span style="background-color:yellow;">in</span> the photography workflow for <span style="background-color:yellow;">blending</span> multiple expositions or doing panoramas , like the Pano Tools . </p>
<br /><b># <span style="background-color:yellow;">3</span> </b><br /><p>You really need to specify the question <span style="background-color:yellow;">better</span> , <span style="background-color:yellow;">but</span> , looking <span style="background-color:yellow;">at</span> those 5 <span style="background-color:yellow;">images</span> , the organisms <span style="background-color:yellow;">all</span> seem to <span style="background-color:yellow;">be</span> oriented the same way. If this <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">always</span> the case , you can try doing <span style="background-color:yellow;">a</span> normalized cross-correlation <span style="background-color:yellow;">between</span> the two <span style="background-color:yellow;">images</span> <span style="background-color:yellow;">and</span> taking the peak value <span style="background-color:yellow;">as</span> your degree of similarity. I do n't know of <span style="background-color:yellow;">a</span> normalized cross-correlation function <span style="background-color:yellow;">in</span> Python , <span style="background-color:yellow;">but</span> there <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> similar fftconvolve ( ) function <span style="background-color:yellow;">and</span> you can do the circular cross-correlation yourself : </p>
<pre><code>a = asarray(Image.open('c603225337.jpg').convert('L'))
b = asarray(Image.open('9b78f22f42.jpg').convert('L'))
f1 = rfftn(a)
f2 = rfftn(b)
g =  f1 * f2
c = irfftn(g)
</code></pre>
<p>This wo n't work <span style="background-color:yellow;">as</span> written since the <span style="background-color:yellow;">images</span> <span style="background-color:yellow;">are</span> different sizes , <span style="background-color:yellow;">and</span> the output <span style="background-color:yellow;">is</span> n't weighted or normalized <span style="background-color:yellow;">at</span> <span style="background-color:yellow;">all</span> . </p>
<p>The location of the peak value of the output <span style="background-color:yellow;">indicates</span> the offset <span style="background-color:yellow;">between</span> the two <span style="background-color:yellow;">images</span> , <span style="background-color:yellow;">and</span> the magnitude of the peak <span style="background-color:yellow;">indicates</span> the similarity. There should <span style="background-color:yellow;">be</span> <span style="background-color:yellow;">a</span> way to weight/normalize <span style="background-color:yellow;">it</span> so that you can tell the difference <span style="background-color:yellow;">between</span> <span style="background-color:yellow;">a</span> <span style="background-color:yellow;">good</span> match <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">a</span> poor match . </p>
<p>This <span style="background-color:yellow;">is</span> n't <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">good</span> of <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">answer</span> <span style="background-color:yellow;">as</span> I want , since I have n't figured out how to normalize <span style="background-color:yellow;">it</span> yet , <span style="background-color:yellow;">but</span> I 'll update <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">if</span> I figure <span style="background-color:yellow;">it</span> out , <span style="background-color:yellow;">and</span> <span style="background-color:yellow;">it</span> will <span style="background-color:yellow;">give</span> you <span style="background-color:yellow;">an</span> <span style="background-color:yellow;">idea</span> to look <span style="background-color:yellow;">into</span> . </p>
<br /><b># 4 </b><br /><p>I have done some <span style="background-color:yellow;">image</span> processing course long <span style="background-color:yellow;">ago</span> , <span style="background-color:yellow;">and</span> remember that when matching I normally started with making the <span style="background-color:yellow;">image</span> <span style="background-color:yellow;">grayscale</span> , <span style="background-color:yellow;">and</span> then sharpening the edges of the <span style="background-color:yellow;">image</span> so you only see edges. You ( the software ) can then shift <span style="background-color:yellow;">and</span> subtract the <span style="background-color:yellow;">images</span> until the difference <span style="background-color:yellow;">is</span> minimal . </p>
<p>If that difference <span style="background-color:yellow;">is</span> larger than the treshold you set , the <span style="background-color:yellow;">images</span> <span style="background-color:yellow;">are</span> not equal <span style="background-color:yellow;">and</span> you can move on to the next. <span style="background-color:yellow;">Images</span> with <span style="background-color:yellow;">a</span> smaller treshold can then <span style="background-color:yellow;">be</span> <span style="background-color:yellow;">analyzed</span> next . </p>
<p>I do think that <span style="background-color:yellow;">at</span> <span style="background-color:yellow;">best</span> you can radically thin out possible matches , <span style="background-color:yellow;">but</span> will need to personally compare possible matches to determine they 're really equal . </p>
<p>I ca n't really show code <span style="background-color:yellow;">as</span> <span style="background-color:yellow;">it</span> was <span style="background-color:yellow;">a</span> long time <span style="background-color:yellow;">ago</span> , <span style="background-color:yellow;">and</span> I used Khoros/Cantata for that course . </p>
<br /><b># 5 </b><br /><p>First off , correlation <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> very CPU <span style="background-color:yellow;">intensive</span> rather <span style="background-color:yellow;">inaccurate</span> measure for similarity. Why not just <span style="background-color:yellow;">go</span> for the sum of the squares <span style="background-color:yellow;">if</span> differences <span style="background-color:yellow;">between</span> <span style="background-color:yellow;">individual</span> pixels ? </p>
<p>A simple solution , <span style="background-color:yellow;">if</span> the <span style="background-color:yellow;">maximum</span> shift <span style="background-color:yellow;">is</span> limited : <span style="background-color:yellow;">generate</span> <span style="background-color:yellow;">all</span> possible shifted <span style="background-color:yellow;">images</span> <span style="background-color:yellow;">and</span> find the one that <span style="background-color:yellow;">is</span> the <span style="background-color:yellow;">best</span> match. Make sure you calculate your match variable ( <span style="background-color:yellow;">i.e.</span> correllation ) only over the subset of pixels that can <span style="background-color:yellow;">be</span> matched <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">all</span> shifted <span style="background-color:yellow;">images.</span> Also , your <span style="background-color:yellow;">maximum</span> shift should <span style="background-color:yellow;">be</span> significantly smaller than the size of your <span style="background-color:yellow;">images</span> . </p>
<p>If you want to use some more <span style="background-color:yellow;">advances</span> <span style="background-color:yellow;">image</span> processing techniques I suggest you look <span style="background-color:yellow;">at</span> SIFT this <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">a</span> very powerfull method that ( theoretically <span style="background-color:yellow;">anyway</span> ) can properly match <span style="background-color:yellow;">items</span> <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">images</span> <span style="background-color:yellow;">independent</span> of translation , rotation <span style="background-color:yellow;">and</span> scale . </p>
<br /><b># 6 </b><br /><p>I <span style="background-color:yellow;">guess</span> you could do something like this : </p>
<ul>estimate vertical / horizontal displacement of reference <span style="background-color:yellow;">image</span> vs the comparison <span style="background-color:yellow;">image.</span> <span style="background-color:yellow;">a</span> simple SAD ( sum of <span style="background-color:yellow;">absolute</span> difference ) with motion vectors would do to . shift the comparison <span style="background-color:yellow;">image</span> <span style="background-color:yellow;">accordingly</span> compute the pearson correlation you were trying to do </ul>
<p>Shift measurement <span style="background-color:yellow;">is</span> not difficult . </p>
<ul>Take <span style="background-color:yellow;">a</span> region ( say <span style="background-color:yellow;">about</span> <span style="background-color:yellow;">32x32</span> ) <span style="background-color:yellow;">in</span> comparison <span style="background-color:yellow;">image</span> . Shift <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">by</span> x pixels <span style="background-color:yellow;">in</span> horizontal <span style="background-color:yellow;">and</span> y pixels <span style="background-color:yellow;">in</span> vertical direction . Compute the SAD ( sum of <span style="background-color:yellow;">absolute</span> difference ) w.r.t. original <span style="background-color:yellow;">image</span> Do this for several values of x <span style="background-color:yellow;">and</span> y <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">a</span> small range ( -10 , + <span style="background-color:yellow;">10</span> ) Find the place where the difference <span style="background-color:yellow;">is</span> minimum Pick that value <span style="background-color:yellow;">as</span> the shift motion vector </ul>
<p>Note : </p>
<p>If the SAD <span style="background-color:yellow;">is</span> coming very high for <span style="background-color:yellow;">all</span> values of x <span style="background-color:yellow;">and</span> y then you can <span style="background-color:yellow;">anyway</span> <span style="background-color:yellow;">assume</span> that the <span style="background-color:yellow;">images</span> <span style="background-color:yellow;">are</span> highly dissimilar <span style="background-color:yellow;">and</span> shift measurement <span style="background-color:yellow;">is</span> not necessary . </p>
<br />