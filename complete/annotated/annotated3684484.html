<h3>Question ( ID-3684484 ) : </h3><h2>Peak detection in a 2D <span style="background-color:yellow;">array</span> </h2><p>I 'm <span style="background-color:yellow;">helping</span> a veterinary clinic measuring <span style="background-color:yellow;">pressure</span> under a dogs <span style="background-color:yellow;">paw.</span> I use Python for my data analysis and now I 'm stuck trying to divide the <span style="background-color:yellow;">paws</span> into ( anatomical ) subregions . </p>
<p>I made a 2D <span style="background-color:yellow;">array</span> of each <span style="background-color:yellow;">paw</span> , that consists of the maximal values for each sensor that <span style="background-color:yellow;">has</span> been loaded by the <span style="background-color:yellow;">paw</span> over time. Here 's an example of one <span style="background-color:yellow;">paw</span> , <span style="background-color:yellow;">where</span> I used Excel to draw the areas I <span style="background-color:yellow;">want</span> to 'detect'. These are 2 by 2 boxes around the sensor <span style="background-color:yellow;">with</span> local maxima 's , that together <span style="background-color:yellow;">have</span> the largest sum . </p>
<p></p>
<p>So I tried some experimenting and decide to simply look for the maximums of each column and row ( ca n't look in one direction due to the shape of the <span style="background-color:yellow;">paw</span> ) . This seems to 'detect ' the location of the separate toes fairly <span style="background-color:yellow;">well</span> , but it also marks neighboring sensors . </p>
<p></p>
<p>So <span style="background-color:yellow;">what</span> <span style="background-color:yellow;">would</span> be the best <span style="background-color:yellow;">way</span> to tell Python <span style="background-color:yellow;">which</span> of these maximums are the ones I <span style="background-color:yellow;">want</span> ? </p>
<p>Note : The 2x2 squares ca n't overlap , since they <span style="background-color:yellow;">have</span> to be separate toes ! </p>
<p>Also I took 2x2 as a convenience , any more advanced solution is <span style="background-color:yellow;">welcome</span> , but I 'm simply a <span style="background-color:yellow;">human</span> movement scientist , so I 'm neither a real <span style="background-color:yellow;">programmer</span> or a mathematician , so <span style="background-color:yellow;">please</span> keep it 'simple' . </p>
<p>Edit : Here 's a link to my <span style="background-color:yellow;">array</span> <span style="background-color:yellow;">with</span> the four average <span style="background-color:yellow;">paws.</span> I used <span style="background-color:yellow;">pickle</span> to <span style="background-color:yellow;">write</span> it to the file as <span style="background-color:yellow;">was</span> suggested <span style="background-color:yellow;">here</span> </p>
<p>Here 's a version that can be loaded <span style="background-color:yellow;">with</span> np.loadtxt </p>
<hr />
<h2>Results </h2>
<p>So I tried @ <span style="background-color:yellow;">jextee</span> 's solution ( see the results below ) . As you can see , it <span style="background-color:yellow;">works</span> very on the front <span style="background-color:yellow;">paws</span> , but it <span style="background-color:yellow;">works</span> less <span style="background-color:yellow;">well</span> for the <span style="background-color:yellow;">hind</span> legs . </p>
<p>More specifically , it ca n't recognize the small <span style="background-color:yellow;">peak</span> that 's the fourth toe. This is obviously inherent to the fact that the loop looks top down towards the lowest value , <span style="background-color:yellow;">without</span> taking into account <span style="background-color:yellow;">where</span> this is . </p>
<p>Would anyone know <span style="background-color:yellow;">how</span> to tweak @ <span style="background-color:yellow;">jextee</span> 's algorithm , so that it might be able to find the <span style="background-color:yellow;">4th</span> toe too ? </p>
<p></p>
<p>Since I <span style="background-color:yellow;">have</span> n't <span style="background-color:yellow;">processed</span> any other trials yet , I ca n't supply any other samples. But the data I gave before <span style="background-color:yellow;">were</span> the averages of each <span style="background-color:yellow;">paw.</span> This file is an <span style="background-color:yellow;">array</span> <span style="background-color:yellow;">with</span> the maximal data of <span style="background-color:yellow;">9</span> <span style="background-color:yellow;">paws</span> in the order they made contact <span style="background-color:yellow;">with</span> the <span style="background-color:yellow;">plate</span> . </p>
<p>This <span style="background-color:yellow;">image</span> shows <span style="background-color:yellow;">how</span> they <span style="background-color:yellow;">were</span> spatially spread out over the <span style="background-color:yellow;">plate</span> . </p>
<p></p>
<h2>Update : </h2>
<p>I <span style="background-color:yellow;">have</span> set up a blog for anyone interested and I <span style="background-color:yellow;">have</span> setup a SkyDrive <span style="background-color:yellow;">with</span> all the raw measurements. So to anyone requesting more data : more <span style="background-color:yellow;">power</span> to you ! </p>
<hr />
<h2>New update : </h2>
<p>So after the <span style="background-color:yellow;">help</span> I got <span style="background-color:yellow;">with</span> my questions regarding <span style="background-color:yellow;">paw</span> detection and <span style="background-color:yellow;">paw</span> <span style="background-color:yellow;">sorting</span> , I <span style="background-color:yellow;">was</span> finally able to check the toe detection for every <span style="background-color:yellow;">paw</span> ! Turns out , it does n't <span style="background-color:yellow;">work</span> so <span style="background-color:yellow;">well</span> in anything but <span style="background-color:yellow;">paws</span> sized like the one in my own example. Off course in <span style="background-color:yellow;">hindsight</span> , it 's my own fault for choosing the 2x2 so arbitrarily . </p>
<p>Here 's a nice example of <span style="background-color:yellow;">where</span> it goes <span style="background-color:yellow;">wrong</span> : a nail is being recognized as a toe and the 'heel ' is so <span style="background-color:yellow;">wide</span> , it gets recognized twice ! </p>
<p></p>
<p>The <span style="background-color:yellow;">paw</span> is too large , so taking a 2x2 size <span style="background-color:yellow;">with</span> no overlap , causes some toes to be detected twice. The other <span style="background-color:yellow;">way</span> around , in small dogs it often fails to find a <span style="background-color:yellow;">5th</span> toe , <span style="background-color:yellow;">which</span> I suspect is being caused by the 2x2 area being too large . </p>
<p>After trying the current solution on all my measurements I came to the staggering conclusion that for nearly all my small dogs it did n't find a <span style="background-color:yellow;">5th</span> toe and that in over <span style="background-color:yellow;">50</span> % of the impacts for the large dogs it <span style="background-color:yellow;">would</span> find more ! </p>
<p>So clearly I need to change it. My own guess <span style="background-color:yellow;">was</span> changing the size of the neighborhood to something smaller for small dogs and larger for large dogs. But generate_binary_structure <span style="background-color:yellow;">would</span> n't let me change the size of the <span style="background-color:yellow;">array</span> . </p>
<p>Therefore , I 'm <span style="background-color:yellow;">hoping</span> that anyone else <span style="background-color:yellow;">has</span> a better suggestion for locating the toes , <span style="background-color:yellow;">perhaps</span> <span style="background-color:yellow;">having</span> the toe area scale <span style="background-color:yellow;">with</span> the <span style="background-color:yellow;">paw</span> size ? </p>
<br /><h3>Answers ( Total-18 ) : </h3><b># <span style="background-color:yellow;">0</span> </b><br /><p>I detected the <span style="background-color:yellow;">peaks</span> using a local maximum filter . Here is the result on your first dataset of <span style="background-color:yellow;">4</span> <span style="background-color:yellow;">paws</span> : </p>
<p>I also ran it on the second dataset of <span style="background-color:yellow;">9</span> <span style="background-color:yellow;">paws</span> and it <span style="background-color:yellow;">worked</span> as <span style="background-color:yellow;">well</span> . </p>
<p>Here is <span style="background-color:yellow;">how</span> you do it : </p>
<pre><code>import numpy as np
from scipy.ndimage.filters import maximum_filter
from scipy.ndimage.morphology import generate_binary_structure, binary_erosion
import matplotlib.pyplot as pp

#for some reason I had to reshape. Numpy ignored the shape header.
paws_data = np.loadtxt("paws.txt").reshape(4,11,14)

#getting a list of images
paws = [p.squeeze() for p in np.vsplit(paws_data,4)]


def detect_peaks(image):
    """
    Takes an image and detect the peaks usingthe local maximum filter.
    Returns a boolean mask of the peaks (i.e. 1 when
    the pixel's value is the neighborhood maximum, 0 otherwise)
    """

    # define an 8-connected neighborhood
    neighborhood = generate_binary_structure(2,2)

    #apply the local maximum filter; all pixel of maximal value 
    #in their neighborhood are set to 1
    local_max = maximum_filter(image, footprint=neighborhood)==image
    #local_max is a mask that contains the peaks we are 
    #looking for, but also the background.
    #In order to isolate the peaks we must remove the background from the mask.

    #we create the mask of the background
    background = (image==0)

    #a little technicality: we must erode the background in order to 
    #successfully subtract it form local_max, otherwise a line will 
    #appear along the background border (artifact of the local maximum filter)
    eroded_background = binary_erosion(background, structure=neighborhood, border_value=1)

    #we obtain the final mask, containing only peaks, 
    #by removing the background from the local_max mask
    detected_peaks = local_max - eroded_background

    return detected_peaks


#applying the detection and plotting results
for i, paw in enumerate(paws):
    detected_peaks = detect_peaks(paw)
    pp.subplot(4,2,(2*i+1))
    pp.imshow(paw)
    pp.subplot(4,2,(2*i+2) )
    pp.imshow(detected_peaks)

pp.show()
</code></pre>
<p>All you need to do after is use <span style="background-color:yellow;">scipy.ndimage.measurements.label</span> on the mask to label all distinct objects. Then you 'll be able to <span style="background-color:yellow;">play</span> <span style="background-color:yellow;">with</span> them individually . </p>
<p>Note that the method <span style="background-color:yellow;">works</span> <span style="background-color:yellow;">well</span> because the background is not noisy. If it <span style="background-color:yellow;">were</span> , you <span style="background-color:yellow;">would</span> detect a bunch of other unwanted <span style="background-color:yellow;">peaks</span> in the background. Another important factor is the size of the neighborhood . You <span style="background-color:yellow;">will</span> need to adjust it if the <span style="background-color:yellow;">peak</span> size changes ( the should remain roughly <span style="background-color:yellow;">proportional</span> ) . </p>
<br /><b># 1 </b><br /><h3>Solution </h3>
<p>Data file : <span style="background-color:yellow;">paw.txt</span> . Source code : </p>
<pre><code>from scipy import *
from operator import itemgetter

n = 5  # how many fingers are we looking for

d = loadtxt("paw.txt")
width, height = d.shape

# Create an array where every element is a sum of 2x2 squares.

fourSums = d[:-1,:-1] + d[1:,:-1] + d[1:,1:] + d[:-1,1:]

# Find positions of the fingers.

# Pair each sum with its position number (from 0 to width*height-1),

pairs = zip(arange(width*height), fourSums.flatten())

# Sort by descending sum value, filter overlapping squares

def drop_overlapping(pairs):
    no_overlaps = []
    def does_not_overlap(p1, p2):
        i1, i2 = p1[0], p2[0]
        r1, col1 = i1 / (width-1), i1 % (width-1)
        r2, col2 = i2 / (width-1), i2 % (width-1)
        return (max(abs(r1-r2),abs(col1-col2)) >= 2)
    for p in pairs:
        if all(map(lambda prev: does_not_overlap(p,prev), no_overlaps)):
            no_overlaps.append(p)
    return no_overlaps

pairs2 = drop_overlapping(sorted(pairs, key=itemgetter(1), reverse=True))

# Take the first n with the heighest values

positions = pairs2[:n]

# Print results

print d, "\n"

for i, val in positions:
    row = i / (width-1)
    column = i % (width-1)
    print "sum = %f @ %d,%d (%d)" % (val, row, column, i)
    print d[row:row+2,column:column+2], "\n"
</code></pre>
<p>Output <span style="background-color:yellow;">without</span> overlapping squares. It seems that the same areas are selected as in your example . </p>
<h3>Some comments </h3>
<p>The tricky <span style="background-color:yellow;">part</span> is to calculate sums of all 2x2 squares. I assumed you need all of them , so there might be some overlapping. I used slices to cut the first/last columns and rows from the original 2D <span style="background-color:yellow;">array</span> , and then overlapping them all together and calculating sums . </p>
<p>To understand it better , imaging a 3x3 <span style="background-color:yellow;">array</span> : </p>
<pre><code>>>> a = arange(9).reshape(3,3) ; a
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
</code></pre>
<p>Then you can take its slices : </p>
<pre><code>>>> a[:-1,:-1]
array([[0, 1],
       [3, 4]])
>>> a[1:,:-1]
array([[3, 4],
       [6, 7]])
>>> a[:-1,1:]
array([[1, 2],
       [4, 5]])
>>> a[1:,1:]
array([[4, 5],
       [7, 8]])
</code></pre>
<p>Now imagine you stack them one above the other and sum elements at the same <span style="background-color:yellow;">positions.</span> These sums <span style="background-color:yellow;">will</span> be exactly the same sums over the 2x2 squares <span style="background-color:yellow;">with</span> the top-left corner in the same <span style="background-color:yellow;">position</span> : </p>
<pre><code>>>> sums = a[:-1,:-1] + a[1:,:-1] + a[:-1,1:] + a[1:,1:]; sums
array([[ 8, 12],
       [20, 24]])
</code></pre>
<p>When you <span style="background-color:yellow;">have</span> the sums over 2x2 squares , you can use max to find the maximum , or <span style="background-color:yellow;">sort</span> , or <span style="background-color:yellow;">sorted</span> to find the <span style="background-color:yellow;">peaks</span> . </p>
<p>To remember <span style="background-color:yellow;">positions</span> of the <span style="background-color:yellow;">peaks</span> I couple every value ( the sum ) <span style="background-color:yellow;">with</span> its ordinal <span style="background-color:yellow;">position</span> in a flattened <span style="background-color:yellow;">array</span> ( see zip ) . Then I calculate row/column <span style="background-color:yellow;">position</span> again <span style="background-color:yellow;">when</span> I <span style="background-color:yellow;">print</span> the results . </p>
<h3>Notes </h3>
<p>I allowed for the 2x2 squares to overlap. Edited version filters out some of them such that only non-overlapping squares appear in the results . </p>
<h3>Choosing fingers ( an idea ) </h3>
<p>Another <span style="background-color:yellow;">problem</span> is <span style="background-color:yellow;">how</span> to choose <span style="background-color:yellow;">what</span> is likely to be fingers out of all the <span style="background-color:yellow;">peaks.</span> I <span style="background-color:yellow;">have</span> an idea <span style="background-color:yellow;">which</span> may or may not <span style="background-color:yellow;">work.</span> I do n't <span style="background-color:yellow;">have</span> time to implement it right now , so <span style="background-color:yellow;">just</span> <span style="background-color:yellow;">pseudo-code</span> . </p>
<p>I noticed that if the front fingers stay on almost a <span style="background-color:yellow;">perfect</span> circle , the rear finger should be inside of that circle. Also , the front fingers are more or less equally spaced. We may try to use these <span style="background-color:yellow;">heuristic</span> <span style="background-color:yellow;">properties</span> to detect the fingers . </p>
<p>Pseudo code : </p>
<pre><code>select the top N finger candidates (not too many, 10 or 12)
consider all possible combinations of 5 out of N (use itertools.combinations)
for each combination of 5 fingers:
    for each finger out of 5:
        fit the best circle to the remaining 4
        => position of the center, radius
        check if the selected finger is inside of the circle
        check if the remaining four are evenly spread
        (for example, consider angles from the center of the circle)
        assign some cost (penalty) to this selection of 4 peaks + a rear finger
        (consider, probably weighted:
             circle fitting error,
             if the rear finger is inside,
             variance in the spreading of the front fingers,
             total intensity of 5 peaks)
choose a combination of 4 peaks + a rear peak with the lowest penalty
</code></pre>
<p>This is a brute-force approach. If N is relatively small , then I think it is doable. For N = 12 , there are C_12 ^ <span style="background-color:yellow;">5</span> = 792 combinations , times <span style="background-color:yellow;">5</span> <span style="background-color:yellow;">ways</span> to select a rear finger , so 3960 cases to evaluate for every <span style="background-color:yellow;">paw</span> . </p>
<br /><b># 2 </b><br /><p>This is an <span style="background-color:yellow;">image</span> registration <span style="background-color:yellow;">problem</span> . The general strategy is : </p>
<ul>Have a known example , or some kind of <span style="background-color:yellow;">prior</span> on the data . Fit your data to the example , or fit the example to your data . It <span style="background-color:yellow;">helps</span> if your data is roughly aligned in the first <span style="background-color:yellow;">place</span> . </ul>
<p>Here 's a rough and ready approach , " the dumbest thing that could <span style="background-color:yellow;">possibly</span> <span style="background-color:yellow;">work</span> " : </p>
<ul>Start <span style="background-color:yellow;">with</span> five toe coordinates in roughly the <span style="background-color:yellow;">place</span> you expect . With each one , iteratively climb to the top of the <span style="background-color:yellow;">hill.</span> i.e. given current <span style="background-color:yellow;">position</span> , move to maximum neighbouring <span style="background-color:yellow;">pixel</span> , if its value is greater than current <span style="background-color:yellow;">pixel.</span> Stop <span style="background-color:yellow;">when</span> your toe coordinates <span style="background-color:yellow;">have</span> stopped moving . </ul>
<p>To counteract the orientation <span style="background-color:yellow;">problem</span> , you could <span style="background-color:yellow;">have</span> 8 or so initial settings for the basic directions ( North , North East , etc ) . Run each one individually and throw away any results <span style="background-color:yellow;">where</span> two or more toes end up at the same <span style="background-color:yellow;">pixel.</span> I 'll think about this some more , but this kind of thing is still being researched in <span style="background-color:yellow;">image</span> <span style="background-color:yellow;">processing</span> - there are no right answers ! </p>
<p>Slightly more complex idea : ( <span style="background-color:yellow;">weighted</span> ) K-means clustering. It 's not that bad . </p>
<ul>Start <span style="background-color:yellow;">with</span> five toe coordinates , but now these are " cluster centres " . </ul>
<p>Then iterate until convergence : </p>
<ul>Assign each <span style="background-color:yellow;">pixel</span> to the closest cluster ( <span style="background-color:yellow;">just</span> make a list for each cluster ) . Calculate the center of mass of each cluster. For each cluster , this is : Sum ( coordinate * intensity value ) /Sum ( coordinate ) Move each cluster to the new centre of mass . </ul>
<p>This method <span style="background-color:yellow;">will</span> almost certainly give much better results , and you get the mass of each cluster <span style="background-color:yellow;">which</span> may <span style="background-color:yellow;">help</span> in identifying the toes . </p>
<p>( Again , you 've specified the number of clusters up front. With clustering you <span style="background-color:yellow;">have</span> to specify the density one <span style="background-color:yellow;">way</span> or another : Either choose the number of clusters , appropriate in this case , or choose a cluster radius and see <span style="background-color:yellow;">how</span> many you end up <span style="background-color:yellow;">with.</span> An example of the latter is mean-shift . ) </p>
<p>Sorry about the lack of implementation details or other specifics. I <span style="background-color:yellow;">would</span> code this up but I 've got a deadline. If nothing else <span style="background-color:yellow;">has</span> <span style="background-color:yellow;">worked</span> by next <span style="background-color:yellow;">week</span> let me know and I 'll give it a shot . </p>
<br /><b># 3 </b><br /><p>Just a couple of ideas off the top of my <span style="background-color:yellow;">head</span> : </p>
<ul>take the gradient ( derivative ) of the scan , see if that eliminates the false calls take the maximum of the local maxima </ul>
<p>You might also <span style="background-color:yellow;">want</span> to take a look at OpenCV , it 's got a fairly decent Python API and might <span style="background-color:yellow;">have</span> some functions you 'd find useful . </p>
<br /><b># <span style="background-color:yellow;">4</span> </b><br /><p>Here is an idea : you calculate the ( discrete ) Laplacian of the <span style="background-color:yellow;">image.</span> I <span style="background-color:yellow;">would</span> expect it to be ( negative and ) large at maxima , in a <span style="background-color:yellow;">way</span> that is more dramatic than in the original <span style="background-color:yellow;">images.</span> Thus , maxima could be easier to find . </p>
<p>Here is another idea : if you know the typical size of the <span style="background-color:yellow;">high-pressure</span> spots , you can first smooth your <span style="background-color:yellow;">image</span> by convoluting it <span style="background-color:yellow;">with</span> a Gaussian of the same size. This may give you simpler <span style="background-color:yellow;">images</span> to <span style="background-color:yellow;">process</span> . </p>
<br /><b># <span style="background-color:yellow;">5</span> </b><br /><p>This <span style="background-color:yellow;">problem</span> <span style="background-color:yellow;">has</span> been studied in some depth by <span style="background-color:yellow;">physicists.</span> There is a good implementation in ROOT . Look at the TSpectrum classes ( especially TSpectrum2 for your case ) and the documentation for them . </p>
<p>References : </p>
<ol>M.Morhac et al. : Background elimination methods for multidimensional coincidence gamma-ray spectra. Nuclear Instruments and Methods in Physics Research A <span style="background-color:yellow;">401</span> ( 1997 ) 113-132 . M.Morhac et al. : Efficient one- and two-dimensional Gold deconvolution and its application to gamma-ray spectra decomposition. Nuclear Instruments and Methods in Physics Research A <span style="background-color:yellow;">401</span> ( 1997 ) 385-408 . M.Morhac et al. : Identification of <span style="background-color:yellow;">peaks</span> in multidimensional coincidence gamma-ray spectra. Nuclear Instruments and Methods in Research Physics A <span style="background-color:yellow;">443</span> ( 2000 ) , 108-125 . </ol>
<p>...and for those <span style="background-color:yellow;">who</span> do n't <span style="background-color:yellow;">have</span> access to a subscription to NIM : </p>
<ul>Spectrum.doc SpectrumDec.ps.gz SpectrumSrc.ps.gz SpectrumBck.ps.gz </ul>
<br /><b># 6 </b><br /><p>Physicist 's solution : Define <span style="background-color:yellow;">5</span> <span style="background-color:yellow;">paw-markers</span> identified by their <span style="background-color:yellow;">positions</span> X_i and init them <span style="background-color:yellow;">with</span> random <span style="background-color:yellow;">positions</span> . Define some energy function combining some award for location of markers in <span style="background-color:yellow;">paws</span> ' <span style="background-color:yellow;">positions</span> <span style="background-color:yellow;">with</span> some <span style="background-color:yellow;">punishment</span> for overlap of markers ; let 's say : </p>
<pre><code>E(X_i;S)=-Sum_i(S(X_i))+alfa*Sum_ij (|X_i-Xj|<=2*sqrt(2)?1:0)
</code></pre>
<p>( S ( X_i ) is the mean force in 2x2 square around X_i , alfa is a <span style="background-color:yellow;">parameter</span> to be <span style="background-color:yellow;">peaked</span> experimentally ) </p>
<p>Now time to do some Metropolis-Hastings magic : 1. Select random marker and move it by one <span style="background-color:yellow;">pixel</span> in random direction . 2. Calculate dE , the difference of energy this move caused . 3. Get an uniform random number from <span style="background-color:yellow;">0-1</span> and call it r . <span style="background-color:yellow;">4.</span> If dE&lt ; <span style="background-color:yellow;">0</span> or exp ( -beta * dE ) &gt ; r , accept the move and go to 1 ; if not , undo the move and go to 1 . This should be repeated until the markers <span style="background-color:yellow;">will</span> converge to <span style="background-color:yellow;">paws.</span> Beta controls the scanning to optimizing tradeoff , so it should be also optimized experimentally ; it can be also constantly increased <span style="background-color:yellow;">with</span> the time of simulation ( simulated annealing ) . </p>
<br /><b># 7 </b><br /><p>Heres another approach that I used <span style="background-color:yellow;">when</span> doing something similar for a large telescope : </p>
<p>1 ) Search for the <span style="background-color:yellow;">highest</span> <span style="background-color:yellow;">pixel</span> . Once you <span style="background-color:yellow;">have</span> that , search around that for the best fit for 2x2 ( maybe maximizing the 2x2 sum ) , or do a 2d gaussian fit inside the sub region of say <span style="background-color:yellow;">4x4</span> centered on the <span style="background-color:yellow;">highest</span> <span style="background-color:yellow;">pixel</span> . </p>
<p>Then set those 2x2 <span style="background-color:yellow;">pixels</span> you <span style="background-color:yellow;">have</span> found to zero ( or maybe 3x3 ) around the <span style="background-color:yellow;">peak</span> center </p>
<p>go back to 1 ) and repeat till the <span style="background-color:yellow;">highest</span> <span style="background-color:yellow;">peak</span> falls below a noise threshold , or you <span style="background-color:yellow;">have</span> all the toes you need </p>
<br /><b># 8 </b><br /><p>It 's <span style="background-color:yellow;">probably</span> <span style="background-color:yellow;">worth</span> to try <span style="background-color:yellow;">with</span> neural networks if you are able to create some training data... but this needs many samples annotated by <span style="background-color:yellow;">hand</span> . </p>
<br /><b># <span style="background-color:yellow;">9</span> </b><br /><p>a rough outline.. . </p>
<p>you 'd <span style="background-color:yellow;">probably</span> <span style="background-color:yellow;">want</span> to use a connected components algorithm to isolate each <span style="background-color:yellow;">paw</span> region. <span style="background-color:yellow;">wiki</span> <span style="background-color:yellow;">has</span> a decent description of this ( <span style="background-color:yellow;">with</span> some code ) <span style="background-color:yellow;">here</span> : <span style="background-color:yellow;">http</span> : //en.wikipedia.org/wiki/Connected_Component_Labeling </p>
<p>you 'll <span style="background-color:yellow;">have</span> to make a decision about <span style="background-color:yellow;">whether</span> to use <span style="background-color:yellow;">4</span> or 8 connectedness. <span style="background-color:yellow;">personally</span> , for most <span style="background-color:yellow;">problems</span> i <span style="background-color:yellow;">prefer</span> 6-connectedness. anyway , once you 've separated out each " <span style="background-color:yellow;">paw</span> <span style="background-color:yellow;">print</span> " as a connected region , it should be easy enough to iterate through the region and find the maxima. once you 've found the maxima , you could iteratively enlarge the region until you reach a <span style="background-color:yellow;">predetermined</span> threshold in order to identify it as a given " toe " . </p>
<p>one subtle <span style="background-color:yellow;">problem</span> <span style="background-color:yellow;">here</span> is that as soon as you start using computer <span style="background-color:yellow;">vision</span> techniques to identify something as a right/left/front/rear <span style="background-color:yellow;">paw</span> and you start looking at individual toes , you <span style="background-color:yellow;">have</span> to start taking rotations , skews , and translations into account. this is accomplished through the analysis of so-called " moments " . there are a few different moments to consider in <span style="background-color:yellow;">vision</span> applications : </p>
<p>central moments : translation invariant normalized moments : scaling and translation invariant <span style="background-color:yellow;">hu</span> moments : translation , scale , and rotation invariant </p>
<p>more information about moments can be found by searching " <span style="background-color:yellow;">image</span> moments " on <span style="background-color:yellow;">wiki</span> . </p>
<br /><b># 10 </b><br /><p>thanks for the raw data. I 'm on the train and this is as far as I 've gotten ( my stop is coming up ) . I massaged your txt file <span style="background-color:yellow;">with</span> regexps and <span style="background-color:yellow;">have</span> <span style="background-color:yellow;">plopped</span> it into a <span style="background-color:yellow;">html</span> <span style="background-color:yellow;">page</span> <span style="background-color:yellow;">with</span> some <span style="background-color:yellow;">javascript</span> for <span style="background-color:yellow;">visualization.</span> I 'm sharing it <span style="background-color:yellow;">here</span> because some , like myself , might find it more readily <span style="background-color:yellow;">hackable</span> than <span style="background-color:yellow;">python</span> . </p>
<p>I think a good approach <span style="background-color:yellow;">will</span> be scale and rotation invariant , and my next step <span style="background-color:yellow;">will</span> be to investigate mixtures of gaussians. ( each <span style="background-color:yellow;">paw</span> <span style="background-color:yellow;">pad</span> being the center of a gaussian ) . </p>
<pre><code>    <html>
<head>
    <script type="text/javascript" src="http://vis.stanford.edu/protovis/protovis-r3.2.js"></script> 
    <script type="text/javascript">
    var heatmap = [[[0,0,0,0,0,0,0,4,4,0,0,0,0],
[0,0,0,0,0,7,14,22,18,7,0,0,0],
[0,0,0,0,11,40,65,43,18,7,0,0,0],
[0,0,0,0,14,61,72,32,7,4,11,14,4],
[0,7,14,11,7,22,25,11,4,14,65,72,14],
[4,29,79,54,14,7,4,11,18,29,79,83,18],
[0,18,54,32,18,43,36,29,61,76,25,18,4],
[0,4,7,7,25,90,79,36,79,90,22,0,0],
[0,0,0,0,11,47,40,14,29,36,7,0,0],
[0,0,0,0,4,7,7,4,4,4,0,0,0]
],[
[0,0,0,4,4,0,0,0,0,0,0,0,0],
[0,0,11,18,18,7,0,0,0,0,0,0,0],
[0,4,29,47,29,7,0,4,4,0,0,0,0],
[0,0,11,29,29,7,7,22,25,7,0,0,0],
[0,0,0,4,4,4,14,61,83,22,0,0,0],
[4,7,4,4,4,4,14,32,25,7,0,0,0],
[4,11,7,14,25,25,47,79,32,4,0,0,0],
[0,4,4,22,58,40,29,86,36,4,0,0,0],
[0,0,0,7,18,14,7,18,7,0,0,0,0],
[0,0,0,0,4,4,0,0,0,0,0,0,0],
],[
[0,0,0,4,11,11,7,4,0,0,0,0,0],
[0,0,0,4,22,36,32,22,11,4,0,0,0],
[4,11,7,4,11,29,54,50,22,4,0,0,0],
[11,58,43,11,4,11,25,22,11,11,18,7,0],
[11,50,43,18,11,4,4,7,18,61,86,29,4],
[0,11,18,54,58,25,32,50,32,47,54,14,0],
[0,0,14,72,76,40,86,101,32,11,7,4,0],
[0,0,4,22,22,18,47,65,18,0,0,0,0],
[0,0,0,0,4,4,7,11,4,0,0,0,0],
],[
[0,0,0,0,4,4,4,0,0,0,0,0,0],
[0,0,0,4,14,14,18,7,0,0,0,0,0],
[0,0,0,4,14,40,54,22,4,0,0,0,0],
[0,7,11,4,11,32,36,11,0,0,0,0,0],
[4,29,36,11,4,7,7,4,4,0,0,0,0],
[4,25,32,18,7,4,4,4,14,7,0,0,0],
[0,7,36,58,29,14,22,14,18,11,0,0,0],
[0,11,50,68,32,40,61,18,4,4,0,0,0],
[0,4,11,18,18,43,32,7,0,0,0,0,0],
[0,0,0,0,4,7,4,0,0,0,0,0,0],
],[
[0,0,0,0,0,0,4,7,4,0,0,0,0],
[0,0,0,0,4,18,25,32,25,7,0,0,0],
[0,0,0,4,18,65,68,29,11,0,0,0,0],
[0,4,4,4,18,65,54,18,4,7,14,11,0],
[4,22,36,14,4,14,11,7,7,29,79,47,7],
[7,54,76,36,18,14,11,36,40,32,72,36,4],
[4,11,18,18,61,79,36,54,97,40,14,7,0],
[0,0,0,11,58,101,40,47,108,50,7,0,0],
[0,0,0,4,11,25,7,11,22,11,0,0,0],
[0,0,0,0,0,4,0,0,0,0,0,0,0],
],[
[0,0,4,7,4,0,0,0,0,0,0,0,0],
[0,0,11,22,14,4,0,4,0,0,0,0,0],
[0,0,7,18,14,4,4,14,18,4,0,0,0],
[0,4,0,4,4,0,4,32,54,18,0,0,0],
[4,11,7,4,7,7,18,29,22,4,0,0,0],
[7,18,7,22,40,25,50,76,25,4,0,0,0],
[0,4,4,22,61,32,25,54,18,0,0,0,0],
[0,0,0,4,11,7,4,11,4,0,0,0,0],
],[
[0,0,0,0,7,14,11,4,0,0,0,0,0],
[0,0,0,4,18,43,50,32,14,4,0,0,0],
[0,4,11,4,7,29,61,65,43,11,0,0,0],
[4,18,54,25,7,11,32,40,25,7,11,4,0],
[4,36,86,40,11,7,7,7,7,25,58,25,4],
[0,7,18,25,65,40,18,25,22,22,47,18,0],
[0,0,4,32,79,47,43,86,54,11,7,4,0],
[0,0,0,14,32,14,25,61,40,7,0,0,0],
[0,0,0,0,4,4,4,11,7,0,0,0,0],
],[
[0,0,0,0,4,7,11,4,0,0,0,0,0],
[0,4,4,0,4,11,18,11,0,0,0,0,0],
[4,11,11,4,0,4,4,4,0,0,0,0,0],
[4,18,14,7,4,0,0,4,7,7,0,0,0],
[0,7,18,29,14,11,11,7,18,18,4,0,0],
[0,11,43,50,29,43,40,11,4,4,0,0,0],
[0,4,18,25,22,54,40,7,0,0,0,0,0],
[0,0,4,4,4,11,7,0,0,0,0,0,0],
],[
[0,0,0,0,0,7,7,7,7,0,0,0,0],
[0,0,0,0,7,32,32,18,4,0,0,0,0],
[0,0,0,0,11,54,40,14,4,4,22,11,0],
[0,7,14,11,4,14,11,4,4,25,94,50,7],
[4,25,65,43,11,7,4,7,22,25,54,36,7],
[0,7,25,22,29,58,32,25,72,61,14,7,0],
[0,0,4,4,40,115,68,29,83,72,11,0,0],
[0,0,0,0,11,29,18,7,18,14,4,0,0],
[0,0,0,0,0,4,0,0,0,0,0,0,0],
]
];
</script>
</head>
<body>
    <script type="text/javascript+protovis">    
    for (var a=0; a < heatmap.length; a++) {
    var w = heatmap[a][0].length,
    h = heatmap[a].length;
var vis = new pv.Panel()
    .width(w * 6)
    .height(h * 6)
    .strokeStyle("#aaa")
    .lineWidth(4)
    .antialias(true);
vis.add(pv.Image)
    .imageWidth(w)
    .imageHeight(h)
    .image(pv.Scale.linear()
        .domain(0, 99, 100)
        .range("#000", "#fff", '#ff0a0a')
        .by(function(i, j) heatmap[a][j][i]));
vis.render();
}
</script>
  </body>
</html>
</code></pre>
<p></p>
<br /><b># 11 </b><br /><p>Well , <span style="background-color:yellow;">here</span> 's some simple and not terribly efficient code , but for this size of a data set it is fine . </p>
<pre><code>import numpy as np
grid = np.array([[0,0,0,0,0,0,0,0,0,0,0,0,0,0],
              [0,0,0,0,0,0,0,0,0.4,0.4,0.4,0,0,0],
              [0,0,0,0,0.4,1.4,1.4,1.8,0.7,0,0,0,0,0],
              [0,0,0,0,0.4,1.4,4,5.4,2.2,0.4,0,0,0,0],
              [0,0,0.7,1.1,0.4,1.1,3.2,3.6,1.1,0,0,0,0,0],
              [0,0.4,2.9,3.6,1.1,0.4,0.7,0.7,0.4,0.4,0,0,0,0],
              [0,0.4,2.5,3.2,1.8,0.7,0.4,0.4,0.4,1.4,0.7,0,0,0],
              [0,0,0.7,3.6,5.8,2.9,1.4,2.2,1.4,1.8,1.1,0,0,0],
              [0,0,1.1,5,6.8,3.2,4,6.1,1.8,0.4,0.4,0,0,0],
              [0,0,0.4,1.1,1.8,1.8,4.3,3.2,0.7,0,0,0,0,0],
              [0,0,0,0,0,0.4,0.7,0.4,0,0,0,0,0,0]])

arr = []
for i in xrange(grid.shape[0] - 1):
    for j in xrange(grid.shape[1] - 1):
        tot = grid[i][j] + grid[i+1][j] + grid[i][j+1] + grid[i+1][j+1]
        arr.append([(i,j),tot])

best = []

arr.sort(key = lambda x: x[1])

for i in xrange(5):
    best.append(arr.pop())
    badpos = set([(best[-1][0][0]+x,best[-1][0][1]+y)
                  for x in [-1,0,1] for y in [-1,0,1] if x != 0 or y != 0])
    for j in xrange(len(arr)-1,-1,-1):
        if arr[j][0] in badpos:
            arr.pop(j)


for item in best:
    print grid[item[0][0]:item[0][0]+2,item[0][1]:item[0][1]+2]
</code></pre>
<p>I basically <span style="background-color:yellow;">just</span> make an <span style="background-color:yellow;">array</span> <span style="background-color:yellow;">with</span> the <span style="background-color:yellow;">position</span> of the upper-left and the sum of each 2x2 square and <span style="background-color:yellow;">sort</span> it by the sum. I then take the 2x2 square <span style="background-color:yellow;">with</span> the <span style="background-color:yellow;">highest</span> sum out of contention , <span style="background-color:yellow;">put</span> it in the best <span style="background-color:yellow;">array</span> , and remove all other 2x2 squares that used any <span style="background-color:yellow;">part</span> of this <span style="background-color:yellow;">just</span> removed 2x2 square . </p>
<p>It seems to <span style="background-color:yellow;">work</span> fine except <span style="background-color:yellow;">with</span> the last <span style="background-color:yellow;">paw</span> ( the one <span style="background-color:yellow;">with</span> the smallest sum on the far right in your first <span style="background-color:yellow;">picture</span> ) , it turns out that there are two other eligible 2x2 squares <span style="background-color:yellow;">with</span> a larger sum ( and they <span style="background-color:yellow;">have</span> an equal sum to each other ) . One of them is still selects one square from your 2x2 square , but the other is off to the left. Fortunately , by luck <span style="background-color:yellow;">we</span> see to be choosing more of the one that you <span style="background-color:yellow;">would</span> <span style="background-color:yellow;">want</span> , but this may require some other ideas to be used to get <span style="background-color:yellow;">what</span> you actually <span style="background-color:yellow;">want</span> all of the time . </p>
<br /><b># 12 </b><br /><p>It seems you can cheat a bit using <span style="background-color:yellow;">jetxee</span> 's algorithm. He is finding the first three toes fine , and you should be able to guess <span style="background-color:yellow;">where</span> the fourth is based off that . </p>
<br /><b># 13 </b><br /><p>Perhaps you can use something like Gaussian Mixture Models. Here 's a Python <span style="background-color:yellow;">package</span> for doing GMMs ( <span style="background-color:yellow;">just</span> did a Google search ) <span style="background-color:yellow;">http</span> : //www.ar.media.kyoto-u.ac.jp/members/david/softwares/em/ </p>
<br /><b># 14 </b><br /><p>Interesting <span style="background-color:yellow;">problem.</span> The solution I <span style="background-color:yellow;">would</span> try is the following . </p>
<ol>Apply a low <span style="background-color:yellow;">pass</span> filter , such as convolution <span style="background-color:yellow;">with</span> a 2D gaussian mask. This <span style="background-color:yellow;">will</span> give you a bunch of ( <span style="background-color:yellow;">probably</span> , but not necessarily floating <span style="background-color:yellow;">point</span> ) values . Perform a 2D non-maximal suppression using the known approximate radius of each <span style="background-color:yellow;">paw</span> <span style="background-color:yellow;">pad</span> ( or toe ) . </ol>
<p>This should give you the maximal <span style="background-color:yellow;">positions</span> <span style="background-color:yellow;">without</span> <span style="background-color:yellow;">having</span> multiple candidates <span style="background-color:yellow;">which</span> are close together. Just to clarify , the radius of the mask in step 1 should also be similar to the radius used in step 2. This radius could be selectable , or the vet could explicitly measure it beforehand ( it <span style="background-color:yellow;">will</span> vary <span style="background-color:yellow;">with</span> age/breed/etc ) . </p>
<p>Some of the solutions suggested ( mean shift , neural nets , and so on ) <span style="background-color:yellow;">probably</span> <span style="background-color:yellow;">will</span> <span style="background-color:yellow;">work</span> to some degree , but are overly complicated and <span style="background-color:yellow;">probably</span> not ideal . </p>
<br /><b># 15 </b><br /><p>Maybe a naive approach is sufficient <span style="background-color:yellow;">here</span> : Build a list of all 2x2 squares on your <span style="background-color:yellow;">plane</span> , order them by their sum ( in descending order ) . </p>
<p>First , select the <span style="background-color:yellow;">highest-valued</span> square into your " <span style="background-color:yellow;">paw</span> list " . Then , iteratively <span style="background-color:yellow;">pick</span> <span style="background-color:yellow;">4</span> of the next-best squares that do n't intersect <span style="background-color:yellow;">with</span> any of the <span style="background-color:yellow;">previously</span> found squares . </p>
<br /><b># 16 </b><br /><p>What if you <span style="background-color:yellow;">proceed</span> step by step : you first locate the global maximum , <span style="background-color:yellow;">process</span> if needed the surrounding <span style="background-color:yellow;">points</span> given their value , then set the found region to zero , and repeat for the next one . </p>
<br /><b># 17 </b><br /><p>I am not sure this answers the question , but it seems like you can <span style="background-color:yellow;">just</span> look for the n <span style="background-color:yellow;">highest</span> <span style="background-color:yellow;">peaks</span> that do n't <span style="background-color:yellow;">have</span> neighbors . </p>
<p>Here is the gist. Note that it 's in Ruby , but the idea should be clear . </p>
<p><span style="background-color:yellow;">http</span> : //gist.github.com/574052 </p>
<br />