<h3>Question ( ID-2130202 ) : </h3><h2>put stockprices <span style="background-color:yellow;">into</span> <span style="background-color:yellow;">groups</span> when they are within <span style="background-color:yellow;">0.5</span> % of each other </h2><p>Thanks for the answers , I have not used StackOverflow before so I was suprised by the number of answers and the speed of them - <span style="background-color:yellow;">its</span> fantastic . </p>
<p>I have not been through the answers properly yet , but thought I should add some <span style="background-color:yellow;">information</span> to the problem specification. See the <span style="background-color:yellow;">image</span> below . </p>
<p>I ca n't post an <span style="background-color:yellow;">image</span> <span style="background-color:yellow;">in</span> this because <span style="background-color:yellow;">i</span> do n't have enough points but you can see an <span style="background-color:yellow;">image</span> at http : //journal.acquitane.com/2010-01-20/image003.jpg </p>
<p>This <span style="background-color:yellow;">image</span> may describe more closely what I 'm trying to achieve. So you can see on the horizontal lines across the page are price points on the chart. Now where you get a clustering of lines within <span style="background-color:yellow;">0.5</span> % of each , this <span style="background-color:yellow;">is</span> considered to be a good thing and why I want to <span style="background-color:yellow;">identify</span> those clusters automatically. You can see on the chart that there <span style="background-color:yellow;">is</span> a cluster at S2 &amp ; MR1 , R2 &amp ; WPP1 . </p>
<p>So everyday I produce these price points and then I can <span style="background-color:yellow;">identify</span> manually those that are within <span style="background-color:yellow;">0.5</span> % . - but the purpose of this question <span style="background-color:yellow;">is</span> how to do <span style="background-color:yellow;">it</span> with a python routine . </p>
<p>I have reproduced the list again ( see below ) with labels. Just be aware that the list price points do n't match the price points <span style="background-color:yellow;">in</span> the <span style="background-color:yellow;">image</span> because they are from two different days . </p>
<p>[ YR3,175.24,8 ] [ SR3,147.85,6 ] [ YR2,144.13,8 ] [ SR2,130.44,6 ] [ YR1,127.79,8 ] [ QR3,127.42,5 ] [ SR1,120.94,6 ] [ QR2,120.22,5 ] [ MR3,118.10,3 ] [ WR3,116.73,2 ] [ DR3,116.23,1 ] [ WR2,115.93,2 ] [ QR1,115.83,5 ] [ MR2,115.56,3 ] [ DR2,115.53,1 ] [ WR1,114.79,2 ] [ DR1,114.59,1 ] [ WPP,113.99,2 ] [ DPP,113.89,1 ] [ MR1,113.50,3 ] [ DS1,112.95,1 ] [ WS1,112.85,2 ] [ DS2,112.25,1 ] [ WS2,112.05,2 ] [ DS3,111.31,1 ] [ MPP,110.97,3 ] [ WS3,110.91,2 ] [ <span style="background-color:yellow;">50MA,110.87,4</span> ] [ MS1,108.91,3 ] [ QPP,108.64,5 ] [ MS2,106.37,3 ] [ MS3,104.31,3 ] [ QS1,104.25,5 ] [ SPP,103.53,6 ] [ 200MA,99.42,7 ] [ QS2,97.05,5 ] [ YPP,96.68,8 ] [ SS1,94.03,6 ] [ QS3,92.66,5 ] [ YS1,80.34,8 ] [ SS2,76.62,6 ] [ SS3,67.12,6 ] [ YS2,49.23,8 ] [ YS3,32.89,8 ] </p>
<p>I did make a mistake with the original list <span style="background-color:yellow;">in</span> that <span style="background-color:yellow;">Group</span> C <span style="background-color:yellow;">is</span> wrong and should not be <span style="background-color:yellow;">included.</span> Thanks for pointing that out . </p>
<p>Also the <span style="background-color:yellow;">0.5</span> % <span style="background-color:yellow;">is</span> not fixed this <span style="background-color:yellow;">value</span> will change from day to day , but I have just used <span style="background-color:yellow;">0.5</span> % as an example for spec'ing the problem . </p>
<p>Thanks Again . Mark </p>
<p>PS. I will get cracking on checking the answers now now . </p>
<p>Hi : </p>
<p>I need to do some manipulation of stock prices. I have just started using Python , ( but I think I would have trouble <span style="background-color:yellow;">implementing</span> this <span style="background-color:yellow;">in</span> any language ) . I 'm looking for some <span style="background-color:yellow;">ideas</span> on how to <span style="background-color:yellow;">implement</span> this nicely <span style="background-color:yellow;">in</span> python . </p>
<p>Thanks Mark </p>
<p>Problem : I have a list of lists ( FloorLevels ( see below ) ) where the sublist has two <span style="background-color:yellow;">items</span> ( stockprice , weight ) . I want to put the stockprices <span style="background-color:yellow;">into</span> <span style="background-color:yellow;">groups</span> when they are within <span style="background-color:yellow;">0.5</span> % of each other. A <span style="background-color:yellow;">groups</span> strength will be determined by <span style="background-color:yellow;">its</span> total weight. For example : </p>
<pre><code>Group-A
115.93,2
115.83,5
115.56,3
115.53,1
-------------
TotalWeight:12
-------------
Group-B
113.50,3
112.95,1
112.85,2
-------------
TotalWeight:6
-------------    

FloorLevels[   
[175.24,8]
[147.85,6]
[144.13,8]
[130.44,6]
[127.79,8]
[127.42,5]
[120.94,6]
[120.22,5]
[118.10,3]
[116.73,2]
[116.23,1]
[115.93,2]
[115.83,5]
[115.56,3]
[115.53,1]
[114.79,2]
[114.59,1]
[113.99,2]
[113.89,1]
[113.50,3]
[112.95,1]
[112.85,2]
[112.25,1]
[112.05,2]
[111.31,1]
[110.97,3]
[110.91,2]
[110.87,4]
[108.91,3]
[108.64,5]
[106.37,3]
[104.31,3]
[104.25,5]
[103.53,6]
[99.42,7]
[97.05,5]
[96.68,8]
[94.03,6]
[92.66,5]
[80.34,8]
[76.62,6]
[67.12,6]
[49.23,8]
[32.89,8]
]
</code></pre>
<br /><h3>Answers ( Total-7 ) : </h3><b># <span style="background-color:yellow;">0</span> </b><br /><p>I suggest a repeated use of k-means clustering -- let 's call <span style="background-color:yellow;">it</span> KMC for short. KMC <span style="background-color:yellow;">is</span> a simple and powerful clustering algorithm... but <span style="background-color:yellow;">it</span> needs to " be told " how many clusters , k , you 're aiming for. You do n't know that <span style="background-color:yellow;">in</span> advance ( <span style="background-color:yellow;">if</span> I understand you correctly ) -- you just want the smallest k such that no two <span style="background-color:yellow;">items</span> " clustered together " are more than X % apart from each other. So , start with k equal 1 -- everything bunched together , no clustering pass needed ; - ) -- and check the <span style="background-color:yellow;">diameter</span> of the cluster ( a cluster 's " <span style="background-color:yellow;">diameter</span> " , from the use of the term <span style="background-color:yellow;">in</span> geometry , <span style="background-color:yellow;">is</span> the largest distance between any two members of a cluster ) . </p>
<p>If the <span style="background-color:yellow;">diameter</span> <span style="background-color:yellow;">is</span> &gt ; X % , set k + = 1 , perform KMC with k as the number of clusters , and repeat the check , <span style="background-color:yellow;">iteratively</span> . </p>
<p>In pseudo-code : </p>
<pre><code>def markCluster(items, threshold):
    k = 1
    clusters = [items]
    maxdist = diameter(items)
    while maxdist > threshold:
        k += 1
        clusters = Kmc(items, k)
        maxdist = max(diameter(c) for c in clusters)
    return clusters
</code></pre>
<p>assuming of course we have suitable <span style="background-color:yellow;">diameter</span> and Kmc Python functions . </p>
<p>Does this sound like the kind of thing you want ? If so , then we can move on to show you how to write <span style="background-color:yellow;">diameter</span> and Kmc ( <span style="background-color:yellow;">in</span> pure Python <span style="background-color:yellow;">if</span> you have a relatively limited number of <span style="background-color:yellow;">items</span> to deal with , otherwise maybe by exploiting powerful third-party add-on frameworks such as numpy ) -- but <span style="background-color:yellow;">it</span> 's not worthwhile to go to such trouble <span style="background-color:yellow;">if</span> you actually want something pretty different , whence this check ! - ) </p>
<br /><b># 1 </b><br /><p>A stock s belong <span style="background-color:yellow;">in</span> a <span style="background-color:yellow;">group</span> G <span style="background-color:yellow;">if</span> for each stock t <span style="background-color:yellow;">in</span> G , s * 1.05 &gt ; = t and s / 1.05 &lt ; = t , right ? </p>
<p>How do we add the stocks to each <span style="background-color:yellow;">group</span> ? If we have the stocks 95 , 100 , 101 , and 105 , and we start a <span style="background-color:yellow;">group</span> with 100 , then add 101 , we will end up with { 100 , 101 , 105 } . If we did 95 after 100 , we 'd end up with { 100 , 95 } . </p>
<p>Do we just need to consider all possible permutations ? If so , your algorithm <span style="background-color:yellow;">is</span> going to be <span style="background-color:yellow;">inefficient</span> . </p>
<br /><b># 2 </b><br /><p>You need to specify your problem <span style="background-color:yellow;">in</span> more detail. Just what does " put the stockprices <span style="background-color:yellow;">into</span> <span style="background-color:yellow;">groups</span> when they are within <span style="background-color:yellow;">0.5</span> % of each other " mean ? </p>
<p>Possibilities : </p>
<p>( 1 ) each member of the <span style="background-color:yellow;">group</span> <span style="background-color:yellow;">is</span> within <span style="background-color:yellow;">0.5</span> % of every other member of the <span style="background-color:yellow;">group</span> </p>
<p>( 2 ) sort the list and split <span style="background-color:yellow;">it</span> where the gap <span style="background-color:yellow;">is</span> more than <span style="background-color:yellow;">0.5</span> % </p>
<p>Note that 116.23 <span style="background-color:yellow;">is</span> within <span style="background-color:yellow;">0.5</span> % of 115.93 -- abs ( ( 116.23 / 115.93 - 1 ) * 100 ) &lt ; <span style="background-color:yellow;">0.5</span> -- but you have put one number <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">Group</span> A and one <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">Group</span> C . </p>
<p>Simple example : a , b , c = ( <span style="background-color:yellow;">0.996</span> , 1 , 1.004 ) ... Note that a and b fit , b and c fit , but a and c do n't fit. How do you want them <span style="background-color:yellow;">grouped</span> , and why ? Is the order <span style="background-color:yellow;">in</span> the <span style="background-color:yellow;">input</span> list relevant ? </p>
<p>Possibility ( 1 ) produces ab,c or a,bc ... tie-breaking rule , please Possibility ( 2 ) produces abc ( no big gaps , so only one <span style="background-color:yellow;">group</span> ) </p>
<br /><b># 3 </b><br /><p>You wo n't be able to classify them <span style="background-color:yellow;">into</span> hard " <span style="background-color:yellow;">groups</span> " . If you have prices ( 1.0,1.05 , 1.1 ) then the first and second should be <span style="background-color:yellow;">in</span> the same <span style="background-color:yellow;">group</span> , and the second and third should be <span style="background-color:yellow;">in</span> the same <span style="background-color:yellow;">group</span> , but not the first and third . </p>
<p>A quick , dirty way to do something that you might find useful : </p>
<pre><code>def make_group_function(tolerance = 0.05):
    from math import log10, floor
    # I forget why this works. 
    tolerance_factor = -1.0/(-log10(1.0 + tolerance))
    # well ... since you might ask
    # we want: log(x)*tf - log(x*(1+t))*tf = -1, 
    # so every 5% change has a different group. The minus is just so groups 
    # are ascending .. it looks a bit nicer.
    #
    # tf = -1/(log(x)-log(x*(1+t)))
    # tf = -1/(log(x/(x*(1+t))))
    # tf = -1/(log(1/(1*(1+t)))) # solved .. but let's just be more clever
    # tf = -1/(0-log(1*(1+t)))
    # tf = -1/(-log((1+t))
    def group_function(value):
        # don't just use int - it rounds up below zero, and down above zero
        return int(floor(log10(value)*tolerance_factor))
    return group_function
</code></pre>
<p>Usage : </p>
<pre><code>group_function = make_group_function()
import random
groups = {}
for i in range(50):
    v = random.random()*500+1000
    group = group_function(v)
    if group in groups:
        groups[group].append(v)
    else:
        groups[group] = [v]

for group in sorted(groups):
    print 'Group',group
    for v in sorted(groups[group]):
        print v
    print
</code></pre>
<br /><b># 4 </b><br /><p>For a given set of stock prices , there <span style="background-color:yellow;">is</span> probably more than one way to <span style="background-color:yellow;">group</span> stocks that are within <span style="background-color:yellow;">0.5</span> % of each other. Without some additional rules for <span style="background-color:yellow;">grouping</span> the prices , there 's no way to be sure an answer will do what you really want . </p>
<br /><b># 5 </b><br /><p>apart from the proper way to pick which <span style="background-color:yellow;">values</span> fit together , this <span style="background-color:yellow;">is</span> a problem where a little Object Orientation dropped <span style="background-color:yellow;">in</span> can make <span style="background-color:yellow;">it</span> a lot easier to deal with . </p>
<p>I made two classes here , with a minimum of desirable behaviors , but which can make the classification a lot easier -- you get a single point to play with <span style="background-color:yellow;">it</span> on the <span style="background-color:yellow;">Group</span> class . </p>
<p>I can see the code bellow <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">incorrect</span> , <span style="background-color:yellow;">in</span> the sense the limtis for <span style="background-color:yellow;">group</span> <span style="background-color:yellow;">inclusion</span> <span style="background-color:yellow;">varies</span> as new members are added -- even <span style="background-color:yellow;">it</span> the separation crieteria remaisn teh same , you heva e torewrite the <span style="background-color:yellow;">get_groups</span> method to use a multi-pass approach. It should nto be hard -- but the code would be too long to be helpfull here , and <span style="background-color:yellow;">i</span> think this snipped <span style="background-color:yellow;">is</span> enoguh to get you going : </p>
<pre><code>from copy import copy

class Group(object):
    def __init__(self,data=None, name=""):
        if data:
            self.data = data
        else:
            self.data = []
        self.name = name

    def get_mean_stock(self):
        return sum(item[0] for item in self.data) / len(self.data)

    def fits(self, item):
        if 0.995 < abs(item[0]) / self.get_mean_stock() < 1.005:
            return True
        return False

    def get_weight(self):
        return sum(item[1] for item in self.data)

    def __repr__(self):
        return "Group-%s\n%s\n---\nTotalWeight: %d\n\n" % (
            self.name,
            "\n".join("%.02f, %d" % tuple(item) for item in self.data ),
            self.get_weight())


class StockGrouper(object):
    def __init__(self, data=None):
        if data:
            self.floor_levels = data
        else:
            self.floor_levels = []

    def get_groups(self):
        groups = []
        floor_levels = copy(self.floor_levels)
        name_ord = ord("A") - 1
        while floor_levels:
            seed = floor_levels.pop(0)
            name_ord += 1
            group = Group([seed], chr(name_ord))
            groups.append(group)
            to_remove = []
            for i, item in enumerate(floor_levels):
                if group.fits(item):
                    group.data.append(item)
                    to_remove.append(i)
            for i in reversed(to_remove):
                floor_levels.pop(i)
        return groups
</code></pre>
<p>testing : </p>
<pre><code>floor_levels = [  [stock. weight] ,... <paste the data above> ]
s = StockGrouper(floor_levels)
s.get_groups()
</code></pre>
<br /><b># 6 </b><br /><p>For the <span style="background-color:yellow;">grouping</span> element , could you use <span style="background-color:yellow;">itertools.groupby</span> ( ) ? As the data <span style="background-color:yellow;">is</span> sorted , a lot of the work of <span style="background-color:yellow;">grouping</span> <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">is</span> already done , and then you could test <span style="background-color:yellow;">if</span> the current <span style="background-color:yellow;">value</span> <span style="background-color:yellow;">in</span> the <span style="background-color:yellow;">iteration</span> was different to the last by &lt ; <span style="background-color:yellow;">0.5</span> % , and have <span style="background-color:yellow;">itertools.groupby</span> ( ) break <span style="background-color:yellow;">into</span> a new <span style="background-color:yellow;">group</span> every time your function returned false . </p>
<br />