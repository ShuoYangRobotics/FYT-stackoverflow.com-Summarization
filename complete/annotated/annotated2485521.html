<h3>Question ( ID-2485521 ) : </h3><h2>Python mistaking float for string </h2><p>I receive </p>
<pre><code>TypeError: Can't convert 'float' object to str implicitly
</code></pre>
<p>while using </p>
<pre><code>Gambler.pot += round(self.bet + self.money * 0.1)
</code></pre>
<p>where pot , bet , and money are all doubles ( or at least are supposed to be ) . I 'm not sure if this is yet another Eclipse thing , but how do I get the line to compile ? </p>
<p>Code where bet and money are initialized : </p>
<pre><code>class Gambler:
    money = 0
    bet = 0
</code></pre>
<p>Test case : </p>
<pre><code>number = 0
print("Here, the number is a {0}".format(type(number)))
number = input("Enter in something: ")
print("But now, it has turned into a {0}".format(type(number)))
</code></pre>
<p>Output from test case : </p>
<pre><code>Here, the number is a <class 'int'>
Enter in something: 1
But now, it has turned into a <class 'str'>
</code></pre>
<p>Apparently , input ( ) is changing it to a string . </p>
<p>EDIT : Finally fixed the problem ( I think ) with </p>
<pre><code>self.bet = int(self.bet.strip())
</code></pre>
<p>after the user inputs the value. Though I dunno if that 's the best way to fix the problem : ) </p>
<p>A better solution by Daniel G. : </p>
<pre><code>self.bet = float(input("How much would you like to bet? $"))
</code></pre>
<br /><h3>Answers ( Total-6 ) : </h3><b># 0 </b><br /><p>input ( ) in 3.x only returns strings. It is the programmer 's job to pass it to a numeric constructor in order to turn it into a number . </p>
<br /><b># 1 </b><br /><p>Are you initializing pot ? Have you tried storing intermediate results to track down here the problem is coming from ? And finally , do you know about <span style="background-color:yellow;">pdb</span> ? That may be a big help . </p>
<pre><code>class Gambler:
    pot = 0.0
    def __init__(self, money=0.0)
        self.pot = 0.0
        self.bet = 0.0
        self.money = money

    def update_pot(self):
        import pdb; pdb.set_trace()
        to_pot = self.bet + self.money * 0.1
        to_pot = round(to_pot)
        Gambler.pot = Gambler.pot + to_pot
</code></pre>
<p>You will get a prompt when the set_trace ( ) line is executed. Try looking at the current values when you get there . </p>
<pre><code>(Pdb) h    # help
(Pdb) n    # go to next statement
(Pdb) l    # list source code
...
(Pdb) to_pot
...
(Pdb) self.bet
...
(Pdb) self.money
...
(Pdb) Gambler.pot
...
(Pdb) c    # continue
</code></pre>
<br /><b># 2 </b><br /><p>If any of <span style="background-color:yellow;">Gambler.pot</span> , <span style="background-color:yellow;">self.bet</span> or <span style="background-color:yellow;">self.money</span> have somehow become strings ( because they were set to a string at some point ) , + will be taken to mean string concatenation which causes the error message you see . </p>
<br /><b># 3 </b><br /><p>Python3.2 ( py3k : 77602 ) gives these error messages : </p>
<pre>
>>> "1.2" * 0.1                                                #1
Traceback (most recent call last):
  File "", line 1, in 
TypeError: can't multiply sequence by non-int of type 'float'
>>> "3.4" + 1.2 * 0.1                                          #2
Traceback (most recent call last):
  File "", line 1, in 
TypeError: Can't convert 'float' object to str implicitly
>>> n = "42"
>>> n += round(3.4 + 1.2 * 0.1)                                #3
Traceback (most recent call last):
  File "", line 1, in 
TypeError: Can't convert 'int' object to str implicitly
</pre>
<p>I suspect your error message is because one of your actual values is a string instead of the expected float in a scenario similar to # 2 , which is an exact match for your exception . </p>
<p>If you could write a test case , that would be a big help . </p>
<hr />
<p>Remember that Py3.x 's input is identical to Py2.x 's raw _input , and Py2.x 's input is gone ( it 's equivalent to using evai , which you do n't want to do ) . Because of this , input in 3.x will always return a string. Use int to convert : </p>
<pre><code>n = int(input("Enter a number: "))
</code></pre>
<p>If you want to handle input errors , then catch ValueError , which is what int raises on errors : </p>
<pre><code>try:
  n = int(input("Enter a number: "))
except ValueError:
  print("invalid input")
else:
  print("squared:", n*n)
</code></pre>
<br /><b># 4 </b><br /><p>In Python 3.x , input ( ) replaces Python 2.x 's raw_input ( ) . Therefore , the function input ( ) returns the exact string that the user input ( as raw_input ( ) did in previous versions ) . </p>
<p>To get Python 2.x behavior , you can just do </p>
<pre><code>number = eval(input("Please enter a number: "))
</code></pre>
<p>However , I would n't recommend using " eval " since the user can put any line of Python they want in there , which is probably not what you want. If you know you want a float , just tell Python that 's what you want : </p>
<pre><code>number = float(input("Please enter a number: "))
</code></pre>
<br /><b># 5 </b><br /><p>As was said in a comment , what you 've shown is initializing local variables to 0. Instead try something like : </p>
<pre><code>class Gambler:
    def __init__(self):
        self.bet = 0.0
        self.money = 0.0

    def calc_pot(self):
        self.pot = round(self.bet  + self.money * 0.1)

g = Gambler()
g.bet = 2.0
g.money = 5.0
g.calc_pot()

print "Pot = %f" % (g.pot)
</code></pre>
<p>Also , make sure there 's nothing that might be turning those members into strings . </p>
<br />