<h3>Question ( ID-6789649 ) : </h3><h2>How can I get <span style="background-color:yellow;">this</span> Python code <span style="background-color:yellow;">to</span> run more quickly ? [ Project Euler Problem # 7 ] </h2><p>I 'm <span style="background-color:yellow;">trying</span> <span style="background-color:yellow;">to</span> complete <span style="background-color:yellow;">this</span> Project Euler challenge : </p>
<blockquote>By listing <span style="background-color:yellow;">the</span> first six prime <span style="background-color:yellow;">numbers</span> : 2 , 3 , 5 , 7 , 11 , and 13 , <span style="background-color:yellow;">we</span> can see <span style="background-color:yellow;">that</span> <span style="background-color:yellow;">the</span> 6th prime <span style="background-color:yellow;">is</span> 13 . What <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">the</span> 10 001st prime <span style="background-color:yellow;">number</span> ? </blockquote>
<p>My code seem <span style="background-color:yellow;">to</span> be right because <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">works</span> <span style="background-color:yellow;">with</span> small <span style="background-color:yellow;">numbers</span> , e.g 6th prime <span style="background-color:yellow;">is</span> 13 . </p>
<p>How can <span style="background-color:yellow;">i</span> <span style="background-color:yellow;">improve</span> <span style="background-color:yellow;">it</span> so <span style="background-color:yellow;">that</span> <span style="background-color:yellow;">the</span> code <span style="background-color:yellow;">will</span> run much more quickly for larger <span style="background-color:yellow;">numbers</span> such as 10 001 . </p>
<p>Code <span style="background-color:yellow;">is</span> below : </p>
<pre><code>#Checks if a number is a prime
def is_prime(n):
    count = 0
    for i in range(2, n):
        if n%i == 0:
            return False
            break
        else:
            count += 1
    if count == n-2:
        return True

#Finds the value for the given nth term     
def term(n):
    x = 0
    count = 0
    while count != n:
        x += 1
        if is_prime(x) == True:
            count += 1
    print x


term(10001)
</code></pre>
<p>UPDATE : </p>
<p>Thanks for your responses. I should have been more clear , I am <span style="background-color:yellow;">not</span> looking <span style="background-color:yellow;">to</span> speed up <span style="background-color:yellow;">the</span> <span style="background-color:yellow;">interpreter</span> <span style="background-color:yellow;">or</span> finding a faster <span style="background-color:yellow;">interpreter</span> , because <span style="background-color:yellow;">i</span> know my code <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">n't</span> great , so <span style="background-color:yellow;">i</span> <span style="background-color:yellow;">was</span> looking for <span style="background-color:yellow;">ways</span> <span style="background-color:yellow;">of</span> make my code more efficient . </p>
<br /><h3>Answers ( Total-7 ) : </h3><b># 0 </b><br /><p>The purpose <span style="background-color:yellow;">of</span> Project Euler <span style="background-color:yellow;">is</span> <span style="background-color:yellow;">not</span> really <span style="background-color:yellow;">to</span> <span style="background-color:yellow;">think</span> learn programming , but <span style="background-color:yellow;">to</span> <span style="background-color:yellow;">think</span> about algorithms . On problem # 10 , your algorithm <span style="background-color:yellow;">will</span> <span style="background-color:yellow;">need</span> <span style="background-color:yellow;">to</span> be even faster <span style="background-color:yellow;">than</span> <span style="background-color:yellow;">on</span> # 7 , etc. etc. So you <span style="background-color:yellow;">need</span> <span style="background-color:yellow;">to</span> come up <span style="background-color:yellow;">with</span> a better <span style="background-color:yellow;">way</span> <span style="background-color:yellow;">to</span> find prime <span style="background-color:yellow;">numbers</span> , <span style="background-color:yellow;">not</span> a faster <span style="background-color:yellow;">way</span> <span style="background-color:yellow;">to</span> run Python code. People solve <span style="background-color:yellow;">these</span> problems under <span style="background-color:yellow;">the</span> <span style="background-color:yellow;">time</span> limit <span style="background-color:yellow;">with</span> far slower computers <span style="background-color:yellow;">that</span> you 're using <span style="background-color:yellow;">now</span> by <span style="background-color:yellow;">thinking</span> about <span style="background-color:yellow;">the</span> <span style="background-color:yellow;">math</span> . </p>
<p>On <span style="background-color:yellow;">that</span> <span style="background-color:yellow;">note</span> , maybe ask about your prime <span style="background-color:yellow;">number</span> algorithm <span style="background-color:yellow;">on</span> http : //math.stackexchange.com/ <span style="background-color:yellow;">if</span> you really <span style="background-color:yellow;">need</span> help <span style="background-color:yellow;">thinking</span> about <span style="background-color:yellow;">the</span> problem . </p>
<br /><b># 1 </b><br /><p>A few questions <span style="background-color:yellow;">to</span> ponder : </p>
<ul>Do you really <span style="background-color:yellow;">need</span> <span style="background-color:yellow;">to</span> check <span style="background-color:yellow;">the</span> division until <span style="background-color:yellow;">n-1</span> ? How earlier can you stop ? Apart from 2 , do you really <span style="background-color:yellow;">need</span> <span style="background-color:yellow;">to</span> check <span style="background-color:yellow;">the</span> division by all <span style="background-color:yellow;">the</span> multiples <span style="background-color:yellow;">of</span> <span style="background-color:yellow;">two</span> ? What about <span style="background-color:yellow;">the</span> multiples <span style="background-color:yellow;">of</span> 3 ? 5 ? Is <span style="background-color:yellow;">there</span> a <span style="background-color:yellow;">way</span> <span style="background-color:yellow;">to</span> extend <span style="background-color:yellow;">this</span> <span style="background-color:yellow;">idea</span> <span style="background-color:yellow;">to</span> all <span style="background-color:yellow;">the</span> multiples <span style="background-color:yellow;">of</span> previously <span style="background-color:yellow;">tested</span> primes ? </ul>
<br /><b># 2 </b><br /><p>A faster <span style="background-color:yellow;">interpreter</span> <span style="background-color:yellow;">wo</span> <span style="background-color:yellow;">n't</span> cut <span style="background-color:yellow;">it.</span> Even an <span style="background-color:yellow;">implementation</span> <span style="background-color:yellow;">written</span> <span style="background-color:yellow;">in</span> C <span style="background-color:yellow;">or</span> assembly language <span style="background-color:yellow;">wo</span> <span style="background-color:yellow;">n't</span> be fast enough ( <span style="background-color:yellow;">to</span> be <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">the</span> " about <span style="background-color:yellow;">one</span> second " <span style="background-color:yellow;">timeframe</span> <span style="background-color:yellow;">of</span> project Euler ) . To put <span style="background-color:yellow;">it</span> bluntly , your algorithm <span style="background-color:yellow;">is</span> pathetic. Some research and <span style="background-color:yellow;">thinking</span> <span style="background-color:yellow;">will</span> help you <span style="background-color:yellow;">write</span> an algorithm <span style="background-color:yellow;">that</span> runs faster <span style="background-color:yellow;">in</span> a dog-slow <span style="background-color:yellow;">interpreter</span> <span style="background-color:yellow;">than</span> your current algorithm <span style="background-color:yellow;">implemented</span> <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">native</span> code ( I <span style="background-color:yellow;">wo</span> <span style="background-color:yellow;">n't</span> <span style="background-color:yellow;">name</span> any specifics , partly because <span style="background-color:yellow;">that</span> 's your job and partly because I ca <span style="background-color:yellow;">n't</span> <span style="background-color:yellow;">tell</span> <span style="background-color:yellow;">offhand</span> how much <span style="background-color:yellow;">optimization</span> <span style="background-color:yellow;">will</span> be <span style="background-color:yellow;">needed</span> ) . </p>
<br /><b># 3 </b><br /><p>Without discussing your algorithm , <span style="background-color:yellow;">the</span> PyPy <span style="background-color:yellow;">interpreter</span> can be ridiculously faster <span style="background-color:yellow;">than</span> <span style="background-color:yellow;">the</span> <span style="background-color:yellow;">normal</span> CPython <span style="background-color:yellow;">one</span> for <span style="background-color:yellow;">tight</span> <span style="background-color:yellow;">numerical</span> computation like <span style="background-color:yellow;">this.</span> You might <span style="background-color:yellow;">want</span> <span style="background-color:yellow;">to</span> <span style="background-color:yellow;">try</span> <span style="background-color:yellow;">it</span> <span style="background-color:yellow;">out</span> . </p>
<br /><b># 4 </b><br /><p>Many <span style="background-color:yellow;">of</span> <span style="background-color:yellow;">the</span> Euler problems ( <span style="background-color:yellow;">including</span> <span style="background-color:yellow;">this</span> <span style="background-color:yellow;">one</span> ) are designed <span style="background-color:yellow;">to</span> have a solution <span style="background-color:yellow;">that</span> computes <span style="background-color:yellow;">in</span> acceptable <span style="background-color:yellow;">time</span> <span style="background-color:yellow;">on</span> pretty much any given hardware and compiler ( <span style="background-color:yellow;">well</span> , <span style="background-color:yellow;">not</span> INTERCAL <span style="background-color:yellow;">on</span> a PDP-11 maybe ) . </p>
<p>You algorithm <span style="background-color:yellow;">works</span> , but <span style="background-color:yellow;">it</span> has quadratic complexity. Using a faster <span style="background-color:yellow;">interpreter</span> <span style="background-color:yellow;">will</span> give you a linear performance boost , but <span style="background-color:yellow;">the</span> quadratic complexity <span style="background-color:yellow;">will</span> dwarf <span style="background-color:yellow;">it</span> long before you calculate 10,000 primes. There are algorithms <span style="background-color:yellow;">with</span> much lower complexity ; find <span style="background-color:yellow;">them</span> ( <span style="background-color:yellow;">or</span> google <span style="background-color:yellow;">them</span> , <span style="background-color:yellow;">no</span> shame <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">that</span> and you 'll still learn a lot ) and <span style="background-color:yellow;">implement</span> <span style="background-color:yellow;">them</span> . </p>
<br /><b># 5 </b><br /><p>As most people have said , <span style="background-color:yellow;">it</span> 's all about coming up <span style="background-color:yellow;">with</span> <span style="background-color:yellow;">the</span> correct algorithm. Have you considered looking at a Sieve <span style="background-color:yellow;">of</span> Eratosthenes </p>
<br /><b># 6 </b><br /><p>based <span style="background-color:yellow;">on</span> <span style="background-color:yellow;">the</span> haskell code <span style="background-color:yellow;">in</span> <span style="background-color:yellow;">the</span> paper : The Genuine Sieve <span style="background-color:yellow;">of</span> Eratosthenes by Melissa E. O'Neill </p>
<pre><code>from itertools import cycle, chain, tee, islice

wheel2357 = [2,4,2,4,6,2,6,4,2,4,6,6,2,6,4,2,6,4,6,8,4,2,4,2,4,8,6,4,6,2,4,6,2,6,6,4,2,4,6,2,6,4,2,4,2,10,2,10]

def spin(wheel, n):
    for x in wheel:
        yield n
        n = n + x

import heapq

def insertprime(p,xs,t):
    heapq.heappush(t,(p*p,(p*v for v in xs)))

def adjust(t,x):
    while True:
        n, ns = t[0]
        if n <= x:
            n, ns = heapq.heappop(t)
            heapq.heappush(t, (ns.next(), ns))
        else:
            break

def sieve(it):
    t = []
    x = it.next()
    yield x
    xs0, xs1 = tee(it)
    insertprime(x,xs1,t)
    it = xs0
    while True:
        x = it.next()
        if t[0][0] <= x:
            adjust(t,x)
            continue
        yield x
        xs0, xs1 = tee(it)
        insertprime(x,xs1,t)
        it = xs0

primes = chain([2,3,5,7], sieve(spin(cycle(wheel2357), 11)))

from time import time
s = time()
print list(islice(primes, 10000, 10001))
e = time()
print "%.8f seconds" % (e-s)
</code></pre>
<p>prints : </p>
<pre><code>[104743]
0.18839407 seconds
</code></pre>
<hr />
<pre><code>from itertools import islice
from heapq import heappush, heappop

wheel2357 = [2,4,2,4,6,2,6,4,2,4,6,6,2,6,4,2,6,4,6,8,4,2,4,2,
             4,8,6,4,6,2,4,6,2,6,6,4,2,4,6,2,6,4,2,4,2,10,2,10]

class spin(object):
    __slots__ = ('wheel','o','n','m')
    def __init__(self, wheel, n, o=0, m=1):
        self.wheel = wheel
        self.o = o
        self.n = n
        self.m = m
    def __iter__(self):
        return self
    def next(self):
        v = self.m*self.n
        self.n += self.wheel[self.o]
        self.o = (self.o + 1) % len(self.wheel)
        return v
    def copy(self):
        return spin(self.wheel, self.n, self.o, self.m)
    def times(self, x):
        return spin(self.wheel, self.n, self.o, self.m*x)

def adjust(t,x):
    while t[0][0] <= x:
        n, ns = heappop(t)
        heappush(t, (ns.next(), ns))

def sieve_primes():

    for p in [2,3,5,7]:
        yield p

    it = spin(wheel2357, 11)

    t = []
    p = it.next()
    yield p
    heappush(t, (p*p, it.times(p)))

    while True:
        p = it.next()
        if t[0][0] <= p:
            adjust(t,p)
            continue
        yield p
        heappush(t, (p*p, it.times(p)))

from time import time
s = time()
print list(islice(sieve_primes(), 10000, 10001))[-1]
e = time()
print "%.8f seconds" % (e-s)
</code></pre>
<p>prints : </p>
<pre><code>104743
0.22022200 seconds
</code></pre>
<hr />
<pre><code>import time
from math import sqrt

wheel2357 = [2,4,2,4,6,2,6,4,2,4,6,6,2,6,4,2,6,4,6,8,4,2,4,2,4,8,6,4,6,2,4,6,2,6,6,4,2,4,6,2,6,4,2,4,2,10,2,10]

list_prime = [2,3,5,7]

def isprime(num):
    limit = sqrt(num)
    for prime in list_prime:
        if num % prime == 0: return 0
        if prime > limit: break
    return 1

def generate_primes(no_of_primes):
    o = 0
    n = 11
    w = wheel2357
    l = len(w)
    while len(list_prime) < no_of_primes:
        i = n
        n = n + w[o]
        o = (o + 1) % l
        if isprime(i): 
            list_prime.append(i)

t0 = time.time()
generate_primes(10001)
print list_prime[-1]        # 104743
t1 = time.time()
print t1-t0                 # 0.18 seconds
</code></pre>
<p>prints : </p>
<pre><code>104743
0.307313919067
</code></pre>
<br />