<h3>Question ( ID-464342 ) : </h3><h2>Combining two <span style="background-color:yellow;">sorted</span> <span style="background-color:yellow;">lists</span> in Python </h2><p>I have two <span style="background-color:yellow;">lists</span> of objects. Each <span style="background-color:yellow;">list</span> is already <span style="background-color:yellow;">sorted</span> by a property of the object that is of the <span style="background-color:yellow;">datetime</span> type. I would like to combine the two <span style="background-color:yellow;">lists</span> into one <span style="background-color:yellow;">sorted</span> <span style="background-color:yellow;">list.</span> Is the best way just to do a bubble <span style="background-color:yellow;">sort</span> or is there a smarter way to do this in Python ? </p>
<br /><h3>Answers ( Total-10 ) : </h3><b># <span style="background-color:yellow;">0</span> </b><br /><p>People seem to be over complicating this.. Just combine the two <span style="background-color:yellow;">lists</span> , then <span style="background-color:yellow;">sort</span> them : </p>
<pre><code>>>> l1 = [1, 3, 4, 7]
>>> l2 = [0, 2, 5, 6, 8, 9]
>>> l1.extend(l2)
>>> sorted(l1)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>..or shorter ( and without modifying <span style="background-color:yellow;">l1</span> ) : </p>
<pre><code>>>> sorted(l1 + l2)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>
<p>..easy ! Plus , <span style="background-color:yellow;">it</span> 's using only two built-in functions , so assuming the <span style="background-color:yellow;">lists</span> are of a reasonable size , <span style="background-color:yellow;">it</span> should be quicker than implementing the <span style="background-color:yellow;">sorting/merging</span> in a loop. More importantly , the above is much less code , and very readable . </p>
<p>If <span style="background-color:yellow;">your</span> <span style="background-color:yellow;">lists</span> are large ( over a few hundred thousand , I would guess ) , <span style="background-color:yellow;">it</span> may be quicker to use an alternative/custom <span style="background-color:yellow;">sorting</span> method , but there are likely other optimisations to be made first ( e.g not storing millions of <span style="background-color:yellow;">datetime</span> objects ) </p>
<p>Using the timeit.Timer ( ) .repeat ( ) ( which repeats the functions 1000000 times ) , I loosely benchmarked <span style="background-color:yellow;">it</span> against ghoseb 's solution , and <span style="background-color:yellow;">sorted</span> ( <span style="background-color:yellow;">l1</span> + <span style="background-color:yellow;">l2</span> ) is substantially quicker : </p>
<p><span style="background-color:yellow;">merge_sorted_lists</span> took. . </p>
<pre><code>[9.7439379692077637, 9.8844599723815918, 9.552299976348877]
</code></pre>
<p><span style="background-color:yellow;">sorted</span> ( <span style="background-color:yellow;">l1</span> + <span style="background-color:yellow;">l2</span> ) took. . </p>
<pre><code>[2.860386848449707, 2.7589840888977051, 2.7682540416717529]
</code></pre>
<br /><b># 1 </b><br /><blockquote>is there a smarter way to do this in Python </blockquote>
<p>This has n't been mentioned , so I 'll go ahead - there is a <span style="background-color:yellow;">merge</span> stdlib function in the heapq module of python 2.6 + . If all <span style="background-color:yellow;">you</span> 're looking to do is getting things done , this might be a better idea. Of course , if <span style="background-color:yellow;">you</span> want to implement <span style="background-color:yellow;">your</span> own , the <span style="background-color:yellow;">merge</span> of <span style="background-color:yellow;">merge-sort</span> is the way to go . </p>
<pre><code>>>> list1 = [1, 5, 8, 10, 50]
>>> list2 = [3, 4, 29, 41, 45, 49]
>>> from heapq import merge
>>> list(merge(list1, list2))
[1, 3, 4, 5, 8, 10, 29, 41, 45, 49, 50]
</code></pre>
<br /><b># 2 </b><br /><p>Long story short , unless len ( <span style="background-color:yellow;">l1</span> + <span style="background-color:yellow;">l2</span> ) ~ 1000000 use : </p>
<pre><code>L = l1 + l2
L.sort()
</code></pre>
<p></p>
<p>Description of the figure and source code can be found here . </p>
<p>The figure was generated by the following command : </p>
<pre><code>$ python make-figures.py --nsublists 2 --maxn=0x100000 -s merge_funcs.merge_26 -s merge_funcs.sort_builtin
</code></pre>
<br /><b># 3 </b><br /><p>This is simply merging. Treat each <span style="background-color:yellow;">list</span> as if <span style="background-color:yellow;">it</span> were a stack , and continuously pop the smaller of the two stack heads , adding the <span style="background-color:yellow;">item</span> to the result <span style="background-color:yellow;">list</span> , until one of the stacks is empty. Then add all remaining <span style="background-color:yellow;">items</span> to the resulting <span style="background-color:yellow;">list</span> . </p>
<br /><b># 4 </b><br /><p>There is a slight flaw in ghoseb 's solution , making <span style="background-color:yellow;">it</span> O ( n * * 2 ) , rather than O ( n ) . The problem is that this is performing : </p>
<pre><code>item = l1.pop(0)
</code></pre>
<p>With linked <span style="background-color:yellow;">lists</span> or deques this would be an O ( 1 ) operation , so would n't affect complexity , but since python <span style="background-color:yellow;">lists</span> are implemented as vectors , this copies the rest of the elements of <span style="background-color:yellow;">l1</span> one space <span style="background-color:yellow;">left</span> , an O ( n ) operation. Since this is done each pass through the <span style="background-color:yellow;">list</span> , <span style="background-color:yellow;">it</span> turns an O ( n ) algorithm into an O ( n * * 2 ) one. This can be corrected by using a method that does n't alter the source <span style="background-color:yellow;">lists</span> , but just keeps track of the current position . </p>
<p>I 've tried out benchmarking a corrected algorithm vs a simple <span style="background-color:yellow;">sorted</span> ( <span style="background-color:yellow;">l1</span> + <span style="background-color:yellow;">l2</span> ) as suggested by dbr </p>
<pre><code>def merge(l1,l2):
    if not l1:  return list(l2)
    if not l2:  return list(l1)

    # l2 will contain last element.
    if l1[-1] > l2[-1]:
        l1,l2 = l2,l1

    it = iter(l2)
    y = it.next()
    result = []

    for x in l1:
        while y < x:
            result.append(y)
            y = it.next()
        result.append(x)
    result.append(y)
    result.extend(it)
    return result
</code></pre>
<p>I 've tested these with <span style="background-color:yellow;">lists</span> generated with </p>
<pre><code>l1 = sorted([random.random() for i in range(NITEMS)])
l2 = sorted([random.random() for i in range(NITEMS)])
</code></pre>
<p>For various sizes of <span style="background-color:yellow;">list</span> , I get the following timings ( repeating 100 times ) : </p>
<pre><code># items:  1000   10000 100000 1000000
merge  :  0.079  0.798 9.763  109.044 
sort   :  0.020  0.217 5.948  106.882
</code></pre>
<p>So in fact , <span style="background-color:yellow;">it</span> looks like dbr is <span style="background-color:yellow;">right</span> , just using <span style="background-color:yellow;">sorted</span> ( ) is preferable unless <span style="background-color:yellow;">you</span> 're expecting very large <span style="background-color:yellow;">lists</span> , though <span style="background-color:yellow;">it</span> does have worse algorithmic complexity. The break even point being at around a million <span style="background-color:yellow;">items</span> in each source <span style="background-color:yellow;">list</span> ( 2 million total ) . </p>
<p>One advantage of the <span style="background-color:yellow;">merge</span> approach though is that <span style="background-color:yellow;">it</span> is trivial to rewrite as a generator , which will use substantially less memory ( no need for an intermediate <span style="background-color:yellow;">list</span> ) . </p>
<p>[ Edit ] I 've retried this with a situation closer to the question - using a <span style="background-color:yellow;">list</span> of objects containing a field " date " which is a <span style="background-color:yellow;">datetime</span> object . The above algorithm was changed to compare against .date instead , and the <span style="background-color:yellow;">sort</span> method was changed to : </p>
<pre><code>return sorted(l1 + l2, key=operator.attrgetter('date'))
</code></pre>
<p>This does change things a bit. The comparison being more expensive means that the number we perform becomes more important , relative to the constant-time speed of the implementation. This means <span style="background-color:yellow;">merge</span> makes up lost ground , surpassing the <span style="background-color:yellow;">sort</span> ( ) method at 100,000 <span style="background-color:yellow;">items</span> instead. Comparing based on an even more complex object ( large strings or <span style="background-color:yellow;">lists</span> for instance ) would likely shift this balance even more . </p>
<pre><code># items:  1000   10000 100000  1000000[1]
merge  :  0.161  2.034 23.370  253.68
sort   :  0.111  1.523 25.223  313.20
</code></pre>
<p>[ 1 ] : Note : I actually only did 10 repeats for 1,000,000 <span style="background-color:yellow;">items</span> and scaled up accordingly as <span style="background-color:yellow;">it</span> was pretty slow . </p>
<br /><b># 5 </b><br /><pre><code>from datetime import datetime
from itertools import chain
from operator import attrgetter

class DT:
    def __init__(self, dt):
        self.dt = dt

list1 = [DT(datetime(2008, 12, 5, 2)),
         DT(datetime(2009, 1, 1, 13)),
         DT(datetime(2009, 1, 3, 5))]

list2 = [DT(datetime(2008, 12, 31, 23)),
         DT(datetime(2009, 1, 2, 12)),
         DT(datetime(2009, 1, 4, 15))]

list3 = sorted(chain(list1, list2), key=attrgetter('dt'))
for item in list3:
    print item.dt
</code></pre>
<p>The output : </p>
<pre><code>2008-12-05 02:00:00
2008-12-31 23:00:00
2009-01-01 13:00:00
2009-01-02 12:00:00
2009-01-03 05:00:00
2009-01-04 15:00:00
</code></pre>
<p>I bet this is faster than any of the fancy pure-Python <span style="background-color:yellow;">merge</span> algorithms , even for large data. Python 2.6 's heapq.merge is a whole another story . </p>
<br /><b># 6 </b><br /><p>This is simple merging of two <span style="background-color:yellow;">sorted</span> <span style="background-color:yellow;">lists.</span> Take a look at the sample code below which <span style="background-color:yellow;">merges</span> two <span style="background-color:yellow;">sorted</span> <span style="background-color:yellow;">lists</span> of integers . </p>
<pre><code>#!/usr/bin/env python
## merge.py -- Merge two sorted lists -*- Python -*-
## Time-stamp: "2009-01-21 14:02:57 ghoseb"

l1 = [1, 3, 4, 7]
l2 = [0, 2, 5, 6, 8, 9]

def merge_sorted_lists(l1, l2):
    """Merge sort two sorted lists

    Arguments:
    - `l1`: First sorted list
    - `l2`: Second sorted list
    """
    sorted_list = []

    # Copy both the args to make sure the original lists are not
    # modified
    l1 = l1[:]
    l2 = l2[:]

    while (l1 and l2):
        if (l1[0] <= l2[0]): # Compare both heads
            item = l1.pop(0) # Pop from the head
            sorted_list.append(item)
        else:
            item = l2.pop(0)
            sorted_list.append(item)

    # Add the remaining of the lists
    sorted_list.extend(l1 if l1 else l2)

    return sorted_list

if __name__ == '__main__':
    print merge_sorted_lists(l1, l2)
</code></pre>
<p>This should work fine with <span style="background-color:yellow;">datetime</span> objects. Hope this helps . </p>
<br /><b># 7 </b><br /><p>Use the 'merge ' step of <span style="background-color:yellow;">merge</span> <span style="background-color:yellow;">sort</span> , <span style="background-color:yellow;">it</span> runs in O ( n ) time . </p>
<p>From wikipedia ( pseudo-code ) : </p>
<pre><code>function merge(left,right)
    var list result
    while length(left) > 0 and length(right) > 0
        if first(left) â‰¤ first(right)
            append first(left) to result
            left = rest(left)
        else
            append first(right) to result
            right = rest(right)
    end while
    while length(left) > 0 
        append left to result
    while length(right) > 0 
        append right to result
    return result
</code></pre>
<br /><b># 8 </b><br /><p>Well , the naive approach ( combine 2 <span style="background-color:yellow;">lists</span> into large one and <span style="background-color:yellow;">sort</span> ) will be O ( N * log ( N ) ) complexity. On the other hand , if <span style="background-color:yellow;">you</span> implement the <span style="background-color:yellow;">merge</span> manually ( i do not know about any ready code in python libs for this , but i 'm no expert ) the complexity will be O ( N ) , which is clearly faster . The idea is described wery well in post by Barry Kelly . </p>
<br /><b># 9 </b><br /><pre><code>def compareDate(obj1, obj2):
    if obj1.getDate() < obj2.getDate():
        return -1
    elif obj1.getDate() > obj2.getDate():
        return 1
    else:
        return 0



list = list1 + list2
list.sort(compareDate)
</code></pre>
<p>Will <span style="background-color:yellow;">sort</span> the <span style="background-color:yellow;">list</span> in place. Define <span style="background-color:yellow;">your</span> own function for comparing two objects , and pass that function into the built in <span style="background-color:yellow;">sort</span> function . </p>
<p>Do NOT use bubble <span style="background-color:yellow;">sort</span> , <span style="background-color:yellow;">it</span> has horrible performance . </p>
<br />