<h3>Question ( ID-5104366 ) : </h3><h2>basic inheritance ( in <span style="background-color:yellow;">python</span> ) </h2><p>users, </p>
<p>I have a basic question <span style="background-color:yellow;">concerning</span> inheritance ( in <span style="background-color:yellow;">python</span> ) . I have two <span style="background-color:yellow;">classes</span> and one of them is inherited from the other like </p>
<pre><code>class   p:
    def __init__(self,name):
        self.pname  = name

class   c(p):
    def __init__(self,name):
        self.cname  = name
</code></pre>
<p>Is there any <span style="background-color:yellow;">possibility</span> that I <span style="background-color:yellow;">can</span> <span style="background-color:yellow;">create</span> a <span style="background-color:yellow;">parent</span> <span style="background-color:yellow;">object</span> and several <span style="background-color:yellow;">child</span> <span style="background-color:yellow;">objects</span> which refer to the SAME <span style="background-color:yellow;">parent</span> <span style="background-color:yellow;">object</span> ? It should work like that that the <span style="background-color:yellow;">parent</span> <span style="background-color:yellow;">object</span> <span style="background-color:yellow;">contains</span> several variables and whenever I access the <span style="background-color:yellow;">corresponding</span> variables from a <span style="background-color:yellow;">child</span> I actually access the variable form the <span style="background-color:yellow;">parent.</span> I.e. if I <span style="background-color:yellow;">change</span> it for one <span style="background-color:yellow;">child</span> it is <span style="background-color:yellow;">changed</span> also for all other <span style="background-color:yellow;">childes</span> and the data are only stored once in memory ( and not <span style="background-color:yellow;">copied</span> for each <span style="background-color:yellow;">child...</span> ) </p>
<p>Thank you in advance . </p>
<p>Here is a <span style="background-color:yellow;">possible</span> workaround which I do not <span style="background-color:yellow;">consider</span> as so nice </p>
<pre><code>class P:
    def __init__(self, name):
        self.pname = name

class C:
    def __init__(self, name,pobject):
        self.pobject = pobject
        self.cname = name
</code></pre>
<p>Is this really the state of the art or do there exist other <span style="background-color:yellow;">concepts</span> ? </p>
<p>Sebastian </p>
<p>Thank you all for helping me , also with the <span style="background-color:yellow;">name</span> <span style="background-color:yellow;">conventions</span> : ) But I am still not very satisfied. Maybe I give a more advanced example to stress what I really want to do . </p>
<pre><code>class P:
    data = "shareddata"
    def __init__(self,newdata):
        self.data = newdata 

    def printname(self):
        print self.name 

class C(P):
    def __init__(self,name):
        self.name = name
</code></pre>
<p>Now I <span style="background-color:yellow;">can</span> do the following </p>
<pre><code>In [33]: c1 = test.C("name1")

In [34]: c2 = test.C("name2")

In [35]: c1.printname()
name1

In [36]: c2.printname()
name2

In [37]: c1.data
Out[37]: 'shareddata'

In [38]: c2.data
Out[38]: 'shareddata'
</code></pre>
<p>And this is so far exactly what I want. There is a variable <span style="background-color:yellow;">name</span> which is different for every <span style="background-color:yellow;">child</span> and the <span style="background-color:yellow;">parent</span> <span style="background-color:yellow;">class</span> accesses the individual variables. Normal inheritance . Then there is the variable data which <span style="background-color:yellow;">comes</span> from the <span style="background-color:yellow;">parent</span> <span style="background-color:yellow;">class</span> and every <span style="background-color:yellow;">child</span> access it. However , now the following does not work any more </p>
<pre><code>In [39]: c1.data = "tst"

In [40]: c2.data
Out[40]: 'shareddata'

In [41]: c1.data
Out[41]: 'tst'
</code></pre>
<p>I want the <span style="background-color:yellow;">change</span> in <span style="background-color:yellow;">c1.data</span> to affect also <span style="background-color:yellow;">c2.data</span> since I want the variable to be shared , somehow a global variable of this <span style="background-color:yellow;">parent</span> <span style="background-color:yellow;">class</span> . </p>
<p>And more than that. I also want to <span style="background-color:yellow;">create</span> different instances of <span style="background-color:yellow;">P</span> , each having its own data variable. And when I <span style="background-color:yellow;">create</span> a new <span style="background-color:yellow;">C</span> <span style="background-color:yellow;">object</span> I want to specify from which <span style="background-color:yellow;">P</span> <span style="background-color:yellow;">object</span> data should be inhetited i.e. shared... . </p>
<p>UPDATE : </p>
<p>remark to the <span style="background-color:yellow;">comment</span> of @ eyquem : Thanks for this , it is going into the direction I want. However , now the __class__.pvar is shared among all <span style="background-color:yellow;">objects</span> of the <span style="background-color:yellow;">class.</span> What I want is that several instances of <span style="background-color:yellow;">P</span> may have a different <span style="background-color:yellow;">pvar.</span> Lets assume <span style="background-color:yellow;">P1</span> has <span style="background-color:yellow;">pvar</span> = <span style="background-color:yellow;">1</span> and <span style="background-color:yellow;">P2</span> has <span style="background-color:yellow;">pvar</span> = <span style="background-color:yellow;">2.</span> Then I want to <span style="background-color:yellow;">create</span> <span style="background-color:yellow;">children</span> <span style="background-color:yellow;">C1a</span> , <span style="background-color:yellow;">C1b</span> , <span style="background-color:yellow;">C1c</span> which are related to <span style="background-color:yellow;">P1</span> , i.e. if I say <span style="background-color:yellow;">C1a.pvar</span> it should acess <span style="background-color:yellow;">pvar</span> from <span style="background-color:yellow;">P1.</span> Then I <span style="background-color:yellow;">create</span> <span style="background-color:yellow;">C2a</span> , <span style="background-color:yellow;">C2b</span> , <span style="background-color:yellow;">C2c</span> and if I access i.e. <span style="background-color:yellow;">C2b.pvar</span> I want to access <span style="background-color:yellow;">pvar</span> from <span style="background-color:yellow;">P2.</span> Since the <span style="background-color:yellow;">class</span> <span style="background-color:yellow;">C</span> inherits <span style="background-color:yellow;">pvar</span> from the <span style="background-color:yellow;">class</span> <span style="background-color:yellow;">P</span> <span style="background-color:yellow;">pvar</span> is known to <span style="background-color:yellow;">C.</span> My naive idea is that if I <span style="background-color:yellow;">create</span> a new instance of <span style="background-color:yellow;">C</span> I should be able to specify which ( existing ) <span style="background-color:yellow;">P</span> <span style="background-color:yellow;">object</span> should be used as the <span style="background-color:yellow;">parent</span> <span style="background-color:yellow;">object</span> and not to <span style="background-color:yellow;">create</span> a <span style="background-color:yellow;">completely</span> new <span style="background-color:yellow;">P</span> <span style="background-color:yellow;">object</span> as it is done when <span style="background-color:yellow;">calling</span> <span style="background-color:yellow;">P.__init__</span> inside of the <span style="background-color:yellow;">__init__</span> of <span style="background-color:yellow;">C...</span> It sounds simple to me , maybe I forget something.. . </p>
<p>UPDATE : </p>
<p>So I found this discussion which is <span style="background-color:yellow;">pretty</span> much my question </p>
<p>Any suggestions ? </p>
<p>UPDATE : </p>
<p>The method . <span style="background-color:yellow;">class</span> ._ subclasses _ seems to be not existing any more. . </p>
<p>UPDATE : </p>
<p>Here is onother link : </p>
<p>link to discussion </p>
<p>There it is solved by <span style="background-color:yellow;">copying.</span> But I do not want to <span style="background-color:yellow;">copy</span> the <span style="background-color:yellow;">parent</span> <span style="background-color:yellow;">class</span> since I would like that it exists only once.. . </p>
<p>UPDATE : </p>
<p>Sorry for leaving the discussion yesterday , I am a bit ill... And thank you for the <span style="background-color:yellow;">posts</span> ! I will now read through them. I thought about it a bit more and here is a <span style="background-color:yellow;">possible</span> solution I found </p>
<pre><code>class P(object):
    def __init__(self,pvar):
        self.pobject    = None
        self._pvar  = pvar

    @property
    def pvar(self):
    if self.pobject != None:
        return  self.pobject.pvar
    else:
            return self._pvar
    @pvar.setter
    def pvar(self,val):
    if self.pobject != None:
        self.pobject.pvar = val
    else:
            self._pvar=val

    def printname(self):
    print self.name


class C(P):
    def __init__(self,name,pobject):  #<-- The same default `P()` is 
                                          # used for all instances of `C`, 
                                          # unless pobject is explicitly defined.
    P.__init__(self,None)
        self.name   = name
        self.pobject = pobject


p1  = P("1")
p2  = P("2")


c1a = C("c1a",p1)
c1b = C("c1b",p1)
c1c = C("c1c",p1)
c2a = C("c2a",p2)
c2b = C("c2b",p2)
c2c = C("c2c",p2)


print   id(c1a.pvar)
print   id(c1b.pvar)
print   id(c1c.pvar)
print   id(c2a.pvar)
print   id(c2b.pvar)
print   id(c2c.pvar)
print   id(p1.pvar)
print   id(p2.pvar)

print   id(c1a.name)
print   id(c1b.name)
print   id(c1c.name)
print   id(c2a.name)
print   id(c2b.name)
print   id(c2c.name)
</code></pre>
<p>It is a bit <span style="background-color:yellow;">cumbersome</span> and I hope that there is a simpler way to achieve this. But it has the feature that <span style="background-color:yellow;">pvar</span> is only mentioned in the <span style="background-color:yellow;">class</span> <span style="background-color:yellow;">P</span> and the <span style="background-color:yellow;">class</span> <span style="background-color:yellow;">C</span> does not know about <span style="background-color:yellow;">pvar</span> as it should be according to my understanding of inheritance. Nevertheless when I <span style="background-color:yellow;">create</span> a new instance of <span style="background-color:yellow;">C</span> I <span style="background-color:yellow;">can</span> specify an existing instance of <span style="background-color:yellow;">P</span> which will be stored in the variable <span style="background-color:yellow;">pobject.</span> When the variable <span style="background-color:yellow;">pvar</span> is accessed actually <span style="background-color:yellow;">pvar</span> of the <span style="background-color:yellow;">P-instance</span> stored in this variable is accessed.. . </p>
<p>The output is given by </p>
<pre><code>3078326816
3078326816
3078326816
3074996544
3074996544
3074996544
3078326816
3074996544
156582944
156583040
156583200
156583232
156583296
156583360
</code></pre>
<p>I will read now through your last <span style="background-color:yellow;">comments,</span> </p>
<p>all the best , Sebastian </p>
<p>UPDATE : </p>
<p>I think the most elegant way would be the following ( which DOES NOT work ) </p>
<pre><code>class P(object):
    def __init__(self,pvar):
        self.pvar   = pvar

    def printname(self):
        print self.name


class C(P):
    def __init__(self,name,pobject):  
        P = pobject
        self.name   = name
</code></pre>
<p>I think <span style="background-color:yellow;">python</span> should allow for this.. . </p>
<p>UPDATE : </p>
<p>Ok , now I found a way to achieve this , due to the explanations by eyquem. But Since this is really a hack there should be an official version for the same.. . </p>
<pre><code>def replaceinstance(parent,child):
    for item in parent.__dict__.items():
        child.__dict__.__setitem__(item[0],item[1])
        print item

class P(object):
    def __init__(self,pvar):
        self.pvar   = pvar

    def printname(self):
    print self.name


class C(P):
    def __init__(self,name,pobject):
    P.__init__(self,None)
    replaceinstance(pobject,self)
        self.name   = name



p1  = P("1")
p2  = P("2")


c1a = C("c1a",p1)
c1b = C("c1b",p1)
c1c = C("c1c",p1)
c2a = C("c2a",p2)
c2b = C("c2b",p2)
c2c = C("c2c",p2)


print   id(c1a.pvar)
print   id(c1b.pvar)
print   id(c1c.pvar)
print   id(c2a.pvar)
print   id(c2b.pvar)
print   id(c2c.pvar)
print   id(p1.pvar)
print   id(p2.pvar)

print   id(c1a.name)
print   id(c1b.name)
print   id(c1c.name)
print   id(c2a.name)
print   id(c2b.name)
print   id(c2c.name)
</code></pre>
<p>the output is the same as above </p>
<pre><code>3077745184
3077745184
3077745184
3074414912
3074414912
3074414912
3077745184
3074414912
144028416
144028448
144028480
144028512
144028544
144028576
</code></pre>
<p>UPDATE : Even if the id 's seem to be right , the last <span style="background-color:yellow;">code</span> does not work as is <span style="background-color:yellow;">clear</span> from this test </p>
<pre><code>c1a.pvar    = "newpvar1"

print   c1a.pvar
print   c1b.pvar
print   c1c.pvar
print   c2a.pvar
print   c2b.pvar
print   c2c.pvar
print   p1.pvar
print   p2.pvar
</code></pre>
<p>it has the output </p>
<pre><code>newpvar1
1
1
2
2
2
1
2
</code></pre>
<p>However the version I <span style="background-color:yellow;">posted</span> first works : </p>
<pre><code>class P(object):
    def __init__(self,pvar):
        self.pobject    = None
        self._pvar  = pvar

    @property
    def pvar(self):
    if self.pobject != None:
        return  self.pobject.pvar
    else:
            return self._pvar
    @pvar.setter
    def pvar(self,val):
    if self.pobject != None:
        self.pobject.pvar = val
    else:
            self._pvar=val

    def printname(self):
    print self.name


class C(P):
    def __init__(self,name,pobject):  #<-- The same default `P()` is 
                                          # used for all instances of `C`, 
                                          # unless pobject is explicitly defined.
    P.__init__(self,None)
        self.name   = name
        self.pobject = pobject


p1  = P("1")
p2  = P("2")


c1a = C("c1a",p1)
c1b = C("c1b",p1)
c1c = C("c1c",p1)
c2a = C("c2a",p2)
c2b = C("c2b",p2)
c2c = C("c2c",p2)


print   id(c1a.pvar)
print   id(c1b.pvar)
print   id(c1c.pvar)
print   id(c2a.pvar)
print   id(c2b.pvar)
print   id(c2c.pvar)
print   id(p1.pvar)
print   id(p2.pvar)

print   id(c1a.name)
print   id(c1b.name)
print   id(c1c.name)
print   id(c2a.name)
print   id(c2b.name)
print   id(c2c.name)




print   "testing\n"

c1a.printname()
c1b.printname()
c1c.printname()
c2a.printname()
c2b.printname()
c2c.printname()


print   "\n"
c1a.name = "c1anewname"
c2b.name = "c2bnewname"


c1a.printname()
c1b.printname()
c1c.printname()
c2a.printname()
c2b.printname()
c2c.printname()


print "pvar\n"

print   c1a.pvar
print   c1b.pvar
print   c1c.pvar
print   c2a.pvar
print   c2b.pvar
print   c2c.pvar
print   p1.pvar
print   p2.pvar

print "\n"
c1a.pvar    = "newpvar1"

print   c1a.pvar
print   c1b.pvar
print   c1c.pvar
print   c2a.pvar
print   c2b.pvar
print   c2c.pvar
print   p1.pvar
print   p2.pvar

print "\n"
c2c.pvar    = "newpvar2"

print   c1a.pvar
print   c1b.pvar
print   c1c.pvar
print   c2a.pvar
print   c2b.pvar
print   c2c.pvar
print   p1.pvar
print   p2.pvar
</code></pre>
<p>with the output </p>
<pre><code>3077745184
3077745184
3077745184
3074414912
3074414912
3074414912
3077745184
3074414912
144028416
144028448
144028480
144028512
144028544
144028576
testing

c1a
c1b
c1c
c2a
c2b
c2c


c1anewname
c1b
c1c
c2a
c2bnewname
c2c
pvar

1
1
1
2
2
2
1
2


newpvar1
newpvar1
newpvar1
2
2
2
newpvar1
2


newpvar1
newpvar1
newpvar1
newpvar2
newpvar2
newpvar2
newpvar1
newpvar2
</code></pre>
<p>Does anybody know why it is like that ? I <span style="background-color:yellow;">probably</span> do not understand the internal way <span style="background-color:yellow;">python</span> works with this __dict__ so well.. . </p>
<br /><h3>Answers ( Total-8 ) : </h3><b># 0 </b><br /><blockquote>It should work like that that the <span style="background-color:yellow;">parent</span> <span style="background-color:yellow;">object</span> <span style="background-color:yellow;">contains</span> several variables and whenever I access the <span style="background-color:yellow;">corresponding</span> variables from a <span style="background-color:yellow;">child</span> I actually access the variable form the <span style="background-color:yellow;">parent.</span> I.e. if I <span style="background-color:yellow;">change</span> it for one <span style="background-color:yellow;">child</span> it is <span style="background-color:yellow;">changed</span> also for all other <span style="background-color:yellow;">childes</span> and the data are only stored once in memory ( and not <span style="background-color:yellow;">copied</span> for each <span style="background-color:yellow;">child...</span> ) </blockquote>
<p>That 's not inheritance . </p>
<p>That 's a <span style="background-color:yellow;">completely</span> different <span style="background-color:yellow;">concept</span> . </p>
<p>Your " shared variables " are simply <span style="background-color:yellow;">objects</span> that <span style="background-color:yellow;">can</span> be mutated and have references in other <span style="background-color:yellow;">objects.</span> Nothing interesting . </p>
<p>Inheritance is <span style="background-color:yellow;">completely</span> different from this . </p>
<br /><b># <span style="background-color:yellow;">1</span> </b><br /><p>I think your workaround is doable ; You <span style="background-color:yellow;">could</span> use <span style="background-color:yellow;">properties</span> to make access to <span style="background-color:yellow;">P</span> 's attributes easier : </p>
<pre><code>class P(object):
    def __init__(self,name='default',pvar=1):
        self.pname  = name
        self.pvar=pvar

class C(object):
    def __init__(self,name,pobject=P()):  #<-- The same default `P()` is 
                                          # used for all instances of `C`, 
                                          # unless pobject is explicitly defined.
        self.cname  = name
        self.pobject=pobject
    @property
    def pvar(self):
        return self.pobject.pvar
    @pvar.setter
    def pvar(self,val):
        self.pobject.pvar=val

c1=C('1')
c2=C('2')
</code></pre>
<p><span style="background-color:yellow;">c1</span> and <span style="background-color:yellow;">c2</span> share the same <span style="background-color:yellow;">pobject</span> : </p>
<pre><code>print(c1.pvar)
# 1
c1.pvar=2
</code></pre>
<p>Notice that <span style="background-color:yellow;">changing</span> <span style="background-color:yellow;">pvar</span> through <span style="background-color:yellow;">c1</span> <span style="background-color:yellow;">changes</span> <span style="background-color:yellow;">c2.pvar</span> : </p>
<pre><code>print(c2.pvar)
# 2
</code></pre>
<p><span style="background-color:yellow;">c3</span> has a different <span style="background-color:yellow;">pobject</span> : </p>
<pre><code>c3=C('3',P())
print(c3.pvar)
# 1
</code></pre>
<hr />
<p>Regarding OOP design for the <span style="background-color:yellow;">psychology</span> experiment ( mentioned in the <span style="background-color:yellow;">comments</span> ) : </p>
<pre><code>import Image

class Picture(object):
    def __init__(self,filename):
        self.filename = filename
        self.image=Image.open(filename)       

class Person(object):
    def __init__(self,name):
        self.name=name
        # other vital statistics associated with people as individuals here

class Trial(object):
    # A trial is composed of one person, one picture, and the places they look
    def __init__(self,person,picture,locations):
        self.person=person
        self.picture=picture
        self.locations = locations
    # put methods for analyzing where the person looked here
</code></pre>
<p>A <span style="background-color:yellow;">Picture</span> is <span style="background-color:yellow;">certainly</span> not a <span style="background-color:yellow;">Person</span> , nor vice versa. And the same goes for <span style="background-color:yellow;">Trial</span> s. So none of these <span style="background-color:yellow;">classes</span> should inherit from each other . </p>
<p>Each of these <span style="background-color:yellow;">classes</span> have a <span style="background-color:yellow;">public</span> ( and maybe a <span style="background-color:yellow;">private</span> ) interface . <span style="background-color:yellow;">Public</span> methods and attributes should be freely accessible from other <span style="background-color:yellow;">classes</span> . So given a <span style="background-color:yellow;">Trial</span> instance , t , the <span style="background-color:yellow;">image</span> should be accessible through t.picture.image . As long as you are only accessing <span style="background-color:yellow;">public</span> attributes and methods , then everything should be fine . </p>
<p>For <span style="background-color:yellow;">convenience</span> , you <span style="background-color:yellow;">can</span> use <span style="background-color:yellow;">properties</span> to link attributes to <span style="background-color:yellow;">component-attributes.</span> For example : </p>
<pre><code>class Trial(object):
    ...
    @property
    def image(self):
        return self.picture.image
</code></pre>
<p>But to short-cut this by making , say , <span style="background-color:yellow;">Trial</span> a subclass of <span style="background-color:yellow;">Picture</span> would be <span style="background-color:yellow;">contrary</span> to fundamental OOP design <span style="background-color:yellow;">principles</span> . </p>
<br /><b># <span style="background-color:yellow;">2</span> </b><br /><p>The other answer is right , your question is more about <span style="background-color:yellow;">namespaces</span> and references than about inheritance . </p>
<p>All variables in <span style="background-color:yellow;">Python</span> are references , and all <span style="background-color:yellow;">object</span> instance is a <span style="background-color:yellow;">namespace.</span> So you <span style="background-color:yellow;">can</span> do : </p>
<pre><code>class C():
    def __init__(self, x):
        self.x  = x

class Shared(object):
    def __init__(self, value):
        self.value  = value

# instances:
>>> shared1 = Shared(1)
>>> shared2 = Shared(2)
>>> c1 = C(shared1)
>>> c2 = C(shared1)
>>> c3 = C(shared2)
>>> c4 = C(shared2)
# c1 and c2 sharing a reference to shared1
>>> c1.x.value
1
>>> c2.x.value
1
# change c2.x will reflect on c1 
>>> c2.x.value = 3
>>> c1.x.value
3
# but not on c3, because shared1 and shared2 are distinct namespaces
>>> c3.x.value
2
</code></pre>
<p>UPDATE : </p>
<p>But watch out , it is easy to make a mistake : </p>
<pre><code>>>> c4.x = 4
>>> c3.x.value
2
>>> c4.x.value
Traceback (most recent call last):
  File "<interactive input>", line 1, in <module>
AttributeError: 'int' object has no attribute 'value'
>>> 
</code></pre>
<p>I think the state of the art would be using <span style="background-color:yellow;">properties</span> to hide the __shared_instance in a <span style="background-color:yellow;">private</span> instance variable - so you <span style="background-color:yellow;">can</span> use <span style="background-color:yellow;">c1.x</span> instead of <span style="background-color:yellow;">c1.x.value</span> and avoid a typo like the example above . </p>
<br /><b># 3 </b><br /><p>I am lost in all these diverse answers . </p>
<p>But I think that what you need is expressed in the following <span style="background-color:yellow;">code</span> : </p>
<pre><code>class P:
    pvar=1                    # <--- class attribute
    def __init__(self,name):
        self.cname  = name

class C(P):
    def __init__(self,name):
        self.cname  = name


c1=C('1')
c2=C('2')

print
print "C.pvar ==",C.pvar,'  id(C.pvar) ==',id(C.pvar)
print "c1.pvar==",c1.pvar,'  id(c1.pvar)==',id(c1.pvar)
print "c2.pvar==",c2.pvar,'  id(c2.pvar)==',id(c2.pvar)

print
C.pvar = [1,2]
print "instruction   C.pvar = [1,2]   executed"
print "C.pvar ==",C.pvar,'  id(C.pvar) ==',id(C.pvar)
print "c1.pvar==",c1.pvar,'  id(c1.pvar)==',id(c1.pvar)
print "c2.pvar==",c2.pvar,'  id(c2.pvar)==',id(c2.pvar)

print
c2.__class__.pvar = 'sun'
print "instruction   c2.__class__.pvar = 'sun'   executed"
print "C.pvar ==",C.pvar,'  id(C.pvar) ==',id(C.pvar)
print "c1.pvar==",c1.pvar,'  id(c1.pvar)==',id(c1.pvar)
print "c2.pvar==",c2.pvar,'  id(c2.pvar)==',id(c2.pvar)

print
c2.pvar = 145
print "instruction   c2.pvar = 145   executed"
print "C.pvar ==",C.pvar,'  id(C.pvar) ==',id(C.pvar)
print "c1.pvar==",c1.pvar,'  id(c1.pvar)==',id(c1.pvar)
print "c2.pvar==",c2.pvar,'  id(c2.pvar)==',id(c2.pvar)
</code></pre>
<p>result </p>
<pre><code>C.pvar == 1   id(C.pvar) == 10021768
c1.pvar== 1   id(c1.pvar)== 10021768
c2.pvar== 1   id(c2.pvar)== 10021768

instruction   C.pvar = [1,2]   executed
C.pvar == [1, 2]   id(C.pvar) == 18729640
c1.pvar== [1, 2]   id(c1.pvar)== 18729640
c2.pvar== [1, 2]   id(c2.pvar)== 18729640

instruction   c2.__class__.pvar = 'sun'   executed
C.pvar == sun   id(C.pvar) == 18579136
c1.pvar== sun   id(c1.pvar)== 18579136
c2.pvar== sun   id(c2.pvar)== 18579136

instruction   c2.pvar = 145   executed
C.pvar == sun   id(C.pvar) == 18579136
c1.pvar== sun   id(c1.pvar)== 18579136
c2.pvar== 145   id(c2.pvar)== 10022024
</code></pre>
<p>I mean that what you must know is that to <span style="background-color:yellow;">change</span> , through an instruction implying directly the <span style="background-color:yellow;">name</span> of an instance ( and not through a <span style="background-color:yellow;">change</span> implying only the <span style="background-color:yellow;">parent</span> <span style="background-color:yellow;">class</span> 's <span style="background-color:yellow;">name</span> ) the <span style="background-color:yellow;">class</span> attribute <span style="background-color:yellow;">pvar</span> while it <span style="background-color:yellow;">continues</span> to be shared by all the <span style="background-color:yellow;">P</span> 's instances , you must write </p>
<pre><code>c2.__class__.pvar = something 
</code></pre>
<p>and not </p>
<pre><code>c2.pvar =something
</code></pre>
<p>Note that <span style="background-color:yellow;">C</span> is a <span style="background-color:yellow;">class</span> effectively inheriting from a <span style="background-color:yellow;">parent</span> <span style="background-color:yellow;">class</span> <span style="background-color:yellow;">P</span> </p>
<br /><b># 4 </b><br /><p>One thing you must know as a base of the understanding of functionning of <span style="background-color:yellow;">classes</span> and instances : </p>
<blockquote>
<p>A class instance has a namespace
  implemented as a dictionary which is
  the <strong>first place in which attribute
  references are searched</strong>.</p>
<p>When an attribute is not found there,
  and the instance’s class has an
  attribute by that name, the search
  continues with the class attributes.</p>
<p><a href="http://docs.python.org/reference/datamodel.html#the-standard-type-hierarchy" rel="nofollow">http://docs.python.org/reference/datamodel.html#the-standard-type-hierarchy</a></p>
</blockquote>
<p>In the second sentence , I do n't exactly understand the meaning of " by that <span style="background-color:yellow;">name</span> " , but I understand of the global that an attribute is searched first in the <span style="background-color:yellow;">namespace</span> of an instance and then in the <span style="background-color:yellow;">namespace</span> of its type . </p>
<p>In the following <span style="background-color:yellow;">code</span> : </p>
<ul>For <span style="background-color:yellow;">class</span> <span style="background-color:yellow;">P</span> and instance <span style="background-color:yellow;">c</span> : </ul>
<p>the <span style="background-color:yellow;">name</span> 'dataclass ' and <span style="background-color:yellow;">object</span> dataclass really belong to the <span style="background-color:yellow;">P</span> <span style="background-color:yellow;">class</span> 's <span style="background-color:yellow;">namespace</span> and only APPARENTLY belong to the <span style="background-color:yellow;">c</span> instance 's <span style="background-color:yellow;">namespace</span> : when <span style="background-color:yellow;">c.dataclass</span> is <span style="background-color:yellow;">called</span> , that 's in fact <span style="background-color:yellow;">c.__class__.dataclass</span> that is attained , by the <span style="background-color:yellow;">course</span> of search described above . </p>
<ul>But in an instance <span style="background-color:yellow;">cc</span> of the <span style="background-color:yellow;">class</span> <span style="background-color:yellow;">PP</span> , the <span style="background-color:yellow;">name</span> 'data ' , which belongs to the <span style="background-color:yellow;">P</span> <span style="background-color:yellow;">class</span> 's <span style="background-color:yellow;">namespace</span> , is assigned ( binded ) by the definition occuring in <span style="background-color:yellow;">__init__</span> ( ) to a new data <span style="background-color:yellow;">object</span> <span style="background-color:yellow;">created</span> in the <span style="background-color:yellow;">c</span> instance 's <span style="background-color:yellow;">namespace</span> . </ul>
<p>Hence , the only solution to obtain the <span style="background-color:yellow;">class</span> 's data 's value is to <span style="background-color:yellow;">call</span> it by its real reference , either <span style="background-color:yellow;">PP.data</span> or <span style="background-color:yellow;">cc.__class__.data</span> . </p>
<pre><code>class   P:
    dataclass    = "shareddata"

    def __init__(self,newdata):
        self.data   = newdata

    def printname(self):
        print   self.name

c = P(1)

print 'P.__dict__.keys()==',P.__dict__.keys()
print 'c.__dict__.keys()==',c.__dict__.keys()
print  
print 'c.data==',c.data
print 'c.dataclass==',c.dataclass


print 

class   PP:
    data    = "shareddata"

    def __init__(self,newdata):
        self.data   = newdata

    def printname(self):
        print   self.name

cc = PP(2)
print 'PP.__dict__.keys()==',PP.__dict__.keys()
print 'cc.__dict__.keys()==',cc.__dict__.keys()
print
print 'cc.data==',cc.data
print 'PP.data==',PP.data
print 'cc.__class__.data==',cc.__class__.data
</code></pre>
<p>result </p>
<pre><code>P.__dict__.keys()== ['dataclass', '__module__', 'printname', '__init__', '__doc__']
c.__dict__.keys()== ['data']

c.data== 1
c.dataclass== shareddata

PP.__dict__.keys()== ['__module__', 'data', 'printname', '__init__', '__doc__']
cc.__dict__.keys()== ['data']

cc.data== 2
PP.data== shareddata
cc.__class__.data== shareddata
</code></pre>
<p>. </p>
<p>Note : </p>
<blockquote>
<p><strong>dir([object])</strong></p>
<p>With an argument, attempt to return a
  list of valid attributes for that
  object.</p>
<p>If the object does not provide
  <strong>dir</strong>(), the function tries its best to gather information from the
  object’s <strong>dict</strong> attribute, if
  defined, and from its type object. </p>
<p>The default dir() mechanism behaves
  differently with different types of
  objects, as it attempts to produce the
  most relevant, rather than complete,
  information:</p>
<p>•If the object is a type or class
  object, the list contains the names of
  its attributes, and recursively of the
  attributes of its bases.</p>
<p>•Otherwise, the list contains the
  object’s attributes’ names, the names
  of its class’s attributes, and
  recursively of the attributes of its
  class’s base classes.</p>
<p><a href="http://docs.python.org/library/functions.html#dir" rel="nofollow">http://docs.python.org/library/functions.html#dir</a></p>
</blockquote>
<p>. </p>
<p>Hence , the use of dir ( ob ) to display the attributes of the <span style="background-color:yellow;">object</span> ob is a trap because it display more attributes than the ones belonging strictly to the <span style="background-color:yellow;">object</span> . </p>
<p>In other words , __dict__ is the real thing , while dir ( ) gives a dashboard , in a sense . </p>
<br /><b># 5 </b><br /><p>r6d9 , <span style="background-color:yellow;">please</span> , when you write an update , you should <span style="background-color:yellow;">put</span> the date and hour by the word UPDATE. It begins to be <span style="background-color:yellow;">complcated</span> to follow all that </p>
<p>. </p>
<p>. </p>
<p><span style="background-color:yellow;">Concerning</span> this <span style="background-color:yellow;">code</span> of you : </p>
<pre><code>def replaceinstance(parent,child):
    for item in parent.__dict__.items():
        child.__dict__.__setitem__(item[0],item[1])
        print item

class P(object):
    def __init__(self,pvar):
        self.pvar   = pvar
    def printname(self):
        print self.name

class C(P):
    def __init__(self,name,pobject):
        P.__init__(self,None)
        replaceinstance(pobject,self)
        self.name   = name
</code></pre>
<p>it <span style="background-color:yellow;">can</span> be replaced by this one : </p>
<pre><code>class P(object):
    def __init__(self,pvar):
        self.pvar   = pvar
    def printname(self):
        print self.name

class C(P):
    def __init__(self,name,pobject):
        P.__init__(self,None)
        self.pvar = pobject.pvar
        self.name   = name
</code></pre>
<p>but it seems to simple </p>
<br /><b># 6 </b><br /><p>Finally , I found a way to do it . </p>
<p>The key <span style="background-color:yellow;">point</span> is to abandon the aim to obtain instances <span style="background-color:yellow;">c</span> with real <span style="background-color:yellow;">pvar</span> field , because it is impossible : </p>
<p>Since it is the same _ init _ ( ) function ( the one being in <span style="background-color:yellow;">class</span> <span style="background-color:yellow;">P</span> ) that <span style="background-color:yellow;">processes</span> to <span style="background-color:yellow;">create</span> the <span style="background-color:yellow;">objects</span> <span style="background-color:yellow;">pvar</span> , it is n't <span style="background-color:yellow;">possible</span> to <span style="background-color:yellow;">create</span> <span style="background-color:yellow;">pvar</span> in instances <span style="background-color:yellow;">c</span> that will <span style="background-color:yellow;">points</span> to the <span style="background-color:yellow;">pvar</span> in an instance <span style="background-color:yellow;">p</span> to mirror its value and that will also give the <span style="background-color:yellow;">possibility</span> to <span style="background-color:yellow;">change</span> this value of a <span style="background-color:yellow;">p</span> 's <span style="background-color:yellow;">pvar</span> each time a <span style="background-color:yellow;">c</span> 's <span style="background-color:yellow;">pvar</span> 's value will <span style="background-color:yellow;">change.</span> That makes too much <span style="background-color:yellow;">contradictory</span> <span style="background-color:yellow;">conditions</span> to verify . </p>
<p><span style="background-color:yellow;">Consequently</span> , since the instances <span style="background-color:yellow;">c</span> <span style="background-color:yellow;">ca</span> n't have a real <span style="background-color:yellow;">pvar</span> field , the best is to set up a mechanism <span style="background-color:yellow;">controling</span> the <span style="background-color:yellow;">creation</span> of ( with _ setattr _ ) and access to ( with _ getattr _ ) these <span style="background-color:yellow;">c</span> 's seemingly <span style="background-color:yellow;">pvar</span> <span style="background-color:yellow;">objects</span> to give the illusion that they exist . </p>
<pre><code>class P(object):
    def __init__(self,pvar_arg,foo="^^^ "):
        self.pvar = pvar_arg
        self.cat  = foo
    def printname(self):
        print self.name

class C(P):

    def __init__(self,name,pobject,foo=''):
        self.__dict__['name'] = name
        P.__init__(self,None,pobject.cat+foo)
        C.dic[name] = pobject

    def __setattr__(self,xn,val):
        if xn!='pvar':
            self.__dict__[xn] = val
        elif self.name in C.dic:
            # During the creation of an instance c,
            # this condition is False because the instruction
            # C.dic[name] = pobject is  written after 
            # P.__init__(self,None,pobject.cat+foo).
            # Hence the value of pobject.pvar is preserved,
            # not changed with the value val being None
            # due to P.__init__(self,None,pobject.cat+foo)
            # that provokes self.pvar = pvar_arg and
            # consequently a call __setattr__(self,'pvar',None)
            C.dic[self.name].pvar = val

    def __getattribute__(self,xn):
        if xn=='pvar':
            return object.__getattribute__(C.dic[self.name],'pvar')
        else:
            return object.__getattribute__(self,xn)

    dic = {}


p1  = P("1")
p2  = P("2","QZX ")
print '--- p1  = P("1")  and  p2  = P("2","QZX ")  executed ---'
print "p1.__dict__  ==",p1.__dict__
print "p2.__dict__  ==",p2.__dict__
print 'p1.pvar==',p1.pvar
print 'p2.pvar==',p2.pvar

c1a = C("c1a",p1,'sea')
c1b = C("c1b",p1,'mountain')
c1c = C("c1c",p1,'desert')
c2a = C("c2a",p2,'banana')
c2b = C("c2b",p2)
c2c = C("c2c",p2,'pear')
print '\n--- creations of c1a, c1b, c1c, c2a, c2b, c2c executed ---'
print "p1.__dict__  ==",p1.__dict__
print "p2.__dict__  ==",p2.__dict__
print "c1a.__dict__ ==",c1a.__dict__
print "c1b.__dict__ ==",c1b.__dict__
print "c1c.__dict__ ==",c1c.__dict__
print "c2a.__dict__ ==",c2a.__dict__
print "c2b.__dict__ ==",c2b.__dict__
print "c2c.__dict__ ==",c2c.__dict__
print 'p1.pvar==',p1.pvar
print 'p2.pvar==',p2.pvar
print '(c1a.pvar, c1b.pvar, c1c.pvar)==',(c1a.pvar,c1b.pvar,c1c.pvar)
print '(c2a.pvar, c2b.pvar, c2c.pvar)==',(c2a.pvar,c2b.pvar,c2c.pvar)

c1a.pvar = "newpvar1"
print '\n--- c1a.pvar = "newpvar1"  executed ---'
print 'p1.pvar==',p1.pvar
print 'p2.pvar==',p2.pvar
print '(c1a.pvar, c1b.pvar, c1c.pvar)==',(c1a.pvar,c1b.pvar,c1c.pvar)
print '(c2a.pvar, c2b.pvar, c2c.pvar)==',(c2a.pvar,c2b.pvar,c2c.pvar)

c2c.pvar = 45789
print '\n--- c2c.pvar = 45789  executed ---'
print 'p1.pvar==',p1.pvar
print 'p2.pvar==',p2.pvar
print '(c1a.pvar, c1b.pvar, c1c.pvar)==',(c1a.pvar,c1b.pvar,c1c.pvar)
print '(c2a.pvar, c2b.pvar, c2c.pvar)==',(c2a.pvar,c2b.pvar,c2c.pvar)
</code></pre>
<p>result </p>
<pre><code>--- p1  = P("1")  and  p2  = P("2","QZX ")  executed ---
p1.__dict__  == {'cat': '^^^ ', 'pvar': '1'}
p2.__dict__  == {'cat': 'QZX ', 'pvar': '2'}
p1.pvar== 1
p2.pvar== 2

--- creations of c1a, c1b, c1c, c2a, c2b, c2c executed ---
p1.__dict__  == {'cat': '^^^ ', 'pvar': '1'}
p2.__dict__  == {'cat': 'QZX ', 'pvar': '2'}
c1a.__dict__ == {'name': 'c1a', 'cat': '^^^ sea'}
c1b.__dict__ == {'name': 'c1b', 'cat': '^^^ mountain'}
c1c.__dict__ == {'name': 'c1c', 'cat': '^^^ desert'}
c2a.__dict__ == {'name': 'c2a', 'cat': 'QZX banana'}
c2b.__dict__ == {'name': 'c2b', 'cat': 'QZX '}
c2c.__dict__ == {'name': 'c2c', 'cat': 'QZX pear'}
p1.pvar== 1
p2.pvar== 2
(c1a.pvar, c1b.pvar, c1c.pvar)== ('1', '1', '1')
(c2a.pvar, c2b.pvar, c2c.pvar)== ('2', '2', '2')

--- c1a.pvar = "newpvar1"  executed ---
p1.pvar== newpvar1
p2.pvar== 2
(c1a.pvar, c1b.pvar, c1c.pvar)== ('newpvar1', 'newpvar1', 'newpvar1')
(c2a.pvar, c2b.pvar, c2c.pvar)== ('2', '2', '2')

--- c2c.pvar = 45789  executed ---
p1.pvar== newpvar1
p2.pvar== 45789
(c1a.pvar, c1b.pvar, c1c.pvar)== ('newpvar1', 'newpvar1', 'newpvar1')
(c2a.pvar, c2b.pvar, c2c.pvar)== (45789, 45789, 45789)
</code></pre>
<p>Remarks : </p>
<ol>the attribute <span style="background-color:yellow;">name</span> must be defined before the instruction <span style="background-color:yellow;">P.</span> init ( <span style="background-color:yellow;">self,None,pobject.cat</span> + <span style="background-color:yellow;">foo</span> ) because the execution of this instruction <span style="background-color:yellow;">calls</span> <span style="background-color:yellow;">__setattr__</span> ( <span style="background-color:yellow;">self,'pvar</span> ' , " <span style="background-color:yellow;">1</span> " ) that executes itself the instruction <span style="background-color:yellow;">C.dic</span> [ <span style="background-color:yellow;">self.name</span> ] .pvar = " <span style="background-color:yellow;">1</span> " when <span style="background-color:yellow;">c1a</span> = <span style="background-color:yellow;">C</span> ( " <span style="background-color:yellow;">c1a</span> " ,p1,'sea ' ) is executed , for example . AnHence this <span style="background-color:yellow;">call</span> needs <span style="background-color:yellow;">self.name</span> as key for dic . I introduced <span style="background-color:yellow;">foo</span> and <span style="background-color:yellow;">cat</span> to justify the need to write the instruction <span style="background-color:yellow;">P.</span> init ( <span style="background-color:yellow;">self,None,pobject.cat</span> + <span style="background-color:yellow;">foo</span> ) otherwise , as no <span style="background-color:yellow;">pvar</span> is in fact defined into the instances <span style="background-color:yellow;">c</span> , this instuction would n't be useful . There are two situations in which <span style="background-color:yellow;">__setattr__</span> is <span style="background-color:yellow;">called</span> : at the <span style="background-color:yellow;">creation</span> of an instance , and at the modifications of the attributes of an existing instance. When an instance is <span style="background-color:yellow;">created</span> , the value of <span style="background-color:yellow;">pvar</span> of the instance <span style="background-color:yellow;">p</span> must remain unaffected by the instruction <span style="background-color:yellow;">C.dic</span> [ <span style="background-color:yellow;">self.name</span> ] .pvar = None . Hence the <span style="background-color:yellow;">condition</span> elif <span style="background-color:yellow;">self.name</span> in <span style="background-color:yellow;">C.dic</span> : In order that this <span style="background-color:yellow;">condition</span> gives a <span style="background-color:yellow;">correct</span> result , the instruction <span style="background-color:yellow;">C.dic</span> [ <span style="background-color:yellow;">name</span> ] = <span style="background-color:yellow;">pobject</span> must follow the <span style="background-color:yellow;">call</span> to <span style="background-color:yellow;">P.__init__</span> ( <span style="background-color:yellow;">self,None,pobject.cat</span> + <span style="background-color:yellow;">foo</span> ) </ol>
<p>. </p>
<p>EDIT <span style="background-color:yellow;">1</span> </p>
<p>I think it 's better to write </p>
<pre><code>def __setattr__(self,xn,val):
    if xn=='pvar':
        self.__class__.dic[self.name].pvar = val
</code></pre>
<p>than </p>
<pre><code>def __setattr__(self,xn,val):
    if xn=='pvar':
        C.dic[self.name].pvar = val
</code></pre>
<p>In the first <span style="background-color:yellow;">case</span> , the interpreter has to search for the reference to the <span style="background-color:yellow;">self</span> 's <span style="background-color:yellow;">class</span> <span style="background-color:yellow;">C</span> ( that is to say under the <span style="background-color:yellow;">name</span> '_ <span style="background-color:yellow;">class</span> _ ' ) in the <span style="background-color:yellow;">namespace</span> of <span style="background-color:yellow;">self</span> . </p>
<p>In the second <span style="background-color:yellow;">case</span> , the interpreter must search for the same reference ( but under the <span style="background-color:yellow;">name</span> 'C ' ) in the <span style="background-color:yellow;">namespace</span> of the level in which <span style="background-color:yellow;">classes</span> <span style="background-color:yellow;">P</span> and <span style="background-color:yellow;">C</span> are defined . </p>
<p>This second <span style="background-color:yellow;">namespace</span> may be more more big than the limited <span style="background-color:yellow;">namespace</span> of an instance. In the first <span style="background-color:yellow;">case</span> , the <span style="background-color:yellow;">name</span> '_ <span style="background-color:yellow;">class</span> _ ' is looked for as a key in the dictionary implementing the <span style="background-color:yellow;">self</span> 's <span style="background-color:yellow;">namespace</span> . In the second , the <span style="background-color:yellow;">name</span> 'C ' is the key searched for in the dictionary of the level inclosing the <span style="background-color:yellow;">classes</span> <span style="background-color:yellow;">P</span> and <span style="background-color:yellow;">C</span> . </p>
<p>The identity of these two <span style="background-color:yellow;">objects</span> <span style="background-color:yellow;">can</span> be verified with the function id ( ) </p>
<p>. </p>
<p>. </p>
<p>EDIT <span style="background-color:yellow;">2</span> </p>
<p>There is another <span style="background-color:yellow;">possibility</span> for the dic <span style="background-color:yellow;">object</span> : instead of making it a <span style="background-color:yellow;">class</span> attribute of the <span style="background-color:yellow;">class</span> <span style="background-color:yellow;">C</span> , it <span style="background-color:yellow;">can</span> be defined in the outer scope of the <span style="background-color:yellow;">class</span> <span style="background-color:yellow;">C</span> . If this outer level is a module , then dic is a global <span style="background-color:yellow;">object</span> . </p>
<pre><code>class P(object):
    def __init__(self,pvar,foo="^^^ "):
        self.pvar   = pvar
        self.cat = foo
    def printname(self):
        print self.name

class C(P):

    def __init__(self,name,pobject,foo=''):
        self.__dict__['name'] = name
        P.__init__(self,None,pobject.cat+foo)
        dic[name] = pobject

    def __setattr__(self,xn,val):
        if xn!='pvar':
            self.__dict__[xn] = val
        elif self.name in dic:
            # During the creation of an instance c,
            # this condition is False because the instruction
            # dic[name] = pobject is  written after 
            # P.__init__(self,None,pobject.cat+foo).
            # Hence the value of pobject.pvar is preserved,
            # not changed with the value val being None
            # due to P.__init__(self,None,pobject.cat+foo)
            # that provokes self.pvar = pvar_arg and
            # consequently a call __setattr__(self,'pvar',None)
            dic[self.name].pvar = val

    def __getattribute__(self,xn):
        if xn=='pvar':
            return object.__getattribute__(dic[self.name],'pvar')
        else:
            return object.__getattribute__(self,xn)


dic = {}
</code></pre>
<p>The result is exactly the same </p>
<p>Doing so , dic looses its OOish nature . </p>
<p>. </p>
<p>. </p>
<p>EDIT 3 </p>
<p>At last , there is still another way : instead of <span style="background-color:yellow;">creating</span> an illusory attribute <span style="background-color:yellow;">pvar</span> for each instance <span style="background-color:yellow;">c</span> with help of functions <span style="background-color:yellow;">__setattr__</span> and <span style="background-color:yellow;">__getattribute__</span> , it is better , according to me , to use a function with the dictionary dic as a default argument and that will replace them . </p>
<pre><code>class P(object):
    def __init__(self,pvar,foo="^^^ "):
        self.pvar   = pvar
        self.cat = foo
    def printname(self):
        print self.name

class C(P):
    def __init__(self,name,pobject,foo=''):
        P.__init__(self,None,pobject.cat+foo)
        self.__dict__['name'] = name
        del self.pvar
        self.pvar(pobject)

    def pvar(self,x = None,dic = {}):
        if x.__class__==P: # a pobject
            dic[self.name] = x
        elif x: # a value
            dic[self.name].pvar = x
        else: # to return value
            return dic[self.name].pvar

p1  = P("1")
p2  = P("2","QZX ")
print '--- p1  = P("1")  and  p2  = P("2","QZX ")  executed ---'
print "p1.__dict__  ==",p1.__dict__
print "p2.__dict__  ==",p2.__dict__
print 'p1.pvar==',p1.pvar
print 'p2.pvar==',p2.pvar

c1a = C("c1a",p1,'sea')
c1b = C("c1b",p1,'mountain')
c1c = C("c1c",p1,'desert')
c2a = C("c2a",p2,'banana')
c2b = C("c2b",p2)
c2c = C("c2c",p2,'pear')
print '\n--- creations of c1a, c1b, c1c, c2a, c2b, c2c executed ---'
print "p1.__dict__  ==",p1.__dict__
print "p2.__dict__  ==",p2.__dict__
print "c1a.__dict__ ==",c1a.__dict__
print "c1b.__dict__ ==",c1b.__dict__
print "c1c.__dict__ ==",c1c.__dict__
print "c2a.__dict__ ==",c2a.__dict__
print "c2b.__dict__ ==",c2b.__dict__
print "c2c.__dict__ ==",c2c.__dict__
print 'p1.pvar==',p1.pvar
print 'p2.pvar==',p2.pvar
print   '(c1a.pvar(),c1b.pvar(),c1c.pvar())==',(c1a.pvar(),c1b.pvar(),c1c.pvar())
print   '(c2a.pvar(),c2b.pvar(),c2c.pvar())==',(c2a.pvar(),c2b.pvar(),c2c.pvar())

c1a.pvar("newpvar1")
print '\n--- c1a.pvar("newpvar1")  executed ---'
print 'p1.pvar==',p1.pvar
print 'p2.pvar==',p2.pvar
print   '(c1a.pvar(),c1b.pvar(),c1c.pvar())==',(c1a.pvar(),c1b.pvar(),c1c.pvar())
print   '(c2a.pvar(),c2b.pvar(),c2c.pvar())==',(c2a.pvar(),c2b.pvar(),c2c.pvar())

c2c.pvar(45789)
print '\n--- c2c.pvar(45789) ---'
print 'p1.pvar==',p1.pvar
print 'p2.pvar==',p2.pvar
print   '(c1a.pvar(),c1b.pvar(),c1c.pvar())==',(c1a.pvar(),c1b.pvar(),c1c.pvar())
print   '(c2a.pvar(),c2b.pvar(),c2c.pvar())==',(c2a.pvar(),c2b.pvar(),c2c.pvar())
</code></pre>
<p>Results are the same , only use of <span style="background-color:yellow;">c.pvar</span> ( ) is slightly different : </p>
<pre><code>--- p1  = P("1")  and  p2  = P("2","QZX ")  executed ---
p1.__dict__  == {'cat': '^^^ ', 'pvar': '1'}
p2.__dict__  == {'cat': 'QZX ', 'pvar': '2'}
p1.pvar== 1
p2.pvar== 2

--- creations of c1a, c1b, c1c, c2a, c2b, c2c executed ---
p1.__dict__  == {'cat': '^^^ ', 'pvar': '1'}
p2.__dict__  == {'cat': 'QZX ', 'pvar': '2'}
c1a.__dict__ == {'cat': '^^^ sea', 'name': 'c1a'}
c1b.__dict__ == {'cat': '^^^ mountain', 'name': 'c1b'}
c1c.__dict__ == {'cat': '^^^ desert', 'name': 'c1c'}
c2a.__dict__ == {'cat': 'QZX banana', 'name': 'c2a'}
c2b.__dict__ == {'cat': 'QZX ', 'name': 'c2b'}
c2c.__dict__ == {'cat': 'QZX pear', 'name': 'c2c'}
p1.pvar== 1
p2.pvar== 2
(c1a.pvar(),c1b.pvar(),c1c.pvar())== ('1', '1', '1')
(c2a.pvar(),c2b.pvar(),c2c.pvar())== ('2', '2', '2')

--- c1a.pvar("newpvar1")  executed ---
p1.pvar== newpvar1
p2.pvar== 2
(c1a.pvar(),c1b.pvar(),c1c.pvar())== ('newpvar1', 'newpvar1', 'newpvar1')
(c2a.pvar(),c2b.pvar(),c2c.pvar())== ('2', '2', '2')

--- c2c.pvar(45789) ---
p1.pvar== newpvar1
p2.pvar== 45789
(c1a.pvar(),c1b.pvar(),c1c.pvar())== ('newpvar1', 'newpvar1', 'newpvar1')
(c2a.pvar(),c2b.pvar(),c2c.pvar())== (45789, 45789, 45789)
</code></pre>
<p>Note that in this last <span style="background-color:yellow;">code</span> <span style="background-color:yellow;">P</span> 's instances <span style="background-color:yellow;">ca</span> n't be values of <span style="background-color:yellow;">C</span> 'instances because a <span style="background-color:yellow;">pobject</span> <span style="background-color:yellow;">passed</span> to a <span style="background-color:yellow;">c.pvar</span> ( ) method will never be <span style="background-color:yellow;">considered</span> as a value . </p>
<br /><b># 7 </b><br /><p>Okay , I think you might want to rephrase your question as : </p>
<p>How <span style="background-color:yellow;">can</span> I extend <span style="background-color:yellow;">Python</span> 's OOP to make inheritance work on the level of <span style="background-color:yellow;">objects</span> rather than <span style="background-color:yellow;">classes</span> ? </p>
<p>First off - do n't mess with the dicts : If you are just <span style="background-color:yellow;">copying</span> the entries of the <span style="background-color:yellow;">parent</span> dict over to the <span style="background-color:yellow;">child-dict</span> , this works for instantiation , but <span style="background-color:yellow;">changes</span> in any of the dicts will not automagically update entries in all the other dicts. Assigning a new value to an attribute will simply <span style="background-color:yellow;">create</span> a new reference , so the attribute will not <span style="background-color:yellow;">point</span> to the same <span style="background-color:yellow;">object</span> any more . </p>
<p>The solution is to tell <span style="background-color:yellow;">python</span> to look for the attribute in the right <span style="background-color:yellow;">place</span> using some <span style="background-color:yellow;">Python</span> magic .. . </p>
<pre><code>class ProxyMixin (object):

    def __init__(self, parent):
        self.parent = parent

    def __getattribute__(self, name):
        if name != 'parent' and hasattr(self.parent, name):
            return getattr(self.parent, name)
        else:
            return object.__getattribute__(self, name)

    def __setattr__(self, name, val):
        if name != 'parent' and hasattr(self.parent, name):
            setattr(self.parent, name)
        else:
            object.__setattr__(self, name, val)
</code></pre>
<p>( see the <span style="background-color:yellow;">python</span> reference on attribute access ) </p>
<p>Just add the <span style="background-color:yellow;">ProxyMixin</span> to your <span style="background-color:yellow;">child</span> <span style="background-color:yellow;">class</span> , and you will be fine . </p>
<pre><code>class P:
    data = "shared data"
    def __init__(self, name):
        self.name = name
    def printname(self):
        print self.name

class C(P, ProxyMixin):
    def __init__(self, parent=None):
        if parent:
            ProxyMixin.__init__(self, parent)
</code></pre>
<p>Now youn <span style="background-color:yellow;">can</span> dynamically rewire the <span style="background-color:yellow;">parent</span> <span style="background-color:yellow;">object</span> at any time using a simple assignment : </p>
<pre><code>c.parent = newparent
</code></pre>
<br />