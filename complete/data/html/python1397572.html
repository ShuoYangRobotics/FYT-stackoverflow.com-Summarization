<h3>Question (ID-1397572):</h3><h2>How to reverse engineer a program which has no documentation</h2><p>I have a source of python program which doesn't have any documentation or comments. 
I did tried twice to understand it but most of the times I am losing my track, because there are many files. 
What should be the steps to understand that program fully and quickly.</p>
<br /><h3>Answers (Total-8):</h3><b>#0</b><br /><p><a href="http://www.objectmentor.com/omTeam/feathers%5Fm.html" rel="nofollow">Michael Feathers</a>' "<a href="http://www.informit.com/store/product.aspx?isbn=0131177052" rel="nofollow">Working Effectively with Legacy Code</a>" is a superb starting point for such endeavors -- not particularly language-dependent (his examples are in several non-python languages, but the techniques and mindset DO extend pretty well to Python and just about any other language).</p>

<p>The key focus is, that you want to understand the code <strong>for a reason</strong> -- modifying it and/or porting it. So, instrumenting the legacy code -- with batteries and scaffolding of tests and tracing/logging -- is the crucial path on the long, hard slog to understanding and modifying safely and responsibly.</p>

<p>Feathers suggests heuristics and techniques for where to focus your efforts and how to get started when the code is a total mess (hence "legacy") - no docs, or <strong>misleading</strong> docs (describing something quite different, maybe in subtle ways, from what the code actually DOES), no tests, an untestable-without-refactoring tangle of spaghetti dependencies. This may seem an extreme case but anybody who's spent a long-ish career in programming knows it's actually more common than anyone would like;-).</p>
<br /><b>#1</b><br /><ul>
<li>In past I have used <a href="http://pycallgraph.slowchop.com/" rel="nofollow">'Python call graph'</a> to understand the source structure</li>
<li>Use a debugger e.g. pdb to wak thru
the code.</li>
<li>Try to read code again after one day
break, that also helps</li>
</ul>
<br /><b>#2</b><br /><p>I would recommend to generate some documentation with epydoc <a href="http://epydoc.sourceforge.net/" rel="nofollow">http://epydoc.sourceforge.net/</a> . For sure, if no docstring exists, the result will be poor but it will give you at least one view of your application and you'lle be able to navigate in the classes more easily.</p>

<p>Then you can try to document by yourself when you understand something new and then regenerate the docs again. It is never too late to start something.</p>

<p>I hope it helps</p>
<br /><b>#3</b><br /><p>I have had to do a lot of this in my job. What works for me may be different to what works for you, but I'll share my experience.</p>

<p>I start by trying to identify the data structures being used and draw diagrams showing the relationships between them. Not necessarily something formal like UML, but a sketch on paper which <em>you</em> understand which allows you to see the overall structure of the data being manipulated by the program. Only once I have some view of the data structures being used do I start to try to understand <em>how</em> the data is being manipulated.</p>

<p>Secondly, for a large body of software, sometimes you need to just attack bite sized pieces at first. You won't get an overall understanding straight away, but if you understand small parts in detail and keep chipping away, eventually all the pieces fall together.</p>

<p>I combine these two approaches, switching between them when I am getting overly frustrated or bored. Regular walks around the block are recommended :) I find this gets me good results in the end.</p>

<p>Good luck!</p>
<br /><b>#4</b><br /><p>You are lucky it's in Python which is easy to read. But it is of course possible to write tricky hard to understand code in Python as well.</p>

<p>The steps are:</p>

<ol>
<li>Run the software and learn to use it, and understand it's features at least a little bit.</li>
<li>Read though the tests, if any.</li>
<li>Read through the code.</li>
<li>When you encounter code you don't understand, put a debug break there, and step through the code, looking at what it does.</li>
<li>If there aren't any tests, or the test coverage is low, write tests to increase the test coverage. It's a good way to learn the system.</li>
<li>Repeat until you feel you have a vague grip on the code. A vague grip is all you need if you are going to manage the code. You'll get a good grip once you start actually working  with the code. For a big system that can take years, so don't try to understand it all first.</li>
</ol>

<p>There are tools that can help you. As Stephen C says, an IDE is a good idea. I'll explain why:</p>

<p>Many editors analyses the code. This typically gives you code completion, but more importantly in this case, it makes it possible to just just ctrl-click on a variable to see where it comes from. This really speeds things up when you want to understand otehr peoples code.</p>

<p>Also, you need to learn a debugger. You will, in tricky parts of the code, have to step through them in a debugger to see what the code actually do. Pythons pdb works, but many IDE's have integrated debuggers, which make debugging easier.</p>

<p>That's it. Good luck.</p>
<br /><b>#5</b><br /><p>I'd start with a good python IDE.  See the answers for <a href="http://stackoverflow.com/questions/81584/what-ide-to-use-for-python">this question</a>.</p>
<br /><b>#6</b><br /><p><a href="http://www.sparxsystems.com.au/" rel="nofollow">Enterprise Architect</a> by Sparx Systems is very good at processing a source directory and generating class diagrams.  It is not free, but very reasonably priced for what you get.  (I am not associated with this company in any way, I've just been a satisfied user of their product for several years.)</p>
<br /><b>#7</b><br /><p>pyreverse from Logilab and PyNSource from Andy Bulka are helpful too for UML diagram generation.</p>
<br />