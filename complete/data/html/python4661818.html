<h3>Question (ID-4661818):</h3><h2>Code Golf: Finite-state machine!</h2><h2>Finite state machine</h2>

<p>A deterministic finite state machine is a simple computation model, widely used as an introduction to automata theory in basic CS courses. It is a simple model, equivalent to regular expression, which determines of a certain input string is <em>Accepted</em> or <em>Rejected</em>. <a href="http://en.wikipedia.org/wiki/Finite-state_machine#Mathematical_model" rel="nofollow">Leaving some formalities aside</a>, A run of a finite state machine is composed of:</p>

<ol>
<li><em>alphabet</em>, a set of characters.</li>
<li><em>states</em>, usually visualized as circles. One of the states must be the <em>start state</em>. Some of the states might be <em>accepting</em>, usually visualized as double circles.</li>
<li><em>transitions</em>, usually visualized as directed arches between states, are directed links between states associated with an alphabet letter.</li>
<li><em>input string</em>, a list of <em>alphabet</em> characters.</li>
</ol>

<p>A <em>run</em> on the machine begins at the starting state. Each letter of the input string is read; If there is a transition between the current state and another state which corresponds to the letter, the current state is changed to the new state. After the last letter was read, if the current state is an accepting state, the input string is accepted. If the last state was not an accepting state, or a letter had no corresponding arch from a state during the run, the input string is rejected.</p>

<p>Note: This short descruption is far from being a full, formal definition of a FSM; <a href="http://en.wikipedia.org/wiki/Finite-state_machine#Mathematical_model" rel="nofollow">Wikipedia's fine article</a> is a great introduction to the subject.</p>

<h2>Example</h2>

<p>For example, the following machine tells if a binary number, read from left to right, has an even number of <code>0</code>s:</p>

<p><img src="http://i.stack.imgur.com/fDBWN.png" alt="http://en.wikipedia.org/wiki/Finite-state_machine"></p>

<ol>
<li>The alphabet is the set <code>{0,1}</code>.</li>
<li>The states are S1 and S2.</li>
<li>The transitions are <code>(S1, 0) -&gt; S2</code>, <code>(S1, 1) -&gt; S1</code>, <code>(S2, 0) -&gt; S1</code> and <code>(S2, 1) -&gt; S2</code>.</li>
<li>The input string is any binary number, including an empty string.</li>
</ol>

<h2>The rules:</h2>

<p>Implement a FSM in a language of your choice. </p>

<h3>Input</h3>

<p>The FSM should accept the following input:</p>

<pre><code>&lt;States&gt;       List of state, separated by space mark.
               The first state in the list is the start state.
               Accepting states begin with a capital letter.
&lt;transitions&gt;  One or more lines. 
               Each line is a three-tuple:
               origin state, letter, destination state)
&lt;input word&gt;   Zero or more characters, followed by a newline.
</code></pre>

<p>For example, the aforementioned machine with <code>1001010</code> as an input string, would be written as:</p>

<pre><code>S1 s2
S1 0 s2
S1 1 S1
s2 0 S1
s2 1 s2
1001010
</code></pre>

<h3>Output</h3>

<p>The FSM's run, written as <code>&lt;State&gt; &lt;letter&gt; -&gt; &lt;state&gt;</code>, followed by the final state. The output for the example input would be:</p>

<pre><code>S1 1 -&gt; S1
S1 0 -&gt; s2
s2 0 -&gt; S1
S1 1 -&gt; S1
S1 0 -&gt; s2
s2 1 -&gt; s2
s2 0 -&gt; S1
ACCEPT
</code></pre>

<p>For the empty input <code>''</code>:</p>

<pre><code>S1
ACCEPT
</code></pre>

<p><strong>Note:</strong> Following your comments, the <code>S1</code> line (showing the first state) might be omitted, and the following output is also acceptable:</p>

<pre><code>ACCEPT
</code></pre>

<p>For <code>101</code>:</p>

<pre><code>S1 1 -&gt; S1
S1 0 -&gt; s2
s2 1 -&gt; s2
REJECT
</code></pre>

<p>For <code>'10X'</code>:</p>

<pre><code>S1 1 -&gt; S1
S1 0 -&gt; s2
s2 X
REJECT
</code></pre>

<h3>Prize</h3>

<p>A 250 rep bounty will be given to the shortest solution.</p>

<h2>Reference implementation</h2>

<p>A reference Python implementation is available <a href="http://friendpaste.com/58v7LrH0bGqC4b23QjYdDv" rel="nofollow">here</a>. Note that output requirements have been relaxed for empty-string input.</p>

<h1>Addendum</h1>

<h2>Output format</h2>

<p>Following popular demand, the following output is also acceptable for empty input string:</p>

<pre><code>ACCEPT
</code></pre>

<p>or</p>

<pre><code>REJECT
</code></pre>

<p>Without the first state written in the previous line.</p>

<h2>State names</h2>

<p>Valid state names are an English letter followed by any number of letters, <code>_</code> and digits, much like variable names, e.g. <code>State1</code>, <code>state0</code>, <code>STATE_0</code>.</p>

<h2>Input format</h2>

<p>Like most code golfs, you can assume your input is correct.</p>

<h2>Summary of answers:</h2>

<ul>
<li>Cobol - <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4662814#4662814">4078 characters</a></li>
<li>Python - <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4666506#4666506">171 characters</a>, <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4662032#4662032">568 characters</a>, <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4743454#4743454">203 characters</a>, <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4663124#4663124">218 characters</a>, <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4662150#4662150">269 characters</a></li>
<li>sed - <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4687779#4687779">137 characters</a></li>
<li>ruby - <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4723235#4723235">145 characters</a>, <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4666863#4666863">183 characters</a></li>
<li>Haskell - <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4666075#4666075">192 characters</a>, <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4708713#4708713">189 characters</a></li>
<li>LISP - <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4728522#4728522">725 characters</a></li>
<li>Perl - <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4709167#4709167">184 characters</a></li>
<li>Bash - <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4767994#4767994">184 characters</a></li>
<li>Rexx - <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4702588#4702588">205 characters</a></li>
<li>Lua - <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4748356#4748356">356 characters</a></li>
<li>F# - <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4766246#4766246">420 characters</a></li>
<li>C# - <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4753598#4753598">356 characters</a></li>
<li><a href="http://www.catb.org/~esr/mixal/" rel="nofollow">Mixal</a> - <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4788780#4788780">898 characters</a></li>
</ul>

<p>The <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4687779#4687779"><code>sed</code> 137 solution</a> is the shortest, <a href="http://stackoverflow.com/questions/4661818/code-golf-finite-state-machine/4723235#4723235">ruby 145</a> is #2. Currently, I can't get the sed solution to work:</p>

<pre><code>cat test.fsm | sed -r solution.sed
sed -r solution.sed test.fsm
</code></pre>

<p>both gave me:</p>

<pre><code>sed: -e expression #1, char 12: unterminated `s' command
</code></pre>

<p>so unless It there are clarifications the bounty goes to the ruby solution.</p>
<br /><h3>Answers (Total-20):</h3><b>#0</b><br /><h2>Python 2.7+, <del>201 192 187 181 179 175</del> 171 chars</h2>

<p>PS. After the problem was relaxed (no need to output state line on empty input), here is new code that's notably shorter. If you are on version &lt;2.7, there is no <em>dict comprehension</em>, so instead of <code>{c+o:s for o,c,s in i[1:-1]}</code> try <code>dict((c+o,s)for o,c,s in i[1:-1])</code> for the price of +5.</p>

<pre><code>import sys
i=map(str.split,sys.stdin)
s=i[0][0]
for c in''.join(i[-1]):
    if s:o=s;s={c+o:s for o,c,s in i[1:-1]}.get(c+s,());print o,c,'-&gt;',s
print'ARCECJEEPCTT'[s&gt;'Z'::2]
</code></pre>

<p>And its test output:</p>

<pre><code># for empty input
ACCEPT

# for input '1001010'
S1 1  -&gt;  S1
S1 0  -&gt;  s2
s2 0  -&gt;  S1
S1 1  -&gt;  S1
S1 0  -&gt;  s2
s2 1  -&gt;  s2
s2 0  -&gt;  S1
ACCEPT

# for input '101'
S1 1  -&gt;  S1
S1 0  -&gt;  s2
s2 1  -&gt;  s2
REJECT

# for input '10X'
S1 1  -&gt;  S1
S1 0  -&gt;  s2
s2 X  -&gt;  ()
REJECT

# for input 'X10'
S1 X  -&gt;  ()
REJECT
</code></pre>

<hr>

<p>Previous entry (len 201):</p>

<pre><code>import sys
i=list(sys.stdin)
s=i[0].split()[0]
t={}
for r in i[1:-1]:a,b,c=r.split();t[a,b]=c
try:
    for c in i[-1]:print s,c.strip(),;s=t[s,c];print' -&gt;',s
except:print('ACCEPT','REJECT')[s&gt;'Z'or' '&lt;c]
</code></pre>

<p>I want to apologize before someone slaps me for it: <strong>the code behavior is slightly different</strong> from the original spec - per question-comments discussion. This is my illustration for the discussion.</p>

<p>PS. while i like the resolution ACCEPT/REJECT on the same line with the final state, it can me moved to solitude (e.g. imagine results are to be parsed by stupid script that only cares about last line being accept or reject) by adding <code>'\n'+</code> (5 chars) to the last <code>print</code> for the price of +5 chars.</p>

<p>Example output:</p>

<pre><code># for empty input
S1  ACCEPT

# for input '1001010'
S1 1  -&gt; S1
S1 0  -&gt; s2
s2 0  -&gt; S1
S1 1  -&gt; S1
S1 0  -&gt; s2
s2 1  -&gt; s2
s2 0  -&gt; S1
S1  ACCEPT

# for input '101'
S1 1  -&gt; S1
S1 0  -&gt; s2
s2 1  -&gt; s2
s2  REJECT

# for input '10X'
S1 1  -&gt; S1
S1 0  -&gt; s2
s2 X REJECT

# for input 'X10'
S1 X REJECT
</code></pre>
<br /><b>#1</b><br /><p>I'm feeling retro today, my language of choice for this task is IBM Enterprise Cobol - char count <s>2462</s> 4078 (Sorry, pasted from a screen oriented device, trailing spaces are a tragic side effect):</p>

<pre><code> Identification Division.               
 Program-ID. FSM.                       
 Environment Division.                  
 Data Division.                         
 Working-Storage Section.               

 01 FSM-Storage.                        

*&gt; The current state                    
   05 Start-State      Pic X(2).        
   05 Next-State       Pic X(2).        

*&gt; List of valid states                 
   05 FSM-State-Cnt    Pic 9.           
   05 FSM-States       Occurs 9         
                       Pic X(2).        

*&gt; List of valid transitions            
   05 FSM-Trans-Cnt    Pic 999.         
   05 FSM-Trans        Occurs 999.      
     10 Trans-Start    Pic X(2).        
     10 Trans-Char     Pic X.           
     10 Trans-End      Pic X(2).        

*&gt; Input                                
   05 In-Buff          Pic X(72).      

*&gt; Some work fields                     
   05 II               Pic s9(8) binary.
   05 JJ               Pic s9(8) binary.

   05 Wk-Start         Pic X(2).        
   05 Wk-Char          Pic X.           
   05 Wk-End           Pic X(2).        
   05 Wk-Cnt           Pic 999.         

   05                  Pic X value ' '. 
     88 Valid-Input        value 'V'.   

   05                  Pic X value ' '.                 
     88 Valid-State        value 'V'.                   

   05                  Pic X value ' '.                 
     88 End-Of-States      value 'E'.                   

   05                  Pic X value ' '.                 
     88 Trans-Not-Found    value ' '.                   
     88 Trans-Found        value 'T'.                   


 Linkage Section.                                       

 01 The-Char-Area.                                      
   05 The-Char         Pic X.                           
     88 End-Of-Input       value x'13'.                 
   05 The-Next-Char    Pic X.                           

 Procedure Division.                                    

      Perform Load-States                               
      Perform Load-Transitions                          
      Perform Load-Input                                
      Perform Process-Input                             

      Goback.                                           

*&gt; Run the machine...                                   
 Process-Input.                                         

      Move FSM-States (1) to Start-State                
      Set address of The-Char-Area to address of In-Buff

      Perform until End-Of-Input                        

        Perform Get-Next-State                          
        Set address of The-Char-Area to address of The-Next-Char

        Move Next-State to Start-State                          

      End-Perform                                               

      If Start-State (1:1) is Alphabetic-Lower                  
        Display 'REJECT'                                        
      Else                                                      
        Display 'ACCEPT'                                        
      End-If                                                    

      Exit.                                                     

*&gt; Look up the first valid transition...                        
 Get-Next-State.                                                

      Set Trans-Not-Found to true                               
      Perform varying II from 1 by 1                            
        until (II &gt; FSM-State-Cnt)                              
           or Trans-Found                                       

        If Start-State = Trans-Start (II)                       
          and The-Char = Trans-Char (II)                        

          Move Trans-End (II) to Next-State                     
          Set Trans-Found to true                               

        End-If                                                  

      End-Perform                                               
      Display Start-State ' ' The-Char ' -&gt; ' Next-State        

      Exit.                                                     

*&gt; Read the states in...                                        
 Load-States.                                                   

      Move low-values to In-Buff                         
      Accept In-Buff from SYSIN                          

      Move 0 to FSM-State-Cnt                            
      Unstring In-Buff                                   
        delimited by ' '                                 
        into FSM-States (1) FSM-States (2) FSM-States (3)
             FSM-States (4) FSM-States (5) FSM-States (6)
             FSM-States (7) FSM-States (8) FSM-States (9)
        count in FSM-State-Cnt                           
      End-Unstring                                       

      Exit.                                              

*&gt; Read the transitions in...                            
 Load-Transitions.                                       

      Move low-values to In-Buff                         
      Accept In-Buff from SYSIN                          

      Perform varying II from 1 by 1                     
        until End-Of-States                              

        Move 0 to Wk-Cnt                                 
        Unstring In-Buff                                 
          delimited by ' '                               
          into Wk-Start Wk-Char Wk-End                   
          count in Wk-Cnt                                
        End-Unstring                                     

        If Wk-Cnt = 3                                    

          Add 1 to FSM-Trans-Cnt                         
          Move Wk-Start to Trans-Start (FSM-Trans-Cnt)   
          Move Wk-Char  to Trans-Char  (FSM-Trans-Cnt)   
          Move Wk-End   to Trans-End   (FSM-Trans-Cnt)   

          Move low-values to In-Buff                     
          Accept In-Buff from SYSIN                           

        Else                                                  

          Set End-Of-States to true                           

        End-If                                                

      End-Perform                                             

      Exit.                                                   

*&gt; Fix input so it has newlines...the joys of mainframes      
 Load-Input.                                                  

      Perform varying II from length of In-Buff by -1         
        until Valid-Input                                     

        If In-Buff (II:1) = ' ' or In-Buff (II:1) = low-values
          Move x'13' to In-Buff (II:1)                        
        Else                                                  
          Set Valid-Input to true                             
        End-If                                                

      End-Perform                                             

      Exit.                                                   

  End Program FSM.    
</code></pre>
<br /><b>#2</b><br /><h2>sed -- <s>118</s> 137 characters</h2>

<p>This is using the -r flag (+3), for a total of 134+3=137 characters.</p>

<pre><code>$!{H;D}
/:/!{G;s/(\S*)..(\S*)/\2 \1:/}
s/(.* .)(.*\n\1 (\S*))/\1 -&gt; \3\n\3 \2/
/-/{P;D}
/^[A-Z].* :/cACCEPT
s/( .).*/\1/
/:/!P
cREJECT
</code></pre>

<p>This should handle inputs without transitions correctly... hopefully it fully complies with the spec now...</p>
<br /><b>#3</b><br /><h2>Ruby 1.9.2 - <strike>178 190 182 177 153 161 158 154</strike> 145 characters</h2>

<pre><code>h={}
o=s=p
$&lt;.map{|l|o,b,c=l.split;h[[o,b]]=c;s||=o}
o.chars{|c|puts s+' '+c+((s=h[[s,c]])?' -&gt; '+s :'')}rescue 0
puts s&amp;&amp;s&lt;'['?:ACCEPT: :REJECT
</code></pre>

<h3>Testing Script</h3>

<pre><code>[
  "S1 s2
S1 0 s2
S1 1 S1
s2 0 S1
s2 1 s2
1001010",
  "S1 s2
S1 0 s2
S1 1 S1
s2 0 S1
s2 1 s2
101",
  "S1 s2
S1 0 s2
S1 1 S1
s2 0 S1
s2 1 s2
",
  "S1 s2
S1 0 s2
S1 1 S1
s2 0 S1
s2 1 s2
10X"
].each do |b|
  puts "------"
  puts "Input:"
  puts b
  puts
  puts "Output:"
  puts `echo "#{b}" | ruby fsm-golf.rb`
  puts "------"
end
</code></pre>

<h3>Outputs</h3>

<p>All input starts with:</p>

<pre><code>S1 s2
S1 0 s2
S1 1 S1
s2 0 S1
s2 1 s2
</code></pre>

<hr>

<pre><code>Input: '1001010'
Output:
S1 1 -&gt; S1
S1 0 -&gt; s2
s2 0 -&gt; S1
S1 1 -&gt; S1
S1 0 -&gt; s2
s2 1 -&gt; s2
s2 0 -&gt; S1
ACCEPT

Input: '101'
Output:
S1 1 -&gt; S1
S1 0 -&gt; s2
s2 1 -&gt; s2
REJECT

Input: 'X10'
Output:
S1 X
REJECT

Input: ''
Output:
ACCEPT

Input: '10X'
Output:
S1 1 -&gt; S1
S1 0 -&gt; s2
s2 X
REJECT
</code></pre>
<br /><b>#4</b><br /><p>Adam provided a reference implementation.  I didn't see it before I made mine, but the logic is similar:</p>

<p><strong>Edit:</strong> This is Python 2.6 code.  I did not try to minimize length; I just tried to make it conceptually simple.</p>

<pre><code>import sys
a = sys.stdin.read().split('\n')
states = a[0].split()
transitions = a[1:-2]
input = a[-2]
statelist = {}
for state in states:
    statelist[state] = {}

for start, char, end in [x.split() for x in transitions]:
    statelist[start][char] = end

state = states[0]
for char in input:
    if char not in statelist[state]:
        print state,char
        print "REJECT"
        exit()
    newstate = statelist[state][char]
    print state, char, '-&gt;', newstate
    state = newstate
if state[0].upper() == state[0]:
    print "ACCEPT"
else:
    print "REJECT"
</code></pre>
<br /><b>#5</b><br /><h2>Python, 218 characters</h2>

<pre><code>import sys
T=sys.stdin.read()
P=T.split()
S=P[0]
n="\n"
for L in P[-1]if T[-2]!=n else"":
 i=T.find(n+S+" "+L)
 if i&lt;0:print S,L;S=n;break
 S=T[i:].split()[2];print S,L,"-&gt;",S
print ("REJECT","ACCEPT")[S[0].isupper()]
</code></pre>
<br /><b>#6</b><br /><h2>Haskell - <strike>252</strike> <strike>216</strike> <strike>204</strike> <strike>197</strike> 192 characters</h2>

<pre><code>s%(c:d,t)=s++' ':c:maybe('\n':x)(\[u]-&gt;" -&gt; "++u++'\n':u%(d,t))(lookup[s,[c]]t)
s%_|s&lt;"["="ACCEPT\n"|1&lt;3=x
x="REJECT\n"
p(i:j)=(words i!!0)%(last j,map(splitAt 2.words)j)
main=interact$p.lines
</code></pre>

<p>Conforms to output specification.</p>

<p>Ungolf'd version:</p>

<pre><code>type State = String
type Transition = ((State, Char), State)

run :: [Transition] -&gt; State -&gt; String -&gt; [String]
run ts s (c:cs) =  maybe notFound found $ lookup (s,c) ts
  where
    notFound =  stateText                 : ["REJECT"]
    found u  = (stateText ++ " -&gt; " ++ u) : run ts u cs
    stateText = s ++ " " ++ [c]

run _ (s:_) "" | s &gt;= 'A' &amp;&amp; s &lt;= 'Z' = ["ACCEPT"]
               | otherwise            = ["REJECT"]

prepAndRun :: [String] -&gt; [String]
prepAndRun (l0:ls) = run ts s0 input
  where
    s0 = head $ words l0
    input = last ls
    ts = map (makeEntry . words) $ init ls
    makeEntry [s,(c:_),t] = ((s,c),t)

main' = interact $ unlines . prepAndRun . lines
</code></pre>

<p>A good puzzle is why <code>init</code> isn't needed in the golf'd version! Other than that, rest are all standard Haskell golf techniques.</p>
<br /><b>#7</b><br /><h1>Perl — 184 characters</h1>

<p>(Count excluding all newlines, which are optional.)</p>

<pre><code>($s)=split' ',&lt;&gt;;$\=$/;
while(&lt;&gt;){chomp;$r{$_[1].$_[0]}=$_[2]if split&gt;2;$t=$_}
$_=$t;
1 while$s&amp;&amp;s/(.)(.*)/print"$s $1",($s=$r{$1.$s})?" -&gt; $s":"";$2/e;
print$s=~/^[A-Z]/?"ACCEPT":"REJECT"
</code></pre>

<hr>

<p>Also, this 155-character program does not implement the intermediate outputs, but executes the machine entirely as a repeated substitution on the whole FSM definition (changing the start state and input string). It was inspired by, but not derived from, the <code>sed</code> solution. It could be shortened by 2 characters by converting the <code>(?:...)</code> into a <code>(...)</code> and renumbering as needed.</p>

<pre><code>$/="";$_=&lt;&gt;;
1 while s/\A(\S+)(?: +\S+)*\n(.*\n)?\1 +(.) +(.+)\n(.*\n)?\3([^\n]*)\n\z/$4\n$2$1 $3 $4\n$5$6\n/s;
print/\A[A-Z].*\n\n\z/s?"ACCEPT\n":"REJECT\n"
</code></pre>
<br /><b>#8</b><br /><h1>Python 3, Chars: 203</h1>

<p>The output format seems a bit hard to fit.</p>

<pre><code>import sys
L=[i.split()for i in sys.stdin]
N,P=L[0][0],print
for c in L[-1]and L[-1][-1]:
 if N:O,N=N,{(i[0],i[1]):i[2]for i in L[1:-1]}.get((N,c),'');P(O,c,N and'-&gt; '+N)
P(('REJECT','ACCEPT')[''&lt;N&lt;'_'])
</code></pre>
<br /><b>#9</b><br /><h1>Haskell - 189 characters</h1>

<pre><code>main=interact$r.lines
r f=g t z$last f where{(z:_):t=map words f;g _ s""|s&lt;"["="ACCEPT\n";g([q,j,p]:_)s(i:k)|i:s==j++q=s++' ':i:" -&gt; "++p++'\n':g t p k;g(_:y)s i=g y s i;g _ _ _="REJECT\n"}
</code></pre>

<p>EDIT: Does not correctly implement the output for no-transition rejection.</p>

<p>Line-broken version and variable guide:</p>

<pre><code>-- r: run FSM
-- f: fsm definition as lines
-- z: initial state

-- g: loop function
-- t: transition table
-- s: current state
-- i: current input
-- k: rest of input

-- q: transition table match state
-- j: transition table match input
-- p: transition table next state
-- y: tail of transition table

main=interact$r.lines;
r f=g t z$last f where{
(z:_):t=map words f;
g _ s""|s&lt;"["="ACCEPT\n";
g([q,j,p]:_)s(i:k)|i:s==j++q=s++' ':i:" -&gt; "++p++'\n':g t p k;
g(_:y)s i=g y s i;
g _ _ _="REJECT\n"}
</code></pre>

<p>I got the <code>s&lt;"["</code> technique from MtnViewMark's solution; the rest is my own design. Notable characteristics:</p>

<ul>
<li>The input is left as junk in the transition table. This is OK as long as the input does not contain two spaces; but note that the transition rule format is arguably unfriendly to transitioning on the space character anyway.</li>
<li>Stepping through the input string and searching the transition table are the same function.</li>
<li>Both REJECT cases are handled by the same fallthrough.</li>
</ul>
<br /><b>#10</b><br /><p><strong>Common Lisp - 725</strong></p>

<pre><code>(defun split (string)
  (loop for i = 0 then (1+ j)
     as j = (position #\Space string :start i)
     collect (subseq string i j)
     while j))

(defun do-fsm ()
  (let* ((lines (loop for l = (read-line *standard-input* nil)
      until (not l)
     collect (split l)))
  (cur (caar lines))
  (transitions (subseq lines 1 (- (length lines) 1))))
    (if (or (loop for c across (caar (last lines))
      do (format t "~a ~a" cur c)
        when (not (loop for tr in transitions
       when (and (equal cur (car tr))
          (equal c (char (cadr tr) 0)))
       return (progn (format t " -&gt; ~a~%"
        (setq cur (caddr tr)))
       t)
         ))
        return t)
     (lower-case-p (char cur 0)))
 (format t "~%REJECT~%")
 (format t "ACCEPT~%"))))
</code></pre>

<p>No real attempt to minimize the code -- Common Lisp pays a heavy penalty in the required input processing, so I don't think there's much chance of this solution winning :-) </p>
<br /><b>#11</b><br /><h2>Ruby — 183</h2>

<pre><code>h={}
r=$&lt;.read
t=s=r.split[0]
i=r[-1]=="
"?"":r.split[-1]
r.scan(/(\S+) (.) (.+)/){|a,b,c|h[[a,b]]=c}
i.chars{|c|puts s+" #{c} -&gt; #{s=h[[s,c]]}"}
puts s&amp;&amp;s[/^[A-Z]/]?"ACCEPT":"REJECT"
</code></pre>

<p>Really, strange output specification. Here how my works: <a href="http://ideone.com/cxweL" rel="nofollow">http://ideone.com/cxweL</a></p>
<br /><b>#12</b><br /><h2>Rexx 205 characters</h2>

<p>(This answer went through few edits as I initially just posted some code for general interest and then decided to actually post a real solution)</p>

<p>Here's a Rexx version to give people a taste for that less known lanugage.  Rexx <a href="http://en.wikipedia.org/wiki/REXX" rel="nofollow">http://en.wikipedia.org/wiki/REXX</a> is an interpreted language used in IBM's VM/CMS mainframe operating system and later in IBM OS/2 (and I believe there was an Amiga variant).  It's a very expressive language and an amazing general purpose/"scripting" language.</p>

<pre><code>Parse pull i .
d.='~'
Do until l='';Parse pull o l d.o.l;End
Do j=1 to LENGTH(o)
t=SUBSTR(o,j,1);p=i t;i=d.i.t
If i=d. then Do;Say p;Leave;End
Say p '-&gt;' i
End
Say WORD('ACCEPT REJECT',c2d(left(i,1))%32-1)
</code></pre>

<p>This can be run with the <a href="http://regina-rexx.sourceforge.net/" rel="nofollow">Regina Rexx</a> interpreter.</p>

<p>Handling the incorrect transition scenario with its unique output and also testing for uppercase is a bit expensive.</p>

<p>Code from some older edits below for people interested in the Rexx syntax, those aren't 100% compliant with the output requirements but are functional (all code in this answer works with the samples I pasted below but the code above handles the other required corners):</p>

<p>Older short version:</p>

<pre><code>Parse pull i .
Do until l = ""; Parse pull o l d; t.o.l = d; End
Do j=1 to LENGTH(o); t=substr(o,j,1); Say i t "-&gt;" t.i.t; i=t.i.t; End
If LEFT(i,1)='S' then Say 'ACCEPT'; else say 'REJECT'
</code></pre>

<p>Longer version:</p>

<pre><code>Parse pull initial . /* Rexx has a powerful built in string parser, this takes the first word into initial */

Do until letter = "" /* This style of do loops is a bit unusual, note how it doesn't matter that letter isn't defined yet */
  Parse pull origin letter destination /* Here we parse the inpt line into three words */
  transition.origin.letter = destination /* Rexx has a very powerful notion of associative containers/dictionaries, many years pre-Python */
End

/* Now we take the last line and iterate over the transitions */
Do i = 1 to LENGTH(origin) 
  t = substr(origin, i, 1) /* This is the actual letter using Rexx's string functions */
  Say initial t "-&gt;" transition.initial.t /* Say is like print */
  initial = transition.initial.t /* Perform the transition */
End

/* check for uppercase in the current state */
if left(initial, 1) = 'S' then Say 'ACCEPT'; else say 'REJECT'
</code></pre>

<p>Sample in/out:</p>

<pre><code>S1 s2
S1 0 s2
0
S1 0 -&gt; s2
REJECT

S1 s2
S1 0 s2
S1 1 S1
s2 0 S1
s2 1 s2
1001010
S1 1 -&gt; S1
S1 0 -&gt; s2
s2 0 -&gt; S1
S1 1 -&gt; S1
S1 0 -&gt; s2
s2 1 -&gt; s2
s2 0 -&gt; S1
ACCEPT
</code></pre>
<br /><b>#13</b><br /><p><strong>Lua, 356</strong></p>

<p>Takes any nonspace characters for states, and any non-space one characters for transition letters. Though it seems not shortest, I'll post it any way.
Could save 25 chars printing tabs instead of spaces.</p>

<p>Readable version:</p>

<pre><code>i=io.read
p=print
S={}
i():gsub("(%S+)",function (a) f=f or a S[a]={} end )
l=i"*a"
for a,t,d in l:gmatch"(%S+) (%S) (%S+)"do
    S[a][t]=d
end
I=l:match"(%S+)%s$"or"" -- fixes empty input
function F(a,i)
    t=I:sub(i,i)
    if t==""then
        p"ACCEPT"
    elseif S[a][t] then
        p(("%s %s -&gt; %s"):format(a,t, S[a][t]))
        return F( S[a][t],i+1)
    else
        if t~=""then p(a.." "..t)end p'REJECT'
    end
end
F(f,1)
</code></pre>

<p>Golfed version + in- an output.</p>

<pre><code>i=io.read p=print S={}i():gsub('(%S+)',function(a)f=f or a S[a]={}end)l=i'*a'for a,t,d in l:gmatch"(%S+) (%S) (%S+)"do S[a][t]=d end I=l:match'(%S+)%s$'or''function F(a,i)t=I:sub(i,i)if t==""and a:match'^%u'then p'ACCEPT'elseif S[a][t]then p(('%s %s -&gt; %s'):format(a,t,S[a][t]))return F(S[a][t],i+1)else if t~=''then p(a.." "..t)end p'REJECT'end end F(f,1)
-- input --
A B C   
A B B
A C C
A A A
B A A 
B B B
B C C
C A A 
C B B
C C C
AABCCBCBAX
-- output --

A A -&gt; A
A A -&gt; A
A B -&gt; B
B C -&gt; C
C C -&gt; C
C B -&gt; B
B C -&gt; C
C B -&gt; B
B A -&gt; A
REJECT
</code></pre>
<br /><b>#14</b><br /><h1>bash - <strike>186 185</strike> 184 chars</h1>

<pre>declare -A a
read s x
while read f m t&&[ $m ];do a[$f $m]=$t;done
for((i=0;i-${#f};i++))do b="$s ${f:i:1}";s=${a[$b]};echo $b -\> $s;done
[ "$s" = "${s,}" ]&&echo REJECT||echo ACCEPT</pre>

<p>Note that this does actually require bash - POSIX sh doesn't have associative arrays or the C-style for syntax (and probably doesn't have all the parameter expansions used either, although I haven't checked).</p>

<p>Edit: alternatively, for the exact same length,</p>

<pre>declare -A a
read s x
while read f m t&&[ $m ];do a[$f $m]=$t;done
while [ $f ];do b="$s ${f:i:1}";f=${f:1};s=${a[$b]};echo $b -\> $s;done
[ "$s" = "${s,}" ]&&echo REJECT||echo ACCEPT</pre>
<br /><b>#15</b><br /><h2><a href="http://en.wikipedia.org/wiki/MIXAL" rel="nofollow">MIXAL</a> 898 characters</h2>

<pre><code>    ORIG    3910
A   ALF ACCEP
    ALF T    
    ORIG    3940
R   ALF REJEC
    ALF T    
    ORIG    3970
O   CON 0
    ALF -&gt;   
    ORIG    3000
S   ENT6    0
T   IN  0,6(19)
    INC6    14
    JBUS    *(19)
    LDA -14,6
    JANZ    T
    LDA -28,6(9)
    DECA    30
    JAZ C
    DECA    1
    JANZ    B
C   LD2 0(10)
    ENT4    -28,6
    ENT5    9
D   JMP G
    ENT3    0
F   INC3    14
    LD1 0,3(10)
    DEC2    0,1
    J2Z M
    INC2    0,1
    DEC3    -28,6
    J3NN    U
    INC3    -28,6
    JMP F
M   INC2    0,1
    LD1 0,3(36)
    DECA    0,1
    JAZ H
    INCA    0,1
    JMP F
H   INCA    0,1
    ST2 O(10)
    LD2 1,3(10)
    STA O(36)
    ST2 O+1(37)
    OUT O(18)
    JBUS    *(18)
    JMP D
    HLT
E   LD1 0(10)
    DEC1    0,2
    J1Z B
U   OUT R(18)
    JBUS    *(18)
    HLT
B   OUT A(18)
    JBUS    *(18)
    HLT
G   STJ K
    ST5 *+1(36)
    LDA 0,4
    JAZ E
    DECA    30
    JAZ I
    DECA    1
    JANZ    W
    INCA    1
I   INCA    30
    DEC5    45
    J5NN    J
    INC5    54
    JMP K
J   INC4    1
    ENT5    9
K   JMP *
W   ST2 O(10)
    INCA    31
    STA O(36)
    STZ O+1
    OUT O(18)
    JBUS    *(18)
    JMP B
    END S
</code></pre>

<h3>Deify Knuth!</h3>
<br /><b>#16</b><br /><h2>Python (2.6) ~ 269 characters.</h2>

<p>Probably still room for improvement, hints welcome. 
Handles specifications I think.</p>

<pre><code>import sys;a=sys.stdin.readlines();b=a[0].split()
f=b[0];d=dict((x,{})for x in b);s=''
for x,y,z in map(str.split,a[1:-1]):d[x][y]=z
for g in a[-1]:
 try:s+=f+' '+g;f=d[f][g];s+=' -&gt; '+f+'\n'
 except:s+='\n';break
print s+("REJECT","ACCEPT")[ord(f[0])&lt;90 and g in d[f]]
</code></pre>
<br /><b>#17</b><br /><h1><strong>Lua - <strike>248</strike> 227</strong></h1>

<pre><code>r=...
p=print
M={}
s=r:match('(%a%d)')
for i,n,o in r:gmatch('(%a%d)%s(%d)%s(%a%d)')do
M[i]=M[i]or{}
M[i][n]=o
end
for c in r:match('%d%d+'):gmatch('(%d)')do
z=s
s=M[z][c]
p(z,c,'-&gt;',s)
end
p(s==s:upper()and'ACCEPT'or'REJECT')
</code></pre>

<p>check running version on <a href="http://codepad.org/qZ6CeCmu" rel="nofollow">codepad</a> <a href="http://codepad.org/PEdQkG9M" rel="nofollow"><strike>old version</strike></a></p>
<br /><b>#18</b><br /><p><strong>C# - <strike>453</strike> <strike>375</strike> <strike>353</strike> 345 characters</strong></p>

<p>This doesn't win (not that anyone should have expected it to), but it was fun to write anyway.  I kept the leading spaces and newlines for legibility:</p>

<pre><code>using System;
class P
{
  static void Main()
  {
    string c,k="";
    var t=new string[99999][];
    int p=-1,n;
    while((c=Console.ReadLine())!="")
      t[++p]=c.Split(' ');

    c=t[0][0];
    foreach(var d in t[p][0]){
      k+=c+' '+d;
      for(n=1;n&lt;p;n++)
        if(c==t[n][0]&amp;&amp;d==t[n][1][0])
      {
        c=t[n][2];
        k+=" -&gt; "+c;
        break;
      }
      k+="\n";
      if(n==p){
        c="~";
        break;
      }
    }
    Console.Write(k+(c[0]&gt;'Z'?"REJECT":"ACCEPT"));
  }
}
</code></pre>

<p>In my last update I was able to save 22 characters by assuming a practical limit to the number of input rows (namely 99,999).  In the worst case, you'd need to up that to the Int32 max of 2,147,483,647 which would add 5 chars.  My machine doesn't like the idea of an array that long though...</p>

<p>An example of the execution:</p>

<pre><code>&gt;FSM.exe
S1 s2
S1 0 s2
S1 1 S1
s2 0 S1
s2 1 s2
1001010

S1 1 -&gt; S1
S1 0 -&gt; s2
s2 0 -&gt; S1
S1 1 -&gt; S1
S1 0 -&gt; s2
s2 1 -&gt; s2
s2 0 -&gt; S1
ACCEPT
</code></pre>
<br /><b>#19</b><br /><h1>F# 420</h1>

<p>Not bad for immutable golf I think.  I didn't do very good on the course today though.</p>

<pre><code>open System
let f,p,a=Array.fold,printf,Map.add
let l=Console.In.ReadToEnd().Split '\n'
let e,s=l.Length,l.[0].Split ' '
let t,w=Map.ofList[for q in s-&gt;q,Map.empty],[|"ACCEPT";"REJECT"|]
let m=f(fun t (r:String)-&gt;let s=r.Split ' 'in a s.[0](t.[s.[0]]|&gt;a s.[1].[0]s.[2])t)t l.[1..e-2]
try let r=l.[e-1].ToCharArray()|&gt;f(fun s c-&gt;p"%s %c "s c;let n=m.[s].[c]in p"-&gt; %s\n"n;n)s.[0]in p"%s"w.[int r.[0]/97]with|_-&gt;p"%s"w.[1]
</code></pre>

<p>33 lines for un-golfed F#.  I'll update again in a bit after I've golfed.</p>

<pre><code>open System

let input = Console.In.ReadToEnd()
//let input = "S1 s2\nS1 0 s2\nS1 1 S1\ns2 0 S1\ns2 1 s2\n1001010"
let lines = input.Split '\n'
let length = lines.Length
let states = lines.[0].Split ' '

let stateMap = Map.ofList [for state in states -&gt; (state, Map.empty)]

let folder stateMap (line:String) =
    let s = line.Split ' '
    stateMap |&gt; Map.add s.[0] (stateMap.[s.[0]] |&gt; Map.add s.[1].[0] s.[2])

let machine = Array.fold folder stateMap lines.[1 .. (length-2)]

let stateMachine state char =
    printf "%s %c " state char
    let newState = machine.[state].[char]
    printfn "-&gt; %s" newState
    newState

try
    let result = 
        lines.[length-1].ToCharArray()
        |&gt; Array.fold stateMachine states.[0]

    if Char.IsUpper result.[0] then
        printf "ACCEPT"
    else
        printf "REJECT"
with
    | _ -&gt; printf "REJECT"
</code></pre>
<br />