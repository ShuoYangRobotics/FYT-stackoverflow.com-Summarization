<h3>Question (ID-1935990):</h3><h2>Excluding last element in 0-based indexing</h2><p>Once when I was reading some python docs I came across a reference to an article that explained why programming languages with 0-based indexing should always exclude the last element during operations like slicing:</p>

<pre><code>&gt;&gt; a = [1, 2, 3]
&gt;&gt; a[0:1]
[1]  #and not [1,2]
</code></pre>

<p>Unfortunately I did not bookmark it. Does anyone know which article I am talking about?</p>

<p>PS: I welcome any explanations of why this is for my immediate satisfaction :-)</p>
<br /><h3>Answers (Total-6):</h3><b>#0</b><br /><p>Could it be <a href="http://www.cs.utexas.edu/~EWD/ewd08xx/EWD831.PDF" rel="nofollow">this note</a> from E. W. Dijkstra?</p>
<br /><b>#1</b><br /><p>No, but there are at least two good reasons:</p>

<ol>
<li><code>a[m:n]</code> gives you <em>n</em>-<em>m</em> elements, making it easy to compute how many elements you are requesting.</li>
<li>With inclusive end-points, it's awkward to request an empty slice (<code>a[3:2]</code>? yuck).</li>
</ol>

<p><strong>Edit:</strong> I just thought of another Python-specific reason: a[m:-n] excludes the first <em>m</em> and last <em>n</em> items. If it was inclusive, it would exclude the first <em>m</em> and last <em>n</em>-1 items, which is much harder to remember.</p>
<br /><b>#2</b><br /><p>You might be thinking of <a href="http://nedbatchelder.com/blog/200909/why%5Fnumbering%5Fshould%5Fstart%5Fat%5Fzero.html" rel="nofollow">Dijkstra's short note about zero-based numbering</a>.</p>
<br /><b>#3</b><br /><p>I don't know exactly which article you are referring to, but Googling <a href="http://www.google.com/search?q=half-open+ranges" rel="nofollow">half-open ranges</a> should find it for you.  It found <a href="http://www.siliconbrain.com/ranges.htm" rel="nofollow">this surprisingly good one</a> that I think is a new personal favorite.</p>
<br /><b>#4</b><br /><p>As far as I know, the first extensive treatment in print was in Koenig's great book, <a href="http://rads.stackoverflow.com/amzn/click/0201179288" rel="nofollow">C Traps and Pitfalls</a> -- 20 years old and still in print (indeed, in-stock and shipped immediately from Amazon!-), quite a tribute to its nature as a classic.  Unfortunately, there are no previews of it available in Google Books, and while the PDF of the internal report which formed the book <em>is</em> available <a href="http://www.literateprogramming.com/ctraps.pdf" rel="nofollow">online</a>, it's obviously much shorter than the book and in particular it does not mention the "open-ranges" issue.  There are of course pirate copies on the web, but I don't recommend downloading those.</p>

<p>Several years ago, I summarized Koenig's reasoning <a href="http://groups.google.com/group/comp.lang.python/msg/1bf4d925dfbf368?pli=1" rel="nofollow">here</a>, with a followup discussion <a href="http://mail.python.org/pipermail/python-list/2001-May/682787.html" rel="nofollow">here</a>, but of course that's no substitute for the complete treatment as found in his book (though it may be a helpful complement, as in the second post in particular I add other observations in response to critique that was posted on that thread).</p>
<br /><b>#5</b><br /><p>Don't know any specific article, but I think the rationale is simply that this way you get the number of resulting elements via simple subtraction, 1-0=1, instead of having to add 1 there (which you would forget half of the time anyway).</p>
<br />