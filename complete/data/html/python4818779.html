<h3>Question (ID-4818779):</h3><h2>Good source code for compiler components</h2><p>I am currently taking a course on Compilers. I don't like the idea of blindly memorising facts without any sort of place to apply them to. I want to learn by hands-on doing. </p>

<p>So, I would like to have the complete code of 3-4 compilers, possibly for languages with different syntax rules (python,c, c++, java) while working through the Dragon book.</p>

<p>If complete compilers are too much of an ask, examples of parsers(well-written LL, LR, LALR parsers) and intermediate-code generators for these languages would also do. </p>

<p>There is a LOT of code out there on the Internet regarding this, but I want something that is considered to be high-quality and standard. I would be grateful for any resources that you can refer me to in this matter. Thanks. </p>
<br /><h3>Answers (Total-6):</h3><b>#0</b><br /><p>You can grab code for the Lua compiler from lua.org, they distribute full source, and you could also get GCC's source code, which is both C and C++ compiling.</p>
<br /><b>#1</b><br /><p>There is a bunch of simple and comprehendable compilers:</p>

<ul>
<li><a href="http://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler" rel="nofollow">http://spivey.oriel.ox.ac.uk/corner/Oxford_Oberon-2_compiler</a></li>
<li><a href="http://caml.inria.fr/caml-light/index.en.html" rel="nofollow">http://caml.inria.fr/caml-light/index.en.html</a></li>
<li><p><a href="http://bellard.org/tcc/" rel="nofollow">http://bellard.org/tcc/</a></p>

<p>And some tools, not complete compilers, but still useful:</p></li>
<li><a href="http://cil.sourceforge.net/" rel="nofollow">http://cil.sourceforge.net/</a> (a complete C parser and code analysis tool)</li>
<li><a href="http://scottmcpeak.com/elkhound/" rel="nofollow">http://scottmcpeak.com/elkhound/</a> (a complete C++ parser)</li>
</ul>

<p><strong>UPDATE:</strong></p>

<p>Probably the most impressive one:
 - <a href="http://community.schemewiki.org/?90min-scheme2c" rel="nofollow">http://community.schemewiki.org/?90min-scheme2c</a></p>
<br /><b>#2</b><br /><p>The Python parser documentation.  The source is part of your Python distribution.  Install Python and you'll have the module's source.</p>

<p><a href="http://docs.python.org/library/parser.html#module-parser" rel="nofollow">http://docs.python.org/library/parser.html#module-parser</a></p>

<p>The older Compiler package.</p>

<p><a href="http://docs.python.org/library/compiler.html" rel="nofollow">http://docs.python.org/library/compiler.html</a></p>
<br /><b>#3</b><br /><ul>
<li>C/C++: <a href="http://gcc.gnu.org/releases.html" rel="nofollow">GCC</a> (old and crusty codebase, but extremely popular), or <a href="http://clang.llvm.org/" rel="nofollow">clang</a> (newer, modular, getting close to production quality, backed by Apple among others). There's also <a href="http://bellard.org/tcc/" rel="nofollow">TCC</a> - the Tiny C Compiler, which would probably be good for learning.</li>
<li>Python: <a href="http://codespeak.net/pypy/dist/pypy/doc/" rel="nofollow">PyPy</a>, <a href="http://www.stackless.com/" rel="nofollow">stackless python</a>, or the original <a href="http://www.python.org/download/" rel="nofollow">cpython</a> are good implementations</li>
<li>Java: If you just care about the bytecode compiler, look at e.g., <a href="http://jikes.sourceforge.net/" rel="nofollow">Jikes</a>. If you want the JIT and whatnot as well, <a href="http://openjdk.java.net/" rel="nofollow">openjdk</a> is for you.</li>
</ul>

<p>That said, real compilers can be quite complex; building a toy compiler may be easier to understand. That said, TCC would likely be the best starting point out of this group, as it's small enough to easily understand.</p>
<br /><b>#4</b><br /><p>Your course on compilers should be giving you the pieces that will eventually lead to a full blown compiler.  </p>

<p>For example, the section on lexical analysis can lead to a component called the Lexer.  If you keep an eye open to generics and re-usability, you can turn this into a component that can be used later in your compiler.</p>

<p>I highly suggest you take the approach of having at least two components in every homework project:  <code>main</code> and the library component.  In the example of lexical analysis, the <code>main</code> component would handle input and testing.  The library component would be the lexer.  This technique will help greatly after you graduate and develop huge applications in the real world. </p>
<br /><b>#5</b><br /><p>I would definitely look into <a href="http://llvm.org/" rel="nofollow">The LLVM Compiler Infrastructure</a>.  It is not a compiler by itself, but rather core tools for writing compilers, interpreters and virtual machines.  Clang is a C/C++ compiler built on this framework.</p>

<p>Just note that implementing compiler theory directly will yield a very naive compiler.  Most compilers extend that theory with many years of advanced research on parsing techniques, optimizations and code generation.</p>

<p>If you can, look into smaller projects, limited to a single architecture (i.e. some RISC computer) and a single language.  Once you've progressed through that, look into bigger compiler suites which support multiple languages on the front-end and multiple architectures on the back-end.</p>
<br />