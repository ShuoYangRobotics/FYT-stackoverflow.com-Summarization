<h3>Question (ID-3559548):</h3><h2>Calculating e with high precision with python?</h2><p>*Is it possible to calculate the value of the mathematical constant, <strong><em>e</em></strong> with high precision (2000+ decimal places) with Python? (I was thinking with Numpy or SciPy)</p>
<br /><h3>Answers (Total-6):</h3><b>#0</b><br /><p>you can set the precision you want with the <a href="http://docs.python.org/library/decimal.html" rel="nofollow">decimal</a> <strong>built-in module</strong>:</p>

<pre><code>from decimal import *
getcontext().prec = 40
Decimal(1).exp()
</code></pre>

<p>returned:</p>

<pre><code>Decimal('2.718281828459045235360287471352662497757')
</code></pre>
<br /><b>#1</b><br /><p>This can also be done with <a href="http://code.google.com/p/sympy/">sympy</a> using <a href="http://docs.sympy.org/modules/evalf.html">numerical evaluation</a>:</p>

<pre><code>import sympy

print sympy.N(sympy.E, 100)
</code></pre>
<br /><b>#2</b><br /><p>Using a series sum you could calculate it:</p>

<pre><code>getcontext().prec = 2000
e = Decimal(0)
i = 0
while True:
    fact = math.factorial(i)
    e += Decimal(1)/fact
    i += 1
    if fact &gt; 10**2000: break
</code></pre>

<p>But that's not really necessary, as what Mermoz did agrees just fine with it:</p>

<pre><code>&gt;&gt;&gt; e 
Decimal('2.7182818284590452353602874713526624977572470936999595749669676 
277240766303535475945713821785251664274274663919320030599218174135966290 
435729003342952605956307381323286279434907632338298807531952510190115738 
341879307021540891499348841675092447614606680822648001684774118537423454 
424371075390777449920695517027618386062613313845830007520449338265602976 
067371132007093287091274437470472306969772093101416928368190255151086574 
637721112523897844250569536967707854499699679468644549059879316368892300 
987931277361782154249992295763514822082698951936680331825288693984964651 
058209392398294887933203625094431173012381970684161403970198376793206832 
823764648042953118023287825098194558153017567173613320698112509961818815 
930416903515988885193458072738667385894228792284998920868058257492796104 
841984443634632449684875602336248270419786232090021609902353043699418491 
463140934317381436405462531520961836908887070167683964243781405927145635 
490613031072085103837505101157477041718986106873969655212671546889570350 
354021234078498193343210681701210056278802351930332247450158539047304199 
577770935036604169973297250886876966403555707162268447162560798826517871 
341951246652010305921236677194325278675398558944896970964097545918569563 
802363701621120477427228364896134225164450781824423529486363721417402388 
934412479635743702637552944483379980161254922785092577825620926226483262 
779333865664816277251640191059004916449982893150566047258027786318641551 
956532442586982946959308019152987211725563475463964479101459040905862984 
967912874068705048958586717479854667757573205681288459205413340539220001 
137863009455606881667400169842055804033637953764520304024322566135278369 
511778838638744396625322498506549958862342818997077332761717839280349465 
014345588970719425863987727547109629537415211151368350627526023264847287 
039207643100595841166120545297030236472549296669381151373227536450988890 
313602057248176585118063036442812314965507047510254465011727211555194866 
850800368532281831521960037356252794495158284188294787610852639810')
&gt;&gt;&gt; Decimal(1).exp() 
Decimal('2.7182818284590452353602874713526624977572470936999595749669676 
277240766303535475945713821785251664274274663919320030599218174135966290 
435729003342952605956307381323286279434907632338298807531952510190115738 
341879307021540891499348841675092447614606680822648001684774118537423454 
424371075390777449920695517027618386062613313845830007520449338265602976 
067371132007093287091274437470472306969772093101416928368190255151086574 
637721112523897844250569536967707854499699679468644549059879316368892300 
987931277361782154249992295763514822082698951936680331825288693984964651 
058209392398294887933203625094431173012381970684161403970198376793206832 
823764648042953118023287825098194558153017567173613320698112509961818815 
930416903515988885193458072738667385894228792284998920868058257492796104 
841984443634632449684875602336248270419786232090021609902353043699418491 
463140934317381436405462531520961836908887070167683964243781405927145635 
490613031072085103837505101157477041718986106873969655212671546889570350 
354021234078498193343210681701210056278802351930332247450158539047304199 
577770935036604169973297250886876966403555707162268447162560798826517871 
341951246652010305921236677194325278675398558944896970964097545918569563 
802363701621120477427228364896134225164450781824423529486363721417402388 
934412479635743702637552944483379980161254922785092577825620926226483262 
779333865664816277251640191059004916449982893150566047258027786318641551 
956532442586982946959308019152987211725563475463964479101459040905862984 
967912874068705048958586717479854667757573205681288459205413340539220001 
137863009455606881667400169842055804033637953764520304024322566135278369 
511778838638744396625322498506549958862342818997077332761717839280349465 
014345588970719425863987727547109629537415211151368350627526023264847287 
039207643100595841166120545297030236472549296669381151373227536450988890 
313602057248176585118063036442812314965507047510254465011727211555194866 
850800368532281831521960037356252794495158284188294787610852639814') 
</code></pre>
<br /><b>#3</b><br /><p>I would think you could combine the info from these webpages:</p>

<p><a href="http://en.wikipedia.org/wiki/Taylor_series" rel="nofollow">http://en.wikipedia.org/wiki/Taylor_series</a></p>

<p>This gives you the familiar power series. Since you're working with large factorial numbers you should then probably work with gmpy which implements multiiprecision arithmetic. An example for the evaluation of pi is given here</p>

<p><a href="http://wj32.wordpress.com/2007/12/04/ways-to-calculate-pi-in-python/" rel="nofollow">http://wj32.wordpress.com/2007/12/04/ways-to-calculate-pi-in-python/</a></p>
<br /><b>#4</b><br /><p>The excellent pure-python library, <a href="http://code.google.com/p/mpmath/" rel="nofollow">Mpmath</a>, will certainly do the trick. </p>

<p>The sole focus of this library is <em>multi-precision floating-point arithmetic</em>.</p>

<p>E.g., <em>Mpath</em> can evaluate <strong><em>e</em></strong> to arbitrary precision:</p>

<pre><code>In [2]: from mpmath import *
# set the desired precision on the fly
In [3]: mp.dps=20; mp.pretty=True
In [4]: +e
Out[4]: 2.7182818284590452354

# re-set the precision (50 digits)
In [5]: mp.dps=50; mp.pretty=True
In [6]: +e
Out[6]: 2.7182818284590452353602874713526624977572470937
</code></pre>

<p>As an aside, Mpmath is also tightly integrated with Matplotlib.</p>
<br /><b>#5</b><br /><p>Using Sage:</p>

<pre><code>N(e, digits=2000)
</code></pre>
<br />