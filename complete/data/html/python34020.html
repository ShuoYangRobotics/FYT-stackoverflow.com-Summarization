<h3>Question (ID-34020):</h3><h2>Are Python threads buggy?</h2><p>A reliable coder friend told me that Python's current multi-threading implementation is seriously buggy - enough to avoid using altogether.  What can said about this rumor?</p>
<br /><h3>Answers (Total-6):</h3><b>#0</b><br /><p>Python threads are good for <strong>concurrent I/O programming</strong>. Threads are swapped out of the CPU as soon as they block waiting for input from file, network, etc. This allows other Python threads to use the CPU while others wait. This would allow you to write a multi-threaded web server or web crawler, for example.</p>

<p>However, Python threads are serialized by the <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" rel="nofollow">GIL</a> when they enter interpreter core. This means that if two threads are crunching numbers, only one can run at any given moment. It also means that you can't take advantage of multi-core or multi-processor architectures.</p>

<p>There are solutions like running multiple Python interpreters concurrently, using a C based threading library. This is not for the faint of heart and the benefits might not be worth the trouble. Let's hope for an all Python solution in a future release.</p>
<br /><b>#1</b><br /><p>The standard implementation of Python (generally known as CPython as it is written in C) uses OS threads, but since there is the <a href="http://en.wikipedia.org/wiki/Global_Interpreter_Lock" rel="nofollow">Global Interpreter Lock</a>, only one thread at a time is allowed to run Python code.  But within those limitations, the threading libraries are robust and widely used.</p>

<p>If you want to be able to use multiple CPU cores, there are a few options.  One is to use multiple python interpreters concurrently, as mentioned by others.  Another option is to use a different implementation of Python that does not use a GIL.  The two main options are <a href="http://en.wikipedia.org/wiki/Jython" rel="nofollow">Jython</a> and <a href="http://en.wikipedia.org/wiki/IronPython" rel="nofollow">IronPython</a>.</p>

<p>Jython is written in Java, and is now fairly mature, though some incompatibilities remain.  For example, the web framework <a href="http://zyasoft.com/pythoneering/2008/01/django-on-jython-minding-gap.html" rel="nofollow">Django does not run perfectly yet</a>, but is getting closer all the time.  Jython is <a href="http://mail.python.org/pipermail/python-list/2001-December/116555.html" rel="nofollow">great for thread safety</a>, comes out <a href="http://blogs.warwick.ac.uk/dwatkins/entry/benchmarking_parallel_python_1_2/" rel="nofollow">better in benchmarks</a> and has a <a href="http://cgwalters.livejournal.com/17956.html" rel="nofollow">cheeky message for those wanting the GIL</a>.</p>

<p>IronPython uses the .NET framework and is written in C#.  Compatibility is reaching the stage where <a href="http://www.infoq.com/news/2008/03/django-and-ironpython" rel="nofollow">Django can run on IronPython</a> (at least as a demo) and there are <a href="http://www.voidspace.org.uk/ironpython/threading.shtml" rel="nofollow">guides to using threads in IronPython</a>.</p>
<br /><b>#2</b><br /><p>The GIL (Global Interpreter Lock) might be a problem, but the API is quite OK. Try out the excellent <code>processing</code> module, which implements the Threading API for separate processes. I am using that right now (albeit on OS X, have yet to do some testing on Windows) and am really impressed. The Queue class is really saving my bacon in terms of managing complexity!</p>

<p><strong>EDIT</strong>: it seemes the processing module is being included in the standard library as of version 2.6 (<code>import multiprocessing</code>). Joy!</p>
<br /><b>#3</b><br /><p>As far as I know there are no real bugs, but the performance when threading in cPython is really bad (compared to most other threading implementations, but usually good enough if all most of the threads do is block) due to the <a href="http://docs.python.org/api/threads.html" rel="nofollow">GIL</a> (Global Interpreter Lock), so really it is implementation specific rather than language specific. Jython, for example, does not suffer from this due to using the Java thread model.</p>

<p>See <a href="http://www.artima.com/weblogs/viewpost.jsp?thread=214235" rel="nofollow">this</a> post on why it is not really feasible to remove the GIL from the cPython implementation, and <a href="http://www.pyzine.com/Issue001/Section_Articles/article_ThreadingGlobalInterpreter.html" rel="nofollow">this</a> for some practical elaboration and workarounds.</p>

<p>Do a quick google for <a href="http://www.google.com/search?q=python+gil" rel="nofollow">"Python GIL"</a> for more information.</p>
<br /><b>#4</b><br /><p>If you want to code in python and get great threading support, you might want to check out IronPython or Jython. Since the python code in IronPython and Jython run on the .NET CLR and Java VM respectively, they enjoy the great threading support built into those libraries. In addition to that, IronPython doesn't have the GIL, an issue that prevents CPython threads from taking full advantage of multi-core architectures.</p>
<br /><b>#5</b><br /><p>I've used it in several applications and have never had nor heard of threading being anything other than 100% reliable, as long as you know its limits.  You can't spawn 1000 threads at the same time and expect your program to run properly on Windows, however you can easily write a worker pool and just feed it 1000 operations, and keep everything nice and under control.</p>
<br />