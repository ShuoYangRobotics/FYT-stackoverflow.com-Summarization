<h3>Question (ID-1865727):</h3><h2>How to design an application in a modular way?</h2><p><strong>I am looking for pointers, suggestions, links, warnings, ideas and even anecdotical accounts about <em>"how to design an application in a modular way"</em>. I am going to use python for this project, but advice does not need to necessarily refer to this language, although I am only willing to implement a design based on OOP.</strong></p>

<p>Here's some context to understand where I come from and what I am trying to achieve...</p>

<p><hr></p>

<p>My project will be a small application that will consume web services and display the results in a variety of ways, including:</p>

<ul>
<li>notification popup containing just the result of the call</li>
<li>tab in the main window of the application with graphics plotted from retrieved raw-data</li>
<li>buffer of messages (visible on domand) where results from various services will pile up</li>
</ul>

<p>The application will be released as free (as-in-speech) software, and for this reason I would like to <strong>make it really easy for other devs to write plugins/modules</strong> that will extend the functionality of the main application without needing to change the core code.</p>

<p>At this point in time, <strong>plugins should essentially enable a developer to activate a new webservice, by defining the provider, the data manipulation (if any) and the way the data will be presented to the user</strong>.</p>

<p>I have extensive experience in developing with <a href="http://drupal.org/" rel="nofollow">drupal</a> which has a powerful modular approach, but that also follows a non-object-oriented design, so I suspect that for python, drupal design might not be the optimal solution.</p>

<p>If this is of any importance - the core will be natively developed for GNU/Linux.</p>

<p>Thank you in advance for your time!</p>
<br /><h3>Answers (Total-6):</h3><b>#0</b><br /><p><strong><em>Short Answer to make Modular Design</em></strong></p>

<p>You can check,</p>

<ul>
<li>(Inversion of control) pattern</li>
<li>Dependency Injection pattern</li>
<li>Locator pattern</li>
</ul>

<p>All of them are described in <strong><a href="http://martinfowler.com/articles/injection.html" rel="nofollow">Martin Fowler:IOC</a></strong> and <strong><a href="http://msdn.microsoft.com/en-us/library/cc304758.aspx" rel="nofollow">Microsoft:Modularity</a></strong></p>

<p><strong><em>to Implement them in real world</em></strong></p>

<blockquote>
  <p>First of all select methadologies to
  planning and processing project. I use
  <strong><a href="http://en.wikipedia.org/wiki/SCRUM" rel="nofollow">Scrum</a></strong>.</p>
</blockquote>

<p><img src="http://www.russianit.info/en/scrum/scrum%5Flarge.gif" alt="SCRUM"></p>

<p><hr></p>

<blockquote>
  <p>Test is more important than coding and
  check out <a href="http://en.wikipedia.org/wiki/Test-driven%5Fdevelopment" rel="nofollow"><strong>TDD</strong></a></p>
</blockquote>

<p><img src="http://upload.wikimedia.org/wikipedia/en/9/9c/Test-driven%5Fdevelopment.PNG" alt="TDD"></p>

<p><hr></p>

<blockquote>
  <p>Also <a href="http://en.wikipedia.org/wiki/Refactoring" rel="nofollow"><strong>Refactoring</strong></a> is important.</p>
</blockquote>

<p><img src="http://www.simple-talk.com/iwritefor/articlefiles/330-Fig2RefactoringD-jan07.gif" alt="REFACTORING"></p>

<p><hr></p>

<blockquote>
  <p>Source Version Control (<strong><a href="http://subversion.tigris.org/" rel="nofollow">SVN</a></strong>, <a href="http://en.wikipedia.org/wiki/Concurrent%5FVersions%5FSystem" rel="nofollow"><strong>CVS</strong></a>,
  <a href="http://git-scm.com/" rel="nofollow"><strong>GIT</strong></a> etc.)  is important</p>
</blockquote>

<p><img src="http://media.wiley.com/assets/400/98/image1Large.jpg" alt="SOURCE CONTROL"></p>

<p><hr></p>

<blockquote>
  <p><strong><a href="http://en.wikipedia.org/wiki/Continuous%5Fintegration" rel="nofollow">Continious Integration</a></strong> (<strong><a href="https://hudson.dev.java.net/" rel="nofollow">Hudson</a></strong>, <strong><a href="http://cruisecontrol.sourceforge.net/" rel="nofollow">Cruise Control</a></strong> etc.)
  is important. (Also you can check
  <strong><a href="http://www.developer.com/java/ent/article.php/10933%5F3803646%5F1/The-Best-Continuous-Integration-Tools.htm" rel="nofollow">Continious Integration Tools</a></strong>)</p>
</blockquote>

<p><img src="http://www.methodsandtools.com/archive/CI1.jpg" alt="alt text"></p>

<p><hr></p>

<blockquote>
  <p>Keep everythings simple, don't make
  things harder.</p>
</blockquote>

<p><img src="http://intranetblog.blogware.com/IA%20sample.jpg" alt="KISS"></p>

<p><hr></p>

<blockquote>
  <p>Use <a href="http://maven.apache.org/" rel="nofollow"><strong>maven</strong></a> or same things to
  manage dependency (this can help in
  modular way) Additional you can check
  <strong><a href="http://www.grails.org/" rel="nofollow">Grails</a></strong> and <strong><a href="http://appfuse.org/display/APF/Home" rel="nofollow">AppFuse</a></strong></p>
</blockquote>

<p><img src="http://www.javaworld.com/javaworld/jw-12-2005/images/jw-1205-maven2.gif" alt="MAVEN"></p>

<p><hr></p>

<blockquote>
  <p>Use <a href="http://en.wikipedia.org/wiki/Object-oriented%5Fprogramming" rel="nofollow"><strong>software pattern, oo
  principles</strong></a> etc. and patterns,
  principles, idea based frameworks
  (like <a href="http://www.springsource.org/" rel="nofollow"><strong>spring</strong></a>,
  <a href="http://code.google.com/p/google-guice/" rel="nofollow"><strong>guice</strong></a> etc.).</p>
</blockquote>

<p><img src="http://www.restafari.org/005-object-oriented-sheep-running-in-ruby-shoes/animals.png" alt="OO"></p>

<p><hr></p>

<blockquote>
  <p>Also be careful to select which
  language, Os platform, technologies
  etc. that you choose. It usually
  depends on what do you want to
  develop.</p>
</blockquote>

<p><img src="http://phpimpact.files.wordpress.com/2008/06/programming%5Flanguages.png" alt="SAMPLE LANGUAGE GRAPH"></p>

<p><hr></p>

<blockquote>
  <p><strong><a href="http://en.wikipedia.org/wiki/Issue%5Ftracking%5Fsystem" rel="nofollow">Issiu tracking</a></strong> is important also. We can use <strong><a href="http://trac.edgewall.org/" rel="nofollow">trac</a></strong>, <strong><a href="http://www.bugzilla.org/" rel="nofollow">bugzilla</a></strong> etc.
  Eclipse and another IDEs have got
  connector of tracking system.</p>
</blockquote>

<p><img src="http://www.alliancetechpartners.com/attask/sol-issue-tracking.gif" alt="alt text"></p>

<p><hr></p>

<blockquote>
  <p>And last, <strong><a href="http://www.manageability.org/" rel="nofollow">manageability</a></strong> is No:1
  important things.</p>
</blockquote>

<p><img src="http://wiki.laptop.org/images/f/ff/Important.png" alt="IMPORTANT"></p>

<p><hr></p>

<p><strong>After that we can develop everything in modular etc.</strong></p>
<br /><b>#1</b><br /><p>As you will deliver some basic functionality with your app, make sure that you code the part that should be extendable/replaceable already as a plugin by yourself. Then you'll best get a feeling about how your API should look like.</p>

<p>And to prove that the API is good, you should write a second and third plugin, because then you will discover that you made a lot of assumptions when writing the first one. Normally things clear up a bit after doing this 2nd and 3rd step.</p>

<p>Now, you should write one more plugin, because the last plugins you wrote resemble the first one in type, input data and presentation (maybe yet another weather webservice). Choose something total different, with absolutely different data, and you will see your API being still too tailored. (Else you did a good job!)</p>
<br /><b>#2</b><br /><p>Try to keep things loosely coupled, and use interfaces liberally to help.</p>

<p>I'd start the design with the <em>Separation of Concerns</em>.  The major architectural layers are:</p>

<ul>
<li>Problem Domain (aka. Engine, Back-end): the domain classes, which do all the actual work, have domain knowledge implement domain behaviour</li>
<li>Persistence: storage management for domain classes, database/filesystem layer</li>
<li>User Interface: the GUI, which talks to the domain classes</li>
<li>System Interfaces: talking to other systems, eg. networking, web services</li>
</ul>

<p>The domain classes do the work, but don't know about the UI.  The persistence layer knows about the domain classes, enough to save/load as required.  The system interface layer abstracts away external systems, which lets you plug a simulator in behind while testing.  The UI should ideally use MVC, for maximum flexibility.</p>

<p>Without putting too fine a point on it, one would not ordinarily look to Drupal as an exemplar of good architectural design.  It has grown rather organically, and there have been many upheavals of the design, as evidenced by the regular plugin breakage upon system upgrades.</p>

<p>I would also echo what MicSim said, regarding carefully designing the plugin interface and writing multiple different plugins to exercise it.  This is the only way to really flesh out the issues of how the app and plugins interact.</p>
<br /><b>#3</b><br /><p>Well, probably the first place to start is to sit down and figure out what the plug-in might need to fulfill its purpose.</p>

<p>You'd want to consider two main aspects in your design.</p>

<ul>
<li>How will your framework pass requests / receive responses from the plug-in?</li>
<li>What helper classes or modules might be good to provide?</li>
</ul>

<p>And probably also, since this sounds like a learning project.</p>

<ul>
<li>What do you want to write yourself, and what are you happy just to pick out of an existing library?</li>
</ul>

<p>I'd also recommend developing some basic plugins as you design the API. The experience of having to actually use what you design will allow you to see where a given approach might be making things harder than they need to be.</p>
<br /><b>#4</b><br /><ul>
<li>design the api for your app, carefully (<a href="http://www.youtube.com/watch?v=aAb7hSCtvGw" rel="nofollow">How To Design A Good API and Why it Matters</a>)</li>
<li>make everything, which could be used independently a module, then group and build larger parts out of the simple parts (KISS)</li>
<li>don't repeat yourself (DRY)</li>
<li>write/publish short documentation frequently, for yourself and others (open source mantra) ...</li>
</ul>
<br /><b>#5</b><br /><p>Look into the listener-subscriber pattern. Sooner or later, your app will be complex enough that you need to implement callbacks. When you hit that limit, use listener-subscriber (there's an implementation in wxPython).</p>

<p>For example, several modules will want to watch for new data from a number of feeds. Modules that link together might want to update themselves, based on new data.</p>
<br />