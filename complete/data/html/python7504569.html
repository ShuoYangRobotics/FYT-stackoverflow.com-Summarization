<h3>Question (ID-7504569):</h3><h2>catch wrong-arguments exception, in the general case</h2><p>I want to catch an exception, but only if it comes from the very next level of logic.</p>

<p>The intent is to handle errors caused by the act of calling the function with the wrong number of arguments, without masking errors generated by the function implementation.</p>

<p>How can I implement the <code>wrong_arguments</code> function below?</p>

<p>Example:</p>

<pre><code>try:
    return myfunc(*args)
except TypeError, error:
    #possibly wrong number of arguments
    #we know how to proceed if the error occurred when calling myfunc(), 
    #but we shouldn't interfere with errors in the implementation of myfunc
    if wrong_arguments(error, myfunc):
        return fixit()
    else:
        raise
</code></pre>

<hr>

<p>Addendum:</p>

<p>There are several solutions that work nicely in the simple case, but none of the current answers will work in the real-world case of decorated functions.</p>

<p>Consider that these are possible values of <code>myfunc</code> above:</p>

<pre><code>def decorator(func):
    "The most trivial (and common) decorator"
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)

def myfunc1(a, b, c='ok'):
    return (a, b, c)

myfunc2 = decorator(myfunc1)
myfunc3 = decorator(myfunc2)
</code></pre>

<p>Even the conservative look-before-you-leap method (inspecting the function argument spec) fails here, since most decorators will have an argspec of <code>*args, **kwargs</code> regardless of the decorated function. Exception inspection also seems reliable, since <code>myfunc.__name__</code> will be simply "wrapper" for most decorators, regardless of the core function's name.</p>

<p>Is there any good solution if the function may or may not have decorators?</p>
<br /><h3>Answers (Total-7):</h3><b>#0</b><br /><p>You can do:</p>

<pre><code>    try:
        myfunc()
    except IndexError:
        trace = sys.exc_info()[2]
        if trace.tb_next.tb_next is None:
            pass
        else:
            raise
</code></pre>

<p>Although it is kinda ugly and would seem to violate encapsulation.</p>

<p>Stylistically, wanting to catch having passed too many arguments seem strange. I suspect that a more general rethink of what you are doing may resolve the problem. But without more details I can't be sure. </p>

<p><strong>EDIT</strong></p>

<p>Possible approach: check if function you are calling has the arguments <code>*args,**kwargs</code>. If it does, assume its a decorator and adjust the code above to check if the exception was one further layer in. If not, check as above.</p>

<p>Still, I think you need to rethink your solution. </p>
<br /><b>#1</b><br /><p>I am not a fan of doing magic this way. I suspect you have an underlying design problem rather.</p>

<p>--original answer and code which was too unspecific to the problem removed--</p>

<p>Edit after understanding specific problem:</p>

<pre><code>from inspect import getargspec

def can_call_effectively(f, args):
    (fargs, varargs, _kw, df) = getattr(myfunc, 'effective_argspec', \
        getargspec(myfunc))
    fargslen = len(fargs)
    argslen = len(args)
    minargslen = fargslen - len(df)
    return (varargs and argslen &gt;= minargslen) or minargslen &lt;= argslen &lt;= fargslen

if can_call_effectively(myfunc, args)
    myfunc(*args)
else:
    fixit()
</code></pre>

<p>All your decorators, or at least those you want to be transparent in regard to
calling via the above code, need to set 'effective_argspec' on the returned callable.
Very explicit, no magic. To achieve this, you could decorate your decorators with the appropriate code...</p>

<p>Edit: more code, the decorator for transparent decorators.</p>

<pre><code>def transparent_decorator(decorator):
    def wrapper(f):
        wrapped = decorator(f)
        wrapped.effective_argspec = getattr(f, 'effective_argspec', getargspec(f))
        return wrapped
    return wrapper
</code></pre>

<p>Use this on your decorator:</p>

<pre><code>@transparent_decorator
def decorator(func):
"The most trivial (and common) decorator"
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper  # line missing in example above
</code></pre>

<p>Now if you create myfunc1 - myfunc3 as above, they work exactly as expected.</p>
<br /><b>#2</b><br /><p>Ugh unfortunately not really.  Your best bet is to introspect the error object that is returned and see if myfunc and the number of arguments is mentioned.</p>

<p>So you'd do something like:</p>

<pre><code>except TypeError, err:
    if err.has_some_property or 'myfunc' in str(err):
        fixit()
    raise
</code></pre>
<br /><b>#3</b><br /><p>you can do it by doing something like</p>

<pre><code>&gt;&gt;&gt; def f(x,y,z):
    print (f(0))


&gt;&gt;&gt; try:
    f(0)
except TypeError as e:
    print (e.__traceback__.tb_next is None)


True
&gt;&gt;&gt; try:
    f(0,1,2)
except TypeError as e:
    print (e.__traceback__.tb_next is None)


False
</code></pre>

<p>but a better way should be to count the number of args of function and comparing with the number of args expected</p>

<pre><code>len(inspect.getargspec(f).args) != len (args)
</code></pre>
<br /><b>#4</b><br /><p>Well-written wrappers will preserve the function name, signature, etc, of the functions they wrap; however, if you have to support wrappers that don't, or if you have situations where you want to catch an error in a wrapper (not just the final wrapped function), then there is no general solution that will work.</p>
<br /><b>#5</b><br /><p>You can retrieve the traceback and look at its length. Try:</p>

<pre><code>import traceback as tb
import sys

def a():
    1/0

def b():
    a()

def c():
    b()

try:
    a()
except:
    print len(tb.extract_tb(sys.exc_traceback))

try:
    b()
except:
    print len(tb.extract_tb(sys.exc_traceback))

try:
    c()
except:
    print len(tb.extract_tb(sys.exc_traceback))
</code></pre>

<p>This prints</p>

<pre><code>2
3
4
</code></pre>
<br /><b>#6</b><br /><p>Seems to me what you're trying to do is exactly the problem that exceptions are supposed to solve, ie where an exception will be caught somewhere in the call stack, so that there's no need to propagate errors upwards.</p>

<p>Instead, it sounds like you are trying to do error handling the C (non-exception handling) way, where the return value of a function indicates either no error (typically 0) or an error (non 0 value).  So, I'd try just writing your function to return a value, and have the caller check for the return value.</p>
<br />