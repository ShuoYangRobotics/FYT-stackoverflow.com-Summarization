<h3>Question (ID-1173539):</h3><h2>What scripting language should I learn for file/text manipulation tasks?</h2><p>I am trying to design a script for the automation of a very tedious configuration process we had been doing by hand.  The configuration process mostly consists of copying files from various ClearCase views, editing their contents in a predictable way, and putting them into a new local tree of directories. </p>

<p>There's also some Protege and MS SQL Server business involved, but that is not much trouble to do by hand.  I am more concerned with the endless copying and pasting that is prone to human error. The configuration process is mostly done in Windows XP, but there's also a fair number of scripts run on Red Hat Linux.</p>

<p>Right now I only know C++ and Java, but I was thinking I'd learn some Python for all this file manipulation; it seems like pretty high-level work so a scripting language would be appropriate.</p>

<p>Am I on the right track? Are there any particularly common mistakes I should watch out for?</p>

<p>[edit: I don't have any particular technical questions at this early stage (though I'll no doubt post again when I get down to the nitty-gritty), well, except: would Python be a good choice of language for this task, considering that I've never used it before (though I am quite familiar with C++ and Java)? Or should I just work in one of those?]</p>
<br /><h3>Answers (Total-22):</h3><b>#0</b><br /><ol>
<li>Imagine yourself creating the script, how long it would take.</li>
<li>Sextuple it. (Edit: someone finally caught my "quintuple" bug)</li>
</ol>

<p>Why?</p>

<ul>
<li>The first 100% increase is because there's no such thing as 100% productivity.</li>
<li>The second 100%, because you're learning a new language.</li>
<li>The third 100%, because you aren't considering the edge cases that automation <strong>will</strong> unveil.</li>
<li>The fourth 100%, because you need to test and document your code.</li>
<li>The fifth 100% for support, maintenance, and bug fixes during the first year of operation.</li>
</ul>

<p>So, if you think it's going to take you a day and a half of straight coding, one week would be a more reasonable estimate.</p>

<p>When making your case, be sure to do the cost-benefit analysis. If it saves someone at your pay grade 20 hours a week, the pay-off takes two weeks.</p>
<br /><b>#1</b><br /><p>Noob mistake number one:  Under-estimating the time it will take to complete.</p>

<p>Consider doubling or tripling the amount of time that you think it will take.  If you really are a newcomer, your boss understands this.  If it takes less time than your estimate, you're a hero.</p>
<br /><b>#2</b><br /><p>I'm surprised so many posters concern themselves with time estimates and manager communication. I thought the question was about programming languages?! Have I missed something, or is it due to post editing (a tricky beast here at SO)?!</p>

<p>Anyway, here are my 2 cent:</p>

<ul>
<li>Definitely go for a scripting language. It will be a very valuable addition to your personal skill set, and will pay off hundreds of times in the future. Since you are interested in programming anyway, think strategic, this is not for this job only. And you will find that you <em>are</em> more productive with a scripting language.</li>
<li>Don't go back to the dinosaurs like AWK. This is just for guys who know them already, along with several alternatives, but will take you nowhere in the long run. No proper investment.</li>
<li>Perl has been mentioned a couple of times, and has a justified reputation for these kind of jobs. But after 7 years of Perl, let me recommend you to Python. It is so much easier to learn, develop and maintain code in Python. For your own sanity, use Python.</li>
<li>The only valid alternative I see for you is choosing a JVM-based language, like Groovy or Clojure. This would allow you to re-use all the platform knowledge you already have, use of libraries and such.</li>
</ul>
<br /><b>#3</b><br /><p>I think everybody should know the rule of UPOD -- Under promise and over deliver. So in general you should make time estimates for projects/task; track you time to complete tasks, and then you will know how much on average your estimate is off. </p>

<p>Estimating time to create software can be a difficult task. I always give a rule of thumb of take your best honest estimate and times by 3 to estimate your time. If you track general time on the project you will find general numbers for a particular environment(job site/ personnel)</p>

<p>And lastly don't forget to ask other people at your job to step up to the plate and estimate what they think it will take to complete the same project.</p>

<p>good luck</p>
<br /><b>#4</b><br /><p><a href="http://www.rexxinfo.org/" rel="nofollow">Rexx</a> or <a href="http://www.perl.com/" rel="nofollow">Perl</a> come to mind for file manipulation (both very easy to learn).  I dont know Python either, so I can't compare that to these two.</p>
<br /><b>#5</b><br /><ul>
<li>The first 90% of the work will take
90% of your time. The last 10% of the
work will take 90% of your time.</li>
<li>Hofstadter's Law: It always takes
longer than you expect, even when you
take into account Hofstadter's Law.</li>
</ul>

<p>etc. and so forth. </p>
<br /><b>#6</b><br /><p>I'm a Ruby fan myself.  I've also dabbled in Perl and Python.  Any of these languages will work out for you, it's personal preference.</p>

<p>Here are some Ruby resources:</p>

<ul>
<li><a href="http://www.ruby-lang.org" rel="nofollow">Ruby's official site</a></li>
<li><a href="http://www.zenspider.com/Languages/Ruby/QuickRef.html" rel="nofollow">Ruby Quick reference</a></li>
<li><a href="http://poignantguide.net/ruby/index.html" rel="nofollow">why's poignant guide to ruby</a></li>
</ul>

<p><strong>edit:</strong> <a href="http://www.rubyinside.com/why-the-lucky-stiff-links-2333.html" rel="nofollow">_why has disappeared</a>! Here is a <a href="http://mislav.uniqpath.com/poignant-guide/" rel="nofollow">mirror of the poignant guide</a>, or you can <a href="http://www.rubyinside.com/media/poignant-guide.pdf" rel="nofollow">download the PDF</a>.</p>
<br /><b>#7</b><br /><p>Noob mistake number 2:  Assuming that you'll need to "knock this assignment out of the park" to get more work.  </p>
<br /><b>#8</b><br /><p>I think you are asking help in the wrong place.<br />
Go to your team leader / boss, explain him the situation and your concerns - and <strong>ask him for an help</strong> in the estimate and in the planning.</p>

<p>Estimation and delivery of a project is a fine art - and no one can expect you to already master it.<br />
However, <strong>you are accountable for knowing your limits, and asking colleagues for help</strong>.</p>

<p>[Just a note: this -as many others in this topic- is a reply to the <em>original</em> question, that was quite different from the current one]</p>
<br /><b>#9</b><br /><p>Perl is IMO the daddy for text manipulation. I put my hands up to being a front end dev who is more comfortable with CSS and Javascript, but I have done alot of the kind of work that you mention on a small scale, and I found the basics of PERL most useful to get me off the ground. You will need to have a good grounding in regex, so i suggest you learn the basics of perl file handling, and then get a good overview of regex for perl ( keep a cheat sheet bookmark or three handy) and best of luck. Most of all I can say I really enjoyed learning how to use PERL, and whenever I get a task that requires automating text manipulation I relish doing it all over again. Good luck pal, and enjoy!</p>
<br /><b>#10</b><br /><p>I recommend you to install a linux distribution on your computer, and then learn bash and the basic Unix tools.</p>

<p>Some examples of these tools are:</p>

<ol>
<li>grep, an utility to retrieve the lines of a file matching a particular regular expression (a set of characters)</li>
<li>awk, to work with csv files as if you were using a spreadsheet</li>
<li>sed, to make word and characters substitutions </li>
<li>wc, sort, join, paste, uniq: tools which make more or less what their names indicate (e.g. sort: sort a file given a key)</li>
</ol>

<p>To complement these tools and have a way to organize them in a pipeline, I recommend you to study how to write a Makefile.</p>

<p>In the future, you can complement your skills on bash with perl or python, but it is always worth to know these tools, as they are always there and they are free.</p>
<br /><b>#11</b><br /><p>Don't overestimate you abilities, especially on the schedule.</p>

<p>If you say you'll finish in 2 weeks and it turns into 2 months, people will be upset. Make sure to set realistic deadlines and goals for yourself.</p>
<br /><b>#12</b><br /><p>You should write down you general ideas for how to complete the task, then talk to your manager and ask for him/her to give you some feedback on your thoughts so far. Let him/her know that you really want to do a good job and would appreciate his/her guidance, which is part of a manager's job. Hopefully your workplace is well-run enough that there is understanding and support for your situation as a fresh programmer.</p>

<p>You shouldn't have to seek the advice of strangers on the web for something like this, however nice and supportive they are. Your employer should give you the support you need to succeed in completing your task. Don't be afraid to ask.</p>
<br /><b>#13</b><br /><p>As several posters have said, underestimating is a risk for you. By the same token, since management knows your level of (in)experience, they should figure that your estimates will have a significant margin of error. Put your best work into your estimates, extend them some to take into account the variables like those pointed out by richardtallent, and when you present your estimates, point out the specific sections that you are least confident about how long a given sub-task might take.</p>

<p>One thing that can be helpful in estimation is to break the project up into parts that are small enough and similar enough to what you have done before so that you can have a decent level of confidence of your estimate of that part.</p>

<p>Since you don't have much experience, maybe you want to estimate the project using a language you already know and also estimate it with Python. While Python sounds like it might be more appropriate for the task, if you find a big difference in your estimates, you can give management the choice of which implementation they want.</p>

<p>Another idea: is there anyone in your organization with whom you can "sanity check" your estimates?</p>

<p>Now I'll play the other side for a moment - overestimating by too much can lead a manager to think:</p>

<ul>
<li>You're lazy or sandbagging</li>
<li>You don't know how to estimate</li>
<li>You want to cover your backside more than you want to give him/her realistic figures</li>
</ul>

<p>And there can be danger in harboring a "hero" reputation as someone who comes in under estimates - someday your estimates will be more accurate and how realistic your estimates are will be more clear to your co-workers and management. At that time, you won't be able to get away with as much "padding", so to come in under estimate would require cutting quality or working hours off the clock.</p>
<br /><b>#14</b><br /><p>I would use perl for this task. YMMV, but perl still has some of the best tools for exactly this sort of operation: taking a set of files, doing some text-level operation to them, and putting them back (or editing them in place).</p>
<br /><b>#15</b><br /><p>Linux "bash" scripting is the easiest way to get productive quickly. The bash shell is all about file and text manipulation. On Windows, bash requires installation of either cygwin, mingw-msys, or "windows services for unix" (I prefer the lightweight msys environment)</p>

<p>If you want to learn a fully featured scripting language, Python is pretty much taking over, Ruby is not far behind. Forget Perl, it's becoming less relevant and it's quite scary to learn.</p>

<p>Otherwise look into Windows Powershell, or WScript </p>
<br /><b>#16</b><br /><p>You are on the right track! You will do just fine! </p>

<p>Good luck!</p>
<br /><b>#17</b><br /><p>Definitely PHP. Definitely.</p>
<br /><b>#18</b><br /><p>You may consider AWK as the language to use.  If you're used to C languages, but want scripting and heavy duty text manipulation, AWK might be a contender.</p>
<br /><b>#19</b><br /><p>Depending on what you need to have done, some languages will be simpler/easier/faster to do it with than others.</p>

<p>The more mature the language the more information exists either in the form of books/examples or solutions.</p>

<p>You best bet in deciding "which one to learn" is to try a few and see which one syntactically "agrees" with you :)</p>

<p>Then, get used to at least two, because you'll end up dealing with or using at least four! </p>

<p>D</p>
<br /><b>#20</b><br /><p>The question seems to concern itself with file manipulation and working with multiple clearcase views. I recommend a shell language, since clearcase has a comprehensive and useable command-line interface.  Either plan 9's "rc", or the Korn shell "ksh", are consistent programming environments.  The other major advantage to the shell is that you can tie together the pieces which do subtasks, and write those pieces in the best languages for the subtasks.</p>

<p>The actual configuration task is described as: take an input file, perform some transformation on it, and put it somewhere else.  The posix standard (and cygwin) tool "make" handles situations like this efficiently, since a makefile rule of this form will only execute when the input file changes (this reduces process time through build avoidance).</p>

<pre><code>/path/to/output/file: /path/to/input/file
    transformation command
</code></pre>

<p>See <a href="http://www.opengroup.org/onlinepubs/009695399/utilities/make.html" rel="nofollow">http://www.opengroup.org/onlinepubs/009695399/utilities/make.html</a>, or any of the various books on make, for a description, tutorial, and reference.  Make tends to scale to arbitrarily complex file manipulation tasks, since it takes on the job of figuring out the minimum set of work that needs done.</p>

<p>As a general approach, I'd look for a match between the thousands of tools and languages at your disposal, and the problem you face.  The less code you write to solve this problem (even if it takes several tools and languages), the better off you, the code base, its maintainers, and your organization will be.  An advantage of posix (standardized unix) tools in particular is that they are portable, generally straightforward to pick up and get working, well-documented around the net, and work in the problem domain you face (files, and calling special-purpose sub-programs).</p>
<br /><b>#21</b><br /><p>Python is a good choice. It is a good general purpose programming language.</p>
<br />