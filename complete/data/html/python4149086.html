<h3>Question (ID-4149086):</h3><h2>Python-style pickling for C++?</h2><p>Does anyone know of a "language level" facility for pickling in C++?  I don't want something like Boost serialization, or Google Protocol Buffers.  Instead, something that could automatically serialize all the members of a class (with an option to exclude some members, either because they're not serializable, or else because I just don't care to save them for later). This could be accomplished with an extra action at parse time, that would generate code to handle the automatic serialization.  Has anyone heard of anything like that?</p>
<br /><h3>Answers (Total-6):</h3><b>#0</b><br /><p>I don't believe there's any way to do this in a language with no run-time introspection capabilities.</p>
<br /><b>#1</b><br /><p>perhaps xml <em>Data Binding</em>? <a href="http://gsoap2.sourceforge.net/" rel="nofollow">gsoap</a> is just one of many options. You can automatically generate code for mapping between data structure and xml schema. Not sure that setting this up would be easier than other options you mention</p>
<br /><b>#2</b><br /><blockquote>
  <p>something that could automatically
  serialize all the members of a class</p>
</blockquote>

<p>This is not possible in C++. Python, C#, Java et al. use run-time introspection to achieve this. You can't do that in C++, RTTI is not powerful enough.</p>

<p>In essence, there is nothing in the C++ language that would enable someone to discover the member variables of an object at run-time. Without that, you can't automatically serialize them.</p>
<br /><b>#3</b><br /><p>it's true that C++ does not have run-time introspection, but I think Roni was asking for a solution more like what, for instance, swig does: parse the c++ code in a separate step and generate a serialization interface automatically.  the problem seems to be that using the methods he mentions, whenever a member is added or removed from the class definition the serialization stuff needs to be altered, and forgetting to do so could mean some members get defaults when unserializing.</p>
<br /><b>#4</b><br /><p>There's the standard C++ serialization with the &lt;&lt; and >> operators, although you'll have to implement these for each of your classes (which it sounds like you don't want to do). Some practitioners say you should alway implement these operators, although of course, most of us rarely do.</p>
<br /><b>#5</b><br /><p>One quick way to do this that I got working once when I needed to save a struct to a file was to cast my struct to a <code>char</code> array and write it out to a file. Then when I wanted to load my struct back in, I would read the entire file (in binary mode), and cast the whole thing to my struct's type. Easy enough and exploits the fact that structs are stored as a contiguous block in memory. I wouldn't expect this to work with convoluted data structures or pointers, though, but food for thought.</p>
<br />