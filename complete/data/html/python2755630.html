<h3>Question (ID-2755630):</h3><h2>Simplest language to make an interpreter for</h2><p>I want to make an interpreter of a very simple language for practice. When I say simple I don't mean easy to use, I mean simple. Brainf**k is a good example of a language I want. I already have made a brainf**k interpreter in python (which is the language I would be using to write the interpreter). I would appreciate any suggestions of simple languages.<br/>
<strong>Note:</strong> I don't want to make a compiler! I want to make an interpreter.<br/>
<strong>Edit</strong>: I want a language where all features are defined and not to numerous or advanced. For example: brainf**k has exactly eight symbols that are easy to parse.<br/>
And I want to use python to make the interpreter (using PLY), not C or something else.</p>
<br /><h3>Answers (Total-14):</h3><b>#0</b><br /><p>You could try something like a <strong><a href="http://www.sigala.it/sandro/software.php#slisp" rel="nofollow">simplified LISP</a></strong> interpreter. </p>

<p>While LISP is a pretty big language, it's pretty simple to write something that can parse and execute LISP like <a href="http://en.wikipedia.org/wiki/S-expression" rel="nofollow">S-expressions</a>. Once you have that, you could extend your interpreter to support whatever other features of the language you find the most interesting.</p>

<p>If you're looking to implement a complete language, you might want to try <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)" rel="nofollow">Scheme</a>. It's similar to LISP and you can also start by writing a simple interpreter for S-expressions. But, it's a much smaller language. </p>
<br /><b>#1</b><br /><p>I would say Forth is a very easy language to interpret. I worked on a project to have a bootsector(512 bytes) that was a Forth Interpreter.. I never got further than a simple RPN calculator with peek/poke commands(I had about 150 bytes left, but I got bored with it)</p>

<p>The language is very simple though and should be trivial to write an interpreter for</p>
<br /><b>#2</b><br /><p>I recently did this for Scheme by following a great set of blog posts by Peter Michaux.  you can find them here <a href="http://peter.michaux.ca/articles/scheme-from-scratch-introduction" rel="nofollow">http://peter.michaux.ca/articles/scheme-from-scratch-introduction</a></p>

<p>the series covers just about everything you need to know while leaving enough out to make it interesting (if you get stuck you can always look at the authors code).  </p>

<p>You dont even really need to know scheme all that well to get started with this.. </p>
<br /><b>#3</b><br /><p>Invent your own language.  Then you can learn some basic language design ideas at the same time as you learn about implementation techniques.  And you can avoid getting bogged down with some language feature that is too gnarly ... or too tedious ... to be fun.</p>
<br /><b>#4</b><br /><p>I would say Brainf**k is actually your best bet: it's only got <strike>six</strike> eight very simple commands, and the entire source file can be parsed in a single run on-the-fly.</p>

<hr>

<p><strong>[Edit]</strong> Since you've already written a Brianf**k interpreter, your next best bet is interpreting some simple assembly language, such as  PDP-8, which <a href="http://www.faqs.org/faqs/dec-faq/pdp8/section-3.html" rel="nofollow">only has about two dozen instructions</a>.</p>
<br /><b>#5</b><br /><p>Take a look at an already implemented simplified scheme in Python  <a href="http://norvig.com/lispy.html" rel="nofollow">lis.py</a> by Peter Norvig. It is excellent tutorial and demonstration in only 90 lines of code. Several days ago he wrote a more complete version <a href="http://norvig.com/lispy2.html" rel="nofollow">(How to Write a (Lisp) Interpreter (in Python))</a> </p>
<br /><b>#6</b><br /><p><a href="http://en.wikipedia.org/wiki/Logo_(programming_language)" rel="nofollow">Logo</a> is a fairly simple beginners language that looks like it would be reasonable to build an interpreter for.</p>

<p>Small subsets of Lisp or Scheme are easy to build interpreters for as well, if you are familiar with  functional programming.</p>

<p>Another option is to write your own language and build an interpreter for it.  That gives you excellent experience.</p>
<br /><b>#7</b><br /><p>PostScript is a surprisingly pleasant language to write an interpreter for.  Leave out all the graphics operators and you have a weird little stack-based language that operates on strings, numbers, tables, and arrays.  Kind of like Forth but with data structures and (dynamic) types.  It would be fun to write the interpreter in Python.</p>
<br /><b>#8</b><br /><p>Don't take me too serious, but the 'h' language is a very simple one specified by <a href="http://stackoverflow.com/users/22656/jon-skeet">Jon Skeet</a>. The full reference manual of the language can be found in <a href="http://stackoverflow.com/questions/284797/hello-world-in-less-than-20-bytes/284898#284898">this answer</a></p>
<br /><b>#9</b><br /><p>Didn't Bill Gates write a Basic interpreter ?</p>

<p>There are also many examples of Basic Interpreters out there.</p>
<br /><b>#10</b><br /><p>Scheme and Lisp are quite good, but still it can be made much easier. Look at the <a href="http://en.wikipedia.org/wiki/SKI_combinator_calculus" rel="nofollow">SKI calculus</a>. It has only three concepts and it is possible to write any algorithm in it. It is and equivalent of untyped lambda calculus, which is theoretical base for interpreting functional programs. Also the meaning of those three concepts is so easy, that you could implement them just by using regexp one liners.</p>
<br /><b>#11</b><br /><p>I recommend an interpreter for lambda calculus written in scheme. Lambda calculus is a very simple language that is a subset of scheme containing only lambda's of 1 argument, symbols, and procedures of 1 argument. However, this language is useless and complicated to write programs for, the great thing about it is that you can write an interpreter in scheme for it in less that 10 lines. Also you can add functionality to the language just by adding lines.</p>
<br /><b>#12</b><br /><p>Write a programmable calculator. You can implement a subset of an existing one (say, TI-59), or create your own.</p>
<br /><b>#13</b><br /><p>One of the simplest languages to implement is <a href="http://www.latrobe.edu.au/phimvt/joy.html" rel="nofollow">Joy</a> or an untyped <a href="http://www.cat-language.com" rel="nofollow">Cat</a> (which is based on Joy). These are functional stack-based (i.e. concatenative) languages, similar to PostScript but even simpler. In fact Andrew Nelis already wrote an implementation of <a href="http://www.triv.org.uk/~nelis/" rel="nofollow">Cat in Python</a>.</p>
<br />