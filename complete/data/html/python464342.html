<h3>Question (ID-464342):</h3><h2>Combining two sorted lists in Python</h2><p>I have two lists of objects. Each list is already sorted by a property of the object that is of the datetime type. I would like to combine the two lists into one sorted list. Is the best way just to do a bubble sort or is there a smarter way to do this in Python?</p>
<br /><h3>Answers (Total-10):</h3><b>#0</b><br /><p>People seem to be over complicating this.. Just combine the two lists, then sort them:</p>

<pre><code>&gt;&gt;&gt; l1 = [1, 3, 4, 7]
&gt;&gt;&gt; l2 = [0, 2, 5, 6, 8, 9]
&gt;&gt;&gt; l1.extend(l2)
&gt;&gt;&gt; sorted(l1)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>..or shorter (and without modifying <code>l1</code>):</p>

<pre><code>&gt;&gt;&gt; sorted(l1 + l2)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<p>..easy! Plus, it's using only two built-in functions, so assuming the lists are of a reasonable size, it should be quicker than implementing the sorting/merging in a loop. More importantly, the above is much less code, and very readable.</p>

<p>If your lists are large (over a few hundred thousand, I would guess), it may be quicker to use an alternative/custom sorting method, but there are likely other optimisations to be made first (e.g not storing millions of <code>datetime</code> objects)</p>

<p>Using the <code>timeit.Timer().repeat()</code> (which repeats the functions 1000000 times), I loosely benchmarked it against <a href="http://stackoverflow.com/questions/464342/combining-two-sorted-lists-in-python#464454">ghoseb's</a> solution, and <code>sorted(l1+l2)</code> is substantially quicker:</p>

<p><code>merge_sorted_lists</code> took..</p>

<pre><code>[9.7439379692077637, 9.8844599723815918, 9.552299976348877]
</code></pre>

<p><code>sorted(l1+l2)</code> took..</p>

<pre><code>[2.860386848449707, 2.7589840888977051, 2.7682540416717529]
</code></pre>
<br /><b>#1</b><br /><blockquote>
  <p>is there a smarter way to do this in Python</p>
</blockquote>

<p>This hasn't been mentioned, so I'll go ahead - there is a <a href="http://svn.python.org/view/python/trunk/Lib/heapq.py?view=markup" rel="nofollow">merge stdlib function</a> in the heapq module of python 2.6+. If all you're looking to do is getting things done, this might be a better idea. Of course, if you want to implement your own, the merge of merge-sort is the way to go.</p>

<pre><code>&gt;&gt;&gt; list1 = [1, 5, 8, 10, 50]
&gt;&gt;&gt; list2 = [3, 4, 29, 41, 45, 49]
&gt;&gt;&gt; from heapq import merge
&gt;&gt;&gt; list(merge(list1, list2))
[1, 3, 4, 5, 8, 10, 29, 41, 45, 49, 50]
</code></pre>
<br /><b>#2</b><br /><p>Long story short, unless <code>len(l1 + l2) ~ 1000000</code> use:</p>

<pre><code>L = l1 + l2
L.sort()
</code></pre>

<p><img src="http://i403.photobucket.com/albums/pp111/uber_ulrich/_020sorted_random_2147483647.png" alt="merge vs. sort comparison" /></p>

<p>Description of the figure and source code can be found <a href="http://stackoverflow.com/questions/464960/code-golf-combining-multiple-sorted-lists-into-a-single-sorted-list#464967">here</a>. </p>

<p>The figure was generated by the following command:</p>

<pre><code>$ python make-figures.py --nsublists 2 --maxn=0x100000 -s merge_funcs.merge_26 -s merge_funcs.sort_builtin
</code></pre>
<br /><b>#3</b><br /><p>This is simply merging. Treat each list as if it were a stack, and continuously pop the smaller of the two stack heads, adding the item to the result list, until one of the stacks is empty. Then add all remaining items to the resulting list.</p>
<br /><b>#4</b><br /><p>There is a slight flaw in <a href="http://stackoverflow.com/questions/464342/combining-two-sorted-lists-in-python#464454">ghoseb's</a> solution, making it O(n**2), rather than O(n).<br />
The problem is that this is performing:</p>

<pre><code>item = l1.pop(0)
</code></pre>

<p>With linked lists or deques this would be an O(1) operation, so wouldn't affect complexity, but since python lists are implemented as vectors, this copies the rest of the elements of l1 one space left, an O(n) operation.  Since this is done each pass through the list, it turns an O(n) algorithm into an O(n**2) one.  This can be corrected by using a method that doesn't alter the source lists, but just keeps track of the current position.</p>

<p>I've tried out benchmarking a corrected algorithm vs a simple sorted(l1+l2) as suggested by <a href="http://stackoverflow.com/questions/464342/combining-two-sorted-lists-in-python#464538">dbr</a></p>

<pre><code>def merge(l1,l2):
    if not l1:  return list(l2)
    if not l2:  return list(l1)

    # l2 will contain last element.
    if l1[-1] &gt; l2[-1]:
        l1,l2 = l2,l1

    it = iter(l2)
    y = it.next()
    result = []

    for x in l1:
        while y &lt; x:
            result.append(y)
            y = it.next()
        result.append(x)
    result.append(y)
    result.extend(it)
    return result
</code></pre>

<p>I've tested these with lists generated with</p>

<pre><code>l1 = sorted([random.random() for i in range(NITEMS)])
l2 = sorted([random.random() for i in range(NITEMS)])
</code></pre>

<p>For various sizes of list, I get the following timings (repeating 100 times):</p>

<pre><code># items:  1000   10000 100000 1000000
merge  :  0.079  0.798 9.763  109.044 
sort   :  0.020  0.217 5.948  106.882
</code></pre>

<p>So in fact, it looks like dbr is right, just using sorted() is preferable unless you're expecting very large lists, though it does have worse algorithmic complexity.  The break even point being at around a million items in each source list (2 million total).</p>

<p>One advantage of the merge approach though is that it is trivial to rewrite as a generator, which will use substantially less memory (no need for an intermediate list).</p>

<p><strong>[Edit]</strong>
I've retried this with a situation closer to the question - using a list of objects containing a field "<code>date</code>" which is a datetime object.
The above algorithm was changed to compare against <code>.date</code> instead, and the sort method was changed to:</p>

<pre><code>return sorted(l1 + l2, key=operator.attrgetter('date'))
</code></pre>

<p>This does change things a bit.  The comparison being more expensive means that the number we perform becomes more important, relative to the constant-time speed of the implementation.  This means merge makes up lost ground, surpassing the sort() method at 100,000 items instead.  Comparing based on an even more complex object (large strings or lists for instance) would likely shift this balance even more.</p>

<pre><code># items:  1000   10000 100000  1000000[1]
merge  :  0.161  2.034 23.370  253.68
sort   :  0.111  1.523 25.223  313.20
</code></pre>

<p>[1]: Note: I actually only did 10 repeats for 1,000,000 items and scaled up accordingly as it was pretty slow.</p>
<br /><b>#5</b><br /><pre><code>from datetime import datetime
from itertools import chain
from operator import attrgetter

class DT:
    def __init__(self, dt):
        self.dt = dt

list1 = [DT(datetime(2008, 12, 5, 2)),
         DT(datetime(2009, 1, 1, 13)),
         DT(datetime(2009, 1, 3, 5))]

list2 = [DT(datetime(2008, 12, 31, 23)),
         DT(datetime(2009, 1, 2, 12)),
         DT(datetime(2009, 1, 4, 15))]

list3 = sorted(chain(list1, list2), key=attrgetter('dt'))
for item in list3:
    print item.dt
</code></pre>

<p>The output:</p>

<pre><code>2008-12-05 02:00:00
2008-12-31 23:00:00
2009-01-01 13:00:00
2009-01-02 12:00:00
2009-01-03 05:00:00
2009-01-04 15:00:00
</code></pre>

<p>I bet this is faster than any of the fancy pure-Python merge algorithms, even for large data. Python 2.6's <code>heapq.merge</code> is a whole another story.</p>
<br /><b>#6</b><br /><p>This is simple merging of two sorted lists. Take a look at the sample code below which merges two sorted lists of integers.</p>

<pre><code>#!/usr/bin/env python
## merge.py -- Merge two sorted lists -*- Python -*-
## Time-stamp: "2009-01-21 14:02:57 ghoseb"

l1 = [1, 3, 4, 7]
l2 = [0, 2, 5, 6, 8, 9]

def merge_sorted_lists(l1, l2):
    """Merge sort two sorted lists

    Arguments:
    - `l1`: First sorted list
    - `l2`: Second sorted list
    """
    sorted_list = []

    # Copy both the args to make sure the original lists are not
    # modified
    l1 = l1[:]
    l2 = l2[:]

    while (l1 and l2):
        if (l1[0] &lt;= l2[0]): # Compare both heads
            item = l1.pop(0) # Pop from the head
            sorted_list.append(item)
        else:
            item = l2.pop(0)
            sorted_list.append(item)

    # Add the remaining of the lists
    sorted_list.extend(l1 if l1 else l2)

    return sorted_list

if __name__ == '__main__':
    print merge_sorted_lists(l1, l2)
</code></pre>

<p>This should work fine with datetime objects. Hope this helps.</p>
<br /><b>#7</b><br /><p>Use the 'merge' step of merge sort, it runs in O(n) time.</p>

<p>From <a href="http://en.wikipedia.org/wiki/Merge_sort" rel="nofollow">wikipedia</a> (pseudo-code):</p>

<pre><code>function merge(left,right)
    var list result
    while length(left) &gt; 0 and length(right) &gt; 0
        if first(left) â‰¤ first(right)
            append first(left) to result
            left = rest(left)
        else
            append first(right) to result
            right = rest(right)
    end while
    while length(left) &gt; 0 
        append left to result
    while length(right) &gt; 0 
        append right to result
    return result
</code></pre>
<br /><b>#8</b><br /><p>Well, the naive approach (combine 2 lists into large one and sort) will be O(N*log(N)) complexity. On the other hand, if you implement the merge manually (i do not know about any ready code in python libs for this, but i'm no expert) the complexity will be O(N), which is clearly faster.
The idea is described wery well in post by Barry Kelly.</p>
<br /><b>#9</b><br /><pre><code>def compareDate(obj1, obj2):
    if obj1.getDate() &lt; obj2.getDate():
        return -1
    elif obj1.getDate() &gt; obj2.getDate():
        return 1
    else:
        return 0



list = list1 + list2
list.sort(compareDate)
</code></pre>

<p>Will sort the list in place. Define your own function for comparing two objects, and pass that function into the built in sort function.</p>

<p>Do NOT use bubble sort, it has horrible performance.</p>
<br />