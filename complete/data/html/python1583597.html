<h3>Question (ID-1583597):</h3><h2>asm / C / Python / Perl / Lisp / Scheme Programmer looking for something new to learn</h2><p>I need to have an at-home project now that I'm working on Python/Django at work. I'd like to learn something new, so I was thinking of checking out Java.</p>

<p>What's the most well respected web framework for deploying Java web apps?
The only reason I'm not checking out ruby on rails is because of how similar the ORM and other parts are to Django.</p>

<p>Alternatively, does anyone think I should take a look at seaside/smalltalk? Can anyone explain why I should?</p>

<p>Haskell is something I'll consider if anyone can make a good argument for it. I'd need a web framework and database access library to go along with it though.</p>

<p>I'd consider factor/forth if I wasn't so accustomed to the stack paradigm via x86/asm. I'd be willing to hear any counter-arguments to this as well.</p>

<p>See also: <a href="http://www.reddit.com/r/programming/comments/9v3uf/asm%5Fc%5Fpython%5Fperl%5Flisp%5Fscheme%5Fprogrammer%5Flooking/" rel="nofollow">http://www.reddit.com/r/programming/comments/9v3uf/asm%5Fc%5Fpython%5Fperl%5Flisp%5Fscheme%5Fprogrammer%5Flooking/</a></p>
<br /><h3>Answers (Total-12):</h3><b>#0</b><br /><p>With that range of skills, why don't you learn something more outside your comfort zone, like carpentry or painting, or any of hundreds of other skills that have little to do with your field.</p>

<p>At some point, all languages are the same and you'll get scant benefit from learning another. </p>

<p>Whereas, with something totally different, you will become a much more well-rounded individual. I, for one, like painting and golf, even though I'm not that good at either of them - when I asked my golf instructor what my handicap was, he said it was an inability to hit the ball straight :-)</p>

<p>I find that I <em>enjoy</em> doing stuff I'm not accustomed to since it's a genuinely new experience. Learning another computer skill is a easy thing to do after a while and hence the pleasure from doing it is reduced.</p>

<p>Don't get me wrong, I like to keep up with developments in the field but, for the most part, the brand new technologies give nothing to my career since most work I do is on stable technologies. You may be in a different situation.</p>
<br /><b>#1</b><br /><p><a href="http://www.haskell.org/" rel="nofollow">Haskell</a> is pretty popular these days as a mind-bender, though it may not hurt as much for you if you already know Lisp and Scheme. It's purely functional, so there are no side effects to anything. You have to use monads to print text and do other things that require a certain order. It's also completely lazily evaluated, so you can make infinite lists in Haskell and not have to worry about memory consumption.</p>

<p>The <a href="http://hackage.haskell.org/platform/" rel="nofollow">Haskell Platform</a> may not be fully complete, but is intended to be a portable set of libraries for Haskell. It's <a href="http://hackage.haskell.org/platform/contents.html" rel="nofollow">list of packages</a> includes some for CGI handling and (X)HTML generation.</p>
<br /><b>#2</b><br /><p>I do suggest Java.  When I was looking for a job, I noticed lots of openings for Java developers, so there's a lot of it out there, and you might someday have a chance to use your Java skills.</p>

<p>And then you should try out Scala.  Scala is a sort of Python-ish language that uses functional programming to make very scalable programs.  Unlike Python, in Scala you do need to declare types of things.  Scala runs on the Java Virtual Machine so it can be used in Java shops.</p>

<p><a href="http://www.scala-lang.org/" rel="nofollow">http://www.scala-lang.org/</a></p>

<p>It's possible I'm just giving you this answer because these are the next two languages I intend to learn, myself.</p>

<p>You probably should also spend a little time playing around with Javascript.  Javascript was sort of intended to be a "stealth Lisp" and I imagine you would pick it right up.</p>

<p><a href="http://www.crockford.com/javascript/javascript.html" rel="nofollow">http://www.crockford.com/javascript/javascript.html</a></p>

<p><a href="http://bc.tech.coop/blog/030920.html" rel="nofollow">http://bc.tech.coop/blog/030920.html</a></p>

<p>And heck, have some fun with it.  Write a game or something!</p>
<br /><b>#3</b><br /><p>Sounds like you're into web programming, so smalltalk/seaside is a great one. IMO everyone should learn smalltalk even if they never use it, and seaside is a really different web framework than what you are used to. Django, fer instance, is all about REST, while the seaside philosophy basically says "to hell with REST." </p>

<p>And if you've never coded in an image based environment there's just something about it that seems... natural, magical even. Lots of IDE functionality that originated in smalltalk have been implemented in file based language IDE's, but it always feels like an unnatural grafting, where those same features feel as if they simply belong there in smalltalk. </p>

<p>Check out Pharo. Give it enough time to get used to the fact that there's no menu bar and see if it doesn't grab you.  </p>
<br /><b>#4</b><br /><p>From your list I'd say you are due for a completely object oriented language. </p>

<p>You could check out Ruby, but I'd recommend JavaScript since it offers a lot of interesting things you probably wouldn't expect, like support for closures, higher-order functions and prototypical inheritance - plus it's kinda fun and becoming very popular.</p>
<br /><b>#5</b><br /><blockquote>
  <p>I'd need a web framework and database access library to go along with it though.</p>
</blockquote>

<p>If all your programming is based on web frameworks and SQL databases, you will only be solving the same problems with different syntax if you switch languages.</p>

<p>Build something using a different data model - Prolog, Conceptual Graphs, RDF, Linda/JavaSpaces, XQuery, HDF5, ASN.1, or a different network model - XMPP pub-sub, SNMP, a zero-config mesh or a swarm of ZigBee enabled Arduinos.</p>

<p>Maybe look at languages like <a href="http://www.mozart-oz.org/" rel="nofollow">Oz</a>, <a href="http://iolanguage.com/" rel="nofollow">Io</a> or <a href="http://www.erlang.org/doc/" rel="nofollow">Erlang/OTP</a>, which are distributed rather than primarily monolithic like the ones you mention.</p>
<br /><b>#6</b><br /><p>What about the Java Spring framework?</p>

<p><a href="http://www.springsource.org/" rel="nofollow">http://www.springsource.org/</a></p>

<p>Or maybe NHibernate?</p>

<p><a href="http://en.wikipedia.org/wiki/NHibernate" rel="nofollow">http://en.wikipedia.org/wiki/NHibernate</a></p>

<p>At the end of the day its up to you.  As I only listed two out of many.  When I am programming a static language professonally... I try to learn a dynamic or scripting language.  And vice versa.</p>

<p>Also, I try to learn something totally different or outside my realm... maybe even Powershell or Korn shell or ActionScript.</p>
<br /><b>#7</b><br /><blockquote>
  <p>What's the most well respected web framework for deploying Java web apps?</p>
</blockquote>

<p>There is no single web framework more respected than others. Struts2, Spring MVC, Stripes or Wicket (which is event based) are all good candidates (I personally like Stripes). But you'll need a bit more for the persistence (Hibernate or JPA) and for the glue (Spring). </p>

<p>Grails (Groovy on Rails) is another good option.</p>

<blockquote>
  <p>Alternatively, does anyone think I should take a look at seaside/smalltalk? Can anyone explain why I should?</p>
</blockquote>

<p>Well, I guess that learning Smalltalk can't hurt but I don't see a good reason to choose Smalltalk over a moderner language like Java. Regarding tooling, I don't know anything in this field except <a href="http://www-01.ibm.com/software/awdtools/smalltalk/" rel="nofollow">VisualAge for Smalltalk</a> but, personally, I'd really stay far away from it.</p>

<blockquote>
  <p>Haskell is something I'll consider if anyone can make a good argument for it. [...]</p>
</blockquote>

<p>Looks like I'm not the right guy for that.</p>

<blockquote>
  <p>I'd consider factor/forth if I wasn't so accustomed to the stack paradigm via x86/asm. I'd be willing to hear any counter-arguments to this as well.</p>
</blockquote>

<p>Same as above.</p>
<br /><b>#8</b><br /><p>I would have suggested mastering Lisp (in some relevant dialect) so even if you have Lisp and Scheme on your resume, it might be worthwhile to REALLY learn deeply.    See <a href="http://www.paulgraham.com/avg.html" rel="nofollow">http://www.paulgraham.com/avg.html</a> for reasons why.</p>

<p>Otherwise Prolog might interest you.  It is related to SQL but for programming instead of communicating with an organised set of data tables.</p>

<p>If you want to target web technologies I only have experience with Java.  Here the newest Java Server Faces (JSF) allow for using Ajax to update pages, and Google Web Toolkit allow for very rich component based web pages.  These might be juicy enough to interest you enough to learn enough Java to find them fun :)</p>
<br /><b>#9</b><br /><p>I don’t see C# and the .NET platform on your list. And I am surprised no one mentioned it yet.   </p>

<p>I have worked in C# for 5 years.  I have looked at some Java code but I have never coded in it.  I believe that Java is somewhat similar to C# enough so that if you become proficient in one I think you could pick up the other is a matter of a few days. </p>

<p>One idea might be to create your own language / compiler.  The one I would like to create (or see created) would be an Assembly Language level compiler with an object oriented syntax that would be very much like Python…  but make it typed language.  You could start with the basic raw binary types db, dw, dd, and then add on to these … The functions and methods could have assembly language freely mixed in the high-level code.  Now, that would be a fun project, I think ?</p>
<br /><b>#10</b><br /><p>Definitely try Haskell or Smalltalk or Forth.</p>

<p>I would say Smalltalk would be most useful while Forth would get you away from the x86 asm and C bullshit. There's more than one way to code close-to-the-hardware stuff.</p>
<br /><b>#11</b><br /><p>Why don't you try OCaml? And if you ever happen (sadly) to return to .NET world - you will have knowledge of F# in your baggage.</p>
<br />