<h3>Question (ID-1861457):</h3><h2>Python vs. Java -- Which would you pick to do concurrent programming and why?</h2><p>Also, if not python or java, then would you more generally pick a statically-typed language or a dynamic-type language?</p>
<br /><h3>Answers (Total-11):</h3><b>#0</b><br /><p>I would choose the JVM over python, primarily because multi-threading in Python is impeded by the <a href="http://en.wikipedia.org/wiki/Global%5FInterpreter%5FLock" rel="nofollow">Global Interpreter Lock</a>. However, Java is unlikely to be your best when running on the JVM. <a href="http://clojure.org/" rel="nofollow">Clojure</a> or <a href="http://www.scala-lang.org/" rel="nofollow">Scala</a> (using actors) are both likely to be better suited to multi-threaded problems.</p>

<p>If you do choose Java you should consider making use of the <a href="http://www.ibm.com/developerworks/java/library/j-jtp1126.html" rel="nofollow"><strong>java.util.concurrent</strong></a> libraries and avoid multi-threading primitives such as <strong>synchronized</strong>.</p>
<br /><b>#1</b><br /><p>For concurrency, I would use Java. By use Java, I actually mean <a href="http://www.scala-lang.org/" rel="nofollow">Scala</a>, which borrows a lot from Erlang's concurrency constructs, but is (probably) more accessible to a Java developer who has never used either before.</p>

<p>Python threads suffer from having to wait for the Global Interpreter Lock, making true concurrency (within a single process) unachievable for CPU-bound programs. As I understand, Stackless Python solves some (though not all) of CPython's concurrency deficiencies, but as I have not used it, I can't really advise on it.</p>
<br /><b>#2</b><br /><p>Definetely <a href="http://www.stackless.com/" rel="nofollow">Stackless Python</a>! That a Python variant especially made for concurrency. </p>

<p>But in the end it depends on your target platform and what you are trying to achieve. </p>

<p>Best wishes,<br>
Fabian</p>
<br /><b>#3</b><br /><p>If not Java/Python I would go for a <strong>functional language</strong> since taking side effects into account is one of the complexities of writing concurrent software. (As far as your question goes : this one happens to be statical typed, but compiler infered most of the time)</p>

<p>Personally I would pick F#, since I've seen lots of nice examples of writing concurrent software with ease using it.</p>

<p>As an introduction : this man is <a href="http://mschnlnine.vo.llnwd.net/d1/pdc08/WMV-HQ/TL11.wmv" rel="nofollow">equally fun as inspiring</a>, even a must have seen if you are not interested in F# what so ever. </p>
<br /><b>#4</b><br /><p>I don't think the argument is about language choice or static or dynamic typing - it's between two models of concurrency - shared memory and message passing. Which model makes more sense in your situation &amp; does your chosen language allow you to make a choice or are you forced to adopt one model over the other?</p>

<p>Why not have a look at <a href="http://www.erlang.org/" rel="nofollow">Erlang</a> (which has dynamic typing) and <a href="http://en.wikipedia.org/wiki/Message_passing" rel="nofollow">message passing</a>, the <a href="http://en.wikipedia.org/wiki/Actor_model" rel="nofollow">Actor model</a>, and read why <a href="http://armstrongonsoftware.blogspot.com/2006/09/why-i-dont-like-shared-memory.html" rel="nofollow">Joe Armstrong doesn't like shared memory</a>. There's also a interesting discussion about java concurrency using locks and threads <a href="http://stackoverflow.com/questions/508850/java-concurrency-cynicism-gone-too-far">here on SO</a>.</p>

<p>I don't know about Python, but Java, along with the inbuilt locks and threads model, has a mesasge passing framework called <a href="http://www.malhar.net/sriram/kilim/" rel="nofollow">Kilim</a>.</p>
<br /><b>#5</b><br /><p>I would use Java, via Jython. Java has strong thread capabilities, and it can be written using the Python syntax with Jython, so you got the best of the two worlds.</p>

<p>Python itself is not really good with concurrency, and is slower than Java anyway.</p>

<p>But if you have concurrency issues and free hands, I'd have a look at Erlang because it has been design for such problems. Of course, you must consider Erlang only if you have:</p>

<ul>
<li>time to master a (very) new technology</li>
<li>control on a reasonable part of the production chain, since Erland need some adaptations in your toolbox to fit</li>
</ul>
<br /><b>#6</b><br /><p>For some tasks, Python is too slow. Your single thread Java program could be faster than the concurrent version of Python on a multi-core computer...</p>

<p>I'd like to use Java or Scala, F# or simply go to C++(MPI and OpenMPI).</p>
<br /><b>#7</b><br /><p>The Java environment (JVM + libraries) is better for concurrency than (C)Python, but Java the language sucks.  I would probably go with another language on the JVM - Jython has already been mentioned, and Clojure and Scala both have excellent support for concurrency.  </p>

<p>Clojure is particularly good - it has support for high performance persistent data structures, agents and software transactional memory.  It is a dynamic language but you can give it type hints to get performance as good as Java.</p>

<p>Watch <a href="http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey" rel="nofollow">this video</a> on InfoQ by Richard Hickey (creator of Clojure) on the problems with traditional approaches to concurrency, and how Clojure handles it.</p>
<br /><b>#8</b><br /><p>I'd look at Objective-C and the Foundation Framework. Asynchronous, concurrent programming is well provided for.</p>

<p>This of course depends on your access to Apple's Developer Tools or GnuStep, but if you have access to either one it's a good route to take with concurrent programming.</p>
<br /><b>#9</b><br /><p>Neither. Concurrent programming is notoriously hard to get correct. There is the option of using a process oriented programming language like <a href="http://en.wikipedia.org/wiki/Occam-%CF%80" rel="nofollow">occam-pi</a> which is based of the idea of <a href="http://en.wikipedia.org/wiki/Communicating%5Fsequential%5Fprocesses" rel="nofollow">communicating sequential processes</a> and the <a href="http://en.wikipedia.org/wiki/Pi%5Fcalculus" rel="nofollow">pi calculus</a>. This allows compile time checking for deadlock and many other problems that arise during concurrent systems development. If you do not like occam-pi, which I cant blame you if you dont, you could try <a href="http://en.wikipedia.org/wiki/Go%5F%28programming%5Flanguage%29" rel="nofollow">Go</a> the new language from google which also implements a version of CSP.</p>
<br /><b>#10</b><br /><p>The answer is that it depends. For example are you trying to take advantage of multiple cores or cpus on a single machine or are you wanting to distribute your task across many machines? How important is speed vs. ease of implementation?</p>

<p>As mentioned before, Python has the Global Interpreter Lock but you could use the <a href="http://docs.python.org/library/multiprocessing.html" rel="nofollow">multiprocessing</a> module. Note that while <a href="http://www.stackless.com/" rel="nofollow">Stackless</a> is very cool, it <a href="http://www.stackless.com/pipermail/stackless/2008-June/003551.html" rel="nofollow">won't utilise multiple cores</a> on its own. Python is usually considered easier to work with than Java. If speed is a priority Java is usually faster.</p>

<p>The <code>java.util.concurrent</code> library in Java makes writing concurrent applications on a single machine simpler but you'll still need to synchronise around any shared state. While Java isn't necessarily the best language for concurrency, there are a lot of tools, libraries, documentation and best practices out there to help.</p>

<p>Using message passing and immutability instead of threads and shared state is considered the better approach to programming concurrent applications. Functional languages that discourage mutability and side effects are often preferred as a result. If distributing your concurrent applications across multiple machines is a requirement, it is worth looking at runtimes designed for this e.g. <a href="http://ftp.sunet.se/pub/lang/erlang/" rel="nofollow">Erlang</a> or <a href="http://www.scala-lang.org/node/242" rel="nofollow">Scala Actors</a>.</p>
<br />