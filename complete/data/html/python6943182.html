<h3>Question (ID-6943182):</h3><h2>Python - get name of current class</h2><p>How do I get the name of the class I am currently in?</p>

<p>Example:</p>

<pre><code>def get_input(class_name):
    [do things]
    return class_name_result


class foo():
    input = get_input([class name goes here])
</code></pre>

<p>Due to the nature of the program I am interfacing with (vistrails), I cannot use <strong>init</strong> to initialize input.</p>
<br /><h3>Answers (Total-6):</h3><b>#0</b><br /><p>Within the body of a class, the class name isn't defined yet, so it is not available.  Can you not simply type the name of the class?  Maybe you need to say more about the problem so we can find a solution for you.</p>

<p>I would create a metaclass to do this work for you.  It's invoked at class creation time (conceptually at the very end of the class: block), and can manipulate the class being created.  I haven't tested this:</p>

<pre><code>class InputAssigningMetaclass(type):
    def __new__(cls, name, bases, attrs):
        cls.input = get_input(name)
        return super(MyType, cls).__new__(cls, name, bases, newattrs)

class MyBaseFoo(object):
    __metaclass__ = InputAssigningMetaclass

class foo(MyBaseFoo):
    # etc, no need to create 'input'

class foo2(MyBaseFoo):
    # etc, no need to create 'input'
</code></pre>
<br /><b>#1</b><br /><p>You can access it by the class' private attributes:</p>

<pre><code>cls_name = self.__class__.__name__
</code></pre>

<p><strong>EDIT:</strong></p>

<p>As said by <code>Ned Batcheler</code>, this wouldn't work in the class body, but it would in a method.</p>
<br /><b>#2</b><br /><p>Not sure if these links answer your question</p>

<p><a href="http://stackoverflow.com/questions/510972/getting-the-class-name-of-an-instance-in-python">Getting the class name of an instance in Python</a></p>

<p><a href="http://stackoverflow.com/questions/602846/how-can-i-access-the-current-executing-module-or-class-name-in-python">How can I access the current executing module or class name in Python?</a></p>
<br /><b>#3</b><br /><p>You can access and parse the object's <strong>class</strong> property:</p>

<pre><code>&gt;&gt;&gt; import collections
&gt;&gt;&gt; c = collections.Counter()
&gt;&gt;&gt; str(c.__class__)
"&lt;class 'collections.Counter'&gt;"
</code></pre>
<br /><b>#4</b><br /><p><code>obj.__class__.__name__</code> will get you any objects name, so you can do this:</p>

<pre><code>class Clazz():
    def getName(self):
        return self.__class__.__name__
</code></pre>

<p>Usage:</p>

<pre><code>&gt;&gt;&gt; c = Clazz()
&gt;&gt;&gt; c.getName()
'Clazz'
</code></pre>
<br /><b>#5</b><br /><p><strong>EDIT:</strong> Yes, you can; but you have to cheat: The currently running class name is present on the call stack, and the <a href="http://docs.python.org/library/traceback.html#traceback.extract_stack" rel="nofollow"><code>traceback</code></a> module allows you to access the stack.</p>

<pre><code>&gt;&gt;&gt; import traceback
&gt;&gt;&gt; def get_input(class_name):
...     return class_name.encode('rot13')
... 
&gt;&gt;&gt; class foo(object):
...      _name = traceback.extract_stack()[-1][2]
...     input = get_input(_name)
... 
&gt;&gt;&gt; 
&gt;&gt;&gt; foo.input
'sbb'
</code></pre>

<p>However, I wouldn't do this;  My original answer is still my own preference as a solution.  Original answer:</p>

<p>probably the very simplest solution is to use a decorator, which is similar to Ned's answer involving metaclasses, but less powerful (decorators are capable of black magic, but metaclasses are capable of <em>ancient, occult</em> black magic)</p>

<pre><code>&gt;&gt;&gt; def get_input(class_name):
...     return class_name.encode('rot13')
... 
&gt;&gt;&gt; def inputize(cls):
...     cls.input = get_input(cls.__name__)
...     return cls
... 
&gt;&gt;&gt; @inputize
... class foo(object):
...     pass
... 
&gt;&gt;&gt; foo.input
'sbb'
&gt;&gt;&gt; 
</code></pre>
<br />