<h3>Question (ID-1497504):</h3><h2>How to make unique short URL with Python?</h2><p>How can I make unique URL in Python a la <a href="http://imgur.com/gM19g" rel="nofollow">http://imgur.com/gM19g</a> or <a href="http://tumblr.com/xzh3bi25y" rel="nofollow">http://tumblr.com/xzh3bi25y</a>
When using uuid from python I get a very large one. I want something shorter for URLs.</p>
<br /><h3>Answers (Total-7):</h3><b>#0</b><br /><p>I'm not sure most URL shorteners use a random string.  My impression is they write the URL to a database, then use the integer ID of the new record as the short URL, encoded base 36 or 62 (letters+digits).</p>

<p>Python code to convert an int to a string in arbitrary bases is <a href="http://code.activestate.com/recipes/65212/" rel="nofollow">here</a>.</p>
<br /><b>#1</b><br /><p><strong>Edit</strong>: Here, I wrote a module for you.  Use it. <a href="http://code.activestate.com/recipes/576918/">http://code.activestate.com/recipes/576918/</a></p>

<p><hr /></p>

<p>Counting up from 1 will guarantee short, unique URLS. /1, /2, /3 ... etc.</p>

<p>Adding uppercase and lowercase letters to your alphabet will give URLs like those in your question.  And you're just counting in base-62 instead of base-10.</p>

<p>Now the only problem is that the URLs come consecutively.  To fix that, read my answer to this question here:</p>

<p><a href="http://stackoverflow.com/questions/1051949/map-incrementing-integer-range-to-six-digit-base-26-max-but-unpredictably/1052896#1052896">http://stackoverflow.com/questions/1051949/map-incrementing-integer-range-to-six-digit-base-26-max-but-unpredictably/1052896#1052896</a></p>

<p>Basically the approach is to simply swap bits around in the incrementing value to give the appearance of randomness while maintaining determinism and guaranteeing that you don't have any collisions.</p>
<br /><b>#2</b><br /><p>The reason UUIDs are long is because they contain lots of information so that they can be guaranteed to be globally unique.</p>

<p>If you want something shorter, then you'll need to do something like generate a random string, checking whether it is in the universe of already generated strings, and repeating until you get an unused string. You'll also need to watch out for concurrency here (what if the same string gets generated by a separate process before you inserted into the set of strings?).</p>

<p>If you need some help generating random strings in Python, this <a href="http://stackoverflow.com/questions/367586/generating-random-text-strings-of-a-given-pattern">other question</a> might help.</p>
<br /><b>#3</b><br /><p>It doesn't really matter that this is Python, but you just need a hash function that maps to the length you want.  For example, maybe use MD5 and then take just the first <code>n</code> characters.  You'll have to watch out for collisions in that case, though, so you might want to pick something a little more robust in terms of collision detection (like using primes to cycle through the space of hash strings).</p>
<br /><b>#4</b><br /><p>I don't know if you can use this, but we generate content objects in Zope that get unique numeric ids based on current time strings, in millis (eg, 1254298969501)</p>

<p>Maybe you can guess the rest. Using the recipe described here:
<a href="http://stackoverflow.com/questions/561486/how-to-convert-an-integer-to-the-shortest-url-safe-string-in-python">http://stackoverflow.com/questions/561486/how-to-convert-an-integer-to-the-shortest-url-safe-string-in-python</a>, we encode and decode the real id on the fly, with no need for storage. A 13-digit integer is reduced to 7 alphanumeric chars in base 62, for example.</p>

<p>To complete the implementation, we registered a short (xxx.yy) domain name, that decodes and does a 301 redirect for "not found" URLs, </p>

<p>If I was starting over, I would subtract the "starting-over" time (in millis) from the numeric id prior to encoding, then re-add it when decoding. Or else when generating the objects. Whatever. That would be way shorter..</p>
<br /><b>#5</b><br /><p>This module will do what you want, guaranteeing that the string is globally unique (it is a UUID):</p>

<p><a href="http://pypi.python.org/pypi/shortuuid/0.1" rel="nofollow">http://pypi.python.org/pypi/shortuuid/0.1</a></p>

<p>If you need something shorter, you should be able to truncate it to the desired length and still get something that will reasonably probably avoid clashes.</p>
<br /><b>#6</b><br /><p>Try this <a href="http://code.google.com/p/tiny4py/" rel="nofollow">http://code.google.com/p/tiny4py/</a> ... It's still under development, but very useful!!</p>
<br />