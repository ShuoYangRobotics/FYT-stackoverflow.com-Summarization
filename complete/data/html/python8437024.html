<h3>Question (ID-8437024):</h3><h2>Modify a large list without any loops in python</h2><p>My list is:</p>

<pre><code>a=[1,2,3,4]
</code></pre>

<p>Now I want my list to be:</p>

<pre><code>a=[-1,-2,-3,-4]
</code></pre>

<p>How can I change my list this way without using any loops?</p>

<p>Update: this may be a large list, on the order of 10000 elements.</p>
<br /><h3>Answers (Total-8):</h3><b>#0</b><br /><p>some quick and dirty benchmarks from ipython</p>

<pre><code>In [1]: a=range(10000)

In [2]: import numpy 

In [3]: timeit [-i for i in a]
1000 loops, best of 3: 576 us per loop

In [4]: timeit map(lambda i:-i, a)
1000 loops, best of 3: 1.68 ms per loop

In [5]: timeit list(-1*numpy.array(a))
100 loops, best of 3: 2.53 ms per loop
</code></pre>

<p>Note that if <code>a</code> can be a numpy array you don't need to wast time on the conversion</p>

<pre><code>In [6]: a = numpy.array(a)

In [7]: timeit -- -a
100000 loops, best of 3: 15.4 us per loop
</code></pre>
<br /><b>#1</b><br /><p>Use Python's <a href="http://docs.python.org/library/functions.html#map" rel="nofollow">map</a> functionality</p>

<pre><code>a[:] = map(lambda x: -x, a)
</code></pre>

<p>Here's the description of the map function from the above link:</p>

<blockquote>
  <p><strong>map(function, iterable, ...)</strong><br>
  Apply function to every item of iterable and return a list of the
  results. If additional iterable arguments are passed, function must
  take that many arguments and is applied to the items from all
  iterables in parallel. If one iterable is shorter than another it is
  assumed to be extended with None items. If function is None, the
  identity function is assumed; if there are multiple arguments, map()
  returns a list consisting of tuples containing the corresponding items
  from all iterables (a kind of transpose operation). The iterable
  arguments may be a sequence or any iterable object; the result is
  always a list.</p>
</blockquote>
<br /><b>#2</b><br /><p>You can use the numpy library:</p>

<pre><code>list(-1*numpy.array(a))
</code></pre>
<br /><b>#3</b><br /><p>Well it depends on what you mean by without any loops. In case you just want to avoid explicit loops like</p>

<pre><code>a = [ -x for x in a ]
</code></pre>

<p>you could use the map function, that would loop for you.</p>

<pre><code>a = map( lambda x:-x, a)
</code></pre>
<br /><b>#4</b><br /><pre><code>import operator
a = map(operator.neg, a)
</code></pre>
<br /><b>#5</b><br /><p>Without knowing the exact reason why loop is not required and knowing that there is no other efficient way to negate a list here is my super fast solution (I have no knowledge of the context so this may not work)</p>

<pre><code>class nlist(object):
    def __init__(self, l):
        self._list = l

    def __getitem__(self, key):
        return -self._list[key]

    def __iter__(self):
        for i in self._list:
            yield -i


nl = nlist([1,2,3,4])
for i in nl:
    print i
</code></pre>
<br /><b>#6</b><br /><p>You cannot do it without loop but you can hide the fact.    </p>

<pre><code>map(lambda x: -x, a)
</code></pre>
<br /><b>#7</b><br /><pre><code>a = [-a[0], -a[1], -a[2], -a[3]]
</code></pre>

<p>Now the problem is that this only works if <code>a</code> has exactly 4 items. To generalise to different number of items...well that's what loops are for.</p>
<br />