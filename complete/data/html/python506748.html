<h3>Question (ID-506748):</h3><h2>Symbolic Mathematics Python?</h2><p>I am extreamly interested in math and programming and planning to start <strong>symbolic math</strong> project <strong>from scratch</strong>.</p>

<ol>
<li><p>Is this good project idea?</p></li>
<li><p>Where to start?</p></li>
<li><p>How should one approach this
    project?</p></li>
<li><p>Any good resources?</p></li>
</ol>

<p>Thanks in advance.</p>
<br /><h3>Answers (Total-7):</h3><b>#0</b><br /><ol>
<li><p>It's a good project to practice programming skills. But if you want to create a real library that other people will want to use this is a project you do not want to start allone and from scratch ...</p></li>
<li><p><em>Where to start:</em> Have a look at the solutions that are already out there and think about what it is that you want to do different. How will your project differ from others? </p></li>
<li><p>Resource: <a href="http://code.google.com/p/sympy" rel="nofollow">SymPy is a Python library for symbolic mathematics</a></p></li>
</ol>
<br /><b>#1</b><br /><p>1.Is this good project idea?</p>

<p>Yes; I would expect it to provide an endless source of interesting work which will, quite quickly, test and extend your programming powers.</p>

<p>2.Where to start?</p>

<p>I second the other suggestions that you should look at existing work.  SAGE is very impressive and if you had asked for my advice I would suggest that you firstly write a basic system for doing arithmetic with numbers and symbols; then have a look at SAGE and write a module to extend the system, in other words become a contributor to something larger rather than trying to do it all on your own.  Look also at Mathematica and Maple, Macsyma and Axiom.  The latter 2 are free (I think) but they are all well documented on-line and a great source of ideas and challenges.</p>

<p>3.How should one approach this project?</p>

<p>As one would approach eating an elephant.  One bite at a time.  More seriously, I think there are some core issues, such as representation of expressions, and some basic functionality (arithmetic on polynomials) which you could cut your teeth on.</p>

<p>4.Any good resources?</p>

<p>Lots and lots.  google for 'computer algebra', 'term rewriting'.  Have a look at what's available on Amazon.  And, if you have access, check out the ACM digital library</p>

<p>Good luck.</p>
<br /><b>#2</b><br /><p>Symbolic math is a fun project.  Whether or not anyone uses it doesn't appear to matter in your question, so dive in.</p>

<p>I've written two of these over the years.  The coolest was one for SQL where clauses -- it did some trivial symbolic manipulations on the SQL to fold in some additional AND conditions.  Not a complete "solver" or "optimizer" or anything, just a few symbolic manipulations of any SQL where clause possible.  The less cool one was for a debugger; it did complex math to work out (symbolically) stack offsets for variables.</p>

<p>You start by defining classes for elements of a mathematical expression -- operands, operators, functions, etc.</p>

<p>You have to decide what manipulations these objects have to participate in.  Getting a concrete value for an expression is an easy and obvious one.  Start with the case where all variables have a binding.</p>

<p>Then handle the case where some variables remain unbound, and you can only evaluate parts of the expression.</p>

<p>Then handle rearranging an expression into a canonical form.  I.e., you've done a partial evaluation and have <code>Add( Variable(x), Add( Variable(x), Lit(3) ) )</code>.  You need to write rules to transform this into <code>Add( Multiply( Lit(2), Variable(x) ), Lit(3) )</code>.</p>

<p>One very cool exercise is optimizing the parenthesis so that the printed output has the fewest parenthesis necessary to capture the meaning.</p>

<p>There are many, many other "expression transformation" rules that we all learn in school for doing algebraic manipulations.  Lots of them.</p>

<p>In particular, rearranging an equation to isolate a variable can be really hard in some cases.</p>

<p>Doing the derivative transformation is easy, but symbolic integration is really, really hard with a ton of special cases.</p>

<p>The basics are fun.  Depending on how far you want to go, it gets progressively harder. </p>
<br /><b>#3</b><br /><p>@Resources: You could take a look at <a href="http://www.strout.net/python/pythonica.html" rel="nofollow">pythonica</a> - this was an attepmt to implement a Mathematica-type program in python (soure code is available for download).</p>
<br /><b>#4</b><br /><p>This <a href="http://planet.sympy.org/" rel="nofollow">pySym Blog</a> might also interest you for getting ideas and starters, and learning what others are doing with python &amp; symbolic math.</p>
<br /><b>#5</b><br /><p>More in the way of resources: <a href="http://code.google.com/p/sympycore/" rel="nofollow">SympyCore</a>:</p>

<blockquote>
  <p>The aim of the  SympyCore  project is to seek out new high Performance solutions to represent and manipulate symbolic expressions in the Python programming language, and to try out new symbolic models to achive fundamentally consistent and sufficiently general symbolic model that would be easy to extend to a Computer Algebra System (CAS).</p>
</blockquote>
<br /><b>#6</b><br /><p>I think this is a great project for a programmer of any skill level. It is quite easy to do implement a symbolic calculator that is just powerful enough to be useful. If you continue to work on breadth, there are so many fun features to add that you can occupy yourself with it for a long time. If you choose to go for depth, you will find that things soon get <em>very hard</em>. You can challenge yourself indefinitely, if that's what you like.</p>

<p>There are many great resources. I recommend the book "Modern Computer Algebra" by zur Gathen and Gerhard, although it is really more concerned with arithmetic in special forms (polynomials, integers, matrices) than general symbolic manipulation. When you're starting out, you may actually be better helped by looking at some Lisp or Scheme tutorial, because symbolic math is conceptually very straightforward to do in Lisp, and to build a symbolic engine in Python you'll more or less have to implement a mini-Lisp as a foundation.</p>

<p>As others have pointed out, you could look at SymPy and sympycore for inspiration or concrete algorithms. The source code for either project is a bit complex (but certainly not too hard to learn from).</p>

<p>(If I may plug a bit, I <a href="http://www.dd.chalmers.se/~frejohl/code/sym/" rel="nofollow">wrote a tiny symbolic engine</a> a while back (as a weekend project -- it's very tiny and I haven't worked on it since). It implements a generic symbolic engine in about 200 lines of code, and then there are  300 lines of code implementing symbolic arithmetic and symbolic boolean algebra, with some very rudimentary simplification. Perhaps easier to dig into than SymPy. But everything in there is things that you could easily discover for yourself, and may have more fun doing so.)</p>
<br />