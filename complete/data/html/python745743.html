<h3>Question (ID-745743):</h3><h2>Is Python interpreted (like Javascript or PHP)?</h2><p>I know next to nothing about Python but have decided to jump in. I'm curious though, is Python strictly interpreted at run time, or can it be used to develop programs that run as background applications (like a Java app or C program)?</p>
<br /><h3>Answers (Total-7):</h3><b>#0</b><br /><p>There's multiple questions here:</p>

<ol>
<li>No, Python is not interpreted. The standard implementation compiles to bytecode, and then executes in a virtual machine. Many modern JavaScript engines also do this.</li>
<li>Regardless of implementation (interpreter, VM, machine code), anything you want can run in the background. You can run shell scripts in the background, if you want.</li>
</ol>
<br /><b>#1</b><br /><p>Technically Python is compiled to bytecode and then interpreted in a VM, as John Millikin said. If the Python compiler is able to write out the bytecode into a .pyc file, it will (usually) do so.</p>

<p>On the other hand, there's no explicit compilation step in Python as there is with Java or C. From the point of view of the developer, it looks like Python is just interpreting the .py file directly. Plus, Python offers an interactive prompt where you can type Python statements and have them executed immediately. So the workflow in Python is much more similar to that of an interpreted language than that of a compiled language. To me (and a lot of other developers, I suppose), that distinction of workflow is more important than whether there's an intermediate bytecode step or not.</p>
<br /><b>#2</b><br /><p>As the varied responses will tell you, the line between interpreted and compiled is no longer as clear as it was when such terms were coined.  In fact, it's also something of a mistake to consider <em>langauges</em> as being either interpreted or compiled, as different <em>implementations</em> of languages may do different things.  These days you can find both <a href="http://root.cern.ch/drupal/content/cint" rel="nofollow">C interpreters</a> and <a href="https://developer.mozilla.org/en/Rhino%5FJavaScript%5FCompiler" rel="nofollow">Javascript compilers</a>.</p>

<p>Even when looking at an implementation, things still aren't clear-cut.  There are layers of interpretation.  Here are a few of the gradations between interpreted and compiled:</p>

<ol>
<li><p>Pure interpretation.  Pretty much what it says on the tin.  Read a line of source and immediately do what it says.  This isn't actually done by many production languages - pretty much just things like shell scripts.</p></li>
<li><p><a href="http://en.wikipedia.org/wiki/Tokenisation" rel="nofollow">Tokenisation</a> + interpretation.  A trivial optimisation on the above.  Rather than interpret each line from scratch, it's first tokenised (that is, rather than seeing a string like "print 52 + x", it's translated into a stream of tokens (eg. <code>[PRINT_STATEMENT, INTEGER(52), PLUS_SIGN, IDENTIFIER('x')]</code> ) to avoid repeatedly performing that state of interpretation.  Many versions of basic worked this way.</p></li>
<li><p><a href="http://en.wikipedia.org/wiki/Bytecode" rel="nofollow">Bytecode</a> compilation.  This is the approach taken by languages like Java and C# (though see below).  The code is transformed into instructions for a "virtual machine".  These instructions are then interpreted.  This is also the approach taken by python (or at least cpython, the most common implementation.) The <a href="http://www.jython.org/Project/" rel="nofollow">Jython</a> and <a href="http://www.codeplex.com/Wiki/View.aspx?ProjectName=IronPython" rel="nofollow">Ironpython</a> implementations also take this approach, but compile to the bytecode for the Java and C# virtual machines resepectively.</p></li>
<li><p>Bytecode + <a href="http://en.wikipedia.org/wiki/Just-in-time%5Fcompilation" rel="nofollow">Just in Time compilation</a>.  As above, but rather than interpreting the bytecodes, the code that would be performed is compiled from the bytecode at the point of execution, and then run.  In some cases, this can actually outperform native compilation, as it is free to perform runtime analysis on the code, and can use specific features of the current processor (while static compilation may need to compile for a lowest common denominator CPU).  Later versions of Java, and C# use this approach.  <a href="http://psyco.sourceforge.net/" rel="nofollow">Psyco</a> performs this for python.</p></li>
<li><p>Native machine-code compilation.  The code is compiled to the machine code of the target system.  You may think we've now completely eliminated interpretation, but even here there are subtleties.  Some machine code instructions are not actually directly implemented in hardware, but are in fact implemented via <a href="http://en.wikipedia.org/wiki/Microcode" rel="nofollow">microcode</a> - even machine code is sometimes interpreted!</p></li>
</ol>
<br /><b>#3</b><br /><p>Yes, Python is interpreted, but you can also run them as long-running applications.</p>
<br /><b>#4</b><br /><p>Python is an interpreted language but it is the bytecode which is interpreted at run time. There are also many tools out there that can assist you in making your programs run as a windows service / UNIX daemon.</p>
<br /><b>#5</b><br /><p>Yes, it's interpreted, its main implementation compiles bytecode first and then runs it though (kind of if you took a java source and the JVM compiled it before running it). Still, you can run your application in background. Actually, you can run pretty much anything in background.</p>
<br /><b>#6</b><br /><p>There is something that's close to it called <a href="http://psyco.sourceforge.net/introduction.html" rel="nofollow">Psyco</a>. I never worked with this Python compiler, and I suggest you peruse the Python mailing list and the web for possible pitfalls if you are using it on a mission-critical app in production. </p>
<br />