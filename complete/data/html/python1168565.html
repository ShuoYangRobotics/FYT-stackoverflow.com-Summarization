<h3>Question (ID-1168565):</h3><h2>Recommended ways to split some functionality into functions, modules and packages?</h2><p>There comes a point where, in a relatively large sized project, one need to think about splitting the functionality into various functions, and then various modules, and then various packages. Sometimes across different source distributions (eg: extracting a common utility, such as optparser, into a separate project).</p>

<p>The question - how does one decide the parts to put in the same module, and the parts to put in a separate module? Same question for packages.</p>
<br /><h3>Answers (Total-6):</h3><b>#0</b><br /><p>There's a classic paper by David Parnas called "On the criteria to be used in decomposing systems into modules". It's a classic (and has a certain age, so can be a little outdated).</p>

<p>Maybe you can start from there, a PDF is available here</p>

<p><a href="http://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf" rel="nofollow">http://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf</a></p>
<br /><b>#1</b><br /><p>Take out a pen and piece of paper.  Try to draw how your software interacts on a high level.  Draw the different layers of the software etc.  Group items by functionality and purpose, maybe even by what sort of technology they use.  If your software has multiple abstraction layers, I would say to group them by that.  On a high level, the elements of a specific layer all share the same general purpose.  Now that you have your software in layers, you can divide these layers into different projects based on specific functionality or specialization.  </p>

<p>As for a certain stage that you reach in which you should do this?  I'd say when you have multiple people working on the code base or if you want to keep your project as modular as possible.  Hopefully your code is modular enough to do this with.  If you are unable to break apart your software on a high level, then your software is probably spaghetti code and you should look at refactoring it.  </p>

<p>Hopefully that will give you something to work with.</p>
<br /><b>#2</b><br /><p>IMHO this should probably one of the things you do earlier in the development process. I have never worked on a large-scale project, but it would make sense that you make a roadmap of what's going to be done and where. (Not trying to rib you for asking about it like you made a mistake :D )</p>

<p>Modules are generally grouped somehow, by purpose or functionality. You could try each implementation of an interface, or other connections.</p>
<br /><b>#3</b><br /><p>See <a href="http://stackoverflow.com/questions/106896/how-many-python-classes-should-i-put-in-one-file">http://stackoverflow.com/questions/106896/how-many-python-classes-should-i-put-in-one-file</a></p>

<p>Sketch your overall set of class definitions.</p>

<p>Partition these class definitions into "modules".</p>

<p>Implement and test the modules separately from each other.</p>

<p>Knit the modules together to create your final application.</p>

<p><strong>Note</strong>.  It's almost impossible to decompose a working application that evolved organically.  So don't do that.  </p>

<p>Decompose your design early and often.  Build separate modules.  Integrate to build an application.</p>
<br /><b>#4</b><br /><p>I sympathize with you. You are suffering from self-doubt. Don't worry. If you can speak any language, including your mother tongue, you are qualified to do modularization on your own. For evidence, you may read "The Language Instinct," or "The Math Instinct."</p>

<p>Look around, but not too much. You can learn a lot from them, but you can learn many bad things from them too. </p>

<p>(1) Some projects/framework get a lot fo hype. Yet, some of their groupings of functionality, even names given to modules are misleading. They don't "reveal intention" of the programmers. They fail the "high cohesiveness" test.</p>

<p>(2) Books are no better. Please apply 80/20 rule in your book selection. Even a good, very complete, well-researched book like Capers Jones' 2010 "Software Engineering Best Practices" is clueless. It says 10-man Agile/XP team would take 12 years to do Windows Vista or 25 years to do an ERP package! It says there is no method till 2009 for segmentation, its term for modularization. I don't think it will help you.</p>

<p>My point is: You must pick your model/reference/source of examples very carefully. Don't over-estimate famous names and under-estimate yourself.</p>

<p>Here is my help, proven in my experience.</p>

<p>(1) It is a lot like deciding what attributes go to which DB table, what properties/methods go to which class/object etc? On a deeper level, it is a lot like arranging furniture at home, or books in a  shelf. You have done such things already. Software is the same, no big deal!</p>

<p>(2) Worry about "cohesion" first.  e.g. Books (Leo Tolstoy, James Joyce, DE Lawrence) is choesive .(HTML, CSS, John Keats. jQuery, tinymce) is not. And there are many ways to arrange things. Even taxonomists are still in serious feuds over this.</p>

<p>(3) Then worry about "coupling." Be "shy". "Don't talk to strangers." Don't be over-friendly. Try to make your package/DB table/class/object/module/bookshelf as self-contained, as independent as possible. Joel has talked about his admiration for the Excel team that abhor all external dependencies and that even built their own compiler.</p>
<br /><b>#5</b><br /><p>Actually it varies for each project you create but here is an example:</p>

<ol>
<li><code>core</code> package contains modules that are your project cant live without. this may contain the main functionality of your application.</li>
<li><code>ui</code> package contains modules that deals with the user interface. that is if you split the UI from your console.</li>
</ol>

<p>This is just an example. and it would really you that would be deciding which and what to go where.</p>
<br />