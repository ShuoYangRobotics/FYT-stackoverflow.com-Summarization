<h3>Question (ID-2145510):</h3><h2>Python: Random is barely random at all?</h2><p>I did this to test the randomness of randint:</p>

<pre><code>&gt;&gt;&gt; from random import randint
&gt;&gt;&gt;
&gt;&gt;&gt; uniques = []
&gt;&gt;&gt; for i in range(4500):  # You can see I was optimistic.
...     x = randint(500, 5000)
...     if x in uniques:
...         raise Exception('We duped %d at iteration number %d' % (x, i))
...     uniques.append(x)
...
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 4, in &lt;module&gt;
Exception: We duped 887 at iteration number 7
</code></pre>

<p>I tried about 10 times more and the best result I got was 121 iterations before a repeater. Is this the best sort of result you can get from the standard library?</p>
<br /><h3>Answers (Total-12):</h3><b>#0</b><br /><h2>The Birthday Paradox, or why PRNGs produce duplicates more often than you might think.</h2>

<p><br>There are a couple of issues at play in the OP's problem.  One is the <a href="http://en.wikipedia.org/wiki/Birthday_problem">birthday paradox</a> as mentioned above and the second is the nature of what you are generating, which does not inherently guarantee that a given number will not be repeated.  </p>

<p>The Birthday Paradox applies where given value can occur more than once during the period of the generator - and therefore duplicates can happen within a sample of values.  The effect of the Birthday Paradox is that the real likelihood of getting such duplicates is quite significant and the average period between them is smaller than one might otherwise have thought.  This dissonance between the percived and actual probabilities makes the Birthday Paradox a good example example of a <a href="http://en.wikipedia.org/wiki/Cognitive_bias">cognitive bias</a>, where a naive intuitive estimate is likely to be wildly wrong.</p>

<p><strong>A quick primer on Pseudo Random Number Generators (PRNGs)</strong></p>

<p>The first part of your problem is that you are taking the exposed value of a random number generator and converting it to a much smaller number, so the space of possible values is reduced.  Although some <a href="http://en.wikipedia.org/wiki/Pseudorandom_number_generator">pseudo-random number generators</a> do not repeat values during their period this transformation changes the domain to a much smaller one.  The smaller domain invalidates the 'no repeats' condition so you can expect a significant likelihood of repeats.   </p>

<p>Some algorithms, such as the <a href="http://en.wikipedia.org/wiki/Linear_congruential_generator">linear congruential PRNG</a> (<code>A'=AX|M</code>) <em>do</em> guarantee uniqueness for the entire period.  In a LCG the generated value contains the entire state of the accumulator and no additional state is held.  The generator is deterministic and cannot repeat a number within the period - any given accumulator value can imply only one possible successive value.  Therefore, each value can only occur once within the period of the generator.  However, the period of such a PRNG is relatively small - about 2^30 for typical implementations of the LCG algorithm - and cannot possibly be larger than the number of distinct values.</p>

<p>Not all PRNG algorithms share this characteristic; some can repeat a given value within the period.  In the OP's problem the <a href="http://en.wikipedia.org/wiki/Mersenne_twister">Mersenne Twister</a> algorithm (used in Python's <a href="http://docs.python.org/library/random.html">random</a> module) has a very long period - much greater than 2^32.   Unlike a Linear Congruential PRNG, the result is not purely a function of the previous output value as the accumulator contains additional state.  With 32 bit integer output and a period of ~2^19937 it cannot possibly provide a such a guarantee.  </p>

<p>The Merseene Twister is a popular algorithm for PRNGs because it has good statistical and geometric properties and a very long period - desirable characteristics for a PRNG used on simulation models.   </p>

<ul>
<li><p>Good <a href="http://en.wikipedia.org/wiki/Uniform_distribution_%28discrete%29">statistical properties</a> mean that the numbers generated by the algorithm are evenly distributed with no numbers having a significantly higher probability of appearing than others.  Poor statistical properties could produce unwanted skew in the results.</p></li>
<li><p>Good <a href="http://random.mat.sbg.ac.at/~charly/server/node3.html">geometric properies</a> mean that sets of N numbers do not lie on a hyperplane in N dimensional space.  Poor geometric properties can generate spurious correlations in a simulation model and distort the results.</p></li>
<li><p>A long period means that you can generate a lot of numbers before the sequence wraps around to the start.  If a model needs a large number of iterations or has to be run from several seeds then the 2^30 or so discrete numbers available from a typical LCG implementation may not be sufficient.  The MT19337 algorithm has a very long period - 2^19337-1, or about 10^5821.  By comparison the total number of atoms in the universe is estimated at about 10^80.</p></li>
</ul>

<p>The 32 bit integer produced by a MT19337 PRNG cannot possibly represent enough discrete values to avoid repeating during such a large period.  In this case duplicate values are likely to occur and inevitable with a large enough sample.  </p>

<p><strong>The Birthday Paradox in a nutshell</strong></p>

<p>This problem is originally defined as the probability of any two people in the room sharing the same birthday.  The key point is that <strong><em>any two</em></strong> people in the room could share a birthday.  People tend to naively misinterpret the problem as the probability of someone in the room sharing a birthday with a specific individual, which is the source of the <a href="http://en.wikipedia.org/wiki/Cognitive_bias">cognitive bias</a> that often causes people to underestimate the probability.  This is the incorrect assumption - there is no requirement for the match to be to a specific individual and any two individuals could match.  </p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Birthday_paradox.png/450px-Birthday_paradox.png" alt="This graph shows the probability of a shared birthday as number of people in the room increases.  For 23 people the probability of two sharing a birthday is just over 50%." title="This graph shows the probability of a shared birthday as number of people in the room increases.  For 23 people the probability of two sharing a birthday is just over 50%."></p>

<p>The probability of a match occurring between any two individuals is much higher than the probability of a match to a specific individual as the match does not have to be to a specific date.  Rather, you only have to find two individuals that share the same birthday.  From this graph (which can be found on the wikipedia page on the subject), we can see that we only need 23 people in the room for there to be a 50% chance of finding two that match in this way.</p>

<p>From the <a href="http://en.wikipedia.org/wiki/Birthday_problem">Wikipedia entry on the subject</a> we can get a <a href="http://en.wikipedia.org/wiki/Birthday_problem#Understanding_the_problem">nice summary.</a>  In the OP's problem we have 4,500 possible 'birthdays', rather than 365.  For a given number of random values generated (equating to 'people') we want to know the probability of <em>any</em> two identical values appearing within the sequence.  </p>

<p><strong>Computing the likely effect of the Birthday Paradox on the OP's problem</strong></p>

<p>For a sequence of 100 numbers, we have <img src="http://mathurl.com/yc4cdsr.png" alt="(100 * 99) / 2 = 4950" title="(100 * 99) / 2 = 4950"> pairs (see <a href="http://en.wikipedia.org/wiki/Birthday_problem#Understanding_the_problem">Understanding the Problem</a>) that could potentially match (i.e. the first could match with the second, third etc., the second could match the third, fourth etc. and so on), so the number of <em>combinations</em> that could potentially match is rather more than just 100.  </p>

<p>From <a href="http://en.wikipedia.org/wiki/Birthday_problem#Calculating_the_probability">Calculating the Probability</a> we get an expression of <img src="http://mathurl.com/ybfweny.png" alt="1 - (4500! / (4500**100 * (4500 - 100)!)" title="1 - (4500! / (4500**100 * (4500 - 100)!)">.  The following snippet of Python code below does a naive evaluation of the probability of a matching pair occurring.  </p>

<pre><code># === birthday.py ===========================================
#
from math import log10, factorial

PV=4500          # Number of possible values
SS=100           # Sample size

# These intermediate results are exceedingly large numbers;
# Python automatically starts using bignums behind the scenes.
#
numerator = factorial (PV)          
denominator = (PV ** SS) * factorial (PV - SS)

# Now we need to get from bignums to floats without intermediate
# values too large to cast into a double.  Taking the logs and 
# subtracting them is equivalent to division.
#  
log_prob_no_pair = log10 (numerator) - log10 (denominator)

# We've just calculated the log of the probability that *NO*
# two matching pairs occur in the sample.  The probability
# of at least one collision is 1.0 - the probability that no 
# matching pairs exist.
#
print 1.0 - (10 ** log_prob_no_pair)
</code></pre>

<p>This produces a sensible looking result of <strong><em>p=0.669</em></strong> for a match occuring within 100 numbers sampled from a population of 4500 possible values (Maybe someone could verify this and post a comment if it's wrong).  From this we can see that the lengths of runs between matching numbers observed by the OP seem to be quite reasonable.</p>

<p><strong>Footnote: using shuffling to get a unique sequence of pseudo-random numbers</strong> </p>

<p>See <a href="http://stackoverflow.com/questions/2145510/python-random-is-barely-random-at-all/2145533#2145533">this answer below from S. Mark</a> for a means of getting a guaranteed unique set of random numbers.  The technique the poster refers to takes an array of numbers (which you supply, so you can make them unique) and shuffles them into random order.  Drawing the numbers in sequence from the shuffled array will give you a sequence of pseudo-random numbers that are guaranteed not to repeat.</p>

<p><strong>Footnote: Cryptographically Secure PRNGs</strong> </p>

<p>The MT algorithm is not <a href="http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">cryptographically secure</a> as it is relatively easy to infer the internal state of the generator by observing a sequence of numbers.  Other algorithms such as <a href="http://en.wikipedia.org/wiki/Blum_Blum_Shub">Blum Blum Shub</a> are used for cryptographic applications, but may be unsuitable for simulation or general random number applications.  Cryptographically secure PRNGs may be expensive (perhaps requiring bignum calculations) or may not have good geometric properties.  In the case of this type of algorithm the primary requirement is that it should be computationally infeasible to infer the internal state of the generator by observing a sequence of values.</p>
<br /><b>#1</b><br /><p>Before blaming Python, you should really brush up some probability &amp; statistics theory. Start by reading about the <a href="http://en.wikipedia.org/wiki/Birthday_paradox" rel="nofollow">birthday paradox</a></p>

<p>By the way, the <code>random</code> module in Python uses the <a href="http://en.wikipedia.org/wiki/Mersenne_twister" rel="nofollow">Mersenne twister</a> PRNG, which is considered very good, has an enormous period and was extensively tested. So rest assured you're in good hands.</p>
<br /><b>#2</b><br /><p>If you don't want repetative one, generate sequential array and use <a href="http://docs.python.org/library/random.html#random.shuffle" rel="nofollow">random.shuffle</a></p>
<br /><b>#3</b><br /><p><img src="http://dilbert.com/dyn/str_strip/000000000/00000000/0000000/000000/00000/2000/300/2318/2318.strip.gif" alt="alt text"></p>
<br /><b>#4</b><br /><p>True randomness definitely includes repetition of values before the whole set of possible values is exhausted. It would not be random otherwise, as you would be able to predict for how long a value would not be repeated.</p>

<p>If you ever rolled dice, you surely got 3 sixes in row quite often...</p>
<br /><b>#5</b><br /><p>As an answer to the answer of Nimbuz:</p>

<p><a href="http://xkcd.com/221/">http://xkcd.com/221/</a></p>

<p><img src="http://imgs.xkcd.com/comics/random_number.png" alt="alt text"></p>
<br /><b>#6</b><br /><p>You are generating <code>4500</code> random numbers from a range <code>500 &lt;= x &lt;= 5000</code>. You then check to see for each number whether it has been generated before. The <a href="http://en.wikipedia.org/wiki/Birthday_problem" rel="nofollow">birthday problem</a> tells us what the probability is for two of those numbers to match given <code>n</code> tries out of a range <code>d</code>.</p>

<p>You can also invert the formula to calculate how many numbers you have to generate until the chance of generating a duplicate is more than <code>50%</code>. In this case you have a <code>&gt;50%</code> chance of finding a duplicate number after <code>79</code> iterations.</p>
<br /><b>#7</b><br /><p>Python's random implementation is actually quite state of the art: </p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Mersenne_twister" rel="nofollow">http://en.wikipedia.org/wiki/Mersenne_twister</a> </li>
<li><a href="http://docs.python.org/library/random.html" rel="nofollow">http://docs.python.org/library/random.html</a></li>
</ul>
<br /><b>#8</b><br /><p>That's not a repeater. A repeater is when you repeat the same <em>sequence</em>. Not just one number.</p>
<br /><b>#9</b><br /><p>You have defined a random space of 4501 values  (500-5000), and you are iterating 4500 times.  You are basically guaranteed to get a collision in the test you wrote.</p>

<p>To think about it another way:</p>

<ul>
<li>When the result array is empty P(dupe) = 0</li>
<li>1 value in Array P(dupe) = 1/4500</li>
<li>2 values in Array P(dupe) = 2/4500</li>
<li>etc.</li>
</ul>

<p>So by the time you get to 45/4500, that insert has a 1% chance of being a duplicate, and that probability keeps increasing with each subsequent insert.</p>

<p>To create a test that truly tests the abilities of the random function, increase the universe of possible random values (eg: 500-500000)  You may, or may not get a dupe.  But you'll get far more iterations on average.</p>
<br /><b>#10</b><br /><p>For anyone else with this problem, I used uuid.uuid4() and it works like a charm.</p>
<br /><b>#11</b><br /><p>I want to write a program that will simulate 3 dice being rolled at the same time but I want the 3 dice to always have a different number from each other every time they are rolled. ex on the first roll I get 2,1,6 that is fine but I dont want the prog. to ever roll duplicates for ex 2,4,2.</p>

<h1>generating random numbers 1 - 6</h1>

<p>die1 = random.randint(1, 6) </p>

<p>die2 = random.randrange(1, 6)</p>

<p>die3 = random.randrange(1, 6)</p>

<p>this is all I have so far, im a beginner ... </p>
<br />