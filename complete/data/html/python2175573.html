<h3>Question (ID-2175573):</h3><h2>What are the downsides of using Python instead of Objective-C?</h2><p>I know some Python and I'm really impressed by the language's ease of use. From what I've seen of Objective-C it looks a lot less pretty, but it seems to be the <em>lingua franca</em> for Mac OS X development (which means it has better documentation). </p>

<p>I'm thinking about starting Mac development - will using PyObjC+Python make me a second class citizen?</p>
<br /><h3>Answers (Total-8):</h3><b>#0</b><br /><p>Yes.</p>

<p>For one thing, as you note, all the documentation is written for Objective-C, which is a very different language.</p>

<p>One difference is method name. In Objective-C, when you send a message to (Python would say “call a method of”) an object, the method name (selector) and arguments are mixed:</p>

<pre><code>NSURL *URL = /*…*/;
NSError *error = nil;

QTMovie *movie = [QTMovie movieWithURL:URL
    error:&amp;error];
</code></pre>

<p>This isn't possible in Python. Python's keyword arguments don't count as part of the method name, so if you did this:</p>

<pre><code>movie = QTMovie.movieWithURL(URL, error = ???)
</code></pre>

<p>you would get an exception, because the QTMovie class has no method named <code>movieWithURL</code>; the message in the Objective-C example uses the selector <code>movieWithURL:error:</code>. <code>movieWithURL:</code> and <code>movieWithURL</code> would be two other selectors.</p>

<p>There's no way they can change this, because Python's keyword arguments aren't ordered. Suppose you have a hypothetical three-argument method:</p>

<pre><code>foo = Foo.foo(fred, bar=bar, baz=baz)
</code></pre>

<p>Now, this calls <code>foo:bar:baz:</code>, right?</p>

<p>Not so fast. Foo may also have a method named <code>foo:baz:bar:</code>. Because Python's keyword arguments aren't ordered, you may actually be calling that method. Likewise, if you tried to call <code>foo:baz:bar:</code>, you may actually end up calling <code>foo:bar:baz:</code>. In reality, this case is unlikely, but if it ever happens, you would be unable to reliably call either method.</p>

<p>So, in PyObjC, you would need to call the method like this:</p>

<pre><code>movie = QTMovie.movieWithURL_error_(URL, ???)
</code></pre>

<p>You may be wondering about the ???. C doesn't allow multiple return values, so, in Objective-C, the <code>error:</code> argument takes a pointer to a pointer variable, and the method will store an object in that variable (this is called return-by-reference). Python doesn't have pointers, so the way the bridge handles arguments like this is that you pass None, and the method will (appear to) return a tuple. So the correct example is:</p>

<pre><code>movie, error = QTMovie.movieWithURL_error_(URL, None)
</code></pre>

<p>You can see how even a simple example deviates from what documentation might show you in Objective-C.</p>

<p>There are other issues, such as the GIL. Cocoa apps are only going to get more concurrent, and you're going to want in on this, especially with tempting classes like NSOperation lying around. And <a href="http://blip.tv/file/2232410" rel="nofollow">the GIL is a serious liability, especially on multi-core machines</a>. I say this as a Python guy myself (when not writing for Cocoa). As David Beazley demonstrates in that video, it's a cold, hard fact; there's no denying it.</p>

<p>So, if I were going to switch away from Objective-C for my apps, I would take up <a href="http://macruby.org/" rel="nofollow">MacRuby</a>. Unlike with PyObjC and RubyCocoa, messages to Cocoa objects don't cross the language bridge; it's a from-the-ground-up Ruby implementation in Cocoa, with language extensions to better support writing Cocoa code in it.</p>

<p>But that's too far ahead of you. You're just getting started. Start with Objective-C. Better to avoid <em>all</em> impedance mismatches between the language you're using and the one the documentation is written for by keeping them the same language.</p>

<p>Plus, you'll find some bugs (such as messages to deceased objects) harder to diagnose without knowledge of how Objective-C works. You <em>will</em> write these bugs as a new Cocoa programmer, regardless of which language you're writing the code in.</p>

<p>So, learn C, then learn Objective-C. A working knowledge of both shouldn't take more than a few weeks, and at the end of it, you'll be better prepared for everything else.</p>

<p>I won't go into how I learned C; suffice to say that I do not recommend the way I did it. I've heard that <a href="http://rads.stackoverflow.com/amzn/click/1430218096" rel="nofollow">this book</a> is good, but I've never owned nor read it. I do have <a href="http://oreilly.com/catalog/9781565923065/" rel="nofollow" title="Practical C Programming by Steve Oualline">this book</a>, and can confirm that it's good, but it's also not Mac-specific; skip the chapter on how to compile the code, and use Xcode instead.</p>

<p>As for Objective-C: <a href="http://rads.stackoverflow.com/amzn/click/0321503619" rel="nofollow">The Hillegass book</a> is the most popular, but I didn't use it. (I have skimmed it, and it looks good.) I read <a href="http://developer.apple.com/mac/library/documentation/Cocoa/Conceptual/ObjectiveC/" rel="nofollow">Apple's document on the language</a>, then jumped right in to writing small Cocoa apps. I read some of <a href="http://developer.apple.com/mac/library/navigation/" rel="nofollow">the guides</a>, with mixed results. There is <a href="http://developer.apple.com/mac/library/documentation/Cocoa/Conceptual/ObjCTutorial/" rel="nofollow">a Currency Converter tutorial</a>, but it didn't help me at all, and doesn't quite reflect a modern Cocoa app. (Modern apps still use outlets and actions, but also Bindings, and a realistic Currency Converter would be almost entirely a couple of Bindings.)</p>
<br /><b>#1</b><br /><p>This really says it all: </p>

<blockquote>
  <p>As the maintainer of PyObjC for nearly
  15 years, I will say it bluntly. Use
  Objective-C. You will need to know
  Objective-C to really understand Cocoa
  anyway and PyObjC is just going to add
  a layer of bugs &amp; issues that are
  alien to 99% of Cocoa programmers.</p>
</blockquote>

<p>a comment in an answer to <a href="http://stackoverflow.com/questions/1359227/pyobjc-and-cocoa-on-snow-leopard">this question</a>. <a href="http://stackoverflow.com/questions/426607/">This</a> question is also interesting.</p>
<br /><b>#2</b><br /><p>Second class citizen seems a bit strong. The Objective-C API's are available from Python as well, should you need them, and that's mostly if you want to make Cocoa apps. But then they are restricted to OS X anyway. Personally, I have no interest in building apps that isn't cross-platform, but that's me. That also means I haven't actually done this, so I don't know how tricky it is, but there was an article in the Python Magazine not long ago, and it didn't look that horrible.</p>

<p>The major drawback of Python is execution time, and that mainly comes from it being a dynamic language. This can be solved with Cython and C-extensions, etc, but then you get a mix of Python + ObjectiveC API's + Cython which can be daunting.</p>

<p>So it depends a lot of what kinds of applications you are going to make. Something uniquely OSX-ish that makes no sense anywhere else? ObjectiveC is probably the ticket. Cross-platform servers, well then Python rocks! Something else? Then it depends.</p>
<br /><b>#3</b><br /><p><strong>DO NOT ATTEMPT</strong> to avoid learning objective-C if you're going to write apps for the Mac.  The purpose of PyObjC and the other language bindings is to let you re-use existing libraries in your apps, not to let you avoid learning the native tools.  </p>
<br /><b>#4</b><br /><p>This is something I've been wondering myself, and although I hope someone comes by with more experience, from what I know you will not be seriously constrained by Python itself. Along with Java and GCC, Python is an excellent way to write native cross-platform applications. Once you get the hang of it you should be able to map example code in Objective C to your Python code.</p>

<p>Since you have access to all libraries and events, everything that you can do in Objective C will be there in Python. Of course, the more OS X-only calls and functions you use, the less easy it will be to port to another platform, but that's beside the point. Usually graphics programming  and working with device drivers is somewhat of a limiting factor - but in both cases I'm finding evidence of good support and community libraries (search for Python and Quartz, Lightblue, libhid, PyUSB, for some examples).</p>

<p>The decisive factor for me would be: what is the level of tooling and IDE support that is needed. Apple provides some great software for building new software, but then again with something like Pydev you've got a great place to write Python code too! <a href="http://pydev.org/" rel="nofollow">http://pydev.org/</a></p>

<p>So give it a try, I'm sure you won't regret it, and there will be a supportive community to draw on for help and insipiration.</p>
<br /><b>#5</b><br /><p>You're going to need Objective-C: that's what all the tutorials, documentation, sample code, and everything is written in. In addition to a wilder variety of people being able to help you.</p>

<p>So learn ObjC first. If, on your second or third project, or a year down the road, you start a project that needs a Python module (like, say, Twisted, or SQLAlchemy. But a SERIOUS need like foundation of your app need, where the extra boost your app gets makes everything worth it), then you can write a PyObjC app and get a lot of the speed benefits of that language, with your background in Cocoa.</p>
<br /><b>#6</b><br /><p>Just as an extra option, consider that <a href="http://wxpython.org/" rel="nofollow">wxPython</a> can produce some pretty good applications on Mac as well as on Linux and Windows.  For the most part you can get native appearance but maintain portability with little or no attention to platform-specific issues.</p>

<p>In other words, PyObjC + Python is <em>not</em> the only way to do Mac development with Python.</p>
<br /><b>#7</b><br /><p>No you dont need to know Objective C you dont need to use PyObjC , and you wont be a second class citizent. </p>

<p>Unless you want to do something extremely specific to the MAC platform , coding in Objective C or using PyObjC is a really bad idea. </p>

<p>The reason is obvious, once you go the objc route you say a big "goodbye" to other platforms. Its that simple. </p>

<p>Apple does not want you to code for other platforms the same way Microsoft does not want you to code for other platforms. And that is why more and more developers are turning to open source languages like, python, java, ruby etc. Because you dont care what Apple and Microsot , you only care about an App that is the most useful and most easy to develop. And making your App available only for MAC will make it less useful and obviously developing in Objective C is way more difficult. </p>

<p>Python has more than enough libraries to accomodate you , hundrends of them , readily available for the mac platform. I for instance develope a new application in pygame, no its not a game, if I have done the same thing in ObjC or PyObj I would have to rewrite the code for windows and linux. While with pygame my code works exactly the same in windows and linux even though my main platform is macos. </p>

<p>Thats the appeal of most python libraries , they are cross platform. WxPython is another example, someone mentioned that "it does not exactly look natively" , do you want this to stop you from making your application available for windows and linux. Why limit yourself only on the MAC platform ? Do you think the average user will care how natively your app will look. Even macos apps do not look native , many of them introduce their own "eye candy" gui. Not that you cant make WxPython look 100% native, the way you code is always importnat.  </p>

<p>Objc makes sense when you intend to develop for Iphone OS , as Apple thought it a great idea to exclude python (and not only python), even though they were forced to include javascript (or else websurfing would have being a nightmare on iphoneos) . Pyjamas, can make python available for iphone os as well (with no hacks or jailbroken phones), but with the obvious limitations since it translates python code to javascript, but still its a valid solution till Apple decide that excluding python from iphone os is a really bad idea. </p>

<p><a href="http://pyjs.org/" rel="nofollow">link text</a></p>

<p>There is no harm done in studying Objective C though. You can always use the native libraries via pyobjc. </p>

<p>But to be absolutely sincere with you, If my app reaches a dead end with the python libraries ( a very unlikely scenario) I would rather wrap an existing cross platform C/C++ Libraries with Cython than go the objective c pyobjc route and detroy the cross platform ability of my app. The last thing I would be using is anything platoform specifc.</p>

<p>Now if you dont care about other platforms at all, then I guess Objective C can be a valid choice. It certainly looks ugly as hell, but I have heard that it gets much better the more you use it and there are many people that prefer it over C/C++. </p>
<br />