<h3>Question (ID-891655):</h3><h2>Resources to learn Dynamic Programming, NP Complete, Knapsack Problems, and more on Algorithms</h2><p>What are the good resources that discuss Algorithms, P NP problems, Dynamic Programming, Special cases of those- Knapsack problems and such.</p>

<p>The resource must have working code, preferably in Python. Advantage if it explains some of the <a href="http://www.topcoder.com/" rel="nofollow">TopCoder</a> SRM Dynamic Programming questions.</p>

<p>PS: I am a web developer interested in algorithms and and am now trying to look into some formal and complete material on the subject.</p>

<p>Does <a href="http://mitpress.mit.edu/sicp/" rel="nofollow">SICP</a> discuss these?</p>
<br /><h3>Answers (Total-10):</h3><b>#0</b><br /><p>No, SICP wouldn't be the right place. It may mention them, but the best reference on this is <a href="http://rads.stackoverflow.com/amzn/click/0262032937" rel="nofollow">Introduction to Algorithms</a> which you may hear referred to as "CLR", though I guess now it's CLRS. No working code in this, just a pascal-like pseudocode.</p>
<br /><b>#1</b><br /><p>If you want a crash course in Dynamic Programming, try <a href="http://projecteuler.net/" rel="nofollow">Project Euler</a>... Problems <a href="http://projecteuler.net/index.php?section=problems&amp;id=208" rel="nofollow">208</a> and <a href="http://projecteuler.net/index.php?section=problems&amp;id=215" rel="nofollow">215</a> spring to mind as requiring DP. If you get hooked to it as most of us do, you'll find yourself learning more mathematics, algorithms and advanced programming than any formal course could provide you, and even better, having fun along the way. The best part is, once you solve a problem, you have access to other people solutions, and reading through them is extremly instructive.</p>

<p>And then of course you have wikipedia...</p>
<br /><b>#2</b><br /><p>Another resource you can look at is <strong>Algorithms</strong> by S. Dasgupta, C.H. Papadimitriou, and U.V. Vazirani.</p>

<p>It is a relatively recent book, and hence not one of the 'classics', but it is a good job of teaching algorithms from the ground up. The last few chapters look at "Dynamic Programming", "Linear programming and reductions", "NP-complete Search Problems" and "Coping with NP-completeness" - so exactly what you want. The code annotations are in pseudo-code, and are all cleanly reimplemented.</p>

<p>The primary advantage of this book is the authors distribute it's penultimate draft free on their site. I'm a new user and can't post hyperlinks, but google "algorithms vazirani" and it's the first and second link.</p>

<p>In regards to looking for working code "preferably in Python", I think that's the wrong approach, especially in algorithms. Implementing the algorithms yourself is a vital step in both learning the algorithm and feeling comfortable with the language. If you haven't yet worked out how the algorithm works, it's far better to actually look at the algorithm's steps rather than trying to find the algorithm's steps in the program's implementations.</p>

<p>After you learn these algorithms and techniques a great deal of the TopCoder problems can be sorted into a few sets, each expanding off of one idea or another. Once you're done with a more theoretical approach, you could move on to something like <strong>Programming Challenges</strong> by Steven S. Skiena and Miguel Revilla. It has a far briefer look at the algorithms themselves, instead focusing more on what sorts of competition problems can be solved by which of the standard algorithms. Almost always the solution to competition problems are re-imaginings or extensions of the original algorithms.</p>
<br /><b>#3</b><br /><p>If you don't restrict yourself to code only, the primary reference for NP is Garey and Johnson's Computers and Intractability: A Guide to the Theory of NP-Completeness</p>

<p><a href="http://rads.stackoverflow.com/amzn/click/0716710455" rel="nofollow">http://www.amazon.com/Computers-Intractability-NP-Completeness-Mathematical-Sciences/dp/0716710455</a></p>
<br /><b>#4</b><br /><p>Theoretical Side (P=NP?) : <a href="http://www-math.mit.edu/~sipser/book.html" rel="nofollow">Introduction to the Theory of Computation, Sipser</a></p>

<p>Algorithmic Side (Dynamic Programming et al.): <a href="http://mitpress.mit.edu/catalog/item/default.asp?tid=8570&amp;ttype=2" rel="nofollow">Introduction to Algrithms, Corment</a>
This is not python specific, but you can't ignore this. </p>
<br /><b>#5</b><br /><p>Well, you've binded together some different topics:</p>

<ol>
<li>Algorithms is a really huge topic, so I assume that you're talking about some basic background on that argument. The immortal Cormen should give you a good "introduction".</li>
<li>P, NP, etc. are elements of a complexity hierarchy. Those are subject of Computational Complexity, a fascinating and theoretically-intensive field of computer science. A formal training in those subject is a challenging job, because it's a mathematically rich area (the halting problem is a reformulation of the Goedel's incompleteness theorem...); I have to note that NP-hard and NP-complete is often used as a cool word to just say "it's difficult to solve in an efficient manner", not in their formal meaning...</li>
<li>The Knapsack problem is an optimization problem in the field of Operational Reseach. The Cormen book cover a little of that (huge) field.</li>
</ol>

<p>So, if you want a decent coverage of those things, you have to invest your time in three different (and vast) topics.</p>
<br /><b>#6</b><br /><p><a href="http://rads.stackoverflow.com/amzn/click/0321295358" rel="nofollow">Algorithm Design</a> by Kleinberg and Tardos is a very well written book, but uses pseudo code.</p>
<br /><b>#7</b><br /><p>Take an algorithm first. Skim what is it it about, and try to understand how it works (your own implementation might help). To check if you understood the matter you can solve a problem related to the topic. </p>

<p>For example, given the dynamic programming approach you can easily find the description of the  <a href="http://en.wikipedia.org/wiki/Longest_common_subsequence_problem#Code_for_the_dynamic_programming_solution" rel="nofollow">dynamic programming for the longest common subsequence problem</a> or some other <a href="http://en.wikipedia.org/wiki/Dynamic_programming#Algorithms_that_use_dynamic_programming" rel="nofollow">dynamic programming algorithms</a>.</p>

<p>Later on you can try some of problems (see at the <a href="http://spoj.pl" rel="nofollow">problems classifier</a> with dp keyword)
available to be solved and check by the online judge service (like <a href="http://spoj.pl" rel="nofollow">Sphere Online Judge</a>).</p>
<br /><b>#8</b><br /><p>I guess that if you are intrested in Dynamic Programming, you should look at Introduction to Algorithms.</p>

<p>But generally speaking, it is a technique in Optimization Theory/Operation Research areas.
There are more techniques such as Linear Programming, Interger Linear Programming etc.
If you are intrested in them, look for Introduction to Operation Research by H.Taha</p>
<br /><b>#9</b><br /><p>If you're not afraid of C/C++/Pascal, Solve every <a href="http://ace.delos.com/usacogate" rel="nofollow" title="USACO">USACO</a> problem in a row. It is designed to prepare students for Informatics Olympiads, what should give you great understanding of the most popular algorithms, data structures. The solutions are secret until you solve the problem, however you can easily google them if you want.</p>

<p>An alternative for USACO is UVa Online Judge. It accepts java as well as C/C++/Pascal and has a larger and newer set of problems. The disadvantage of it that the material is structured worse than in USACO. Also, last time I checked, it was slower and did not give helpful responses if the submission was incorrect.</p>

<p>If you like reading books instead solving stuff, you can try "Algorithm Design Manual", by S.Skiena, though examples there are basically in C. I like this book, because it also contains "War stories" - how algorithms are applied in real life, and a bunch of interview questions as well as basic maths required to understand the algorithms.</p>
<br />