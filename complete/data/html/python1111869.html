<h3>Question (ID-1111869):</h3><h2>What are quines? Any specific purpose to have them?</h2><p>I came across this term - Quine (also called self-reproducing programs). Just wanted to know more on it. How does one write a quine and are they used anywhere or they are just an exercise for fun?</p>

<p>I've started with Python, and I might try writing one in Python. Any suggestions?</p>
<br /><h3>Answers (Total-11):</h3><b>#0</b><br /><p>At a minimum, quines---programs which produce their own source as their output---are a necessary step in constructing <a href="http://en.wikipedia.org/wiki/G%C3%B6del%27s%5Fincompleteness%5Ftheorems" rel="nofollow">GÃ¶del's proof on incompleteness</a>.</p>

<p>Whether this constitutes a practical use is something I offer no comment on.</p>
<br /><b>#1</b><br /><p>Quines are useless in a practical sense, but they're a great exercise to help you learn more about a language.</p>

<p>Here's a very concise one in python:</p>

<pre><code>a='a=%r;print a%%a';print a%a
</code></pre>
<br /><b>#2</b><br /><blockquote>
  <p>A quine is a computer program which produces a copy of its own source code as its only output.</p>
</blockquote>

<p>I've yet to see a practical use for one but I'm sure there's one out there somewhere.</p>

<p><hr /></p>

<h2>Python Example (<a href="http://miscoranda.com/37" rel="nofollow">found here</a>)</h2>

<pre><code>print (lambda s:s+`s`+')')("print (lambda s:s+`s`+')')(")
</code></pre>

<p><hr /></p>

<h2>C Example (<a href="http://en.wikipedia.org/wiki/Quine%5F%28computing" rel="nofollow">found here</a>)</h2>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char** argv)
{
/* This macro B will expand to its argument, followed by a printf
 command that prints the macro invocation as a literal string */
#define B(x) x; printf("  B(" #x ")\n");

/* This macro A will expand to a printf command that prints the
 macro invocation, followed by the macro argument itself. */
#define A(x) printf("  A(" #x ")\n"); x;

/* Now we call B on the text of the program
 up to this point. It will execute the command, and then cause
 itself to be printed. */
  B(printf("#include &lt;stdio.h&gt;\n\nint main(int argc, char** argv)\n{\n/*
    This macro B will expand to its argument, followed by a printf\n
    command that prints the macro invocation as a literal string
    */\n#define B(x) x; printf(\"  B(\" #x \")\\n\");\n\n/* This macro
    A will expand to a printf command that prints the\n
    macro invocation, followed by the macro argument itself. */\n#define A(x)
    printf(\"  A(\" #x \")\\n\"); x;\n\n/* Now we call B on the text
    of the program\n up to this point. It will execute the command,
    and then cause\n itself to be printed. */\n"))
  A(printf("/* Lastly, we call A on a command to print the remainder
    of the program;\n it will cause itself to be printed, and then
    execute the command. */\n}\n"))
/* Lastly, we call A on a command to print the remainder of the program;
 it will cause itself to be printed, and then execute the command. */
}
</code></pre>
<br /><b>#3</b><br /><p>This is my favorite C example</p>

<pre><code>char*p="char*p=%c%s%c;main(){printf(p,34,p,34);}";main(){printf(p,34,p,34);}
</code></pre>

<p>Two things I learned from it:</p>

<ol>
<li>White space isn't required but does help readability</li>
<li>The prinftf function is really powerful</li>
</ol>
<br /><b>#4</b><br /><p>As others explained, quines are programs that reproduce exact copies of themselves.</p>

<p>With regards to applications, if you think that the DNA encodes logic to interpret itself and reproduce itself - the answer is pretty straightforward, without the concept of quines we wouldn't be here and we would never be able to create artificial (self-reproducing) life. </p>
<br /><b>#5</b><br /><p>I can't present any data to say that writing a quine or two has expanded my mind or made me a better programmer.  But it <em>is</em> fun to do, at least the first couple of times.  Anyway, you asked about how to write one.  I can point you to some well written references:</p>

<p>Craig Kaplan has a neat paper which describes how to actually produce quines:</p>

<ul>
<li><a href="http://www.cgl.uwaterloo.ca/~csk/washington/paper/" rel="nofollow">The Search For Self-Documenting Code</a>
<ul>
<li>This report examines the problem of writing a self-documenting program: a program that, when run, produces itself as output. The problem is examined from the point of view of self-reference, the property a self-documenting program must exhibit. The report proceeds from early programs that fail to work correctly, through successively sophisticated programs which approach a solution, to working self-documenting programs. Then it steps back a bit and shows how some programs can seem to cheat and still fit the definition of a self-documenting program, suggesting improvements to that definition. At each step, the report addresses how the given programs demonstrate the subtle relationship between computer programming and self-reference.</li>
</ul></li>
</ul>

<p>You might also find David Madore's <a href="http://www.madore.org/~david/computers/quine.html" rel="nofollow">"Quines (self-replicating programs)"</a> interesting reading.</p>

<p>Finally, if you want to see implementations, check out the <a href="http://www.nyx.net/~gthompso/quine.htm" rel="nofollow">Quine Page</a> where you can find quines in various languages and other related matter.</p>
<br /><b>#6</b><br /><p>See <a href="http://cm.bell-labs.com/who/ken/trust.html" rel="nofollow">Reflections on Trusting Trust</a> for an example of a trojan using a quine.</p>
<br /><b>#7</b><br /><p>Here's one in Python (it's ugly; I just wrote it to try it out). Didn't even know this was called a quine back then.</p>

<pre><code>def e(s): print s[:42]+s[42:].replace('#','"'); print 'e("""'+s+'""")'
e("""def e(s): print s[:42]+s[42:].replace('#','"'); print 'e(###'+s+'###)'""")
</code></pre>

<p>Oh, and to answer your other question: Quines are totally useless.</p>
<br /><b>#8</b><br /><p>What are quines used for? Programming exercises and viruses.</p>

<p>A virus needs to replicate somehow -- and one way is to make it a quine. Let's say that a hypothetical antivirus program would flag any process that read its own binary into memory (to pass it to the intended victim); the way to get around that would to have it output itself.</p>

<p>Bear in mind that a quine in machine code would require no compilation.</p>
<br /><b>#9</b><br /><p>Szymon Rusinkiewicz's quine (which was originally written in C) should work.</p>
<br /><b>#10</b><br /><p>This is an interesting quine in c++: <a href="http://npcomplete.weebly.com/1/post/2010/02/self-reproducing-c-program-quine.html" rel="nofollow">http://npcomplete.weebly.com/1/post/2010/02/self-reproducing-c-program-quine.html</a></p>

<p>Quines are for fun. They have no practical use as far as I know.</p>
<br />