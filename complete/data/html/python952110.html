<h3>Question (ID-952110):</h3><h2>Recursive Function palindrome in Python</h2><p>I need help writing a recursive function which detects whether a string is a palindrome. But i can't use any loops it must be recursive. Can anyone help show me how this is done. I need to learn this for an upcoming midterm. Im using Python.</p>
<br /><h3>Answers (Total-11):</h3><b>#0</b><br /><p>From a general algorithm perspective, the recursive function has 3 cases:</p>

<p>1) <strong>0 items left</strong>.  Item is a <a href="http://en.wikipedia.org/wiki/Palindrome" rel="nofollow">palindrome</a>, by identity.</p>

<p>2) <strong>1 item left</strong>.  Item is a <a href="http://en.wikipedia.org/wiki/Palindrome" rel="nofollow">palindrome</a>, by identity.</p>

<p>3) <strong>2 or more items</strong>.  Remove first and last item.  Compare.  If they are the same, call function on what's left of string.  If first and last are not the same, item is not a <a href="http://en.wikipedia.org/wiki/Palindrome" rel="nofollow">palindrome</a>.</p>

<p>The implementation of the function itself is left as an exercise to the reader :)</p>
<br /><b>#1</b><br /><pre><code>def ispalindrome(word):
    if len(word) &lt; 2: return True
    if word[0] != word[-1]: return False
    return ispalindrome(word[1:-1])
</code></pre>

<p>And here is the best one liner</p>

<pre><code>def ispalindrome(word):
    return word == word[::-1]
</code></pre>
<br /><b>#2</b><br /><p>If a string is zero or one letters long, it's a palindrome.</p>

<p>If a string has the first and last letters the same, and the remaining letters (I think it's a <code>[1: -1]</code> slice in Python, but my Python is a bit rusty) are a palindrome, it's a palindrome.</p>

<p>Now, write that as a palindrome function that takes a string.  It will call itself.</p>
<br /><b>#3</b><br /><p>Here's another viewpoint</p>

<p>A palindromic string is</p>

<ol>
<li><p>Some letter, <em>x</em>.</p></li>
<li><p>Some palindromic substrinng.</p></li>
<li><p>The same letter, <em>x</em>, repeated.</p></li>
</ol>

<p>Also, note that you may be given a proper English sentence "Able was I ere I saw Elba." with punctuation.  Your palindrome checker may have to quietly skip punctuation.  Also, you may have to quietly match without considering case.  This is slightly more complex.</p>

<ol>
<li><p>Some leading punctuation.  Some letter, <em>x</em>.</p></li>
<li><p>Some palindromic substring.</p></li>
<li><p>Some letter, <em>x</em>, repeated without regard to case.  Some trailing punctuation.</p></li>
</ol>

<p>And, by definition, a zero-length string is a palindrome.  Also a single-letter string (after removing punctuation) is a palindrome.</p>
<br /><b>#4</b><br /><p>Since we're posting code anyway, and no one-liner has been posted yet, here goes:</p>

<pre><code>def palindrome(s):
    return len(s) &lt; 2 or s[0] == s[-1] and palindrome(s[1:-1])
</code></pre>
<br /><b>#5</b><br /><p>The function should expect a string. If there is more then one letter in the string compare the first and the last letter. If 1 or 0 letters, return true. If the two letters are equal call the function then again with the string, without the first and the last letter. If they are not equal return false.</p>

<pre><code> palindrom( word):
   IF length of word 1 or 0 THEN
      return 0;
   IF last and first letter equal THEN
     word := remove first and last letter of word;
     palindrom( word);
   ELSE
     return false;
</code></pre>
<br /><b>#6</b><br /><p>Here's a way you can think of simple recursive functions... flip around the problem and think about it that way.  How do you make a palindrome recursively?  Here's how I would do it...</p>

<pre><code>def make_palindrome():
    maybe:
        return ""
    elsemaybe:
        return some_char()
    else:
        c = some_char()
        return c + make_palindrome() + c
</code></pre>

<p>Then you can flip it around to build the test.</p>
<br /><b>#7</b><br /><pre><code>n=raw_input("Enter a number===&gt;")
n=str(n)
l=len(n)
s=""
for i in range(1,l+1):
    s=s+n[l-i]
if s==n:
    print "Given number is polindrom"
else:
    print "Given number is not polindrom"
</code></pre>
<br /><b>#8</b><br /><pre><code>a=raw_input("enter the string:")
b=len(a)
c=0
for i in range(b):
    if a[i]==a[-(i+1)]:
        c=c+1
if c==b:
    print a,"is polindrome"
else:
    print a,"is not polindrome"
</code></pre>
<br /><b>#9</b><br /><p>My solution</p>

<pre><code>#To solve this I'm using the stride notation within a slice [::]
def amazonPalindrome(input):
    inputB = input
    input = input[::-1]
    #print input
    noPalindrome = inputB + " is not a palindrome"
    isPalindrome = inputB + " is a palindrome"
    #compare the value of the reversed string to input string
    if input[0]!= input[-1]: 
        print noPalindrome
    else:
        print isPalindrome


#invoking the def requires at least 1 value or else it fails
#tests include splitting the string,mixing integers, odd amount palindromes.
#call the def  
amazonPalindrome('yayay')
</code></pre>
<br /><b>#10</b><br /><p>Here is C version, if anyone happens to land here searching for C code!</p>

<pre><code>int IsPalindrome_Recursive(char *s, int start, int end)
{
    if ((end - start) &lt; 2)
    {
        return 1;
    }
    if (s[start] != s[end])
    {
        return 0;
    }
    return IsPalindrome_Recursive(s, ++start, --end);
}
</code></pre>

<p>Call as:</p>

<pre><code>IsPalindrome_Recursive(s, 0, strlen(s) - 1)
</code></pre>
<br />