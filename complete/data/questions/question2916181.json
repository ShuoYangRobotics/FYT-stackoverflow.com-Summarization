[{"text": ["What is the Pythonic way to implement a simple FSM?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Yesterday I had to parse a very simple binary data file - the rule is, look for two bytes in a row that are both 0xAA, then the next byte will be a length byte, then skip 9 bytes and output the given amount of data from there.", "Repeat to the end of the file."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["My solution did work, and was very quick to put together (even though I am a C programmer at heart, I still think it was quicker for me to write this in Python than it would have been in C) - BUT, it is clearly not at all Pythonic and it reads like a C program (and not a very good one at that!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["What would be a better / more Pythonic approach to this?", "Is a simple FSM like this even still the right choice in Python?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["My solution:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n #! /usr/bin/python\n\nimport sys\n\nf = open(sys.argv[1], \"rb\")\n\nstate = 0\n\nif f:\n    for byte in f.read():\n        a = ord(byte)       \n        if state == 0:\n            if a == 0xAA:\n                state = 1\n        elif state == 1:\n            if a  == 0xAA:\n                state = 2\n            else: \n                state = 0\n        elif state == 2:\n            count = a;\n            skip = 9\n            state = 3\n        elif state == 3:\n            skip = skip -1\n            if skip == 0:\n                state = 4\n        elif state == 4:\n             print \"%02x\" %a\n             count = count -1 \n             if count == 0:\n                 state = 0\n                 print \"\\r\\n\"\n</code>\n</pre>\n", "senID": 5}]