[{"text": ["Python: efficiently check if integer is within *many* ranges"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I am working on a postage application which is required to check an integer postcode against a number of postcode ranges, and return a different code based on which range the postcode matches against."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Each code has more than one postcode range.", "For example, the M code should be returned if the postcode is within the ranges 1000-2429, 2545-2575, 2640-2686 or is equal to 2890."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "M", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["I could write this as:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n if 1000 &lt;= postcode &lt;= 2429 or 2545 &lt;= postcode &lt;= 2575 or 2640 &lt;= postcode &lt;= 2686 or postcode == 2890:\n    return 'M'\n</code>\n</pre>\n", "senID": 4}, {"text": ["but this seems like a lot of lines of code, given that there are 27 returnable codes and 77 total ranges to check against.", "Is there a more efficient (and preferably more concise) method of matching an integer to all these ranges using Python?"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Edit: There's a lot of excellent solutions flying around, so I have implemented all the ones that I could, and benchmarked their performances."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["The environment for this program is a web service (Django-powered actually) which needs to check postcode region codes one-by-one, on the fly.", "My preferred implementation, then, would be one that can be quickly used for each request, and does not need any process to be kept in memory, or needs to process many postcodes in bulk."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["I tested the following solutions using timeit.Timer with default 1000000 repetitions using randomly generated postcodes each time."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "timeit.Timer", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if 1000 &lt;= postcode &lt;= 2249 or 2555 &lt;= postcode &lt;= 2574 or ...:\n    return 'M'\nif 2250 &lt;= postcode &lt;= 2265 or ...:\n    return 'N'\n...\n</code>\n</pre>\n", "senID": 9}, {"text": ["Time for 1m reps: 5.11 seconds."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Somewhat more elegant to my mind and certainly easier to enter and read the ranges.", "Particularly good if they change over time, which is possible.", "But it did end up four times slower in my implementation."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n if any(lower &lt;= postcode &lt;= upper for (lower, upper) in [(1000, 2249), (2555, 2574), ...]):\n    return 'M'\nif any(lower &lt;= postcode &lt;= upper for (lower, upper) in [(2250, 2265), ...]):\n    return 'N'\n...\n</code>\n</pre>\n", "senID": 12}, {"text": ["Time for 1m reps: 19.61 seconds."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["As stated by the author, \"it's only better if you are building the set once to check against many postcodes in a loop\".", "But I thought I would test it anyway to see."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n if postcode in set(chain(*(xrange(start, end+1) for start, end in ((1000, 2249), (2555, 2574), ...)))):\n    return 'M'\nif postcode in set(chain(*(xrange(start, end+1) for start, end in ((2250, 2265), ...)))):\n    return 'N'\n...\n</code>\n</pre>\n", "senID": 15}, {"text": ["Time for 1m reps: 339.35 seconds."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["This one may have been a bit above my intellect level.", "I learnt a lot reading about the bisect module but just couldn't quite work out which parameters to give find_ge() to make a runnable test.", "I expect that it would be extremely fast with a loop of many postcodes, but not if it had to do the setup each time.", "So, with 1m repetitions of filling numbers, edgepairs, edgeanswers etc for just one postal region code (the M code with four ranges), but not actually running the fast_solver:"], "childNum": 7, "tag": "p", "senID": 17, "childList": [{"text": "bisect", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "find_ge()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "numbers", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "edgepairs", "childNum": 0, "tag": "code", "childList": []}, {"text": "edgeanswers", "childNum": 0, "tag": "code", "childList": []}, {"text": "M", "childNum": 0, "tag": "strong", "childList": []}, {"text": "fast_solver", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Time for 1m reps: 105.61 seconds."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["Using one dict per postal region code pre-generated, cPickled in a source file (106 KB), and loaded for each run.", "I was expecting much better performance from this method, but on my system at least, the IO really destroyed it.", "The server is a not-quite-blindingly-fast-top-of-the-line Mac Mini."], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["Time for 1m reps: 5895.18 seconds (extrapolated from a 10,000 run)."], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"text": ["The summary"], "childNum": 0, "tag": "h2", "senID": 21, "childList": []}, {"text": ["Well, I was expecting someone to just give a simple 'duh' answer that I hadn't considered, but it turns out this is much more complicated (and even a little controversial)."], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"text": ["If every nanosecond of efficiency counted in this case, I would probably keep a separate process running which implemented one of the binary search or dict solutions and kept the result in memory for an extremely fast lookup.", "However, since the IF tree takes only five seconds to run a million times, which is plenty fast enough for my small business, that's what I'll end up using in my application."], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"text": ["Thank you to everyone for contributing!"], "childNum": 0, "tag": "p", "senID": 24, "childList": []}]