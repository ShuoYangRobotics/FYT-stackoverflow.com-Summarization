[{"text": ["Independent function or method"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I need to deal with a two objects of a class in a way that will return a third object of the same class, and I am trying to determine whether it is better to do this as an independent function that receives two objects and returns the third or as a method which would take one other object and return the third."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For a simple example.", "Would this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from collections import namedtuple\n\nclass Point(namedtuple('Point', 'x y')):\n    __slots__ = ()\n    #Attached to class\n    def midpoint(self, otherpoint):\n        mx = (self.x + otherpoint.x) / 2.0\n        my = (self.y + otherpoint.y) / 2.0\n        return Point(mx, my)\n\na = Point(1.0, 2.0)\nb = Point(2.0, 3.0)\n\nprint a.midpoint(b)\n#Point(x=1.5, y=2.5)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from collections import namedtuple\n\nclass Point(namedtuple('Point', 'x y')):\n    __slots__ = ()\n\n\n#not attached to class\n#takes two point objects\ndef midpoint(p1, p2):\n    mx = (p1.x + p2.x) / 2.0\n    my = (p1.y + p2.y) / 2.0\n    return Point(mx, my)\n\n\na = Point(1.0, 2.0)\nb = Point(2.0, 3.0)\n\nprint midpoint(a, b)\n#Point(x=1.5, y=2.5)\n</code>\n</pre>\n", "senID": 5}, {"text": ["and why would one be preferred over the other?"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["This seems far less clear cut than I had expected when I asked the question."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["In summary, it seems that something like a.midpoint(b) is not preferred since it seems to give a special place to one point or another in what is really a symmetric function that returns a completely new point instance.", "But it seems to be largely a matter of taste and style between something like a freestanding module function or a function attached to the class, but not meant to be called by the insance, such as Point.midpoint(a, b)."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["I think, personally, I stylistically lean towards free-standing module functions, but it may depend on the circumstances.", "In cases where the function is definitely tightly bound to the class and there is any risk of namespace pollution or potential confusion, then making a class function probably makes more sense."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Also, a couple of people mentioned making the function more general, perhaps by implementing additional features of the class to support this.", "In this particular case dealing with points and midpoints, that is probably the overall best approach.", "It supports polymorphism and code reuse and is highly readable.", "In a lot of cases though, that would not work (the project that inspired me to ask this for instance), but points and midpoints seemed like a concise and understandable example to illustrate the question."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Thank you all, it was enlightening."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}]