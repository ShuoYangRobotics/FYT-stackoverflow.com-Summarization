[{"text": ["Distribute points on a circle as evenly as possible"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Problem statement"], "childNum": 0, "tag": "h2", "senID": 1, "childList": []}, {"text": ["I have the following problem: I have a circle with a certain number (zero or more) of points on it.", "These positions are fixed.", "Now I have to position another set of points on the circle, such as all points together are as evenly distributed around the circle as possible."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Goal"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"text": ["My goal is now to develop a algorithm taking a list of angles (representing the fixed points) and an int value (representing how many additional points should be placed) and returning a list of angles again (containing only the angles where the additional points should lie). "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The points dont have to be really evenly distributed (all same distance from each other), but rather as evenly as it is just possible.", "A perfect solution may not exist most of the time, as certain points are fixed."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The range of all angles lie in between -pi and +pi."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Examples"], "childNum": 0, "tag": "h2", "senID": 7, "childList": []}, {"text": ["Some examples of what I am trying to archieve:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n fixed_points = [-pi, -pi/2, pi/2]\n\n v         v                   v\n |---------|---------|---------|---------|\n-pi     -pi/2        0        pi/2       pi\n\nfill_circle(fixed_points, 1)\n# should return: [0]\n\nfill_circle(fixed_points, 2)\n# should return: [-pi/6, pi/6]\n</code>\n</pre>\n", "senID": 9}, {"text": ["or:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n fixed_points = [-pi, -pi*3/4, -pi/4]\n\n v    v         v\n |---------|---------|---------|---------|\n-pi     -pi/2        0        pi/2       pi\n\nfill_circle(fixed_points, 6)\n</code>\n</pre>\n", "senID": 11}, {"text": ["This last example should return something like: One point is to set right in between -pi*3/4 and -pi/4, that is: -pi/2 and distribute the other 5 points between -pi/4 and +pi (remember it is a circle, so in this case -pi = +pi):"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n v    v    x    v   x   x    x   x    x\n |---------|---------|---------|---------|\n-pi     -pi/2        0        pi/2       pi\n</code>\n</pre>\n", "senID": 13}, {"text": ["Previous try"], "childNum": 0, "tag": "h2", "senID": 14, "childList": []}, {"text": ["I started with a recursive algorithm that first searches for the largest interval between two points and sets the new point right in between.", "However it doesnt give satisfying results.", "Consider for example this configuration, with two points needed to be inserted:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n v         v                   v\n |---------|---------|---------|---------|\n-pi     -pi/2        0        pi/2       pi\n\nfirst step: insert right in the middle of largest interval\n v         v         x         v\n |---------|---------|---------|---------|\n-pi     -pi/2        0        pi/2       pi\n\nsecond step: insert right in the middle of largest interval \n-&gt; all intervals are evenly large, so one of them will be taken\n v    x    v         v         v\n |---------|---------|---------|---------|\n-pi     -pi/2        0        pi/2       pi\n</code>\n</pre>\n", "senID": 16}, {"text": ["Not a very nice solution, as it could have been much better distributed (see above: -pi/6 and +pi/6)."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["Sorry for the long question, I hope you understand what I want to archieve."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["I dont need a complete working algorithm, but rather the right idea for developing one.", "Maybe some pseudocode if you like.", "Would be very grateful for some hints to push me in the right direction.", "Thanks in advance!"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["Update: Completed algorithm:"], "childNum": 0, "tag": "h2", "senID": 20, "childList": []}, {"text": ["Thank you all for your answers!", "It showed up I basically just needed a non-greedy version of my already existing algorithm.", "I really liked haydenmuhls idea to simplify the problem a little bit by encapsulating an interval/segment class:"], "childNum": 1, "tag": "p", "senID": 21, "childList": [{"text": "haydenmuhls", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/374953/haydenmuhl"}]}, {"code": "<pre>\n<code>\n class Segment:\n    def __init__(self, angle, prev_angle, wrap_around):\n        self.angle = angle\n        self.length = abs(angle - prev_angle + \\\n                          (2*math.pi if wrap_around else 0))\n        self.num_points = 0\n\n    def sub_length(self):\n        return self.length / (self.num_points + 1)\n\n    def next_sub_length(self):\n        return self.length / (self.num_points + 2)\n\n    def add_point(self):\n        self.num_points += 1\n</code>\n</pre>\n", "senID": 22}, {"text": ["This makes the actual algorithm incredibly easy and readable:"], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"code": "<pre>\n<code>\n def distribute(angles, n):\n    # No points given? Evenly distribute them around the circle\n    if len(angles) == 0:\n        return [2*math.pi / n * i - math.pi for i in xrange(n)]\n\n    # Sort the angles and split the circle into segments\n    s, pi, ret = sorted(angles), math.pi, []\n    segments = [Segment(s[i], s[i-1], i == 0) for i in xrange(len(s))]\n\n    # Calculate the length of all subsegments if the point\n    # would be added; take the largest to add the point to\n    for _ in xrange(n):\n        max(segments, key = lambda x: x.next_sub_length()).add_point()\n\n    # Split all segments and return angles of the points\n    for seg in segments:\n        for k in xrange(seg.num_points):\n            a = seg.angle - seg.sub_length() * (k + 1)\n            # Make sure all returned values are between -pi and +pi\n            ret.append(a - 2*pi if a &gt; pi else a + 2*pi if a &lt; -pi else a)\n\n    return ret\n</code>\n</pre>\n", "senID": 24}]