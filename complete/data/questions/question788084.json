[{"text": ["How can I optimize this Python code?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Profiling shows this is the slowest segment of my code for a little word game I wrote:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def distance(word1, word2):\n    difference = 0\n    for i in range(len(word1)):\n        if word1[i] != word2[i]:\n            difference += 1\n    return difference\n\ndef getchildren(word, wordlist):\n    return [ w for w in wordlist if distance(word, w) == 1 ]\n</code>\n</pre>\n", "senID": 2}, {"text": ["\"distance\" is called over 5 million times, majority of which is from getchildren, which is supposed to get all words in the wordlist that differ from \"word\" by exactly 1 letter."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I'm fairly new to Python (started learning it 3 days ago) so comments on naming conventions or other style things also appreciated."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Edit: Forgot to mention that wordlist is pre-filtered to only have words containing the same number of letters as \"word\" so it's guaranteed that \"word1\" and \"word2\" have the same number of chars."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Results:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Thanks everyone, with combinations of different suggestions I got the program running twice as fast now (on top of the optimizations I did on my own before asking, so 4 times speed increase approx from my initial implementation)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["I tested with 2 sets of inputs which I'll call A and B\nOptimization1:\nFrom"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n for i in range(len(word1)):\n        if word1[i] != word2[i]:\n            difference += 1\n    return difference\n</code>\n</pre>\n", "senID": 9}, {"text": ["to"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n for x,y in zip (word1, word2):\n        if x != y:\n            difference += 1\n    return difference\n</code>\n</pre>\n", "senID": 11}, {"text": ["Got execution time from 11.92 to 9.18 for input A, and 79.30 to 74.59 for input B"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Optimization2:\nAdded a separate method for differs by one in addition to the distance method (which I still needed elsewhere for the A* heuristics)"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n def is_neighbors(word1,word2):\n    different = False\n    for c1,c2 in zip(word1,word2):\n        if c1 != c2:\n            if different:\n                return False\n            different = True\n    return different\n</code>\n</pre>\n", "senID": 14}, {"text": ["Got execution time from 9.18 to 8.83 for input A, and 74.59 to 70.14 for input B"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["Optimization3:\nBig winner here was to use izip instead of zip"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["Got execution time from 8.83 to 5.02 for input A, and 70.14 to 41.69 for input B"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["I could probably do better writing it in a lower level language, but I'm happy with this for now.", "Thanks everyone!"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["Edit again: More results\nUsing Mark's method of checking the case where the first letter doesn't match got it down from 5.02 -> 3.59 and 41.69 -> 29.82"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["Building on that and incorporating izip instead of range, I ended up with this:"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"code": "<pre>\n<code>\n def is_neighbors(word1,word2):\n    if word1[0] != word2[0]:\n        return word1[1:] == word2[1:]\n    different = False\n    for x,y in izip(word1[1:],word2[1:]):\n        if x != y:\n            if different:\n                return False\n            different = True\n    return different\n</code>\n</pre>\n", "senID": 21}, {"text": ["Which squeezed a little bit more, bringing the times down from 3.59 -> 3.38 and 29.82 -> 27.88"], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"text": ["Even more results!"], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"text": ["Trying Sumudu's suggestion that I generate a list of all strings that are 1 letter off from \"word\" and then checking to see which ones were in the wordlist, instead of the is_neighbor function I ended up with this:"], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"code": "<pre>\n<code>\n def one_letter_off_strings(word):\n    import string\n    dif_list = []\n    for i in xrange(len(word)):\n        dif_list.extend((word[:i] + l + word[i+1:] for l in string.ascii_lowercase if l != word[i]))\n    return dif_list\n\ndef getchildren(word, wordlist):\n    oneoff = one_letter_off_strings(word)\n    return ( w for w in oneoff if w in wordlist )\n</code>\n</pre>\n", "senID": 25}, {"text": ["Which ended up being slower (3.38 -> 3.74 and 27.88 -> 34.40) but it seemed promising.", "At first I thought the part I'd need to optimize was \"one_letter_off_strings\" but profiling showed otherwise and that the slow part was in fact "], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"code": "<pre>\n<code>\n ( w for w in oneoff if w in wordlist )\n</code>\n</pre>\n", "senID": 27}, {"text": ["I thought if there'd be any difference if I switched \"oneoff\" and \"wordlist\" and did the comparison the other way when it hit me that I was looking for the intersection of the 2 lists.", "I replace that with:"], "childNum": 0, "tag": "p", "senID": 28, "childList": []}, {"code": "<pre>\n<code>\n return set(oneoff) &amp; set(wordlist)\n</code>\n</pre>\n", "senID": 29}, {"text": ["Bam!", "3.74 -> 0.23 and 34.40 -> 2.25"], "childNum": 0, "tag": "p", "senID": 30, "childList": []}, {"text": ["This is truely amazing, total speed difference from my original naive implementation:\n23.79 -> 0.23 and 180.07 -> 2.25, so approx 80 to 100 times faster than the original implementation."], "childNum": 0, "tag": "p", "senID": 31, "childList": []}, {"text": ["If anyone is interested, I made blog post describing the program and describing the optimizations made including one that isn't mentioned here (because it's in a different section of code)."], "childNum": 2, "tag": "p", "senID": 32, "childList": [{"text": "describing the program", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://davy8.wordpress.com/2009/04/25/detour-into-python-and-optimizations/"}, {"href": "http://davy8.wordpress.com/2009/04/26/detour-into-python-and-optimizations-part-2/", "text": "describing the optimizations", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["The Great Debate:"], "childNum": 1, "tag": "p", "senID": 33, "childList": [{"text": "The Great Debate:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Ok, me and Unknown are having a big debate which you can read in the comments of his answer.", "He claims that it would be faster using the original method (using is_neighbor instead of using the sets) if it was ported to C.  I tried for 2 hours to get a C module I wrote to build and be linkable without much success after trying to follow this and this example, and it looks like the process is a little different in Windows?", "I don't know, but I gave up on that.", "Anyway, here's the full code of the program, and the text file come from the 12dict word list using the \"2+2lemma.txt\" file.", "Sorry if the code's a little messy, this was just something I hacked together.", "Also I forgot to strip out commas from the wordlist so that's actually a bug that you can leave in for the sake of the same comparison or fix it by adding a comma to the list of chars in cleanentries."], "childNum": 4, "tag": "p", "senID": 34, "childList": [{"text": "his answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/788084/how-can-i-optimize-this-python-code/788090#788090"}, {"text": "this", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://superjared.com/entry/anatomy-python-c-module/"}, {"text": "this", "tag": "a", "pos": 4, "childList": [], "childNum": 0, "href": "http://www.dalkescientific.com/writings/NBN/c%5Fextensions.html"}, {"text": "12dict word list", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://downloads.sourceforge.net/wordlist/12dicts-5.0.zip"}]}, {"code": "<pre>\n<code>\n from itertools import izip\ndef unique(seq):  \n    seen = {} \n    result = [] \n    for item in seq: \n        if item in seen:\n            continue \n        seen[item] = 1 \n        result.append(item) \n    return result\ndef cleanentries(li):\n    pass\n    return unique( [w.strip('[]') for w in li if w != \"-&gt;\"] )\ndef distance(word1, word2):\n    difference = 0\n    for x,y in izip (word1, word2):\n        if x != y:\n            difference += 1\n    return difference\ndef is_neighbors(word1,word2):\n    if word1[0] != word2[0]:\n        return word1[1:] == word2[1:]\n    different = False\n    for x,y in izip(word1[1:],word2[1:]):\n        if x != y:\n            if different:\n                return False\n            different = True\n    return different\ndef one_letter_off_strings(word):\n    import string\n    dif_list = []\n    for i in xrange(len(word)):\n        dif_list.extend((word[:i] + l + word[i+1:] for l in string.ascii_lowercase if l != word[i]))\n    return dif_list\n\ndef getchildren(word, wordlist):\n    oneoff = one_letter_off_strings(word)\n    return set(oneoff) &amp; set(wordlist)\ndef AStar(start, goal, wordlist):\n    import Queue\n    closedset = []\n    openset = [start]\n    pqueue = Queue.PriorityQueue(0)\n    g_score = {start:0}         #Distance from start along optimal path.\n    h_score = {start:distance(start, goal)}\n    f_score = {start:h_score[start]}\n    pqueue.put((f_score[start], start))\n    parent_dict = {}\n    while len(openset) &gt; 0:\n        x = pqueue.get(False)[1]\n        if x == goal:\n            return reconstruct_path(parent_dict,goal)\n        openset.remove(x)\n        closedset.append(x)\n        sortedOpen = [(f_score[w], w, g_score[w], h_score[w]) for w in openset]\n        sortedOpen.sort()\n        for y in getchildren(x, wordlist):\n            if y in closedset:\n                continue\n            temp_g_score = g_score[x] + 1\n            temp_is_better = False\n            appended = False\n            if (not y in openset): \n                openset.append(y)\n                appended = True\n                h_score[y] = distance(y, goal)\n                temp_is_better = True\n            elif temp_g_score &lt; g_score[y] :\n                temp_is_better = True\n            else :\n                pass\n            if temp_is_better:\n                parent_dict[y] = x\n                g_score[y] = temp_g_score\n                f_score[y] = g_score[y] + h_score[y]\n                if appended :\n                    pqueue.put((f_score[y], y))\n    return None\n\n\ndef reconstruct_path(parent_dict,node):\n     if node in parent_dict.keys():\n         p = reconstruct_path(parent_dict,parent_dict[node])\n         p.append(node)\n         return p\n     else:\n         return []        \n\nwordfile = open(\"2+2lemma.txt\")\nwordlist = cleanentries(wordfile.read().split())\nwordfile.close()\nwords = []\nwhile True:\n    userentry = raw_input(\"Hello, enter the 2 words to play with separated by a space:\\n \")\n    words = [w.lower() for w in userentry.split()]\n    if(len(words) == 2 and len(words[0]) == len(words[1])):\n        break\nprint \"You selected %s and %s as your words\" % (words[0], words[1])\nwordlist = [ w for w in wordlist if len(words[0]) == len(w)]\nanswer = AStar(words[0], words[1], wordlist)\nif answer != None:\n    print \"Minimum number of steps is %s\" % (len(answer))\n    reply = raw_input(\"Would you like the answer(y/n)? \")\n    if(reply.lower() == \"y\"):\n        answer.insert(0, words[0])\n        print \"\\n\".join(answer)\n    else:\n        print \"Good luck!\"\nelse:\n    print \"Sorry, there's no answer to yours\"\nreply = raw_input(\"Press enter to exit\")\n</code>\n</pre>\n", "senID": 35}, {"text": ["I left the is_neighbors method in even though it's not used.", "This is the method that is proposed to be ported to C.  To use it, just replace getchildren with this:"], "childNum": 0, "tag": "p", "senID": 36, "childList": []}, {"code": "<pre>\n<code>\n def getchildren(word, wordlist):\n    return ( w for w in wordlist if is_neighbors(word, w))\n</code>\n</pre>\n", "senID": 37}, {"text": ["As for getting it to work as a C module I didn't get that far, but this is what I came up with:"], "childNum": 0, "tag": "p", "senID": 38, "childList": []}, {"code": "<pre>\n<code>\n #include \"Python.h\"\n\nstatic PyObject *\npy_is_neighbor(PyObject *self, Pyobject *args)\n{\n    int length;\n    const char *word1, *word2;\n    if (!PyArg_ParseTuple(args, \"ss\", &amp;word1, &amp;word2, &amp;length))\n        return NULL;\n\n    int i;\n    int different = 0;\n    for (i =0; i &lt; length; i++)\n    {\n        if (*(word1 + i) != *(word2 + i))\n        {\n            if (different)\n            {\n                return Py_BuildValue(\"i\", different);\n            }\n            different = 1;\n        }\n    }\n    return Py_BuildValue(\"i\", different);\n}\n\nPyMethodDef methods[] = {\n    {\"isneighbor\", py_is_neighbor, METH_VARARGS, \"Returns whether words are neighbors\"},\n    {NULL, NULL, 0, NULL}\n};\n\nPyMODINIT_FUNC\ninitIsNeighbor(void)\n{\n    Py_InitModule(\"isneighbor\", methods);\n}\n</code>\n</pre>\n", "senID": 39}, {"text": ["I profiled this using:"], "childNum": 0, "tag": "p", "senID": 40, "childList": []}, {"text": ["And the time recorded was the total time of the AStar method call.", "The fast input set was \"verse poets\" and the long input set was \"poets verse\".", "Timings will obviously vary between different machines, so if anyone does end up trying this give result comparison of the program as is, as well as with the C module."], "childNum": 0, "tag": "p", "senID": 41, "childList": []}]