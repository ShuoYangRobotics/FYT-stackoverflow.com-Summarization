[{"text": ["How to handle constructors or methods with a different set (or type) of arguments in Python?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Is there a way in Python, to have more than one constructor or more than one method with the same name, who differ in the number of arguments they accept or the type(s) of one or more argument(s)?"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "same name", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "number of arguments", "childNum": 0, "tag": "em", "childList": []}, {"text": "type(s) of one or more argument(s)", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["If not, what would be the best way to handle such situations?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For an example I made up a color class.", "This class should only work as a basic example to discuss this, there is lot's of unnecessary and/or redundant stuff in there."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "This class should only work as a basic example to discuss this", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["It would be nice, if I could call the constructor with different objects (a list, an other color object or three integers...) and the constructor handles them accordingly.", "In this basic example it works in some cases with * args and * * kwargs, but using class methods is the only general way I came up with.", "What would be a \"best practice\" like solution for this?"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "best practice", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["The constructor aside, if I would like to implement an _ _ add _ _ method too, how can I get this method to accept all of this: A plain integer (which is added to all values), three integers (where the first is added to the red value and so forth) or another color object (where both red values are added together, etc.", ")?"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "add", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["EDIT"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 6, "lis": [{"text": ["I added an alternative constructor (initializer, _ _ init _ _) that basicly does all the stuff I wanted."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "alternative", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "init", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["But I stick with the first one and the factory methods.", "Seems clearer."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["I also added an _ _ add _ _, which does all the things mentioned above but I'm not sure if it's good style.", "I try to use the iteration protocol and fall back to \"single value mode\" instead of checking for specific types.", "Maybe still ugly tho."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "add", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "good style", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["I have taken a look at _ _ new _ _, thanks for the links."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "new", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["My first quick try with it fails: I filter the rgb values from the * args and * * kwargs (is it a class, a list, etc.", ") then call the superclass's _ _ new _ _ with the right args (just r,g,b) to pass it along to init.", "The call to the 'Super(cls, self)._ _ new _ _ (....)' works, but since I generate and return the same object as the one I call from (as intended), all the original args get passed to _ _ init _ _ (working as intended), so it bails. "], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["I could get rid of the _ _ init _ _ completly and set the values in the _ _ new _ _ but I don't know... feels like I'm abusing stuff here ;-) I should take a good look at metaclasses and new first I guess."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}]}, {"text": ["Source:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\nclass Color (object):\n\n  # It's strict on what to accept, but I kinda like it that way.\n  def __init__(self, r=0, g=0, b=0):\n    self.r = r\n    self.g = g\n    self.b = b\n\n  # Maybe this would be a better __init__?\n  # The first may be more clear but this could handle way more cases...\n  # I like the first more though. What do you think?\n  #\n  #def __init__(self, obj):\n  #  self.r, self.g, self.b = list(obj)[:3]\n\n  # This methods allows to use lists longer than 3 items (eg. rgba), where\n  # 'Color(*alist)' would bail\n  @classmethod\n  def from_List(cls, alist):\n    r, g, b = alist[:3]\n    return cls(r, g, b)\n\n  # So we could use dicts with more keys than rgb keys, where\n  # 'Color(**adict)' would bail\n  @classmethod\n  def from_Dict(cls, adict):\n    return cls(adict['r'], adict['g'], adict['b'])\n\n  # This should theoreticaly work with every object that's iterable.\n  # Maybe that's more intuitive duck typing than to rely on an object\n  # to have an as_List() methode or similar.\n  @classmethod\n  def from_Object(cls, obj):\n    return cls.from_List(list(obj))\n\n  def __str__(self):\n    return \"&lt;Color(%s, %s, %s)&gt;\" % (self.r, self.g, self.b)\n\n  def _set_rgb(self, r, g, b):\n    self.r = r\n    self.g = g\n    self.b = b\n  def _get_rgb(self):\n    return  (self.r, self.g, self.b)\n  rgb = property(_get_rgb, _set_rgb)\n\n  def as_List(self):\n    return [self.r, self.g, self.b]\n\n  def __iter__(self):\n    return (c for c in (self.r, self.g, self.b))\n\n  # We could add a single value (to all colorvalues) or a list of three\n  # (or more) values (from any object supporting the iterator protocoll)\n  # one for each colorvalue\n  def __add__(self, obj):\n    r, g, b = self.r, self.g, self.b\n    try:\n      ra, ga, ba = list(obj)[:3]\n    except TypeError:\n      ra = ga = ba = obj\n    r += ra\n    g += ga\n    b += ba\n    return Color(*Color.check_rgb(r, g, b))\n\n  @staticmethod\n  def check_rgb(*vals):\n    ret = []\n    for c in vals:\n      c = int(c)\n      c = min(c, 255)\n      c = max(c, 0)\n      ret.append(c)\n    return ret\n\nclass ColorAlpha(Color):\n\n  def __init__(self, r=0, g=0, b=0, alpha=255):\n    Color.__init__(self, r, g, b)\n    self.alpha = alpha\n\n  def __str__(self):\n    return \"&lt;Color(%s, %s, %s, %s)&gt;\" % (self.r, self.g, self.b, self.alpha)\n\n  # ...\n\nif __name__ == '__main__':\n  l = (220, 0, 70)\n  la = (57, 58, 61, 255)\n  d = {'r': 220, 'g': 0, 'b':70}\n  da = {'r': 57, 'g': 58, 'b':61, 'a':255}\n  c = Color(); print c # &lt;Color(0, 0, 0)&gt;\n  ca = ColorAlpha(*la); print ca # &lt;Color(57, 58, 61, 255)&gt;\n  print '---'\n  c = Color(220, 0, 70); print c # &lt;Color(220, 0, 70)&gt;\n  c = Color(*l); print c # &lt;Color(220, 0, 70)&gt;\n  #c = Color(*la); print c # -&gt; Fail\n  c = Color(**d); print c # &lt;Color(220, 0, 70)&gt;\n  #c = Color(**da); print c # -&gt; Fail\n  print '---'\n  c = Color.from_Object(c); print c # &lt;Color(220, 0, 70)&gt;\n  c = Color.from_Object(ca); print c # &lt;Color(57, 58, 61, 255)&gt;\n  c = Color.from_List(l); print c # &lt;Color(220, 0, 70)&gt;\n  c = Color.from_List(la); print c # &lt;Color(57, 58, 61, 255)&gt;\n  c = Color.from_Dict(d); print c # &lt;Color(220, 0, 70)&gt;\n  c = Color.from_Dict(da); print c # &lt;Color(57, 58, 61, 255)&gt;\n  print '---'\n  print 'Check =', Color.check_rgb('1', 0x29a, -23, 40)\n  # Check = [1, 255, 0, 40]\n  print '%s + %s = %s' % (c, 10, c + 10)\n  # &lt;Color(57, 58, 61)&gt; + 10 = &lt;Color(67, 68, 71)&gt;\n  print '%s + %s = %s' % (c, ca, c + ca)\n  # &lt;Color(57, 58, 61)&gt; + &lt;Color(57, 58, 61, 255)&gt; = &lt;Color(114, 116, 122)&gt;\n</code>\n</pre>\n", "senID": 14}]