[{"text": ["floating point equality in Python and in general"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I have a piece of code that behaves differently depending on whether I go through a dictionary to get conversion factors or whether I use them directly."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The following piece of code will print 1.0 == 1.0 -&gt; False"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "1.0 == 1.0 -&gt; False", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["But if you replace factors[units_from] with 10.0 and factors[units_to  ] with 1.0 / 2.54 it will print 1.0 == 1.0 -&gt; True"], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "factors[units_from]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "10.0", "childNum": 0, "tag": "code", "childList": []}, {"text": "factors[units_to  ]", "childNum": 0, "tag": "code", "childList": []}, {"text": "1.0 / 2.54", "childNum": 0, "tag": "code", "childList": []}, {"text": "1.0 == 1.0 -&gt; True", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nbase = 'cm'\nfactors = {\n    'cm'        : 1.0,\n    'mm'        : 10.0,\n    'm'         : 0.01,\n    'km'        : 1.0e-5,\n    'in'        : 1.0 / 2.54,\n    'ft'        : 1.0 / 2.54 / 12.0,\n    'yd'        : 1.0 / 2.54 / 12.0 / 3.0,\n    'mile'      : 1.0 / 2.54 / 12.0 / 5280,\n    'lightyear' : 1.0 / 2.54 / 12.0 / 5280 / 5.87849981e12,\n}\n\n# convert 25.4 mm to inches\nval = 25.4\nunits_from = 'mm'\nunits_to = 'in'\n\nbase_value = val / factors[units_from]\nret = base_value * factors[units_to  ]\nprint ret, '==', 1.0, '-&gt;', ret == 1.0\n</code>\n</pre>\n", "senID": 4}, {"text": ["Let me first say that I am pretty sure what is going on here.", "I have seen it before in C, just never in Python but since Python in implemented in C we're seeing it."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I know that floating point numbers will change values going from a CPU register to cache and back.", "I know that comparing what should be two equal variables will return false if one of them was paged out while the other stayed resident in a register."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Questions"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Questions", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "What is the best way to avoid problems like this?... In Python or in general.", "tag": "none", "senID": 8}, {"text": "Am I doing something completely wrong?", "tag": "none", "senID": 9}]}, {"text": ["Side Note"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Side Note", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This is obviously part of a stripped down example but what I'm trying to do is come with with classes of length, volume, etc that can compare against other objects of the same class but with different units."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Rhetorical Questions"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "Rhetorical Questions", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "If this is a potentially dangerous problem since it makes programs behave in an undetermanistic matter, should compilers warn or error when they detect that you're checking equality of floats", "tag": "none", "senID": 13}, {"text": "Should compilers support an option to replace all float equality checks with a 'close enough' function?", "tag": "none", "senID": 14}, {"text": "Do compilers already do this and I just can't find the information.", "tag": "none", "senID": 15}]}]