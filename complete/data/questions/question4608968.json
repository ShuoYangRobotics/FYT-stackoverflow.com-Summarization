[{"text": ["How to access a superclass's class attributes in Python?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Have a look at the following code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    defaults = {'a': 1}\n\n    def __getattr__(self, name):\n        print('A.__getattr__')\n        return self.get_default(name)\n\n    @classmethod\n    def get_default(cls, name):\n        # some debug output\n        print('A.get_default({}) - {}'.format(name, cls))\n        try:\n            print(super(cls, cls).defaults) # as expected\n        except AttributeError: #except for the base object class, of course\n            pass\n\n        # the actual function body\n        try:\n            return cls.defaults[name]\n        except KeyError:\n            return super(cls, cls).get_default(name) # infinite recursion\n            #return cls.__mro__[1].get_default(name) # this works, though\n\nclass B(A):\n    defaults = {'b': 2}\n\nclass C(B):\n    defaults = {'c': 3}\n\n\nc = C()\nprint('c.a =', c.a)\n</code>\n</pre>\n", "senID": 2}, {"text": ["I have a hierarchy of classes each with its own dictionary containing some default values.", "If an instance of a class doesn't have a particular attribute, a default value for it should be returned instead.", "If no default value for the attribute is contained in the current class's defaults dictionary, the superclass's defaults dictionary should be searched."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "defaults", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "defaults", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I'm trying to implement this using the recursive class method get_default.", "The program gets stuck in an infinite recursion, unfortunately.", "My understanding of super() is obviously lacking.", "By accessing __mro__, I can get it to work properly though, but I'm not sure this is a proper solution."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "get_default", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "super()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__mro__", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["I have the feeling the answer is somewhere in this article, but I haven't been able to find it yet.", "Perhaps I need to resort to using a metaclass?"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "this article", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.artima.com/weblogs/viewpost.jsp?thread=236275"}]}, {"text": ["edit: In my application, __getattr__ first checks self.base.", "If it is not None, the attribute needs to be fetched from there.", "Only in the other case, a default value must be returned.", "I could probably override __getattribute__.", "Would that be the better solution?"], "childNum": 5, "tag": "p", "senID": 6, "childList": [{"text": "edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "__getattr__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "self.base", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__getattribute__", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["edit 2: Below is an extended example of the functionality that I'm looking for.", "It is currently implemented using __mro__ (unutbu's earlier suggestion, as opposed to my original recursive method).", "Unless someone can suggest a more elegant solution, I'm happy using this implementation.", "I hope this clears things up."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "edit 2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "__mro__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class A(object):\n    defaults = {'a': 1}\n\n    def __init__(self, name, base=None):\n        self.name = name\n        self.base = base\n\n    def __repr__(self):\n        return self.name\n\n    def __getattr__(self, name):\n        print(\" '{}' attribute not present in '{}'\".format(name, self))\n        if self.base is not None:\n            print(\"  getting '{}' from base ({})\".format(name, self.base))\n            return getattr(self.base, name)\n        else:\n            print(\"  base = None; returning default value\")\n            return self.get_default(name)\n\n    def get_default(self, name):\n        for cls in self.__class__.__mro__:\n            try:\n                return cls.defaults[name]\n            except KeyError:\n                pass\n        raise KeyError\n\nclass B(A):\n    defaults = {'b': 2}\n\nclass C(B):\n    defaults = {'c': 3}\n\n\nc1 = C('c1')\nc1.b = 55\n\nprint('c1.a = ...'); print('   ...', c1.a) # 1\nprint(); print('c1.b = ...'); print('   ...', c1.b) # 55\nprint(); print('c1.c = ...'); print('   ...', c1.c) # 3\n\nc2 = C('c2', base=c1)\nc2.c = 99\n\nprint(); print('c2.a = ...'); print('   ...', c2.a) # 1\nprint(); print('c2.b = ...'); print('   ...', c2.b) # 55\nprint(); print('c2.c = ...'); print('   ...', c2.c) # 99\n</code>\n</pre>\n", "senID": 8}, {"text": ["The output:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n c1.a = ...\n 'a' attribute not present in 'c1'\n  base = None; returning default value\n   ... 1\n\nc1.b = ...\n   ... 55\n\nc1.c = ...\n 'c' attribute not present in 'c1'\n  base = None; returning default value\n   ... 3\n\nc2.a = ...\n 'a' attribute not present in 'c2'\n  getting 'a' from base (c1)\n 'a' attribute not present in 'c1'\n  base = None; returning default value\n   ... 1\n\nc2.b = ...\n 'b' attribute not present in 'c2'\n  getting 'b' from base (c1)\n   ... 55\n\nc2.c = ...\n   ... 99\n</code>\n</pre>\n", "senID": 10}]