[{"text": ["Python: Is there a way to keep an automatic conversion from int to long int from happening?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Python is more strongly typed than other scripting languages.", "For example, in Perl:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n perl -E '$c=5; $d=\"6\"; say $c+$d'   #prints 11\n</code>\n</pre>\n", "senID": 2}, {"text": ["But in Python:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; c=\"6\"\n&gt;&gt;&gt; d=5\n&gt;&gt;&gt; print c+d\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: cannot concatenate 'str' and 'int' objects\n</code>\n</pre>\n", "senID": 4}, {"text": ["Perl will inspect a string and convert to a number, and the + - / * ** operators work as you expect with a number.", "PHP is similar. "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "+ - / * **", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Python uses + to concatenate strings so the the attempted operation of c+d fails because c is a string, d an int.", "Python has stronger sense of numeric types than does Perl.", "OK -- I can deal with that. "], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "c+d", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "numeric types", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#typesnumeric"}]}, {"text": ["But consider:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from sys import maxint\n&gt;&gt;&gt; type(maxint)\n&lt;type 'int'&gt;\n&gt;&gt;&gt; print maxint\n9223372036854775807\n&gt;&gt;&gt; type(maxint+2)\n&lt;type 'long'&gt;\n&gt;&gt;&gt; print maxint+2\n9223372036854775809\n&gt;&gt;&gt; type((maxint+2)+maxint)\n&lt;type 'long'&gt;\n&gt;&gt;&gt; print ((maxint+2)+maxint)\n18446744073709551616\n</code>\n</pre>\n", "senID": 8}, {"text": ["Now Python will autopromote from an int, which in this case is a 64 bit long (OS X, python 2.6.1) to a python long int which is of arbitrary precision.", "Even though the types are not the same, they are similar and Python allows the usual numeric operators to be used.", "Usually this is helpful.", "It is helpful with smoothing the differences between 32 bit and 64 bit for example. "], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "autopromote", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0237/"}]}, {"text": ["The conversion from int to long is one way:"], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "long", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; type((maxint+2)-2)\n&lt;type 'long'&gt;\n</code>\n</pre>\n", "senID": 11}, {"text": ["Once the conversion is made, all operations on that variable are now done in arbitrary precision.", "The arbitrary precision operations are orders of magnitude slower than the native int operations.", "On a script I am working on, I would have some execution be snappy and other that extended into hours because of this.", "Consider:"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "all", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print maxint**maxint        # execution so long it is essentially a crash\n</code>\n</pre>\n", "senID": 13}, {"text": ["So my question: Is there a way to defeat or not allow the auto-promotion of a Python int to a Python long? "], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "long", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit, follow-up:"], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "Edit, follow-up:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I received several comments in the form of 'why on earth would you want to have C style overflow behavior?", "' The issue was that this particular piece of code worked OK on 32 bits in C and Perl (with use int) with C's overflow behavior.", "There was a failed attempt to port this code to Python.", "Python's different overflow behavior turn out to be (part) of the problem.", "The code has many of those different idioms (C, Perl, some python) mixed in (and those comments mixed in), so it was challenging."], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "use int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Essentially, the image analysis being done is a disc based high-pass filter to perform similar image comparison.", "Part of the high-pass filter has an integer-based multiplication of two large polynomials.", "The overflow was essentially a \"don't - care, it's big...\" kind of logic so the result was as intended with a C-based overflow.", "So the use of Horner's rule with O(n2) time was a waste since the larger polynomials would just be \"big\" -- a rough-justice form of carot-top's saturation arithmetic. "], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "2", "childNum": 0, "tag": "sup", "pos": 3, "childList": []}]}, {"text": ["Changing the loop-based polynomial multiplication to a form of FFT is probably significantly faster.", "FFT runs in close to linear time vs O(n2) for Horner's rule polynomial multiply.", "Going from disc based to in-memory will also speed this up.", "The images are not terribly big, but the original code was written at a time when they were considered \"huge!!!", "\" The code owner is not quite ready to trash his beloved code, so we'll see.", "The 'right answer' for him probably is just keep Perl or C if he wants that code. "], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "2", "childNum": 0, "tag": "sup", "pos": 1, "childList": []}]}, {"text": ["Thanks for the answers.", "I did not know about Python's decimal module, and that seemed to be closest to what I was asking -- even though there are other issues to be solved in this case!"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}]