[{"text": ["Performance gain using MPI"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I tested the performance gain of parallelizing the (nearly) \"embarassingly parallel\" (i.e.", "perfectly parallelizable) algorithm of summing up the first N integers: "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "N", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The serial algorithm is simply:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n N = 100000000\nprint sum(range(N))\n</code>\n</pre>\n", "senID": 3}, {"text": ["Execution time on my dual core laptop (Lenovo X200): 0m21.111s."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The parallelized (with mpi4py) version uses 3 nodes; node 0 calculates the sum of the lower half of the interger, node 1 calculates the sum of the upper half.", "The both send their results (via comm.send) to node 2 which sums up both numbers and prints the result: "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "comm.send", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from mpi4py import MPI\n\ncomm = MPI.COMM_WORLD\nrank = comm.Get_rank()\n\nN = 100000000\n\nif rank == 0: \n  s = sum(range(N/2))\n  comm.send(s,dest=2,tag=11)\nelif rank == 1:\n  s = sum(range(N/2+1,N))\n  comm.send(s,dest=2,tag=11)\nelif rank == 2:\n  s1 = comm.recv(source=0, tag=11)\n  s2 = comm.recv(source=1, tag=11)\n  print s1+s2\n</code>\n</pre>\n", "senID": 6}, {"text": ["Both cores of my dual-core-laptop are fully used; Execution time now: 15.746s."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["My Question: At least in theory, the execution time should nearly be halfed.", "Which overhead eats the missing 4 seconds?", "(surely not s1+s2).", "Are those send- / receive-Commands that time-consuming?"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Edit: After reading the answers and rethinking the question, I think the 4 seconds (in some runs even more than that) are eaten by the high memory traffic caused by the generation of two lists of length 50000000; the two cores of my laptop share a common memory (at least main memory; I think they have separate L2-Caches) and exactly this is the bottleneck: so, very often, both cores want to access memory at the same time (for getting the next list element) and one of them has to wait..."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If I use xrange instead of range, the next list elements are generated lazily and little memory is allocated.", "I tested it and running the same programm as above with xrange takes just 11 seconds!"], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "xrange", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "range", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]