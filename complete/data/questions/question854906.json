[{"text": ["Is this Python producer-consumer lockless approach thread-safe?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I recently wrote a program that used a simple producer/consumer pattern.", "It initially had a bug related to improper use of threading.Lock that I eventually fixed.", "But it made me think whether it's possible to implement producer/consumer pattern in a lockless manner."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Requirements in my case were simple:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "One producer thread.", "tag": "none", "senID": 3}, {"text": "One consumer thread.", "tag": "none", "senID": 4}, {"text": "Queue has place for only one item.", "tag": "none", "senID": 5}, {"text": "Producer can produce next item before the current one is consumed. The current item is therefore lost, but that's OK for me.", "tag": "none", "senID": 6}, {"text": "Consumer can consume current item before the next one is produced. The current item is therefore consumed twice (or more), but that's OK for me.", "tag": "none", "senID": 7}]}, {"text": ["So I wrote this:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n QUEUE_ITEM = None\n\n# this is executed in one threading.Thread object\ndef producer():\n    global QUEUE_ITEM\n    while True:\n        i = produce_item()\n        QUEUE_ITEM = i\n\n# this is executed in another threading.Thread object\ndef consumer():\n    global QUEUE_ITEM\n    while True:\n        i = QUEUE_ITEM\n        consume_item(i)\n</code>\n</pre>\n", "senID": 9}, {"text": ["My question is: Is this code thread-safe?"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Immediate comment: this code isn't really lockless - I use CPython and it has GIL."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["I tested the code a little and it seems to work.", "It translates to some LOAD and STORE ops which are atomic because of GIL.", "But I also know that del x operation isn't atomic when x implements __del__ method.", "So if my item has a __del__ method and some nasty scheduling happens, things may break.", "Or not?"], "childNum": 3, "tag": "p", "senID": 12, "childList": [{"text": "del x", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__del__", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "__del__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Another question is: What kind of restrictions (for example on produced items' type) do I have to impose to make the above code work fine?"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["My questions are only about theoretical possibility to exploit CPython's and GIL's quirks in order to come up with lockless (i.e.", "no locks like threading.Lock explicitly in code) solution."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}]