[{"text": ["Tips on how to parse custom file format"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Sorry about the vague title, but I really don't know how to describe this problem concisely."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I've created a (more or less) simple domain-specific language that I will to use to specify what validation rules to apply to different entities (generally forms submitted from a web page).", "I've included a sample at the bottom of this post of what the language looks like."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "domain-specific language", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Domain-specific_language"}]}, {"text": ["My problem is that I have no idea how to begin parsing this language into a form I can use (I will be using Python to do the parsing).", "My goal is to end up with a list of rules/filters (as strings, including arguments, e.g.", "'cocoa(99)') that should be applied (in order) to each object/entity (also a string, e.g.", "'chocolate', 'chocolate.lindt', etc.", ")."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "'cocoa(99)'", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "'chocolate'", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "'chocolate.lindt'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["I'm not sure what technique to use to start with, or even what techniques exist for problems like this.", "What do you think is the best way of going about this?", "I'm not looking for a complete solution, just a general nudge in the right direction."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Thanks.   "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Sample file of language:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n # Comments start with the '#' character and last until the end of the line\n# Indentation is significant (as in Python)\n\n\nconstant NINETY_NINE = 99       # Defines the constant `NINETY_NINE` to have the value `99`\n\n\n*:      # Applies to all data\n    isYummy             # Everything must be yummy\n\nchocolate:              # To validate, say `validate(\"chocolate\", object)`\n    sweet               # chocolate must be sweet (but not necessarily chocolate.*)\n\n    lindt:              # To validate, say `validate(\"chocolate.lindt\", object)`\n        tasty           # Applies only to chocolate.lindt (and not to chocolate.lindt.dark, for e.g.)\n\n        *:              # Applies to all data under chocolate.lindt\n            smooth      # Could also be written smooth()\n            creamy(1)   # Level 1 creamy\n        dark:           # dark has no special validation rules\n            extraDark:\n                melt            # Filter that modifies the object being examined\n                c:bitter        # Must be bitter, but only validated on client\n                s:cocoa(NINETY_NINE)    # Must contain 99% cocoa, but only validated on server. Note constant\n        milk:\n            creamy(2)   # Level 2 creamy, overrides creamy(1) of chocolate.lindt.* for chocolate.lindt.milk\n            creamy(3)   # Overrides creamy(2) of previous line (all but the last specification of a given rule are ignored)\n\n\n\nruleset food:       # To define a chunk of validation rules that can be expanded from the placeholder `food` (think macro)\n    caloriesWithin(10, 2000)        # Unlimited parameters allowed\n    edible\n    leftovers:      # Nested rules allowed in rulesets\n        stale\n\n# Rulesets may be nested and/or include other rulesets in their definition\n\n\n\nchocolate:              # Previously defined groups can be re-opened and expanded later\n    ferrero:\n        hasHazelnut\n\n\n\ncake:\n    tasty               # Same rule used for different data (see chocolate.lindt)\n    isLie\n    ruleset food        # Substitutes with rules defined for food; cake.leftovers must now be stale\n\n\npasta:\n    ruleset food        # pasta.leftovers must also be stale\n\n\n\n\n# Sample use (in JavaScript):\n\n# var choc = {\n#   lindt: {\n#       cocoa: {\n#           percent: 67,\n#           mass:    '27g'\n#       }\n#   }\n#   // Objects/groups that are ommitted (e.g. ferrro in this example) are not validated and raise no errors\n#   // Objects that are not defined in the validation rules do not raise any errors (e.g. cocoa in this example)\n# };\n# validate('chocolate', choc);\n\n# `validate` called isYummy(choc), sweet(choc), isYummy(choc.lindt), smooth(choc.lindt), creamy(choc.lindt, 1), and tasty(choc.lindt) in that order\n# `validate` returned an array of any validation errors that were found\n\n# Order of rule validation for objects:\n# The current object is initially the object passed in to the validation function (second argument).\n# The entry point in the rule group hierarchy is given by the first argument to the validation function.\n# 1. First all rules that apply to all objects (defined using '*') are applied to the current object,\n#    starting with the most global rules and ending with the most local ones.\n# 2. Then all specific rules for the current object are applied.\n# 3. Then a depth-first traversal of the current object is done, repeating steps 1 and 2 with each object found as the current object\n# When two rules have equal priority, they are applied in the order they were defined in the file.\n\n\n\n# No need to end on blank line\n</code>\n</pre>\n", "senID": 7}]