[{"text": ["The best way to invoke methods in Python class declarations?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Say I am declaring a class C and a few of the declarations are very similar.", "I'd like to use a function f to reduce code repetition for these declarations.", "It's possible to just declare and use f as usual:"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "C", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class C(object):\n...     def f(num):\n...             return '&lt;' + str(num) + '&gt;'\n...     v = f(9)\n...     w = f(42)\n... \n&gt;&gt;&gt; C.v\n'&lt;9&gt;'\n&gt;&gt;&gt; C.w\n'&lt;42&gt;'\n&gt;&gt;&gt; C.f(4)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unbound method f() must be called with C instance as first argument (got int instance instead)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Oops!", "I've inadvertently exposed f to the outside world, but it doesn't take a self argument (and can't for obvious reasons).", "One possibility would be to del the function after I use it:"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "f", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "del", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class C(object):\n...     def f(num):\n...             return '&lt;' + str(num) + '&gt;'\n...     v = f(9)\n...     del f\n... \n&gt;&gt;&gt; C.v\n'&lt;9&gt;'\n&gt;&gt;&gt; C.f\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: type object 'C' has no attribute 'f'\n</code>\n</pre>\n", "senID": 4}, {"text": ["But what if I want to use f again later, after the declaration?", "It won't do to delete the function.", "I could make it \"private\" (i.e., prefix its name with __) and give it the @staticmethod treatment, but invoking staticmethod objects through abnormal channels gets very funky:"], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "f", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "@staticmethod", "childNum": 0, "tag": "code", "childList": []}, {"text": "staticmethod", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class C(object):\n...     @staticmethod\n...     def __f(num):\n...             return '&lt;' + str(num) + '&gt;'\n...     v = __f.__get__(1)(9)   # argument to __get__ is ignored...\n... \n&gt;&gt;&gt; C.v\n'&lt;9&gt;'\n</code>\n</pre>\n", "senID": 6}, {"text": ["I have to use the above craziness because staticmethod objects, which are descriptors, are not themselves callable.", "I need to recover the function wrapped by the staticmethod object before I can call it."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "staticmethod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "staticmethod", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["There has got to be a better way to do this.", "How can I cleanly declare a function in a class, use it during its declaration, and also use it later from within the class?", "Should I even be doing this?"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}]