[{"text": ["basic inheritance (in python)"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["users, "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I have a basic question concerning inheritance (in python).", "I have two classes and one of them is inherited from the other like"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class   p:\n    def __init__(self,name):\n        self.pname  = name\n\nclass   c(p):\n    def __init__(self,name):\n        self.cname  = name\n</code>\n</pre>\n", "senID": 3}, {"text": ["Is there any possibility that I can create a parent object and several child objects which refer to the SAME parent object?", "It should work like that that the parent object contains several variables and whenever I access the corresponding variables from a child I actually access the variable form the parent.", "I.e.", "if I change it for one child it is changed also for all other childes and the data are only stored once in memory (and not copied for each child...)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Thank you in advance."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Here is a possible workaround which I do not consider as so nice"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n class P:\n    def __init__(self, name):\n        self.pname = name\n\nclass C:\n    def __init__(self, name,pobject):\n        self.pobject = pobject\n        self.cname = name\n</code>\n</pre>\n", "senID": 7}, {"text": ["Is this really the state of the art or do there exist other concepts?"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Sebastian"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Thank you all for helping me, also with the name conventions :) But I am still not very satisfied.", "Maybe I give a more advanced example to stress what I really want to do."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n class P:\n    data = \"shareddata\"\n    def __init__(self,newdata):\n        self.data = newdata \n\n    def printname(self):\n        print self.name \n\nclass C(P):\n    def __init__(self,name):\n        self.name = name\n</code>\n</pre>\n", "senID": 11}, {"text": ["Now I can do the following"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n In [33]: c1 = test.C(\"name1\")\n\nIn [34]: c2 = test.C(\"name2\")\n\nIn [35]: c1.printname()\nname1\n\nIn [36]: c2.printname()\nname2\n\nIn [37]: c1.data\nOut[37]: 'shareddata'\n\nIn [38]: c2.data\nOut[38]: 'shareddata'\n</code>\n</pre>\n", "senID": 13}, {"text": ["And this is so far exactly what I want.", "There is a variable name which is different for every child and the parent class accesses the individual variables.", "Normal inheritance.", "Then there is the variable data which comes from the parent class and every child access it.", "However, now the following does not work any more"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n In [39]: c1.data = \"tst\"\n\nIn [40]: c2.data\nOut[40]: 'shareddata'\n\nIn [41]: c1.data\nOut[41]: 'tst'\n</code>\n</pre>\n", "senID": 15}, {"text": ["I want the change in c1.data to affect also c2.data since I want the variable to be shared, somehow a global variable of this parent class. "], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["And more than that.", "I also want to create different instances of P, each having its own data variable.", "And when I create a new C object I want to specify from which P object data should be inhetited i.e.", "shared...."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["UPDATE: "], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["remark to the comment of  @eyquem: Thanks for this, it is going into the direction I want.", "However, now the __class__.pvar is shared among all objects of the class.", "What I want is that several instances of P may have a different pvar.", "Lets assume P1 has pvar=1 and P2 has pvar=2.", "Then I want to create children C1a, C1b, C1c which are related to P1, i.e.", "if I say C1a.pvar it should acess pvar from P1.", "Then I create C2a, C2b, C2c and if I access i.e.", "C2b.pvar I want to access pvar from P2.", "Since the class C inherits pvar from the class P pvar is known to C. My naive idea is that if I create a new instance of C I should be able to specify which (existing) P object should be used as the parent object and not to create a completely new P object as it is done when calling P.__init__ inside of the __init__ of C...", "It sounds simple to me, maybe I forget something..."], "childNum": 3, "tag": "p", "senID": 19, "childList": [{"text": "__class__.pvar", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "P.__init__", "childNum": 0, "tag": "code", "pos": 8, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["UPDATE:"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"text": ["So I found this discussion which is pretty much my question"], "childNum": 1, "tag": "p", "senID": 21, "childList": [{"text": "this discussion", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.velocityreviews.com/forums/t356880-can-you-create-an-instance-of-a-subclass-with-an-existing-instance-of-the-base-class.html"}]}, {"text": ["Any suggestions?"], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"text": ["UPDATE:"], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"text": ["The method .class._subclasses_ seems to be not existing any more.."], "childNum": 2, "tag": "p", "senID": 24, "childList": [{"text": "class", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "subclasses", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["UPDATE:"], "childNum": 0, "tag": "p", "senID": 25, "childList": []}, {"text": ["Here is onother link:"], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"text": ["link to discussion"], "childNum": 1, "tag": "p", "senID": 27, "childList": [{"text": "link to discussion", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bytes.com/topic/python/answers/834541-using-existing-instance-parent"}]}, {"text": ["There it is solved by copying.", "But I do not want to copy the parent class since I would like that it exists only once..."], "childNum": 0, "tag": "p", "senID": 28, "childList": []}, {"text": ["UPDATE:"], "childNum": 0, "tag": "p", "senID": 29, "childList": []}, {"text": ["Sorry for leaving the discussion yesterday, I am a bit ill... And thank you for the posts!", "I will now read through them.", "I thought about it a bit more and here is a possible solution I found"], "childNum": 0, "tag": "p", "senID": 30, "childList": []}, {"code": "<pre>\n<code>\n class P(object):\n    def __init__(self,pvar):\n        self.pobject    = None\n        self._pvar  = pvar\n\n    @property\n    def pvar(self):\n    if self.pobject != None:\n        return  self.pobject.pvar\n    else:\n            return self._pvar\n    @pvar.setter\n    def pvar(self,val):\n    if self.pobject != None:\n        self.pobject.pvar = val\n    else:\n            self._pvar=val\n\n    def printname(self):\n    print self.name\n\n\nclass C(P):\n    def __init__(self,name,pobject):  #&lt;-- The same default `P()` is \n                                          # used for all instances of `C`, \n                                          # unless pobject is explicitly defined.\n    P.__init__(self,None)\n        self.name   = name\n        self.pobject = pobject\n\n\np1  = P(\"1\")\np2  = P(\"2\")\n\n\nc1a = C(\"c1a\",p1)\nc1b = C(\"c1b\",p1)\nc1c = C(\"c1c\",p1)\nc2a = C(\"c2a\",p2)\nc2b = C(\"c2b\",p2)\nc2c = C(\"c2c\",p2)\n\n\nprint   id(c1a.pvar)\nprint   id(c1b.pvar)\nprint   id(c1c.pvar)\nprint   id(c2a.pvar)\nprint   id(c2b.pvar)\nprint   id(c2c.pvar)\nprint   id(p1.pvar)\nprint   id(p2.pvar)\n\nprint   id(c1a.name)\nprint   id(c1b.name)\nprint   id(c1c.name)\nprint   id(c2a.name)\nprint   id(c2b.name)\nprint   id(c2c.name)\n</code>\n</pre>\n", "senID": 31}, {"text": ["It is a bit cumbersome and I hope that there is a simpler way to achieve this.", "But it has the feature that pvar is only mentioned in the class P and the class C does not know about pvar as it should be according to my understanding of inheritance.", "Nevertheless when I create a new instance of C I can specify an existing instance of P which will be stored in the variable pobject.", "When the variable pvar is accessed actually pvar of the P-instance stored in this variable is accessed... "], "childNum": 0, "tag": "p", "senID": 32, "childList": []}, {"text": ["The output is given by"], "childNum": 0, "tag": "p", "senID": 33, "childList": []}, {"code": "<pre>\n<code>\n 3078326816\n3078326816\n3078326816\n3074996544\n3074996544\n3074996544\n3078326816\n3074996544\n156582944\n156583040\n156583200\n156583232\n156583296\n156583360\n</code>\n</pre>\n", "senID": 34}, {"text": ["I will read now through your last comments,"], "childNum": 0, "tag": "p", "senID": 35, "childList": []}, {"text": ["all the best, Sebastian "], "childNum": 0, "tag": "p", "senID": 36, "childList": []}, {"text": ["UPDATE:"], "childNum": 0, "tag": "p", "senID": 37, "childList": []}, {"text": ["I think the most elegant way would be the following (which DOES NOT work)"], "childNum": 0, "tag": "p", "senID": 38, "childList": []}, {"code": "<pre>\n<code>\n class P(object):\n    def __init__(self,pvar):\n        self.pvar   = pvar\n\n    def printname(self):\n        print self.name\n\n\nclass C(P):\n    def __init__(self,name,pobject):  \n        P = pobject\n        self.name   = name\n</code>\n</pre>\n", "senID": 39}, {"text": ["I think python should allow for this..."], "childNum": 0, "tag": "p", "senID": 40, "childList": []}, {"text": ["UPDATE:"], "childNum": 0, "tag": "p", "senID": 41, "childList": []}, {"text": ["Ok, now I found a way to achieve this, due to the explanations by eyquem.", "But Since this is really a hack there should be an official version for the same..."], "childNum": 0, "tag": "p", "senID": 42, "childList": []}, {"code": "<pre>\n<code>\n def replaceinstance(parent,child):\n    for item in parent.__dict__.items():\n        child.__dict__.__setitem__(item[0],item[1])\n        print item\n\nclass P(object):\n    def __init__(self,pvar):\n        self.pvar   = pvar\n\n    def printname(self):\n    print self.name\n\n\nclass C(P):\n    def __init__(self,name,pobject):\n    P.__init__(self,None)\n    replaceinstance(pobject,self)\n        self.name   = name\n\n\n\np1  = P(\"1\")\np2  = P(\"2\")\n\n\nc1a = C(\"c1a\",p1)\nc1b = C(\"c1b\",p1)\nc1c = C(\"c1c\",p1)\nc2a = C(\"c2a\",p2)\nc2b = C(\"c2b\",p2)\nc2c = C(\"c2c\",p2)\n\n\nprint   id(c1a.pvar)\nprint   id(c1b.pvar)\nprint   id(c1c.pvar)\nprint   id(c2a.pvar)\nprint   id(c2b.pvar)\nprint   id(c2c.pvar)\nprint   id(p1.pvar)\nprint   id(p2.pvar)\n\nprint   id(c1a.name)\nprint   id(c1b.name)\nprint   id(c1c.name)\nprint   id(c2a.name)\nprint   id(c2b.name)\nprint   id(c2c.name)\n</code>\n</pre>\n", "senID": 43}, {"text": ["the output is the same as above"], "childNum": 0, "tag": "p", "senID": 44, "childList": []}, {"code": "<pre>\n<code>\n 3077745184\n3077745184\n3077745184\n3074414912\n3074414912\n3074414912\n3077745184\n3074414912\n144028416\n144028448\n144028480\n144028512\n144028544\n144028576\n</code>\n</pre>\n", "senID": 45}, {"text": ["UPDATE: Even if the id's seem to be right, the last code does not work as is clear from this test"], "childNum": 0, "tag": "p", "senID": 46, "childList": []}, {"code": "<pre>\n<code>\n c1a.pvar    = \"newpvar1\"\n\nprint   c1a.pvar\nprint   c1b.pvar\nprint   c1c.pvar\nprint   c2a.pvar\nprint   c2b.pvar\nprint   c2c.pvar\nprint   p1.pvar\nprint   p2.pvar\n</code>\n</pre>\n", "senID": 47}, {"text": ["it has the output "], "childNum": 0, "tag": "p", "senID": 48, "childList": []}, {"code": "<pre>\n<code>\n newpvar1\n1\n1\n2\n2\n2\n1\n2\n</code>\n</pre>\n", "senID": 49}, {"text": ["However the version I posted first works:"], "childNum": 0, "tag": "p", "senID": 50, "childList": []}, {"code": "<pre>\n<code>\n class P(object):\n    def __init__(self,pvar):\n        self.pobject    = None\n        self._pvar  = pvar\n\n    @property\n    def pvar(self):\n    if self.pobject != None:\n        return  self.pobject.pvar\n    else:\n            return self._pvar\n    @pvar.setter\n    def pvar(self,val):\n    if self.pobject != None:\n        self.pobject.pvar = val\n    else:\n            self._pvar=val\n\n    def printname(self):\n    print self.name\n\n\nclass C(P):\n    def __init__(self,name,pobject):  #&lt;-- The same default `P()` is \n                                          # used for all instances of `C`, \n                                          # unless pobject is explicitly defined.\n    P.__init__(self,None)\n        self.name   = name\n        self.pobject = pobject\n\n\np1  = P(\"1\")\np2  = P(\"2\")\n\n\nc1a = C(\"c1a\",p1)\nc1b = C(\"c1b\",p1)\nc1c = C(\"c1c\",p1)\nc2a = C(\"c2a\",p2)\nc2b = C(\"c2b\",p2)\nc2c = C(\"c2c\",p2)\n\n\nprint   id(c1a.pvar)\nprint   id(c1b.pvar)\nprint   id(c1c.pvar)\nprint   id(c2a.pvar)\nprint   id(c2b.pvar)\nprint   id(c2c.pvar)\nprint   id(p1.pvar)\nprint   id(p2.pvar)\n\nprint   id(c1a.name)\nprint   id(c1b.name)\nprint   id(c1c.name)\nprint   id(c2a.name)\nprint   id(c2b.name)\nprint   id(c2c.name)\n\n\n\n\nprint   \"testing\\n\"\n\nc1a.printname()\nc1b.printname()\nc1c.printname()\nc2a.printname()\nc2b.printname()\nc2c.printname()\n\n\nprint   \"\\n\"\nc1a.name = \"c1anewname\"\nc2b.name = \"c2bnewname\"\n\n\nc1a.printname()\nc1b.printname()\nc1c.printname()\nc2a.printname()\nc2b.printname()\nc2c.printname()\n\n\nprint \"pvar\\n\"\n\nprint   c1a.pvar\nprint   c1b.pvar\nprint   c1c.pvar\nprint   c2a.pvar\nprint   c2b.pvar\nprint   c2c.pvar\nprint   p1.pvar\nprint   p2.pvar\n\nprint \"\\n\"\nc1a.pvar    = \"newpvar1\"\n\nprint   c1a.pvar\nprint   c1b.pvar\nprint   c1c.pvar\nprint   c2a.pvar\nprint   c2b.pvar\nprint   c2c.pvar\nprint   p1.pvar\nprint   p2.pvar\n\nprint \"\\n\"\nc2c.pvar    = \"newpvar2\"\n\nprint   c1a.pvar\nprint   c1b.pvar\nprint   c1c.pvar\nprint   c2a.pvar\nprint   c2b.pvar\nprint   c2c.pvar\nprint   p1.pvar\nprint   p2.pvar\n</code>\n</pre>\n", "senID": 51}, {"text": ["with the output"], "childNum": 0, "tag": "p", "senID": 52, "childList": []}, {"code": "<pre>\n<code>\n 3077745184\n3077745184\n3077745184\n3074414912\n3074414912\n3074414912\n3077745184\n3074414912\n144028416\n144028448\n144028480\n144028512\n144028544\n144028576\ntesting\n\nc1a\nc1b\nc1c\nc2a\nc2b\nc2c\n\n\nc1anewname\nc1b\nc1c\nc2a\nc2bnewname\nc2c\npvar\n\n1\n1\n1\n2\n2\n2\n1\n2\n\n\nnewpvar1\nnewpvar1\nnewpvar1\n2\n2\n2\nnewpvar1\n2\n\n\nnewpvar1\nnewpvar1\nnewpvar1\nnewpvar2\nnewpvar2\nnewpvar2\nnewpvar1\nnewpvar2\n</code>\n</pre>\n", "senID": 53}, {"text": ["Does anybody know why it is like that?", "I probably do not understand the internal way python works with this __dict__ so well..."], "childNum": 1, "tag": "p", "senID": 54, "childList": [{"text": "__dict__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]