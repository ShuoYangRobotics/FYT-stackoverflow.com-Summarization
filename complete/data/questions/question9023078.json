[{"text": ["custom dict that allows delete during iteration"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["UPDATED based on Lennart Regebro's answer"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Suppose you iterate through a dictionary, and sometimes need to delete an element.", "The following is very efficient:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n remove = []\nfor k, v in dict_.items():\n  if condition(k, v):\n    remove.append(k)\n    continue\n  # do other things you need to do in this loop\nfor k in remove:\n  del dict_[k]\n</code>\n</pre>\n", "senID": 3}, {"text": ["The only overhead here is building the list of keys to remove; unless it grows large compared to the dictionary size, it's not an issue.", "However, this approach requires some extra coding, so it's not very popular."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The popular dict comprehension approach:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n dict_ = {k : v for k, v in dict_ if not condition(k, v)}\nfor k, v in dict_.items():\n  # do other things you need to do in this loop\n</code>\n</pre>\n", "senID": 6}, {"text": ["results in a full dictionary copy, and so has the risk of a silly performance hit if dictionaries grow large or the containing function is called often. "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["A much better approach is to copy the keys only rather than whole dictionary:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n for k in list(dict_.keys()):\n  if condition(k, dict_[k]):\n    del dict_[k]\n    continue\n  # do other things you need to do in this loop\n</code>\n</pre>\n", "senID": 9}, {"text": ["(Note that all code examples are in Python 3, so keys(), items() returns a view, not a copy."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "keys()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "items()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In most cases, it won't hurt performance that much, since the time to check even the simplest condition (not to mention other stuff you're doing in the loop) is usually greater than the time to add one key to a list."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Still, I am wondering if it's possible to avoid even that with a custom dictionary that allows deletions while iterating:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n for k, v in dict_.items():\n  if condition(k, v):\n    del dict_[k]\n    continue\n  # do other things you need to do in this loop\n</code>\n</pre>\n", "senID": 13}, {"text": ["Perhaps an iterator could always look ahead, so that when the __next__ is called, the iterator knows where to go without even looking at the current element (it would only need to look at the element when it first gets to it).", "And if there is no next element, the iterator could just set the flag that would cause StopIteration exception raised whenever __next__ is called again."], "childNum": 3, "tag": "p", "senID": 14, "childList": [{"text": "__next__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "StopIteration", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__next__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If the element the iterator tries to advance to turns out to be deleted, it's fine to raise an exception; there is no need to support deletions while multiple iterations are going on simultaneously. "], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["Are there any problems with this approach?"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["One problem is that I'm not sure it can be done with no material overhead compared to the existing dict; otherwise, it would be faster to use the list(dict_) approach!"], "childNum": 2, "tag": "p", "senID": 17, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list(dict_)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["UPDATE:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["I tried all the versions.", "I don't report the timing, since they are clearly very dependent on the exact situation.", "But it seems safe to say that in many cases, the fastest approach is likely to be list(dict_).", "After all, if you think about, the copy is the fastest operation that grows linearly with size of the list; almost any other overhead, as long as it's also proportional to the list size, is likely to be bigger. "], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "list(dict_)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["I really like all the ideas, but since I have to select only one, I'm accepting the context manager solution since it allows to use the dictionary as either normal or \"enhanced\" with very small code changes."], "childNum": 0, "tag": "p", "senID": 20, "childList": []}]