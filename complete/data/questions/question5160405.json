[{"text": ["python regex: capture parts of multiple strings that contain spaces"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I am trying to capture sub-strings from a string that looks similar to"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n 'some string, another string, '\n</code>\n</pre>\n", "senID": 2}, {"text": ["I want the result match group to be"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n ('some string', 'another string')\n</code>\n</pre>\n", "senID": 4}, {"text": ["my current solution"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from re import match\n&gt;&gt;&gt; match(2 * '(.*?), ', 'some string, another string, ').groups()\n('some string', 'another string')\n</code>\n</pre>\n", "senID": 6}, {"text": ["works, but is not practicable - what I am showing here of course is massively reduced in terms of complexity compared to what I'm doing in the real project; I want to use one 'straight' (non-computed) regex pattern only.", "Unfortunately, my attempts have failed so far:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["This doesn't match (None as result), because {2} is applied to the space only, not to the whole string:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; match('.*?, {2}', 'some string, another string, ')\n</code>\n</pre>\n", "senID": 9}, {"text": ["adding parentheses around the repeated string has the comma and space in the result"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; match('(.*?, ){2}', 'some string, another string, ').groups()\n('another string, ',)\n</code>\n</pre>\n", "senID": 11}, {"text": ["adding another set of parantheses does fix that, but gets me too much:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; match('((.*?), ){2}', 'some string, another string, ').groups()\n('another string, ', 'another string')\n</code>\n</pre>\n", "senID": 13}, {"text": ["adding a non-capturing modifier improves the result, but still misses the first string"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; match('(?:(.*?), ){2}', 'some string, another string, ').groups()\n('another string',)\n</code>\n</pre>\n", "senID": 15}, {"text": ["I feel like I'm close, but I can't really seem to find the proper way."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["Can anyone help me ?", "Any other approaches I'm not seeing ?"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["Update after the first few responses:"], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "Update after the first few responses:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["First up, thank you very much everyone, your help is greatly appreciated!", ":-)"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["As I said in the original post, I have omitted a lot of complexity in my question for the sake of depicting the actual core problem.", "For starters, in the project I am working on, I am parsing large amounts of files (currently tens of thousands per day) in a number (currently 5, soon ~25, possibly in the hundreds later) of different line-based formats.", "There is also XML, JSON, binary and some other data file formats, but let's stay focussed."], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"text": ["In order to cope with the multitude of file formats and to exploit the fact that many of them are line-based, I have created a somewhat generic Python module that loads one file after the other, applies a regex to every line and returns a large data structure with the matches.", "This module is a prototype, the production version will require a C++ version for performance reason which will be connected over Boost::Python and will probably add the subject of regex dialects to the list of complexities."], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"text": ["Also, there are not 2 repetitions, but an amount varying between currently zero and 70 (or so), the comma is not always a comma and despite what I said originally, some parts of the regex pattern will have to be computed at runtime; let's just say I have reason to try and reduce the 'dynamic' amount and have as much 'fixed' pattern as possible."], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"text": ["So, in a word: I must use regular expressions."], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "I must use regular expressions.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Attempt to rephrase: I think the core of the problem boils down to: Is there a Python RegEx notation that e.g.", "involves curly braces repetitions and allows me to capture"], "childNum": 1, "tag": "p", "senID": 24, "childList": [{"text": "Attempt to rephrase:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 'some string, another string, '\n</code>\n</pre>\n", "senID": 25}, {"text": ["into"], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"code": "<pre>\n<code>\n ('some string', 'another string')\n</code>\n</pre>\n", "senID": 27}, {"text": [], "childNum": 0, "tag": "p", "senID": 28, "childList": []}, {"text": ["Hmmm, that probably narrows it down too far - but then, any way you do it is wrong :-D"], "childNum": 0, "tag": "p", "senID": 29, "childList": []}, {"text": ["Second attempt to rephrase: Why do I not see the first string ('some string') in the result ?", "Why does the regex produce a match (indicating there's gotta be 2 of something), but only returns 1 string (the second one) ?"], "childNum": 1, "tag": "p", "senID": 30, "childList": [{"text": "Second attempt to rephrase:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The problem remains the same even if I use non-numeric repetition, i.e.", "using + instead of {2}:"], "childNum": 0, "tag": "p", "senID": 31, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; match('(?:(.*?), )+', 'some string, another string, ').groups()\n('another string',)\n</code>\n</pre>\n", "senID": 32}, {"text": ["Also, it's not the second string that's returned, it is the last one:"], "childNum": 0, "tag": "p", "senID": 33, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; match('(?:(.*?), )+', 'some string, another string, third string, ').groups()\n('third string',)\n</code>\n</pre>\n", "senID": 34}, {"text": ["Again, thanks for your help, never ceases to amaze me how helpful peer review is while trying to find out what I actually want to know..."], "childNum": 0, "tag": "p", "senID": 35, "childList": []}]