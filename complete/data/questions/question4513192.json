[{"text": ["python dynamic class names"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Trying to instantiate a class based on a string value and... failing.", "The parser object below is a dict, in the example let's say we have one called foo and here parser['name'] is 'foo':"], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "parser", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "childList": []}, {"text": "parser['name']", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n obj = parser['name']()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Fails, yielding TypeError: 'str' object is not callable.", "But, since I have:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "TypeError: 'str' object is not callable", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class foo:\n    def __init__(self():\n        print 'Hello'\n</code>\n</pre>\n", "senID": 4}, {"text": ["And if I do obj = foo() it works fine and creates the correct object.", "Also, calling obj = type(parser['name'])() doesn't work."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "obj = foo()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "obj = type(parser['name'])()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["How to resolve this?", "Update: I don't really want to use a mapping system: the names of these classes are defined INI files, and parsed that way, so they will be strings.."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}]