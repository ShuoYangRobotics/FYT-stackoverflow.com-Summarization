[{"text": ["Python's layout of low-value ints in memory"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["My question is:  where do these patterns (below) originate?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I learned (somewhere) that Python has unique \"copies\", if that's the right word, for small integers.", "For example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = y = 0\n&gt;&gt;&gt; id(0)\n4297074752\n&gt;&gt;&gt; id(x)\n4297074752\n&gt;&gt;&gt; id(y)\n4297074752\n&gt;&gt;&gt; x += 1\n&gt;&gt;&gt; id(x)\n4297074728\n&gt;&gt;&gt; y\n0\n</code>\n</pre>\n", "senID": 3}, {"text": ["When I look at the memory locations of ints, there is a simple pattern early:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; N = id(0)\n&gt;&gt;&gt; for i in range(5):\n...     print i, N - id(i)\n... \n0 0\n1 24\n2 48\n3 72\n4 96\n&gt;&gt;&gt; bin(24)\n'0b11000'\n</code>\n</pre>\n", "senID": 5}, {"text": ["It's not clear to me why this is chosen as the increment.", "Moreover, I can't explain this pattern at all above 256:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; prev = 0\n&gt;&gt;&gt; for i in range(270):\n...     t = (id(i-1), id(i))\n...     diff = t[0] - t[1]\n...     if diff != prev:\n...         print i-1, i, t, diff\n...         prev = diff\n... \n-1 0 (4297074776, 4297074752) 24\n35 36 (4297073912, 4297075864) -1952\n36 37 (4297075864, 4297075840) 24\n76 77 (4297074904, 4297076856) -1952\n77 78 (4297076856, 4297076832) 24\n117 118 (4297075896, 4297077848) -1952\n118 119 (4297077848, 4297077824) 24\n158 159 (4297076888, 4297078840) -1952\n159 160 (4297078840, 4297078816) 24\n199 200 (4297077880, 4297079832) -1952\n200 201 (4297079832, 4297079808) 24\n240 241 (4297078872, 4297080824) -1952\n241 242 (4297080824, 4297080800) 24\n256 257 (4297080464, 4297155264) -74800\n257 258 (4297155072, 4297155288) -216\n259 260 (4297155072, 4297155336) -264\n260 261 (4297155048, 4297155432) -384\n261 262 (4297155024, 4297155456) -432\n262 263 (4297380280, 4297155384) 224896\n263 264 (4297155000, 4297155240) -240\n264 265 (4297155072, 4297155216) -144\n266 267 (4297155072, 4297155168) -96\n267 268 (4297155024, 4297155144) -120\n</code>\n</pre>\n", "senID": 7}, {"text": ["Any thoughts, clues, places to look?"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Edit:  and what's special about 24?"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Update:  The standard library has sys.getsizeof() which returns 24 when I call it with 1 as argument.", "That's a lot of bytes, but on a 64-bit machine, we have 8 bytes each for the type, the value and the ref count.", "Also, see here, and the C API reference here."], "childNum": 6, "tag": "p", "senID": 10, "childList": [{"text": "library", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/sys.html#sys.getsizeof"}, {"text": "sys.getsizeof()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "24", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "here", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.codexon.com/posts/memory-size-of-python-objects"}, {"href": "http://docs.python.org/c-api/intro.html#objects-types-and-reference-counts", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Spent some time with the \"source\" in the link from Peter Hansen in comments.", "Couldn't find the definition of an int (beyond a declaration of *int_int), but I did find:"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "*int_int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n #define NSMALLPOSINTS       257\n#define NSMALLNEGINTS       5\n</code>\n</pre>\n", "senID": 12}]