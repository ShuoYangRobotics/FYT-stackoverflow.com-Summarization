[{"text": ["Overriding the newline generation behaviour of Python's print statement"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I have a bunch of legacy code for encoding raw emails that contains a lot of print statements such as"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n print &gt;&gt;f, \"Content-Type: text/plain\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["This is all well and good for emails, but we're now leveraging the same code for outputting HTTP request.", "The problem is that the Python print statement outputs '\\n' whilst HTTP requires '\\r\\n'."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "'\\n'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "'\\r\\n'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It looks like Python (2.6.4 at least) generates a trailing PRINT_NEWLINE byte code for a print statement which is implemented as"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "PRINT_NEWLINE", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n ceval.c:1582: err = PyFile_WriteString(\"\\n\", w);\n</code>\n</pre>\n", "senID": 5}, {"text": ["Thus it appears there's no easy way to override the default newline behaviour of print.", "I have considered the following solutions"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["After writing the output simply do a.replace('\\n', '\\r\\n').", "This will interfere with HTTP messages that use multipart encoding.", "Create a wrapper around the destination file object and proxy the.writemethod "], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "After writing the output simply do a.replace('\\n', '\\r\\n'). This will interfere with HTTP messages that use multipart encoding.", "childNum": 1, "tag": "li", "pos": -1, "childList": [{"text": ".replace('\\n', '\\r\\n')", "tag": "code"}]}, {"text": ".replace('\\n', '\\r\\n')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Create a wrapper around the destination file object and proxy the.writemethod", "childNum": 1, "tag": "li", "pos": 2, "childList": [{"text": ".write", "tag": "code"}]}, {"text": ".write", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def write(self, data):\n    if data == '\\n':\n        data = '\\r\\n'\n    return self._file.write(data)\n</code>\n</pre>\n", "senID": 8}, {"text": ["Write a regular expression that translatesprint &gt;&gt;f, texttof.write(text + line_end)whereline_endcan be'\\n'or'\\r\\n'."], "childNum": 6, "tag": "p", "senID": 9, "childList": [{"text": "Write a regular expression that translatesprint &gt;&gt;f, texttof.write(text + line_end)whereline_endcan be'\\n'or'\\r\\n'.", "childNum": 5, "tag": "li", "pos": 0, "childList": [{"text": "print &gt;&gt;f, text", "tag": "code"}, {"text": "f.write(text + line_end)", "tag": "code"}, {"text": "line_end", "tag": "code"}, {"text": "'\\n'", "tag": "code"}, {"text": "'\\r\\n'", "tag": "code"}]}, {"text": "print &gt;&gt;f, text", "childNum": 0, "tag": "code", "childList": []}, {"text": "f.write(text + line_end)", "childNum": 0, "tag": "code", "childList": []}, {"text": "line_end", "childNum": 0, "tag": "code", "childList": []}, {"text": "'\\n'", "childNum": 0, "tag": "code", "childList": []}, {"text": "'\\r\\n'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I believe the third option would be the most appropriate.", "It would be interesting to hear what your Pythonic approach to the problem would be."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}]