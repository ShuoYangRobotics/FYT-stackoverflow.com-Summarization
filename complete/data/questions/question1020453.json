[{"text": ["What\u2019s the point of inheritance in Python?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I apologize if this question is long.", "This was part of a blog post I did some time ago, and a reader suggested me to post it on stackoverflow.", "I trimmed it a bit though."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Suppose you have the following situation"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;iostream&gt;\n\nclass Animal {\npublic:\n    virtual void speak() = 0;\n};\n\nclass Dog : public Animal {\n    void speak() { std::cout &lt;&lt; \"woff!\" &lt;&lt;std::endl; }\n};\n\nclass Cat : public Animal {\n    void speak() { std::cout &lt;&lt; \"meow!\" &lt;&lt;std::endl; }\n};\n\nvoid makeSpeak(Animal &amp;a) {\n    a.speak();\n}\n\nint main() {\n    Dog d;\n    Cat c;\n    makeSpeak(d);\n    makeSpeak(c);\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["As you can see, makeSpeak is a routine that accepts a generic Animal object.", "In this case, Animal is quite similar to a Java interface, as it contains only a pure virtual method.", "makeSpeak does not know the nature of the Animal it gets passed.", "It just sends it the signal \u201cspeak\u201d and leaves the late binding to take care of which method to call: either Cat::speak() or Dog::speak().", "This means that, as far as makeSpeak is concerned, the knowledge of which subclass is actually passed is irrelevant."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["But what about Python?", "Let\u2019s see the code for the same case in Python.", "Please note that I try to be as similar as possible to the C++ case for a moment:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class Animal(object):\n    def speak(self):\n        raise NotImplementedError()\n\nclass Dog(Animal):\n    def speak(self):\n        print \"woff!\"\n\nclass Cat(Animal):\n    def speak(self):\n        print \"meow\"\n\ndef makeSpeak(a):\n    a.speak()\n\nd=Dog()\nc=Cat()\nmakeSpeak(d)\nmakeSpeak(c)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Now, in this example you see the same strategy.", "You use inheritance to leverage the hierarchical concept of both Dogs and Cats being Animals.", "But in Python, there\u2019s no need for this hierarchy.", "This works equally well"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n class Dog:\n    def speak(self):\n        print \"woff!\"\n\nclass Cat:\n    def speak(self):\n        print \"meow\"\n\ndef makeSpeak(a):\n    a.speak()\n\nd=Dog()\nc=Cat()\nmakeSpeak(d)\nmakeSpeak(c)\n</code>\n</pre>\n", "senID": 8}, {"text": ["In Python you can send the signal \u201cspeak\u201d to any object you want.", "If the object is able to deal with it, it will be executed, otherwise it will raise an exception.", "Suppose you add a class Airplane to both codes, and submit an Airplane object to makeSpeak.", "In the C++ case, it won\u2019t compile, as Airplane is not a derived class of Animal.", "In the Python case, it will raise an exception at runtime, which could even be an expected behavior."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["On the other side, suppose you add a MouthOfTruth class with a method speak().", "In the C++ case, either you will have to refactor your hierarchy, or you will have to define a different makeSpeak method to accept MouthOfTruth objects, or in java you could extract the behavior into a CanSpeakIface and implement the interface for each.", "There are many solutions..."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["What I\u2019d like to point out is that I haven\u2019t found a single reason yet to use inheritance in Python (apart of frameworks and trees of exceptions, but I guess that alternative strategies exist).", "you don\u2019t need to implement a base-derived hierarchy to perform polymorphically.", "If you want to use inheritance to reuse implementation, you can accomplish the same through containment and delegation, with the added benefit that you can alter it at runtime, and you clearly define the interface of the contained, without risking unintended side effects."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["So, in the end, the question stands: what's the point of inheritance in Python?"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Edit: thanks for the very interesting answers.", "Indeed you can use it for code reuse, but I am always careful when reusing implementation.", "In general, I tend to do very shallow inheritance trees or no tree at all, and if a functionality is common I refactor it out as a common module routine and then call it from each object.", "I do see the advantage of having one single point of change (eg.", "instead of adding to Dog, Cat, Moose and so on, I just add to Animal, which is the basic advantage of inheritance), but you can achieve the same with a delegation chain (eg.", "a la JavaScript).", "I'm not claiming it's better though, just another way."], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I also found a similar post on this regard."], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "a similar post", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://forums.devshed.com/python-programming-11/does-interface-only-inheritance-make-sense-in-python-82822.html"}]}]