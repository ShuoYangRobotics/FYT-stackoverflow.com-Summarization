[{"text": ["Search for string allowing for one mismatch in any location of the string"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I am working with DNA sequences of length 25 (see examples below).", "I have a list of 230,000 and need to look for each sequence in the entire genome (toxoplasma gondii parasite).", "I am not sure how large the genome is, but much longer than 230,000 sequences."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I need to look for each of my sequences of 25 characters, for example,  (AGCCTCCCATGATTGAACAGATCAT)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The genome is formatted as a continuous string, i.e.", "(CATGGGAGGCTTGCGGAGCCTGAGGGCGGAGCCTGAGGTGGGAGGCTTGCGGAGTGCGGAGCCTGAGCCTGAGGGCGGAGCCTGAGGTGGGAGGCTT....)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I don't care where or how many times it is found, only whether it is or not.", "This is simple I think --  "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n str.find(AGCCTCCCATGATTGAACAGATCAT)\n</code>\n</pre>\n", "senID": 5}, {"text": ["But I also what to find a close match defined as wrong (mismatched) at any location, but only one location, and record the location in the sequence.", "I am not sure how do do this.", "The only thing I can think of is using a wildcard and performing the search with a wildcard in each position.", "I.e., search 25 times."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["For example,\nAGCCTCCCATGATTGAACAGATCAT\nAGCCTCCCATGATAGAACAGATCAT"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["A close match with a mismatch at position 13."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Speed is not a big issue because I am only doing it 3 times, though it would be nice if it was fast."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["There are programs that do this -- find matches and partial matches -- but I am looking for a type of partial match that is not discoverable with these applications."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Here is a similar post for perl, although they are only comparing sequences and not searching a continuous string : "], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Related post"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "Related post", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1672782/fastest-way-to-find-mismatch-positions-between-two-strings-of-the-same-length"}]}]