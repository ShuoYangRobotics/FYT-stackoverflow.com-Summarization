[{"text": ["counting combinations and permutations efficiently"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I have some code to count permutations and combinations, and I'm trying to make it work better for large numbers."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I've found a better algorithm for permutations that avoids large intermediate results, but I still think I can do better for combinations."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["So far, I've put in a special case to reflect the symmetry of nCr, but I'd still like to find a better algorithm that avoids the call to factorial(r), which is an unnecessarily large intermediate result.", "Without this optimization, the last doctest takes too long trying to calculate factorial(99000)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Can anyone suggest a more efficient way to count combinations?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from math import factorial\n\ndef product(iterable):\n    prod = 1\n    for n in iterable:\n        prod *= n\n    return prod\n\ndef npr(n, r):\n    \"\"\"\n    Calculate the number of ordered permutations of r items taken from a\n    population of size n.\n\n    &gt;&gt;&gt; npr(3, 2)\n    6\n    &gt;&gt;&gt; npr(100, 20)\n    1303995018204712451095685346159820800000\n    \"\"\"\n    assert 0 &lt;= r &lt;= n\n    return product(range(n - r + 1, n + 1))\n\ndef ncr(n, r):\n    \"\"\"\n    Calculate the number of unordered combinations of r items taken from a\n    population of size n.\n\n    &gt;&gt;&gt; ncr(3, 2)\n    3\n    &gt;&gt;&gt; ncr(100, 20)\n    535983370403809682970\n    &gt;&gt;&gt; ncr(100000, 1000) == ncr(100000, 99000)\n    True\n    \"\"\"\n    assert 0 &lt;= r &lt;= n\n    if r &gt; n // 2:\n        r = n - r\n    return npr(n, r) // factorial(r)\n</code>\n</pre>\n", "senID": 5}]