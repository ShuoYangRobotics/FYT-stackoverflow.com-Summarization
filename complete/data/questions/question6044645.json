[{"text": ["Efficient way to get index of minimum value in long vector, python"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I have a long list of longitude values (len(Lon) = 420481), and another one of latitude values.", "I want to find the corresponding latitude to the minimum of the longitude."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I tried:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n SE_Lat = [Lat[x] for x,y in enumerate(Lon) if y == min(Lon)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["but this takes ages to finish."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Does anyone know a more efficient way?  "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Maybe you also have a suggestions for this:\nI now try to find the closest corresponding latitude to a new longitude, which is not in the original longitude vector.", "I tried this:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n minDiff = [min(abs(x - lon_new) for x in lons)] # not very quick, but works\n[(lat,lon) for lat,lon in izip(lats,lons) if abs(lon-lon_new)==minDiff]\n</code>\n</pre>\n", "senID": 7}, {"text": ["The last line throws an error, because there are multiple matches.", "I don't know at the moment how to find only one value, lets say the first.", "Any help is greatly appreciated!"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}]