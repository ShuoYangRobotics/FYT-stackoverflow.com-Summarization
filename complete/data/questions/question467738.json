[{"text": ["Implementing a \"rules engine\" in Python"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I'm writing a log collection / analysis application in Python and I need to write a \"rules engine\" to match and act on log messages."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It needs to feature:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Regular expression matching for the message itself", "tag": "none", "senID": 3}, {"text": "Arithmetic comparisons for message severity/priority", "tag": "none", "senID": 4}, {"text": "Boolean operators", "tag": "none", "senID": 5}]}, {"text": ["I envision An example rule would probably be something like:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n (message ~ \"program\\\\[\\d+\\\\]: message\" and severity &gt;= high) or (severity &gt;= critical)\n</code>\n</pre>\n", "senID": 7}, {"text": ["I'm thinking about using PyParsing or similar to actually parse the rules and construct the parse tree."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "PyParsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}]}, {"text": ["The current (not yet implemented) design I have in mind is to have classes for each rule type, and construct and chain them together according to the parse tree.", "Then each rule would have a \"matches\" method that could take a message object return whether or not it matches the rule."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Very quickly, something like:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n class RegexRule(Rule):\n    def __init__(self, regex):\n         self.regex = regex\n\n    def match(self, message):\n         return self.regex.match(message.contents)\n\nclass SeverityRule(Rule):\n    def __init__(self, operator, severity):\n         self.operator = operator\n\n    def match(self, message):\n         if operator == \"&gt;=\":\n             return message.severity &gt;= severity\n         # more conditions here...\n\nclass BooleanAndRule(Rule):\n    def __init__(self, rule1, rule2):\n         self.rule1 = rule1\n         self.rule2 = rule2\n\n    def match(self, message):\n          return self.rule1.match(message) and self.rule2.match(message)\n</code>\n</pre>\n", "senID": 11}, {"text": ["These rule classes would then be chained together according to the parse tree of the message, and the match() method called on the top rule, which would cascade down until all the rules were evaluated."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["I'm just wondering if this is a reasonable approach, or if my design and ideas are way totally out of whack?", "Unfortunately I never had the chance to take a compiler design course or anything like that in Unviersity so I'm pretty much coming up with this stuff of my own accord."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["Could someone with some experience in these kinds of things please chime in and evaluate the idea?"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["EDIT:\nSome good answers so far, here's a bit of clarification."], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The aim of the program is to collect log messages from servers on the network and store them in the database.", "Apart from the collection of log messages, the collector will define a set of rules that will either match or ignore messages depending on the conditions and flag an alert if necessary."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["I can't see the rules being of more than a moderate complexity, and they will be applied in a chain (list) until either a matching alert or ignore rule is hit.", "However, this part isn't quite as relevant to the question."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["As far the syntax being close to Python syntax, yes that is true, however I think it would be difficult to filter the Python down to the point where the user couldn't inadvertently do some crazy stuff with the rules that was not intended."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}]