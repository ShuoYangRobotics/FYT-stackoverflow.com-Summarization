[{"text": ["Emulate floating point string conversion behaviour of Linux on Windows"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I've encountered an annoying problem in outputting a floating point number.", "When I format 11.545 with a precision of 2 decimal points on Windows it outputs \"11.55\", as I would expect.", "However, when I do the same on Linux the output is \"11.54\"!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I originally encountered the problem in Python, but further investigation showed that the difference is in the underlying C runtime library.", "(The architecture is x86-x64 in both cases.", ") Running the following line of C produces the different results on Windows and Linux, same as it does in Python."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n printf(\"%.2f\", 11.545);\n</code>\n</pre>\n", "senID": 3}, {"text": ["To shed more light on this I printed the number to 20 decimal places (\"%.20f\"):"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "\"%.20f\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n Windows: 11.54500000000000000000\nLinux:   11.54499999999999992895\n</code>\n</pre>\n", "senID": 5}, {"text": ["I know that 11.545 cannot be stored precisely as a binary number.", "So what appears to be happening is that Linux outputs the number it's actually stored with the best possible precision, while Windows outputs the simplest decimal representation of it, ie.", "tries to guess what the user most likely meant."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["My question is: is there any (reasonable) way to emulate the Linux behaviour on Windows?"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "is there any (reasonable) way to emulate the Linux behaviour on Windows?", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["(While the Windows behaviour is certainly the intuitive one, in my case I actually need to compare the output of a Windows program with that of a Linux program and the Windows one is the only one I can change.", "By the way, I tried to look at the Windows source of printf, but the actual function that does the float->string conversion is _cfltcvt_l and its source doesn't appear to be available."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "printf", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "_cfltcvt_l", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["EDIT: the plot thickens!", "The theory about this being caused by an imprecise representation might be wrong, because 0.125 does have an exact binary representation and it's still different when output with '%.2f' % 0.125:"], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "0.125", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "'%.2f' % 0.125", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n Windows: 0.13\nLinux:   0.12\n</code>\n</pre>\n", "senID": 10}, {"text": ["However, round(0.125, 2) returns 0.13 on both Windows and Linux."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "round(0.125, 2)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]