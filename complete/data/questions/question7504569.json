[{"text": ["catch wrong-arguments exception, in the general case"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I want to catch an exception, but only if it comes from the very next level of logic."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The intent is to handle errors caused by the act of calling the function with the wrong number of arguments, without masking errors generated by the function implementation."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["How can I implement the wrong_arguments function below?"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "wrong_arguments", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n try:\n    return myfunc(*args)\nexcept TypeError, error:\n    #possibly wrong number of arguments\n    #we know how to proceed if the error occurred when calling myfunc(), \n    #but we shouldn't interfere with errors in the implementation of myfunc\n    if wrong_arguments(error, myfunc):\n        return fixit()\n    else:\n        raise\n</code>\n</pre>\n", "senID": 5}, {"text": ["Addendum:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["There are several solutions that work nicely in the simple case, but none of the current answers will work in the real-world case of decorated functions."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Consider that these are possible values of myfunc above:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "myfunc", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def decorator(func):\n    \"The most trivial (and common) decorator\"\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n\ndef myfunc1(a, b, c='ok'):\n    return (a, b, c)\n\nmyfunc2 = decorator(myfunc1)\nmyfunc3 = decorator(myfunc2)\n</code>\n</pre>\n", "senID": 9}, {"text": ["Even the conservative look-before-you-leap method (inspecting the function argument spec) fails here, since most decorators will have an argspec of *args, **kwargs regardless of the decorated function.", "Exception inspection also seems reliable, since myfunc.__name__ will be simply \"wrapper\" for most decorators, regardless of the core function's name."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "*args, **kwargs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "myfunc.__name__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Is there any good solution if the function may or may not have decorators?"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}]