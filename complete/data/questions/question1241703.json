[{"text": ["Controlling getter and setter for a python's class"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Consider the following class :"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Token:\n    def __init__(self):\n        self.d_dict = {}\n\n    def __setattr__(self, s_name, value):\n        self.d_dict[s_name] = value\n\n    def __getattr__(self, s_name):\n        if s_name in self.d_dict.keys():\n            return self.d_dict[s_name]\n        else:\n            raise AttributeError('No attribute {0} found !'.format(s_name))\n</code>\n</pre>\n", "senID": 2}, {"text": ["In my code Token have some other function (like get_all() wich return d_dict, has(s_name) which tell me if my token has a particular attribute)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Anyway, I think their is a flaw in my plan since it don't work : when I create a new instance, python try to call __setattr__('d_dict', '{}')."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "__setattr__('d_dict', '{}')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["How can I achieve a similar behaviour (maybe in a more pythonic way ?", ") without having to write something like Token.set(name, value) and get(name) each I want to set or get an attribute for a token."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Critics about design flaw and/or stupidity welcome :)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Thank !"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]