[{"text": ["Continuing in Python's unittest when an assertion fails"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["EDIT: switched to a better example, and clarified why this is a real problem."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I'd like to write unit tests in Python that continue executing when an assertion fails, so that I can see multiple failures in a single test.", "For example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Car(object):\n  def __init__(self, make, model):\n    self.make = make\n    self.model = make  # Copy and paste error: should be model.\n    self.has_seats = True\n    self.wheel_count = 3  # Typo: should be 4.\n\nclass CarTest(unittest.TestCase):\n  def test_init(self):\n    make = \"Ford\"\n    model = \"Model T\"\n    car = Car(make=make, model=model)\n    self.assertEqual(car.make, make)\n    self.assertEqual(car.model, model)  # Failure!\n    self.assertTrue(car.has_seats)\n    self.assertEqual(car.wheel_count, 4)  # Failure!\n</code>\n</pre>\n", "senID": 3}, {"text": ["Here, the purpose of the test is to ensure that Car's __init__ sets its fields correctly.", "I could break it up into four methods (and that's often a great idea), but in this case I think it's more readable to keep it as a single method that tests a single concept (\"the object is initialized correctly\")."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If we assume that it's best here to not break up the method, then I have a new problem: I can't see all of the errors at once.", "When I fix the model error and re-run the test, then the wheel_count error appears.", "It would save me time to see both errors when I first run the test."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "model", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "wheel_count", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["For comparison, Google's C++ unit testing framework distinguishes between between non-fatal EXPECT_* assertions and fatal ASSERT_* assertions:"], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "distinguishes between", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/googletest/wiki/Primer#Assertions"}, {"text": "EXPECT_*", "childNum": 0, "tag": "code", "childList": []}, {"text": "ASSERT_*", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Is there a way to get EXPECT_*-like behavior in Python's unittest?", "If not in unittest, then is there another Python unit test framework that does support this behavior?"], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "EXPECT_*", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "unittest", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "unittest", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Incidentally, I was curious about how many real-life tests might benefit from non-fatal assertions, so I looked at some code examples that I found with Google Code Search.", "Out of the first 10 results, 9 were unit tests (one was part of a mock framework), and 7 of the 9 used multiple independent assertions in the same test method.", "All 7 would benefit from non-fatal assertions."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "code examples", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://google.com/codesearch?hl=en&lr=&q=%22import+unittest%22+unittest.TestCase+self.assertEqual&sbtn=Search"}]}]