[{"text": ["Is there a way to efficiently yield every file in a directory containing millions of files?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I'm aware of os.listdir, but as far as I can gather, that gets all the filenames in a directory into memory, and then returns the list.", "What I want, is a way to yield a filename, work on it, and then yield the next one, without reading them all into memory."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "os.listdir", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Is there any way to do this?", "I worry about the case where filenames change, new files are added, and files are deleted using such a method.", "Some iterators prevent you from modifying the collection during iteration, essentially by taking a snapshot of the state of the collection at the beginning, and comparing that state on each move operation.", "If there is an iterator capable of yielding filenames from a path, does it raise an error if there are filesystem changes (add, remove, rename files within the iterated directory) which modify the collection? "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "move", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["There could potentially be a few cases that could cause the iterator to fail, and it all depends on how the iterator maintains state.", "Using S.Lotts example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n filea.txt\nfileb.txt\nfilec.txt\n</code>\n</pre>\n", "senID": 4}, {"text": ["Iterator yields filea.txt.", "During processing, filea.txt is renamed to filey.txt and fileb.txt is renamed to filez.txt.", "When the iterator attempts to get the next file, if it were to use the filename filea.txt to find it's current position in order to find the next file and filea.txt is not there, what would happen?", "It may not be able to recover it's position in the collection.", "Similarly, if the iterator were to fetch fileb.txt when yielding filea.txt, it could look up the position of fileb.txt, fail, and produce an error. "], "childNum": 11, "tag": "p", "senID": 5, "childList": [{"text": "filea.txt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "processing", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "filea.txt", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "filey.txt", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fileb.txt", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "filez.txt", "childNum": 0, "tag": "code", "childList": []}, {"text": "filea.txt", "childNum": 0, "tag": "code", "childList": []}, {"text": "filea.txt", "childNum": 0, "tag": "code", "childList": []}, {"text": "fileb.txt", "childNum": 0, "tag": "code", "childList": []}, {"text": "filea.txt", "childNum": 0, "tag": "code", "childList": []}, {"text": "fileb.txt", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If the iterator instead was able to somehow maintain an index dir.get_file(0), then maintaining positional state would not be affected, but some files could be missed, as their indexes could be moved to an index 'behind' the iterator."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "dir.get_file(0)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This is all theoretical of course, since there appears to be no built-in (python) way of iterating over the files in a directory.", "There are some great answers below, however, that solve the problem by using queues and notifications."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Edit:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["The OS of concern is Redhat.", "My use case is this:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Process A is continuously writing files to a storage location.", "Process B (the one I'm writing), will be iterating over these files, doing some processing based on the filename, and moving the files to another location."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Edit:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Definition of valid:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Adjective\n1.", "Well grounded or justifiable, pertinent."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["(Sorry S.Lott, I couldn't resist)."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["I've edited the paragraph in question above."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}]