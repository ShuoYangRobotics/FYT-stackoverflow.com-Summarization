[{"text": ["Segmentation fault in Prime Number generator"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I am aware the following isn't the fastest way of generating a list of primes however I posed myself the problem and before googling wrote the following program.", "It works fine for numbers &lt; ~ 44,000 but then gives a segmentation fault when ran on my 2Ghz Core 2 Duo Macbook.", "I am not really interested in alternative methods at the moment but in why its giving me a seg fault."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The last prime it is able to calculate is 42751 before it dies saying 'Segmentation fault'."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from sys import argv, exit, setrecursionlimit\n\ndef isPrime(no, halfNo, x = 3):\n\n  # if counted through and all numbers from 3 too x are not factors is prime\n  if x &gt; halfNo:\n    print no\n    return 1\n\n  # is x a factor?\n  if no % x == 0:\n    return 0\n  else:\n    isPrime(no, halfNo, x + 2)\n\npath, limLow, limHigh = argv\n\nlimLow = int(limLow)\nlimHigh = int(limHigh)\n\nsetrecursionlimit(limHigh)\n\n# negitive numbers, 0 and 1 are not primes so answer invalid\nif limLow &lt; 2:\n  exit('Invalid input');\n\n# if lower limit is even its not prime so increase by 1\nif limLow % 2 == 0:\n  limLow += 1\n\nwhile (limLow &lt;= limHigh):\n  isPrime(limLow, limLow / 2)\n  limLow += 2\n</code>\n</pre>\n", "senID": 3}]