[{"text": ["Fastest way in Python to find a 'startswith' substring in a long sorted list of strings"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I've done a lot of Googling, but haven't found anything, so I'm really sorry if I'm just searching for the wrong things."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I am writing an implementation of the Ghost for MIT Introduction to Programming, assignment 5."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Ghost", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://secure.wikimedia.org/wikipedia/en/wiki/Ghost_%28game%29"}, {"href": "http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/assignments/", "text": "MIT Introduction to Programming, assignment 5", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["As part of this, I need to determine whether a string of characters is the start of any valid word.", "I have a list of valid words (\"wordlist\")."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Update: I could use something that iterated through the list each time, such as Peter's simple suggestion:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def word_exists(wordlist, word_fragment):\nreturn any(w.startswith(word_fragment) for w in wordlist)\n</code>\n</pre>\n", "senID": 5}, {"text": ["I previously had:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n wordlist = [w for w in wordlist if w.startswith(word_fragment)]\n</code>\n</pre>\n", "senID": 7}, {"text": ["(from here) to narrow the list down to the list of valid words that start with that fragment and consider it a loss if wordlist is empty.", "The reason that I took this approach was that I (incorrectly, see below) thought that this would save time, as subsequent lookups would only have to search a smaller list. "], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4822840/python-algorithm-for-the-game-ghost-need-a-way-to-intelligently-look-up-all"}]}, {"text": ["It occurred to me that this is going through each item in the original wordlist (38,000-odd words) checking the start of each.", "This seems silly when wordlist is ordered, and the comprehension could stop once it hits something that is after the word fragment.", "I tried this:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n newlist = []\nfor w in wordlist:\n    if w[:len(word_fragment)] &gt; word_fragment:\n        # Take advantage of the fact that the list is sorted\n        break\n    if w.startswith(word_fragment):\n        newlist.append(w)\nreturn newlist\n</code>\n</pre>\n", "senID": 10}, {"text": ["but that is about the same speed, which I thought may be because list comprehensions run as compiled code?"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["I then thought that more efficient again would be some form of binary search in the list to find the block of matching words.", "Is this the way to go, or am I missing something really obvious?"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Clearly it isn't really a big deal in this case, but I'm just starting out with programming and want to do things properly."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["UPDATE:"], "childNum": 0, "tag": "h2", "senID": 14, "childList": []}, {"text": ["I have since tested the below suggestions with a simple test script.", "While Peter's binary search/bisect would clearly be better for a single run, I was interested in whether the narrowing list would win over a series of fragments.", "In fact, it did not:"], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "simple test script", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pastebin.com/sCd4424k"}]}, {"code": "<pre>\n<code>\n The totals for all strings \"p\", \"py\", \"pyt\", \"pyth\", \"pytho\" are as follows:\nIn total, Peter's simple test took 0.175472736359\nIn total, Peter's bisect left test took 9.36985015869e-05\nIn total, the list comprehension took 0.0499348640442\nIn total, Neil G's bisect took 0.000373601913452\n</code>\n</pre>\n", "senID": 16}, {"text": ["The overhead of creating a second list etc clearly took more time than searching the longer list.", "In hindsight, this was likely the best approach regardless, as the \"reducing list\" approach increased the time for the first run, which was the worst case scenario. "], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "increased", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Thanks all for some excellent suggestions, and well done Peter for the best answer!!"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}]