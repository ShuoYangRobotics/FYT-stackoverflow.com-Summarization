[{"text": ["Clean and type-safe state machine implementation in a statically typed language?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I implemented a simple state machine in Python:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import time\n\ndef a():\n    print \"a()\"\n    return b\n\ndef b():\n    print \"b()\"\n    return c\n\ndef c():\n    print \"c()\"\n    return a\n\n\nif __name__ == \"__main__\":\n    state = a\n    while True:\n        state = state()\n        time.sleep(1)\n</code>\n</pre>\n", "senID": 2}, {"text": ["I wanted to port it to C, because it wasn't fast enough.", "But C doesn't let me make a function that returns a function of the same type.", "I tried making the function of this type: typedef *fn(fn)(), but it doesn't work, so I had to use a structure instead.", "Now the code is very ugly!"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "typedef *fn(fn)()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n #include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\ntypedef struct fn {\n    struct fn (*f)(void);\n} fn_t;\n\nfn_t a(void);\nfn_t b(void);\nfn_t c(void);\n\nfn_t a(void)\n{\n    fn_t f = {b};\n\n    (void)printf(\"a()\\n\");\n\n    return f;\n}\n\nfn_t b(void)\n{\n    fn_t f = {c};\n\n    (void)printf(\"b()\\n\");\n\n    return f;\n}\n\nfn_t c(void)\n{\n    fn_t f = {a};\n\n    (void)printf(\"c()\\n\");\n\n    return f;\n}\n\nint main(void)\n{\n    fn_t state = {a};\n\n    for(;; (void)sleep(1)) state = state.f();\n\n    return EXIT_SUCCESS;\n}\n</code>\n</pre>\n", "senID": 4}, {"text": ["So I figured it's a problem with C's broken type system.", "So I used a language with a real type system (Haskell), but the same problem happens.", "I can't just do something like:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n type Fn = IO Fn\na :: Fn\na = print \"a()\" &gt;&gt; return b\nb :: Fn\nb = print \"b()\" &gt;&gt; return c\nc :: Fn\nc = print \"c()\" &gt;&gt; return a\n</code>\n</pre>\n", "senID": 6}, {"text": ["I get the error, Cycle in type synonym declarations."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Cycle in type synonym declarations", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So I have to make some wrapper the same way I did for the C code like this:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n import Control.Monad\nimport System.Posix\n\ndata Fn = Fn (IO Fn)\n\na :: IO Fn\na = print \"a()\" &gt;&gt; return (Fn b)\n\nb :: IO Fn\nb = print \"b()\" &gt;&gt; return (Fn c)\n\nc :: IO Fn\nc = print \"c()\" &gt;&gt; return (Fn a)\n\nrun = foldM (\\(Fn f) () -&gt; sleep 1 &gt;&gt; f) (Fn a) (repeat ())\n</code>\n</pre>\n", "senID": 9}, {"text": ["Why is it so hard to make a state machine in a statically typed language?", "I have to make unnecessary overhead in statically typed languages as well.", "Dynamically typed languages don't have this problem.", "Is there an easier way to do it in a statically typed language?"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}]