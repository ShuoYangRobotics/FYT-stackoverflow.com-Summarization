[{"text": ["how to avoid substrings"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I currently process sections of a string like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for (i, j) in huge_list_of_indices:\n    process(huge_text_block[i:j])\n</code>\n</pre>\n", "senID": 2}, {"text": ["I want to avoid the overhead of generating these temporary substrings.", "Any ideas?", "Perhaps a wrapper that somehow uses index offsets?", "This is currently my bottleneck."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Note that process() is another python module that expects a string as input."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "process()", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["A few people doubt there is a problem.", "Here are some sample results:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import time\nimport string\ntext = string.letters * 1000\n\ndef timeit(fn):\n    t1 = time.time()\n    for i in range(len(text)):\n        fn(i)\n    t2 = time.time()\n    print '%s took %0.3f ms' % (fn.func_name, (t2-t1) * 1000)\n\ndef test_1(i):\n    return text[i:]\n\ndef test_2(i):\n    return text[:]\n\ndef test_3(i):\n    return text\n\ntimeit(test_1)\ntimeit(test_2)\ntimeit(test_3)\n</code>\n</pre>\n", "senID": 7}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n test_1 took 972.046 ms\ntest_2 took 47.620 ms\ntest_3 took 43.457 ms\n</code>\n</pre>\n", "senID": 9}]