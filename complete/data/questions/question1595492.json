[{"text": ["blocks - send input to python subprocess pipeline"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I'm testing subprocesses pipelines with python.", "I'm aware that I can do what the programs below do in python directly, but that's not the point.", "I just want to test the pipeline so I know how to use it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["My system is Linux Ubuntu 9.04 with default python 2.6."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I started with this documentation example."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "documentation example", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/subprocess.html#replacing-shell-pipeline"}]}, {"code": "<pre>\n<code>\n from subprocess import Popen, PIPE\np1 = Popen([\"grep\", \"-v\", \"not\"], stdout=PIPE)\np2 = Popen([\"cut\", \"-c\", \"1-10\"], stdin=p1.stdout, stdout=PIPE)\noutput = p2.communicate()[0]\nprint output\n</code>\n</pre>\n", "senID": 4}, {"text": ["That works, but since p1's stdin is not being redirected, I have to type stuff in the terminal to feed the pipe.", "When I type ^D closing stdin, I get the output I want."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "p1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "stdin", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "^D", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["However, I want to send data to the pipe using a python string variable.", "First I tried writing on stdin:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n p1 = Popen([\"grep\", \"-v\", \"not\"], stdin=PIPE, stdout=PIPE)\np2 = Popen([\"cut\", \"-c\", \"1-10\"], stdin=p1.stdout, stdout=PIPE)\np1.stdin.write('test\\n')\noutput = p2.communicate()[0] # blocks forever here\n</code>\n</pre>\n", "senID": 7}, {"text": ["Didn't work.", "I tried using p2.stdout.read() instead on last line, but it also blocks.", "I added p1.stdin.flush() and p1.stdin.close() but it didn't work either.", "I Then I moved to communicate:"], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "p2.stdout.read()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "p1.stdin.flush()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "p1.stdin.close()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n p1 = Popen([\"grep\", \"-v\", \"not\"], stdin=PIPE, stdout=PIPE)\np2 = Popen([\"cut\", \"-c\", \"1-10\"], stdin=p1.stdout, stdout=PIPE)\np1.communicate('test\\n') # blocks forever here\noutput = p2.communicate()[0]\n</code>\n</pre>\n", "senID": 9}, {"text": ["So that's still not it."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["I noticed that running a single process (like p1 above, removing p2) works perfectly.", "And passing a file handle to p1 (stdin=open(...)) also works.", "So the problem is:"], "childNum": 4, "tag": "p", "senID": 11, "childList": [{"text": "p1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "p2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "p1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "stdin=open(...)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Is it possible to pass data to a pipeline of 2 or more subprocesses in python, without blocking?", "Why not?"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["I'm aware I could run a shell and run the pipeline in the shell, but that's not what I want."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"tag": "hr", "senID": 14}, {"text": ["UPDATE 1: Following Aaron Digulla's hint below I'm now trying to use threads to make it work."], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "UPDATE 1", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["First I've tried running p1.communicate on a thread."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n p1 = Popen([\"grep\", \"-v\", \"not\"], stdin=PIPE, stdout=PIPE)\np2 = Popen([\"cut\", \"-c\", \"1-10\"], stdin=p1.stdout, stdout=PIPE)\nt = threading.Thread(target=p1.communicate, args=('some data\\n',))\nt.start()\noutput = p2.communicate()[0] # blocks forever here\n</code>\n</pre>\n", "senID": 17}, {"text": ["Okay, didn't work.", "Tried other combinations like changing it to .write() and also p2.read().", "Nothing.", "Now let's try the opposite approach:"], "childNum": 2, "tag": "p", "senID": 18, "childList": [{"text": ".write()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "p2.read()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def get_output(subp):\n    output = subp.communicate()[0] # blocks on thread\n    print 'GOT:', output\n\np1 = Popen([\"grep\", \"-v\", \"not\"], stdin=PIPE, stdout=PIPE)\np2 = Popen([\"cut\", \"-c\", \"1-10\"], stdin=p1.stdout, stdout=PIPE)\nt = threading.Thread(target=get_output, args=(p2,)) \nt.start()\np1.communicate('data\\n') # blocks here.\nt.join()\n</code>\n</pre>\n", "senID": 19}, {"text": ["code ends up blocking somewhere.", "Either in the spawned thread, or in the main thread, or both.", "So it didn't work.", "If you know how to make it work it would make easier if you can provide working code.", "I'm trying here."], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"tag": "hr", "senID": 21}, {"text": ["UPDATE 2"], "childNum": 1, "tag": "p", "senID": 22, "childList": [{"text": "UPDATE 2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Paul Du Bois answered below with some information, so I did more tests.", "I've read entire subprocess.py module and got how it works.", "So I tried applying exactly that to code."], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "subprocess.py", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I'm on linux, but since I was testing with threads, my first approach was to replicate the exact windows threading code seen on subprocess.py's communicate() method, but for two processes instead of one.", "Here's the entire listing of what I tried:"], "childNum": 2, "tag": "p", "senID": 24, "childList": [{"text": "subprocess.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "communicate()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import os\nfrom subprocess import Popen, PIPE\nimport threading\n\ndef get_output(fobj, buffer):\n    while True:\n        chunk = fobj.read() # BLOCKS HERE\n        if not chunk:\n            break\n        buffer.append(chunk)\n\np1 = Popen([\"grep\", \"-v\", \"not\"], stdin=PIPE, stdout=PIPE)\np2 = Popen([\"cut\", \"-c\", \"1-10\"], stdin=p1.stdout, stdout=PIPE)\n\nb = [] # create a buffer\nt = threading.Thread(target=get_output, args=(p2.stdout, b))\nt.start() # start reading thread\n\nfor x in xrange(100000):\n    p1.stdin.write('hello world\\n') # write data\n    p1.stdin.flush()\np1.stdin.close() # close input...\nt.join()\n</code>\n</pre>\n", "senID": 25}, {"text": ["Well.", "It didn't work.", "Even after p1.stdin.close() was called, p2.stdout.read() still blocks."], "childNum": 2, "tag": "p", "senID": 26, "childList": [{"text": "p1.stdin.close()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "p2.stdout.read()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Then I tried the posix code on subprocess.py:"], "childNum": 1, "tag": "p", "senID": 27, "childList": [{"text": "subprocess.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import os\nfrom subprocess import Popen, PIPE\nimport select\n\np1 = Popen([\"grep\", \"-v\", \"not\"], stdin=PIPE, stdout=PIPE)\np2 = Popen([\"cut\", \"-c\", \"1-10\"], stdin=p1.stdout, stdout=PIPE)\n\nnumwrites = 100000\nto_read = [p2.stdout]\nto_write = [p1.stdin]\nb = [] # create buffer\n\nwhile to_read or to_write:\n    read_now, write_now, xlist = select.select(to_read, to_write, [])\n    if read_now:\n        data = os.read(p2.stdout.fileno(), 1024)\n        if not data:\n            p2.stdout.close()\n            to_read = []\n        else:\n            b.append(data)\n\n    if write_now:\n        if numwrites &gt; 0:\n            numwrites -= 1\n            p1.stdin.write('hello world!\\n'); p1.stdin.flush()\n        else:\n            p1.stdin.close()\n            to_write = []\n\nprint b\n</code>\n</pre>\n", "senID": 28}, {"text": ["Also blocks on select.select().", "By spreading prints around, I found out this:"], "childNum": 2, "tag": "p", "senID": 29, "childList": [{"text": "select.select()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "print", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"tag": "ul", "num": 5, "lis": [{"text": "Reading is working. Code reads many times during execution.", "tag": "none", "senID": 30}, {"text": "Writing is also working. Data is written to ", "tag": "none", "senID": 31}, {"text": "At the end of ", "tag": "none", "senID": 32}, {"text": "When ", "tag": "none", "senID": 33}, {"text": ["os.read()"], "childNum": 0, "tag": "code", "senID": 34, "childList": []}]}, {"text": ["Conclusion from both tests:  Closing the stdin of the first process on the pipeline (grep in the example) is not making it dump its buffered output to the next and die."], "childNum": 3, "tag": "p", "senID": 35, "childList": [{"text": "Conclusion from both tests", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "stdin", "childNum": 0, "tag": "code", "childList": []}, {"text": "grep", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["No way to make it work?"], "childNum": 0, "tag": "p", "senID": 36, "childList": []}, {"text": ["PS: I don't want to use a temporary file, I've already tested with files and I know it works.", "And I don't want to use windows."], "childNum": 0, "tag": "p", "senID": 37, "childList": []}]