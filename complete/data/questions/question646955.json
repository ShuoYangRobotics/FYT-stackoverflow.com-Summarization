[{"text": ["How to tell whether a file is executable on Windows in Python?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I'm writing grepath utility that finds executables in %PATH% that match a pattern.", "I need to define whether given filename in the path is executable (emphasis is on command line scripts)."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "grepath", "tag": "a", "pos": 0, "childList": [{"text": "grepath", "tag": "code"}], "childNum": 1, "href": "http://gist.github.com/79233"}, {"text": "grepath", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "%PATH%", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Based on \"Tell if a file is executable\" I've got:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "\"Tell if a file is executable\"", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://timgolden.me.uk/python/win32%5Fhow%5Fdo%5Fi/tell-if-a-file-is-executable.html"}]}, {"code": "<pre>\n<code>\n import os\nfrom pywintypes import error\nfrom win32api   import FindExecutable, GetLongPathName\n\ndef is_executable_win(path):\n    try:\n        _, executable = FindExecutable(path)\n        ext = lambda p: os.path.splitext(p)[1].lower()\n        if (ext(path) == ext(executable) # reject *.cmd~, *.bat~ cases\n            and samefile(GetLongPathName(executable), path)):\n            return True\n        # path is a document with assoc. check whether it has extension\n        # from %PATHEXT% \n        pathexts = os.environ.get('PATHEXT', '').split(os.pathsep)\n        return any(ext(path) == e.lower() for e in pathexts)\n    except error:\n        return None # not an exe or a document with assoc.\n</code>\n</pre>\n", "senID": 3}, {"text": ["Where samefile is:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "samefile", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n try: samefile = os.path.samefile\nexcept AttributeError:    \n    def samefile(path1, path2):\n        rp = lambda p: os.path.realpath(os.path.normcase(p))\n        return rp(path1) == rp(path2)\n</code>\n</pre>\n", "senID": 5}, {"text": ["How is_executable_win could be improved in the given context?", "What functions from Win32 API could help?"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "is_executable_win", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["P.S."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "time performance doesn't matter", "tag": "none", "senID": 8}, {"text": ["subst"], "childNum": 0, "tag": "code", "senID": 9, "childList": []}, {"text": "C++ answer is OK if it uses functions available on Windows XP", "tag": "none", "senID": 10}]}, {"tag": "ul", "num": 5, "lis": [{"text": ["notepad.exe"], "childNum": 0, "tag": "code", "senID": 11, "childList": []}, {"text": ["which.py is executable if it is associated with some executable (e.g., python.exe) and .PY is in %PATHEXT% i.e., 'C:\\&gt; which' could start:"], "childNum": 4, "tag": "p", "senID": 12, "childList": [{"text": "which.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".PY", "childNum": 0, "tag": "code", "childList": []}, {"text": "%PATHEXT%", "childNum": 0, "tag": "code", "childList": []}, {"text": "'C:\\&gt; which'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["somefile.doc most probably is not executable (when it is associated with Word for example)"], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "somefile.doc", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["another_file.txt"], "childNum": 0, "tag": "code", "senID": 14, "childList": []}, {"text": ["ack.pl"], "childNum": 0, "tag": "code", "senID": 15, "childList": []}]}, {"code": "<pre>\n<code>\n def is_executable_win_destructive(path):\n    #NOTE: it assumes `path` &lt;-&gt; `barename` for the sake of example\n    barename = os.path.splitext(os.path.basename(path))[0]\n    p = Popen(barename, stdout=PIPE, stderr=PIPE, shell=True)\n    stdout, stderr = p.communicate()\n    return p.poll() != 1 or stdout != '' or stderr != error_message(barename)\n</code>\n</pre>\n", "senID": 16}, {"text": ["Where error_message() depends on language.", "English version is:"], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "error_message()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def error_message(barename):\n    return \"'%(barename)s' is not recognized as an internal\" \\\n           \" or external\\r\\ncommand, operable program or batch file.\\r\\n\" \\\n           %  dict(barename=barename)\n</code>\n</pre>\n", "senID": 18}, {"text": ["If is_executable_win_destructive() returns when it defines whether the path points to an  executable for the purpose of this question."], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "is_executable_win_destructive()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; path = r\"c:\\docs\\somefile.doc\"\n&gt;&gt;&gt; barename = \"somefile\"\n</code>\n</pre>\n", "senID": 21}, {"text": ["After that it executes %COMSPEC% (cmd.exe by default):"], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"code": "<pre>\n<code>\n c:\\cwd&gt; cmd.exe /c somefile\n</code>\n</pre>\n", "senID": 23}, {"text": ["If output looks like this:"], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"code": "<pre>\n'somefile' is not recognized as an internal or external\ncommand, operable program or batch file.\n</pre>\n", "senID": 25}, {"text": ["Then the path is not an executable else it is (lets assume there is one-to-one correspondence between path and barename for the sake of example)."], "childNum": 3, "tag": "p", "senID": 26, "childList": [{"text": "path", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "path", "childNum": 0, "tag": "code", "childList": []}, {"text": "barename", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Another example:"], "childNum": 0, "tag": "p", "senID": 27, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; path = r'c:\\bin\\grepath.py'\n&gt;&gt;&gt; barename = 'grepath'\n</code>\n</pre>\n", "senID": 28}, {"text": ["If .PY in %PATHEXT% and c:\\bin is in %PATH% then:"], "childNum": 4, "tag": "p", "senID": 29, "childList": [{"text": ".PY", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "%PATHEXT%", "childNum": 0, "tag": "code", "childList": []}, {"text": "c:\\bin", "childNum": 0, "tag": "code", "childList": []}, {"text": "%PATH%", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n c:\\docs&gt; grepath\nUsage:\n  grepath.py [options] PATTERN\n  grepath.py [options] -e PATTERN\n\ngrepath.py: error: incorrect number of arguments\n</code>\n</pre>\n", "senID": 30}, {"text": ["The above output is not equal to error_message(barename) therefore 'c:\\bin\\grepath.py' is an \"executable\"."], "childNum": 2, "tag": "p", "senID": 31, "childList": [{"text": "error_message(barename)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'c:\\bin\\grepath.py'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So the question is how to find out whether the path will produce the error without actually running it?", "What Win32 API function and what conditions used to trigger the 'is not recognized as an internal..' error?"], "childNum": 1, "tag": "p", "senID": 32, "childList": [{"text": "path", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]