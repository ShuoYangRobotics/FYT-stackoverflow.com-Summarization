[{"text": ["Creating a singleton in python"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["This question is not for the discussion of whether or not the Singleton design pattern is desirable, is an anti-pattern, or for any religious wars, but to discuss how this pattern is best implemented in python in such a way that is most pythonic.", "In this instance I define 'most pythonic' to mean that it follows the 'principle of least astonishment'"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "This question is not for the discussion of whether or not the Singleton design pattern is desirable, is an anti-pattern, or for any religious wars, but to discuss how this pattern is best implemented in python in such a way that is most pythonic. In this instance I define 'most pythonic' to mean that it follows the 'principle of least astonishment'", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["I have multiple classes which would become singletons my use-case is for a logger, but this is not important.", "I do not wish to clutter several classes with added gumph when I can simply inherit or decorate.", "suitable methods best methods:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Method 1: A decorator"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def singleton(class_):\n  instances = {}\n  def getinstance(*args, **kwargs):\n    if class_ not in instances:\n        instances[class_] = class_(*args, **kwargs)\n    return instances[class_]\n  return getinstance\n\n@singleton\nclass MyClass(BaseClass):\n  pass\n</code>\n</pre>\n", "senID": 4}, {"text": ["Pros"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "Decorators are additive in a way that is often more intuitive than multiple inheritance.", "tag": "none", "senID": 6}]}, {"text": ["Cons"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "While objects created using MyClass() would be true singleton objects, MyClass itself is a a function, not a class, so you cannot call class methods from it. Also for ", "tag": "none", "senID": 8}]}, {"text": ["Method 2: A base class"], "childNum": 0, "tag": "h2", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n class Singleton(object):\n  _instance = None\n  def __new__(class_, *args, **kwargs):\n    if not isinstance(class_._instance, class_):\n        class_._instance = object.__new__(class_, *args, **kwargs)\n    return class_._instance\n\nclass MyClass(Singleton, BaseClass):\n  pass\n</code>\n</pre>\n", "senID": 10}, {"text": ["Pros"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "It's a true class", "tag": "none", "senID": 12}]}, {"text": ["Cons"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "Multiple inheritance - eugh! ", "tag": "none", "senID": 14}]}, {"text": ["Method 3: A metaclass"], "childNum": 1, "tag": "h2", "senID": 15, "childList": [{"text": "metaclass", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python"}]}, {"code": "<pre>\n<code>\n class Singleton(type):\n    _instances = {}\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass MyClass(BaseClass):\n    __metaclass__ = Singleton\n</code>\n</pre>\n", "senID": 16}, {"text": ["Pros"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "It's a true class", "tag": "none", "senID": 18}, {"text": "Auto-magically covers inheritance", "tag": "none", "senID": 19}, {"text": "Uses ", "tag": "none", "senID": 20}]}, {"text": ["Cons"], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "Are there any?", "tag": "none", "senID": 22}]}, {"text": ["Method 4: decorator returning a class with the same name"], "childNum": 0, "tag": "h2", "senID": 23, "childList": []}, {"code": "<pre>\n<code>\n def singleton(class_):\n  class class_w(class_):\n    _instance = None\n    def __new__(class_, *args, **kwargs):\n      if class_w._instance is None:\n          class_w._instance = super(class_w, \n                                    class_).__new__(class_, \n                                                    *args, \n                                                    **kwargs)\n          class_w._instance._sealed = False\n      return class_w._instance\ndef __init__(self, *args, **kwargs):\n      if self._sealed:\n    return\n      super(class_w, self).__init__(*args, **kwargs)\n      self._sealed = True\n  class_w.__name__ = class_.__name__\n    return class_w\n\n@singleton\nclass MyClass(BaseClass):\n    pass\n</code>\n</pre>\n", "senID": 24}, {"text": ["Pros"], "childNum": 0, "tag": "p", "senID": 25, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "It's a true class", "tag": "none", "senID": 26}, {"text": "Auto-magically covers inheritance", "tag": "none", "senID": 27}]}, {"text": ["Cons"], "childNum": 0, "tag": "p", "senID": 28, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Is there not an overhead for creating each new class? Here we are creating two classes for each class we wish to make a singleton. While this is fine in my case I worry that this might not scale. Of course there is a matter of debate as to whether it aught to be too easy to scale this pattern...", "tag": "none", "senID": 29}, {"text": "What is the point of the ", "tag": "none", "senID": 30}, {"text": "Can't call methods of the same name on base classes using ", "tag": "none", "senID": 31}]}]