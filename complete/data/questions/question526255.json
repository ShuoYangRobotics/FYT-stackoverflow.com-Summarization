[{"text": ["Probability distribution in Python"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I have a bunch of keys that each have an unlikeliness variable.", "I want to randomly choose one of these keys, yet I want it to be more unlikely for unlikely (key, values) to be chosen than a less unlikely (a more likely) object.", "I am wondering if you would have any suggestions, preferably an existing python module that I could use, else I will need to make it myself."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I have checked out the random module; it does not seem to provide this."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I have to make such choices many millions of times for 1000 different sets of objects each containing 2,455 objects.", "Each set will exchange objects among each other so the random chooser needs to be dynamic.", "With 1000 sets of 2,433 objects, that is 2,433 million objects; low memory consumption is crucial.", "And since these choices are not the bulk of the algorithm, I need this process to be quite fast; CPU-time is limited."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Thx  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Update:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Ok, I tried to consider your suggestions wisely, but time is so limited... "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I looked at the binary search tree approach and it seems too risky (complex and complicated).", "The other suggestions all resemble the ActiveState recipe.", "I took it and modified it a little in the hope of making more efficient:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def windex(dict, sum, max):\n    '''an attempt to make a random.choose() function that makes\n    weighted choices accepts a dictionary with the item_key and\n    certainty_value as a pair like:\n    &gt;&gt;&gt; x = [('one', 20), ('two', 2), ('three', 50)], the\n    maximum certainty value (max) and the sum of all certainties.'''\n    n = random.uniform(0, 1)\n    sum = max*len(list)-sum \n    for key, certainty in dict.iteritems():\n        weight = float(max-certainty)/sum\n        if n &lt; weight:\n            break\n        n = n - weight\n    return key\n</code>\n</pre>\n", "senID": 8}, {"text": ["I am hoping to get an efficiency gain from dynamically maintaining the sum of certainties and the maximum certainty.", "Any further suggestions are welcome.", "You guys saves me so much time and effort, while increasing my effectiveness, it is crazy.", "Thx!", "Thx!", "Thx!"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Update2:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["I decided to make it more efficient by letting it choose more choices at once.", "This will result in an acceptable loss in precision in my algo for it is dynamic in nature.", "Anyway, here is what I have now:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def weightedChoices(dict, sum, max, choices=10):\n    '''an attempt to make a random.choose() function that makes\n    weighted choices accepts a dictionary with the item_key and\n    certainty_value as a pair like:\n    &gt;&gt;&gt; x = [('one', 20), ('two', 2), ('three', 50)], the\n    maximum certainty value (max) and the sum of all certainties.'''\n    list = [random.uniform(0, 1) for i in range(choices)]\n    (n, list) = relavate(list.sort())\n    keys = []\n    sum = max*len(list)-sum \n    for key, certainty in dict.iteritems():\n        weight = float(max-certainty)/sum\n        if n &lt; weight:\n            keys.append(key)\n            if list: (n, list) = relavate(list)\n            else: break\n        n = n - weight\n    return keys\ndef relavate(list):\n    min = list[0]\n    new = [l - min for l in list[1:]]\n    return (min, new)\n</code>\n</pre>\n", "senID": 12}, {"text": ["I haven't tried it out yet.", "If you have any comments/suggestions, please do not hesitate.", "Thx!"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["Update3:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["I have been working all day on a task-tailored version of Rex Logan's answer.", "Instead of a 2 arrays of objects and weights, it is actually a special dictionary class; which makes things quite complex since Rex's code generates a random index...", "I also coded a test case that kind of resembles what will happen in my algo (but I can't really know until I try!).", "The basic principle is: the more a key is randomly generated often, the more unlikely it will be generated again: "], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n import random, time\nimport psyco\npsyco.full()\n\nclass ProbDict():\n    \"\"\"\n    Modified version of Rex Logans RandomObject class. The more a key is randomly\n    chosen, the more unlikely it will further be randomly chosen. \n    \"\"\"\n    def __init__(self,keys_weights_values={}):\n        self._kw=keys_weights_values\n        self._keys=self._kw.keys()\n        self._len=len(self._keys)\n        self._findSeniors()\n        self._effort = 0.15\n        self._fails = 0\n    def __iter__(self):\n        return self.next()\n    def __getitem__(self, key):\n        return self._kw[key]\n    def __setitem__(self, key, value):\n        self.append(key, value)\n    def __len__(self):\n        return self._len\n    def next(self):\n        key=self._key()\n        while key:\n            yield key\n            key = self._key()\n    def __contains__(self, key):\n        return key in self._kw\n    def items(self):\n        return self._kw.items()\n    def pop(self, key):  \n        try:\n            (w, value) = self._kw.pop(key)\n            self._len -=1\n            if w == self._seniorW:\n                self._seniors -= 1\n                if not self._seniors:\n                    #costly but unlikely:\n                    self._findSeniors()\n            return [w, value]\n        except KeyError:\n            return None\n    def popitem(self):\n        return self.pop(self._key())\n    def values(self):\n        values = []\n        for key in self._keys:\n            try:\n                values.append(self._kw[key][1])\n            except KeyError:\n                pass\n        return values\n    def weights(self):\n        weights = []\n        for key in self._keys:\n            try:\n                weights.append(self._kw[key][0])\n            except KeyError:\n                pass\n        return weights\n    def keys(self, imperfect=False):\n        if imperfect: return self._keys\n        return self._kw.keys()\n    def append(self, key, value=None):\n        if key not in self._kw:\n            self._len +=1\n            self._kw[key] = [0, value]\n            self._keys.append(key)\n        else:\n            self._kw[key][1]=value\n    def _key(self):\n        for i in range(int(self._effort*self._len)):\n            ri=random.randint(0,self._len-1) #choose a random object\n            rx=random.uniform(0,self._seniorW)\n            rkey = self._keys[ri]\n            try:\n                w = self._kw[rkey][0]\n                if rx &gt;= w: # test to see if that is the value we want\n                    w += 1\n                    self._warnSeniors(w)\n                    self._kw[rkey][0] = w\n                    return rkey\n            except KeyError:\n                self._keys.pop(ri)\n        # if you do not find one after 100 tries then just get a random one\n        self._fails += 1 #for confirming effectiveness only\n        for key in self._keys:\n            if key in self._kw:\n                w = self._kw[key][0] + 1\n                self._warnSeniors(w)\n                self._kw[key][0] = w\n                return key\n        return None\n    def _findSeniors(self):\n        '''this function finds the seniors, counts them and assess their age. It\n        is costly but unlikely.'''\n        seniorW = 0\n        seniors = 0\n        for w in self._kw.itervalues():\n            if w &gt;= seniorW:\n                if w == seniorW:\n                    seniors += 1\n                else:\n                    seniorsW = w\n                    seniors = 1\n        self._seniors = seniors\n        self._seniorW = seniorW\n    def _warnSeniors(self, w):\n        #a weight can only be incremented...good\n        if w &gt;= self._seniorW:\n            if w == self._seniorW:\n                self._seniors+=1\n            else:\n                self._seniors = 1\n                self._seniorW = w\ndef test():\n    #test code\n    iterations = 200000\n    size = 2500\n    nextkey = size \n\n\n    pd = ProbDict(dict([(i,[0,i]) for i in xrange(size)]))\n    start = time.clock()\n    for i in xrange(iterations):\n        key=pd._key()\n        w=pd[key][0]\n        if random.randint(0,1+pd._seniorW-w):\n            #the heavier the object, the more unlikely it will be removed\n            pd.pop(key)\n        probAppend = float(500+(size-len(pd)))/1000\n        if random.uniform(0,1) &lt; probAppend:\n            nextkey+=1\n            pd.append(nextkey)\n    print (time.clock()-start)*1000/iterations, \"msecs / iteration with\", pd._fails, \"failures /\", iterations, \"iterations\"\n    weights = pd.weights()\n    weights.sort()\n    print \"avg weight:\", float(sum(weights))/pd._len, max(weights), pd._seniorW, pd._seniors, len(pd), len(weights)\n    print weights\ntest()\n</code>\n</pre>\n", "senID": 16}, {"text": ["Any comments are still welcome.", "@Darius: your binary trees are too complex and complicated for me; and I do not think its leafs can be removed efficiently... Thx all"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}]