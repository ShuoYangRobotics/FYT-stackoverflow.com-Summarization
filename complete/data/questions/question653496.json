[{"text": ["How can I cluster a graph in Python?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Let G be a graph.", "So G is a set of nodes and set of links.", "I need to find a fast way to partition the graph.", "The graph I am now working has only 120*160 nodes, but I might soon be working on an equivalent problem, in another context (not medicine, but website development), with millions of nodes. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So, what I did was to store all the links into a graph matrix:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n M=numpy.mat(numpy.zeros((len(data.keys()),len(data.keys()))))\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now M holds a 1 in position s,t, if node s is connected to node t. I make sure M is symmetrical M[s,t]=M[t,s] and each node links to itself M[s,s]=1."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If I remember well if I multiply M with M, the results is a matrix that represents the graph that connects vertexes that are reached on through two steps."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["So I keep on multplying M with itself, until the number of zeros in the matrix do not decrease any longer.", "Now I have the list of the connected components.", "And now I need to cluster this matrix."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Up to now I am pretty satisfied with the algorithm.", "I think it is easy, elegant, and reasonably fast.", "I am having trouble with this part."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Essentially I need to split this graph into its connected components."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["I can go through all the nodes, and see what are they connected to."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["But what about sorting the matrix reordering the lines.", "But I don't know if it is possible to do it."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["What follows is the code so far:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def findzeros(M):\n    nZeros=0\n    for t in M.flat:\n        if not t:\n            nZeros+=1\n    return nZeros\n\nM=numpy.mat(numpy.zeros((len(data.keys()),len(data.keys()))))    \nfor s in data.keys():\n    MatrixCells[s,s]=1\n    for t in data.keys():\n        if t&lt;s:\n            if (scipy.corrcoef(data[t],data[s])[0,1])&gt;threashold:\n                M[s,t]=1\n                M[t,s]=1\n\nnZeros=findzeros(M)\nM2=M*M\nnZeros2=findzeros(M2)\n\nwhile (nZeros-nZeros2):\n    nZeros=nZeros2\n    M=M2\n    M2=M*M\n    nZeros2=findzeros(M2)\n</code>\n</pre>\n", "senID": 12}, {"tag": "hr", "senID": 13}, {"text": ["It has been suggested that I use SVD decomposition.", "Here is a simple example of the problem on a 5x5 graph.", "We shall use this since with the 19200x19200 square matrix is not that easy to see the clusters."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n import numpy\nimport scipy\n\nM=numpy.mat(numpy.zeros((5,5)))\n\nM[1,3]=1\nM[3,1]=1\nM[1,1]=1\nM[2,2]=1\nM[3,3]=1\nM[4,4]=1\nM[0,0]=1\n\nprint M\n\nu,s,vh = numpy.linalg.linalg.svd(M)\nprint u\nprint s\nprint vh\n</code>\n</pre>\n", "senID": 15}, {"text": ["Essentially there are 4 clusters here: (0),(1,3),(2),(4)\nBut I still don't see how the svn can help in this context."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}]