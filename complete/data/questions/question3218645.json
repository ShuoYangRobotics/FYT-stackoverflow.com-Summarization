[{"text": ["Handling large dense matrices in python"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Basically, what is the best way to go about storing and using dense matrices in python?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I have a project that generates similarity metrics between every item in an array."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Each item is a custom class, and stores a pointer to the other class and a number representing it's \"closeness\" to that class."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Right now, it works brilliantly up to about ~8000 items, after which it fails with a out-of-memory error.", "Basically, if you assume that each comparison uses ~30 (seems accurate based on testing) bytes to store the similarity, that means the total required memory is:\nnumItems^2 * itemSize = Memory\nSo the memory usage is exponential based on the number of items.", "In my case, the memory size is ~30 bytes per link, so:\n8000 * 8000 * 30 = 1,920,000,000 bytes, or 1.9 GB\nwhich is right at the memory limit for a single thread."], "childNum": 8, "tag": "p", "senID": 4, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "numItems^2 * itemSize = Memory", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "8000 * 8000 * 30 = 1,920,000,000 bytes, or 1.9 GB", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["It seems to me that there has to be a more effective way of doing this.", "I've looked at memmapping, but it's already computationally intensive just to generate the similarity values, and bottlenecking it all through a harddrive seems a little ridiculous."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Edit\nI've looked at numpy and scipy.", "Unfortunatly, they don't support very large arrays either.  "], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; np.zeros((20000,20000), dtype=np.uint16)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nMemoryError\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 7}, {"text": ["Further Edit\nNumpy seems to be popular.", "However, numpy won't really do what I want, at least without another abstraction layer."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "Further Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"text": ["I don't want to store numbers, I want to store reference to classes.", "Numpy supports objects, but that doesn't really address the array size issues.", "I brought up numpy just as an example of what isn't working."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "want", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "isn't", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Any advice?"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Edit Well, I wound up just rewriting all the logic so it no longer stores any redundant values, reducing the memory useage from O*n^2 to O*((n*(n-1))/2)."], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "O*n^2", "childNum": 0, "tag": "code", "childList": []}, {"text": "O*((n*(n-1))/2)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Basically, this whole affair is a version of the handshake problem, so I've switched from storing all links to only a single version of each link."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "handshake problem", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Handshake_problem"}]}, {"text": ["It's not a complete solution, but I generally don't have any datasets large enough to overflow it, so I think it will work out.", "PyTables is really interesting, but I don't know any SQL, and there doesn't appear to be any nice traditional slicing or index based way to access the table data.", "I may revisit the issue in the future."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}]