[{"text": ["KenKen puzzle addends: REDUX A (corrected) non-recursive algorithm"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["This question relates to those parts of the KenKen Latin Square puzzles which ask you to find all possible combinations of ncells numbers with values x such that 1 &lt;= x &lt;= maxval and x(1) + ... + x(ncells) = targetsum.", "Having tested several of the more promising answers, I'm going to award the answer-prize to Lennart Regebro, because:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["chrispy contributed an algorithm that seems equivalent to Lennart's, but 5 hrs later, sooo, first to the wire gets it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["A remark:  Alex Martelli's bare-bones recursive algorithm is an example of making every possible combination and throwing them all at a sieve and seeing which go through the holes.", "This approach takes 20+ times longer than Lennart's or mine.", "(Jack up the input to max_val = 100, n_cells = 5, target_sum = 250 and on my box it's 18 secs vs. 8+ mins.", ")  Moral:  Not generating every possible combination is good."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Another remark: Lennart's and my routines generate the same answers in the same order.", "Are they in fact the same algorithm seen from different angles?", "I don't know."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "the same answers in the same order", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Something occurs to me.", "If you sort the answers, starting, say, with (8,8,2,1,1) and ending with (4,4,4,4,4) (what you get with max_val=8, n_cells=5, target_sum=20), the series forms kind of a \"slowest descent\", with the first ones being \"hot\" and the last one being \"cold\" and the greatest possible number of stages in between.", "Is this related to \"informational entropy\"?", "What's the proper metric for looking at it?", "Is there an algorithm that producs the combinations in descending (or ascending) order of heat?", "(This one doesn't, as far as I can see, although it's close over short stretches, looking at normalized std.", "dev."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Here's the Python routine:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n#filename: makeAddCombos.07.py -- stripped for StackOverflow\n\ndef initialize_combo( max_val, n_cells, target_sum):\n    \"\"\"returns combo\n    Starting from left, fills combo to max_val or an intermediate value from 1 up.  \n    E.g.:  Given max_val = 5, n_cells=4, target_sum = 11, creates [5,4,1,1].\n    \"\"\"\n    combo = []\n    #Put 1 in each cell.\n    combo += [1] * n_cells\n    need = target_sum - sum(combo)\n    #Fill as many cells as possible to max_val.\n    n_full_cells = need //(max_val - 1)\n    top_up = max_val - 1\n    for i in range( n_full_cells): combo[i] += top_up\n    need = target_sum - sum(combo)\n    # Then add the rest to next item.\n    if need &gt; 0:\n        combo[n_full_cells] += need\n    return combo\n#def initialize_combo()\n\ndef scrunch_left( combo):\n    \"\"\"returns (new_combo,done)\n    done   Boolean; if True, ignore new_combo, all done;\n            if Falso, new_combo is valid.\n\n    Starts a new combo list.  Scanning from right to left, looks for first\n    element at least 2 greater than right-end element.  \n    If one is found, decrements it, then scrunches all available counts on its\n    right up against its right-hand side.  Returns the modified combo.\n    If none found, (that is, either no step or single step of 1), process\n    done.\n    \"\"\"\n    new_combo = []\n    right_end = combo[-1]\n    length = len(combo)\n    c_range = range(length-1, -1, -1)\n    found_step_gt_1 = False\n    for index in c_range:\n        value = combo[index]\n        if (value - right_end) &gt; 1:\n            found_step_gt_1 = True\n            break\n    if not found_step_gt_1:\n        return ( new_combo,True)\n\n    if index &gt; 0:\n        new_combo += combo[:index]\n    ceil = combo[index] - 1\n    new_combo += [ceil]\n    new_combo += [1] * ((length - 1) - index)\n    need = sum(combo[index:]) - sum(new_combo[index:])\n    fill_height = ceil - 1\n    ndivf = need // fill_height\n    nmodf = need % fill_height\n    if ndivf &gt; 0:\n        for j in range(index + 1, index + ndivf + 1):\n            new_combo[j] += fill_height\n    if nmodf &gt; 0:\n        new_combo[index + ndivf + 1] += nmodf\n    return (new_combo, False)\n#def scrunch_left()\n\ndef make_combos_n_cells_ge_two( combos, max_val, n_cells, target_sum):\n    \"\"\"\n    Build combos, list of tuples of 2 or more addends.\n    \"\"\"\n    combo = initialize_combo( max_val, n_cells, target_sum)\n    combos.append( tuple( combo))\n    while True:\n        (combo, done) = scrunch_left( combo)\n        if done:\n            break\n        else:\n            combos.append( tuple( combo))\n    return combos\n#def make_combos_n_cells_ge_two()\n\nif __name__ == '__main__':\n\n    combos = []\n    max_val     = 8\n    n_cells     = 5\n    target_sum  = 20\n    if n_cells == 1: combos.append( (target_sum,))\n    else:\n        combos = make_combos_n_cells_ge_two( combos, max_val, n_cells, target_sum)\n    import pprint\n    pprint.pprint( combos)\n</code>\n</pre>\n", "senID": 7}]