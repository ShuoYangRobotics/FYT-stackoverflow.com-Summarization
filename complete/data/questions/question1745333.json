[{"text": ["Structured programming and Python generators?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Note: This question mutated a bit as people answered and forced me to \"raise the stakes\", as my trivial examples had trivial simplifications; rather than continue to mutate it here, I will repose the question when I have it clearer in my head, as per Alex's suggestion."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Note:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "hr", "senID": 2}, {"text": ["Python generators are a thing of beauty, but how can I easily break one down into modules (structured programming)?", "I effectively want PEP 380, or at least something comparable in syntax burden, but in existing Python (e.g.", "2.6)"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "PEP 380", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0380/"}]}, {"text": ["As an (admittedly stupid) example, take the following:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def sillyGenerator():\n  for i in xrange(10):\n    yield i*i\n  for i in xrange(12):\n    yield i*i\n  for i in xrange(8):\n    yield i*i\n</code>\n</pre>\n", "senID": 5}, {"text": ["Being an ardent believer in DRY, I spot the repeated pattern here and factor it out into a method:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def quadraticRange(n):\n  for i in xrange(n)\n    yield i*i\n\ndef sillyGenerator():\n  quadraticRange(10)\n  quadraticRange(12)\n  quadraticRange(8)\n</code>\n</pre>\n", "senID": 7}, {"text": ["...which of course doesn't work.", "The parent must call the new function in a loop, yielding the results:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def sillyGenerator():\n  for i in quadraticRange(10):\n    yield i\n  for i in quadraticRange(12):\n    yield i\n  for i in quadraticRange(8):\n    yield i\n</code>\n</pre>\n", "senID": 9}, {"text": ["...which is even longer than before!"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["If I want to push part of a generator into a function, I always need this rather verbose, two-line wrapper to call it.", "It gets worse if I want to support send():"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def sillyGeneratorRevisited():\n  g = subgenerator()\n  v = None\n  try:\n    while True:\n      v = yield g.send(v)\n  catch StopIteration:\n    pass\n  if v &lt; 4:\n    # ...\n  else:\n    # ...\n</code>\n</pre>\n", "senID": 12}, {"text": ["And that's not taking into account passing in exceptions.", "The same boilerplate every time!", "Yet one cannot apply DRY and factor this identical code into a function, because...you'd need the boilerplate to call it!", "What I want is something like:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n def sillyGenerator():\n  yield from quadraticRange(10)\n  yield from quadraticRange(12)\n  yield from quadraticRange(8)\n\ndef sillyGeneratorRevisited():\n  v = yield from subgenerator()\n  if v &lt; 4:\n    # ...\n  else:\n    # ...\n</code>\n</pre>\n", "senID": 14}, {"text": ["Does anyone have a solution to this problem?", "I have a first-pass attempt, but I'd like to know what others have come up with.", "Ultimately, any solution will have to tackle examples where the main generator performs complex logic based on the result of data sent into the generator, and potentially makes a very large number of calls to sub-generators: my use-case is generators used to implement long-running, complex state machines."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}]