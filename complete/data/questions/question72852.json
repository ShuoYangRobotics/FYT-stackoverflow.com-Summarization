[{"text": ["How to do relative imports in Python?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Imagine this directory structure:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n app/\n   __init__.py\n   sub1/\n      __init__.py\n      mod1.py\n   sub2/\n      __init__.py\n      mod2.py\n</code>\n</pre>\n", "senID": 2}, {"text": ["I'm coding mod1, and I need to import something from mod2.", "How should I do it?  "], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "mod1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "mod2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["I tried from ..sub2 import mod2 but I'm getting an \"Attempted relative import in non-package\"."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "from ..sub2 import mod2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I googled around but found only \"sys.path manipulation\" hacks.", "Isn't there a clean way?  "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "sys.path", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit: all my __init__.py's are currently empty  "], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "__init__.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit2: I'm trying to do this because sub2 contains classes that are shared across sub packages (sub1, subX, etc.", ")."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "sub1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "subX", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Edit3: The behaviour I'm looking for is the same as described in PEP 366 (thanks John B)"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "PEP 366", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0366/"}]}]