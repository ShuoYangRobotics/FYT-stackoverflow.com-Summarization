[{"text": ["Shortest hash in python to name cache files"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["What is the shortest hash (in filename-usable form, like a hexdigest) available in python?", "My application wants to save cache files for some objects.", "The objects must have unique repr() so they are used to 'seed' the filename.", "I want to produce a possibly unique filename for each object (not that many).", "They should not collide, but if they do my app will simply lack cache for that object (and will have to reindex that object's data, a minor cost for the application)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "cache files", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["So, if there is one collision we lose one cache file, but it is the collected savings of caching all objects makes the application startup much faster, so it does not matter much."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Right now I'm actually using abs(hash(repr(obj))); that's right, the string hash!", "Haven't found any collisions yet, but I would like to have a better hash function.", "hashlib.md5 is available in the python library, but the hexdigest is really long if put in a filename.", "Alternatives, with reasonable collision resistance?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Edit:\nUse case is like this:\nThe data loader gets a new instance of a data-carrying object.", "Unique types have unique repr.", "so if a cache file for hash(repr(obj)) exists, I unpickle that cache file and replace obj with the unpickled object.", "If there was a collision and the cache was a false match I notice.", "So if we don't have cache or have a false match, I instead init obj (reloading its data)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "hash(repr(obj))", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Conclusions (?"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Conclusions (?)", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["The str hash in python may be good enough, I was only worried about its collision resistance.", "But if I can hash 2**16 objects with it, it's going to be  more than good enough."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "2**16", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I found out how to take a hex hash (from any hash source) and store it compactly with base64:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n # 'h' is a string of hex digits \nbytes = \"\".join(chr(int(h[i:i+2], 16)) for i in xrange(0, len(h), 2))\nhashstr = base64.urlsafe_b64encode(bytes).rstrip(\"=\")\n</code>\n</pre>\n", "senID": 8}]