[{"text": ["How to add a custom implicit conversion to a C++ type in Boost::Python?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["In my C++ code I have a class Foo with many methods taking a Bar type variable as an argument:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Foo {\npublic:\n  void do_this(Bar b);\n  void do_that(Bar b);\n  /* ... */\n};\n</code>\n</pre>\n", "senID": 2}, {"text": ["Bar has a number of constructors that create a new object from many common types such as int, std::string, float, etc:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Bar {\npublic:\n  Bar(int i);\n  Bar(float f);\n  Bar(std::string s);\n  /* ... */\n};\n</code>\n</pre>\n", "senID": 4}, {"text": ["I wrapped this with Boost::Python and I'm now able to call my Foo methods using Python literals directly, as they get implicitly converted to Bar objects."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n f = Foo()\nf.do_this(5)\nf.do_that(\"hello\")\n</code>\n</pre>\n", "senID": 6}, {"text": ["Now, I would like to be able to use also other Python types, such as tuples, like this:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n f.do_that((1,2,3))\n</code>\n</pre>\n", "senID": 8}, {"text": ["But I don't want to touch the original Bar definition, and I don't want to pollute my C++ library with Boost::Python stuff.", "I want to write a wrapper function in my binding code, but I just can't understand if this is possible and what is the correct way for doing this."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["In other words: can I register a factory function to be used as an automatic conversion in Python?"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}]