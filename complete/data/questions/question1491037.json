[{"text": ["Mapping std::map to Python"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Sometimes it makes sense to have a key-ordered dictionary.", "In C++, this is often implemented with a Red-black tree.", "But any self-balancing binary search tree will do (fwiw, Knuth is particularly clear on this subject).", "The best solution I've been able to come up with so far is to take R. McGraw's AVL-tree type and create a wrapper class that basically implements the STL map interface (also counting on the handy ordering of pairs (two element tuples) in Python).", "Such a tuple basically corresponds to std::map::value_type."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "R. McGraw's AVL-tree type", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://sourceforge.net/projects/pyavl/"}]}, {"text": ["Yes, there's Python's bisect module, and while that is logarithmic at insertion time in the same way that self-balancing binary trees are logarithmic at insertion time (right?", "), frankly I just want an object.", "Called OrderedDict or something (and no, the Python 3.1 OrderedDict doesn't qualify -- that's for 'insertion-time' ordering -- and frankly what insertion-time ordering has to do with ordering is not quite obvious)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note, a key-ordered dictionary is highly useful in many industries (in finance for instance, it's ordinary to keep track of price books of data, which are basically ordered dictionaries of price -> quantity, aggregated order information, etc.", "). "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If anyone has any other ideas, that's great.", "All I know is I just got five million times smarter by Alex Martelli's 'answers' here.", "So I thought I'd ask."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]