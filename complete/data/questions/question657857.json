[{"text": ["Python : is it ok returning both boolean and string?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Original Question"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I have made a function which is waiting for a particular string to appear on a serial port, and returns all character read until the string was found, or false if not.", "This is quite convenient, but I was wondering if it is considered bad practice or not ?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Clarification :"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The primary goal is to wait for a particular string to appear in a given amount of time.", "Except for IO error, the possible outcome is True (the string did appear) or False\nThe secondary goal is to get the entire output, because there might be information that I would like to parse for before the actual answer that is looked for.", "I thought may be I could combine the primary and secondary goal in one return value."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "particular", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def MyFunc(s, timeout) :\n    test = get_some_input(timeout)\n    if test.endswith(s)\n        return test\n    else\n        return False\n</code>\n</pre>\n", "senID": 5}, {"text": ["Edit : Another proposed answer is to raise an exception.", "I don't think it is a good idea, because the timeout is an expected behaviour.", "I mean, if there is a parameter for specifying a timeout, then a timeout is a possible outcome, and not an exception."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Edit 2 :\nSince I need to store the input, maybe using a class is the right solution.", "The wait for function has a clear return value, yet the entire string that was read until timeout is also accessible."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n class Parser :\n        def __init__(self, sport_name):\n                self.currentMsg = ''\n                self.ser = serial.Serial(sport_name, 115200)\n        def WaitFor(self, s, timeOut=None):\n                self.ser.timeout = timeOut\n                self.currentMsg = ''\n                while self.currentMsg.endswith(s) != True :\n                        # should add a try catch here\n                        c=self.ser.read()\n                        if c != '' :\n                               self.currentMsg += c\n                        else :\n                                print 'timeout waiting for ' + s\n                                return False\n                return True\n</code>\n</pre>\n", "senID": 8}]