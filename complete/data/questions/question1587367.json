[{"text": ["Python/numpy tricky slicing problem"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I have a problem with some numpy stuff.", "I need a numpy array to behave in an unusual manner by returning a slice as a view of the data I have sliced, not a copy.", "So heres an example of what I want to do:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Say we have a simple array like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a = array([1, 0, 0, 0])\n</code>\n</pre>\n", "senID": 3}, {"text": ["I would like to update consecutive entries in the array (moving left to right) with the previous entry from the array, using syntax like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n a[1:] = a[0:3]\n</code>\n</pre>\n", "senID": 5}, {"text": ["This would get the following result:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n a = array([1, 1, 1, 1])\n</code>\n</pre>\n", "senID": 7}, {"text": ["Or something like this:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n a[1:] = 2*a[:3]\n# a = [1,2,4,8]\n</code>\n</pre>\n", "senID": 9}, {"text": ["To illustrate further I want the following kind of behaviour:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n for i in range(len(a)):\n    if i == 0 or i+1 == len(a): continue\n    a[i+1] = a[i]\n</code>\n</pre>\n", "senID": 11}, {"text": ["Except I want the speed of numpy."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["The default behavior of numpy is to take a copy of the slice, so what I actually get is this:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n a = array([1, 1, 0, 0])\n</code>\n</pre>\n", "senID": 14}, {"text": ["I already have this array as a subclass of the ndarray, so I can make further changes to it if need be, I just need the slice on the right hand side to be continually updated as it updates the slice on the left hand side. "], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["Am I dreaming or is this magic possible?"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["Update: This is all because I am trying to use Gauss-Seidel iteration to solve a linear algebra problem, more or less.", "It is a special case involving harmonic functions, I was trying to avoid going into this because its really not necessary and likely to confuse things further, but here goes."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["The algorithm is this:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n while not converged:\n    for i in range(len(u[:,0])):\n        for j in range(len(u[0,:])):\n            # skip over boundary entries, i,j == 0 or len(u)\n            u[i,j] = 0.25*(u[i-1,j] + u[i+1,j] + u[i, j-1] + u[i,j+1])\n</code>\n</pre>\n", "senID": 19}, {"text": ["Right?", "But you can do this two ways, Jacobi involves updating each element with its neighbours without considering updates you have already made until the while loop cycles, to do it in loops you would copy the array then update one array from the copied array.", "However Gauss-Seidel uses information you have already updated for each of the i-1 and j-1 entries, thus no need for a copy, the loop should essentially 'know' since the array has been re-evaluated after each single element update.", "That is to say, every time we call up an entry like u[i-1,j] or u[i,j-1] the information calculated in the previous loop will be there."], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"text": ["I want to replace this slow and ugly nested loop situation with one nice clean line of code using numpy slicing:"], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"code": "<pre>\n<code>\n u[1:-1,1:-1] = 0.25(u[:-2,1:-1] + u[2:,1:-1] + u[1:-1,:-2] + u[1:-1,2:])\n</code>\n</pre>\n", "senID": 22}, {"text": ["But the result is Jacobi iteration because when you take a slice: u[:,-2,1:-1] you copy the data, thus the slice is not aware of any updates made.", "Now numpy still loops right?", "Its not parallel its just a faster way to loop that looks like a parallel operation in python.", "I want to exploit this behaviour by sort of hacking numpy to return a pointer instead of a copy when I take a slice.", "Right?", "Then every time numpy loops, that slice will 'update' or really just replicate whatever happened in the update.", "To do this I need slices on both sides of the array to be pointers."], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"text": ["Anyway if there is some really really clever person out there that awesome, but I've pretty much resigned myself to believing the only answer is to loop in C."], "childNum": 0, "tag": "p", "senID": 24, "childList": []}]