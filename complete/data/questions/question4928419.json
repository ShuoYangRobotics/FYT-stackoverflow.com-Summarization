[{"text": ["Python override __getattr__ for nested assignment, but not for referencing?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Here's the behavior I'm looking for:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; o = SomeClass()\n&gt;&gt;&gt; # Works: \n&gt;&gt;&gt; o.foo.bar = 'bar' \n&gt;&gt;&gt; print o.foo.bar\n'bar'\n&gt;&gt;&gt; # The in-between object would be of type SomeClass as well:\n&gt;&gt;&gt; print o.foo \n&gt;&gt;&gt; &lt;__main__.SomeClass object at 0x7fea2f0ef810&gt;\n\n&gt;&gt;&gt; # I want referencing an unassigned attribute to fail: \n&gt;&gt;&gt; print o.baz\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 5, in &lt;module&gt;\n    print o.baz\nAttributeError: 'SomeClass' object has no attribute 'baz'\n</code>\n</pre>\n", "senID": 2}, {"text": ["In other words, I want to override __getattr__ and __setattr__ (and possibly __getattribute__) in such a way that work similarly to defaultdict, allowing assignment to arbitrary attributes, but if an attribute is just referenced but not assigned to, that it throws an AttributeError as it normally would. "], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "__getattr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__setattr__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__getattribute__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Is this possible?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]