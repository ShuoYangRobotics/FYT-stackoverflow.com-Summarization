[{"text": ["\"sorted 1-d iterator\" based on \"2-d iterator\" (Cartesian product of iterators)"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I'm looking for a clean way to do this in Python:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Let's say I have two iterators \"iter1\" and \"iter2\": perhaps a prime number generator, and itertools.count().", "I know a priori that both are are infinite and monotonically increasing.", "Now I want to take some simple operation of two args \"op\" (perhaps operator.add or operator.mul), and calculate every element of the first iterator with every element of the next, using said operation, then yield them one at a time, sorted.", "Obviously, this is an infinite sequence itself.", "(As mentioned in comment by @RyanThompson: this would be called the Cartesian Product of these sequences... or, more exactly, the 1d-sort of that product.", ") "], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "every element", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "every element", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "Cartesian Product", "tag": "a", "pos": 4, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Cartesian_product"}]}, {"text": ["What is the best way to:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "wrap-up \"iter1\", \"iter2\", and \"op\" in an iterable that itself yields the values in monotonically increasing output.", "tag": "none", "senID": 4}]}, {"text": ["Allowable simplifying assumptions:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "If it helps, we can assume op(a,b) >= a and op(a,b) >= b.", "tag": "none", "senID": 6}, {"text": "If it helps, we can assume op(a,b) > op(a,c) for all b > c.", "tag": "none", "senID": 7}]}, {"text": ["Also allowable:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "Also acceptable would be an iterator that yields values in \"generally increasing\" order... by which I mean the iterable could occasionally give me a number less than a previous one, but it would somehow make \"side information\" available (as via a method on the object) that would say \"I'm not guarenteeing the next value I give you will be greater than the one I just gave you, but I AM SURE that all future values will at least be greater than N.\".... and \"N\" itself is monotonically increasing.", "tag": "none", "senID": 9}]}, {"text": ["The only way I can think to do this is a sort of \"diagonalization\" process, where I keep an increasing number of partially processed iterables around, and \"look ahead\" for the minimum of all the possible next() values, and yield that.", "But this weird agglomeration of a heapq and a bunch of deques just seems outlandish, even before I start to code it."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Please: do not base your answer on the fact that my examples mentioned primes or count()....", "I have several uses for this very concept that are NOT related to primes and count()."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["UPDATE: OMG!", "What a great discussion!", "And some great answers with really thorough explanations.", "Thanks so much.", "StackOverflow rocks; you guys rock."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "UPDATE:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I'm going to delve in to each answer more thoroughly soon, and give the sample code a kick in the tires.", "From what I've read so far, my original suspicions are confirmed that there is no \"simple Python idiom\" to do this.", "Rather, by one way or another, I can't escape keeping all yielded values of iter1 and iter2 around indefinitely."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["FWIW: here's an official \"test case\" if you want to try your solutions."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n import operator\n\ndef powers_of_ten():\n    n = 0\n    while True:\n        yield 10**n\n        n += 1\n\ndef series_of_nines():\n    yield 1\n    n = 1\n    while True:\n        yield int(\"9\"*n)\n        n += 1\n\nop = operator.mul\niter1 = powers_of_ten()\niter2 = series_of_nines()\n\n# given (iter1, iter2, op), create an iterator that yields:\n# [1, 9, 10, 90, 99, 100, 900, 990, 999, 1000, 9000, 9900, 9990, 9999, 10000, ...]\n</code>\n</pre>\n", "senID": 15}]