[{"text": ["Use a class in the context of a different module"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I want to modify some classes in the standard library to use a different set of globals the ones that other classes in that module use."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Example"], "childNum": 0, "tag": "h2", "senID": 2, "childList": []}, {"text": ["This example is an example only:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # module_a.py\n\nmy_global = []\n\nclass A:\n    def __init__(self):\n        my_global.append(self)\n\nclass B:\n    def __init__(self):\n        my_global.append(self)\n</code>\n</pre>\n", "senID": 4}, {"text": ["In this example, If I create an instance of A, via A(), it will call append on the object named by my_global.", "But now I wish to create a new module, import B to it, and have B use my_global from the module it's been imported into, instead of the my_global from the module B was original defined."], "childNum": 9, "tag": "p", "senID": 5, "childList": [{"text": "A", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "A()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "append", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "my_global", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "B", "childNum": 0, "tag": "code", "childList": []}, {"text": "B", "childNum": 0, "tag": "code", "childList": []}, {"text": "my_global", "childNum": 0, "tag": "code", "childList": []}, {"text": "my_global", "childNum": 0, "tag": "code", "childList": []}, {"text": "B", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n # module_b.py\n\nfrom module_a import B\n\nmy_global = []\n</code>\n</pre>\n", "senID": 6}, {"text": ["Related"], "childNum": 0, "tag": "h2", "senID": 7, "childList": []}, {"text": ["I'm struggling to explain my problem, here is my previous attempt which did in fact ask something completely different:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": ["Clone a module and make changes to the copy"], "childNum": 0, "tag": "a", "senID": 9, "childList": []}]}, {"text": ["Update0"], "childNum": 0, "tag": "h2", "senID": 10, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "The example above is only for illustration of what I'm trying to achieve.", "tag": "none", "senID": 11}, {"text": "Since there is no variable scope for classes (unlike say, C++), I think a reference to a globals mapping is not stored in a class, but instead is attached to every function when defined.", "tag": "none", "senID": 12}]}, {"text": ["Update1"], "childNum": 0, "tag": "h2", "senID": 13, "childList": []}, {"text": ["An example was requested from the standard library:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["Many (maybe all?", ") of the classes in the threading module make use of globals such as _allocate_lock, get_ident, and _active, defined here and here.", "One cannot change these globals without changing it for all the classes in that module."], "childNum": 7, "tag": "p", "senID": 15, "childList": [{"text": "threading", "tag": "a", "pos": 1, "childList": [{"text": "threading", "tag": "code"}], "childNum": 1, "href": "http://hg.python.org/cpython/file/0408001e4765/Lib/threading.py"}, {"text": "threading", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "_allocate_lock", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "get_ident", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "_active", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "here", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://hg.python.org/cpython/file/0408001e4765/Lib/threading.py#l26"}, {"text": "here", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://hg.python.org/cpython/file/0408001e4765/Lib/threading.py#l595"}]}]