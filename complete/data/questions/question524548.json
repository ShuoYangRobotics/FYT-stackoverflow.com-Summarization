[{"text": ["Regular expression to detect semi-colon terminated C++ for & while loops"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["In my Python application, I need to write a regular expression that matches a C++ for or while loop that has been terminated with a semi-colon (;).", "For example, it should match this:"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "while", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": ";", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n for (int i = 0; i &lt; 10; i++);\n</code>\n</pre>\n", "senID": 2}, {"text": ["... but not this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for (int i = 0; i &lt; 10; i++)\n</code>\n</pre>\n", "senID": 4}, {"text": ["This looks trivial at first glance, until you realise that the text between the opening and closing parenthesis may contain other parenthesis, for example:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n for (int i = funcA(); i &lt; funcB(); i++);\n</code>\n</pre>\n", "senID": 6}, {"text": ["I'm using the python.re module.", "Right now my regular expression looks like this (I've left my comments in so you can understand it easier):"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n # match any line that begins with a \"for\" or \"while\" statement:\n^\\s*(for|while)\\s*\n\\(  # match the initial opening parenthesis\n    # Now make a named group 'balanced' which matches a balanced substring.\n    (?P&lt;balanced&gt;\n        # A balanced substring is either something that is not a parenthesis:\n        [^()]\n        | # \u2026or a parenthesised string:\n        \\( # A parenthesised string begins with an opening parenthesis\n            (?P=balanced)* # \u2026followed by a sequence of balanced substrings\n        \\) # \u2026and ends with a closing parenthesis\n    )*  # Look for a sequence of balanced substrings\n\\)  # Finally, the outer closing parenthesis.\n# must end with a semi-colon to match:\n\\s*;\\s*\n</code>\n</pre>\n", "senID": 8}, {"text": ["This works perfectly for all the above cases, but it breaks as soon as you try and make the third part of the for loop contain a function, like so:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n for (int i = 0; i &lt; 10; doSomethingTo(i));\n</code>\n</pre>\n", "senID": 10}, {"text": ["I think it breaks because as soon as you put some text between the opening and closing parenthesis, the \"balanced\" group matches that contained text, and thus the (?P=balanced) part doesn't work any more since it won't match (due to the fact that the text inside the parenthesis is different)."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "(?P=balanced)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In my Python code I'm using the VERBOSE and MULTILINE flags, and creating the regular expression like so:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n REGEX_STR = r\"\"\"# match any line that begins with a \"for\" or \"while\" statement:\n^\\s*(for|while)\\s*\n\\(  # match the initial opening parenthesis\n    # Now make a named group 'balanced' which matches\n    # a balanced substring.\n    (?P&lt;balanced&gt;\n        # A balanced substring is either something that is not a parenthesis:\n        [^()]\n        | # \u2026or a parenthesised string:\n        \\( # A parenthesised string begins with an opening parenthesis\n            (?P=balanced)* # \u2026followed by a sequence of balanced substrings\n        \\) # \u2026and ends with a closing parenthesis\n    )*  # Look for a sequence of balanced substrings\n\\)  # Finally, the outer closing parenthesis.\n# must end with a semi-colon to match:\n\\s*;\\s*\"\"\"\n\nREGEX_OBJ = re.compile(REGEX_STR, re.MULTILINE| re.VERBOSE)\n</code>\n</pre>\n", "senID": 13}, {"text": ["Can anyone suggest an improvement to this regular expression?", "It's getting too complicated for me to get my head around."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}]