[{"text": ["Atomic operations in Django?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I'm trying to implement (what I think is) a pretty simple data model for a counter:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class VisitorDayTypeCounter(models.Model):\n    visitType = models.CharField(max_length=60)\n    visitDate = models.DateField('Visit Date')\n    counter = models.IntegerField()\n</code>\n</pre>\n", "senID": 2}, {"text": ["When someone comes through, it will look for a row that matches the visitType and visitDate; if this row doesn't exist, it will be created with counter=0."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Then we increment the counter and save."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["My concern is that this process is totally a race.", "Two requests could simultaneously check to see if the entity is there, and both of them could create it.", "Between reading the counter and saving the result, another request could come through and increment it (resulting in a lost count)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["So far I haven't really found a good way around this, either in the Django documentation or in the tutorial (in fact, it looks like the tutorial has a race condition in the Vote part of it)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["How do I do this safely?"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]