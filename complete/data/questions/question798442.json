[{"text": ["What is the correct (or best) way to subclass the Python set class, adding a new instance variable?"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I'm implementing an object that is almost identical to a set, but requires an extra instance variable, so I am subclassing the built-in set object.", "What is the best way to make sure that the value of this variable is copied when one of my objects is copied?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Using the old sets module, the following code worked perfectly:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import sets\nclass Fooset(sets.Set):\n\tdef __init__(self, s = []):\n\t\tsets.Set.__init__(self, s)\n\t\tif isinstance(s, Fooset):\n\t\t\tself.foo = s.foo\n\t\telse:\n\t\t\tself.foo = 'default'\nf = Fooset([1,2,4])\nf.foo = 'bar'\nassert( (f | f).foo == 'bar')\n</code>\n</pre>\n", "senID": 3}, {"text": ["but this does not work using the built-in set module."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The only solution that I can see is to override every single method that returns a copied set object... in which case I might as well not bother subclassing the set object.", "Surely there is a standard way to do this?"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["(To clarify, the following code does not work (the assertion fails):"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Fooset(set):\n\tdef __init__(self, s = []):\n\t\tset.__init__(self, s)\n\t\tif isinstance(s, Fooset):\n\t\t\tself.foo = s.foo\n\t\telse:\n\t\t\tself.foo = 'default'\n\nf = Fooset([1,2,4])\nf.foo = 'bar'\nassert( (f | f).foo == 'bar')\n</code>\n</pre>\n", "senID": 7}, {"text": [], "childNum": 0, "tag": "p", "senID": 8, "childList": []}]