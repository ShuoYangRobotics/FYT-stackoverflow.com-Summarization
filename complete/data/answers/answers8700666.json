[[{"text": ["The following one-liner should do (change 3 to 8 to match your case)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ sort * | uniq -c | grep 3\n      3 Paul\n</code>\n</pre>\n", "senID": 1}, {"text": ["Probably better to do this in python though, using sets..."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "sets", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n python -c 'import sys;print \"\".join(sorted(set.intersection(*[set(open(a).readlines()) for a in sys.argv[1:]])))' File1 File2 File3\n</code>\n</pre>\n", "senID": 0}, {"text": ["prints Paul for your files File1, File2 and File3."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "Paul", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "File1", "childNum": 0, "tag": "code", "childList": []}, {"text": "File2", "childNum": 0, "tag": "code", "childList": []}, {"text": "File3", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Perl"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ perl -lnE '$c{$_}{$ARGV}++ }{ print for grep { keys %{$c{$_}} == 8 } keys %c;' file[1-8]\n</code>\n</pre>\n", "senID": 1}, {"text": ["It should be possible to get rid of the hard-coded 8 as well with @{[ glob \"@ARGV\" ]} but I don't have time to test it now."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "8", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "@{[ glob \"@ARGV\" ]}", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This solution will correctly handle the existence of duplicate lines across files as well."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Here I've been trying to find a concise way to make sure each match comes from a different file.", "If there are no duplicates within the files, it's fairly simple in perl:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n perl -lnwE '$a{$_}++; END { for (keys %a) { print if $a{$_} == 3 } }' files*\n</code>\n</pre>\n", "senID": 1}, {"text": ["The -l option will auto-chomp your input (remove newline), and add a newline to the print.", "This is important in case of missing eof newlines."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "-l", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The -n option will read input from file name arguments (or stdin)."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "-n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The hash assignment will count duplicates, and the END block will print out what duplicates appeared 3 times.", "Change 3 to however many files you have."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If you want a slightly more flexible version, you can count the arguments in a BEGIN block."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n perl -lnwE 'BEGIN { $n = scalar @ARGV } \n    $a{$_}++; END { for (keys %a) { print if $a{$_} == $n } }' files*\n</code>\n</pre>\n", "senID": 6}], [{"code": "<pre>\n<code>\n $ awk '++a[$0]==3' file{1..3}.txt\nPaul\n</code>\n</pre>\n", "senID": 0}, {"text": ["update"], "childNum": 0, "tag": "h2", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n $ awk '(FILENAME SEP $0) in b{next}; b[FILENAME,$0]=1 &amp;&amp; ++a[$0]==3' file{1..3}.txt\nPaul\n</code>\n</pre>\n", "senID": 2}], [{"text": ["This might work for you:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ls file{1..3} | \nxargs -n1 sort -u | \nsort | \nuniq -c | \nsed 's/^\\s*'\"$(ls file{1..3} | wc -l)\"'\\s*//p;d'\n</code>\n</pre>\n", "senID": 1}]]