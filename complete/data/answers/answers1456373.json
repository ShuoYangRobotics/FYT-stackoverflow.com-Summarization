[[{"text": ["In your special case you can store both in one dictionary:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n relation = {}\nrelation['Alice'] = 'Bob'\nrelation['Bob'] = 'Alice'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Since what you are describing is a symmetric relationship.", "A -&gt; B =&gt; B -&gt; A"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "A -&gt; B =&gt; B -&gt; A", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You have two separate issues."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Do something like this"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\nswitchboard= defaultdict( list )\n\nx = Conversation( \"Alice\", \"Bob\" )\ny = Conversation( \"Alice\", \"Charlie\" )\n\nfor c in ( x, y ):\n    switchboard[c.p1].append( c )\n    switchboard[c.p2].append( c )\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Two hash maps is actually probably the fastest-performing solution assuming you can spare the memory.", "I would wrap those in a single class - the burden on the programmer is in ensuring that two the hash maps sync up correctly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["No, there is really no way to do this without creating two dictionaries.", "How would it be possible to implement this with just one dictionary while continuing to offer comparable performance?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You are better off creating a custom type that encapsulates two dictionaries and exposes the functionality you want."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I would just populate a second hash, with"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n reverse_map = dict((reversed(item) for item in forward_map.items()))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is a simple bijective Dictionary implementation, although I don't know if it will meet your performance requirements."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "simple bijective Dictionary implementation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.aminus.net/geniusql/browser/trunk/geniusql/objects.py#L32"}]}, {"text": ["(Link from this blog article on boost Bimap for Python, which has some nice discussion of the topic."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "this blog article on boost Bimap for Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://paddy3118.blogspot.com/2009/04/bimap-bi-directional-mappingdictionary.html"}]}], [{"text": ["The kjbuckets C extension module provides a \"graph\" data structure which I believe gives you what you want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]