[[{"text": ["This decodes your \"list\" of JSON Objects from a string:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from json import JSONDecoder\n\ndef loads_invalid_obj_list(s):\n    decoder = JSONDecoder()\n    s_len = len(s)\n\n    objs = []\n    end = 0\n    while end != s_len:\n        obj, end = decoder.raw_decode(s, idx=end)\n        objs.append(obj)\n\n    return objs\n</code>\n</pre>\n", "senID": 1}, {"text": ["The bonus here is that you play nice with the parser.", "Hence it keeps telling you exactly where it found an error."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "exactly", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Examples"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Examples", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; loads_invalid_obj_list('{}{}')\n[{}, {}]\n\n&gt;&gt;&gt; loads_invalid_obj_list('{}{\\n}{')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"decode.py\", line 9, in loads_invalid_obj_list\n    obj, end = decoder.raw_decode(s, idx=end)\n  File     \"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/json/decoder.py\", line 376, in raw_decode\n    obj, end = self.scan_once(s, idx)\nValueError: Expecting object: line 2 column 2 (char 5)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Clean Solution (added later)"], "childNum": 0, "tag": "h2", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import json\nimport re\n\n#shameless copy paste from json/decoder.py\nFLAGS = re.VERBOSE | re.MULTILINE | re.DOTALL\nWHITESPACE = re.compile(r'[ \\t\\n\\r]*', FLAGS)\n\nclass ConcatJSONDecoder(json.JSONDecoder):\n    def decode(self, s, _w=WHITESPACE.match):\n        s_len = len(s)\n\n        objs = []\n        end = 0\n        while end != s_len:\n            obj, end = self.raw_decode(s, idx=_w(s, end).end())\n            end = _w(s, end).end()\n            objs.append(obj)\n        return objs\n</code>\n</pre>\n", "senID": 6}, {"text": ["Examples"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Examples", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print json.loads('{}', cls=ConcatJSONDecoder)\n[{}]\n\n&gt;&gt;&gt; print json.load(open('file'), cls=ConcatJSONDecoder)\n[{}]\n\n&gt;&gt;&gt; print json.loads('{}{} {', cls=ConcatJSONDecoder)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/json/__init__.py\", line 339, in loads\n    return cls(encoding=encoding, **kw).decode(s)\n  File \"decode.py\", line 15, in decode\n    obj, end = self.raw_decode(s, idx=_w(s, end).end())\n  File \"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/json/decoder.py\", line 376, in raw_decode\n    obj, end = self.scan_once(s, idx)\nValueError: Expecting object: line 1 column 5 (char 5)\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Why don't you load the file as string, replace all }{ with },{ and surround the whole thing with []?", "Something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n re.sub('\\}\\s*?\\{', '\\}, \\{', string_read_from_a_file)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or simple string replace if you are sure you always have }{ without whitespaces in between."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In case you expect }{ to occur in strings as well, you could also split on }{ and evaluate each fragment with json.load, in case you get an error, the fragment wasn't complete and you have to add the next to the first one and so forth."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Solution"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["As far as I know }{ does not appear in valid JSON, so the following should be perfectly safe when trying to get strings for separate objects that were concatenated (txt is the content of your file).", "It does not require any import (even of re module) to do that:"], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "}{", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "txt", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "It does not require any import", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "re", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n retrieved_strings = map(lambda x: '{'+x+'}', txt.strip('{}').split('}{'))\n</code>\n</pre>\n", "senID": 2}, {"text": ["or if you prefer list comprehensions (as David Zwicker mentioned in the comments), you can use it like that:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n retrieved_strings = ['{'+x+'}' for x in txt.strip('{}').split('}{'))]\n</code>\n</pre>\n", "senID": 4}, {"text": ["It will result in retrieved_strings being a list of strings, each containing separate JSON object.", "See proof here: http://ideone.com/Purpb"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "retrieved_strings", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "http://ideone.com/Purpb", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://ideone.com/Purpb"}]}, {"text": ["Example"], "childNum": 0, "tag": "h2", "senID": 6, "childList": []}, {"text": ["The following string:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n '{field1:\"a\",field2:\"b\"}{field1:\"c\",field2:\"d\"}{field1:\"e\",field2:\"f\"}'\n</code>\n</pre>\n", "senID": 8}, {"text": ["will be turned into:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n ['{field1:\"a\",field2:\"b\"}', '{field1:\"c\",field2:\"d\"}', '{field1:\"e\",field2:\"f\"}']\n</code>\n</pre>\n", "senID": 10}, {"text": ["as proven in the example I mentioned."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "the example I mentioned", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ideone.com/Purpb"}]}], [{"text": ["How about something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nimport json\n\njsonstr = open('test.json').read()\n\np = re.compile( '}\\s*{' )\njsonstr = p.sub( '}\\n{', jsonstr )\n\njsonarr = jsonstr.split( '\\n' )\n\nfor jsonstr in jsonarr:\n   jsonobj = json.loads( jsonstr )\n   print json.dumps( jsonobj )\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Sebastian Blask has the right idea, but there's no reason to use regexes for such a simple change."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n objs = json.loads(\"[%s]\"%(open('your_file.name').read().replace('}{', '},{')))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or, more legibly"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n raw_objs_string = open('your_file.name').read() #read in raw data\nraw_objs_string = raw_objs_string.replace('}{', '},{') #insert a comma between each object\nobjs_string = '[%s]'%(raw_objs_string) #wrap in a list, to make valid json\nobjs = json.loads(objs_string) #parse json\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Suppose you added a [ to the start of the text in a file, and used a version of json.load() which, when it detected the error of finding a { instead of an expected comma (or hits the end of the file), spit out the just-completed object?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["How about reading through the file incrementing a counter every time a { is found and decrementing it when you come across a }.", "When your counter reaches 0 you'll know that you've come to the end of the first object so send that through json.load and start counting again.", "Then just repeat to completion.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Replace a file with that junk in it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre class=\"lang-sh prettyprint-override\">\n<code>\n $ sed -i -e 's;}{;}, {;g' foo\n</code>\n</pre>\n", "senID": 1}, {"text": ["Do it on the fly in Python:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n junkJson.replace('}{', '}, {')\n</code>\n</pre>\n", "senID": 3}]]