[[{"text": ["Maybe something like this will do the trick:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python2.6\n\nfrom __future__ import print_function\n\nimport readline\nimport threading\n\nPROMPT = '&gt; '\n\ndef interrupt():\n    print() # Don't want to end up on the same line the user is typing on.\n    print('Interrupting cow -- moo!')\n    print(PROMPT, readline.get_line_buffer(), sep='', end='')\n\ndef cli():\n    while True:\n        cli = str(raw_input(PROMPT))\n\nif __name__ == '__main__':\n    threading.Thread(target=cli).start()\n    threading.Timer(2, interrupt).start()\n</code>\n</pre>\n", "senID": 1}, {"text": ["I don't think that stdin is thread-safe, so you can end up losing characters to the interrupting thread (that the user will have to retype at the end of the interrupt).", "I exaggerated the amount of interrupt time with the time.sleep call.", "The readline.get_line_buffer call won't display the characters that get lost, so it all turns out alright."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "interrupt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "interrupt", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "time.sleep", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "readline.get_line_buffer", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Note that stdout itself isn't thread safe, so if you've got multiple interrupting threads of execution, this can still end up looking gross."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Why are you writing your own REPL using raw_input()?", "Have you looked at the cmd.Cmd class?", "Edit: I just found the sclapp library, which may also be useful."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "raw_input()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "cmd.Cmd", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"href": "http://www.alittletooquiet.net/software/sclapp/", "text": "sclapp", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Note: the cmd.Cmd class (and sclapp) may or may not directly support your original goal; you may have to subclass it and modify it as needed to provide that feature."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "cmd.Cmd", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["run this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n python -m twisted.conch.stdio\n</code>\n</pre>\n", "senID": 1}, {"text": ["You'll get a nice, colored, async REPL, without using threads.", "While you type in the prompt, the event loop is running."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "without using threads", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["look into the code module, it lets you create objects for interpreting python code also (shameless plug) https://github.com/iridium172/PyTerm lets you create interactive command line programs that handle raw keyboard input (like ^C will raise a KeyboardInterrupt)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "https://github.com/iridium172/PyTerm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://github.com/iridium172/PyTerm"}]}], [{"text": ["It's kind of a non-answer, but I would look at IPython's code to see how they're doing it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "IPython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ipython.scipy.org/moin/"}]}], [{"text": ["I think you have 2 basic options:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]