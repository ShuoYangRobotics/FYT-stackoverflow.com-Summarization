[[{"text": ["If you want to do this in place, just use"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n lst[:] = [i for i in lst if i &gt; 3]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This won't be faster or save any memory, but it changes the object in place, if this is the semantics you need."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "won't be faster or save any memory", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4948293/python-slice-assignment-memory-usage/4948508#4948508"}]}], [{"text": ["The other answers are correct; if you want all the names pointing to the old list to point to the new list you can use slice assignment."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, that's not truly in-place creation; the new list is first created elsewhere.", "The link in Sven's answer is good."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The reason there isn't one that truly operates in-place is that while making a new list like that is O(n), each truly in-place item removal would be O(k) by itself, where k is the length of the list from the removal point on.", "The only way to avoid that with Python lists is to use some temporary storage, which is what you're doing by using slice assignment."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "reason", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "by itself", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "k", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["An example of an in-place O(n) filter on a collections.deque, in case you don't need to store your data in a list:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "collections.deque", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from collections import deque\n\ndef dequefilter(deck, condition):\n    for _ in xrange(len(deck)):\n        item = deck.popleft()\n        if condition(item):\n            deck.append(item)\n\ndeck = deque((1, 2, 3, 4, 5))\ndequefilter(deck, lambda x: x &gt; 2) # or operator.gt(2)\nprint deck\n# deque([3, 4, 5])\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Correcting @larsmans original solution, you could either do"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@larsmans original solution", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/revisions/8037534/1"}]}, {"code": "<pre>\n<code>\n i = 0\nwhile i &lt; len(lst):\n    if lst[i] &lt;= 3:\n        del lst[i]\n    else\n        i += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n i = len(lst)\nwhile i &gt; 0:\n    if lst[i-1] &lt;= 3:\n        del lst[i-1]\n    i -= 1\n</code>\n</pre>\n", "senID": 3}, {"text": ["Reason is the \"index shift\" which happens with the del.", "If I del at a ceratin index, I have to re-examine that index because it now holds a different value."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "del", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "del", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Because it's not needed."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "not needed", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4081561/what-is-the-difference-between-list-and-list-in-python/4081587#4081587"}]}, {"code": "<pre>\n<code>\n lst[:] = [i for i in lst if i &gt; 3]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The lst[:] solution by @Sven Marnach is one option.", "You can also perform this operation in-place, using constant extra memory, with"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "lst[:]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; i = 0\n&gt;&gt;&gt; while i &lt; len(lst):\n...  if lst[i] &lt;= 3:\n...   del lst[i]\n...  else:\n...   i += 1\n... \n&gt;&gt;&gt; lst\n[4, 5, 6]\n</code>\n</pre>\n", "senID": 1}, {"text": ["... but this solution is not very readable and takes quadratic time due to all the element shifting involved."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I think it's in place transformation;"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n lst = [1,2,3,4,5,6,7,8,9,10,11]\nto_exclude = [8,4,11,9]\nprint 'lst == %s\\nto_exclude == %s' % (lst,to_exclude)\n\nfor i in xrange(len(lst)-1,-1,-1):\n    if lst[i] in to_exclude:\n        lst.pop(i)\n\nprint '\\nlst ==',lst\n</code>\n</pre>\n", "senID": 1}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n lst == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\nto_exclude == [8, 4, 11, 9]\n\nlst == [1, 2, 3, 5, 6, 7, 10]\n</code>\n</pre>\n", "senID": 3}]]