[[{"text": ["Pythagorean Triples make a good example for claiming \"forloops considered harmful\", because for loops seduce us into thinking about counting, often the most irrelevant part of a task. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "forloops considered harmful", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "for", "tag": "code"}]}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["(I'm going to stick with pseudo-code to avoid language biases, and to keep the pseudo-code streamlined, I'll not optimize away multiple calculations of e.g.", "x * x and y * y."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "x * x", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "y * y", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Version 1:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Version 1", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for x in 1..N {\n    for y in 1..N {\n        for z in 1..N {\n            if x * x + y * y == z * z then {\n                // use x, y, z\n            }\n        }\n    }\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["is the worst solution.", "It generates duplicates, and traverses parts of the space that aren't useful (e.g.", "whenever z &lt; y).", "Its time complexity is cubic on N."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "z &lt; y", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Version 2, the first improvement, comes from requiring x &lt; y &lt; z to hold, as in:"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "Version 2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "x &lt; y &lt; z", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n for x in 1..N {\n    for y in x+1..N {\n        for z in y+1..N {\n            if x * x + y * y == z * z then {\n                // use x, y, z\n            }\n        }\n    }\n}\n</code>\n</pre>\n", "senID": 6}, {"text": ["which reduces run time and eliminates duplicated solutions.", "However, it is still cubic on N; the improvement is just a reduction of the co-efficient of N-cubed."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "N", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It is pointless to continue examining increasing values of z after z * z &lt; x * x + y * y no longer holds.", "That fact motivates Version 3, the first step away from brute-force iteration over z:"], "childNum": 4, "tag": "p", "senID": 8, "childList": [{"text": "z", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "z * z &lt; x * x + y * y", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Version 3", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "z", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n for x in 1..N {\n    for y in x+1..N {\n        z = y + 1\n        while z * z &lt; x * x + y * y {\n            z = z + 1\n        }\n        if z * z == x * x + y * y and z &lt;= N then {\n            // use x, y, z\n        }\n    }\n}\n</code>\n</pre>\n", "senID": 9}, {"text": ["For N of 1000, this is about 5 times faster than Version 2, but it is still cubic on N."], "childNum": 3, "tag": "p", "senID": 10, "childList": [{"text": "N", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "still", "childNum": 0, "tag": "em", "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The next insight is that x and y are the only independent variables; z depends on their values, and the last z value considered for the previous value of y is a good starting search value for the next value of y.", "That leads to Version 4:"], "childNum": 8, "tag": "p", "senID": 11, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "z", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "z", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "starting", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Version 4", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n for x in 1..N {\n    y = x+1\n    z = y+1\n    while z &lt;= N {\n        while z * z &lt; x * x + y * y {\n            z = z + 1\n        }\n        if z * z == x * x + y * y and z &lt;= N then {\n            // use x, y, z\n        }\n        y = y + 1\n    }\n}\n</code>\n</pre>\n", "senID": 12}, {"text": ["which allows y and z to \"sweep\" the values above x only once.", "Not only is it over 100 times faster for N of 1000, it is quadratic on N, so the speedup increases as N grows."], "childNum": 6, "tag": "p", "senID": 13, "childList": [{"text": "y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "z", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I've encountered this kind of improvement often enough to be mistrustful of \"counting loops\" for any but the most trivial uses (e.g.", "traversing an array)."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["Update: Apparently I should have pointed out a few things about V4 that are easy to overlook."], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Below is a not-very-scientific set of timings (using Java under Eclipse on my older laptop with other stuff running...), where the \"use x, y, z\" was implemented by instantiating a Triple object with the three values and putting it in an ArrayList.", "(For these runs, N was set to 10,000, which produced 12,471 triples in each case."], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "N", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n Version 4:           46 sec.\nusing square root:  134 sec.\narray and map:      400 sec.\n</code>\n</pre>\n", "senID": 17}, {"text": ["The \"array and map\" algorithm is essentially:"], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "essentially", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n squares = array of i*i for i in 1 .. N\nroots = map of i*i -&gt; i for i in 1 .. N\nfor x in 1 .. N\n    for y in x+1 .. N\n        z = roots[squares[x] + squares[y]]\n        if z exists use x, y, z\n</code>\n</pre>\n", "senID": 19}, {"text": ["The \"using square root\" algorithm is essentially:"], "childNum": 1, "tag": "p", "senID": 20, "childList": [{"text": "essentially", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for x in 1 .. N\n    for y in x+1 .. N\n        z = (int) sqrt(x * x + y * y)\n        if z * z == x * x + y * y then use x, y, z\n</code>\n</pre>\n", "senID": 21}, {"text": ["The actual code for V4 is:"], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"code": "<pre>\n<code>\n public Collection&lt;Triple&gt; byBetterWhileLoop() {\n    Collection&lt;Triple&gt; result = new ArrayList&lt;Triple&gt;(limit);\n    for (int x = 1; x &lt; limit; ++x) {\n        int xx = x * x;\n        int y = x + 1;\n        int z = y + 1;\n        while (z &lt;= limit) {\n            int zz = xx + y * y;\n            while (z * z &lt; zz) {++z;}\n            if (z * z == zz &amp;&amp; z &lt;= limit) {\n                result.add(new Triple(x, y, z));\n            }\n            ++y;\n        }\n    }\n    return result;\n}\n</code>\n</pre>\n", "senID": 23}, {"text": ["Note that x * x is calculated in the outer loop (although I didn't bother to cache z * z); similar optimizations are done in the other variations."], "childNum": 3, "tag": "p", "senID": 24, "childList": [{"text": "x * x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "is", "childNum": 0, "tag": "em", "childList": []}, {"text": "z * z", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I'll be glad to provide the Java source code on request for the other variations I timed, in case I've mis-implemented anything."], "childNum": 0, "tag": "p", "senID": 25, "childList": []}], [{"text": ["You should define x &lt; y &lt; z."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for x in range (1, 1000):\n    for y in range (x + 1, 1000):\n            for z in range(y + 1, 1000):\n</code>\n</pre>\n", "senID": 1}, {"text": ["Another good optimization would be to only use x and y and calculate zsqr = x * x + y * y.", "If zsqr is a square number (or z = sqrt(zsqr) is a whole number), it is a triplet, else not.", "That way, you need only two loops instead of three (for your example, that's about 1000 times faster)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Algorithms can be tuned for speed, memory usage, simplicity, and other things."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is a pythagore_triplets algorithm tuned for speed, at the cost of memory usage and simplicity.", "If all you want is speed, this could be the way to go."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "pythagore_triplets", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Calculation of list(pythagore_triplets(10000)) takes 40 seconds on my computer, versus 63 seconds for \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5's algorithm, and possibly days of calculation for Tafkas's algorithm (and all other algorithms which use 3 embedded loops instead of just 2)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "list(pythagore_triplets(10000))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def pythagore_triplets(n=1000):\n   maxn=int(n*(2**0.5))+1 # max int whose square may be the sum of two squares\n   squares=[x*x for x in xrange(maxn+1)] # calculate all the squares once\n   reverse_squares=dict([(squares[i],i) for i in xrange(maxn+1)]) # x*x=&gt;x\n   for x in xrange(1,n):\n     x2 = squares[x]\n     for y in xrange(x,n+1):\n       y2 = squares[y]\n       z = reverse_squares.get(x2+y2)\n       if z != None:\n         yield x,y,z\n\n&gt;&gt;&gt; print list(pythagore_triplets(20))\n[(3, 4, 5), (5, 12, 13), (6, 8, 10), (8, 15, 17), (9, 12, 15), (12, 16, 20)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that if you are going to calculate the first billion triplets, then this algorithm will crash before it even starts, because of an out of memory error.", "So \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5's algorithm is probably a safer choice for high values of n."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["BTW, here is Tafkas's algorithm, translated into python for the purpose of my performance tests.", "Its flaw is to require 3 loops instead of 2."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def gcd(a, b):\n  while b != 0:\n    t = b\n    b = a%b\n    a = t\n  return a\n\ndef find_triple(upper_boundary=1000):\n  for c in xrange(5,upper_boundary+1):\n    for b in xrange(4,c):\n      for a in xrange(3,b):\n        if (a*a + b*b == c*c and gcd(a,b) == 1):\n          yield a,b,c\n</code>\n</pre>\n", "senID": 6}], [{"text": ["The previously listed algorithms for generating Pythagorean triplets are all modifications of the naive approach derived from the basic relationship a^2 + b^2 = c^2 where (a, b, c) is a triplet of positive integers.", "It turns out that Pythagorean triplets satisfy some fairly remarkable relationships that can be used to generate all Pythagorean triplets."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Pythagorean triplets", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Pythagorean_triplets"}, {"text": "a^2 + b^2 = c^2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "(a, b, c)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Euclid discovered the first such relationship.", "He determined that for every Pythagorean triple (a, b, c), possibly after a reordering of a and b there are relatively prime positive integers m and n with m &gt; n, at least one of which is even, and a positive integer k such that"], "childNum": 8, "tag": "p", "senID": 1, "childList": [{"text": "Euclid", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Euclid"}, {"text": "(a, b, c)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "m", "childNum": 0, "tag": "code", "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}, {"text": "m &gt; n", "childNum": 0, "tag": "code", "childList": []}, {"text": "k", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n a = k (2mn)\nb = k (m^2 - n^2)\nc = k (m^2 + n^2)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then to generate Pythagorean triplets, generate relatively prime positive integers m and n of differing parity, and a positive integer k and apply the above formula."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "m", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}, {"text": "k", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n struct PythagoreanTriple {\n    public int a { get; private set; }\n    public int b { get; private set; }\n    public int c { get; private set; }\n\n    public PythagoreanTriple(int a, int b, int c) : this() {\n        this.a = a &lt; b ? a : b;\n        this.b = b &lt; a ? a : b;\n        this.c = c;\n    }\n\n    public override string ToString() {\n        return String.Format(\"a = {0}, b = {1}, c = {2}\", a, b, c);\n    }\n\n    public static IEnumerable&lt;PythagoreanTriple&gt; GenerateTriples(int max) {\n        var triples = new List&lt;PythagoreanTriple&gt;();\n        for (int m = 1; m &lt;= max / 2; m++) {\n            for (int n = 1 + (m % 2); n &lt; m; n += 2) {\n                if (m.IsRelativelyPrimeTo(n)) {\n                    for (int k = 1; k &lt;= max / (m * m + n * n); k++) {\n                        triples.Add(EuclidTriple(m, n, k));\n                    }\n                }\n            }\n        }\n\n        return triples;\n    }\n\n    private static PythagoreanTriple EuclidTriple(int m, int n, int k) {\n        int msquared = m * m;\n        int nsquared = n * n;\n        return new PythagoreanTriple(k * 2 * m * n, k * (msquared - nsquared), k * (msquared + nsquared));\n    }\n}\n\npublic static class IntegerExtensions {\n    private static int GreatestCommonDivisor(int m, int n) {\n        return (n == 0 ? m : GreatestCommonDivisor(n, m % n));\n    }\n\n    public static bool IsRelativelyPrimeTo(this int m, int n) {\n        return GreatestCommonDivisor(m, n) == 1;\n    }\n}\n\nclass Program {\n    static void Main(string[] args) {\n        PythagoreanTriple.GenerateTriples(1000).ToList().ForEach(t =&gt; Console.WriteLine(t));            \n    }\n}\n</code>\n</pre>\n", "senID": 4}, {"text": ["The Wikipedia article on Formulas for generating Pythagorean triples contains other such formulae."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Formulas for generating Pythagorean triples", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples"}]}], [{"text": ["Substantially faster than any of the solutions so far.", "Finds triplets in O(log n) time via a binomial heap."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So in plan English we have a formula to generate every single primitive triple ever.", "Too bad there are an infinite number of them."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Fortunately, in the above formula, the sum of the numbers are ever growing so it's pretty easy to say, okay, we've gone deep enough, let's do the next thing."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["While there is not really an easy way to retreive an exact number of elements, IMO it's far more handy to have a list of every triplet that adds to a specific number or below (aka, adds to a specific perimeter or below)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Anyway, enough yapping, here's the algorithm in Python3:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from numpy import matrix,array\n\ndef PrimPythTrips(max=None):\n  '''generate all primative triples such that \n  the sum is less than or equal to max'''\n  u=matrix( [[1,2,2], [-2,-1,-2], [2,2,3]] )\n  a=matrix( [[1,2,2], [2,1,2], [2,2,3]] )\n  d=matrix( [[-1,-2,-2], [2,1,2], [2,2,3]] )\n  m=[ array([3,4,5]) ]\n  while m:\n    for i in m:\n      yield i\n    g=( (i*j).getA1() for i in m for j in (u,a,d) )\n    m=[ i for i in g if max is None or sum(i)&lt;=max ]\n</code>\n</pre>\n", "senID": 5}, {"text": ["If you'd like all triples and not just the primitives:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def AllPythTrips(max):\n  '''generate all triples such that \n  the sum is less than or equal to max'''\n  for i in PrimPythTrips(max):\n    ret=i[:]\n    while sum(ret)&lt;=max:\n      yield ret\n      ret=ret+i\n</code>\n</pre>\n", "senID": 7}, {"text": ["It's also safe to replace sum(i)&lt;=max with i[2]&lt;=max to check the length of the hypotenuse instead of the sum."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "sum(i)&lt;=max", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "i[2]&lt;=max", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It works extremely well and returns list(PrimPythTrips(10**6)) in 5.5 seconds as a full list with 70229 elements.", "So that's the first 70229 primitive triples in under 6s."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "list(PrimPythTrips(10**6))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["list(AllPythTrips(10**6)) takes a bit longer (about 15 secs) but returns with a whopping 808950 elements."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "list(AllPythTrips(10**6))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n def pyth_triplets(n=1000):\n    \"Version 1\"\n    for x in xrange(1, n):\n        x2= x*x # time saver\n        for y in xrange(x+1, n): # y &gt; x\n            z2= x2 + y*y\n            zs= int(z2**.5)\n            if zs*zs == z2:\n                yield x, y, zs\n\n&gt;&gt;&gt; print list(pyth_triplets(20))\n[(3, 4, 5), (5, 12, 13), (6, 8, 10), (8, 15, 17), (9, 12, 15), (12, 16, 20)]\n</code>\n</pre>\n", "senID": 0}, {"text": ["V.1 algorithm has monotonically increasing x values."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["It seems this question is still alive :)\nSince I came back and revisited the code, I tried a second approach which is almost 4 times as fast (about 26% of CPU time for N=10000) as my previous suggestion since it avoids lots of unnecessary calculations:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def pyth_triplets(n=1000):\n    \"Version 2\"\n    for z in xrange(5, n+1):\n        z2= z*z # time saver\n        x= x2= 1\n        y= z - 1; y2= y*y\n        while x &lt; y:\n            x2_y2= x2 + y2\n            if x2_y2 == z2:\n                yield x, y, z\n                x+= 1; x2= x*x\n                y-= 1; y2= y*y\n            elif x2_y2 &lt; z2:\n                x+= 1; x2= x*x\n            else:\n                y-= 1; y2= y*y\n\n&gt;&gt;&gt; print list(pyth_triplets(20))\n[(3, 4, 5), (6, 8, 10), (5, 12, 13), (9, 12, 15), (8, 15, 17), (12, 16, 20)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that this algorithm has increasing z values."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "z", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If the algorithm was converted to C \u2014where, being closer to the metal, multiplications take more time than additions\u2014 one could minimalise the necessary multiplications, given the fact that the step between consecutive squares is:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["so all of the inner x2= x*x and y2= y*y would be converted to additions and subtractions like this:"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "x2= x*x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y2= y*y", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def pyth_triplets(n=1000):\n    \"Version 3\"\n    for z in xrange(5, n+1):\n        z2= z*z # time saver\n        x= x2= 1; xstep= 3\n        y= z - 1; y2= y*y; ystep= 2*y - 1\n        while x &lt; y:\n            x2_y2= x2 + y2\n            if x2_y2 == z2:\n                yield x, y, z\n                x+= 1; x2+= xstep; xstep+= 2\n                y-= 1; y2-= ystep; ystep-= 2\n            elif x2_y2 &lt; z2:\n                x+= 1; x2+= xstep; xstep+= 2\n            else:\n                y-= 1; y2-= ystep; ystep-= 2\n</code>\n</pre>\n", "senID": 7}, {"text": ["Of course, in Python the extra bytecode produced actually slows down the algorithm compared to version 2, but I would bet (without checking :) that V.3 is faster in C."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "slows down", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Cheers everyone :)"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["Yes, there is."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Okay, now you'll want to know why.", "Why not just constrain it so that z > y?", "Try "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for z in range (y+1, 1000)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I wrote that program in Ruby and it similar to the python implementation.", "The important line is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if x*x == y*y + z*z &amp;&amp; gcd(y,z) == 1:\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you have to implement a method that return the greatest common divisor (gcd) of two given numbers.", "A very simple example in Ruby again:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def gcd(a, b)\n    while b != 0\n      t = b\n      b = a%b\n      a = t\n    end\n    return a\nend\n</code>\n</pre>\n", "senID": 3}, {"text": ["The full Ruby methon to find the triplets would be:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def find_triple(upper_boundary)\n\n  (5..upper_boundary).each {|c|\n    (4..c-1).each {|b|\n      (3..b-1).each {|a|\n        if (a*a + b*b == c*c &amp;&amp; gcd(a,b) == 1)\n          puts \"#{a} \\t #{b} \\t #{c}\"\n        end\n      }\n    }\n  }\nend\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Version 5 to Joel Neely."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Since X can  be max of 'N-2' and Y can be max of 'N-1' for range of 1..N. Since Z max is N and Y max is N-1, X can be max of Sqrt ( N * N - (N-1) * (N-1) ) = Sqrt ( 2 * N - 1 ) and can start from 3."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n MaxX = ( 2 * N - 1 ) ** 0.5\n\nfor x in 3..MaxX {\n  y = x+1\n  z = y+1\n  m = x*x + y*y\n  k = z * z\n  while z &lt;= N {\n     while k &lt; m {\n        z = z + 1\n        k = k + (2*z) - 1\n    }\n    if k == m and z &lt;= N then {\n        // use x, y, z\n    }\n    y = y + 1\n    m = m + (2 * y) - 1\n  }\n }\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Just checking, but I've been using the following code to make pythagorean triples.", "It's very fast (and I've tried some of the examples here, though I kind of learned them and wrote my own and came back and checked here (2 years ago)).", "I think this code correctly finds all pythagorean triples up to (name your limit) and fairly quickly too.", "I used C++ to make it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["ullong is unsigned long long and I created a couple of functions to square and root\nmy root function basically said if square root of given number (after making it whole number (integral)) squared not equal number give then return -1 because it is not rootable.", "_square and _root do as expected as of description above, I know of another way to optimize it but I haven't done nor tested that yet."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n generate(vector&lt;Triple&gt;&amp; triplist, ullong limit) {\ncout&lt;&lt;\"Please wait as triples are being generated.\"&lt;&lt;endl;\nregister ullong a, b, c;\nregister Triple trip;\ntime_t timer = time(0);\n\nfor(a = 1; a &lt;= limit; ++a) {\n    for(b = a + 1; b &lt;= limit; ++b) {\n        c = _root(_square(a) + _square(b));\n\n        if(c != -1 &amp;&amp; c &lt;= limit) {\n            trip.a = a; trip.b = b; trip.c = c;\n\n            triplist.push_back(trip);\n\n        } else if(c &gt; limit)\n            break;\n    }\n}\n\ntimer = time(0) - timer;\ncout&lt;&lt;\"Generated \"&lt;&lt;triplist.size()&lt;&lt;\" in \"&lt;&lt;timer&lt;&lt;\" seconds.\"&lt;&lt;endl;\ncin.get();\ncin.get();\n</code>\n</pre>\n", "senID": 2}, {"text": [], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Let me know what you all think.", "It generates all primitive and non-primitive triples according to the teacher I turned it in for.", "(she tested it up to 100 if I remember correctly)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The results from the v4 supplied by a previous coder here are"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Below is a not-very-scientific set of timings (using Java under Eclipse on my older laptop with other stuff running...), where the \"use x, y, z\" was implemented by instantiating a Triple object with the three values and putting it in an ArrayList.", "(For these runs, N was set to 10,000, which produced 12,471 triples in each case."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Version 4:           46 sec.", "using square root:  134 sec.", "array and map:      400 sec."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["The results from mine is\nHow many triples to generate: 10000"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Please wait as triples are being generated.", "Generated 12471 in 2 seconds."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["That is before I even start optimizing via the compiler.", "(I remember previously getting 10000 down to 0 seconds with tons of special options and stuff).", "My code also generates all the triples with 100,000 as the limit of how high side1,2,hyp can go in 3.2 minutes (I think the 1,000,000 limit takes an hour)."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["I modified the code a bit and got the 10,000 limit down to 1 second (no optimizations).", "On top of that, with careful thinking, mine could be broken down into chunks and threaded upon given ranges (for example 100,000 divide into 4 equal chunks for 3 cpu's (1 extra to hopefully consume cpu time just in case) with ranges 1 to 25,000 (start at 1 and limit it to 25,000), 25,000 to 50,000 , 50,000 to 75,000, and 75,000 to end.", "I may do that and see if it speeds it up any (I will have threads premade and not include them in the actual amount of time to execute the triple function.", "I'd need a more precise timer and a way to concatenate the vectors.", "I think that if 1 3.4 GHZ cpu with 8 gb ram at it's disposal can do 10,000 as lim in 1 second then 3 cpus should do that in 1/3 a second (and I round to higher second as is atm)."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}]]