[[{"text": ["How about..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def nindex(mystr, substr, n=0, index=0):\n    for _ in xrange(n+1):\n        index = mystr.index(substr, index) + 1\n    return index - 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Obs: as str.index() does, nindex() raises ValueError when the substr is not found."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "str.index()", "tag": "a", "pos": 0, "childList": [{"text": "str.index()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#str.index"}, {"text": "str.index()", "childNum": 0, "tag": "code", "childList": []}, {"text": "nindex()", "childNum": 0, "tag": "code", "childList": []}, {"text": "ValueError", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Yes.", "Write a loop using s.index('yourstring', start)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "s.index('yourstring', start)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Update after finding a big fat -1 ... didn't I write some code??"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here's my attempt at redemption, which allows non-overlapping if desired, and is tested to the extent shown:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def nindex(haystack, needle, n, overlapping=True):\n...    delta = 1 if overlapping else max(1, len(needle))\n...    start = -delta\n...    for _unused in xrange(n):\n...       start = haystack.index(needle, start+delta)\n...    return start\n...\n&gt;&gt;&gt; for n in xrange(1, 11):\n...    print n, nindex('abcdefacbdea', 'a', n)\n...\n1 0\n2 6\n3 11\n4\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 5, in nindex\nValueError: substring not found\n&gt;&gt;&gt; for olap in (True, False):\n...    for n in (1, 2):\n...       print str(olap)[0], n, nindex('abababab', 'abab', n, olap)\n...\nT 1 0\nT 2 2\nF 1 0\nF 2 4\n&gt;&gt;&gt; for n in xrange(1, 8):\n...    print n, nindex('abcde', '', n)\n...\n1 0\n2 1\n3 2\n4 3\n5 4\n6 5\n7\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 5, in nindex\nValueError: substring not found\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n def nindex(needle, haystack, index=1):\n     parts = haystack.split(needle)\n     position = 0\n     length = len(needle)\n     for i in range(index - 1):\n         position += len(parts[i]) + length\n     return position\n</code>\n</pre>\n", "senID": 0}, {"text": ["I'm interested to see other solutions, I don't feel that this is particularly pythonic."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I would probably use"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [index for index, value in enumerate(s) if s == 'a'][n]\n</code>\n</pre>\n", "senID": 1}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from itertools import islice\nnext(islice((index for index, value in enumerate(s) if s == 'a'), n, None))\n</code>\n</pre>\n", "senID": 3}, {"text": ["or avoid dealing in indices at all."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; from re import finditer, escape\n&gt;&gt;&gt; from itertools import count, izip\n\n&gt;&gt;&gt; def nfind(s1, s2, n=1):\n...    \"\"\"return the index of the nth nonoverlapping occurance of s2 in s1\"\"\"\n...    return next(j.start() for i,j in izip(count(1), finditer(escape(s2),s1)) if i==n)\n...\n&gt;&gt;&gt; nfind(s,'a')\n0\n&gt;&gt;&gt; nfind(s,'a',2)\n6\n&gt;&gt;&gt; nfind(s,'a',3)\n11\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n def ifind( s, word, start=0 ):\n    pos = s.find(word,start)\n    while -1 &lt; pos:\n        yield pos\n        pos = s.find(word,pos+1)\n\nprint list(ifind('abcdefacbdea', 'a'))     # [0, 6, 11]\nprint list(ifind('eee', 'a'))              # []\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n def nindex(str, substr, index):\n  slice = str\n  n = 0\n  while index:\n    n += slice.index(substr) + len(substr)\n    slice = str[n:]\n    index -= 1\n  return slice.index(substr) + n\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n import itertools\ndef multis(search,text,start=0):\n    while start&gt;-1:\n        f=text.find(search,start)\n        start=f\n        if start&gt;-1:\n            yield f\n            start+=1\n\n# one based function for nth result only\ndef nindex(text,search,n):\n    return itertools.islice(multis(search,text),n-1,n).next()\n\ntext = 'abcdefacbdea'\nsearch = 'a'\nprint(\"Hit %i: %i\" % (3, nindex(text,search,3)))\nprint ('All hits: %s' % list(multis(search,text)))\n</code>\n</pre>\n", "senID": 0}, {"text": ["Without indexes:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def nthpartition(search,text,n=None):\n    ## nth partition before and after or all if not n\n    if not n:\n        n=len(text) # bigger always than maximum number of n\n    for i in range(n):\n        before,search,text = text.partition(search)\n        if not search:\n            return\n        yield before,text\n\ntext = 'abcdefacbdea'\nsearch = 'a'\nprint(\"Searching %r in %r\" % (search,text))\n\nfor parts in nthpartition(search,text): print(parts)\n\"\"\"Output:\nSearching 'a' in 'abcdefacbdea'\n('', 'bcdefacbdea')\n('bcdef', 'cbdea')\n('cbde', '')\n\"\"\"\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Here's a memoized version that avoids wasted work as much as possible while maintaining something close [1] to your specs (rather than doing something saner such as looping through \nall hits;-)...:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "memoized", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["[1]: just close -- can't have a new .nindex method in strings as you require, of course!-)"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "close", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": ".nindex", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def nindex(haystack, needle, nrep=1, _memo={}):\n  if nrep &lt; 1:\n    raise ValueError('%r &lt; 1' % (nrep,))\n  k = needle, haystack\n  if k in _memo:\n    where = _memo[k]\n  else:\n    where = _memo[k] = [-1]\n  while len(where) &lt;= nrep:\n    if where[-1] is None:\n      return -1\n    w = haystack.find(needle, where[-1] + 1)\n    if w &lt; 0:\n      where.append(None)\n      return -1\n    where.append(w)\n  return where[nrep]\n\ns = 'abcdefacbdea'\nprint nindex(s, 'a')\nprint nindex(s, 'a', 2)\nprint nindex(s, 'a', 3)\n</code>\n</pre>\n", "senID": 2}, {"text": ["print 0, then 6, then 11, as requested."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n import re\n\ndef nindex(text, n=1, default=-1):\n    return next(\n        itertools.islice((m.start() for m in re.finditer('a', text)), n - 1, None),\n        default\n    )\n\nprint nindex(s)\nprint nindex(s, 1)\nprint nindex(s, 2)\nprint nindex(s, 3)\nprint nindex(s, 4)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Just call 'index' repeatedly, using the result of the last call (+ 1) as start position:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def nindex(needle, haystack, n):\n\"find the nth occurrence of needle in haystack\"\n  pos = -1\n  for dummy in range(n):\n    pos = haystack.index(needle, pos + 1)\n  return pos\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note: I have not tested it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["How about..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # index is 0-based\ndef nindex(needle, haystack, index=0):\n     parts = haystack.split(needle)\n     if index &gt;= len(parts)-1:\n         return -1\n     return sum(len(x) for x in parts[:index+1])+index*len(needle)\n</code>\n</pre>\n", "senID": 1}]]