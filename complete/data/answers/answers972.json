[[{"text": ["In Python, there is a difference between functions and bound methods."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo():\n...     print \"foo\"\n...\n&gt;&gt;&gt; class A:\n...     def bar( self ):\n...         print \"bar\"\n...\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; foo\n&lt;function foo at 0x00A98D70&gt;\n&gt;&gt;&gt; a.bar\n&lt;bound method A.bar of &lt;__main__.A instance at 0x00A9BC88&gt;&gt;\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Bound methods have been \"bound\" (how descriptive) to an instance, and that instance will be passed as the first argument whenever the method is called."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Callables that are attributes of a class (as opposed to an instance) are still unbound, though, so you can modify the class definition whenever you want:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def fooFighters( self ):\n...     print \"fooFighters\"\n...\n&gt;&gt;&gt; A.fooFighters = fooFighters\n&gt;&gt;&gt; a2 = A()\n&gt;&gt;&gt; a2.fooFighters\n&lt;bound method A.fooFighters of &lt;__main__.A instance at 0x00A9BEB8&gt;&gt;\n&gt;&gt;&gt; a2.fooFighters()\nfooFighters\n</code>\n</pre>\n", "senID": 4}, {"text": ["Previously defined instances are updated as well (as long as they haven't overridden the attribute themselves):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a.fooFighters()\nfooFighters\n</code>\n</pre>\n", "senID": 6}, {"text": ["The problem comes when you want to attach a method to a single instance:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def barFighters( self ):\n...     print \"barFighters\"\n...\n&gt;&gt;&gt; a.barFighters = barFighters\n&gt;&gt;&gt; a.barFighters()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: barFighters() takes exactly 1 argument (0 given)\n</code>\n</pre>\n", "senID": 8}, {"text": ["The function is not automatically bound when it's attached directly to an instance:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a.barFighters\n&lt;function barFighters at 0x00A98EF0&gt;\n</code>\n</pre>\n", "senID": 10}, {"text": ["To bind it, we can use the MethodType function in the types module:"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "MethodType function in the types module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/types.html?highlight=methodtype#module-types"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import types\n&gt;&gt;&gt; a.barFighters = types.MethodType( barFighters, a )\n&gt;&gt;&gt; a.barFighters\n&lt;bound method ?.barFighters of &lt;__main__.A instance at 0x00A9BC88&gt;&gt;\n&gt;&gt;&gt; a.barFighters()\nbarFighters\n</code>\n</pre>\n", "senID": 12}, {"text": ["This time other instances of the class have not been affected:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a2.barFighters()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: A instance has no attribute 'barFighters'\n</code>\n</pre>\n", "senID": 14}, {"text": ["More information can be found by reading about descriptors and metaclass programming."], "childNum": 3, "tag": "p", "senID": 15, "childList": [{"text": "descriptors", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://users.rcn.com/python/download/Descriptor.htm"}, {"href": "http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html", "text": "metaclass", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://www.gnosis.cx/publish/programming/metaclass_2.html", "text": "programming", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Module new is deprecated since python 2.6 and removed in 3.0, use types"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "new", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "types", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["see http://docs.python.org/library/new.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/new.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/new.html"}]}, {"text": ["In the example below I've deliberately removed return value from patch_me() function.", "I think that giving return value may make one believe that patch returns a new object, which is not true - it modifies the incoming one.", "Probably this can facilitate a more disciplined use of monkeypatching."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import types\n\nclass A(object):#but seems to work for old style objects too\n    pass\n\ndef patch_me(target):\n    def method(target,x):\n        print \"x=\",x\n        print \"called from\", target\n    target.method = types.MethodType(method,target)\n    #add more if needed\n\na = A()\nprint a\n#out: &lt;__main__.A object at 0x2b73ac88bfd0&gt;  \npatch_me(a)    #patch instance\na.method(5)\n#out: x= 5\n#out: called from &lt;__main__.A object at 0x2b73ac88bfd0&gt;\npatch_me(A)\nA.method(6)        #can patch class too\n#out: x= 6\n#out: called from &lt;class '__main__.A'&gt;\n</code>\n</pre>\n", "senID": 3}], [{"text": ["In Python monkey patching generally works by overwriting a class or functions signature with your own.", "Below is an example from the Zope Wiki:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Zope Wiki", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://wiki.zope.org/zope2/MonkeyPatch"}]}, {"code": "<pre>\n<code>\n from SomeOtherProduct.SomeModule import SomeClass\n <br />\n def speak(self):\n <br />\n return \"ook ook eee eee eee!\"\n <br />\n SomeClass.speak = speak\n <br />\n</code>\n</pre>\n", "senID": 1}, {"text": ["That code will overwrite/create a method called speak on the class.", "In Jeff Atwood's recent post on monkey patching.", "He shows an example in C# 3.0 which is the current language I use for work."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "recent post on monkey patching", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.codinghorror.com/blog/archives/001151.html"}]}], [{"text": ["I also don't know Python, but this struck me as something that should be rather easy to find in Google."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I was right.", "(Note, I don't actually know if this is what you want, but it sure sounds like it."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "I was right.", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/monkey"}]}], [{"text": ["I think that the above answers missed the key point. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Let's have a class with a method:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    def m(self):\n        pass\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now, let's play with it in ipython:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n In [2]: A.m\nOut[2]: &lt;unbound method A.m&gt;\n</code>\n</pre>\n", "senID": 4}, {"text": ["Ok, so m() somehow becomes an unbound method of A.", "But is it really like that?"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "m()", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "A", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n In [5]: A.__dict__['m']\nOut[5]: &lt;function m at 0xa66b8b4&gt;\n</code>\n</pre>\n", "senID": 6}, {"text": ["It turns out that m() is just a function, reference to which is added to A class dictionary - there's no magic.", "Then why A.m gives us an unbound method?", "It's because the dot is not translated to a simple dictionary lookup.", "It's de facto a call of A.__class__.__getattribute__(A, 'm'):"], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "m()", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "A", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "A.m", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n In [11]: class MetaA(type):\n   ....:     def __getattribute__(self, attr_name):\n   ....:         print str(self), '-', attr_name\n\nIn [12]: class A(object):\n   ....:     __metaclass__ = MetaA\n\nIn [23]: A.m\n&lt;class '__main__.A'&gt; - m\n&lt;class '__main__.A'&gt; - m\n</code>\n</pre>\n", "senID": 8}, {"text": ["Now, I'm not sure out of the top of my head why the last line is printed twice, but still it's clear what's going on there."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Now, what the default __getattribute__ does is that it checks if the attribute is a so-called descriptor or not, i.e.", "if it implements a special __get__ method.", "If it implements that method, then what is returned is the result of calling that __get__ method.", "Going back to the first version of out A class, this is what we have:"], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "descriptor", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html#implementing-descriptors"}, {"text": "A", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n In [28]: A.__dict__['m'].__get__(None, A)\nOut[28]: &lt;unbound method A.m&gt;\n</code>\n</pre>\n", "senID": 11}, {"text": ["And because Python functions implement the descriptor protocol, if they are called on behalf  an object, they bound themselves to that object in their __get__ method."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Ok, so how to add a method to an existing object?", "Assuming you don't mind patching class, it's as simple as:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n B.m = m\n</code>\n</pre>\n", "senID": 14}, {"text": ["Then B.m \"becomes\" an unbound method, thanks to the descriptor magic."], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "B.m", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["And if you want to add a method just to a single object, then you have to emulate the machinery yourself, by using types.MethodType:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n b.m = types.MethodType(m, b)\n</code>\n</pre>\n", "senID": 17}, {"text": ["By the way:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n In [2]: A.m\nOut[2]: &lt;unbound method A.m&gt;\n\nIn [59]: type(A.m)\nOut[59]: &lt;type 'instancemethod'&gt;\n\nIn [60]: type(b.m)\nOut[60]: &lt;type 'instancemethod'&gt;\n\nIn [61]: types.MethodType\nOut[61]: &lt;type 'instancemethod'&gt;\n</code>\n</pre>\n", "senID": 19}], [{"text": ["I don't know Python syntax, but I know Ruby can do it, and it is rather trivial.", "Let's say you want to add a method to Array that prints the length to standard out:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Array\n <br />\n def print_length\n <br />\n puts length\n <br />\n end\n <br />\n end\n <br />\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you don't want to modify the whole class, you can just add the method to a single instance of the array, and no other arrays will have the method:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n array = [1, 2, 3]\n <br />\n def array.print_length\n <br />\n puts length\n <br />\n end\n <br />\n</code>\n</pre>\n", "senID": 3}, {"text": ["Just be aware of the issues involved in using this feature.", "Jeff Atwood actually wrote about it not too long ago."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "wrote about it", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.codinghorror.com/blog/archives/001151.html"}]}], [{"text": ["(I'm invoking the \"I don't know Python\" line here.", ") In Perl, you can create a package (which is how Perl implements the concept of a class) with the methods you want to patch in, then add that package to the @ISA of the package you want to patch.", "Heck, you can even edit the target package's symbol table directly."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@ISA", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["What you're looking for is setattr I believe.", "Use this to set an attribute on an object."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "setattr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def printme(s): print repr(s)\n <br />\n &gt;&gt;&gt; class A: pass\n <br />\n &gt;&gt;&gt; setattr(A,'printme',printme)\n <br />\n &gt;&gt;&gt; a = A()\n <br />\n &gt;&gt;&gt; a.printme() # s becomes the implicit 'self' variable\n <br />\n &lt; __ main __ . A instance at 0xABCDEFG&gt;\n <br />\n</code>\n</pre>", "senID": 1}], [{"text": ["What Jason Pratt posted is correct."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class Test(object):\n...   def a(self):\n...     pass\n... \n&gt;&gt;&gt; def b(self):\n...   pass\n... \n&gt;&gt;&gt; Test.b = b\n&gt;&gt;&gt; type(b)\n&lt;type 'function'&gt;\n&gt;&gt;&gt; type(Test.a)\n&lt;type 'instancemethod'&gt;\n&gt;&gt;&gt; type(Test.b)\n&lt;type 'instancemethod'&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["As you can see, Python doesn't consider b() any different than a().", "In Python all methods are just variables that happen to be functions. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Consolidating Jason Pratt's and the community wiki answers, with a look at the results of different methods of binding:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Especially note how adding the binding function as a class method works, but the referencing scope is incorrect."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "works", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/python -u\nimport types\nimport inspect\n\n## dynamically adding methods to a unique instance of a class\n\n\n# get a list of a class's method type attributes\ndef listattr(c):\n    for m in [(n, v) for n, v in inspect.getmembers(c, inspect.ismethod) if isinstance(v,types.MethodType)]:\n        print m[0], m[1]\n\n# externally bind a function as a method of an instance of a class\ndef ADDMETHOD(c, method, name):\n    c.__dict__[name] = types.MethodType(method, c)\n\nclass C():\n    r = 10 # class attribute variable to test bound scope\n\n    def __init__(self):\n        pass\n\n    #internally bind a function as a method of self's class -- note that this one has issues!\n    def addmethod(self, method, name):\n        self.__dict__[name] = types.MethodType( method, self.__class__ )\n\n    # predfined function to compare with\n    def f0(self, x):\n        print 'f0\\tx = %d\\tr = %d' % ( x, self.r)\n\na = C() # created before modified instnace\nb = C() # modified instnace\n\n\ndef f1(self, x): # bind internally\n    print 'f1\\tx = %d\\tr = %d' % ( x, self.r )\ndef f2( self, x): # add to class instance's .__dict__ as method type\n    print 'f2\\tx = %d\\tr = %d' % ( x, self.r )\ndef f3( self, x): # assign to class as method type\n    print 'f3\\tx = %d\\tr = %d' % ( x, self.r )\ndef f4( self, x): # add to class instance's .__dict__ using a general function\n    print 'f4\\tx = %d\\tr = %d' % ( x, self.r )\n\n\nb.addmethod(f1, 'f1')\nb.__dict__['f2'] = types.MethodType( f2, b)\nb.f3 = types.MethodType( f3, b)\nADDMETHOD(b, f4, 'f4')\n\n\nb.f0(0) # OUT: f0   x = 0   r = 10\nb.f1(1) # OUT: f1   x = 1   r = 10\nb.f2(2) # OUT: f2   x = 2   r = 10\nb.f3(3) # OUT: f3   x = 3   r = 10\nb.f4(4) # OUT: f4   x = 4   r = 10\n\n\nk = 2\nprint 'changing b.r from {0} to {1}'.format(b.r, k)\nb.r = k\nprint 'new b.r = {0}'.format(b.r)\n\nb.f0(0) # OUT: f0   x = 0   r = 2\nb.f1(1) # OUT: f1   x = 1   r = 10  !!!!!!!!!\nb.f2(2) # OUT: f2   x = 2   r = 2\nb.f3(3) # OUT: f3   x = 3   r = 2\nb.f4(4) # OUT: f4   x = 4   r = 2\n\nc = C() # created after modifying instance\n\n# let's have a look at each instance's method type attributes\nprint '\\nattributes of a:'\nlistattr(a)\n# OUT:\n# attributes of a:\n# __init__ &lt;bound method C.__init__ of &lt;__main__.C instance at 0x000000000230FD88&gt;&gt;\n# addmethod &lt;bound method C.addmethod of &lt;__main__.C instance at 0x000000000230FD88&gt;&gt;\n# f0 &lt;bound method C.f0 of &lt;__main__.C instance at 0x000000000230FD88&gt;&gt;\n\nprint '\\nattributes of b:'\nlistattr(b)\n# OUT:\n# attributes of b:\n# __init__ &lt;bound method C.__init__ of &lt;__main__.C instance at 0x000000000230FE08&gt;&gt;\n# addmethod &lt;bound method C.addmethod of &lt;__main__.C instance at 0x000000000230FE08&gt;&gt;\n# f0 &lt;bound method C.f0 of &lt;__main__.C instance at 0x000000000230FE08&gt;&gt;\n# f1 &lt;bound method ?.f1 of &lt;class __main__.C at 0x000000000237AB28&gt;&gt;\n# f2 &lt;bound method ?.f2 of &lt;__main__.C instance at 0x000000000230FE08&gt;&gt;\n# f3 &lt;bound method ?.f3 of &lt;__main__.C instance at 0x000000000230FE08&gt;&gt;\n# f4 &lt;bound method ?.f4 of &lt;__main__.C instance at 0x000000000230FE08&gt;&gt;\n\nprint '\\nattributes of c:'\nlistattr(c)\n# OUT:\n# attributes of c:\n# __init__ &lt;bound method C.__init__ of &lt;__main__.C instance at 0x0000000002313108&gt;&gt;\n# addmethod &lt;bound method C.addmethod of &lt;__main__.C instance at 0x0000000002313108&gt;&gt;\n# f0 &lt;bound method C.f0 of &lt;__main__.C instance at 0x0000000002313108&gt;&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["Personally, I prefer the external ADDMETHOD function route, as it allows me to dynamically assign new method names within an iterator as well."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def y(self, x):\n    pass\nd = C()\nfor i in range(1,5):\n    ADDMETHOD(d, y, 'f%d' % i)\nprint '\\nattributes of d:'\nlistattr(d)\n# OUT:\n# attributes of d:\n# __init__ &lt;bound method C.__init__ of &lt;__main__.C instance at 0x0000000002303508&gt;&gt;\n# addmethod &lt;bound method C.addmethod of &lt;__main__.C instance at 0x0000000002303508&gt;&gt;\n# f0 &lt;bound method C.f0 of &lt;__main__.C instance at 0x0000000002303508&gt;&gt;\n# f1 &lt;bound method ?.y of &lt;__main__.C instance at 0x0000000002303508&gt;&gt;\n# f2 &lt;bound method ?.y of &lt;__main__.C instance at 0x0000000002303508&gt;&gt;\n# f3 &lt;bound method ?.y of &lt;__main__.C instance at 0x0000000002303508&gt;&gt;\n# f4 &lt;bound method ?.y of &lt;__main__.C instance at 0x0000000002303508&gt;&gt;\n</code>\n</pre>\n", "senID": 4}]]