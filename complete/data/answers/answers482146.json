[[{"code": "<pre>\n<code>\n import string\nimport itertools\n\nchars = string.digits + string.letters\nMAX_CHARS = 4\nfor nletters in range(MAX_CHARS):\n    for word in itertools.product(chars, repeat=nletters + 1):\n        print (''.join(word))\n</code>\n</pre>\n", "senID": 0}, {"text": ["That'll print all 15018570 words you're looking for.", "If you want more/less words just change the MAX_CHARS variable.", "It will still have just two fors for any number of chars, and you don't have to repeat yourself.", "And is pretty readable."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "15018570", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "15018570", "tag": "code"}]}, {"text": "15018570", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "MAX_CHARS", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["I'm going to submit my answer as the most readable and least scalable :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import string\nchars = [''] + list(string.lowercase)\n\nstrings = (a+b+c+d for a in chars\n                   for b in chars\n                   for c in chars\n                   for d in chars)\n\nfor string in strings:\n    print string\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: Actually, this is incorrect, as it will produce duplicates of all strings of length&lt;4.", "Removing the empty string from the chars array would just produce 4-char strings.  "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "chars", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Normally I'd delete this answer, but I still kinda like it if you need to generate strings of the same length."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Write for the programmer first - the computer second.", "If it's clear and obvious to understand then its correct."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["If speed matters AND the compiler doesn't optimise it anyway AND if you measure it AND it is the problem - then think of a faster cleverer way!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I don't think it's a bad thing, provided you understand (and document :-) it.", "I don't doubt there may be a more pythonic way or clever solution (with lambdas or whatnot) but I've always favored readability over cleverness."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Since you have to generate all possibilities of 1-, 2-, 3- and 4-character \"words\", this method is as good as any.", "I'm not sure how long it would take since you're effectively generating (very roughly) 14 million lines of output (but probably every solution would have that problem)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Pre-calculating the common prefixes may provide a speed boost but you'd be better off measuring it to check (always check, never assume):"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "always", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "never", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n chars = string.digits + string.uppercase + string.lowercase\nfor a in chars:\n    print a\n    for b in chars:\n        ab = '%s%s' % (a, b)\n        print ab\n        for c in chars:\n            abc = '%s%s' % (ab, c)\n            print abc\n            for d in chars:\n                print '%s%s' % (abc, d)\n</code>\n</pre>\n", "senID": 3}, {"text": ["EDIT: I actually did some benchmarks (with Windows-Python 2.6.1) - this version takes about 2.25 time units compared to the original 2.84 so it's 26% faster.", "I think that might warrant its use (again, as long as it's documented clearly what it's trying to achieve)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["There are many algorithms for generating every permutation of a set.", "What you want here is a related problem, but not directly analagous.", "Suggested Reading"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Suggested Reading", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Permutation#Algorithms_to_generate_permutations"}]}], [{"text": ["@nosklo's and @Triptych's solutions produce different results:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "@nosklo's", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/482146/replace-nested-for-loops-or-not#482192"}, {"href": "http://stackoverflow.com/questions/482146/replace-nested-for-loops-or-not#482217", "text": "@Triptych's", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(map(''.join, itertools.chain.from_iterable(itertools.product(\"ab\", \n...     repeat=r) for r in range(4)))) # @nosklo's\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n['', 'a', 'b', 'aa', 'ab', 'ba', 'bb', 'aaa', 'aab', 'aba', 'abb', 'baa', \n 'bab', 'bba', 'bbb']\n</pre>\n", "senID": 2}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; ab = ['']+list(\"ab\")\n&gt;&gt;&gt; list(map(''.join, (a+b+c for a in ab for b in ab for c in ab)))\n</code>\n</pre>\n", "senID": 3}, {"code": "<pre>\n['', 'a', 'b', 'a', 'aa', 'ab', 'b', 'ba', 'bb', 'a', 'aa', 'ab', 'aa', \n 'aaa', 'aab', 'ab', 'aba', 'abb', 'b', 'ba', 'bb', 'ba', 'baa', 'bab', \n 'bb',  'bba', 'bbb']\n</pre>\n", "senID": 4}, {"text": ["Here's modified @Triptych's solution that produce the same output as the @nosklo's one:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; ab = \"ab\"\n&gt;&gt;&gt; list(map(''.join, itertools.chain([''], ab, (a+b for a in ab for b in ab),\n...     (a+b+c for a in ab for b in ab for c in ab))))\n</code>\n</pre>\n", "senID": 6}, {"code": "<pre>\n['', 'a', 'b', 'aa', 'ab', 'ba', 'bb', 'aaa', 'aab', 'aba', 'abb', 'baa', \n 'bab', 'bba', 'bbb']\n</pre>\n", "senID": 7}], [{"text": ["It doesn't exactly answer the question, but this would return the nth combination for the given maximum length and characters in the alphabet to use:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n\ndef nth_combination(n, maxlen=4, alphabet='abc'):\n    \"\"\"\n    &gt;&gt;&gt; print ','.join(nth_combination(n, 1, 'abc') for n in range(3))\n    a,b,c\n    &gt;&gt;&gt; print ','.join(nth_combination(n, 2, 'abc') for n in range(12))\n    a,aa,ab,ac,b,ba,bb,bc,c,ca,cb,cc\n    &gt;&gt;&gt; import string ; alphabet = string.ascii_letters + string.digits\n    &gt;&gt;&gt; print ','.join(nth_combination(n, 4, alphabet) for n in range(16))\n    a,aa,aaa,aaaa,aaab,aaac,aaad,aaae,aaaf,aaag,aaah,aaai,aaaj,aaak,aaal,aaam\n    &gt;&gt;&gt; print ','.join(nth_combination(n, 4, alphabet)\n    ...                for n in range(0, 14000000, 10**6))\n    a,emiL,iyro,mKz2,qWIF,u8Ri,zk0U,Dxav,HJi9,LVrM,P7Ap,UjJ1,YvSE,2H1h\n    \"\"\"\n    if maxlen == 1:\n        return alphabet[n]\n    offset, next_n = divmod(n, 1 + len(alphabet)**(maxlen-1))\n    if next_n == 0:\n        return alphabet[offset]\n    return alphabet[offset] + nth_combination(next_n-1, maxlen-1, alphabet)\n\nif __name__ == '__main__':\n    from doctest import testmod\n    testmod()\n</code>\n</pre>\n", "senID": 1}, {"text": ["This of course makes sense only if you need random access to the set of combinations instead of always iterating through them all."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If maxlen is high, some speed optimization could be achieved e.g.", "by getting rid of string concatenation and re-calculating the length of alphabet and maxlen-1 at each level of the recursion.", "A non-recursive approach might make sense, too."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "maxlen", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "alphabet", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "maxlen-1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}]]