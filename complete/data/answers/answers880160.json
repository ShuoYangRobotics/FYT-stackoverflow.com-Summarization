[[{"text": ["Instead of: \"print hasattr(d1,each)\", try: \"print each, type(getattr(d1,each))\".", "You should find the results informative. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "print hasattr(d1,each)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "print each, type(getattr(d1,each))", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Also, in place of dir() try help(), which I think you're really looking for."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "dir()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "help()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Consider using the standard library's inspect module -- it's often the handiest approach to introspection, packaging up substantial chunks of functionality (you could implement that from scratch, but reusing well-tested, well-designed code is a good thing).", "See http://docs.python.org/library/inspect.html for all the details, but for example inspect.getmembers(foo, inspect.ismethod) is an excellent way to get all methods of foo (you'll get (name, value) pairs sorted by name)."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "inspect", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "http://docs.python.org/library/inspect.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/inspect.html"}, {"text": "inspect.getmembers(foo, inspect.ismethod)", "childNum": 0, "tag": "code", "childList": []}, {"text": "(name, value)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Why is it misleading?", "If obj.ban() is a method, then obj.ban is the corresponding attribute.", "You can have code like this:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "obj.ban()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "obj.ban", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n print obj.getValue()\n</code>\n</pre>\n", "senID": 1}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n get = obj.getValue\nprint get()\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you want to get a list of methods on an object, you can try this function.", "It's not perfect, since it will also trigger for callable attributes that aren't methods, but for 99% of cases should be good enough:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def methods(obj):\n    attrs = (getattr(obj, n) for n in dir(obj))\n    return [a for a in attrs if a.hasattr(\"__call__\")]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["This info module inspired from Dive into Python serves the purpose. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "info", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def info(obj, spacing=20, collapse=1, variables=False):\n    '''Print methods and their doc Strings\n\n    Takes any object'''\n    if variables:\n\tmethodList = [method for method in dir(obj)]\n    else:\n\tmethodList = [method for method in dir(obj) if callable(getattr(obj,method))]\n\n    #print methodList\n\n\n    print '\\n'.join(['%s %s' %\n\t\t    (method.ljust(spacing),\n\t\t     \" \".join(str(getattr(obj,method).__doc__).split()))\n\t\t    for method in methodList])\n\n\nif __name__=='__main__':\n    info(list)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Ideally, when using a complicated library like BeautifulSoup, you should consult its documentation to see what methods each class provides.", "However, in the rare case where you don't have easily accessible documentation, you can check for the presence of methods using the following. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["All methods, which themselves are objects, implement the __call__ method and can be checked using the callable() method which returns True, if the value being checked has the __call__ method. "], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "__call__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "childList": []}, {"text": "__call__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The following code should work."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n x = Die()\nx.roll()\n\nfor attribute in dir(x) :\n    print attribute, callable(getattr(x, attribute))\n</code>\n</pre>\n", "senID": 3}, {"text": ["The above code would return true for all the methods and false for all non callable attributes (such as data members like ban).", "However, this method also returns True for any callable objects (like inner classes).", "you can also check if the type of the attribute is instancemethod"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "True", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "instancemethod", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["There is a built in method called callable.", "You can apply it to any object and it will return True/False depending on if it can be called.", "e.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo():\n...   print \"This is the only function now\"\n...\n&gt;&gt;&gt; localDictionary = dir()\n&gt;&gt;&gt; for item in localDictionary:\n...   print repr(item) + \"is callable: \" + str(callable(locals()[item]))\n'__builtins__'is callable: False\n'__doc__'is callable: False\n'__name__'is callable: False\n'foo'is callable: True\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note the locals() call will return a dictionary containing everything defined in your current scope.", "I did this because the items out of the dictionary are just strings, and we need to run callable on the actual object."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]