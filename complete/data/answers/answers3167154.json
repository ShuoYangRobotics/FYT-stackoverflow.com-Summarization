[[{"text": ["I've been bitten loads of times by people writing their own path fiddling functions and getting it wrong.", "Spaces, slashes, backslashes, colons -- the possibilities for confusion are not endless, but mistakes are easily made anyway.", "So I'm a stickler for the use of os.path, and recommend it on that basis."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "os.path", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["(However, the path to virtue is not the one most easily taken, and many people when finding this are tempted to take a slippery path straight to damnation.", "They won't realise until one day everything falls to pieces, and they -- or, more likely, somebody else -- has to work out why everything has gone wrong, and it turns out somebody made a filename that mixes slashes and backslashes -- and some person suggests that the answer is \"not to do that\".", "Don't be any of these people.", "Except for the one who mixed up slashes and backslashes -- you could be them if you like."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can get the drive and path+file like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n drive,path_and_file=os.path.splitdrive(path)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Get the path and the file:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n path,file=os.path.split(path_and_file)\n</code>\n</pre>\n", "senID": 5}, {"text": ["Getting the individual folder names is not especially convenient, but it is the sort of honest middling discomfort that heightens the pleasure of later finding something that actually works well:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n folders=[]\nwhile 1:\n    path,folder=os.path.split(path)\n\n    if folder!=\"\":\n        folders.append(folder)\n    else:\n        if path!=\"\":\n            folders.append(path)\n\n        break\n\nfolders.reverse()\n</code>\n</pre>\n", "senID": 7}, {"text": ["(This pops a \"\\\" at the start of folders if the path was originally absolute.", "You could lose a bit of code if you didn't want that."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "\"\\\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "folders", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["The problem here starts with how you're creating the string in the first place."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = \"d:\\stuff\\morestuff\\furtherdown\\THEFILE.txt\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Done this way, Python is trying to special case these: \\s, \\m, \\f, and \\T'.", "In your case,\\f` is being treated as a formfeed (0x0C) while the other backslashes are handled correctly.", "What you need to do is one of these:"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "\\s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\m", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\\f", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\\T'.  In your case,", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n b = \"d:\\\\stuff\\\\morestuff\\\\furtherdown\\\\THEFILE.txt\"      # doubled backslashes\nc = r\"d:\\stuff\\morestuff\\furtherdown\\THEFILE.txt\"         # raw string, no doubling necessary\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then once you split either of these, you'll get the result you want."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["It works for me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a=r\"d:\\stuff\\morestuff\\furtherdown\\THEFILE.txt\"\n&gt;&gt;&gt; a.split(\"\\\\\")\n['d:', 'stuff', 'morestuff', 'furtherdown', 'THEFILE.txt']\n</code>\n</pre>\n", "senID": 1}, {"text": ["Sure you might need to also strip out the colon from the first component, but keeping it makes it possible to re-assemble the path."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The r modifier marks the string literal as \"raw\"; notice how embedded backslashes are not doubled."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "r", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The stuff about about mypath.split(\"\\\") would be better expressed as mypath.split(os.pathsep).", "pathsep is the path separator for your particular platform (e.g., \\ for windows, / for unix, etc), and the python build knows which one to use.", "If you use pathsep, then your code will be platform agnostic."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Let assume you have have a file filedata.txt with content:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "filedata.txt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n d:\\stuff\\morestuff\\furtherdown\\THEFILE.txt\nd:\\otherstuff\\something\\otherfile.txt\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can read and split the file paths:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for i in open(\"filedata.txt\").readlines():\n...     print i.strip().split(\"\\\\\")\n... \n['d:', 'stuff', 'morestuff', 'furtherdown', 'THEFILE.txt']\n['d:', 'otherstuff', 'something', 'otherfile.txt']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["use ntpath.split()"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ntpath.split()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Just like others explained - your problem stemmed from using \\, which is escape character in string literal/constant.", "OTOH, if you had that file path string from another source (read from file, console or returned by os function) - there wouldn't have been problem splitting on '\\\\' or r'\\'."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\\", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["And just like others suggested, if you want to use \\ in program literal, you have to either duplicate it \\\\ or the whole literal has to be prefixed by r, like so r'lite\\ral' or r\"lite\\ral\" to avoid the parser converting that \\ and r to CR (carriage return) character."], "childNum": 7, "tag": "p", "senID": 1, "childList": [{"text": "\\", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\\\", "childNum": 0, "tag": "code", "childList": []}, {"text": "r", "childNum": 0, "tag": "code", "childList": []}, {"text": "r'lite\\ral'", "childNum": 0, "tag": "code", "childList": []}, {"text": "r\"lite\\ral\"", "childNum": 0, "tag": "code", "childList": []}, {"text": "\\", "childNum": 0, "tag": "code", "childList": []}, {"text": "r", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["There is one more way though - just don't use backslash \\ pathnames in your code!", "Since last century Windows recognizes and works fine with pathnames which use forward slash as directory separator /!", "Somehow not many people know that.. but it works:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "\\", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "/", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; var = \"d:/stuff/morestuff/furtherdown/THEFILE.txt\"\n&gt;&gt;&gt; var.split('/')\n['d:', 'stuff', 'morestuff', 'furtherdown', 'THEFILE.txt']\n</code>\n</pre>\n", "senID": 3}, {"text": ["This by the way will make your code work on Unix, Windows and Mac... because all of them do use / as directory separator... even if you don't want to use the predefined constants of module os."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "/", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "os", "childNum": 0, "tag": "code", "childList": []}]}]]