[[{"text": ["You can use the multiprocessing module added in Python 2.6.", "You can use pools of processes and then get results asynchronously with: "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "multiprocessing module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/multiprocessing.html#module-multiprocessing"}]}, {"code": "<pre>\n<code>\n apply_async(func[, args[, kwds[, callback]]])\n</code>\n</pre>\n", "senID": 1}, {"text": ["E.g."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from multiprocessing import Pool\n\ndef f(x):\n    return x*x\n\nif __name__ == '__main__':\n    pool = Pool(processes=1)              # Start a worker processes.\n    result = pool.apply_async(f, [10], callback) # Evaluate \"f(10)\" asynchronously calling callback when finished.\n</code>\n</pre>\n", "senID": 3}, {"text": ["This is only one alternative.", "This module provides lots of facilities to achieve what you want.", "Also it will be really easy to make a decorator from this."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["It's not in the language core, but a very mature library that does what you want is Twisted.", "It introduces the Deferred object, which you can attach callbacks or error handlers (\"errbacks\") to.", "A Deferred is basically a \"promise\" that a function will have a result eventually."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Twisted", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://twistedmatrix.com/projects/core/documentation/howto/async.html"}]}], [{"text": ["What about something like (doc at http://docs.python.org/library/threading.html#module-threading)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/threading.html#module-threading", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/threading.html#module-threading"}]}, {"code": "<pre>\n<code>\n import threading\n\nthr = threading.Thread(target=foo, [args=(), kwargs={}])\nthr.start() # will run \"foo\"\n....\nthr.is_alive() # will return whether foo is running currently\n....\nthr.join() # will wait till \"foo\" is done\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Is there any reason not to use threads?", "You can use the \"threading\" class.", "Instead of finished() function use the isAlive(), the result() function could join() the thread and retrieve the result and if you can override the run() and init functions to call the function specified in constructor and save the value somewhere to the instance of the class."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "init", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}], [{"text": ["You can implement a decorator to make your functions asynchronous, though that's a bit tricky.", "The multiprocessing module is full of little quirks and seemingly arbitrary restrictions \u2013 all the more reason to encapsulate it behind a friendly interface, though."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "multiprocessing", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from inspect import getmodule\nfrom multiprocessing import Pool\n\n\ndef async(decorated):\n    r'''Wraps a top-level function around an asynchronous dispatcher.\n\n        when the decorated function is called, a task is submitted to a\n        process pool, and a future object is returned, providing access to an\n        eventual return value.\n\n        The future object has a blocking get() method to access the task\n        result: it will return immediately if the job is already done, or block\n        until it completes.\n\n        This decorator won't work on methods, due to limitations in Python's\n        pickling machinery (in principle methods could be made pickleable, but\n        good luck on that).\n    '''\n    # Keeps the original function visible from the module global namespace,\n    # under a name consistent to its __name__ attribute. This is necessary for\n    # the multiprocessing pickling machinery to work properly.\n    module = getmodule(decorated)\n    decorated.__name__ += '_original'\n    setattr(module, decorated.__name__, decorated)\n\n    def send(*args, **opts):\n        return async.pool.apply_async(decorated, args, opts)\n\n    return send\n</code>\n</pre>\n", "senID": 1}, {"text": ["The code below illustrates usage of the decorator:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n @async\ndef printsum(uid, values):\n    summed = 0\n    for value in values:\n        summed += value\n\n    print(\"Worker %i: sum value is %i\" % (uid, summed))\n\n    return (uid, summed)\n\n\nif __name__ == '__main__':\n    from random import sample\n\n    # The process pool must be created inside __main__.\n    async.pool = Pool(4)\n\n    p = range(0, 1000)\n    results = []\n    for i in range(4):\n        result = printsum(i, sample(p, 100))\n        results.append(result)\n\n    for result in results:\n        print(\"Worker %i: sum value is %i\" % result.get())\n</code>\n</pre>\n", "senID": 3}, {"text": ["In a real-world case I would ellaborate a bit more on the decorator, providing some way to turn it off for debugging (while keeping the future interface in place), or maybe a facility for dealing with exceptions; but I think this demonstrates the principle well enough."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["http://docs.python.org/library/multiprocessing.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/multiprocessing.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/multiprocessing.html"}]}, {"text": ["simplest use with django view: https://gist.github.com/775697"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "https://gist.github.com/775697", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://gist.github.com/775697"}]}], [{"text": ["My solution is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import threading\n\nclass TimeoutError(RuntimeError):\n    pass\n\nclass AsyncCall(object):\n    def __init__(self, fnc, callback = None):\n        self.Callable = fnc\n        self.Callback = callback\n\n    def __call__(self, *args, **kwargs):\n        self.Thread = threading.Thread(target = self.run, name = self.Callable.__name__, args = args, kwargs = kwargs)\n        self.Thread.start()\n        return self\n\n    def wait(self, timeout = None):\n        self.Thread.join(timeout)\n        if self.Thread.isAlive():\n            raise TimeoutError()\n        else:\n            return self.Result\n\n    def run(self, *args, **kwargs):\n        self.Result = self.Callable(*args, **kwargs)\n        if self.Callback:\n            self.Callback(self.Result)\n\nclass AsyncMethod(object):\n    def __init__(self, fnc, callback=None):\n        self.Callable = fnc\n        self.Callback = callback\n\n    def __call__(self, *args, **kwargs):\n        return AsyncCall(self.Callable, self.Callback)(*args, **kwargs)\n\ndef Async(fnc = None, callback = None):\n    if fnc == None:\n        def AddAsyncCallback(fnc):\n            return AsyncMethod(fnc, callback)\n        return AddAsyncCallback\n    else:\n        return AsyncMethod(fnc, callback)\n</code>\n</pre>\n", "senID": 1}, {"text": ["And works exactly as requested:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n @Async\ndef fnc():\n    pass\n</code>\n</pre>\n", "senID": 3}]]