[[{"text": ["If you're deleting multiple non-adjacent items, then what you describe is the best way (and yes, be sure to start from the highest index)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If your items are adjacent, you can use the slice assignment syntax:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a[2:10] = []\n</code>\n</pre>\n", "senID": 2}], [{"text": ["prob not the best, but here it goes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n indices = 0, 2\nsomelist = [i for j, i in enumerate(somelist) if j not in indices]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["So, you essentially want to delete multiple elements in one pass?", "In that case, the position of the next element to delete will be offset by however many were deleted previously."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Our goal is to delete all the vowels, which are precomputed to be indices 1, 4, and 7.", "Note that its important the to_delete indices are in ascending order, otherwise it won't work."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n to_delete = [1, 4, 7]\ntarget = list(\"hello world\")\nfor offset, index in enumerate(to_delete):\n  index -= offset\n  del target[index]\n</code>\n</pre>\n", "senID": 2}, {"text": ["It'd be a more complicated if you wanted to delete the elements in any order.", "IMO, sorting to_delete might be easier than figuring out when you should or shouldn't subtract from index."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "to_delete", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "index", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["As a function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def multi_delete(list_, *args):\n    indexes = sorted(list(args), reverse=True)\n    for index in indexes:\n        del list_[index]\n    return list_\n</code>\n</pre>\n", "senID": 1}, {"text": ["Runs in n log(n) time, which should make it the fastest correct solution yet."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "n log(n)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["You can do that way on a dict, not on a list.", "In a list elements are in sequence.", "In a dict they depend only on the index."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Simple code just to explain it by doing:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "by doing", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; lst = ['a','b','c']\n&gt;&gt;&gt; dct = {0: 'a', 1: 'b', 2:'c'}\n&gt;&gt;&gt; lst[0]\n'a'\n&gt;&gt;&gt; dct[0]\n'a'\n&gt;&gt;&gt; del lst[0]\n&gt;&gt;&gt; del dct[0]\n&gt;&gt;&gt; lst[0]\n'b'\n&gt;&gt;&gt; dct[0]\nTraceback (most recent call last):\n  File \"&lt;pyshell#19&gt;\", line 1, in &lt;module&gt;\n    dct[0]\nKeyError: 0\n&gt;&gt;&gt; dct[1]\n'b'\n&gt;&gt;&gt; lst[1]\n'c'\n</code>\n</pre>\n", "senID": 2}, {"text": ["A way to \"convert\" a list in a dict is:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dct = {}\n&gt;&gt;&gt; for i in xrange(0,len(lst)): dct[i] = lst[i]\n</code>\n</pre>\n", "senID": 4}, {"text": ["The inverse is:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n lst = [dct[i] for i in sorted(dct.keys())]\n</code>\n</pre>\n", "senID": 6}, {"text": ["Anyway I think it's better to start deleting from the higher index as you said."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I can actually think of two ways to do it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["As a specialisation of Greg's answer, you can even use extended slice syntax.", "eg.", "If you wanted to delete items 0 and 2:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a= [0, 1, 2, 3, 4]\n&gt;&gt;&gt; del a[0:3:2]\n&gt;&gt;&gt; a\n[1, 3, 4]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This doesn't cover any arbitrary selection, of course, but it can certainly work for deleting any two items."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["here is another method which removes the elements in place.", "also if your list is really long, it is faster."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = range(10)\n&gt;&gt;&gt; remove = [0,4,5]\n&gt;&gt;&gt; from collections import deque\n&gt;&gt;&gt; deque((list.pop(a, i) for i in sorted(remove, reverse=True)), maxlen=0)\n\n&gt;&gt;&gt; timeit.timeit('[i for j, i in enumerate(a) if j not in remove]', setup='import random;remove=[random.randrange(100000) for i in range(100)]; a = range(100000)', number=1)\n0.1704120635986328\n\n&gt;&gt;&gt; timeit.timeit('deque((list.pop(a, i) for i in sorted(remove, reverse=True)), maxlen=0)', setup='from collections import deque;import random;remove=[random.randrange(100000) for i in range(100)]; a = range(100000)', number=1)\n0.004853963851928711\n</code>\n</pre>\n", "senID": 1}]]