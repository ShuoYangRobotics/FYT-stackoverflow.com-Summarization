[[{"text": ["First normalize 2 XML, then you can compare them.", "I've used the following using lxml"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n obj1 = objectify.fromstring(expect)\n    expect = etree.tostring(obj1)        \n    obj2 = objectify.fromstring(xml)\n    result = etree.tostring(obj2)        \n    self.assertEquals(expect, result)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If the problem is really just the whitespace and attribute order, and you have no other constructs than text and elements to worry about, you can parse the strings using a standard XML parser and compare the nodes manually.", "Here's an example using minidom, but you could write the same in etree pretty simply:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def isEqualXML(a, b):\n    da, db= minidom.parseString(a), minidom.parseString(b)\n    return isEqualElement(da.documentElement, db.documentElement)\n\ndef isEqualElement(a, b):\n    if a.tagName!=b.tagName:\n        return False\n    if sorted(a.attributes.items())!=sorted(b.attributes.items()):\n        return False\n    if len(a.childNodes)!=len(b.childNodes):\n        return False\n    for ac, bc in zip(a.childNodes, b.childNodes):\n        if ac.nodeType!=bc.nodeType:\n            return False\n        if ac.nodeType==ac.TEXT_NODE and ac.data!=bc.data:\n            return False\n        if ac.nodeType==ac.ELEMENT_NODE and not isEqualElement(ac, bc):\n            return False\n    return True\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you need a more thorough equivalence comparison, covering the possibilities of other types of nodes including CDATA, PIs, entity references, comments, doctypes, namespaces and so on, you could use the DOM Level 3 Core method isEqualNode.", "Neither minidom nor etree have that, but pxdom is one implementation that supports it:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def isEqualXML(a, b):\n    da, db= pxdom.parseString(a), pxdom.parseString(a)\n    return da.isEqualNode(db)\n</code>\n</pre>\n", "senID": 3}, {"text": ["(You may want to change some of the DOMConfiguration options on the parse if you need to specify whether entity references and CDATA sections match their replaced equivalents."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["A slightly more roundabout way of doing it would be to parse, then re-serialise to canonical form and do a string comparison.", "Again pxdom supports the DOM Level 3 LS option \u2018canonical-form\u2019 which you could use to do this; an alternative way using the stdlib's minidom implementation is to use c14n.", "However you must have the PyXML extensions install for this so you still can't quite do it within the stdlib:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from xml.dom.ext import c14n\n\ndef isEqualXML(a, b):\n    da, bd= minidom.parseString(a), minidom.parseString(b)\n    a, b= c14n.Canonicalize(da), c14n.Canonicalize(db)\n    return a==b\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Use xmldiff, a python tool that figures out the differences between two similar XML files, the same way that diff does it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "xmldiff", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.logilab.org/859"}]}], [{"text": ["Why are you examining the XML data at all?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The way to test object serialization is to create an instance of the object, serialize it, deserialize it into a new object, and compare the two objects.", "When you make a change that breaks serialization or deserialization, this test will fail."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The only thing checking the XML data is going to find for you is if your serializer is emitting a superset of what the deserializer requires, and the deserializer silently ignores stuff it doesn't expect."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Of course, if something else is going to be consuming the serialized data, that's another matter.", "But in that case, you ought to be thinking about establishing a schema for the XML and validating it."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This is an old question, but the accepted Kozyarchuk's answer doesn't work for me because of attributes order, and the minidom solution doesn't work as-is either (no idea why, I haven't debugged it). "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is what I finally came up with:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from doctest import Example\nfrom lxml.doctestcompare import LXMLOutputChecker\n\nclass XmlTest(TestCase):\n    def assertXmlEqual(self, got, want):\n        checker = LXMLOutputChecker()\n        if not checker.check_output(want, got, 0):\n            message = checker.output_difference(Example(\"\", want), got, 0)\n            raise AssertionError(message)\n</code>\n</pre>\n", "senID": 2}, {"text": ["This also produces a diff that can be helpful in case of large xml files."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The Java component dbUnit does a lot of XML comparisons, so you might find it useful to look at their approach (especially to find any gotchas that they may have already addressed)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dbUnit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I also had this problem and did some digging around it today.", "The doctestcompareapproach may suffice, but I found via Ian Bicking that it is based on formencode.doctest_xml_compare.", "Which appears to now be here.", "As you can see that is a pretty simple function, unlike doctestcompare (although I guess doctestcompare is collecting all the failures and maybe more sophisticated checking).", "Anyway copying/importing xml_compare out of formencode may be a good solution."], "childNum": 10, "tag": "p", "senID": 0, "childList": [{"text": "doctestcompareapproach", "tag": "a", "pos": 1, "childList": [{"text": "doctestcompare", "tag": "code"}], "childNum": 1, "href": "http://stackoverflow.com/questions/321795/comparing-xml-in-a-unit-test-in-python/7060342#7060342"}, {"text": "doctestcompare", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "Ian Bicking", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://blog.ianbicking.org/2007/09/24/lxmlhtml/"}, {"text": "formencode.doctest_xml_compare", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "here", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "https://bitbucket.org/formencode/official-formencode/src/3be5078c6030/formencode/doctest_xml_compare.py#cl-70"}, {"text": "doctestcompare", "tag": "a", "pos": -1, "childList": [{"text": "doctestcompare", "tag": "code"}], "childNum": 1, "href": "https://github.com/lxml/lxml/blob/master/src/lxml/doctestcompare.py"}, {"text": "doctestcompare", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "doctestcompare", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "xml_compare", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "formencode", "childNum": 0, "tag": "code", "childList": []}]}]]