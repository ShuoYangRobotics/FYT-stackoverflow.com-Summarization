[[{"text": ["You need a lot of escapes in your regular expression since {, } and | are special characters in them.", "A first step to extract the relevant parts of the string would be this:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "{", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "}", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "|", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n regex = re.compile(r'\\{\\{(.*?)\\|(.*?)(?:\\|(.*?))?\\}\\}')\nregex.findall(line)\n</code>\n</pre>\n", "senID": 1}, {"text": ["For the example this gives:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [('bla', '123', '456'), ('bli', '789', '123'), ('blu', '789', '')]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then you can continue with converting strings with digits into integers and removing empty strings like for the last match."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; re.findall(' {{(\\w+)\\|(\\w+)(?:\\|(\\w+))?}} ', s)\n[('bla', '123', '456'), ('bli', '789', '123'), ('blu', '789', '')]\n</code>\n</pre>\n", "senID": 0}, {"text": ["if you still want number there you'd need to iterate over the output and convert it to the integer with int."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n [re.split('\\|', i) for i in re.findall(\"{{(.*?)}}\", str)]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Returns:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n [['bla', '123', '456'], ['bli', '789', '123'], ['blu', '789']]\n</code>\n</pre>\n", "senID": 2}, {"text": ["This method works regardless of the number of elements in the {{ }} blocks."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["To get the exact output you wrote, you need a regex and a split:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nmap(lambda s: s.split(\"|\"), re.findall(r\"\\{\\{([^}]*)\\}\\}\", s))\n</code>\n</pre>\n", "senID": 1}, {"text": ["To get it with the numbers converted, do this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n toint = lambda x: int(x) if x.isdigit() else x\n[map(toint, p.split(\"|\")) for p in re.findall(r\"\\{\\{([^}]*)\\}\\}\", s)]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["We might be able to get fancy and do everything in a single complicated regular expression, but that way lies madness.", "Let's do one regexp that grabs the groups, and then split the groups up.", "We could use a regexp to split the groups, but we can just use str.split(), so let's do that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\npat_group = re.compile(\"{{([^}]*)}}\")\ndef mixed_tuple(iterable):\n    lst = []\n    for x in iterable:\n        try:\n            lst.append(int(x))\n        except ValueError:\n            lst.append(x)\n    return tuple(lst)\n\ns = \"a word {{bla|123|456}} another {{bli|789|123}} some more text {{blu|789}} and more\"\n\nlst_groups = re.findall(pat_group, s)\nlst = [mixed_tuple(x.split(\"|\")) for x in lst_groups]\n</code>\n</pre>\n", "senID": 1}, {"text": ["In pat_group, \"{{\" just matches literal \"{{\".", "\"(\" starts a group.", "\"[^}]\" is a character class that matches any character except for \"}\", and '*' allows it to match zero or more such characters.", "\")\" closes out the group and \"}}\" matches literal characters.", "Thus, we match the \"{{...}}\" patterns, and can extract everything between the curly braces as a group."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["re.findall() returns a list of groups matched from the pattern."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Finally, a list comprehension splits each string and returns the result as a tuple."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Assuming your actual format is {{[a-z]+|[0-9]+|[0-9]+}}, here's a complete program with conversion to ints."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "{{[a-z]+|[0-9]+|[0-9]+}}", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\ns = \"a word {{bla|123|456}} another {{bli|789|123}} some more text {{blu|789}} and more\"\nresult = []\n\nfor match in re.finditer('{{.*?}}', s):\n\n   # Split on pipe (|) and filter out non-alphanumerics\n   parts = [filter(str.isalnum, part) for part in match.group().split('|')]\n\n   # Convert to int when possible\n   for index, part in enumerate(parts):      \n      try:\n         parts[index] = int(part)\n      except ValueError:\n         pass\n\n   result.append(tuple(parts))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Is pyparsing overkill for this?", "Maybe, but without too much suffering, it does deliver the desired output, without a thicket of backslashes to escape the '{', '|', or '}'  characters.", "Plus, there's no need for post-parse conversions of integers and whatnot - the parse actions take care of this kind of stuff at parse time."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "does", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from pyparsing import Word, Suppress, alphas, alphanums, nums, delimitedList\n\nLBRACE,RBRACE,VERT = map(Suppress,\"{}|\")\nword = Word(alphas,alphanums)\ninteger = Word(nums)\ninteger.setParseAction(lambda t: int(t[0]))\n\npatt = (LBRACE*2 + delimitedList(word|integer, VERT) + RBRACE*2)\npatt.setParseAction(lambda toks:tuple(toks.asList()))\n\n\ns = \"a word {{bla|123|456}} another {{bli|789|123}} some more text {{blu|789}} and more\"\n\nprint tuple(p[0] for p in patt.searchString(s))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n (('bla', 123, 456), ('bli', 789, 123), ('blu', 789))\n</code>\n</pre>\n", "senID": 3}]]