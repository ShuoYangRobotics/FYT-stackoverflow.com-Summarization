[[{"text": ["It's possible that the data structure you are looking for is the multiset (or \"bag\"), and if so, a good way to implement it in Python is to use collections.Counter:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "multiset", "tag": "a", "pos": 0, "childList": [{"text": "multiset", "tag": "strong"}], "childNum": 1, "href": "http://en.wikipedia.org/wiki/Multiset"}, {"text": "multiset", "childNum": 0, "tag": "strong", "childList": []}, {"href": "http://docs.python.org/library/collections.html#collections.Counter", "text": "collections.Counter", "childNum": 1, "tag": "a", "childList": [{"text": "collections.Counter", "tag": "code"}]}, {"text": "collections.Counter", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; x = Counter([1, 2, 3, 4])\n&gt;&gt;&gt; y = Counter([1, 1, 2, 5, 6])\n&gt;&gt;&gt; x - y\nCounter({3: 1, 4: 1})\n&gt;&gt;&gt; y - x\nCounter({1: 1, 5: 1, 6: 1})\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want to convert the Counter objects back to lists with multiplicity, you can use the elements method:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "Counter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/collections.html#collections.Counter.elements", "text": "elements", "childNum": 1, "tag": "a", "childList": [{"text": "elements", "tag": "code"}]}, {"text": "elements", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list((x - y).elements())\n[3, 4]\n&gt;&gt;&gt; list((y - x).elements())\n[1, 5, 6]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["To build on Gareth's answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = Counter([1, 2, 3, 4])\n&gt;&gt;&gt; b = Counter([1, 1, 2, 5, 6])\n&gt;&gt;&gt; (a - b).elements()\n[3, 4]\n&gt;&gt;&gt; (b - a).elements()\n[1, 5, 6]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Benchmark code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from collections import Counter\nfrom collections import defaultdict\nimport random\n\n# short lists\n#a = [1, 2, 3, 4, 7, 8, 9]\n#b = [1, 1, 2, 5, 6, 8, 8, 10]\n\n# long lists\na = []\nb = []\n\nfor i in range(0, 1000):\n    q = random.choice((1, 2, 3, 4))\n    if q == 1:\n        a.append(i)\n    elif q == 2:\n        b.append(i)\n    elif q == 3:\n        a.append(i)\n        b.append(i)\n    else:\n        a.append(i)\n        b.append(i)\n        b.append(i)\n\n# Modifies the lists in-place! Naughty! And it doesn't actually work, to boot.\ndef original(xlist, ylist):\n    done = False\n\n    while not done:\n        done = True\n        for x in xlist:\n            for y in ylist:\n                if x == y:\n                    xlist.remove(x)\n                    ylist.remove(y)\n                    done = False\n    return xlist, ylist # not strictly necessary, see above\n\n\ndef counter(xlist, ylist):\n    x = Counter(xlist)\n    y = Counter(ylist)\n    return ((x-y).elements(), (y-x).elements())\n\n\ndef nasty(xlist, ylist):\n    x = sum(([i]*(xlist.count(i)-ylist.count(i)) for i in set(xlist)),[])\n    y = sum(([i]*(ylist.count(i)-xlist.count(i)) for i in set(ylist)),[])\n\n    return x, y\n\n\ndef gnibbler(xlist, ylist):\n    d = defaultdict(int)\n    for i in xlist: d[i] += 1\n    for i in ylist: d[i] -= 1\n    return [k for k,v in d.items() for i in range(v)], [k for k,v in d.items() for i in range(-v)]\n\n# substitute algorithm to test in the call\nfor x in range(0, 100000):\n    original(list(a), list(b))\n</code>\n</pre>\n", "senID": 3}, {"text": ["Running the Insufficiently Rigorous Benchmarks[tm] (short lists are the original ones, long lists are randomly generated lists approximately 1000 entries long with a mix of matches and repeats, times given in multipliers of the Original algorithm):"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n 100K iterations, short lists    1K iterations, long lists\nOriginal     1.0                           1.0\nCounter      9.3                           0.06\nNasty        2.9                           1.4\nGnibbler     2.4                           0.02\n</code>\n</pre>\n", "senID": 5}, {"text": ["Note 1: The creation of the Counter object seems to overshadow the actual algorithm at small list sizes."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Note 2: Original and gnibbler are the same at list lengths of approximately 35, above which gnibbler (and Counter) are faster."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["If you don't care about order, use collections.Counter to do it in one line:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "collections.Counter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; Counter(x)-Counter(y)\nCounter({3: 1, 4: 1})\n\n&gt;&gt;&gt; Counter(y)-Counter(x)\nCounter({1: 1, 5: 1, 6: 1})\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you care about order, you can probably iterate through your lists grabbing elements from the above dictionaries:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def prune(seq, toPrune):\n    \"\"\"Prunes elements from front of seq in O(N) time\"\"\"\n    remainder = Counter(seq)-Counter(toPrune)\n    R = []\n    for x in reversed(seq):\n        if remainder.get(x):\n            remainder[x] -= 1\n            R.insert(0,x)\n    return R\n</code>\n</pre>\n", "senID": 3}, {"text": ["Demo:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; prune(x,y)\n[3, 4]\n&gt;&gt;&gt; prune(y,x)\n[1, 1, 5, 6]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Just using collections.defaultdict so will work on Python2.5+"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "collections.defaultdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = [1, 2, 3, 4]\n&gt;&gt;&gt; y = [1, 1, 2, 5, 6]\n&gt;&gt;&gt; from collections import defaultdict\n&gt;&gt;&gt; d = defaultdict(int)\n&gt;&gt;&gt; for i in x:\n...  d[i] += 1\n... \n&gt;&gt;&gt; for i in y:\n...  d[i] -= 1\n... \n&gt;&gt;&gt; [k for k,v in d.items() for i in range(v)]\n[3, 4]\n&gt;&gt;&gt; [k for k,v in d.items() for i in range(-v)]\n[1, 5, 6]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I find this is better than range (or xrange) if the number repetitions get large"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import repeat\n&gt;&gt;&gt; [k for k,v in d.items() for i in repeat(None, v)]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Quite nasty :P"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = sum(([i]*(x.count(i)-y.count(i)) for i in set(x)),[])\nb = sum(([i]*(y.count(i)-x.count(i)) for i in set(y)),[])\n\nx,y = a,b\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is simple if you dont care about the duplicates:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x=[1,2,3,4]\n&gt;&gt;&gt; y=[1,1,2,5,6]\n&gt;&gt;&gt; list(set(x).difference(set(y)))\n[3, 4]\n&gt;&gt;&gt; list(set(y).difference(set(x)))\n[5, 6]\n</code>\n</pre>\n", "senID": 1}]]