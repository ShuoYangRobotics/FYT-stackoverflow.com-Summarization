[[{"code": "<pre>\n<code>\n bin(int(\"abc123efff\", 16))[2:]\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n import binascii\n\nbinary_string = binascii.unhexlify(hex_string)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Read"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["binascii.unhexlify"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "binascii.unhexlify", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/binascii.html#binascii.unhexlify"}]}, {"text": ["Return the binary data represented by the hexadecimal string specified as the parameter."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["For solving the left-side trailing zero problem:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n my_hexdata = \"1a\"\n\nscale = 16 ## equals to hexadecimal\n\nnum_of_bits = 8\n\nbin(int(my_hexdata, scale))[2:].zfill(num_of_bits)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It will give 00011010 instead of the trimmed version."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["hex --> decimal then decimal --> binary"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #decimal to binary \ndef d2b(n):\n    bStr = ''\n    if n &lt; 0: raise ValueError, \"must be a positive integer\"\n    if n == 0: return '0'\n    while n &gt; 0:\n        bStr = str(n % 2) + bStr\n        n = n &gt;&gt; 1    \n    return bStr\n\n#hex to binary\ndef h2b(hex):\n    return d2b(int(hex,16))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Replace each hex digit with the corresponding 4 binary digits:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n 1 - 0001\n2 - 0010\n...\na - 1010\nb - 1011\n...\nf - 1111\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's a fairly raw way to do it using bit fiddling to generate the binary strings."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The key bit to understand is:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n (n & (1 &lt;&lt; i)) and 1\n</code>\n</pre>\n", "senID": 2}, {"text": ["Which will generate either a 0 or 1 if the i'th bit of n is set."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import binascii\n\ndef byte_to_binary(n):\n    return ''.join(str((n & (1 &lt;&lt; i)) and 1) for i in reversed(range(8)))\n\ndef hex_to_binary(h):\n    return ''.join(byte_to_binary(ord(b)) for b in binascii.unhexlify(h))\n\nprint hex_to_binary('abc123efff')\n\n>>> 1010101111000001001000111110111111111111\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Another way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import math\n\ndef hextobinary(hex_string):\n    s = int(hex_string, 16) \n    num_digits = int(math.ceil(math.log(s) / math.log(2)))\n    digit_lst = ['0'] * num_digits\n    idx = num_digits\n    while s &gt; 0:\n    \tidx -= 1\n    \tif s % 2 == 1: digit_lst[idx] = '1'\n    \ts = s / 2\n    return ''.join(digit_lst)\n\nprint hextobinary('abc123efff')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["unhexlify"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "unhexlify", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/binascii.html#binascii.unhexlify"}]}], [{"code": "<pre>\n<code>\n bin(0xabc123eff)[2:]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This is a slight touch up to Glen Maynard's solution, which I think is the right way to do it.", "It just adds the padding element."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def hextobin(self, hexval):\n        '''\n        Takes a string representation of hex data with\n        arbitrary length and converts to string representation\n        of binary.  Includes padding 0s\n        '''\n        thelen = len(hexval)*4\n        binval = bin(int(hexval, 16))[2:]\n        while ((len(binval)) &lt; thelen):\n            binval = '0' + binval\n        return binval\n</code>\n</pre>\n", "senID": 1}, {"text": ["Pulled it out of a class.", "Just take out self, if you're working in a stand-alone script."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "self,", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]