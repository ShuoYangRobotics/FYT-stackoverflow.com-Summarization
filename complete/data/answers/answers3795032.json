[[{"code": "<pre>\n<code>\n # bmi = &lt;whatever&gt;\nfound_bmi_range = [bmi_range for bmi_range\n                   in bmi_ranges\n                   if bmi_ranges[2] &lt;= bmi &lt;= bmi_ranges[3]\n                  ][0]\n</code>\n</pre>\n", "senID": 0}, {"text": ["You can add if clauses to list comprehensions that filter what items are included in the result."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Note: you may want to adjust your range specifications to use a non-inclusive upper bound (i.e.", "[a,b) + [b,c) + [c,d) et cetera), and then change the conditional to a &lt;= b &lt; c, that way you don't have issues with edge cases."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "a &lt;= b &lt; c", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You can do this with a list comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; result = [r for r in bmi_ranges if r[2] &lt;= 32 &lt;= r[3]]\n&gt;&gt;&gt; print result\n[(u'Obese', u'Obese Class I', 30.0, 34.99)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["However it would probably be faster to request the database to do this for you as otherwise you are requesting more data than you need.", "I don't understand how using a BETWEEN requires using one more data connection.", "If you could expand on that it would be useful.", "Are you talking about the pros and cons of caching data versus always asking for live data?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You may also want to create a class for your data so that you don't have to refer to fields as x[2], but instead can use more meaningful names.", "You could also look at namedtuples."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I'm not sure if I understand why you can't do this just by iterating over the list (I know there are more efficient datastructures, but this is very short and iteration would be more understandable).", "What's wrong with"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def check_bmi(bmi, bmi_range):\n    for cls, name, a, b in bmi_range:\n        if a &lt;= bmi &lt;= b:\n            return cls # or name or whatever you need.\n</code>\n</pre>\n", "senID": 1}], [{"text": ["bmi = 26.2"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "bmi = 26.2", "childNum": 1, "tag": "pre", "pos": 0, "childList": [{"text": "bmi = 26.2", "tag": "code"}]}, {"text": "bmi = 26.2", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["bmi_ranges = []\nbmi_ranges.append((u'Underweight', u'Severe Thinness', 0, 15.99))\nbmi_ranges.append((u'Underweight', u'Moderate Thinness', 16.00, 16.99))\nbmi_ranges.append((u'Underweight', u'Mild Thinness', 17.00, 18.49))\nbmi_ranges.append((u'Normal Range', u'Normal Range', 18.50, 24.99))\nbmi_ranges.append((u'Overweight', u'Overweight', 25.00, 29.99))\nbmi_ranges.append((u'Obese', u'Obese Class I', 30.00, 34.99))\nbmi_ranges.append((u'Obese', u'Obese Class II', 35.00, 39.99))\nbmi_ranges.append((u'Obese', u'Obese Class III', 40.00, 1000.00))"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["print filter(lambda x: x[2] &lt;= bmi &lt;= x[3], bmi_ranges)\n"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The builtin filter function exists for this purpose:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n bmi = 26.2\nanswer = filter(lambda T, : T[2]&lt;=bmi&lt;=T[3], bmi_ranges)[0]\nprint answer\n&gt;&gt;&gt; (u'Overweight', u'Overweight', 25.0, 29.989999999999998)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Hope this helps"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This is how I would deal with it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random\n\nbmi_ranges = [(u'Underweight', u'Severe Thinness', 16.0),\n               (u'Underweight', u'Moderate Thinness', 17.0),\n               (u'Underweight', u'Mild Thinness', 18.5),\n               (u'Normal Range', u'Normal Range', 25.0),\n               (u'Overweight', u'Overweight', 30.0),\n               (u'Obese', u'Obese Class I', 35.0),\n               (u'Obese', u'Obese Class II', 40.0),\n               (u'Obese', u'Obese Class III', 1000.0)]\n\ndef bmi_lookup(bmi_value):\n    return next((classification, description, lessthan)\n         for classification, description, lessthan in bmi_ranges\n         if bmi_value &lt; lessthan)\n\nfor bmi in range(20):\n    random_bmi = random.random()*50\n    print random_bmi, bmi_lookup(random_bmi)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you like a lighter original data structure and one import from standard library:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import bisect\n\nbmi_ranges = []\nbmi_ranges.append((u'Underweight', u'Severe Thinness', 0, 15.99))\nbmi_ranges.append((u'Underweight', u'Moderate Thinness', 16.00, 16.99))\nbmi_ranges.append((u'Underweight', u'Mild Thinness', 17.00, 18.49))\nbmi_ranges.append((u'Normal Range', u'Normal Range', 18.50, 24.99))\nbmi_ranges.append((u'Overweight', u'Overweight', 25.00, 29.99))\nbmi_ranges.append((u'Obese', u'Obese Class I', 30.00, 34.99))\nbmi_ranges.append((u'Obese', u'Obese Class II', 35.00, 39.99))\nbmi_ranges.append((u'Obese', u'Obese Class III', 40.00, 1000.00))\n\n# we take just the minimal value for BMI for each class\n# find the limit values between ranges:\n\nlimitValues = [line[2] for line in bmi_range][1:]\n# limitValues = [16.0, 17.0, 18.5, 25.0, 30.0, 35.0, 40.0]\n\n# bisect.bisect(list, value) returns the range\n#in the list, in which value belongs\nbmi_range = bmi_ranges[bisect.bisect(limitValues, bmi)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["More information: bisect"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "bisect", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/bisect.html"}]}]]