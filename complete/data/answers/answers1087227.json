[[{"text": ["You can use Twisted to verify certificates.", "The main API is CertificateOptions, which can be provided as the contextFactory argument to various functions such as listenSSL and startTLS."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "CertificateOptions", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://twistedmatrix.com/documents/8.2.0/api/twisted.internet.ssl.CertificateOptions.html"}, {"text": "contextFactory", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://twistedmatrix.com/documents/8.2.0/api/twisted.internet.interfaces.IReactorSSL.listenSSL.html", "text": "listenSSL", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://twistedmatrix.com/documents/8.2.0/api/twisted.internet.interfaces.ITLSTransport.html#startTLS", "text": "startTLS", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Unfortunately, neither Python nor Twisted comes with a the pile of CA certificates required to actually do HTTPS validation, nor the HTTPS validation logic.", "Due to a limitation in PyOpenSSL, you can't do it completely correctly just yet, but thanks to the fact that almost all certificates include a subject commonName, you can get close enough."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "a limitation in PyOpenSSL", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "https://bugs.launchpad.net/pyopenssl/+bug/324857"}]}, {"text": ["Here is a naive sample implementation of a verifying Twisted HTTPS client which ignores wildcards and subjectAltName extensions, and uses the certificate-authority certificates present in the 'ca-certificates' package in most Ubuntu distributions.", "Try it with your favorite valid and invalid certificate sites :)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import os\nimport glob\nfrom OpenSSL.SSL import Context, TLSv1_METHOD, VERIFY_PEER, VERIFY_FAIL_IF_NO_PEER_CERT, OP_NO_SSLv2\nfrom OpenSSL.crypto import load_certificate, FILETYPE_PEM\nfrom twisted.python.urlpath import URLPath\nfrom twisted.internet.ssl import ContextFactory\nfrom twisted.internet import reactor\nfrom twisted.web.client import getPage\ncertificateAuthorityMap = {}\nfor certFileName in glob.glob(\"/etc/ssl/certs/*.pem\"):\n    # There might be some dead symlinks in there, so let's make sure it's real.\n    if os.path.exists(certFileName):\n        data = open(certFileName).read()\n        x509 = load_certificate(FILETYPE_PEM, data)\n        digest = x509.digest('sha1')\n        # Now, de-duplicate in case the same cert has multiple names.\n        certificateAuthorityMap[digest] = x509\nclass HTTPSVerifyingContextFactory(ContextFactory):\n    def __init__(self, hostname):\n        self.hostname = hostname\n    isClient = True\n    def getContext(self):\n        ctx = Context(TLSv1_METHOD)\n        store = ctx.get_cert_store()\n        for value in certificateAuthorityMap.values():\n            store.add_cert(value)\n        ctx.set_verify(VERIFY_PEER | VERIFY_FAIL_IF_NO_PEER_CERT, self.verifyHostname)\n        ctx.set_options(OP_NO_SSLv2)\n        return ctx\n    def verifyHostname(self, connection, x509, errno, depth, preverifyOK):\n        if preverifyOK:\n            if self.hostname != x509.get_subject().commonName:\n                return False\n        return preverifyOK\ndef secureGet(url):\n    return getPage(url, HTTPSVerifyingContextFactory(URLPath.fromString(url).netloc))\ndef done(result):\n    print 'Done!', len(result)\nsecureGet(\"https://google.com/\").addCallback(done)\nreactor.run()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["M2Crypto can do the validation.", "You can also use M2Crypto with Twisted if you like.", "The Chandler desktop client uses Twisted for networking and M2Crypto for SSL, including certificate validation."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "M2Crypto", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://chandlerproject.org/Projects/MeTooCrypto"}, {"text": "do the validation", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.heikkitoivonen.net/blog/2008/10/14/ssl-in-python-26/"}, {"text": "M2Crypto with Twisted", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://svn.osafoundation.org/m2crypto/trunk/M2Crypto/SSL/TwistedProtocolWrapper.py"}, {"text": "Chandler", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://chandlerproject.org/"}, {"href": "http://svn.osafoundation.org/chandler/trunk/chandler/parcels/osaf/framework/certstore/ssl.py", "text": "uses Twisted for networking and M2Crypto for SSL", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Based on Glyphs comment it seems like M2Crypto does better certificate verification by default than what you can do with pyOpenSSL currently, because M2Crypto checks subjectAltName field too."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I've also blogged on how to get the certificates Mozilla Firefox ships with in Python and usable with Python SSL solutions."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "get the certificates", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.heikkitoivonen.net/blog/2008/09/30/root-certificates-for-python-programs-using-python/"}]}], [{"text": ["I have added a distribution to the Python Package Index which makes the match_hostname() function from the Python 3.2 ssl package available on previous versions of Python."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "match_hostname()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ssl", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["http://pypi.python.org/pypi/backports.ssl_match_hostname/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://pypi.python.org/pypi/backports.ssl_match_hostname/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/backports.ssl_match_hostname/"}]}, {"text": ["You can install it with:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n pip install backports.ssl_match_hostname\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or you can make it a dependency listed in your project's setup.py.", "Either way, it can be used like this:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "setup.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from backports.ssl_match_hostname import match_hostname, CertificateError\n...\nsslsock = ssl.wrap_socket(sock, ssl_version=ssl.PROTOCOL_SSLv3,\n                      cert_reqs=ssl.CERT_REQUIRED, ca_certs=...)\ntry:\n    match_hostname(sslsock.getpeercert(), hostname)\nexcept CertificateError, ce:\n    ...\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Here's an example script which demonstrates certificate validation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import httplib\nimport re\nimport socket\nimport sys\nimport urllib2\nimport ssl\n\nclass InvalidCertificateException(httplib.HTTPException, urllib2.URLError):\n    def __init__(self, host, cert, reason):\n        httplib.HTTPException.__init__(self)\n        self.host = host\n        self.cert = cert\n        self.reason = reason\n\n    def __str__(self):\n        return ('Host %s returned an invalid certificate (%s) %s\\n' %\n                (self.host, self.reason, self.cert))\n\nclass CertValidatingHTTPSConnection(httplib.HTTPConnection):\n    default_port = httplib.HTTPS_PORT\n\n    def __init__(self, host, port=None, key_file=None, cert_file=None,\n                             ca_certs=None, strict=None, **kwargs):\n        httplib.HTTPConnection.__init__(self, host, port, strict, **kwargs)\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.ca_certs = ca_certs\n        if self.ca_certs:\n            self.cert_reqs = ssl.CERT_REQUIRED\n        else:\n            self.cert_reqs = ssl.CERT_NONE\n\n    def _GetValidHostsForCert(self, cert):\n        if 'subjectAltName' in cert:\n            return [x[1] for x in cert['subjectAltName']\n                         if x[0].lower() == 'dns']\n        else:\n            return [x[0][1] for x in cert['subject']\n                            if x[0][0].lower() == 'commonname']\n\n    def _ValidateCertificateHostname(self, cert, hostname):\n        hosts = self._GetValidHostsForCert(cert)\n        for host in hosts:\n            host_re = host.replace('.', '\\.').replace('*', '[^.]*')\n            if re.search('^%s$' % (host_re,), hostname, re.I):\n                return True\n        return False\n\n    def connect(self):\n        sock = socket.create_connection((self.host, self.port))\n        self.sock = ssl.wrap_socket(sock, keyfile=self.key_file,\n                                          certfile=self.cert_file,\n                                          cert_reqs=self.cert_reqs,\n                                          ca_certs=self.ca_certs)\n        if self.cert_reqs &amp; ssl.CERT_REQUIRED:\n            cert = self.sock.getpeercert()\n            hostname = self.host.split(':', 0)[0]\n            if not self._ValidateCertificateHostname(cert, hostname):\n                raise InvalidCertificateException(hostname, cert,\n                                                  'hostname mismatch')\n\n\nclass VerifiedHTTPSHandler(urllib2.HTTPSHandler):\n    def __init__(self, **kwargs):\n        urllib2.AbstractHTTPHandler.__init__(self)\n        self._connection_args = kwargs\n\n    def https_open(self, req):\n        def http_class_wrapper(host, **kwargs):\n            full_kwargs = dict(self._connection_args)\n            full_kwargs.update(kwargs)\n            return CertValidatingHTTPSConnection(host, **full_kwargs)\n\n        try:\n            return self.do_open(http_class_wrapper, req)\n        except urllib2.URLError, e:\n            if type(e.reason) == ssl.SSLError and e.reason.args[0] == 1:\n                raise InvalidCertificateException(req.host, '',\n                                                  e.reason.args[1])\n            raise\n\n    https_request = urllib2.HTTPSHandler.do_request_\n\nif __name__ == \"__main__\":\n    if len(sys.argv) != 3:\n        print \"usage: python %s CA_CERT URL\" % sys.argv[0]\n        exit(2)\n\n    handler = VerifiedHTTPSHandler(ca_certs = sys.argv[1])\n    opener = urllib2.build_opener(handler)\n    print opener.open(sys.argv[2]).read()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["PycURL does this beautifully."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PycURL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pycurl.sourceforge.net/"}]}, {"text": ["Here's a short example.", "It will throw a pycurl.error if something is fishy, where you get a tuple with errorcode and a human readable message."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import pycurl\n\ncurl = pycurl.Curl()\ncurl.setopt(pycurl.CAINFO, \"myFineCA.crt\")\ncurl.setopt(pycurl.SSL_VERIFYPEER, 1)\ncurl.setopt(pycurl.SSL_VERIFYHOST, 2)\ncurl.setopt(pycurl.URL, \"https://internal.stuff/\")\n\ncurl.perform()\n</code>\n</pre>\n", "senID": 2}, {"text": ["You will probably want to configure more options, like where to store the results etc.", "But no need to clutter the example with non-essentials."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Example of what exceptions might be raised:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n (60, 'Peer certificate cannot be authenticated with known CA certificates')\n(51, \"common name 'CN=something.else.stuff,O=Example Corp,C=SE' does not match 'internal.stuff'\")\n</code>\n</pre>\n", "senID": 5}, {"text": ["Some links that I found useful are the libcurl-docs for setopt and getinfo."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["http://curl.haxx.se/libcurl/c/curl_easy_setopt.html"], "childNum": 0, "tag": "a", "senID": 7, "childList": []}, {"text": ["http://curl.haxx.se/libcurl/c/curl_easy_getinfo.html"], "childNum": 0, "tag": "a", "senID": 8, "childList": []}]}], [{"text": ["Jython DOES carry out certificate verification by default, so using standard library modules, e.g.", "httplib.HTTPSConnection, etc, with jython will verify certificates and give exceptions for failures, i.e.", "mismatched identities, expired certs, etc."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In fact, you have to do some extra work to get jython to behave like cpython, i.e.", "to get jython to NOT verify certs. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I have written a blog post on how to disable certificate checking on jython, because it can be useful in testing phases, etc."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Installing an all-trusting security provider on java and jython.", "http://jython.xhaus.com/installing-an-all-trusting-security-provider-on-java-and-jython/"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "http://jython.xhaus.com/installing-an-all-trusting-security-provider-on-java-and-jython/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://jython.xhaus.com/installing-an-all-trusting-security-provider-on-java-and-jython/"}]}], [{"text": ["pyOpenSSL is an interface to the OpenSSL library.", "It should provide everything you need."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pyOpenSSL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://launchpad.net/pyopenssl"}]}]]