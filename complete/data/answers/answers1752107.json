[[{"text": ["You can combine iteration through iter() with a sentinel:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "iter()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#iter"}]}, {"code": "<pre>\n<code>\n for block in iter(lambda: file_obj.read(4), \"\"):\n  use(block)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Have you seen how to iterate over lines in a text file?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for line in file_obj:\n  use(line)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can do the same thing with your own generator:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def read_blocks(file_obj, size):\n  while True:\n    data = file_obj.read(size)\n    if not data:\n      break\n    yield data\n\nfor block in read_blocks(file_obj, 4):\n  use(block)\n</code>\n</pre>\n", "senID": 3}, {"text": ["See also:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": ["file.read"], "childNum": 0, "tag": "a", "senID": 5, "childList": []}]}], [{"text": ["I see, as predicted, that the typical and most popular answer are using very specialized generators to \"read 4 bytes at a time\".", "Sometimes generality isn't any harder (and much more rewarding;-), so, I've suggested instead the following very general solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\ndef funlooper(afun, *a, **k):\n  wearedone = k.pop('wearedone', operator.not_)\n  while True:\n    data = afun(*a, **k)\n    if wearedone(data): break\n    yield data\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now your desired loop header is just: for len_name in funlooper(data.read, 4):."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "for len_name in funlooper(data.read, 4):", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit: made much more general by the wearedone idiom since a comment accused my slightly less general previous version (hardcoding the exit test as if not data:) of having \"a hidden dependency\", of all things!-)"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "wearedone", "childNum": 0, "tag": "code", "childList": []}, {"text": "if not data:", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The usual swiss army knife of looping, itertools, is fine too, of course, as usual:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "itertools", "tag": "a", "pos": 0, "childList": [{"text": "itertools", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.htm"}, {"text": "itertools", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import itertools as it\n\nfor len_name in it.takewhile(bool, it.imap(data.read, it.repeat(4))): ...\n</code>\n</pre>\n", "senID": 5}, {"text": ["or, quite equivalently:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import itertools as it\n\ndef loop(pred, fun, *args):\n  return it.takewhile(pred, it.starmap(fun, it.repeat(args)))\n\nfor len_name in loop(bool, data.read, 4): ...\n</code>\n</pre>\n", "senID": 7}], [{"text": ["I prefer the already mentioned iterator-based solution to turn this into a for-loop.", "Another solution written directly is Knuth's \"loop-and-a-half\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while 1:\n    len_name = data.read(4)\n    if not len_name:\n        break\n    names.append(data.read(len_name))\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can see by comparison how that's easily hoisted into its own generator and used as a for-loop."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The EOF marker in python is an empty string so what you have is pretty close to the best you are going to get without writing a function to wrap this up in an iterator.", "I could be written in a little more pythonic way by changing the while like:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "while", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n while len_name:\n    len_name = struct.unpack(\"&lt;I\", len_name)[0]\n    names.append(data.read(len_name))\n    len_name = data.read(4)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'd go with Tendayi's suggestion re function and iterator for readability:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def read4():\n    len_name = data.read(4)\n    if len_name:\n        len_name = struct.unpack(\"&lt;I\", len_name)[0]\n        return data.read(len_name)\n    else:\n        raise StopIteration\n\nfor d in iter(read4, ''):\n    names.append(d)\n</code>\n</pre>\n", "senID": 1}]]