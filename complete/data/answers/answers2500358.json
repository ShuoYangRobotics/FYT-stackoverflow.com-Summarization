[[{"text": ["Performing line-based changes to text files is often simplest to do in sed."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sed", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n sed -e '2s/  */ /g' infile.txt\n</code>\n</pre>\n", "senID": 1}, {"text": ["will replace any runs of multiple spaces with a single space.", "This may be changing more than you want, though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n sed -e '2s/^\\([^ ]*\\)  /\\1 /' infile.txt\n</code>\n</pre>\n", "senID": 3}, {"text": ["should just replace instances of two spaces after the first block of space-free text with a single space (though I have not tested this)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["(edit: inserted 2 before s in each instance to tie the edit to the second line, specifically."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "edit:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "2", "childNum": 0, "tag": "code", "childList": []}, {"text": "s", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Use sed."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for file in *\ndo\n  sed -i '' '2s/  / /' \"$file\"\ndone\n</code>\n</pre>\n", "senID": 1}, {"text": ["The -i '' flag means to edit in-place without a backup."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "-i ''", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Or use ed!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for file in *\ndo\n  printf \"2s/  / /\\nwq\\n\" |ed -s \"$file\"\ndone\n</code>\n</pre>\n", "senID": 4}], [{"text": ["if the error always can occur at 2nd line, "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for file in file*\ndo\n    awk 'NR==2{$1=$1}1' file &gt;temp\n    mv temp \"$file\"    \ndone\n</code>\n</pre>\n", "senID": 1}, {"text": ["or sed"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n sed -i.bak '2s/  */ /' file* # do 2nd line\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or just pure bash scripting"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n i=1\nwhile read -r line\ndo\n  if [ \"$i\" -eq 2 ];then\n    echo $line\n  else\n    echo \"$line\"\n  fi\n  ((i++))\ndone &lt;\"file\"\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I am going to be different and go with AWK:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n awk '{print $1,$2,$3}' file.txt &gt; file1.txt\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will handle any number of spaces between fields, and replace them with one space"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["To handle a specific line you can add line addresses:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n awk 'NR==2{print $1,$2,$3} NR!=2{print $0}' file.txt &gt; file1.txt\n</code>\n</pre>\n", "senID": 4}, {"text": ["i.e.", "rewrite line 2, but leave unchanged the other lines."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["A line address can be a regular expression as well:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n awk '/regexp/{print $1,$2,$3} !/regexp/{print}' file.txt &gt; file1.txt\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Since it seems every column is separated by one space, another approach not yet mentioned is to use tr to squeeze all multi spaces into single spaces:\n\ntr -s \" \" &lt; infile > outfile"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}], [{"text": ["I don't quite understand, but yes, sed is an option.", "I don't think any POSIX compliant version of sed has an in file option (-i), so a fully POSIX compliant solution would be."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sed", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sed", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n sed -e 's/^BBB  /BBB /' &lt;file&gt; &gt; &lt;newfile&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This answer assumes you don't want to mess with any except the second line."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nimport sys, os\nfor fname in sys.argv[1:]:\n    with open(fname, \"r\") as fin:\n        line1 = fin.readline()\n        line2 = fin.readline()\n        fixedLine2 = \" \".join(line2.split()) + '\\n'\n        if fixedLine2 == line2:\n            continue\n        with open(fname + \".fixed\", \"w\") as fout:\n            fout.write(line1)\n            fout.write(line2)\n            for line in fin:\n                fout.write(line)\n    # Enable these lines if you want the old files replaced with the new ones.\n    #os.remove(fname)\n    #os.rename(fname + \".fixed\", fname)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Use sed:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sed -e 's/[[:space:]][[:space:]]/ /g' yourfile.txt &gt;&gt; newfile.txt\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will replace any two adjacent spaces with one.", "The use of [[:space:]] just makes it a little bit clearer"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n sed -i -e '2s/  / /g' input.txt\n</code>\n</pre>\n", "senID": 0}, {"text": ["-i: edit files in place"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]