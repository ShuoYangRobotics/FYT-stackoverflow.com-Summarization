[[{"text": ["There are locals,globals, and then builtins.", "Perhaps you are looking for the builtin:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import __builtin__\ngetattr(__builtin__,'int')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You've already gotten a solution using builtins, but another worthwhile technique to hold in your toolbag is a dispatch table.", "If your CSV is designed to be used by multiple applications written in multiple languages, it might look like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Integer,15\nString,34\nFloat,1.0\nInteger,8\n</code>\n</pre>\n", "senID": 1}, {"text": ["In such a case you might want something like this, where csv is a list of tuples containing the data above:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "csv", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n mapping = {\n    'Integer': int,\n    'String': str,\n    'Float': float,\n    'Unicode': unicode\n}\nresults = []\nfor row in csv:\n    datatype = row[0]\n    val_string = row[1]\n    results.append(mapping[datatype](val_string))\nreturn results\n</code>\n</pre>\n", "senID": 3}, {"text": ["That gives you the flexibility of allowing arbitrary strings to map to useful types.", "You don't have to massage your data to give you the exact values python expects."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The issue here is that int is part of the __builtins__ module, not just part of the global namespace.", "You can get a built-in type, such as int, using the following bit of code:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__builtins__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n int_gen = getattr(globals()[\"__builtins__\"], \"int\")\ni = int_gen(4)\n# &gt;&gt;&gt; i = 4\n</code>\n</pre>\n", "senID": 1}, {"text": ["Similarly, you can access any other (imported) module by passing the module's name as a string index to globals(), and then using getattr to extract the desired attributes."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "globals()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "getattr", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n getattr(__builtins__,'int')\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Comments suggest that you are unhappy with the idea of using eval to generate data.", "looking for a function in __builtins__ allows you to find eval.  "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__builtins__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "eval", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["the most basic solution given looks like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import __builtin__\n\ndef parseInput(typename, value):\n    return getattr(__builtins__,typename)(value)\n</code>\n</pre>\n", "senID": 2}, {"text": ["You would use it like so:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; parseInput(\"int\", \"123\")\n123\n</code>\n</pre>\n", "senID": 4}, {"text": ["cool.", "works pretty ok.  how about this one though?"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; parseInput(\"eval\", 'eval(compile(\"print \\'Code injection?\\'\",\"\",\"single\"))')\nCode injection?\n</code>\n</pre>\n", "senID": 6}, {"text": ["does this do what you expect?", "Unless you explicitly want this, you need to do something to prevent untrustworthy inputs from poking about in your namespace.", "I'd strongly recommend a simple whitelist, gracefully raising some sort of exception in the case of invalid input, like so:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import __builtin__\n\ndef parseInput(typename, value):\n    return {\"int\":int, \"float\":float, \"str\":str}[typename](value)\n</code>\n</pre>\n", "senID": 8}, {"text": ["but if you just can't bear that, you can still add just a bit of armor by verifying that the requested function is actually a type:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n import __builtin__\n\ndef parseInput(typename, value):\n    typector = getattr(__builtins__,typename)\n    if type(typector) is type:\n        return typector(value)\n    else:\n        return None\n</code>\n</pre>\n", "senID": 10}], [{"text": ["If you have a string that is the name of a thing, and you want the thing, you can also use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n thing = 'int'\neval(thing)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Keep in mind though, that this is very powerful, and you need to understand what thing might contain, and where it came from.", "For example, if you accept user input as thing, a malicious user could do unlimited damage to your machine with this code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]