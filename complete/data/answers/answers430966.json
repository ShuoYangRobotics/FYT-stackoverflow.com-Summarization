[[{"text": ["Regexes with HTML get messy.", "Just use a DOM parser like Beautiful Soup."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["As others have suggested, if real-time-like performance isn't necessary, BeautifulSoup is  a good solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import urllib2\nfrom BeautifulSoup import BeautifulSoup\n\nhtml = urllib2.urlopen(\"http://www.google.com\").read()\nsoup = BeautifulSoup(html)\nall_links = soup.findAll(\"a\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["As for the second question, yes, HTML links ought to be well-defined, but the HTML you actually encounter is very unlikely to be standard.", "The beauty of BeautifulSoup is that it uses browser-like heuristics to try to parse the non-standard, malformed HTML that you are likely to actually come across. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you are certain to be working on standard XHTML, you can use (much) faster XML parsers like expat."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Regex, for the reasons above (the parser must maintain state, and regex can't do that) will never be a general solution."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["No there isn't."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can consider using Beautiful Soup.", "You can call it the standard for parsing html files."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Beautiful Soup", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/"}]}], [{"text": ["No, [X]HTML is not in the general case parseable with regex.", "Consider examples like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &lt;link title='hello\"&gt;world' href=\"x\"&gt;link&lt;/link&gt;\n&lt;!-- &lt;link href=\"x\"&gt;not a link&lt;/link&gt; --&gt;\n&lt;![CDATA[ &gt;&lt;link href=\"x\"&gt;not a link&lt;/link&gt; ]]&gt;\n&lt;script&gt;document.write('&lt;link href=\"x\"&gt;not a link&lt;/link&gt;')&lt;/script&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["and that's just a few random valid examples; if you have to cope with real-world tag-soup HTML there are a million malformed possibilities."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you know and can rely on the exact output format of the target page you can get away with regex.", "Otherwise it is completely the wrong choice for scraping web pages."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I second PEZ's answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As far as I know, any HTML tag may contain any number of nested tags.", "For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &lt;a href=\"http://stackoverflow.com\"&gt;stackoverflow&lt;/a&gt;\n&lt;a href=\"http://stackoverflow.com\"&gt;&lt;i&gt;stackoverflow&lt;/i&gt;&lt;/a&gt;\n&lt;a href=\"http://stackoverflow.com\"&gt;&lt;b&gt;&lt;i&gt;stackoverflow&lt;/i&gt;&lt;/b&gt;&lt;/a&gt;\n...\n</code>\n</pre>\n", "senID": 2}, {"text": ["Thus, in principle, to match a tag properly you must be able at least to match strings of the form:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n BE\nBBEE\nBBBEEE\n...\nBBBBBBBBBBEEEEEEEEEE\n...\n</code>\n</pre>\n", "senID": 4}, {"text": ["where B means the beginning of a tag and E means the end.", "That is, you must be able to match strings formed by any number of B's followed by the same number of E's.", "To do that, your matcher must be able to \"count\", and regular expressions (i.e.", "finite state automata) simply cannot do that (in order to count, an automaton needs at least a stack).", "Referring to PEZ's answer, HTML is a context-free grammar, not a regular language."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "same", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["this has much better general solutions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://stackoverflow.com/questions/773340/can-you-provide-an-example-of-parsing-html-with-your-favorite-parser/773344#773344"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://stackoverflow.com/questions/773340/can-you-provide-an-example-of-parsing-html-with-your-favorite-parser/773344#773344", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/773340/can-you-provide-an-example-of-parsing-html-with-your-favorite-parser/773344#773344"}]}], [{"text": ["Answering your two subquestions there."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["It depends a bit on how the HTML is produced.", "If it's somewhat controlled you can get away with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n re.findall(r'''&lt;link\\s+.*?href=['\"](.*?)['\"].*?(?:&lt;/link|/)&gt;''', html, re.I)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In response to question #2 (shouldn't a link be a well defined regular expression) the answer is ... no.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["An HTML link structure is a recursive much like parens and braces in programming languages.", "There must be an equal number of start and end constructs and the \"link\" expression can be nested within itself.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["To properly match a \"link\" expression a regex would be required to count the start and end tags.", "Regular expressions are a class of Finite Automata.", "By definition a Finite Automata cannot \"count\" constructs within a pattern.", "A grammar is required to describe a recursive data structure such as this.", "The inability for a regex to \"count\" is why you see programming languages described with Grammars as opposed to regular expressions."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["So it is not possible to create a regex that will positively match 100% of all \"link\" expressions.", "There are certainly regex's that will match a good deal of \"link\"'s with a high degree of accuracy but they won't ever be perfect. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I wrote a blog article about this problem recently.", "Regular Expression Limitations"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Regular Expression Limitations", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://blogs.msdn.com/jaredpar/archive/2008/10/15/regular-expression-limitations.aspx"}]}]]