[[{"text": ["Python strings' strip method removes both trailing and leading whitespace.", "The two halves of the problem are very different when working on a C \"string\" (array of char, \\0 terminated)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "strip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For trailing whitespace: set a pointer (or equivalently index) to the existing trailing \\0.", "Keep decrementing the pointer until it hits against the start-of-string, or any non-white character; set the \\0 to right after this terminate-backwards-scan point."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For leading whitespace: set a pointer (or equivalently index) to the start of string; keep incrementing the pointer until it hits a non-white character (possibly the trailing \\0); memmove the rest-of-string so that the first non-white goes to the start of string (and similarly for everything following)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["There is no standard C implementation for a strip() or trim() function.", "That said, here's the one included in the Linux kernel:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n char *strstrip(char *s)\n{\n        size_t size;\n        char *end;\n\n        size = strlen(s);\n\n        if (!size)\n                return s;\n\n        end = s + size - 1;\n        while (end &gt;= s &amp;&amp; isspace(*end))\n                end--;\n        *(end + 1) = '\\0';\n\n        while (*s &amp;&amp; isspace(*s))\n                s++;\n\n        return s;\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Seems like you want something like trim, a quick search on google leads to this forum thread."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.unix.com/high-level-programming/21264-how-trim-white-space-around-string-c-program.html"}]}], [{"text": ["If you want to remove, in place, the final newline on a line, you can use this snippet:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "in place", "childNum": 0, "tag": "b", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n size_t s = strlen(buf);\nif (s &amp;&amp; (buf[s-1] == '\\n')) buf[--s] = 0;\n</code>\n</pre>\n", "senID": 1}, {"text": ["To faithfully mimic Python's str.strip([chars]) method (the way I interpreted its workings), you need to allocate space for a new string, fill the new string and return it.", "After that, when you no longer need the stripped string you need to free the memory it used to have no memory leaks."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "str.strip([chars])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Or you can use C pointers and modify the initial string and achieve a similar result.", "Suppose your initial string is \"____forty two____\\n\" and you want to strip all underscores and the '\\n'"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "\"____forty two____\\n\"", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n ____forty two___\\n\n^ ptr\n</code>\n</pre>\n", "senID": 4}, {"text": ["If you change ptr to the 'f' and replace the first '_' after two with a '\\0' the result is the same as Python's \"____forty two____\\n\".strip(\"_\\n\");"], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "ptr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "two", "childNum": 0, "tag": "code", "childList": []}, {"text": "'\\0'", "childNum": 0, "tag": "code", "childList": []}, {"text": "\"____forty two____\\n\".strip(\"_\\n\");", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n ____forty two\\0___\\n\n    ^ptr\n</code>\n</pre>\n", "senID": 6}, {"text": ["Again, this is not the same as Python.", "The string is modified in place, there's no 2nd string and you cannot revert the changes (the original string is lost)."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I wrote C code to implement this function.", "I also wrote a few trivial tests to make sure my function does sensible things."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This function writes to a buffer you provide, and should never write past the end of the buffer, so it should not be prone to buffer overflow security issues."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Note: only Test() uses stdio.h, so if you just need the function, you only need to include ctype.h (for isspace()) and string.h (for strlen())."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n // strstrip.c -- implement white space stripping for a string in C\n//\n// This code is released into the public domain.\n//\n// You may use it for any purpose whatsoever, and you don't need to advertise\n// where you got it, but you aren't allowed to sue me for giving you free\n// code; all the risk of using this is yours.\n\n\n\n#include &lt;ctype.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n\n\n// strstrip() -- strip leading and trailing white space from a string\n//\n// Copies from sIn to sOut, writing at most lenOut characters.\n//\n// Returns number of characters in returned string, or -1 on an error.\n// If you get -1 back, then nothing was written to sOut at all.\n\nint\nstrstrip(char *sOut, unsigned int lenOut, char const *sIn)\n{\n    char const *pStart, *pEnd;\n    unsigned int len;\n    char *pOut;\n\n    // if there is no room for any output, or a null pointer, return error!\n    if (0 == lenOut || !sIn || !sOut)\n        return -1;\n\n    pStart = sIn;\n    pEnd = sIn + strlen(sIn) - 1;\n\n    // skip any leading whitespace\n    while (*pStart &amp;&amp; isspace(*pStart))\n        ++pStart;\n\n    // skip any trailing whitespace\n    while (pEnd &gt;= sIn &amp;&amp; isspace(*pEnd))\n        --pEnd;\n\n    pOut = sOut;\n    len = 0;\n\n    // copy into output buffer\n    while (pStart &lt;= pEnd &amp;&amp; len &lt; lenOut - 1)\n    {\n        *pOut++ = *pStart++;\n        ++len;\n    }\n\n\n    // ensure output buffer is properly terminated\n    *pOut = '\\0';\n    return len;\n}\n\n\nvoid\nTest(const char *s)\n{\n    int len;\n    char buf[1024];\n\n    len = strstrip(buf, sizeof(buf), s);\n\n    if (!s)\n        s = \"**null**\";  // don't ask printf to print a null string\n    if (-1 == len)\n        *buf = '\\0';  // don't ask printf to print garbage from buf\n\n    printf(\"Input: \\\"%s\\\"  Result: \\\"%s\\\" (%d chars)\\n\", s, buf, len);\n}\n\n\nmain()\n{\n    Test(NULL);\n    Test(\"\");\n    Test(\" \");\n    Test(\"    \");\n    Test(\"x\");\n    Test(\"  x\");\n    Test(\"  x   \");\n    Test(\"  x y z   \");\n    Test(\"x y z\");\n}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I asked a very similar question long ago.", "See here; there are ways to do it both in-place and with a new copy."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/122616/painless-way-to-trim-leading-trailing-whitespace-in-c"}]}]]