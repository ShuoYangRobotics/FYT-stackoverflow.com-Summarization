[[{"text": ["Could it be that your expression triggers exponential behavior in the Python RE engine?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This article deals with the problem.", "If you have the time, you might want to try running your expression in an RE engine developed using those ideas."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "This article", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://swtch.com/~rsc/regexp/regexp1.html"}]}], [{"text": ["Definitely exponential behaviour.", "You've got so many d* parts to your regexp that it'll be backtracking like crazy when it gets to the long string of d's, but fails to match something earlier.", "You need to rethink the regexp, so it has less possible paths to try."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "d*", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In particular I think:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["([ef]d*b|d*)* and ([ef]|([gh]d*(ad*[gh]d)*b))d*b"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "([ef]d*b|d*)*", "childNum": 0, "tag": "pre", "childList": []}, {"text": "", "childNum": 0, "tag": "code", "childList": []}, {"text": "([ef]|([gh]d*(ad*[gh]d)*b))d*b", "childNum": 0, "tag": "pre", "childList": []}]}, {"text": ["Might need rethinking, as they'll force a retry of the alternate match.", "Plus they also overlap in terms of what they match.", "They'd both match edb for example, but if one fails and tries to backtrack the other part will probably have the same behaviour."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["So in short try not to use the | if you can and try to make sure the patterns don't overlap where possible."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "|", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I think you experience what is known as \"catastrophic backtracking\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Your regex has many optional/alternative parts, all of which still try to match, so previous sub-expressions give back characters to the following expression on local failure.", "This leads to a back-and-fourth behavior within the regex and exponentially rising execution times."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Python (2.7+?, I'm not sure) supports atomic grouping and possessive quantifiers, you could examine your regex to identify the parts that should match or fail as a whole.", "Unnecessary backtracking can be brought under control with that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["catastrophic backtracking!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["example and debugger:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://www.codinghorror.com/blog/archives/000488.html"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.codinghorror.com/blog/archives/000488.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.codinghorror.com/blog/archives/000488.html"}]}], [{"text": ["Thanks to all the responses, which were very helpful.", "In the end, surprisingly, it was easy to speed it up.", "Here's the original regex:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (([ef]|([gh]d*(ad*[gh]d)*b))d*b([ef]d*b|d*)*c)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I noticed that the |d* near the end was not really what I needed, so I modified it as follows:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n (([ef]|([gh]d*(ad*[gh]d)*b))d*b([ef]d*bd*)*c)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now it works almost instantaneously on the 65,536 character string.", "I guess now I just have to make sure that the regex is really matching the strings I need it to match..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["(Incidentally, I'm going to accept the answer from someone else that was most helpful to me, rather than accepting my own answer)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Ben"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["You already gave yourself the answer: The regular expression is to complex and ambiguous."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You should try to find a less complex and more distinct expression that is easier to process.", "Or tell us what you want to accomplish and we could try to help you to find one."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "hr", "senID": 2}, {"text": ["Edit\u00a0\u00a0\u00a0If you just want to allow ds in every position as you said in a comment to John Montgomery\u2019s answer, you should remove them before testing the pattern:"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "d", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://stackoverflow.com/questions/755332/can-anyone-help-with-this-problem-i-am-having-with-finditer-in-python/755378#755378", "text": "John Montgomery\u2019s answer", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\nstring = \"ddddddeddbedddbddddddddddddddddddddddddddddddddddd\"\npattern = \"(([ef]|([gh](a[gh])*b))b([ef]b)*c)\"\nmatches = re.finditer(pattern, re.sub(\"d+\", \"\", string))\nfor match in matches:\n    print \"(%d-%d): %s\" % (match.start(), match.end(), match.group())\n</code>\n</pre>\n", "senID": 4}]]