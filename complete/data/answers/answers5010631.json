[[{"text": ["\u00ab Ok, sure, but what if the 'variable manipulation' is being done in a callback function of re.sub, can it be done then?", "I guess a simplified form of my question is: \"Can one use regular expressions to substitue differently based on previous matches?", "\" \u00bb"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Ok, sure, but what if the 'variable manipulation' is being done in a callback function of re.sub, can it be done then? I guess a simplified form of my question is: \"Can one use regular expressions to substitue differently based on previous matches?\"", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["It sounds like we need a generator function as a callback; unfortunately, re.sub() doesn't accept a generator function as a callback."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So we must use some trick:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import re\n\npat = re.compile('^(#+)',re.MULTILINE)\n\nch = '''# Section\n## Subsection\n## Subsection\n# Section\n## Subsection\n### Subsubsection\n### Subsubsection\n## Subsection\n### Subsubsection\n### Subsubsection\n#### Sub4section\n#### Sub4section\n#### Sub4section\n#### Sub4section\n##### Sub5section\n#### Sub4section\n##### Sub5section\n##### Sub5section\n### Subsubsection\n### Subsubsection\n#### Sub4section\n#### Sub4section\n## Subsection\n### Subsubsection\n### Subsubsection\n### Subsubsection\n#### Sub4section\n##### Sub5section\n##### Sub5section\n### Subsubsection\n#### Sub4section\n## Subsection\n### Subsubsection\n### Subsubsection\n# Section\n## Subsection\n## Subsection\n# Section\n## Subsection\n### Subsubsection\n#### Sub4section\n#### Sub4section\n#### Sub4section\n##### Sub5section\n#### Sub4section\n### Subsubsection\n## Subsection\n### Subsubsection\n# Section\n## Subsection\n'''\n\ndef cbk(match, nb = [0] ):\n    if len(match.group())==len(nb):\n        nb[-1] += 1\n    elif  len(match.group())&gt;len(nb):\n        nb.append(1)\n    else:\n        nb[:] = nb[0:len(match.group())]\n        nb[-1] += 1\n    return match.group()+' '+('.'.join(map(str,nb)))\n\nch = pat.sub(cbk,ch)\nprint ch\n</code>\n</pre>\n", "senID": 3}, {"text": [], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["\u00ab Default parameter values are evaluated when the function definition is executed.", "This means that the expression is evaluated once, when the function is defined, and that that same \u201cpre-computed\u201d value is used for each call.", "This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g.", "by appending an item to a list), the default value is in effect modified.", "This is generally not what was intended."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "when a default parameter is a mutable object,", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "if the function modifies the object", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "the default value is in effect modified.", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}, {"text": ["http://docs.python.org/reference/compound_stmts.html#function"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "http://docs.python.org/reference/compound_stmts.html#function", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/compound_stmts.html#function"}]}, {"text": ["But here, it IS my plain intent."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Result:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n # 1 Section\n## 1.1 Subsection\n## 1.2 Subsection\n# 2 Section\n## 2.1 Subsection\n### 2.1.1 Subsubsection\n### 2.1.2 Subsubsection\n## 2.2 Subsection\n### 2.2.1 Subsubsection\n### 2.2.2 Subsubsection\n#### 2.2.2.1 Sub4section\n#### 2.2.2.2 Sub4section\n#### 2.2.2.3 Sub4section\n#### 2.2.2.4 Sub4section\n##### 2.2.2.4.1 Sub5section\n#### 2.2.2.5 Sub4section\n##### 2.2.2.5.1 Sub5section\n##### 2.2.2.5.2 Sub5section\n### 2.2.3 Subsubsection\n### 2.2.4 Subsubsection\n#### 2.2.4.1 Sub4section\n#### 2.2.4.2 Sub4section\n## 2.3 Subsection\n### 2.3.1 Subsubsection\n### 2.3.2 Subsubsection\n### 2.3.3 Subsubsection\n#### 2.3.3.1 Sub4section\n##### 2.3.3.1.1 Sub5section\n##### 2.3.3.1.2 Sub5section\n### 2.3.4 Subsubsection\n#### 2.3.4.1 Sub4section\n## 2.4 Subsection\n### 2.4.1 Subsubsection\n### 2.4.2 Subsubsection\n# 3 Section\n## 3.1 Subsection\n## 3.2 Subsection\n# 4 Section\n## 4.1 Subsection\n### 4.1.1 Subsubsection\n#### 4.1.1.1 Sub4section\n#### 4.1.1.2 Sub4section\n#### 4.1.1.3 Sub4section\n##### 4.1.1.3.1 Sub5section\n#### 4.1.1.4 Sub4section\n### 4.1.2 Subsubsection\n## 4.2 Subsection\n### 4.2.1 Subsubsection\n# 5 Section\n## 5.1 Subsection\n</code>\n</pre>\n", "senID": 9}, {"text": ["EDIT 1 : I corrected else nb[:] = nb[0:len(match.group())] to else: only"], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "else nb[:] = nb[0:len(match.group())]", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "else:", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["EDIT 2 : the code can be condensed to"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def cbk(match, nb = [0] ):\n    if len(match.group())&gt;len(nb):\n        nb.append(1)\n    else:\n        nb[:] = nb[0:len(match.group())]\n        nb[-1] += 1\n    return match.group()+' '+('.'.join(map(str,nb)))\n</code>\n</pre>\n", "senID": 12}], [{"text": ["Regular expressions are for matching strings.", "They are not for manipulating variables as the matching occurs.", "You may not like the solution of iterating over each line and counting yourself, but it is a straightforward solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Pyparsing packages several of these scan/match/replace tasks up for you into its own parsing framework.", "Here is an annotated solution to your stated problem:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from pyparsing import LineStart, Word, restOfLine\n\nsource = \"\"\"\\\n# Section \n## Subsection \n## Subsection \n# Section \n## Subsection #\n### Subsubsection \n### Subsubsection \n# Section \n## Subsection \n\"\"\"\n\n# define a pyparsing expression to match a header line starting with some \n# number of '#'s (i.e., a \"word\" composed of '#'s), followed by the rest \n# of the line\nsectionHeader = LineStart() + Word(\"#\")(\"level\") + restOfLine\n\n# define a callback to keep track of the nesting and numbering\nnumberstack = [0]\ndef insertDottedNumber(tokens):\n    level = len(tokens.level)\n    if level &gt; len(numberstack):\n        numberstack.extend([1]*(level-len(numberstack)))\n    else:\n        del numberstack[level:]\n        numberstack[level-1] += 1\n\n    dottedNum = '.'.join(map(str,numberstack))\n\n    # return the updated string containing the original level and rest\n    # of the line, with the dotted number inserted\n    return \"%s %s %s\" % (tokens.level, dottedNum, tokens[1])\n\n# attach parse-time action callback to the sectionHeader expression\nsectionHeader.setParseAction(insertDottedNumber)\n\n# use sectionHeader expression to transform the input source string\nnewsource = sectionHeader.transformString(source)\nprint newsource\n</code>\n</pre>\n", "senID": 1}, {"text": ["Prints the desired:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # 1  Section \n## 1.1  Subsection \n## 1.2  Subsection \n# 2  Section \n## 2.1  Subsection #\n### 2.1.1  Subsubsection \n### 2.1.2  Subsubsection \n# 3  Section \n## 3.1  Subsection\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This is not a job for regular expressions alone, but you may be able to use them to make your job easier.", "For example, this splits your full text into the major sections by using regular expressions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; p = re.compile(r\"^# .*\\n^(?:^##.*\\n)*\", re.M)\n&gt;&gt;&gt; p.findall(your_text)\n['# Section\\n## Subsection\\n## Subsection\\n', '# Section\\n## Subsection\\n### Subsubsection\\n### Subsubsection\\n', '# Section\\n']\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could conceivably do something recursive with a regular expression like this to further split the subsections, but you are much better off just looping through the lines."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n import re\nimport textwrap\n\nclass DefaultList(list):\n    \"\"\"\n    List having a default value (returned on invalid offset)\n\n    &gt;&gt;&gt; t = DefaultList([1,2,3], default=17)\n    &gt;&gt;&gt; t[104]\n    17\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self.default = kwargs.pop('default', None)\n        super(DefaultList,self).__init__(*args, **kwargs)\n\n    def __getitem__(self, y):\n        if y &gt;= self.__len__():\n            return self.default\n        else:\n            return super(DefaultList,self).__getitem__(y)\n\nclass SectionNumberer(object):\n    \"Hierarchical document numberer\"\n    def __init__(self, LineMatcher, Numbertype_list, defaultNumbertype):\n        \"\"\"\n        @param LineMatcher:       line matcher instance  (recognize section headings and parse them)\n        @param Numbertype_list:   list of Number classes (do section numbering at each level)\n        @param defaultNumbertype: default Number class   (if too few Number classes specified)\n        \"\"\"\n        super(SectionNumberer,self).__init__()\n        self.match   = LineMatcher\n        self.types   = DefaultList(Numbertype_list, default=defaultNumbertype)\n        self.numbers = []\n        self.title   = ''\n\n    def addSection(self, level, title):\n        \"Add new section\"\n        depth = len(self.numbers)\n        if depth &lt; level:\n            for i in range(depth, level):\n                self.numbers.append(self.types[i](1))\n        else:\n            self.numbers = self.numbers[:level]\n            self.numbers[-1].inc()\n\n        self.title = title\n\n    def doLine(self, ln):\n        \"Process section numbering on single-line string\"\n        match = self.match(ln)\n        if match==False:\n            return ln\n        else:\n            self.addSection(*match)\n            return str(self)\n\n    def __call__(self, s):\n        \"Process section numbering on multiline string\"\n        return '\\n'.join(self.doLine(ln) for ln in s.split('\\n'))\n\n    def __str__(self):\n        \"Get label for current section\"\n        section = '.'.join(str(n) for n in self.numbers)\n        return \"{0} {1}\".format(section, self.title)\n\nclass LineMatcher(object):\n    \"Recognize section headers and parse them\"\n    def __init__(self, match):\n        super(LineMatcher,self).__init__()\n        self.match = re.compile(match)\n\n    def __call__(self, line):\n        \"\"\"\n        @param line: string\n\n        Expects that self.match is a valid regex expression\n        \"\"\"\n        match = re.match(self.match, line)\n        if match:\n            return len(match.group(1)), match.group(2)\n        else:\n            return False\n\n# Recognize section headers that look like '### Section_title'\nPoundLineMatcher = lambda: LineMatcher(r'([#]+) (.*)')\n\nclass Numbertype(object):\n    def __init__(self, startAt=0, valueType=int):\n        super(Numbertype,self).__init__()\n        self.value = valueType(startAt)\n\n    def inc(self):\n        self.value += 1\n\n    def __str__(self):\n        return str(self.value)\n\nclass Roman(int):\n    CODING = [\n        (1000, 'M'),\n        ( 900, 'CM'), ( 500, 'D'), ( 400, 'CD'), ( 100, 'C'),\n        (  90, 'XC'), (  50, 'L'), (  40, 'XL'), (  10, 'X'),\n        (   9, 'IX'), (   5, 'V'), (   4, 'IV'), (   1, 'I')\n    ]\n\n    def __add__(self, y):\n        return Roman(int.__add__(self, y))\n\n    def __str__(self):\n        value = self.__int__()\n        if 0 &lt; value &lt; 4000:\n            result = []\n            for v,s in Roman.CODING:\n                while v &lt;= value:\n                    value -= v\n                    result.append(s)\n            return ''.join(result)\n        else:\n            raise ValueError(\"can't generate Roman numeral string for {0}\".format(value))\n\nIntNumber = Numbertype\nRomanNumber = lambda x=1: Numbertype(x, Roman)\n\ndef main():\n    test = textwrap.dedent(\"\"\"\n        # Section\n        ## Subsection\n        ## Subsection\n        # Section\n        ## Subsection\n        ### Subsubsection\n        ### Subsubsection\n        # Section\n        ## Subsection\n    \"\"\")\n\n    numberer = SectionNumberer(PoundLineMatcher(), [IntNumber, RomanNumber, IntNumber], IntNumber)\n    print numberer(test)\n\nif __name__==\"__main__\":\n    main()\n</code>\n</pre>\n", "senID": 0}, {"text": ["turns"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # Section\n## Subsection\n## Subsection\n# Section\n## Subsection\n### Subsubsection\n### Subsubsection\n# Section\n## Subsection\n</code>\n</pre>\n", "senID": 2}, {"text": ["into"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n 1 Section\n1.I Subsection\n1.II Subsection\n2 Section\n2.I Subsection\n2.I.1 Subsubsection\n2.I.2 Subsubsection\n3 Section\n3.I Subsection\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Use that generator trick by eyquem.", "If not you could always do a find all in global context then rewrite the stuff in a new buffer."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If its just a one off thing this Perl sample does it all..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n use strict;\nuse warnings;\n\nmy $data = '\n # \n ## \n ## \n # \n ## \n ### \n ### \n ###### \n ##### \n ####  \n ##### \n #### \n ##### \n ###### \n ##### \n ## \n # \n ## \n ';\n\nmy @cnts = ();\n\n$data =~ s/^ [^\\S\\n]* (\\#+) [^\\S\\n]* (.*) $/ callback($1,$2) /xemg;\n\nprint $data;\n\nexit(0);\n\n##\n sub callback {\n    my ($pounds, $text) = @_;\n    my $i = length($pounds) - 1;\n    if ($i == 0 || $i &lt;= $#cnts) {\n        @cnts[ ($i+1) .. $#cnts ] = (0) x ($#cnts - $i);\n        ++$cnts[ $i ];\n    }\n    else {\n        @cnts[ ($#cnts+1) .. $i ] = (1) x ($i - $#cnts);\n    }\n    my $chapter = $cnts[0];\n    for my $ndx (1 .. $i) {\n        $chapter .= \".$cnts[ $ndx]\";\n    }\n    return \"$pounds \\t $chapter $text\";\n }\n</code>\n</pre>\n", "senID": 2}, {"text": ["Output:  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n #        1\n##       1.1\n##       1.2\n#        2\n##       2.1\n###      2.1.1\n###      2.1.2\n######   2.1.2.1.1.1\n#####    2.1.2.1.2\n####     2.1.2.2\n#####    2.1.2.2.1\n####     2.1.2.3\n#####    2.1.2.3.1\n######   2.1.2.3.1.1\n#####    2.1.2.3.2\n##       2.2\n#        3\n##       3.1\n</code>\n</pre>\n", "senID": 4}, {"text": ["My, all the helpfull people at SO"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]