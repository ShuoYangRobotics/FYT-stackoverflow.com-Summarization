[[{"code": "<pre>\n<code>\n classmap = {\n  'foo': foo\n}\n\nobj = classmap[parser['name']]()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Don't use strings:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n parser = {}\n\nclass foo:\n    pass\n\n\nparser['foo'] = foo\n\nobj = parser['foo']()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can use a metaclass that stores a dict of known classes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # a metaclass\nclass Registry(type):\n    # store all the types we know\n    registered = {}\n    def __new__(cls, name, bases, attrs):\n        # create the new type\n        newtype = super(Registry, cls).__new__(cls, name, bases, attrs)\n        # store it\n        cls.registered[name] = newtype\n        return newtype\n\n    @classmethod\n    def class_by_name(cls, name):\n        # get a class from the registerd classes\n        return cls.registered[name]\n\n\n# random base class for every class that should be in the Register\nclass Registered(object):\n    __metaclass__ = Registry\n\n# some classes\nclass Foo(Registered):\n    pass\n\nclass Bar(Foo):\n    pass\n\n # get the class object: \nprint Registry.class_by_name('Foo') # &lt;class '__main__.Foo'&gt;\n# it can be instanciated too ofc:\nprint Registry.class_by_name('Bar')() # &lt;__main__.Bar object at 0x01F0F9F0&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["But not everyone understands metaclasses, so you might want to avoid them to prevent any confusion.", "They can be useful for stuff like this, but as you can see from the other answers, there are plenty other ways to do it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As answered in:\nPython dynamic class names "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/7281110/python-dynamic-class-names", "text": "Python dynamic class names", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["There is an easier way to do this if you know which module the classes are defined in, for example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n getattr(my_module, my_class_name)()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The type(name, bases, dict) built-in function is the correct way to dynamically construct classes--especially when given strings for class names.", "See the documentation here: http://docs.python.org/library/functions.html#type"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "type(name, bases, dict)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "http://docs.python.org/library/functions.html#type", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#type"}]}, {"text": ["In you particular example, it might look like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def init(self):\n...     print 'Hello'\n...\n&gt;&gt;&gt; Foo = type('Foo', (object,), {'__init__': init})\n&gt;&gt;&gt; foo = Foo()\nHello\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You could use inspect to create the class map:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def get_classes():\n    classes = {}\n    for name, obj in inspect.getmembers(sys.modules[__name__]):\n        if inspect.isclass(obj):\n            classes[name] = obj\n    return classes\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then instantiate a class "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; classes = get_classes()\n&gt;&gt;&gt; c = classes['ClassName']\n&gt;&gt;&gt; c\n&lt;class ClassName...&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["Mostly nicked from Python: Get list of all classes within current module"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Python: Get list of all classes within current module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1796180/python-get-list-of-all-classes-within-current-module"}]}], [{"text": ["In response to your update: The only way to do this is with a mapping system.", "If you don't want to use an explicit mapping system, then you can use one of Python's built-in mapping systems, though it's much less nice and explicit in my opinion."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n obj = globals()[parser['name']]()\n</code>\n</pre>\n", "senID": 1}, {"text": ["will access the global object of with name parser['name'] == 'foo'.", "If this happens to be a class (or a class that you actually want instantiated based on user input), then you should be good to go.", "Otherwise, you will have to build logic around it to whitelist the classes that you actually want."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "parser['name'] == 'foo'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If the classes are coming from a module, then you can use that module's __dict__ attribute to the same effect."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "__dict__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n obj = somemodule.__dict__[parser['name']]()\n</code>\n</pre>\n", "senID": 4}, {"text": ["The same caveats apply to this situation as the previous one.", "It's really better to just use an explicit mapping"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I would use a map of class name to class object like everyone else is saying.", "You can initialize it using statements like parser[foo.__name__] = foo.", "If you do not want to use a mapping object, then you will have to fall back to using the eval function like the following:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "parser[foo.__name__] = foo", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "eval", "tag": "a", "pos": 2, "childList": [{"text": "eval", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/py3k/library/functions.html#eval"}, {"text": "eval", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class foo:\n...   pass\n...\n&gt;&gt;&gt; klass_name = 'foo'\n&gt;&gt;&gt; klass_inst = eval(klass_name)\n&gt;&gt;&gt; klass_inst\n&lt;class __main__.foo at 0x1004b2b90&gt;\n&gt;&gt;&gt; inst = klass_inst()\n&gt;&gt;&gt; inst\n&lt;__main__.foo instance at 0x1004d2680&gt;\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course if you want to use classes that are embedded within a package, then the package will have to be imported before you do the eval.", "You really should build a mapping object so that you can limit the classes that can be accessed using this code."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "eval", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]