[[{"text": ["(a) I fail to see what is wrong with if...elif...else"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(b) I assume that python does not have a switch statement for the same reason that Smalltalk doesn't: it's almost completely redundant, and in the case where you want to switch on types, you can add an appropriate method to your classes; and likewise switching on values should be largely redundant. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Note: I am informed in the comments that whatever Guido's reason for not creating a switch in the first place, PEPs to have it added were rejected on the basis that support for adding such a statement is extremely limited.", "See: http://www.python.org/dev/peps/pep-3103/"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Note:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "http://www.python.org/dev/peps/pep-3103/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3103/"}]}, {"text": ["(c) If you really need switching behaviour, use a hashtable (dict) to store callables.", "The structure is:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n switch_dict = {\n    Foo: self.doFoo,\n    Bar: self.doBar,\n    }\n\nfunc = switch_dict[switch_var]\nresult = func() # or if they take args, pass args\n</code>\n</pre>\n", "senID": 4}], [{"text": ["There's nothing wrong with a long if:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if switch == 'case0':\n   do_case0()\nelif switch == 'case1':\n   do_case1()\nelif switch == 'case2':\n   do_case2()\n...\n</code>\n</pre>\n", "senID": 1}, {"text": ["If that's too long winded, or if you have a lot of cases, put them in a dictionary:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n switch = {'case0': do_case0, 'case1': do_case1, 'case2': do_case2, ...}\nswitch[case_variable]()\n// Alternative:\n(switch[case_variable]).__call__()\n</code>\n</pre>\n", "senID": 3}, {"text": ["If your conditions are a bit more complex, you need to think a little about your data structures.", "e.g."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n switch = {(0,21): 'never have a pension',\n          (21,50): 'might have a pension',\n          (50,65): 'definitely have a pension',\n          (65, 200): 'already collecting pension'}\nfor key, value in switch:\n    if key[0] &lt; case_var &lt; key[1]:\n        print(value)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I don't know which article you've found to do something like this, but this is really messy: the whole result diction will be always evaluated, and instead of doing only part of the work (as a switch / if do), you'll do the whole work everytime.", "(even if you use only a part of the result)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Really, a fast switch statement in Python is using \"if\":"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if case == 1:\n  pass\nelif case == 2:\n  pass\nelif case == 3:\n  pass\nelse:\n  # default case\n  pass\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Assignment in Python is a statement, and cannot be a part of expression.", "Also, using literal in this way evaluates everything at once, which is probably not what you want.", "Just use ifs, you won't gain any readability by using this."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["With \"get\" method, you can have the same effect as \"switch..case\" in C."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Marcin example :"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n switch_dict = {\n    Foo: self.doFoo,\n    Bar: self.doBar,\n}\n\nfunc = switch_dict.get(switch_var, self.dodefault)\nresult = func() # or if they take args, pass args\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You can do something like what you want, but you shouldn't.", "That said, here's how; you can see how it does not improve things."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "can", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "shouldn't.", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["The biggest problem with the way you have it is that Python will evaluate your tests and results once, at the time you declare the dictionary.", "What you'd have to do instead is make all conditions and the resulting statements functions; this way, evaluation is deferred until you call them.", "Fortunately there is a way to do this inline for simple functions using the lambda keyword.", "Secondly, the assignment statement can't be used as a value in Python, so our action functions (which are executed if the corresponding condition function returns a truthy value) have to return a value that will be used to increment c; they can't assign to c themselves."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Also, the items in a dictionary aren't ordered, so your tests won't necessarily be performed in the order you define them, meaning you probably should use something other than a dictionary that preserves order, such as a tuple or a list.", "I am assuming you want only ever one case to execute."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["So, here we go:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def findStuff(cds):\n\n    cases = [ (lambda: a[2][0] == 1, lambda: i + 1),\n              (lambda: a[2][1] == 1, lambda: i + 2),\n              (lambda: a[2][2] == 1, lambda: i + 3),\n              (lambda: a[1] == 1,    lambda: L.append(cds[i:i+3], a[0], c) or 0)\n            ]\n\n    L=[]\n    c=0\n    for i in range(0, len(cds), 3):\n        a=differencesTo(cds[i:i+3])\n        for condition, action in cases:\n            if condition():\n                c += action()\n                break\n    return L\n</code>\n</pre>\n", "senID": 4}, {"text": ["Is this more readable than a sequence of if/elif statements?", "Nooooooooooooo.", "In particular, the fourth case is far less comprehensible than it should be because we are having to rely on a function that returns the increment for c to modify a completely different variable, and then we have to figure out how to get it to return a 0 so that c won't actually be modified.", "Uuuuuugly."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "if/elif", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Don't do this.", "In fact this code probably won't even run as-is, as I deemed it too ugly to test."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Don't do this.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}]]