[[{"text": ["There are probably dozens of ways to store your list data in a file instead of in memory.", "How you choose to do it will depend entirely on what sort of operations you need to perform on the data.", "Do you need random access to the Nth element?", "Do you need to iterate over all elements?", "Will you be searching for elements that match certain criteria?", "What form do the list elements take?", "Will you only be inserting at the end of the list, or also in the middle?", "Is there metadata you can keep in memory with the bulk of the items on disk?", "And so on and so on."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One possibility is to structure your data relationally, and store it in a SQLite database."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The answer is very much \"it depends\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What are you storing in the lists?", "Strings?", "integers?", "Objects?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["How often is the list written to compared with being read?", "Are items only appended on the end, or can entries be modified or inserted in the middle?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you are only appending to the end then writing to a flat file may be the simplest thing that could possibly work."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If you are storing objects of variable size such as strings then maybe keep an in-memory index of the start of each string, so you can read it quickly."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If you want dictionary behaviour then look at the db modules - dbm, gdbm, bsddb, etc."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["If you want random access writing then maybe a SQL database may be better."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Whatever you do, going to disk is going to be orders of magnitude slower than in-memory, but without knowing how the data is going to be used it is impossible to be more specific."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["edit:\nFrom your updated requirements I would go with a flat file and keep an in-memory buffer of the last N elements."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["If your \"numbers\" are simple-enough ones (signed or unsigned integers of up to 4 bytes each, or floats of 4 or 8 bytes each), I recommend the standard library array module as the best way to keep a few millions of them in memory (the \"tip\" of your \"virtual array\") with a binary file (open for binary R/W) backing the rest of the structure on disk.", "array.array has very fast fromfile and tofile methods to facilitate the moving of data back and forth."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "array", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/array.html?highlight=array#module-array"}, {"text": "array.array", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "fromfile", "childNum": 0, "tag": "code", "childList": []}, {"text": "tofile", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I.e., basically, assuming for example unsigned-long numbers, something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import os\n\n# no more than 100 million items in memory at a time\nMAXINMEM = int(1e8)\n\nclass bigarray(object):\n  def __init__(self):\n    self.f = open('afile.dat', 'w+')\n    self.a = array.array('L')\n  def append(self, n):\n    self.a.append(n)\n    if len(self.a) &gt; MAXINMEM:\n      self.a.tofile(self.f)\n      del self.a[:]\n  def pop(self):\n    if not len(self.a):\n      try: self.f.seek(-self.a.itemsize * MAXINMEM, os.SEEK_END)\n      except IOError: return self.a.pop()  # ensure normal IndexError &amp;c\n      try: self.a.fromfile(self.f, MAXINMEM)\n      except EOFError: pass\n      self.f.seek(-self.a.itemsize * MAXINMEM, os.SEEK_END)\n      self.f.truncate()\n    return self.a.pop()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Of course you can add other methods as necessary (e.g.", "keep track of the overall length, add extend, whatever), but if pop and append are indeed all you need this should serve."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "extend", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "pop", "childNum": 0, "tag": "code", "childList": []}, {"text": "append", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Did you check shelve python module which is based on pickle?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://docs.python.org/library/shelve.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/shelve.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/shelve.html"}]}], [{"text": ["Well, if you are looking for speed and your data is numerical in nature, you could consider using numpy and PyTables or h5py.", "From what I remember, the interface is not as nice as simple lists, but the scalability is fantastic!"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "PyTables", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.pytables.org/moin"}, {"text": "h5py", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://h5py.alfven.org/"}]}], [{"text": ["You might want to consider a different kind of structure: not a list, but figuring out how to do (your task) with a generator or a custom iterator."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Modern operating systems will handle this for you without you having to worry about it.", "It's called virtual memory. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "virtual memory", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Virtual_memory"}]}], [{"text": ["What about a document oriented database?", "There are several alternatives; I think the most known one currently is CouchDB, but you can also go for Tokyo Cabinet, or MongoDB.", "The last one has the advantage of python bindings directly from the main project, without requiring any additional module."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "CouchDB", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://couchdb.apache.org/"}, {"text": "Tokyo Cabinet", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/601865/python-table-engine-binding-for-tokyo-cabinet"}, {"text": "MongoDB", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.mongodb.org/display/DOCS/Home"}]}]]