[[{"text": ["There isn't any reason not to use keyword arguments apart from the clarity and readability of the code.", "The choice of whether to use keywords should be based on whether the keyword adds additional useful information when reading the code or not."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I follow the following general rule:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In most cases, stable mandatory arguments would be positional, and optional arguments would be keyword."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["There's also a possible difference in performance, because in every implementation the keyword arguments would be slightly slower, but considering this would be generally a premature optimisation and the results from it wouldn't be significant, I don't think it's crucial for the decision."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["UPDATE: Non-stylistical concerns"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "UPDATE: Non-stylistical concerns", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Keyword arguments can do everything that positional arguments can, and if you're defining a new API there are no technical disadvantages apart from possible performance issues.", "However, you might have little issues if you're combining your code with existing elements."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Consider the following:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "If you make your function take keyword arguments, that becomes part of your interface. \nYou can't replace your function with another that has a similar signature but a different keyword for the same argument.", "tag": "none", "senID": 7}, {"text": "You might want to use a decorator or another utility on your function that assumes that your function takes a positional argument. Unbound methods are an example of such utility because they always pass the first argument as positional after reading it as positional, so ", "tag": "none", "senID": 8}]}, {"text": ["None of these would be a real issue if you design your API well and document the use of keyword arguments, especially if you're not designing something that should be interchangeable with something that already exists."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["Well, there are a few reasons why I would not do that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If all your arguments are keyword arguments, it increases noise in the code and it might remove clarity about which arguments are required and which ones are optionnal."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Also, if I have to use your code, I might want to kill you !!", "(Just kidding), but having to type the name of all the parameters everytime... not so fun."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If your consideration is to improve readability of function calls, why not simply declare functions as normal, e.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def test(x, y):\n    print \"x:\", x\n    print \"y:\", y\n</code>\n</pre>\n", "senID": 1}, {"text": ["And simply call functions by declaring the names explicitly, like so:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n test(y=4, x=1)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Which obviously gives you the output:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n x: 1\ny: 4\n</code>\n</pre>\n", "senID": 5}, {"text": ["or this exercise would be pointless."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["This avoids having arguments be optional and needing default values (unless you want them to be, in which case just go ahead with the keyword arguments!", ":) and gives you all the versatility and improved readability of named arguments that are not limited by order."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I remember reading a very good explanation of \"options\" in UNIX programs: \"Options are meant to be optional, a program should be able to run without any options at all\". "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The same principle could be applied to keyword arguments in Python.", "These kind of arguments should allow a user to \"customize\" the function call, but a function should be able to be called without any implicit keyword-value argument pairs at all. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "keyword", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Just to offer a different argument, I think there are some cases in which named parameters might improve readability.", "For example, imagine a function that creates a user in your system:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n create_user(\"George\", \"Martin\", \"g.m@example.com\", \"payments@example.com\", \"1\", \"Radius Circle\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["From that definition, it is not at all clear what these values might mean, even though they are all required, however with named parameters it is always obvious:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n create_user(\n    first_name=\"George\",\n    last_name=\"Martin\",\n    contact_email=\"g.m@example.com\",\n    billing_email=\"payments@example.com\",\n    street_number=\"1\",\n    street_name=\"Radius Circle\")\n</code>\n</pre>\n", "senID": 3}], [{"text": ["When Python's built-in compile() and __import__() functions gain keyword argument support, the same argument was made in favor of clarity.", "There appears to be no significant performance hit, if any."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "compile()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__import__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "gain keyword argument support", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://bugs.python.org/issue1444529"}]}, {"text": ["Now, if you make your functions only accept keyword arguments (as opposed to passing the positional parameters using keywords when calling them, which is allowed), then yes, it'd be annoying."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "only", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Sometimes, things should be simple because they are simple."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you always enforce you to use keyword arguments on every function call, soon your code will be unreadable."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I don't see the purpose of using keyword arguments when the meaning of the arguments is obvious"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["One downside I could see is that you'd have to think of a sensible default value for everything, and in many cases there might not be any sensible default value (including None).", "Then you would feel obliged to write a whole lot of error handling code for the cases where a kwarg that logically should be a positional arg was left unspecified.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Imagine writing stuff like this every time.."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def logarithm(x=None):\n  if x is None:\n    raise BadArgsException(\"You can't do log(None), silly!\")\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Keyword args are good when you have long parameter lists with no well defined order (that you can't easily come up with a clear scheme to remember); however there are many situations where using them is overkill or makes the program less clear."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First, sometimes is much easier to remember the order of keywords than the names of keyword arguments, and specifying the names of arguments could make it less clear.", "Take randint from scipy.random with the following docstring:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "randint", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "scipy.random", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n randint(low, high=None, size=None)    \nReturn random integers x such that low &lt;= x &lt; high.\nIf high is None, then 0 &lt;= x &lt; low.\n</code>\n</pre>\n", "senID": 2}, {"text": ["When wanting to generate a random int from [0,10) its clearer to write randint(10) than randint(low=10) in my view.", "If you need to generate an array with 100 numbers in [0,10) you can probably remember the argument order and write randint(0, 10, 100).", "However, you may not remember the variable names (e.g., is the first parameter low, lower, start, min, minimum) and once you have to look up the parameter names, you might as well not use them (as you just looked up the proper order).  "], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "randint(10)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "randint(low=10)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "randint(0, 10, 100)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Also consider variadic functions (ones with variable number of parameters that are anonymous themselves).", "E.g., you may want to write something like:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def square_sum(*params):\n    sq_sum = 0\n    for p in params:\n        sq_sum += p*p\n    return sq_sum\n</code>\n</pre>\n", "senID": 5}, {"text": ["that can be applied a bunch of bare parameters (square_sum(1,2,3,4,5) # gives 55 ).", "Sure you could have written the function to take an named keyword iterable def square_sum(params): and called it like square_sum([1,2,3,4,5]) but that may be less intuitive, especially when there's no potential confusion about the argument name or its contents."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "square_sum(1,2,3,4,5) # gives 55", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "def square_sum(params):", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "square_sum([1,2,3,4,5])", "childNum": 0, "tag": "code", "childList": []}]}]]