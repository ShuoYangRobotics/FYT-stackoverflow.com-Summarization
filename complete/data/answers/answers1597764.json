[[{"text": ["Congratulations, your code is very nice.", "There are a few little tricks you could use to make it shorter/simpler."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There is a nifty object type called defaultdict which is  provided by the collections module.", "Instead of having to check if adDict has an adId key, you can set up a defaultdict which acts like a regular dict, except that it automatically provides you with an empty set() when there is no key.", "So you can change"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if ( adId in adDict ):\n    adDict[adId].add(userId)\nelse:\n    adDict[adId] = set(userId)\n</code>\n</pre>\n", "senID": 2}, {"text": ["to simply"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n adDict[adId].add(userId)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Also, instead of "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n for row in reader:\n    adId = row[0]\n    userId = row[1]\n</code>\n</pre>\n", "senID": 6}, {"text": ["you could shorten that to"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n for adId,userId in reader:\n</code>\n</pre>\n", "senID": 8}, {"text": ["Edit: As Parker kindly points out in the comments, "], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for key, value in adDict.iteritems():\n</code>\n</pre>\n", "senID": 10}, {"text": ["is the most efficient way to iterate over a dict, if you are going to use both\nthe key and value in the loop.", "In Python3, you can use"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n for key, value in adDict.items():\n</code>\n</pre>\n", "senID": 12}, {"text": ["since items() returns an iterator. "], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nimport csv\nfrom collections import defaultdict\n\nadDict = defaultdict(set)\nreader = csv.reader(open(\"some.csv\"), delimiter=' ')\nfor adId,userId in reader:\n    adDict[adId].add(userId)\nfor key,value in adDict.iteritems():\n    print (key, ',' , len(value))\n</code>\n</pre>\n", "senID": 14}], [{"text": ["the line of code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n adDict[adId] = set(userId)\n</code>\n</pre>\n", "senID": 1}, {"text": ["is unlikely to do what you want -- it will treat string userId as a sequence of letters, so for example if userId was aleax you'd get a set with four items, just like, say, set(['a', 'l', 'e', 'x']).", "Later, an .add(userId) when userId is aleax again will add a fifth item, the string 'aleax', because .add (differently from the set initializer, which takes an iterable as its argument) takes a single item as its argument."], "childNum": 9, "tag": "p", "senID": 2, "childList": [{"text": "userId", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "userId", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "aleax", "childNum": 0, "tag": "code", "childList": []}, {"text": "set(['a', 'l', 'e', 'x'])", "childNum": 0, "tag": "code", "childList": []}, {"text": ".add(userId)", "childNum": 0, "tag": "code", "childList": []}, {"text": "userId", "childNum": 0, "tag": "code", "childList": []}, {"text": "aleax", "childNum": 0, "tag": "code", "childList": []}, {"text": "'aleax'", "childNum": 0, "tag": "code", "childList": []}, {"text": ".add", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To make a set with a single item, use set([userId]) instead."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "set([userId])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This is a reasonably frequent bug so I wanted to explain it clearly.", "That being said, defaultdict as suggested in other answers is clearly the right approach (avoid setdefault, that was never a good design and doesn't have good performance either, as well as being pretty murky)."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "defaultdict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "setdefault", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I would also avoid the kinda-overkill of csv in favor of a simple loop with a .split and .strip on each line..."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "csv", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You could shorten the for-loop to this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for row in reader:\n  adDict.setdefault(row[0], set()).add(row[1])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Instead of:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for row in reader:\n    adId = row[0]\n    userId = row[1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Use automatic sequence unpacking:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for (adId, userId) in reader:\n</code>\n</pre>\n", "senID": 3}, {"text": ["In:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n if ( adId in adDict ):\n</code>\n</pre>\n", "senID": 5}, {"text": ["You don't need parentheses."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Instead of:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n if ( adId in adDict ):\n    adDict[adId].add(userId)\nelse:\n    adDict[adId] = set(userId)\n</code>\n</pre>\n", "senID": 8}, {"text": ["Use defaultdict:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "defaultdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from collections import defaultdict\nadDict = defaultDict(set)\n\n# ...\n\nadDict[adId].add(userId)\n</code>\n</pre>\n", "senID": 10}, {"text": ["Or, if you're not allowed to use other modules by your professor, use setdefault():"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "setdefault()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n adDict.setdefault(adId, set()).add(userId)\n</code>\n</pre>\n", "senID": 12}, {"text": ["When printing:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n for key, value in adDict.items():\n    print (key, ',' , len(value))\n</code>\n</pre>\n", "senID": 14}, {"text": ["Using string formatting might be easier to format:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n print \"%s,%s\" % (key, len(value))\n</code>\n</pre>\n", "senID": 16}, {"text": ["Or, if you're using Python 3:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n print (\"{0},{1}\".format (key, len(value)))\n</code>\n</pre>\n", "senID": 18}], [{"text": ["Since you only have a space-delimited file, I'd do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import with_statement\nfrom collections import defaultdict\n\nads = defaultdict(set)\nwith open(\"some.csv\") as f:\n    for ad, user in (line.split(\" \") for line in f):\n        ads[ad].add(user)\n\nfor ad in ads:\n    print \"%s, %s\" % (ad, len(ads[ad]))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There are some great answers in here."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One trick I particularly like is to make my code easier to reuse in future like so "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import csv\n\ndef parse_my_file(file_name):\n     # some existing code goes here\n     return aDict\n\nif __name__ == \"__main__\":\n     #this gets executed if this .py file is run directly, rather than imported\n     aDict = parse_my_file(\"some.csv\")\n     for key, value in adDict.items():\n         print (key, ',' , len(value))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now you can import your csv parser from another module and get programmatic access to aDict. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The only changes I'd make are extracting multiple elements from the reader at once, and using string formatting for print statements."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import csv\n\nadDict = {}\nreader = csv.reader(open(\"some.csv\"), delimiter=' ')\n# Can extract multiple elements from a list in the iteration statement:\nfor adId, userId in reader: \n    if ( adId in adDict ):\n        adDict[adId].add(userId)\n    else:\n        adDict[adId] = set(userId)\n\nfor key, value in adDict.items():\n    # I believe this gives you more control over how things are formatted:\n    print (\"%s, %d\" % (key, len(value)))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Just a few bits and pieces:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For extracting the row list into variables:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n adId, userId = row\n</code>\n</pre>\n", "senID": 2}, {"text": ["The if statement does not need braces:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n if adId in adDict:\n</code>\n</pre>\n", "senID": 4}, {"text": ["You could use exceptions to handle a missing Key in the dict, but both ways work well, e.g."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "could", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n try:\n    adDict[adId].add(userId)\nexcept KeyError:\n    adDict[adId] = set(userId)\n</code>\n</pre>\n", "senID": 6}]]