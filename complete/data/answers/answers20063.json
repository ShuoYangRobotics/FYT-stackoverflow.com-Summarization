[[{"text": ["As other people pointed out, you are better off going with optparse over getopt.", "getopt is pretty much a one-to-one mapping of the standard getopt(3) C library functions, and not very easy to use."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["optparse, while being a bit more verbose, is much better structured and simpler to extend later on."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here's a typical line to add an option to your parser:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n parser.add_option('-q', '--query',\n            action=\"store\", dest=\"query\",\n            help=\"query string\", default=\"spam\")\n</code>\n</pre>\n", "senID": 3}, {"text": ["It pretty much speaks for itself; at processing time, it will accept -q or --query as options, store the argument in an attribute called query and has a default value if you don't specify it.", "It is also self-documenting in that you declare the help argument (which will be used when run with -h/--help) right there with the option."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Usually you parse your arguments with:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n options, args = parser.parse_args()\n</code>\n</pre>\n", "senID": 6}, {"text": ["This will, by default, parse the standard arguments passed to the script (sys.argv[1:])"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["options.query will then be set to the value you passed to the script."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["You create a parser simply by doing"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n parser = optparse.OptionParser()\n</code>\n</pre>\n", "senID": 10}, {"text": ["These are all the basics you need.", "Here's a complete Python script that shows this:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n import optparse\n\nparser = optparse.OptionParser()\n\nparser.add_option('-q', '--query',\n    action=\"store\", dest=\"query\",\n    help=\"query string\", default=\"spam\")\n\noptions, args = parser.parse_args()\n\nprint 'Query string:', options.query\n</code>\n</pre>\n", "senID": 12}, {"text": ["5 lines of python that show you the basics."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["Save it in sample.py, and run it once with"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n python sample.py\n</code>\n</pre>\n", "senID": 15}, {"text": ["and once with"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n python sample.py --query myquery\n</code>\n</pre>\n", "senID": 17}, {"text": ["Beyond that, you will find that optparse is very easy to extend.", "In one of my projects, I created a Command class which allows you to nest subcommands in a command tree easily.", "It uses optparse heavily to chain commands together.", "It's not something I can easily explain in a few lines, but feel free to browse around in my repository for the main class, as well as a class that uses it and the option parser"], "childNum": 2, "tag": "p", "senID": 18, "childList": [{"text": "browse around in my repository", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "https://thomas.apestaart.org/moap/trac/browser/trunk/moap/extern/command/command.py"}, {"href": "https://thomas.apestaart.org/moap/trac/browser/trunk/moap/command/doap.py", "text": "a class that uses it and the option parser", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["The new hip way is argparse for these reasons.", "argparse > optparse > getopt"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "argparse", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "these", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://argparse.googlecode.com/svn/trunk/doc/argparse-vs-optparse.html"}]}, {"text": ["update: As of py2.7 argparse is part of the standard library and optparse is deprecated."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/argparse.html", "text": "argparse", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://docs.python.org/library/optparse.html", "text": "optparse", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Pretty much everybody is using getopt"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "getopt", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://python.active-venture.com/lib/module-getopt.html"}]}, {"text": ["Here is the example code for the doc :"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import getopt, sys\n\ndef main():\n    try:\n        opts, args = getopt.getopt(sys.argv[1:], \"ho:v\", [\"help\", \"output=\"])\n    except getopt.GetoptError:\n        # print help information and exit:\n        usage()\n        sys.exit(2)\n    output = None\n    verbose = False\n    for o, a in opts:\n        if o == \"-v\":\n            verbose = True\n        if o in (\"-h\", \"--help\"):\n            usage()\n            sys.exit()\n        if o in (\"-o\", \"--output\"):\n            output = a\n</code>\n</pre>\n", "senID": 2}, {"text": ["So in a word, here is how it works."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You've got two types of options.", "Those who are receiving an arguments, and those who are\njust like switches."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["sys.argv is pretty much your char** argv in C. Like in C you skip the first element which is the name of your program and parse only the arguments : sys.argv[1:]"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Getopt.getopt is will parse it according to the rule you give in argument."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["\"ho:v\" here describes the short arguments : -ONELETTER.", "The : means that -o accepts one arguments."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Finally [\"help\", \"output=\"] describes long arguments ( --MORETHANONELETTER ).", "The = after output once again means that output accepts one arguments."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["The result is a list of couple (option,argument)"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["If an option doesn't accept any argument (like --help here) the arg part is an empty string.", "You then usually want to loop on this list and test the option name as in the example."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["I hope this helped you."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["Use optparse which comes with the standard library.", "Here's a link describing how to use it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.ibm.com/developerworks/aix/library/au-pythocli/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.ibm.com/developerworks/aix/library/au-pythocli/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ibm.com/developerworks/aix/library/au-pythocli/"}]}], [{"text": ["Just in case you might need to, this may help if you need to grab unicode arguments on Win32 (2K, XP etc):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "grab", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from ctypes import *\n\ndef wmain(argc, argv):\n    print argc\n    for i in argv:\n        print i\n    return 0\n\ndef startup():\n    size = c_int()\n    ptr = windll.shell32.CommandLineToArgvW(windll.kernel32.GetCommandLineW(), byref(size))\n    ref = c_wchar_p * size.value\n    raw = ref.from_address(ptr)\n    args = [arg for arg in raw]\n    windll.kernel32.LocalFree(ptr)\n    exit(wmain(len(args), args))\nstartup()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I prefer optparse to getopt.", "It's very declarative: you tell it the names of the options and the effects they should have (e.g., setting a boolean field), and it hands you back a dictionary populated according to your specifications."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://docs.python.org/lib/module-optparse.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/lib/module-optparse.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-optparse.html"}]}], [{"text": ["I think the best way for larger projects is optparse, but if you are looking for an easy way, maybe http://werkzeug.pocoo.org/documentation/script is something for you."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://werkzeug.pocoo.org/documentation/script", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://werkzeug.pocoo.org/documentation/script"}]}, {"code": "<pre>\n<code>\n from werkzeug import script\n\n# actions go here\ndef action_foo(name=\"\"):\n    \"\"\"action foo does foo\"\"\"\n    pass\n\ndef action_bar(id=0, title=\"default title\"):\n    \"\"\"action bar does bar\"\"\"\n    pass\n\nif __name__ == '__main__':\n    script.run()\n</code>\n</pre>\n", "senID": 1}, {"text": ["So basically every function action_* is exposed to the command line and a nice\nhelp message is generated for free. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n python foo.py \nusage: foo.py &lt;action&gt; [&lt;options&gt;]\n       foo.py --help\n\nactions:\n  bar:\n    action bar does bar\n\n    --id                          integer   0\n    --title                       string    default title\n\n  foo:\n    action foo does foo\n\n    --name                        string\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The title doesn't say it all :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "hr", "senID": 1}, {"text": ["best != easiest and tersest "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "hr", "senID": 3}, {"text": ["I think the best way is the optparse way but that's certainly not the tersest  ;)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Check out commandlineapp.", "It makes things a lot easier to handle imo.", "http://blog.doughellmann.com/2008/06/commandlineapp-30.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://blog.doughellmann.com/2008/06/commandlineapp-30.html", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://blog.doughellmann.com/2008/06/commandlineapp-30.html"}]}]]