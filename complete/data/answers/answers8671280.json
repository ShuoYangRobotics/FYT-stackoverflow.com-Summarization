[[{"text": ["You can try itertools.islice(iterable[, start], stop[, step]):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "itertools.islice(iterable[, start], stop[, step])", "tag": "a", "pos": 0, "childList": [{"text": "itertools.islice(iterable[, start], stop[, step])", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.islice"}, {"text": "itertools.islice(iterable[, start], stop[, step])", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\nfor line in itertools.islice(list , start, stop):\n     foo(line)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I prefer to use dropwhile for this.", "It feels natural after using it in Haskell and some other languages, and seems reasonably clear.", "You can also use it in many other cases where you want to look for a \"trigger\" condition more complex than the item's index for the start of the iteration."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dropwhile", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.dropwhile"}]}, {"code": "<pre>\n<code>\n from itertools import dropwhile\n\nfor item in dropwhile(lambda x: x[0] &lt; 2, enumerate(lst)):\n  # ... do something with item\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Although itertools.islice appears to be the optimal solution for this problem, somehow, the extra import just seems like overkill for something so simple."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.islice", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Personally, I find the enumerate solution perfectly readable and succinct - although I would prefer to write it like this:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "enumerate", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for index, line in enumerate(lines):\n    if index &gt;= 2:\n        foo(line)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You might build a helper generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def rangeit(lst, rng):\n  for i in rng:\n    yield lst[i]\n\nfor e in rangeit([\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"], range(2,4)):\n  print(e)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n for fooable in (line for i,line in enumerate(lines) if i &gt;= 2):\n    foo(fooable)\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n def skip_heading( iterable, items ):\n    the_iter= iter( iterable ):\n    for i, e in enumerate(the_iter):\n        if i == items: break\n    for e in the_iter:\n        yield e\n</code>\n</pre>\n", "senID": 0}, {"text": ["Now you can for i in skip_heading( lines, 2 ): without worrying."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "for i in skip_heading( lines, 2 ):", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The original solution is, in most cases, the appropriate one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for line in lines[2:]:\n    foo(line)\n</code>\n</pre>\n", "senID": 1}, {"text": ["While this does copy the list, it is only a shallow copy, and is quite quick.", "Don't worry about optimizing until you have profiled the code and found this to be a bottleneck."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]