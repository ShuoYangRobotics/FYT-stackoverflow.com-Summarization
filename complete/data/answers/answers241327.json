[[{"text": ["C (and C++) comments cannot be nested.", "Regular expressions work well:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n //.*?\\n|/\\*.*?\\*/\n</code>\n</pre>\n", "senID": 1}, {"text": ["This requires the \u201cSingle line\u201d flag (Re.S) because a C comment can span multiple lines."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Re.S", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def stripcomments(text):\n    return re.sub('//.*?\\n|/\\*.*?\\*/', '', text, re.S)\n</code>\n</pre>\n", "senID": 3}, {"text": ["This code should work."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["/EDIT: Notice that my above code actually makes an assumption about line endings!", "This code won't work on a Mac text file.", "However, this can be amended relatively easily:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n //.*?(\\r\\n?|\\n)|/\\*.*?\\*/\n</code>\n</pre>\n", "senID": 6}, {"text": ["This regular expression should work on all text files, regardless of their line endings (covers Windows, Unix and Mac line endings)."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["/EDIT: MizardX and Brian (in the comments) made a valid remark about the handling of strings.", "I completely forgot about that because the above regex is plucked from a parsing module that has additional handling for strings.", "MizardX's solution should work very well but it only handles double-quoted strings."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["This handles C++-style comments, C-style comments, strings and simple nesting thereof."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def comment_remover(text):\n    def replacer(match):\n        s = match.group(0)\n        if s.startswith('/'):\n            return \"\"\n        else:\n            return s\n    pattern = re.compile(\n        r'//.*?$|/\\*.*?\\*/|\\'(?:\\\\.|[^\\\\\\'])*\\'|\"(?:\\\\.|[^\\\\\"])*\"',\n        re.DOTALL | re.MULTILINE\n    )\n    return re.sub(pattern, replacer, text)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Strings needs to be included, because comment-markers inside them does not start a comment."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: re.sub didn't take any flags, so had to compile the pattern first."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Edit2: Added character literals, since they could contain quotes that would otherwise be recognized as string delimiters."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Edit2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["I don't know if you're familiar with sed, the UNIX-based (but Windows-available) text parsing program, but I've found a sed script here which will remove C/C++ comments from a file.", "It's very smart; for example, it will ignore '//' and '/*' if found in a string declaration, etc.", "From within Python, it can be used using the following code:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sed", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "here", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://sed.sourceforge.net/grabbag/scripts/remccoms3.sed"}]}, {"code": "<pre>\n<code>\n import subprocess\nfrom cStringIO import StringIO\n\ninput = StringIO(source_code) # source_code is a string with the source code.\noutput = StringIO()\n\nprocess = subprocess.Popen(['sed', '/path/to/remccoms3.sed'],\n    input=input, output=output)\nreturn_code = process.wait()\n\nstripped_code = output.getvalue()\n</code>\n</pre>\n", "senID": 1}, {"text": ["In this program, source_code is the variable holding the C/C++ source code, and eventually stripped_code will hold C/C++ code with the comments removed.", "Of course, if you have the file on disk, you could have the input and output variables be file handles pointing to those files (input in read-mode, output in write-mode).", "remccoms3.sed is the file from the above link, and it should be saved in a readable location on disk.", "sed is also available on Windows, and comes installed by default on most GNU/Linux distros and Mac OS X."], "childNum": 8, "tag": "p", "senID": 2, "childList": [{"text": "source_code", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "stripped_code", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "input", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "output", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "input", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "output", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "remccoms3.sed", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "sed", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["This will probably be better than a pure Python solution; no need to reinvent the wheel."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Don't forget that in C, backslash-newline is eliminated before comments are processed, and trigraphs are processed before that (because ?", "?/ is the trigraph for backslash).", "I have a C program called SCC (strip C/C++ comments), and here is part of the test code..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \" */ /* SCC has been trained to know about strings /* */ */\"!\n\"\\\"Double quotes embedded in strings, \\\\\\\" too\\'!\"\n\"And \\\nnewlines in them\"\n\n\"And escaped double quotes at the end of a string\\\"\"\n\naa '\\\\\nn' OK\naa \"\\\"\"\naa \"\\\n\\n\"\n\nThis is followed by C++/C99 comment number 1.\n// C++/C99 comment with \\\ncontinuation character \\\non three source lines (this should not be seen with the -C fla\nThe C++/C99 comment number 1 has finished.\n\nThis is followed by C++/C99 comment number 2.\n/\\\n/\\\nC++/C99 comment (this should not be seen with the -C flag)\nThe C++/C99 comment number 2 has finished.\n\nThis is followed by regular C comment number 1.\n/\\\n*\\\nRegular\ncomment\n*\\\n/\nThe regular C comment number 1 has finished.\n\n/\\\n\\/ This is not a C++/C99 comment!\n\nThis is followed by C++/C99 comment number 3.\n/\\\n\\\n\\\n/ But this is a C++/C99 comment!\nThe C++/C99 comment number 3 has finished.\n\n/\\\n\\* This is not a C or C++  comment!\n\nThis is followed by regular C comment number 2.\n/\\\n*/ This is a regular C comment *\\\nbut this is just a routine continuation *\\\nand that was not the end either - but this is *\\\n\\\n/\nThe regular C comment number 2 has finished.\n\nThis is followed by regular C comment number 3.\n/\\\n\\\n\\\n\\\n* C comment */\n</code>\n</pre>\n", "senID": 1}, {"text": ["This does not illustrate trigraphs.", "Note that you can have multiple backslashes at the end of a line, but the line splicing doesn't care about how many there are, but the subsequent processing might.", "Etc.", "Writing a single regex to handle all these cases will be non-trivial (but that is different from impossible)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The regular expression cases will fall down in some situations, like where a string literal contains a subsequence which matches the comment syntax.", "You really need a parse tree to deal with this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["you may be able to leverage py++ to parse the C++ source with GCC."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "py++", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.language-binding.net/pyplusplus/pyplusplus.html"}]}, {"text": ["or, maybe not.", "regardless, this is not a trivial parse."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["@ RE based solutions - you are unlikely to find a RE that handles all possible 'awkward' cases correctly, unless you constrain input (e.g.", "no macros).", "for a bulletproof solution, you really have no choice than leveraging the real grammar."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You may find some of the discussion in this Q &amp; A helpful and especially this particular reply (mainly from the standpoint of pitfalls to watch out for). "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "this Q &amp; A", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/54047/regexs-for-developers"}, {"href": "http://stackoverflow.com/questions/54047/regexs-for-developers#54056", "text": "reply", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["You don't really need a parse tree to do this perfectly, but you do in effect need the token stream equivalent to what is produced by the compiler's front end.", "Such a token stream must necessarilyy take care of all the weirdness such as line-continued comment start, comment start in string, trigraph normalization, etc.", "If you have the token stream, deleting the comments is easy.", "(I have a tool that produces exactly such token streams, as, guess what, the front end of a real parser that produces a real parse tree :).  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The fact that the tokens are individually recognized by regular expressions suggests that you can, in principle, write a regular expression that will pick out the comment lexemes.", "The real complexity of the set regular expressions for the tokenizer (at least the one we wrote) suggests you can't do this in practice; writing them individually was hard enough.", "If you don't want to do it perfectly, well, then, most of the RE solutions above are just fine."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Now, why you would want strip comments is beyond me, unless you are building a code obfuscator.", "In this case, you have to have it perfectly right."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "why", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["I'm sorry this not a Python solution, but you could also use a tool that understands how to remove comments, like your C/C++ preprocessor.", "Here's how GNU CPP does it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "does it", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://gcc.gnu.org/onlinedocs/cpp/Invocation.html#index-fpreprocessed-171"}]}, {"code": "<pre>\n<code>\n cpp -fpreprocessed foo.c\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There is also a non-python answer: use the program stripcmt:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "stripcmt", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.bdc.cx/software/stripcmt/"}]}], [{"text": ["I ran across this problem recently when I took a class where the professor required us to strip javadoc from our source code before submitting it to him for a code review.", "We had to do this several times, but we couldn't just remove the javadoc permanently because we were required to generate javadoc html files as well.", "Here is a little python script I made to do the trick.", "Since javadoc starts with /** and ends with */, the script looks for these tokens, but the script can be modified to suite your needs.", "It also handles single line block comments and cases where a block comment ends but there is still non-commented code on the same line as the block comment ending.", "I hope this helps!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["WARNING: This scripts modifies the contents of files passed in and saves them to the original files.", "It would be wise to have a backup somewhere else"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "WARNING: This scripts modifies the contents of files passed in and saves them to the original files.  It would be wise to have a backup somewhere else", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n\"\"\"\n A simple script to remove block comments of the form /** */ from files\n Use example: ./strip_comments.py *.java\n Author: holdtotherod\n Created: 3/6/11\n\"\"\"\nimport sys\nimport fileinput\n\nfor file in sys.argv[1:]:\n    inBlockComment = False\n    for line in fileinput.input(file, inplace = 1):\n        if \"/**\" in line:\n            inBlockComment = True\n        if inBlockComment and \"*/\" in line:\n            inBlockComment = False\n            # If the */ isn't last, remove through the */\n            if line.find(\"*/\") != len(line) - 3:\n                line = line[line.find(\"*/\")+2:]\n            else:\n                continue\n        if inBlockComment:\n            continue\n        sys.stdout.write(line)\n</code>\n</pre>\n", "senID": 2}]]