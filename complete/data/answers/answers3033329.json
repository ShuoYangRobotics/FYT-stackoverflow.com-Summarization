[[{"text": ["Python is a higher level language than C, which means it abstracts the details of the computer from you - memory management, pointers, etc, and allows you to write programs in a way which is closer to how humans think."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It is true that C code usually runs 10 to 100 times faster than Python code if you measure only the execution time.", "However if you also include the development time Python often beats C. For many projects the development time is far more critical than the run time performance.", "Longer development time converts directly into extra costs, fewer features and slower time to market."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Internally the reason that Python code executes more slowly is because code is interpreted at runtime instead of being compiled to native code at compile time."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Other interpreted languages such as Java bytecode and .NET bytecode run faster than Python because the standard distributions include a JIT compiler that compiles bytecode to native code at runtime.", "The reason why CPython doesn't have a JIT compiler already is because the dynamic nature of Python makes it difficult to write one.", "There is work in progress to write a faster Python runtime so you should expect the performance gap to be reduced in the future, but it will probably be a while before the standard Python distribution includes a powerful JIT compiler. "], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "JIT compiler", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Just-in-time_compilation"}, {"text": "work", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://codespeak.net/pypy/dist/pypy/doc/"}, {"href": "http://code.google.com/p/unladen-swallow/", "text": "progress", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["CPython is particularly slow because it has no Just in Time optimizer (since it's the reference implementation and chooses simplicity over performance in certain cases).", "Unladen Swallow is a project to add an LLVM-backed JIT into CPython, and achieves massive speedups.", "It's possible that Jython and IronPython are much faster than CPython as well as they are backed by heavily optimized virtual machines (JVM and .NET CLR)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Unladen Swallow", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Unladen_Swallow"}]}, {"text": ["One thing that will arguably leave Python slower however, is that it's dynamically typed, and there is tons of lookup for each attribute access."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For instance calling f on an object A will cause possible lookups in __dict__, calls to  __getattr__, etc, then finally call __call__ on the callable object f."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "f", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "A", "childNum": 0, "tag": "code", "childList": []}, {"text": "__dict__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__getattr__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__call__", "childNum": 0, "tag": "code", "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["With respect to dynamic typing, there are many optimizations that can be done if you know what type of data you are dealing with.", "For example in Java or C, if you have a straight array of integers you want to sum, the final assembly code can be as simple as fetching the value at the index i, adding it to the accumulator, and then incrementing i."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "i", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "accumulator", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "i", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In Python, this is very hard to make code this optimal.", "Say you have a list subclass object containing ints.", "Before even adding any, Python must call list.__getitem__(i), then add that to the \"accumulator\" by calling accumulator.__add__(n), then repeat.", "Tons of alternative lookups can happen here because another thread may have altered for example the __getitem__ method, the dict of the list instance, or the dict of the class, between calls to add or getitem.", "Even finding the accumulator and list (and any variable you're using) in the local namespace causes a dict lookup.", "This same overhead applies when using any user defined object, although for some built-in types, it's somewhat mitigated."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "list.__getitem__(i)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "accumulator.__add__(n)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__getitem__", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["It's also worth noting, that the primitive types such as bigint (int in Python 3, long in Python 2.x), list, set, dict, etc, etc, are what people use a lot in Python.", "There are tons of built in operations on these objects that are already optimized enough.", "For example, for the example above, you'd just call sum(list) instead of using an accumulator and index.", "Sticking to these, and a bit of number crunching with int/float/complex, you will generally not have speed issues, and if you do, there is probably a small time critical unit (a SHA2 digest function, for example) that you can simply move out to C (or Java code, in Jython).", "The fact is, that when you code C or C++, you are going to waste lots of time doing things that you can do in a few seconds/lines of Python code.", "I'd say the tradeoff is always worth it except for cases where you are doing something like embedded or real time programming and can't afford it."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "sum(list)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "lots", "childNum": 0, "tag": "strong", "pos": 4, "childList": []}]}], [{"text": ["The difference between python and C is the usual difference between an interpreted (bytecode) and compiled (to native) language.", "Personally, I don't really see python as slow, it manages just fine.", "If you try to use it outside of its realm, of course, it will be slower.", "But for that, you can write C extensions for python, which puts time-critical algorithms in native code, making it way faster."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Compilation vs interpretation isn't important here: Python is compiled, and it's a tiny part of the runtime cost for any non-trivial program."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "is", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["The primary costs are: the lack of an integer type which corresponds to native integers (making all integer operations vastly more expensive), the lack of static typing (which makes resolution of methods more difficult, and means that the types of values must be checked at runtime), and the lack of unboxed values (which reduce memory usage, and can avoid a level of indirection)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Not that any of these things aren't possible or can't be made more efficient in Python, but the choice has been made to favor programmer convenience and flexibility, and language cleanness over runtime speed.", "Some of these costs may be overcome by clever JIT compilation, but the benefits Python provides will always come at some cost."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Comparing C/C++ to Python is not a fair comparison.", "Like comparing a F1 race car with a utility truck. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What is surprising is how fast Python is in comparison to its peers of other dynamic languages.", "While the methodology is often considered flawed, look at The Computer Language Benchmark Game to see relative language speed on similar algorithms."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "The Computer Language Benchmark Game", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://shootout.alioth.debian.org/u32q/python3.php"}]}, {"text": ["The comparison to Perl, Ruby, and C# are more 'fair'"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Python is typically implemented as a scripting language.", "That means it goes through an interpreter which means it translates code on the fly to the machine language rather than having the executable all in machine language from the beginning.", "As a result, it has to pay the cost of translating code in addition to executing it.", "This is true even of CPython even though it compiles to bytecode which is closer to the machine language and therefore can be translated faster.", "With Python also comes some very useful runtime features like dynamic typing, but such things typically cannot be implemented even on the most efficient implementations without heavy runtime costs."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you are doing very processor-intensive work like writing shaders, it's not uncommon for Python to be somewhere around 200 times slower than C++.", "If you use CPython, that time can be cut in half but it's still nowhere near as fast.", "With all those runtmie goodies comes a price.", "There are plenty of benchmarks to show this and here's a particularly good one.", "As admitted on the front page, the benchmarks are flawed.", "They are all submitted by users trying their best to write efficient code in the language of their choice, but it gives you a good general idea."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "here's", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://shootout.alioth.debian.org/"}]}, {"text": ["I recommend you try mixing the two together if you are concerned about efficiency: then you can get the best of both worlds.", "I'm primarily a C++ programmer but I think a lot of people tend to code too much of the mundane, high-level code in C++ when it's just a nuisance to do so (compile times as just one example).", "Mixing a scripting language with an efficient language like C/C++ which is closer to the metal is really the way to go to balance programmer efficiency (productivity) with processing efficiency."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["C and C++ compile to native code- that is, they run directly on the CPU.", "Python is an interpreted language, which means that the Python code you write must go through many, many stages of abstraction before it can become executable machine code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Other than the answers already posted, one thing is pythons ability to change things in runtime that you can't change in for example C. You can add member functions to classes as you go.", "Also, pythons dynamic nature makes it impossible to say what type of parameters will be passed to a function, which in turn makes optimizing a whole lot harder."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["RPython seems to be a way of getting around the optimization problem."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "RPython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/rpython/"}]}, {"text": ["Still, it'll probably won't be near the performance of C for numbercrunching and the like."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]