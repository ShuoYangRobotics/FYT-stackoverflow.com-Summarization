[[{"text": ["No fear of creating new classes -\nYou can take advantage of Python's string formating capabilities\nand simply do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MyDict(dict):\n   def __getitem__(self, item):\n       return dict.__getitem__(self, item) % self\n\ndictionary = MyDict({\n\n    'user' : 'gnucom',\n    'home' : '/home/%(user)s',\n    'bin' : '%(home)s/bin' \n})\n\n\nprint dictionary[\"home\"]\nprint dictionary[\"bin\"]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; dictionary = {\n... 'a':'123'\n... }\n&gt;&gt;&gt; dictionary['b'] = dictionary['a'] + '456'\n&gt;&gt;&gt; dictionary\n{'a': '123', 'b': '123456'}\n</code>\n</pre>\n", "senID": 0}, {"text": ["It works fine but when you're trying to use dictionary it hasn't been defined yet (because it has to evaluate that literal dictionary first)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "dictionary", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["But be careful because this assigns to the key of 'b' the value referenced by the key of 'a' at the time of assignment and is not going to do the lookup every time.", "If that is what you are looking for, it's possible but with more work."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "'b'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'a'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "at the time of assignment", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}], [{"text": ["This is an interesting problem.", "It seems like Greg has a good solution.", "But that's no fun ;)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "good solution", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3738381/what-do-i-do-when-i-need-a-self-referential-dictionary/3740202#3740202"}]}, {"text": ["jsbueno as a very elegant solution but that only applies to strings (as you requested)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "very elegant solution", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3738381/what-do-i-do-when-i-need-a-self-referential-dictionary/3740096#3740096"}]}, {"text": ["The trick to a 'general' self referential dictionary is to use a surrogate object.", "It takes a few (understatement) lines of code to pull off, but the usage is about what you want:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n S = SurrogateDict(AdditionSurrogateDictEntry)\nd = S.resolve({'user': 'gnucom',\n               'home': '/home/' + S['user'],\n               'config': [S['home'] + '/.emacs', S['home'] + '/.bashrc']})\n</code>\n</pre>\n", "senID": 3}, {"text": ["The code to make that happen is not nearly so short.", "It lives in three classes:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import abc\n\nclass SurrogateDictEntry(object):\n    __metaclass__ = abc.ABCMeta\n    def __init__(self, key):\n        \"\"\"record the key on the real dictionary that this will resolve to a \n           value for\n        \"\"\"\n        self.key = key\n\n    def resolve(self, d):\n        \"\"\" return the actual value\"\"\"\n        if hasattr(self, 'op'):\n            # any operation done on self will store it's name in self.op. \n            # if this is set, resolve it by calling the appropriate method \n            # now that we can get self.value out of d\n            self.value = d[self.key]\n            return getattr(self, self.op + 'resolve__')()\n        else:\n            return d[self.key]\n\n    @staticmethod\n    def make_op(opname):\n        \"\"\"A convience class. This will be the form of all op hooks for subclasses\n           The actual logic for the op is in __op__resolve__ (e.g. __add__resolve__)\n        \"\"\"\n        def op(self, other):\n            self.stored_value = other\n            self.op = opname\n            return self\n        op.__name__ = opname\n        return op\n</code>\n</pre>\n", "senID": 5}, {"text": ["Next, comes the concrete class.", "simple enough."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n class AdditionSurrogateDictEntry(SurrogateDictEntry):\n\n    __add__ = SurrogateDictEntry.make_op('__add__')\n    __radd__ = SurrogateDictEntry.make_op('__radd__')\n\n    def __add__resolve__(self):\n        return self.value + self.stored_value \n\n    def __radd__resolve__(self):\n        return self.stored_value + self.value\n</code>\n</pre>\n", "senID": 7}, {"text": ["Here's the final class"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n class SurrogateDict(object):\n    def __init__(self, EntryClass):\n        self.EntryClass = EntryClass\n\n    def __getitem__(self, key):\n        \"\"\"record the key and return\"\"\" \n        return self.EntryClass(key)\n\n    @staticmethod\n    def resolve(d):\n        \"\"\"I eat generators resolve self references\"\"\"\n        stack = [d]\n        while stack:\n            cur = stack.pop()\n            # This just tries to set it to an appropriate iterable\n            it = xrange(len(cur)) if not hasattr(cur, 'keys') else cur.keys()\n            for key in it:\n                # sorry for being a duche. Just register your class with\n                # SurrogateDictEntry and you can pass whatever.\n                while isinstance(cur[key], SurrogateDictEntry):\n                    cur[key] = cur[key].resolve(d)\n                # I'm just going to check for iter but you can add other\n                # checks here for items that we should loop over. \n                if hasattr(cur[key], '__iter__'):\n                    stack.append(cur[key])\n        return d\n</code>\n</pre>\n", "senID": 9}, {"text": ["In response to gnucoms's question about why I named the classes the way that I did. "], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["The word surrogate is generally associated with standing in for something else so it seemed appropriate because that's what the SurrogateDict class does: an instance replaces the 'self' references in a dictionary literal.", "That being said, (other than just being straight up stupid sometimes) naming is probably one of the hardest things for me about coding.", "If you (or anyone else) can suggest a better name, I'm all ears."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "SurrogateDict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I'll provide a brief explanation.", "Throughout S refers to an instance of SurrogateDict and d is the real dictionary."], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "S", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "d", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["That'a a rough sketch.", "If you have any more questions, feel free to ask."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["What you're describing in your edit is how an INI config file works.", "Python does have a built in library called ConfigParser which should work for what you're describing."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ConfigParser", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/configparser.html"}]}], [{"text": ["Nearest I came up without doing object:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dictionary = {\n    'user' : 'gnucom',\n    'home' : lambda:'/home/'+dictionary['user'] \n}\n\nprint dictionary['home']()\ndictionary['user']='tony'\nprint dictionary['home']()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Write a class, maybe something with properties:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class PathInfo(object):\n    def __init__(self, user):\n        self.user = user\n\n    @property\n    def home(self):\n        return '/home/' + self.user\n\np = PathInfo('thc')\nprint p.home # /home/thc\n</code>\n</pre>\n", "senID": 1}], [{"text": ["As sort of an extended version of @Tony's answer, you could build a dictionary subclass that calls its values if they are callables:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@Tony's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3738381/what-do-i-do-when-i-need-a-self-referential-dictionary#answer-3739894"}]}, {"code": "<pre>\n<code>\n class CallingDict(dict):\n    \"\"\"Returns the result rather than the value of referenced callables.\n\n    &gt;&gt;&gt; cd = CallingDict({1: \"One\", 2: \"Two\", 'fsh': \"Fish\",\n    ...                   \"rhyme\": lambda d: ' '.join((d[1], d['fsh'],\n    ...                                                d[2], d['fsh']))})\n    &gt;&gt;&gt; cd[\"rhyme\"]\n    'One Fish Two Fish'\n    &gt;&gt;&gt; cd[1] = 'Red'\n    &gt;&gt;&gt; cd[2] = 'Blue'\n    &gt;&gt;&gt; cd[\"rhyme\"]\n    'Red Fish Blue Fish'\n    \"\"\"\n    def __getitem__(self, item):\n        it = super(CallingDict, self).__getitem__(item)\n        if callable(it):\n            return it(self)\n        else:\n            return it\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course this would only be usable if you're not actually going to store callables as values.", "If you need to be able to do that, you could wrap the lambda declaration in a function that adds some attribute to the resulting lambda, and check for it in CallingDict.__getitem__, but at that point it's getting complex, and long-winded, enough that it might just be easier to use a class for your data in the first place."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "CallingDict.__getitem__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]