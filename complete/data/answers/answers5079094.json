[[{"text": ["You can (and should) use list comprehension:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "list comprehension", "tag": "a", "pos": 0, "childList": [{"text": "list comprehension", "tag": "strong"}], "childNum": 1, "href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions"}, {"text": "list comprehension", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n squared = [x**2 for x in lst]\n</code>\n</pre>\n", "senID": 1}, {"text": ["map makes one function call per element and while lambda expressions are quite handy, using map + lambda is mostly slower than list comprehension."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Python Patterns - An Optimization Anecdote is worth a read."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Python Patterns - An Optimization Anecdote", "tag": "a", "pos": 0, "childList": [{"text": "Python Patterns - An Optimization Anecdote", "tag": "em"}], "childNum": 1, "href": "http://www.python.org/doc/essays/list2str.html"}, {"text": "Python Patterns - An Optimization Anecdote", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["Besides lambda and list comprehensions, you can also use generators.", "List comprehension calculates all the squares when it's called, generators calculate each square as you iterate through the list.", "Generators are better when input size is large or when you're only using some initial part of the results."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def generate_squares(a):\n    for x in a:\n        yield x**2 \n\n# this is equivalent to above\nb = (x**2 for x in a)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n squared = lambda li: map(lambda x: x*x, li)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You should know about map built-in which takes a function as the first argument and an iterable as the second and returns a list consisting of items acted upon by the function.", "For e.g."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def sqr(x):\n...     return x*x\n... \n&gt;&gt;&gt; map(sqr,range(1,10))\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["There is a better way of writing the sqr function above, namely using the nameless lambda having quirky syntax.", "(Beginners get confused looking for return stmt)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; map(lambda x: x*x,range(1,10))\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Apart from that you can use list comprehension too."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n result = [x*x for x in range(1,10)]\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n a = [1, 2, 3]\nb = [x ** 2 for x in a]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["good remark of kefeizhou, but then there is no need of a generator function, a generator expression is right:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for sq in (x*x for x in li):\n   # do\n</code>\n</pre>\n", "senID": 1}]]