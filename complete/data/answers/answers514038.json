[[{"text": ["Pretty much all ML-influenced functional langues (which is most of them) also have great tuple support that makes this sort of thing trivial."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For C++ I like boost::tuple plus boost::tie (or std::tr1 if you have it)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n typedef boost::tuple&lt;double,double,double&gt; XYZ;\n\nXYZ foo();\n\ndouble x,y,z;\nboost::tie(x,y,z) = foo();\n</code>\n</pre>\n", "senID": 2}, {"text": ["or a less contrived example"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n MyMultimap::iterator lower,upper;\nboost::tie(lower,upper) = some_map.equal_range(key);\n</code>\n</pre>\n", "senID": 4}], [{"text": ["A few languages, notably Lisp and JavaScript, have a feature called destructuring assignment or destructuring bind.", "This is essentially tuple unpacking on steroids: rather than being limited to sequences like tuples, lists, or generators, you can unpack more complex object structures in an assignment statement.", "For more details, see here for the Lisp version or here for the (rather more readable) JavaScript version."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "here for the Lisp version", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/mac_destructuring-bind.html"}, {"href": "https://developer.mozilla.org/en/New_in_JavaScript_1.7#Destructuring_assignment", "text": "here for the (rather more readable) JavaScript version", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Other than that, I don't know of many language features for dealing with multiple return values generally.", "However, there are a few specific uses of multiple return values that can often be replaced by other language features.", "For example, if one of the values is an error code, it might be better replaced with an exception."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["While creating new classes to hold multiple return values feels like clutter, the fact that you're returning those values together is often a sign that your code will be better overall once the class is created.", "In particular, other functions that deal with the same data can then move to the new class, which may make your code easier to follow.", "This isn't universally true, but it's worth considering.", "(Cpeterso's answer about data clumps expresses this in more detail)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If a function returns multiple values, that is a sign you might be witnessing the \"Data Clump\" code smell.", "Often data clumps are primitive values that nobody thinks to turn into an object, but interesting stuff happens as you begin to look for behavior to move into the new objects."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\"Data Clump\" code smell", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.martinfowler.com/bliki/DataClump.html"}]}, {"text": ["Writing tiny helper classes might be extra typing, but it provides clear names and strong type checking.", "Developers maintaining your code will appreciate it.", "And useful small classes often grow up to be used in other code."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Also, if a function returns multiple values, then it might be doing too much work.", "Could the function be refactored into two (or more) small functions?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["PHP example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n function my_funct() {\n    $x = \"hello\";\n    $y = \"world\";\n    return array($x, $y);\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then, when run:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n list($x, $y) = my_funct();\necho $x.' '.$y; // \"hello world\"\n</code>\n</pre>\n", "senID": 3}], [{"text": ["As for Java, see Bruce Eckel's Thinking in Java for a nice solution (pp.", "621 ff)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Thinking in Java", "tag": "a", "pos": 0, "childList": [{"text": "Thinking in Java", "tag": "em"}], "childNum": 1, "href": "http://rads.stackoverflow.com/amzn/click/0131872486"}, {"text": "Thinking in Java", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["In essence, you can define a class equivalent to the following:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n public class Pair&lt;T,U&gt; {\n    public final T left;\n    public final U right;\n    public Pair (T t, U u) { left = t; right = u; }\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can then use this as the return type for a function, with appropriate type parameters:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n public Pair&lt;String,Integer&gt; getAnswer() {\n    return new Pair&lt;String,Integer&gt;(\"the universe\", 42);\n}\n</code>\n</pre>\n", "senID": 4}, {"text": ["After invoking that function:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n Pair&lt;String,Integer&gt; myPair = getAnswer();\n</code>\n</pre>\n", "senID": 6}, {"text": ["you can refer to myPair.left and myPair.right for access to the constituent values."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "myPair.left", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "myPair.right", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["There are other syntactical sugar options, but the above is the key point."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Nobody seems to have mentioned Perl yet."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sub myfunc {\n  return 1, 2;\n}\nmy($val1, $val2) = myfunc();\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Even if you ignore the wonderful newer destructuring assignment Moss Collum mentioned, JavaScript is pretty nice on returning multiple results."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Moss Collum mentioned", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/514038/elegant-ways-to-return-multiple-values-from-a-function/514114#514114"}]}, {"code": "<pre>\n<code>\n function give7and5() {\n  return {x:7,y:5};\n}\n\na=give7and5();\nconsole.log(a.x,a.y);\n\n7  5\n</code>\n</pre>\n", "senID": 1}], [{"text": ["i thinks python's is the most natural way, when I had to do same thing in php the only was to wrap return into an array.", "it does have similar unpacking though."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Both Lua and CLU (by Barbara Liskov's group at MIT) have multiple return values for all functions---it is always the default.", "I believe the designers of Lua were inspired by CLU.", "I like having multiple values be the default for calls and returns; I think it is a very elegant way of thinking about things.", "In Lua and CLU this mechanism is completely independent of tuples and/or records."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Lua", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.lua.org/"}]}, {"text": ["The portable assembly language C-- supports multiple return values for its native calling convention but not for the C calling convention.", "There the idea is to enable a compiler writer to return multiple values in individual hardware registers rather than having to put the values in a clump in memory and return a pointer to that clump (or as in C, have the caller pass a pointer to an empty clump)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "C--", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cminusminus.org/"}]}, {"text": ["Like any mechanism, multiple return values can be abused, but I don't think it is any more unreasonable to have a function return multiple values than it is to have a struct contain multiple values."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Often in php I'll use a referenced input:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n public function Validates(&amp;$errors=array()) {\n   if($failstest) {\n      $errors[] = \"It failed\";\n      return false;\n   } else {\n      return true;\n   }\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["That gives me the error messages I want without polluting the bool return, so I can still do:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if($this-&gt;Validates()) ...\n</code>\n</pre>\n", "senID": 3}], [{"text": ["In C++ you can pass a container into the function so the function can fill it:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "C++", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n void getValues(std::vector&lt;int&gt;* result){\n  result-&gt;push_back(2);\n  result-&gt;push_back(6);\n  result-&gt;push_back(73);\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could also have the function return a smart pointer (use shared_ptr) to a vector:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "shared_ptr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "vector", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n boost::shared_ptr&lt; std::vector&lt;int&gt; &gt; getValues(){\n  boost::shared_ptr&lt; std::vector&lt;int&gt; &gt; vec(new std::vector&lt;int&gt;(3));\n  (*vec)[0] = 2;\n  (*vec)[1] = 6;\n  (*vec)[2] = 73;\n  return vec; \n}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["c#"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n public struct tStruct\n{\n    int x;\n    int y;\n    string text;\n    public tStruct(int nx, int ny, string stext)\n    {\n         this.x = nx;\n         this.y = ny;\n         this.text = stext;\n    }\n}\n\npublic tStruct YourFunction()\n{\n    return new tStruct(50, 100, \"hello world\");\n}\n\npublic void YourPrintFunction(string sMessage)\n{\n    Console.WriteLine(sMessage);\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["in Lua you call"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n MyVar = YourFunction();\nYourPrintfFunction(MyVar.x);\nYourPrintfFunction(MyVar.y);\nYourPrintfFunction(MyVar.text);\n</code>\n</pre>\n", "senID": 3}, {"text": ["Output:\n50\n100\nhello world"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Paul"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["By the way, Scala can return multiple values as follows (pasted from an interpreter session):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n scala&gt; def return2 = (1,2)\nreturn2: (Int, Int)\n\nscala&gt; val (a1,a2) = return2\na1: Int = 1\na2: Int = 2\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is a special case of using pattern matching for assignment."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "pattern matching for assignment", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.nearinfinity.com/blogs/bryan_weber/scala_pattern_matching.html"}]}]]