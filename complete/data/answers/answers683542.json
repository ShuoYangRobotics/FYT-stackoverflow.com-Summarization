[[{"text": ["So simple:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def DestinationThread( a ) :\n  while True :\n    items = q.get()\n    func = items[0]\n    args = items[1:]\n    func(*args)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n from Queue import *\nfrom thread import *\nfrom time import *\n\nq = Queue()\n\ndef HandleMsg( arg1, arg2 ) :\n  print arg1, arg2\n\ndef HandleAnotherMsg( arg1, arg2, arg3 ) :\n  print arg1, arg2, arg3\n\ndef DestinationThread() :\n  while True :\n    f, args = q.get()\n    f(*args)\n\nstart_new_thread( DestinationThread, tuple() )\nprint \"start\"\nsleep( 1 )\nq.put( (HandleMsg, [1, 2]) )\nsleep( 1 )\nq.put( (HandleAnotherMsg, [1, 2, 3]) )\nsleep( 1 )\nprint \"stop\"\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Another interesting option is simply to pass in a lambda."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n q.put(lambda: HandleMsg(1,2))\nq.put(lambda: HandleAnother(8, \"hello\", extra=\"foo\"))\n\ndef DestinationThread() :\n   while True :\n      f = q.get()\n      f()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It sounds like you want  to use the apply() intrinsic or its successor:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["def f(x. y):\n   print x+y"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["args = ( 1, 2 )"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["apply(f, args)   # old way"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["f(*args)        # new way"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I've used a similar construct before:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Call:\n    def __init__(self, fn, *args, **kwargs):\n        self.fn = fn\n        self.args = args\n        self.kwargs = kwargs\n\n    def __call__(self):\n        return self.fn(*self.args, **self.kwargs)\n\n\nx = Call(zip, [0,1], [2,3], [4,5])\n</code>\n</pre>\n", "senID": 1}, {"text": ["You should then be able to pass x to your other thread and call it from there:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n x() # returns the same as zip([0,1], [2,3], [4,5])\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You can create an abstract message class with a run method.", "Then for each function that need to be transmitted via the queue, subclass and implement the function as the run method.", "The sending thread will create an instance of the proper sub class and put it into the queue.", "The receiving thread will get an object from the queue and blindly execute the run mehtod."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is usually called the Command pattern (Gamma et al."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Message (object):\n    \"\"\"abstract message class\"\"\"\n    def __init__(self, **kwargs):\n        self.kwargs = kwargs\n\n    def run(self):\n        pass\n\n\nclass MessageOne (Message):\n    \"\"\"one message class\"\"\"\n    def run(self):\n         # perform this emssage's action using the kwargs\n</code>\n</pre>\n", "senID": 3}, {"text": ["The sender will instantiate and send a message:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n queue.put(MessageOne(one='Eins', two='Deux'))\n</code>\n</pre>\n", "senID": 5}, {"text": ["The receiver simply gets a message object and execute it run method (without having to it..else.. thru the available types of messages):"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n msg = queue.get()\nmsg.run()\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Why don't you subclass Queue?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MyQueue(Queue):\n  # by using *args, you can have a variable number of arguments\n  def put(self,*args):\n    for arg in args:\n       Queue.put(self,arg)\n</code>\n</pre>\n", "senID": 1}, {"text": ["or, why don't you put a list?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n list = [function_obj]\nfor arg in function_args:\n   list.append(arg)\nqueue.put(list)\n</code>\n</pre>\n", "senID": 3}]]