[[{"text": ["You can use lookahead assertions with capturing groups to find matches in any order:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "lookahead assertions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.regular-expressions.info/lookaround.html"}]}, {"code": "<pre>\n<code>\n import re\ndef matchany(subject):\n    match = re.match(\n        r\"\"\"\n        (?=.*\\(([^()]*)\\))   # Find match between () --&gt; group 1\n        (?=.*\\{([^{}]*)\\})   # Find match between {} --&gt; group 2\n        (?=.*!([^!]*)!)      # Find match between !! --&gt; group 3\"\"\", \n        subject, re.VERBOSE)\n    return match.groups() if match else None\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you can do"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; matchany(\"STRING[(val1)-{val2}-!val3!]\")\n('val1', 'val2', 'val3')\n&gt;&gt;&gt; matchany(\"STRING[!val3!-(val1)-{val2}]\")\n('val1', 'val2', 'val3')\n&gt;&gt;&gt; matchany(\"STRING[(val1)-{val2}-!val3]\")\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}], [{"text": ["To get a truly complete answer, you should clarify further what are the possible input strings, and what is the format of the string to match.", "However this is an example illustrating at least the basic matching mechanism with re.findall"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "re.findall", "tag": "a", "pos": 1, "childList": [{"text": "re.findall", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/re.html#re.findall"}, {"text": "re.findall", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; examples = '''STRING[(val1)-{val2}-!val3!]\n... STRING[{val2}-!val3!-(val1)]\n... STRING[!val3!-(val1)-{val2}]\n... '''\n&gt;&gt;&gt; for line in examples.split('\\n'):\n...     print re.findall(r'val\\d', 'STRING[(val1)-{val2}-!val3!]')\n... \n['val1', 'val2', 'val3']\n['val1', 'val2', 'val3']\n['val1', 'val2', 'val3']\n['val1', 'val2', 'val3']\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: the regex r'val\\d' instructs to match all those bits that are formed by the letters val + one, and only one digit."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "r'val\\d'", "childNum": 0, "tag": "code", "childList": []}, {"text": "val", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["HTH!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Do you really need regex ?", "Based on your input, the - is looking as a seperator so:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = \"STRING[(val1)-{val2}-!val3!]\"\n\n# First step, remove the \"STRING[\" + \"]\" from the source string\n&gt;&gt;&gt; s = s[7:-1]\n&gt;&gt;&gt; print s\n(val1)-{val2}-!val3!\n\n# Then, split on the '-', and remove the first/last char (mean []!! etc..)\n# Work with any other values if they don't have '-' in it\n&gt;&gt;&gt; [x[1:-1] for x in s.split('-')]\n['val1', 'val2', 'val3']\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import re\n\nregx = re.compile('(?&lt;=[\\[-])[!({](.+?)[!)}](?=[\\]-])')\n\nfor ss  in ('STRING[(val1)-{val2}-!val3!]',\n            'STRING[{val2}-!val3!-(val1)]',\n            'STRING[!val3!-(val1)-{val2}]',\n            'STRING[!val3!-!val1!-{val2}]'):\n    print regx.findall(ss)\n</code>\n</pre>\n", "senID": 0}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n ['val1', 'val2', 'val3']\n['val2', 'val3', 'val1']\n['val3', 'val1', 'val2']\n['val3', 'val1', 'val2']\n</code>\n</pre>\n", "senID": 2}, {"text": ["But the exploited string must strictly respect the pattern: without whitespaces, no one of the  charcaters !", "( { } ) followed or preceded by [ or - in the desired values (if not so preceded or followed , the assertions in my pattern take the cases correctly), etc\nIf necessary, the regex pattern could be improved"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["Edit"], "childNum": 0, "tag": "h2", "senID": 4, "childList": []}, {"text": ["I improved the pattern in order that if a value is preceded by '!", "' , it ends with '!", "',\nif preceded by '(', it ends with ')',\nand if preceded by '{', it ends with '}'"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\nregx_1 = re.compile('(?&lt;=[\\[-])'\n                    '[!({]'\n                    '(.+?)'\n                    '[!)}]'\n                    '(?=[\\]-])')\n\nregx_2 = re.compile('(?&lt;=[\\[-])'\n                    '(?:'\n                        '(!)'\n                        '|'\n                        '(\\()'\n                        '|'\n                        '(\\{)'\n                    ')'\n                    '(.+?)'\n                    '(?(1)!|(?(2)\\)|(?(3)\\})))'\n                    '(?=[\\]\\-])'\n                    )\n\nfor ss  in ('STRING[(val1)-{val2}-!val3!]',\n            'STRING[{val2}-!val3!-(val1)]',\n            'STRING[!val3!-(val1)-{val2}]',\n            'STRING[!val3!-!val1!-{val2}]',\n            'STRING[!va}-l3!-!val)-1!-{va!-)-l2}]',):\n    print ('------------------------------\\n'\n           '%s\\n\\n%s\\n\\n%s\\n%s\\n') % (ss,\n                                      regx_1.findall(ss),\n                                      regx_2.findall(ss),\n                                      [ x[3] for x in regx_2.findall(ss)])\n</code>\n</pre>\n", "senID": 6}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n ------------------------------\nSTRING[(val1)-{val2}-!val3!]\n\n['val1', 'val2', 'val3']\n\n[('', '(', '', 'val1'), ('', '', '{', 'val2'), ('!', '', '', 'val3')]\n['val1', 'val2', 'val3']\n\n------------------------------\nSTRING[{val2}-!val3!-(val1)]\n\n['val2', 'val3', 'val1']\n\n[('', '', '{', 'val2'), ('!', '', '', 'val3'), ('', '(', '', 'val1')]\n['val2', 'val3', 'val1']\n\n------------------------------\nSTRING[!val3!-(val1)-{val2}]\n\n['val3', 'val1', 'val2']\n\n[('!', '', '', 'val3'), ('', '(', '', 'val1'), ('', '', '{', 'val2')]\n['val3', 'val1', 'val2']\n\n------------------------------\nSTRING[!val3!-!val1!-{val2}]\n\n['val3', 'val1', 'val2']\n\n[('!', '', '', 'val3'), ('!', '', '', 'val1'), ('', '', '{', 'val2')]\n['val3', 'val1', 'val2']\n\n------------------------------\nSTRING[!va}-l3!-!val)-1!-{va!-)-l2}]\n\n['va', 'val', 'va']\n\n[('!', '', '', 'va}-l3'), ('!', '', '', 'val)-1'), ('', '', '{', 'va!-)-l2')]\n['va}-l3', 'val)-1', 'va!-)-l2']\n</code>\n</pre>\n", "senID": 8}], [{"text": ["To parse your string into a dictionary with \"val1\", \"val2\", \"val3\" as keys and the found strings as corresponding values you could use something as the below code snippet."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dictionary", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\nexamples = '''STRING[!hello!-(world)-{zup}]\nSTRING[{foobar}-!stack!-(overflow)]\nSTRING[(this)-{might}-!work!]''';\n\nname_dict = {\n  '(': 'val1',\n  '{': 'val2',\n  '!': 'val3'\n}\n\nfor testcase in examples.split ('\\n'):\n  result = {}\n\n  for x in re.split ('[!)}]-', testcase[7:-2]):\n    result[name_dict[x[0]]] = x[1:]\n\n  print result\n</code>\n</pre>\n", "senID": 1}, {"text": ["output"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {'val3': 'hello', 'val2': 'zup', 'val1': 'world'}\n{'val3': 'stack', 'val2': 'foobar', 'val1': 'overflow'}\n{'val3': 'work', 'val2': 'might', 'val1': 'this'}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["with a regular expression."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["this example does not work if your values contain any of the characters used to form the end-of-value-frame '!", "', '}', or ')':"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import re\ns = 'your string here'\nval1, val2, val3 = re.sub(r'[!{(](?P&lt;value&gt;.+?)[!})](?P&lt;delimiter&gt;-)?', '\\g&lt;value&gt;\\g&lt;delimiter&gt;', s).split('-')\n</code>\n</pre>\n", "senID": 2}]]