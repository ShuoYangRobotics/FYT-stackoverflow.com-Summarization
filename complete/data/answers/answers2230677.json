[[{"text": ["Use xml.sax module.", "Build your own handler and inside startElement you should check, whether name is AssetType.", "This way you should be able to only act, when AssetType node is processed."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "xml.sax", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/xml.sax.html"}, {"text": "startElement", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/xml.sax.handler.html#xml.sax.handler.ContentHandler.startElement"}]}, {"text": ["Here you have example handler, which shows, how to build one (though it's not the most pretty way, at that point I didn't know all the cool tricks with Python ;-))."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/rpgdirector/source/browse/trunk/rpg/serialization/plans.py"}]}], [{"text": ["If you don't mind loading the whole document into memory:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from lxml import etree\ndata = etree.parse(fname)\nresult = [node.text.strip() \n    for node in data.xpath(\"//AssetType[@longname='characters']/type\")]\n</code>\n</pre>\n", "senID": 1}, {"text": ["You may need to remove the spaces at the beginning of your tags to make this work."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could use the pulldom API to handle parsing a large file, without loading it all into memory at once.", "This provides a more convenient interface than using SAX with only a slight loss of performance."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pulldom API", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/xml.dom.pulldom.html"}]}, {"text": ["It basically lets you stream the xml file until you find the bit you are interested in, then start using regular DOM operations after that."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "regular DOM operations", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/xml.dom.html"}]}, {"code": "<pre>\n<code>\n from xml.dom import pulldom\n\n# http://mail.python.org/pipermail/xml-sig/2005-March/011022.html\ndef getInnerText(oNode):\n    rc = \"\"\n    nodelist = oNode.childNodes\n    for node in nodelist:\n        if node.nodeType == node.TEXT_NODE:\n            rc = rc + node.data\n        elif node.nodeType==node.ELEMENT_NODE:\n            rc = rc + getInnerText(node)   # recursive !!!\n        elif node.nodeType==node.CDATA_SECTION_NODE:\n            rc = rc + node.data\n        else:\n            # node.nodeType: PROCESSING_INSTRUCTION_NODE, COMMENT_NODE, DOCUMENT_NODE, NOTATION_NODE and so on\n           pass\n    return rc\n\n\n# xml_file is either a filename or a file\nstream = pulldom.parse(xml_file) \nfor event, node in stream:\n    if event == \"START_ELEMENT\" and node.nodeName == \"AssetType\":\n        if node.getAttribute(\"longname\") == \"characters\":\n            stream.expandNode(node) # node now contains a mini-dom tree\n            type_nodes = node.getElementsByTagName('type')\n            for type_node in type_nodes:\n                # type_text will have the value of what's inside the type text\n                type_text = getInnerText(type_node)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Assuming your document is called assets.xml and has the following structure:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "assets.xml", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &lt;assets&gt;\n    &lt;AssetType&gt;\n        ...\n    &lt;/AssetType&gt;\n    &lt;AssetType&gt;\n        ...\n    &lt;/AssetType&gt;\n&lt;/assets&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you can do the following:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from xml.etree.ElementTree import ElementTree\ntree = ElementTree()\nroot = tree.parse(\"assets.xml\")\nfor assetType in root.findall(\"//AssetType[@longname='characters']\"):\n    for type in assetType.getchildren():\n        print type.text\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You could use xpath, something like \"//AssetType[longname='characters']/xyz\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For XPath libs in Python see http://www.somebits.com/weblog/tech/python/xpath.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.somebits.com/weblog/tech/python/xpath.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.somebits.com/weblog/tech/python/xpath.html"}]}], [{"text": ["Similar to eswald's solution, again stripping whitespace, again loading the document into memory, but returning the three text items at a time"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from lxml import etree\n\ndata = \"\"\"&lt;AssetType longname=\"characters\" shortname=\"chr\" shortnames=\"chrs\"\n  &lt;type&gt;\n    pub\n  &lt;/type&gt;\n  &lt;type&gt;\n    geo\n  &lt;/type&gt;\n  &lt;type&gt;\n    rig\n  &lt;/type&gt;\n&lt;/AssetType&gt;\n\"\"\"\n\ndoc = etree.XML(data)\n\nfor asset in doc.xpath('//AssetType[@longname=\"characters\"]'):\n  threetypes = [ x.strip() for x in asset.xpath('./type/text()') ]\n  print threetypes\n</code>\n</pre>\n", "senID": 1}]]