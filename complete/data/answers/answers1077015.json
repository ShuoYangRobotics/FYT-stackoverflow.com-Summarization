[[{"text": ["You can have nested iterations in a single list comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [filename for path in dirs for filename in os.listdir(path)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can find a good answer in itertools' recipes:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools' recipes:", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#recipes"}]}, {"code": "<pre>\n<code>\n def flatten(listOfLists):\n    return list(chain.from_iterable(listOfLists))\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Note: requires Python 2.6+)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could just do the straightforward:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n subs = []\nfor d in dirs:\n    subs.extend(os.listdir(d))\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n subs = []\nmap(subs.extend, (os.listdir(d) for d in dirs))\n</code>\n</pre>\n", "senID": 0}, {"text": ["(but Ants's answer is better; +1 for him)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You could try itertools.chain(), like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.chain()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\nimport os\ndirs = [\"c:\\\\usr\", \"c:\\\\temp\"]\nsubs = list(itertools.chain(*[os.listdir(d) for d in dirs]))\nprint subs\n</code>\n</pre>\n", "senID": 1}, {"text": ["itertools.chain() returns an iterator, hence the passing to list()."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "itertools.chain()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Google brought me next solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def flatten(l):\n   if isinstance(l,list):\n      return sum(map(flatten,l))\n   else:\n      return l\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can concatenate lists using the normal addition operator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [1, 2] + [3, 4]\n[1, 2, 3, 4]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The built-in function sum will add the numbers in a sequence and can optionally start from a specific value:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "sum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sum(xrange(10), 100)\n145\n</code>\n</pre>\n", "senID": 3}, {"text": ["Combine the above to flatten a list of lists:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sum([[1, 2], [3, 4]], [])\n[1, 2, 3, 4]\n</code>\n</pre>\n", "senID": 5}, {"text": ["You can now define your flatmap:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "flatmap", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def flatmap(f, seq):\n...   return sum([f(s) for s in seq], [])\n... \n&gt;&gt;&gt; flatmap(range, [1,2,3])\n[0, 0, 1, 0, 1, 2]\n</code>\n</pre>\n", "senID": 7}, {"text": ["Edit: I just saw the critique in the comments for another answer and I guess it is correct that Python will needlessly build and garbage collect lots of smaller lists with this solution.", "So the best thing that can be said about it is that it is very simple and concise if you're used to functional programming :-)"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "another answer", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1077015/python-list-comprehensions-compressing-a-list-of-lists/1077067#1077067"}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; listOfLists = [[1, 2],[3, 4, 5], [6]]\n&gt;&gt;&gt; reduce(list.__add__, listOfLists)\n[1, 2, 3, 4, 5, 6]\n</code>\n</pre>\n", "senID": 0}, {"text": ["I'm guessing the itertools solution is more efficient than this, but this feel very pythonic and avoids having to import a library just for the sake of a single list operation."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]