[[{"text": ["I recently went down this path as well; though it sounds like my application was slightly different.", "I was interested in approximating set operations on a large number of strings. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You do make the key observation that a fast bit vector is required.", "Depending on what you want to put in your bloom filter, you may also need to give some thought to the speed of the hashing algorithm(s) used.", "You might find this library useful.", "You may also want to tinker with the random number technique used below that only hashes your key a single time."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "fast", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "library", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.partow.net/programming/hashfunctions/index.html"}]}, {"text": ["In terms of non-Java bit array implementations:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Boost has ", "tag": "none", "senID": 3}, {"text": "Java has the built in ", "tag": "none", "senID": 4}]}, {"text": ["I built my bloom filter using BitVector.", "I spent some time profiling and optimizing the library and contributing back my patches to Avi.", "Go to that BitVector link and scroll down to acknowledgments in v1.5 to see details.", "In the end, I realized that performance was not a goal of this project and decided against using it. "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "BitVector", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cobweb.ecn.purdue.edu/~kak/dist/"}]}, {"text": ["Here's some code I had lying around.", "I may put this up on google code at python-bloom.", "Suggestions welcome."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n from BitVector import BitVector\nfrom random import Random\n# get hashes from http://www.partow.net/programming/hashfunctions/index.html\nfrom hashes import RSHash, JSHash, PJWHash, ELFHash, DJBHash\n\n\n#\n# ryan.a.cox@gmail.com / www.asciiarmor.com\n#\n# copyright (c) 2008, ryan cox\n# all rights reserved \n# BSD license: http://www.opensource.org/licenses/bsd-license.php\n#\n\nclass BloomFilter(object):\n    def __init__(self, n=None, m=None, k=None, p=None, bits=None ):\n        self.m = m\n        if k &gt; 4 or k &lt; 1:\n            raise Exception('Must specify value of k between 1 and 4')\n        self.k = k\n        if bits:\n            self.bits = bits\n        else:\n            self.bits = BitVector( size=m )\n        self.rand = Random()\n        self.hashes = []\n        self.hashes.append(RSHash)\n        self.hashes.append(JSHash)\n        self.hashes.append(PJWHash)\n        self.hashes.append(DJBHash)\n\n        # switch between hashing techniques\n        self._indexes = self._rand_indexes\n        #self._indexes = self._hash_indexes\n\n    def __contains__(self, key):\n        for i in self._indexes(key): \n            if not self.bits[i]:\n                return False    \n        return True \n\n    def add(self, key):\n        dupe = True \n        bits = []\n        for i in self._indexes(key): \n            if dupe and not self.bits[i]:\n                dupe = False\n            self.bits[i] = 1\n            bits.append(i)\n        return dupe\n\n    def __and__(self, filter):\n        if (self.k != filter.k) or (self.m != filter.m): \n            raise Exception('Must use bloom filters created with equal k / m paramters for bitwise AND')\n        return BloomFilter(m=self.m,k=self.k,bits=(self.bits &amp; filter.bits))\n\n    def __or__(self, filter):\n        if (self.k != filter.k) or (self.m != filter.m): \n            raise Exception('Must use bloom filters created with equal k / m paramters for bitwise OR')\n        return BloomFilter(m=self.m,k=self.k,bits=(self.bits | filter.bits))\n\n    def _hash_indexes(self,key):\n        ret = []\n        for i in range(self.k):\n            ret.append(self.hashes[i](key) % self.m)\n        return ret\n\n    def _rand_indexes(self,key):\n        self.rand.seed(hash(key))\n        ret = []\n        for i in range(self.k):\n            ret.append(self.rand.randint(0,self.m-1))\n        return ret\n\nif __name__ == '__main__':\n    e = BloomFilter(m=100, k=4)\n    e.add('one')\n    e.add('two')\n    e.add('three')\n    e.add('four')\n    e.add('five')        \n\n    f = BloomFilter(m=100, k=4)\n    f.add('three')\n    f.add('four')\n    f.add('five')\n    f.add('six')\n    f.add('seven')\n    f.add('eight')\n    f.add('nine')\n    f.add(\"ten\")        \n\n    # test check for dupe on add\n    assert not f.add('eleven') \n    assert f.add('eleven') \n\n    # test membership operations\n    assert 'ten' in f \n    assert 'one' in e \n    assert 'ten' not in e \n    assert 'one' not in f         \n\n    # test set based operations\n    union = f | e\n    intersection = f &amp; e\n\n    assert 'ten' in union\n    assert 'one' in union \n    assert 'three' in intersection\n    assert 'ten' not in intersection\n    assert 'one' not in intersection\n</code>\n</pre>\n", "senID": 7}, {"text": ["Also, in my case I found it useful to have a faster count_bits function for BitVector.", "Drop this code into BitVector 1.5 and it should give you a more performant bit counting method:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def fast_count_bits( self, v ):\n    bits = (\n            0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n            3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n            3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n            3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n            3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n            4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 )\n\n    return bits[v &amp; 0xff] + bits[(v &gt;&gt; 8) &amp; 0xff] + bits[(v &gt;&gt; 16) &amp; 0xff] + bits[v &gt;&gt; 24]\n</code>\n</pre>\n", "senID": 9}], [{"text": ["In reaction to Parand, saying \"common practice seems to be using something like SHA1 and split up the bits to form multiple hashes\", while that may be true in the sense that it's common practice (PyBloom also uses it), it still doesn't mean it's the right thing to do ;-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For a Bloom filter, the only requirement a hash function has is that its output space must be uniformly distributed given the expected input.", "While a cryptographic hash certainly fulfils this requirement, it's also a littlebit like shooting a fly with a bazooka."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Instead try the FNV Hash(1) which uses just one XOR and one multiplication per input byte, which I estimate is a few hundred times faster than SHA1 :)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "FNV Hash", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.isthe.com/chongo/tech/comp/fnv/"}]}, {"text": ["The FNV hash is not cryptographically secure, but you don't need it to be.", "It has slightly imperfect avalanche behaviour(2), but you're not using it for integrity checking either."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "mperfect avalanche behaviour", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://bretm.home.comcast.net/~bretm/hash/6.htm"}]}, {"text": ["About uniformity, note that the second link only did a Chi-square test for the 32-bit FNV hash.", "It's better to use more bits and the FNV-1 variant, which swaps the XOR and the MUL steps for better bit-dispersion.", "For a Bloom Filter, there's a few more catches, such as mapping the output uniformly to the index range of the bit-array.", "If possible, I'd say round up the size of the bit-array to the nearest power of 2 and adjust k accordingly.", "That way you get better accuracy and you can use simple XOR-folding to map the range."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "k", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Additionally, here's a reference explaining why you don't want SHA1 (or any cryptographic hash) when you need a general purpose hash(3)."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "a general purpose hash", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bretm.home.comcast.net/~bretm/hash/9.html"}]}, {"text": ["I'm informed that I'm not allowed to post more than one link, AFTER I carefully wrote my entire reply, supplying references etc :( So here's my links, apologies for the inconvenience, you'll need to copy/paste them:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "(1) ", "tag": "none", "senID": 7}, {"text": "(2) ", "tag": "none", "senID": 8}, {"text": "(3) ", "tag": "none", "senID": 9}]}], [{"text": ["Eventually I found pybloomfiltermap.", "I haven't used it, but it looks like it'd fit the bill. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pybloomfiltermap", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/axiak/pybloomfiltermmap"}]}], [{"text": ["Look at the array module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "array", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-array.html"}]}, {"code": "<pre>\n<code>\n class Bit( object ):\n    def __init__( self, size ):\n        self.bits= array.array('B',[0 for i in range((size+7)//8)] )\n    def set( self, bit ):\n        b= self.bits[bit//8]\n        self.bits[bit//8] = b | 1 &lt;&lt; (bit % 8)\n    def get( self, bit ):\n        b= self.bits[bit//8]\n        return (b &gt;&gt; (bit % 8)) &amp; 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["FWIW, all of the //8 and % 8 operations can be replaced with &gt;&gt;3 and &amp;0x07.", "This may lead to slightly better speed at the risk of some obscurity."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "//8", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "% 8", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "&gt;&gt;3", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "&amp;0x07", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "may", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Also, changing 'B' and 8 to 'L' and 32 should be faster on most hardware.", "[Changing to 'H' and 16 might be faster on some hardware, but it's doubtful."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "'B'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "8", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "'L'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "32", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "'H'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I am keenly interested in  Bloom filters variants, their performance and understand their use-cases.", "There are so many well-cited research work on Bloom filter variants( including ones published in top-notch conferences like SIGCOMM,SIGMETRICS) yet I dont think their presence is strong in mainstream language libraries.", "Why do you think that's the case?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["While my interest is language-agnostic,I wanted to share an article I wrote on Bloom filter variants, and applications of Bloom filter.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://appolo85.wordpress.com/2010/08/03/bloom-filter/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://appolo85.wordpress.com/2010/08/03/bloom-filter/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://appolo85.wordpress.com/2010/08/03/bloom-filter/"}]}, {"text": ["I would love to learn more about their use-cases of the Bloom filter variants, and their design/implementation, and libraries in other languages. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Do you think  that most of  the publications, and ( code?", ") on Bloom filters variants , only serve to increment the published paper count of a PhD graduate?", "Or is it that most people do not want to mess with a production-ready standard bloom filter implementation that   \"works just fine\" :D  "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}], [{"text": ["You can try with it.unimi.dsi.util.BloomFilter of The DSI Utilities."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "it.unimi.dsi.util.BloomFilter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://dsiutils.dsi.unimi.it/", "text": "The DSI Utilities", "childNum": 0, "tag": "a", "childList": []}]}]]