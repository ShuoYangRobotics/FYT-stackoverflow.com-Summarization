[[{"text": ["If you have a csv file named 'blah.csv' That looks like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a,b,c,d\n1,2,3,4\n2,3,4,5\n3,4,5,6\n</code>\n</pre>\n", "senID": 1}, {"text": ["you know that you can open the file for reading, and create a DictReader with"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n blah = open('blah.csv', 'r')\nreader= csv.DictReader(blah)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then, you will be able to get the next line with reader.next(), which should output"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n {'a':1,'b':2,'c':3,'d':4}\n</code>\n</pre>\n", "senID": 5}, {"text": ["using it again will produce"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n {'a':2,'b':3,'c':4,'d':5}\n</code>\n</pre>\n", "senID": 7}, {"text": ["However, at this point if you use blah.seek(0), the next time you call reader.next() you will get"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n {'a':1,'b':2,'c':3,'d':4}\n</code>\n</pre>\n", "senID": 9}, {"text": ["again.", "This seems to be the functionality you're looking for.", "I'm sure there are some tricks associated with this approach that I'm not aware of however.", "@Brian suggested simply creating another DictReader.", "This won't work if you're first reader is half way through reading the file, as your new reader will have unexpected keys and values from wherever you are in the file."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["I see many answers suggesting itertools.tee, but that's ignoring one crucial warning in the docs for it:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.tee", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html?highlight=itertools.tee#itertools.tee"}]}, {"text": ["Basically, tee is designed for those situation where two (or more) clones of one iterator, while \"getting out of sync\" with each other, don't do so by much -- rather, they say in the same \"vicinity\" (a few items behind or ahead of each other).", "Not suitable for the OP's problem of \"redo from the start\"."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "tee", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "by much", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["L = list(DictReader(...)) on the other hand is perfectly suitable, as long as the list of dicts can fit comfortably in memory.", "A new \"iterator from the start\" (very lightweight and low-overhead) can be made at any time with iter(L), and used in part or in whole without affecting new or existing ones; other access patterns are also easily available."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "L = list(DictReader(...))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "iter(L)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["As several answers rightly remarked, in the specific case of csv you can also .seek(0) the underlying file object (a rather special case).", "I'm not sure that's documented and guaranteed, though it does currently work;  it would probably be worth considering only for truly huge csv files, in which the list I recommmend as the general approach would have too large a memory footprint."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "csv", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".seek(0)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["No.", "Python's iterator protocol is very simple, and only provides one single method (.next() or __next__()), and no method to reset an iterator in general."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": ".next()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__next__()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The common pattern is to instead create a new iterator using the same procedure again."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you want to \"save off\" an iterator so that you can go back to its beginning, you may also fork the iterator by using itertools.tee"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "itertools.tee", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Only if the underlying type provides a mechanism for doing so (e.g.", "fp.seek(0))."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "fp.seek(0)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["There's a bug in using .seek(0) as advocated by Alex Martelli and Wilduck above, namely that the next call to .next() will give you a dictionary of your header row in the form of {key1:key1, key2:key2, ...}.", "The work around is to follow file.seek(0) with a call to reader.next() to get rid of the header row."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So your code would look something like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n f_in = open('myfile.csv','r')\nreader = csv.DictReader(f_in)\n\nfor record in reader:\n    if some_condition:\n        # reset reader to first row of data on 2nd line of file\n        f_in.seek(0)\n        reader.next()\n        continue\n    do_something(record)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["While there is no iterator reset, the \"itertools\" module from python 2.6 (and later) has some utilities that can help there.", "One of then is the \"tee\" which can make multiple copies of an iterator, and cache the results of the one running ahead, so that these results are used on the copies.", "I will seve your purposes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def printiter(n):\n...   for i in xrange(n):\n...     print \"iterating value %d\" % i\n...     yield i\n\n&gt;&gt;&gt; from itertools import tee\n&gt;&gt;&gt; a, b = tee(printiter(5), 2)\n&gt;&gt;&gt; list(a)\niterating value 0\niterating value 1\niterating value 2\niterating value 3\niterating value 4\n[0, 1, 2, 3, 4]\n&gt;&gt;&gt; list(b)\n[0, 1, 2, 3, 4]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is maybe considered not answering question, but for me first question is:\nAm I asking the right question?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For me the csv files are mostly readable without csv, at least when not using quotes etc."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can use instead of csv module simple code snippet like this mine which I posted in DaniWeb:\ntext file based information access by field name and number"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "text file based information access by field name and number", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.daniweb.com/code/snippet293490.html"}]}, {"text": ["Then you can access the info any way and direction you like."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Second thing is that, I am interested to see exactly the reason arise for this activity.", "Maybe the program logic is not the best possible and the need is just reflection of the overlooked thing?", "Has happened to me at least, that I had to re-examine my pseudo code and correct it instead of doing strange program."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]