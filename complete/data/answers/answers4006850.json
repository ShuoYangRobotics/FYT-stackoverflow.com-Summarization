[[{"text": ["yes , you can do like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\nfrom datetime import datetime\n\ndata = {\n      \"2008-11-10 17:53:59\":\"data\",\n      \"2005-11-10 17:53:59\":\"data\",\n}\n\nlist_ = data.keys()\nnew_list = [datetime.strptime(x, \"%Y-%m-%d %H:%M:%S\") for x in list_]\n\nbegin_date = datetime.strptime(\"2007-11-10 17:53:59\", \"%Y-%m-%d %H:%M:%S\")\n\nfor i in itertools.ifilter(lambda x: x &gt; begin_date, new_list):\n    print i\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you know for a fact that the items in your sequence are sorted, you can just use a generator expression:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (item for item in seq if item &gt;= 5)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This returns a generator; it doesn't actually traverse the list until you iterate over it, i.e."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for item in (item for item in seq if item &gt; 5)\n    print item\n</code>\n</pre>\n", "senID": 3}, {"text": ["will only traverse seq once."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "seq", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Using a generator expression like this is pretty much identical to using itertools.ifilter, which produces a generator that iterates over the list returning only values that meet the filter criterion:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "itertools.ifilter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import itertools\n&gt;&gt;&gt; seq = [1, 2, 3, 4, 5, 6, 7]\n&gt;&gt;&gt; list(itertools.ifilter(lambda x: x&gt;=3, seq))\n[3, 4, 5, 6, 7]\n</code>\n</pre>\n", "senID": 6}, {"text": ["I'm not sure why (except for backwards compatibility) we need itertools.ifilter anymore now that we have generator expressions, but other methods in itertools are invaluable.  "], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "itertools.ifilter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If, for instance, you don't know that your sequence is sorted, and you still want to return everything in the sequence from a known item and beyond, you can't use a generator expression.", "Instead, use itertools.dropwhile.", "This produces a generator that iterates over the list skipping values until it finds one that meets the filter criterion:"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "don't", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "itertools.dropwhile", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; seq = [1, 2, 4, 3, 5, 6, 7]\n&gt;&gt;&gt; list(itertools.dropwhile(lambda x: x != 3, seq))\n[3, 5, 6, 7]\n</code>\n</pre>\n", "senID": 9}, {"text": ["As far as searching backwards goes, this will only work if the sequence you're using is actually a sequence (like a list, i.e.", "something that has an end and can be navigated backwards)  and not just any iterable (e.g.", "a generator that returns the next prime number).", "To do this, use the reversed function, e.g."], "childNum": 3, "tag": "p", "senID": 10, "childList": [{"text": "has", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "can", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "reversed", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n (item for item in reversed(seq) if item &gt;= 5)\n</code>\n</pre>\n", "senID": 11}], [{"text": ["Given your relevant facts:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import bisect\n&gt;&gt;&gt; def find_fwd_iter(S, i):\n...     j = bisect.bisect_left(S, i)\n...     for k in xrange(j, len(S)):\n...         yield S[k]\n...\n&gt;&gt;&gt; def find_bkwd_iter(S, i):\n...     j = bisect.bisect_left(S, i)\n...     for k in xrange(j, -1, -1):\n...         yield S[k]\n...\n&gt;&gt;&gt; L = [100, 150, 200, 300, 400]\n&gt;&gt;&gt; list(find_fwd_iter(L, 200))\n[200, 300, 400]\n&gt;&gt;&gt; list(find_bkwd_iter(L, 200))\n[200, 150, 100]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["One simpler way (albeit slower) would be to use filter and filter for keys before/after that date.", "Filter has to process each element in the list as opposed to slicing not needing to."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "filter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def on_or_after(date):\n    from itertools import dropwhile\n    sorted_items = sorted(date_dictionary.iteritems())\n    def before_date(pair):\n        return pair[0] &lt; date\n    on_or_after_date = dropwhile(before_date, sorted_items)\n</code>\n</pre>\n", "senID": 1}, {"text": ["which I think is about as efficient as it's going to get if you're just doing one such lookup on each sorted collection.", "on_or_after_date will iterate (date, value) pairs."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "on_or_after_date", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Another option would be to build a dictionary as a separate index into the sorted list:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n sorted_items = sorted(date_dictionary.iteritems())\ndate_index = dict((key, i) for i, key in enumerate(sorted_items.keys()))\n</code>\n</pre>\n", "senID": 4}, {"text": ["and then get the items on or after a date with"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def on_or_after(date):\n    return sorted_items[date_index[date]:]\n</code>\n</pre>\n", "senID": 6}, {"text": ["This second approach will be faster if you're going to be doing a lot of lookups on the same series of sorted dates (which it sounds like you are)."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["If you want really speedy slicing of the sorted dates, you might see some improvement by storing it in a tuple instead of a list.", "I could be wrong about that though."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["note the above code is untested, let me know if it doesn't work and you can't sort out why."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "note", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["First off, this question isn't related to dicts.", "You're operating on a sorted list.", "You're using the results on a dict, but that's not relevant to the question."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "results", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["You want the bisect module, which implements binary searching.", "Starting from your code:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "bisect", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import bisect\nmydict = {\n      \"2001-01-01\":\"data1\",\n      \"2005-01-02\":\"data2\",\n      \"2002-01-01\":\"data3\",\n      \"2004-01-02\":\"data4\",\n}\n\n# ['2001-01-01', '2002-01-01', '2004-01-02', '2005-01-02']:\nsorted_dates = sorted(mydict)\n\n# Iterates over 2002-01-01, 2004-01-02 and 2005-01-02:\noffset = bisect.bisect_left(sorted_dates, \"2002-01-01\")\nfor item in sorted_dates[offset:]:\n    print item\n</code>\n</pre>\n", "senID": 2}]]