[[{"text": ["Most of the times it is easier (and cheaper) to make the first iteration the special case instead of the last one:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "first", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n first = True\nfor data in data_list:\n    if first:\n        first = False\n    else:\n        between_items()\n\n    item()\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will work for any iterable, even for those that have no len():"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "len()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n file = open('/path/to/file')\nfor line in file:\n    process_line(line)\n\n    # No way of telling if this is the last line!\n</code>\n</pre>\n", "senID": 3}, {"text": ["Apart from that, I don't think there is a generally superior solution as it depends on what you are trying to do.", "For example, if you are building a string from a list, it's naturally better to use str.join() than using a for loop \u201cwith special case\u201d."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "str.join()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Using the same principle but more compact:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n for i, line in enumerate(data_list):\n    if i &gt; 0:\n        between_items()\n    item()\n</code>\n</pre>\n", "senID": 6}, {"text": ["Looks familiar, doesn't it?", ":)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["The 'code between' is an example of the Head-Tail pattern."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Head-Tail", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You have an item, which is followed by a sequence of ( between, item ) pairs.", "You can also view this as a sequence of (item, between) pairs followed by an item.", "It's generally simpler to take the first element as special and all the others as the \"standard\" case."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Further, to avoid repeating code, you have to provide a function or other object to contain the code you don't want to repeat.", "Embedding an if statement in a loop which is always false except one time is kind of silly."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "if", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def item_processing( item ):\n    # *the common processing*\n\nhead_tail_iter = iter( someSequence )\nhead = head_tail_iter.next()\nitem_processing( head )\nfor item in head_tail_iter:\n    # *the between processing*\n    item_processing( item )\n</code>\n</pre>\n", "senID": 3}, {"text": ["This is more reliable because it's slightly easier to prove,  It doesn't create an extra data structure (i.e., a copy of a list) and doesn't require a lot of wasted execution of an if condition which is always false except once."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "if", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["If you're simply looking to modify the last element in data_list then you can simply use the notation:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "data_list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n L[-1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, it looks like you're doing more than that.", "There is nothing really wrong with your way.", "I even took a quick glance at some Django code for their template tags and they do basically what you're doing."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Django code", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://code.djangoproject.com/browser/django/trunk/django/template/defaulttags.py"}]}], [{"text": ["This is similar to Ants Aasma's approach but without using the itertools module.", "It's also a lagging iterator which looks-ahead a single element in the iterator stream:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def last_iter(it):\n    # Ensure it's an iterator and get the first field\n    it = iter(it)\n    prev = next(it)\n    for item in it:\n        # Lag by one item so I know I'm not at the end\n        yield 0, prev\n        prev = item\n    # Last item\n    yield 1, prev\n\ndef test(data):\n    result = list(last_iter(data))\n    if not result:\n        return\n    if len(result) &gt; 1:\n        assert set(x[0] for x in result[:-1]) == set([0]), result\n    assert result[-1][0] == 1\n\ntest([])\ntest([1])\ntest([1, 2])\ntest(range(5))\ntest(xrange(4))\n\nfor is_last, item in last_iter(\"Hi!\"):\n    print is_last, item\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Is there no possibility to iterate over all-but the last element, and treat the last one outside of the loop?", "After all, a loop is created to do something similar to all elements you loop over; if one element needs something special, it shouldn't be in the loop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(see also this question: does-the-last-element-in-a-loop-deserve-a-separate-treatment)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "does-the-last-element-in-a-loop-deserve-a-separate-treatment", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/156650/does-the-last-element-in-a-loop-deserve-a-separate-treatment"}]}, {"text": ["EDIT: since the question is more about the \"in between\", either the first element is the special one in that it has no predecessor, or the last element is special in that it has no successor."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "first", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "last", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["You can use a sliding window over the input data to get a peek at the next value and use a sentinel to detect the last value.", "This works on any iterable, so you don't need to know the length beforehand.", "The pairwise implementation is from itertools recipes."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools recipes", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html"}]}, {"code": "<pre>\n<code>\n from itertools import tee, izip, chain\n\ndef pairwise(seq):\n    a,b = tee(seq)\n    next(b, None)\n    return izip(a,b)\n\ndef annotated_last(seq):\n    \"\"\"Returns an iterable of pairs of input item and a boolean that show if\n    the current item is the last item in the sequence.\"\"\"\n    MISSING = object()\n    for current_item, next_item in pairwise(chain(seq, [MISSING])):\n        yield current_item, next_item is MISSING:\n\nfor item, is_last_item in annotated_last(data_list):\n    if is_last_item:\n        # current item is the last item\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There is nothing wrong with your way, unless you will have 100 000 loops and wants save 100 000 \"if\" statements.", "In that case, you can go that way :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n iterable = [1,2,3] # Your date\niterator = iter(iterable) # get the data iterator\n\ntry :   # wrap all in a try / except\n    while 1 : \n        item = iterator.next() \n        print item # put the \"for loop\" code here\nexcept StopIteration, e : # make the process on the last element here\n    print item\n</code>\n</pre>\n", "senID": 1}, {"text": ["Outputs :"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 1\n2\n3\n3\n</code>\n</pre>\n", "senID": 3}, {"text": ["But really, in your case I feel like it's overkill."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In any case, you will probably be luckier with slicing :"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n for item in iterable[:-1] :\n    print item\nprint \"last :\", iterable[-1]\n\n#outputs\n1\n2\nlast : 3\n</code>\n</pre>\n", "senID": 6}, {"text": ["or just :"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n for item in iterable :\n    print item\nprint iterable[-1]\n\n#outputs\n1\n2\n3\nlast : 3\n</code>\n</pre>\n", "senID": 8}, {"text": ["Eventually, a KISS way to do you stuff, and that would work with any iterable, including the ones without __len__ :"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "__len__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n item = ''\nfor item in iterable :\n    print item\nprint item\n</code>\n</pre>\n", "senID": 10}, {"text": ["Ouputs:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n 1\n2\n3\n3\n</code>\n</pre>\n", "senID": 12}, {"text": ["If feel like I would do it that way, seems simple to me."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["Assuming input as an iterator, here's a way using tee and izip from itertools:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import tee, izip\nitems, between = tee(input_iterator, 2)  # Input must be an iterator.\nfirst = items.next()\ndo_to_every_item(first)  # All \"do to every\" operations done to first item go here.\nfor i, b in izip(items, between):\n    do_between_items(b)  # All \"between\" operations go here.\n    do_to_every_item(i)  # All \"do to every\" operations go here.\n</code>\n</pre>\n", "senID": 1}, {"text": ["Demo:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def do_every(x): print \"E\", x\n...\n&gt;&gt;&gt; def do_between(x): print \"B\", x\n...\n&gt;&gt;&gt; test_input = iter(range(5))\n&gt;&gt;&gt;\n&gt;&gt;&gt; from itertools import tee, izip\n&gt;&gt;&gt;\n&gt;&gt;&gt; items, between = tee(test_input, 2)\n&gt;&gt;&gt; first = items.next()\n&gt;&gt;&gt; do_every(first)\nE 0\n&gt;&gt;&gt; for i,b in izip(items, between):\n...     do_between(b)\n...     do_every(i)\n...\nB 0\nE 1\nB 1\nE 2\nB 2\nE 3\nB 3\nE 4\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}]]