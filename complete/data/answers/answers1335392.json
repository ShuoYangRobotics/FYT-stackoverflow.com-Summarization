[[{"text": ["If you want to divide a list into slices you can use this trick:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n list_of_slices = zip(*(iter(the_list),) * slice_size)\n</code>\n</pre>\n", "senID": 1}, {"text": ["For example"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; zip(*(iter(range(10)),) * 3)\n[(0, 1, 2), (3, 4, 5), (6, 7, 8)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["If the number of items is not dividable by the slice size and you want to pad the list with None you can do this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; map(None, *(iter(range(10)),) * 3)\n[(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, None, None)]\n</code>\n</pre>\n", "senID": 5}, {"text": ["It is a dirty little trick"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"tag": "hr", "senID": 7}, {"text": ["OK, I'll explain how it works.", "It'll be tricky to explain but I'll try my best."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["First a little background:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["In Python you can multiply a list by a number like this:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n [1, 2, 3] * 3 -&gt; [1, 2, 3, 1, 2, 3, 1, 2, 3]\n([1, 2, 3],) * 3 -&gt; ([1, 2, 3], [1, 2, 3], [1, 2, 3])\n</code>\n</pre>\n", "senID": 11}, {"text": ["And an iterator object can be consumed once like this:"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "iterator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html?highlight=iter#iter"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l=iter([1, 2, 3])\n&gt;&gt;&gt; l.next()\n1\n&gt;&gt;&gt; l.next()\n2\n&gt;&gt;&gt; l.next()\n3\n</code>\n</pre>\n", "senID": 13}, {"text": ["The zip function returns a list of tuples, where the i-th tuple contains the i-th element from each of the argument sequences or iterables.", "For example:"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "zip", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#zip"}]}, {"code": "<pre>\n<code>\n zip([1, 2, 3], [20, 30, 40]) -&gt; [(1, 20), (2, 30), (3, 40)]\nzip(*[(1, 20), (2, 30), (3, 40)]) -&gt; [[1, 2, 3], [20, 30, 40]]\n</code>\n</pre>\n", "senID": 15}, {"text": ["The * in front of zip used to unpack arguments.", "You can find more details here.", "So"], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/controlflow.html#unpacking-argument-lists"}]}, {"code": "<pre>\n<code>\n zip(*[(1, 20), (2, 30), (3, 40)])\n</code>\n</pre>\n", "senID": 17}, {"text": ["is actually equivalent to "], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n zip((1, 20), (2, 30), (3, 40))\n</code>\n</pre>\n", "senID": 19}, {"text": ["but works with a variable number of arguments"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"text": ["Now back to the trick:"], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"code": "<pre>\n<code>\n list_of_slices = zip(*(iter(the_list),) * slice_size)\n</code>\n</pre>\n", "senID": 22}, {"text": ["iter(the_list) -> convert the list into an iterator"], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "iter(the_list)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["(iter(the_list),) * N -> will generate an N reference to the_list iterator."], "childNum": 1, "tag": "p", "senID": 24, "childList": [{"text": "(iter(the_list),) * N", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["zip(*(iter(the_list),) * N) -> will feed those list of iterators into zip.", "Which in turn will group them into N sized tuples.", "But since all N items are in fact references to the same iterator iter(the_list) the result will be repeated calls to next() on the original iterator"], "childNum": 3, "tag": "p", "senID": 25, "childList": [{"text": "zip(*(iter(the_list),) * N)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "iter(the_list)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "next()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I hope that explains it.", "I advice you to go with an easier to understand solution.", "I was only tempted to mention this trick because I like it."], "childNum": 0, "tag": "p", "senID": 26, "childList": []}], [{"text": ["If you want to be able to consume any iterable you can use these functions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import chain, islice\n\ndef ichunked(seq, chunksize):\n    \"\"\"Yields items from an iterator in iterable chunks.\"\"\"\n    it = iter(seq)\n    while True:\n        yield chain([it.next()], islice(it, chunksize-1))\n\ndef chunked(seq, chunksize):\n    \"\"\"Yields items from an iterator in list chunks.\"\"\"\n    for chunk in ichunked(seq, chunksize):\n        yield list(chunk)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Do you mean something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def callonslices(size, fatherList, foo):\n  for i in xrange(0, len(fatherList), size):\n    foo(fatherList[i:i+size])\n</code>\n</pre>\n", "senID": 1}, {"text": ["If this is roughly the functionality you want you might, if you desire, dress it up a bit in a generator:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def sliceup(size, fatherList):\n  for i in xrange(0, len(fatherList), size):\n    yield fatherList[i:i+size]\n</code>\n</pre>\n", "senID": 3}, {"text": ["and then:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def callonslices(size, fatherList, foo):\n  for sli in sliceup(size, fatherList):\n    foo(sli)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I am not sure, but it seems you want to do what is called a moving average.", "numpy provides facilities for this (the convolve function)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n>>> x = numpy.array(range(20))\n>>> x\n    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n       17, 18, 19])    \n>>> n = 2 # moving average window\n>>> numpy.convolve(numpy.ones(n)/n, x)[n-1:-n+1]\narray([  0.5,   1.5,   2.5,   3.5,   4.5,   5.5,   6.5,   7.5,   8.5,\n         9.5,  10.5,  11.5,  12.5,  13.5,  14.5,  15.5,  16.5,  17.5,  18.5])\n</pre>\n", "senID": 1}, {"text": ["The nice thing is that it accomodates different weighting schemes nicely (just change numpy.ones(n) / n to something else)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "numpy.ones(n) / n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You can find a complete material here:\nhttp://www.scipy.org/Cookbook/SignalSmooth"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://www.scipy.org/Cookbook/SignalSmooth", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.scipy.org/Cookbook/SignalSmooth"}]}], [{"text": ["If you need to store state then you can use an object for that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Chunker(object):\n    \"\"\"Split `iterable` on evenly sized chunks.\n\n    Leftovers are remembered and yielded at the next call.\n    \"\"\"\n    def __init__(self, chunksize):\n        assert chunksize &gt; 0\n        self.chunksize = chunksize        \n        self.chunk = []\n\n    def __call__(self, iterable):\n        \"\"\"Yield items from `iterable` `self.chunksize` at the time.\"\"\"\n        assert len(self.chunk) &lt; self.chunksize\n        for item in iterable:\n            self.chunk.append(item)\n            if len(self.chunk) == self.chunksize:\n                # yield collected full chunk\n                yield self.chunk\n                self.chunk = []\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n chunker = Chunker(3)\nfor s in \"abcd\", \"efgh\":\n    for chunk in chunker(s):\n        print ''.join(chunk)\n\nif chunker.chunk: # is there anything left?\n    print ''.join(chunker.chunk)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n abc\ndef\ngh\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Use a generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n big_list = [1,2,3,4,5,6,7,8,9]\nslice_length = 3\ndef sliceIterator(lst, sliceLen):\n    for i in range(len(lst) - sliceLen + 1):\n        yield lst[i:i + sliceLen]\n\nfor slice in sliceIterator(big_list, slice_length):\n    foo(slice)\n</code>\n</pre>\n", "senID": 1}, {"text": ["sliceIterator implements a \"sliding window\" of width sliceLen over the squence lst, i.e.", "it produces overlapping slices: [1,2,3], [2,3,4], [3,4,5], ... Not sure if that is the OP's intention, though."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "sliceIterator", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sliceLen", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "lst", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Your question could use some more detail, but how about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def iterate_over_slices(the_list, slice_size):\n    for start in range(0, len(the_list)-slice_size):\n        slice = the_list[start:start+slice_size]\n        foo(slice)\n</code>\n</pre>\n", "senID": 1}]]