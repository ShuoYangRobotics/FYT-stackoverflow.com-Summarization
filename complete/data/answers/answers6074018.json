[[{"text": ["I believe Python has special case handling for sequences of relational operators to make range comparisons easy to express.", "It's much nicer to be able to say 0 &lt; x &lt;= 5 than to say (0 &lt; x) and (x &lt;= 5)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "0 &lt; x &lt;= 5", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "(0 &lt; x) and (x &lt;= 5)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["These are called chained comparisons.", "And that's a link to the documentation for them."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "chained comparisons", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/expressions.html#notin"}]}, {"text": ["With the other cases you talk about, the parenthesis force one relational operator to be applied before the other, and so they are no longer chained comparisons.", "And since True and False have values as integers you get the answers you do out of the parenthesized versions."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "True", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Because"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (0 &lt; 0) and (0 == 0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["is False.", "You can chain together comparison operators and they are automatically expanded out into the pairwise comparisons."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "False", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["EDIT -- clarification about True and False in Python"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["In Python True and False are just instances of bool, which is a subclass of int.", "In other words, True really is just 1."], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "True", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "bool", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The point of this is that you can use the result of a boolean comparison exactly like an integer.", "This leads to confusing things like"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; (1==1)+(1==1)\n2\n&gt;&gt;&gt; (2&lt;1)&lt;1\nTrue\n</code>\n</pre>\n", "senID": 6}, {"text": ["But these will only happen if you parenthesise the comparisons so that they are evaluated first.", "Otherwise Python will expand out the comparison operators."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["The strange behavior your experiencing comes from pythons ability to chain conditions.", "Since it finds 0 is not less than 0, it decides the entire expression evaluates to false.", "As soon as you break this apart into seperate conditions, you're changing the functionality.", "It initially is essentially testing that a &lt; b &amp;&amp; b == c for your original statement of a &lt; b == c."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "a &lt; b &amp;&amp; b == c", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "a &lt; b == c", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Another example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 1 &lt; 5 &lt; 3\nFalse\n\n&gt;&gt;&gt; (1 &lt; 5) &lt; 3\nTrue\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; 0 &lt; 0 == 0\nFalse\n</code>\n</pre>\n", "senID": 0}, {"text": ["This is a chained comparison.", "It returns true if each pairwise comparison in turn is true.", "It is the equivalent to (0 &lt; 0) and (0 == 0)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "(0 &lt; 0) and (0 == 0)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; (0) &lt; (0 == 0)\nTrue\n</code>\n</pre>\n", "senID": 2}, {"text": ["This is equivalent to 0 &lt; True which evaluates to True."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "0 &lt; True", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; (0 &lt; 0) == 0\nTrue\n</code>\n</pre>\n", "senID": 4}, {"text": ["This is equivalent to False == 0 which evaluates to True."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "False == 0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 0 &lt; (0 == 0)\nTrue\n</code>\n</pre>\n", "senID": 6}, {"text": ["Equivalent to 0 &lt; True which, as above, evaluates to True."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "0 &lt; True", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["maybe this excerpt from the docs can help:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html#object.__lt__"}]}, {"text": ["These were comparisons but since you are chaining comparisons you should know that:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "chaining comparisons", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/expressions.html#notin"}]}], [{"text": ["As other's mentioned x comparison_operator y comparison_operator z is syntactical sugar for (x comparison_operator y) and (y comparison_operator z) with the bonus that y is only evaluated once."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "x comparison_operator y comparison_operator z", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(x comparison_operator y) and (y comparison_operator z)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So your expression 0 &lt; 0 == 0 is really (0 &lt; 0) and (0 == 0), which evaluates to False and True which is just False."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "0 &lt; 0 == 0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(0 &lt; 0) and (0 == 0)", "childNum": 0, "tag": "code", "childList": []}, {"text": "False and True", "childNum": 0, "tag": "code", "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Here it is, in all it's glory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class showme(object):\n...   def __init__(self, name, value):\n...     self.name, self.value = name, value\n...   def __repr__(self):\n...     return \"&lt;showme %s:%s&gt;\" % (self.name, self.value)\n...   def __cmp__(self, other):\n...     print \"cmp(%r, %r)\" % (self, other)\n...     if type(other) == showme:\n...       return cmp(self.value, other.value)\n...     else:\n...       return cmp(self.value, other)\n... \n&gt;&gt;&gt; showme(1,0) &lt; showme(2,0) == showme(3,0)\ncmp(&lt;showme 1:0&gt;, &lt;showme 2:0&gt;)\nFalse\n&gt;&gt;&gt; (showme(1,0) &lt; showme(2,0)) == showme(3,0)\ncmp(&lt;showme 1:0&gt;, &lt;showme 2:0&gt;)\ncmp(&lt;showme 3:0&gt;, False)\nTrue\n&gt;&gt;&gt; showme(1,0) &lt; (showme(2,0) == showme(3,0))\ncmp(&lt;showme 2:0&gt;, &lt;showme 3:0&gt;)\ncmp(&lt;showme 1:0&gt;, True)\nTrue\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm thinking Python is doing it's weird between magic.", "Same as 1 &lt; 2 &lt; 3 means 2 is between 1 and 3."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "1 &lt; 2 &lt; 3", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In this case, I think it's doing [middle 0] is greater than [left 0] and equal to [right 0].", "Middle 0 is not greater than left 0, so it evaluates to false."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["0 &lt; 0 == 0;\n0 is NOT &lt; than 0;"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(0) &lt; (0 == 0);\n0==0?", "true, so the value is 1, 0 &lt; 1?", "true"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["(0 &lt; 0) == 0;\n0 is less than 0?", "no, return 0; 0 == 0?", "true"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["0 &lt; (0 == 0)\n same as (0) &lt; (0 == 0)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["When a comparison or something of the kind is true, it returns the value 1, if it is false it returns 0, and the parenthisis are done first."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The answer to what you asked is written above, should be sufficient ;)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]