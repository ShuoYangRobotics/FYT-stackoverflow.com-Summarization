[[{"text": ["If you use Python >= 2.7, the best approach would be be to use "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def setUpClass(klass):\n    # ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["to perform some initialization once for all tests belonging to the given class."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can save the state if expensiveSetup() is run or not."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "expensiveSetup()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n __expensiveSetup_has_run = False\n\nclass ExpensiveSetupMixin(unittest.TestCase):\n    def setUp(self):\n        global __expensiveSetup_has_run\n        super(ExpensiveSetupMixin, self).setUp()\n        if __expensiveSetup_has_run is False:\n            expensiveSetup()\n            __expensiveSetup_has_run = True\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or some kind of variation of this.", "Maybe pinging xml-rpc server and create a new one if it isn't answering."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["But the unit-testing way AFAIK is to setup and teardown per unittest even if it is expensive."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "setup and teardown per unittest", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["First of all, what S. Lott said.", "However!, you do not want to do that.", "There is a reason setUp and tearDown are wrapped around each test: they help preserve the determinism of testing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Otherwise, if some test places the system in a bad state, your next tests may fail.", "Ideally, each of your tests should be independent."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Also, if you insist on doing it this way, instead of writing by hand self.runTest1(), self.runTest2(), you might want to do a bit of introspection in order to find the methods to run."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Won't package-level initialization do it for you?", "From the Nose Wiki:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Nose Wiki", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.google.com/p/python-nose/wiki/WritingTests"}]}], [{"text": ["You can assure setUp and tearDown execute once if you have only one test method, runTest.", "This method can do whatever else it wants.", "Just be sure you don't have any methods with names that start with test."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "setUp", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tearDown", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "runTest", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "test", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n class MyExpensiveTest( unittest.TestCase ):\n    def setUp( self ):\n        self.resource = owThatHurts()\n    def tearDown( self ):\n        self.resource.flush()\n        self.resource.finish()\n    def runTest( self ):\n        self.runTest1()\n        self.tunTest2()\n    def runTest1( self ):\n        self.assertEquals(...)\n    def runTest2( self ):\n        self.assertEquals(...)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It doesn't automagically figure out what to run.", "If you add a test method, you also have to update runTest.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This is what I do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class TestSearch(unittest.TestCase):\n\"\"\"General Search tests for....\"\"\"\n\nmatcher = None\ncounter      = 0\nnum_of_tests = None\n\ndef setUp(self): # pylint: disable-msg=C0103 \n    \"\"\"Only instantiate the matcher once\"\"\"\n    if self.matcher is None:\n        self.__class__.matcher = Matcher()\n        self.__class__.num_of_tests = len(filter(self.isTestMethod, dir(self)))\n    self.__class__.counter = self.counter + 1 \n\ndef tearDown(self): # pylint: disable-msg=C0103\n    \"\"\"And kill it when done\"\"\"\n    if self.counter == self.num_of_tests:\n        print 'KILL KILL KILL'\n        del self.__class__.matcher\n</code>\n</pre>\n", "senID": 1}, {"text": ["Sadly (because I do want my tests to be independent and deterministic), I do this a lot (because system testing that take less than 5 minutes are also important)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I know nothing about Netbeans, but I though I should mention zope.testrunner and it's support for a nifty thing: Layers.", "Basically, you do the testsetup in separate classes, and attach those classes to the tests.", "These classes can inherit from each other, forming a layer of setups.", "The testrunner will then only call each setup once, and saving the state of that in memory, and instead of setting up and tearing down, it will simply just copy the relevant layer context as a setup."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "zope.testrunner", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/zope.testrunner"}]}, {"text": ["This speeds up test setup a lot, and is used when you test Zope products and Plone, where the testsetup often needs you to start a Plone CMS server, create a Plone site and add loads of content, a process that can take upwards half a minute.", "Doing that for each test method is obviously impossible, but with layers it is done only once.", "This shortens the test setup and protects the test methods from each other, and therefore means that the testing continues to be determenistic."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "and", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["So I don't know of zope.testrunner will work for you, but it's worth a try."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]