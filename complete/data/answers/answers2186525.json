[[{"text": ["Use os.walk to recursively walk a directory and fnmatch.filter to match against a simple expression:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "os.walk", "tag": "a", "pos": 0, "childList": [{"text": "os.walk", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/os.html#os.walk"}, {"text": "os.walk", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/fnmatch.html?highlight=fnmatch#fnmatch.filter", "text": "fnmatch.filter", "childNum": 1, "tag": "a", "childList": [{"text": "fnmatch.filter", "tag": "code"}]}, {"text": "fnmatch.filter", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import fnmatch\nimport os\n\nmatches = []\nfor root, dirnames, filenames in os.walk('src'):\n  for filename in fnmatch.filter(filenames, '*.c'):\n      matches.append(os.path.join(root, filename))\n</code>\n</pre>\n", "senID": 1}, {"text": ["For Python versions older than 2.2, use glob.glob against each filename instead of fnmatch.filter."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "glob.glob", "tag": "a", "pos": 0, "childList": [{"text": "glob.glob", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/glob.html?highlight=glob#glob.glob"}, {"text": "glob.glob", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/fnmatch.html?highlight=fnmatch#fnmatch.filter", "text": "fnmatch.filter", "childNum": 1, "tag": "a", "childList": [{"text": "fnmatch.filter", "tag": "code"}]}, {"text": "fnmatch.filter", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Similar to other solutions, but using fnmatch.fnmatch instead of glob, since os.walk already listed the filenames:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os, fnmatch\n\n\ndef find_files(directory, pattern):\n    for root, dirs, files in os.walk(directory):\n        for basename in files:\n            if fnmatch.fnmatch(basename, pattern):\n                filename = os.path.join(root, basename)\n                yield filename\n\n\nfor filename in find_files('src', '*.c'):\n    print 'Found C source:', filename\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also, using a generator alows you to process each file as it is found, instead of finding all the files and then processing them."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "and then", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["You'll want to use os.walk to collect filenames that match your criteria.", "For example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "os.walk", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import os\ncfiles = []\nfor root, dirs, files in os.walk('src'):\n  for file in files:\n    if file.endswith('.c'):\n      cfiles.append(os.path.join(root, file))\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import os, fnmatch\n\ndef recursive_glob(treeroot, pattern):\n  results = []\n  for base, dirs, files in os.walk(treeroot):\n    goodfiles = fnmatch.filter(files, pattern)\n    results.extend(os.path.join(base, f) for f in goodfiles)\n  return results\n</code>\n</pre>\n", "senID": 0}, {"text": ["fnmatch gives you exactly the same patterns as glob, so this is really an excellent replacement for glob.glob with very close semantics.", "An iterative version (e.g.", "a generator), IOW a replacement for glob.iglob, is a trivial adaptation (just yield the intermediate results as you go, instead of extending a single results list to return at the end)."], "childNum": 8, "tag": "p", "senID": 1, "childList": [{"text": "fnmatch", "tag": "a", "pos": 0, "childList": [{"text": "fnmatch", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/fnmatch.html?highlight=fnmatch#fnmatch.filter"}, {"text": "fnmatch", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "glob", "tag": "a", "pos": 2, "childList": [{"text": "glob", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/glob.html?highlight=glob#glob.glob"}, {"text": "glob", "childNum": 0, "tag": "code", "childList": []}, {"text": "glob.glob", "childNum": 0, "tag": "code", "childList": []}, {"text": "glob.iglob", "childNum": 0, "tag": "code", "childList": []}, {"text": "yield", "childNum": 0, "tag": "code", "childList": []}, {"text": "extend", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I've modified the glob module to support ** for recursive globbing:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["https://github.com/miracle2k/python-glob2/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "https://github.com/miracle2k/python-glob2/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://github.com/miracle2k/python-glob2/"}]}, {"text": ["Useful when you want to provide your users with the ability to use the ** syntax, and thus  os.walk() alone is not good enough."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's a solution with nested list comprehensions, os.walk and simple suffix matching instead of glob:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "os.walk", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "glob", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import os\ncfiles = [os.path.join(root, filename)\n          for root, dirnames, filenames in os.walk('src')\n          for filename in filenames if filename.endswith('.c')]\n</code>\n</pre>\n", "senID": 1}, {"text": ["It can be compressed to a one-liner:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import os;cfiles=[os.path.join(r,f) for r,d,fs in os.walk('src') for f in fs if f.endswith('.c')]\n</code>\n</pre>\n", "senID": 3}, {"text": ["or generalized as a function:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import os\n\ndef recursive_glob(rootdir='.', suffix=''):\n    return [os.path.join(rootdir, filename)\n            for rootdir, dirnames, filenames in os.walk(rootdir)\n            for filename in filenames if filename.endswith(suffix)]\n\ncfiles = recursive_glob('src', '.c')\n</code>\n</pre>\n", "senID": 5}, {"text": ["If you do need full glob style patterns, you can follow Alex's and\nBruno's example and use fnmatch:"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "glob", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fnmatch", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import fnmatch\nimport os\n\ndef recursive_glob(rootdir='.', pattern='*'):\n    return [os.path.join(rootdir, filename)\n            for rootdir, dirnames, filenames in os.walk(rootdir)\n            for filename in filenames\n            if fnmatch.fnmatch(filename, pattern)]\n\ncfiles = recursive_glob('src', '.c')\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Another way to do it using just the glob module.", "Just seed the rglob method with a starting base directory and a pattern to match and it will return a list of matching file names."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import glob\nimport os\n\ndef _getDirs(base):\n    return [x for x in glob.iglob(os.path.join( base, '*')) if os.path.isdir(x) ]\n\ndef rglob(base, pattern):\n    list = []\n    list.extend(glob.glob(os.path.join(base,pattern)))\n    dirs = _getDirs(base)\n    if len(dirs):\n        for d in dirs:\n            list.extend(rglob(os.path.join(base,d), pattern))\n    return list\n</code>\n</pre>\n", "senID": 1}]]