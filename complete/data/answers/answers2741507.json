[[{"text": ["Development and deployment of Python code is made much easier by setuptools in combination with virtualenv and pip."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "setuptools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://peak.telecommunity.com/DevCenter/setuptools"}, {"href": "http://pypi.python.org/pypi/virtualenv", "text": "virtualenv", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://pypi.python.org/pypi/pip", "text": "pip", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Core ideas"], "childNum": 0, "tag": "h2", "senID": 1, "childList": []}, {"text": ["The trickiest part, I've found, is running a development environment that mirrors the deployed setup as closely as possible, while at the same time respecting Pythonic tools and idioms.", "But it turns out that this is very easy to achieve with pip and setuptools, which together allow you to \"install\" a development tree into a Python environment without moving the files around.", "(Actually setuptools does this all by itself, but pip acts as a front end handle dependencies better."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Another key issue is preparing a clean environment with a known package set across both environments.", "Python's virtualenv is a god-send in this respect, allowing you to configure a completely customised Python environment with your own choice of packages, without requiring root access, or OS packages (rpm or dpkg), and without being constrained by whatever packages and versions thereof that happen to be installed on your distro."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Finally, one annoying bug-bear is the difficulty of creating command-line scripts that play nice with PYTHON_PATH.", "This is also dealt with quite elegantly by setuptools."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Setting up"], "childNum": 0, "tag": "h2", "senID": 5, "childList": []}, {"text": ["(To keep things simple, this is fairly prescriptive.", "Feel free to diverge as appropriate."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Development"], "childNum": 0, "tag": "h2", "senID": 7, "childList": []}, {"text": ["Once your tree structure is ready, you are almost ready to begin coding.", "But right now, packages that depend on each other can't see each other as they will in the deployed environment.", "This problem is resolved with a neat little trick that setuptools offers, and which pip makes use of.", "For each package you are developing, run the following command (make sure you are in the virtual environment for your project, as per step 3, above):"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n $ pip install -e pkg1\n</code>\n</pre>\n", "senID": 9}, {"text": ["This command will install pkg1 into your virtual environment, and it does so without copying any of your files.", "It simply adds a link to the site-packages directory pointing to the package's development root and creates an egg-info directory in that root.", "You can also do this without pip, as follows:"], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "pkg1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "site-packages", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n $ cd pkg1\n$ python setup.py develop\n</code>\n</pre>\n", "senID": 11}, {"text": ["And it will usually work, but if you have third-party dependencies (which should be listed in setup.py, as explained here in the setuptools documentation), pip is smarter about finding them."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://peak.telecommunity.com/DevCenter/setuptools#declaring-dependencies"}]}, {"text": ["One caveat to note is that neither setuptools nor pip have any smarts about finding dependencies amongst your own packages.", "If PkgB in directory B, depends on PkgA in directory A, then pip install -e B will fail, because pip has no way of knowing that PkgA can be found in directory A; it will instead try, and fail, to download PkgA from its online repository sources.", "The workaround is simply to install each package after its dependencies."], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "pip install -e B", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["At this point, you can start python, load up one of your modules and start toying with it.", "You can edit code, and it will be immediately available the next time you import it."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["Finally, if you want to create command-line tools with your packages.", "Don't write them by hand.", "You'll end up with a horrible mess of PYTHON_PATH hacks that never quite works properly.", "Just read up on automatic script creation in the setuptools documentation.", "This will spare you a lot of grief."], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "automatic script creation", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://peak.telecommunity.com/DevCenter/setuptools#automatic-script-creation"}]}, {"text": ["Deployment"], "childNum": 0, "tag": "h2", "senID": 16, "childList": []}, {"text": ["When your packages are ready for action, you can use setup.py to create deployment packages.", "There are way too many options to go into here, but the following should get you started:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n $ cd pkg1\n$ python setup.py --help\n$ python setup.py --help-commands\n</code>\n</pre>\n", "senID": 18}, {"text": ["Loose ends"], "childNum": 0, "tag": "h2", "senID": 19, "childList": []}, {"text": ["Due to the broad nature of the question, this answer is necessarily incomplete.", "I haven't dealt with long-running servers, web frameworks or the actual deployment process itself (in particular, use of pip install's --index-url to manage a private repository of third-party and internal packages and -e vcs+..., which will pull packages out of svn, git, hg or bzr).", "But I hope I've given you enough rope to tie it all together (just don't hang yourself with it :-)."], "childNum": 2, "tag": "p", "senID": 20, "childList": [{"text": "--index-url", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "-e vcs+...", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["I've been working on implementing this for our work projects.", "It's a few different parts involved. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First, we customize virtualenv.py using their bootstrap abilities to add in your own custom post-creation functions and flags.", "These allow us to define common types of projects and also gives us a single command to create a new virtualenv, checkout a project from the git repository, and install any requirements into the virtualenv using pip and requirements.txt \nfiles. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["so our commands look like:\npython venv.py --no-site-packages -g $git_proj -t $tag_num $venv_dir"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://pypi.python.org/pypi/virtualenv\nhttp://pip.openplans.org/"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://pypi.python.org/pypi/virtualenv", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/virtualenv"}]}, {"text": ["Now that gets us through the initial checking out of an existing project.", "As we work and update the project we use fabric commands within each project to build releases and then to deploy them:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["http://docs.fabfile.org/0.9.0/"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "http://docs.fabfile.org/0.9.0/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.fabfile.org/0.9.0/"}]}, {"text": ["I've got a fab command: make_tag which checks for unused commits, opens files that need version strings updated, builds and uploads sphinx docs, and then commits the final tag to the repository. "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["The flip side is a fab deploy command which will, over ssh, do a git co of the tag specified, run a pip update on any new requirements, run any database migrations needed, and then resets the web server if this is a web application. "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Here's an example of the tagging function:\nhttp://www.google.com/codesearch/p?hl=en#9tLIXCbI4vU/fabfile.py&amp;q=fabfile.py%20git%20tag_new_version&amp;sa=N&amp;cd=1&amp;ct=rc&amp;l=143"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "http://www.google.com/codesearch/p?hl=en#9tLIXCbI4vU/fabfile.py&amp;q=fabfile.py%20git%20tag_new_version&amp;sa=N&amp;cd=1&amp;ct=rc&amp;l=143", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.google.com/codesearch/p?hl=en#9tLIXCbI4vU/fabfile.py&q=fabfile.py%20git%20tag_new_version&sa=N&cd=1&ct=rc&l=143"}]}, {"text": ["There are a ton of good fabric files you can browse through using the google code search.", "I know I cheat-sheeted a few for my own use. "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["It's definitely complicated and has several parts in order to get things running smooth.", "Once you get it running though, the flexibility and speed for things is just awesome."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["This is really not hard.", "You need to play mostly with buildout and supervisord IMO."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "buildout", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/zc.buildout"}, {"href": "http://supervisord.org/using.html#introduction", "text": "supervisord", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["While learning buildout may take a little time but it's woth it, given amount of pain it reduces in repeated setups."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["About nohup: nohup approach does not suit serious deployments.", "I have very good experience of supervisord.", "It provides excellent solution for running production python applications.", "It is very easy to setup."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "About nohup:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Some specific answers below."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Have a look at Buildout for reproducible deployments."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Buildout", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.buildout.org"}]}], [{"text": ["Another vote for fabric (haven't tried Buildout yet).", "We've been using it successfully for a couple of months now."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you're having trouble with fabric, another option is Capistrano.", "Works great (even for non-rails apps).", "Only stopped using it because it feels weird to use Ruby to deploy Python apps ;)  "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Capistrano", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.capify.org/index.php/Capistrano"}]}], [{"text": ["I would use rsync to synchronize outwards from your production \"prime\" server to the others, and from your \"beta test\" platform, to your production \"prime\" server."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["rsync has the benefit of copying only those files which changed, and copying only parts of files that changed partially, and verifying the integrity and identical content at the end on all machines.", "An update that gets part way through and is interrupted can easily be continued later, making your deployment more robust."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Subversion or Mercurial would not be a bad idea in this case either.", "Mercurial has the \nadvantage of allowing you to \"pull\" or \"push\" instead of just updating from one central source.", "You might find interesting cases where a decentralized model (mercurial) works better."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["if you are a buildout person, then you should know about minitage.recipe.scripts ability to generate a file to set your python environment.", "Source to your web server and your buildout is completely portable.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "minitage.recipe.scripts", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/minitage.recipe.scripts/1.53#generating-an-envrionment-file"}]}], [{"text": ["It sounds like what you want is a build script.", "So write one, using shell, python, ant, or your favorite build tool.", "If you don't like writing in XML, pant allows you to write ant scripts in python.", "Several people have mentioned buildout but I don't have any experience with it."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "pant", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://myarch.com/pant"}, {"text": "buildout", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://www.buildout.org/"}]}, {"text": ["First define your steps.", "It sounds like you want to:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you're doing load balancing or depending on other services production you might want to figure out a way to roll out limited scope so all your customers aren't affected at once.", "If you have a production-like staging environment that might also satisfy that need."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]