[[{"text": ["List comprehensions can contain nested loops and conditionals:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n nonzeros = [val for y in rows\n                for val in y.cols\n                if val != 0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The difference is relatively small, but you have to write a fully-fledged def including name or a lambda to use nontrivial expressions with map, while you can just go and use them in a list comprehension.", "Also, list comprehensions include filtering while you'd need a seperate filter call for that (inefficient and the parens quickly grow beyond what can be managed easily)."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "relatively", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "filter", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"code": "<pre>\n<code>\n [ str(round(355/113.0, i)) for i in range(1,12) if prime(i) ]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["map requires you to define my_round while the LC does not. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "my_round", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Nobody said the difference was huge ;-)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["As S.Lott implied, list comprehension can do more than map.", "You need both itertools.imap and itertools.ifilter to cover what can be done with a comprehension."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools.imap", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "itertools.ifilter", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n [ str(round(355/113.0, i)) for i in range(1,12) if prime(i) ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["is the same as"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import itertools\nlist(\n   itertools.imap(\n      lambda x: str(round(355/113.0, x)), \n      itertools.ifilter(\n         prime,\n         range(1,12))))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["In the case of your example, it is not map which is providing the flexibility, it is the function definition construct.", "You could also use that function in a list comprehension, but would not need to."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]