[[{"code": "<pre>\n<code>\n # this will result in a=\"length\" and b=\"25\"\na, b = \"length=25\".partition(\"=\")[::2]\n\n# this will result in a=\"DEFAULT_LENGTH\" and b=\"\"\na, b = \"DEFAULT_LENGTH\".partition(\"=\")[::2]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This may be of no use to you unless you're using python 3.", "However, for completeness, it's worth noting that the extended tuple unpacking introduced there allows you do do things like:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "extended tuple unpacking", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3132/"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a, *b = \"length=25\".split(\"=\")\n&gt;&gt;&gt; a,b\n(\"length\", ['25'])\n&gt;&gt;&gt; a, *b = \"DEFAULT_LENGTH\".split(\"=\")\n&gt;&gt;&gt; a,b\n(\"DEFAULT_LENGTH\", [])\n</code>\n</pre>\n", "senID": 1}, {"text": ["ie.", "tuple unpacking now works similarly to how it does in argument unpacking, so you can denote \"the rest of the items\" with *, and get them as a (possibly empty) list."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "*", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Partition is probably the best solution for what you're doing however."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The nicest way is using the partition string method:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "partition string method", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html?highlight=partition#str.partition"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; inputstr = \"length=25\"\n&gt;&gt;&gt; inputstr.partition(\"=\")\n('length', '=', '25')\n&gt;&gt;&gt; name, _, value = inputstr.partition(\"=\")\n&gt;&gt;&gt; print name, value\nlength 25\n</code>\n</pre>\n", "senID": 1}, {"text": ["It also works for strings not containing the =:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "=", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; inputstr = \"DEFAULT_VALUE\"\n&gt;&gt;&gt; inputstr.partition(\"=\")\n('DEFAULT_VALUE', '', '')\n</code>\n</pre>\n", "senID": 3}, {"text": ["If for some reason you are using a version of Python before 2.5, you can use list-slicing to do much the same, if slightly less tidily:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = \"DEFAULT_LENGTH\"\n\n&gt;&gt;&gt; a = x.split(\"=\")[0]\n&gt;&gt;&gt; b = \"=\".join(x.split(\"=\")[1:])\n\n&gt;&gt;&gt; print (a, b)\n('DEFAULT_LENGTH', '')\n</code>\n</pre>\n", "senID": 5}, {"text": ["..and when x = \"length=25\":"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "x = \"length=25\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n ('length', '25')\n</code>\n</pre>\n", "senID": 7}, {"text": ["Easily turned into a function or lambda:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; part = lambda x: (x.split(\"=\")[0], \"=\".join(x.split(\"=\")[1:]))\n&gt;&gt;&gt; part(\"length=25\")\n('length', '25')\n&gt;&gt;&gt; part('DEFAULT_LENGTH')\n('DEFAULT_LENGTH', '')\n</code>\n</pre>\n", "senID": 9}], [{"text": ["You could write a helper function to do it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def pack(values, size):\n...     if len(values) &gt;= size:\n...         return values[:size]\n...     return values + [None] * (size - len(values))\n...\n&gt;&gt;&gt; a, b = pack('a:b:c'.split(':'), 2)\n&gt;&gt;&gt; a, b\n('a', 'b')\n&gt;&gt;&gt; a, b = pack('a'.split(':'), 2)\n&gt;&gt;&gt; a, b\n('a', None)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is slightly better than your solution but still not very elegant; it wouldn't surprise me if there's a better way to do it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a, b = (string.split(\"=\") + [None])[:2]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Don't use this code, it is meant as a joke, but it does what you want: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = b = None\ntry: a, b = [a for a in 'DEFAULT_LENGTH'.split('=')]\nexcept: pass\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Yeah, when I've got cases with limit>1 (so I can't use partition) I usually plump for:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def paddedsplit(s, find, limit):\n    parts= s.split(find, limit)\n    return parts+[parts[0][:0]]*(limit+1-len(parts))\n\nusername, password, hash= paddedsplit(credentials, ':', 2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(parts[0][:0] is there to get an empty \u2018str\u2019 or \u2018unicode\u2019, matching whichever of those the split produced.", "You could use None if you prefer."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "parts[0][:0]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Many other solutions have been proposed, but I have to say the most straightforward to me is still"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a, b = string.split(\"=\") if \"=\" in string else (string, None)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["As an alternative, perhaps use a regular expression?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; unpack_re = re.compile(\"(\\w*)(?:=(\\w*))?\")\n\n&gt;&gt;&gt; x = \"DEFAULT_LENGTH\"\n&gt;&gt;&gt; unpack_re.match(x).groups()\n('DEFAULT_LENGTH', None)\n\n&gt;&gt;&gt; y = \"length=107\"\n&gt;&gt;&gt; unpack_re.match(y).groups()\n('length', '107')\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you make sure the re.match() always succeeds, .groups() will always return the right number of elements to unpack into your tuple, so you can safely do"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a,b = unpack_re.match(x).groups()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Have you tried this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n values = aString.split(\"=\")\nif len(values) == 1:\n   a = values[0]\nelse:\n   a, b = values\n</code>\n</pre>\n", "senID": 1}]]