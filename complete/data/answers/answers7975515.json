[[{"text": ["In almost all Python interpreters that will cause a stack overflow, as it would in C. The higher-level feature that would permit this is called Tail Call Optimization or Tail Recursion Elimination, and the benevolent dictator of Python opposes adding this to the language."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Tail Call Optimization", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Tail_call"}, {"href": "http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html", "text": "the benevolent dictator of Python opposes adding this to the language", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["This style is considered to be non-idiomatic for Python, and a simple while True: loop is preferred."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "while True:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The maximum recursion depth can be retrieved with sys.getrecursionlimit() and set with sys.setrecursionlimit(). "], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "sys.getrecursionlimit()", "tag": "a", "pos": 0, "childList": [{"text": "sys.getrecursionlimit()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/sys.html#sys.getrecursionlimit"}, {"text": "sys.getrecursionlimit()", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/sys.html#sys.setrecursionlimit", "text": "sys.setrecursionlimit()", "childNum": 1, "tag": "a", "childList": [{"text": "sys.setrecursionlimit()", "tag": "code"}]}, {"text": "sys.setrecursionlimit()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Yes.", "CPython has no Tail Recursion Elimination / Last Call Optimization."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def recurse():\n    recurse()\n\nrecurse()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Error:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n# 1000 or so lines of this:\n  File \"\", line 2, in recurse\nRuntimeError: maximum recursion depth exceeded\n</pre>\n", "senID": 4}], [{"text": ["The C version of the Python interpreter (which is probably what you're using) will raise an error eventually if you never return from daemonLoop.", "I'm not sure about other versions."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "daemonLoop", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I don't know why you'd think about doing something like that when you could simply have an infinite while loop.", "Anyway for your question about whether it will work:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "while", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n ...\n  File \"test.py\", line 7, in daemonLoop\n    daemonLoop()\n  File \"test.py\", line 7, in daemonLoop\n    daemonLoop()\nRuntimeError: maximum recursion depth exceeded\n</code>\n</pre>\n", "senID": 1}, {"text": ["So yeah, hell it is."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Probably not a good idea...."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def forever(): forever()\n\nforever()\n</code>\n</pre>\n", "senID": 1}, {"text": ["RuntimeError: maximum recursion depth exceeded"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://paulbarry.com/articles/2009/09/02/infinite-recursion"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://paulbarry.com/articles/2009/09/02/infinite-recursion", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://paulbarry.com/articles/2009/09/02/infinite-recursion"}]}], [{"code": "<pre>\n<code>\n (define forever (lambda () (forever)))\n</code>\n</pre>\n", "senID": 0}, {"text": ["This kind of recursion is what Lisp dialects like Scheme are made for!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]