[[{"text": ["Well, there are separate implementations for separate operating systems.", "This means that if the logic to extract the extension of a file differs on Mac from that on Linux, this distinction will be handled by those things.", "I don't know of any such distinction so there might be none."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "hr", "senID": 1}, {"text": ["Edit: @Brian comments that an example like /directory.ext/file would of course not work with a simple .split('.", "') call, and you would have to know both that directories can use extensions, as well as the fact that on some operating systems, forward slash is a valid directory separator."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "@Brian", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/9493/brian"}, {"text": "/directory.ext/file", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": ".split('.')", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["This just emphasizes the use a library routine unless you have a good reason not to part of my answer."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "use a library routine unless you have a good reason not to", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Thanks @Brian."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "@Brian", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/9493/brian"}]}, {"tag": "hr", "senID": 5}, {"text": ["Additionally, where a file doesn't have an extension, you would have to build in logic to handle that case.", "And what if the thing you try to split is a directory name ending with a backslash?", "No filename nor an extension."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["The rule should be that unless you have a specific reason not to use a library function that does what you want, use it.", "This will avoid you having to maintain and bugfix code others have perfectly good solutions to."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["os.path.splitext will correctly handle the situation where the file has no extension and return an empty string.", ".split will return the name of the file."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["There exist operating systems that do not use \u2018.\u2019 as an extension separator."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(Notably, RISC OS by convention uses \u2018/\u2019, since \u2018.\u2019 is used there as a path separator."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["splitext() does a reverse search for '.", "' and returns the extension portion as soon as it finds it.", "split('.", "') will do a forward search for all '.", "' characters and is therefore almost always slower.", "In other words splitext() is specifically written for returning the extension unlike split()."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "splitext()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "split('.')", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "splitext()", "childNum": 0, "tag": "code", "pos": 5, "childList": []}, {"text": "split()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["(see posixpath.py in the Python source if you want to examine the implementation)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The first and most obvious difference is that the split call has no logic in it to default when there is no extension."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This can also be accomplished by a regex, in order to get it to behave as a 1 liner without extra includes, but still return, empty string if the extension isn't there."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Also, the path library can handle different contexts for paths having different seperators for folders."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The only reason to worry about importing the module is concern for overhead - that's not likely to be a concern in the vast majority of cases, and if it is that tight then it's likely other overhead in Python will be a bigger problem before that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In the comment to the answer that provided this solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Not every file has an extension."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["A clearly defined and documented method to get the file extension would always be preferred over splitting a string willy nilly because that method would be more fragile for various reasons."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Edit: This is not language specific."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Besides being standard and therefore guaranteed to be available, os.path.splitext:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "os.path.splitext", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Handles edge cases - like that of a missing extension.", "Offers guarantees - Besides correctly returning the extension if one exists, it guarantees that root + ext will always return the full path.", "Is cross-platform - in the Python source there are actually three different version of os.path, and they are called based on which operating system Python thinks you are on.", "Is more readable - consider that your version requires users to know that arrays can be indexed with negative numbers.  "], "childNum": 9, "tag": "p", "senID": 1, "childList": [{"text": "Handles edge cases", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "Offers guarantees", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "root", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "ext", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}, {"text": "Is cross-platform", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 3, "childList": []}, {"text": "Is more readable", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["btw, it should not be any faster. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["1) simple split('.", "')[-1] won't work correctly for the path as C:\\foo.bar\\Makefile so you need to extract basename first with os.path.basename(), and even in this case it will fail to split file without extension correctly.", "os.path.splitext do this under the hood."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["2) Despite the fact os.path.splitext is cross-platform solution it's not ideal.", "Let's looking at the special files with leading dot, e.g.", ".cvsignore, .bzrignore, .hgignore (they are very popular in some VCS as special files).", "os.path.splitext will return entire file name as extension, although it does not seems right for me.", "Because in this case name without extension is empty string.", "Although this is intended behavior of Python standard library, it's may be not what user wants actually."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]