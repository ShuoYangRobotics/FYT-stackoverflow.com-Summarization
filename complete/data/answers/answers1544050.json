[[{"text": ["Doing this is possible, but the only solution I can think of is fairly convoluted, non-portable, and probably fraught with problematic details.", "You can use LD_PRELOAD to cause the external application to load a dynamic library which contains a constructor that invokes setvbuf to unbuffer stdout.", "You will probably also want to wrap setvbuf in the library to prevent the application from explicitly buffering its own stdout.", "And you'll want to wrap fwrite and printf so that they flush on each call.", "Writing the .so to be preloaded will take you outside of python.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can use PTYs to solve this by:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Creating a pty master/slave pair;", "tag": "none", "senID": 1}, {"text": "Connecting the child process's stdin, stdout and stderr to the pty slave device;", "tag": "none", "senID": 2}, {"text": "Reading from and writing to the pty master in the parent.", "tag": "none", "senID": 3}]}], [{"text": ["I don't think it's possible.", "If the source application doesn't flush its outgoing buffer, the data will not reach outside that process until the buffer overflows and a flush is forced."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Notice how a well-established command such as file has an option (-n) that causes it to flush its output explicitly.", "This is required when using file in the mode where it reads input file names from a pipe, and prints the detected type.", "Since in this mode, the file program doesn't quit when done, the output would otherwise not appear."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "file", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://linux.about.com/library/cmd/blcmdl1%5Ffile.htm"}]}, {"text": ["Consider this at a lower level: the output buffering simply means that doing write() on a buffered stream copies the data into an in-memory buffer, until the buffer fills up or (typically) until a linefeed is found.", "Then, the part of the buffer up to the overflow or linefeed is written write()n to the underlying system-level file descriptor (which could be a file, a pipe, a socket, ...)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "write()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "write()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I don't understand how you're going to convince that program to flush its buffer, from the outside."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Its worth noting that some programs only buffer their output when they think it's not going to a \"real user\" (ie, a tty).", "When they detect that their output is being read by another program, they buffer."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The emulation of a tty is one of the things that Expect does in automating other processes."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Expect", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://expect.nist.gov/"}]}, {"text": ["There is a pure Python implementation of Expect, but I don't know how well it handles tty emulation."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "pure Python implementation of Expect", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://sourceforge.net/projects/pexpect/"}]}], [{"text": ["The answer to this question might help:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python Run a daemon sub-process &amp; read stdout"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Python Run a daemon sub-process &amp; read stdout", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/5411780/python-run-a-daemon-sub-process-read-stdout"}]}, {"text": ["Seems to be addressing the same issue."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Try running the Python interpreter with the -u argument:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n python -u myscript.py\n</code>\n</pre>\n", "senID": 1}, {"text": ["This forces Python to use unbuffered stdin/stdout which may help you."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]