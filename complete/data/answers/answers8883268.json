[[{"text": ["Starting with your input data:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d = (\n (\"row a\", \"a1\",\"a2\",\"a3\"),\n (\"another row\", \"b1\"),\n (\"c\", \"x\", \"y\", \"a long string\")\n)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Make one pass to determine the maximum size of each column:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; col_size = {}\n&gt;&gt;&gt; for row in d:\n        for i, col in enumerate(row):\n            col_size[i] = max(col_size.get(i, 0), len(col))\n\n&gt;&gt;&gt; ncols = len(col_size)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then make a second pass to pad each column to the required width:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; result = []\n&gt;&gt;&gt; for row in d:\n        row = list(row) + [''] * (ncols - len(row))\n        for i, col in enumerate(row):\n            row[i] = col.ljust(col_size[i])\n        result.append(row)\n</code>\n</pre>\n", "senID": 5}, {"text": ["That gives the desired result:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; pprint(result)\n[['row a      ', 'a1', 'a2', 'a3           '],\n ['another row', 'b1', '  ', '             '],\n ['c          ', 'x ', 'y ', 'a long string']]\n</code>\n</pre>\n", "senID": 7}, {"text": ["For convenience, the steps can be combined into a single function:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def align(array):\n    col_size = {}\n    for row in array:\n        for i, col in enumerate(row):\n            col_size[i] = max(col_size.get(i, 0), len(col))\n    ncols = len(col_size)\n    result = []\n    for row in array:\n        row = list(row) + [''] * (ncols - len(row))\n        for i, col in enumerate(row):\n            row[i] = col.ljust(col_size[i])\n        result.append(row)\n    return result\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Here's what I came up with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\ndef pad_rows(strs):\n   for col in itertools.izip_longest(*strs, fillvalue=\"\"):\n      longest = max(map(len, col))\n      yield map(lambda x: x.ljust(longest), col)\n\ndef pad_strings(strs):\n   return itertools.izip(*pad_rows(strs))\n</code>\n</pre>\n", "senID": 1}, {"text": ["And calling it like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n print tuple(pad_strings(x))\n</code>\n</pre>\n", "senID": 3}, {"text": ["yields this result:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n (('row a      ', 'a1', 'a2', 'a3           '),\n ('another row', 'b1', '  ', '             '),\n ('c          ', 'x ', 'y ', 'a long string'))\n</code>\n</pre>\n", "senID": 5}], [{"text": ["First of all, define a padding function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def padder(lst, pad_by):\n  lengths = [len(x) for x in lst]\n  max_len = max(lengths)\n  return (x + pad_by * (max_len - length) for x, length in zip(lst, lengths))\n</code>\n</pre>\n", "senID": 1}, {"text": ["then pad each entry to the same length by '':"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "''", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a = # your list of list of string\n\na_padded = padder(a, ('',))\n</code>\n</pre>\n", "senID": 3}, {"text": ["then, transpose this list of list so we can work column by column,"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n a_tr = zip(*a_padded)\n</code>\n</pre>\n", "senID": 5}, {"text": ["for each row, we find the maximum length of the strings, and then pad it to the specified length."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n a_tr_strpadded = (padder(x, ' ') for x in a_tr)\n</code>\n</pre>\n", "senID": 7}, {"text": ["finally we transpose it again, and evaluate the result."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n a_strpadded = zip(*a_tr_strpadded)\nreturn [list(x) for x in a_strpadded]\n</code>\n</pre>\n", "senID": 9}, {"text": ["Use tuple(tuple(x) for ...) if you want a tuple of tuple instead of list of list."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "tuple(tuple(x) for ...)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Demo: http://ideone.com/4d0DE"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "http://ideone.com/4d0DE", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ideone.com/4d0DE"}]}], [{"code": "<pre>\n<code>\n import itertools\n\ndef fix_grid(grid):\n    # records the number of cols, and their respective widths\n    cols = []\n    for row in grid:\n        # extend cols with widths of 0 if necessary\n        cols.extend(itertools.repeat(0, max(0, len(row) - len(cols)))\n        for index, value in enumerate(row):\n            # increase any widths in cols if this row has larger entries\n            cols[index] = max(cols[index], len(value)\n    # generate new rows with values widened, and fill in values that are missing \n    for row in grid:           \n        yield tuple(value.ljust(width)\n                    for value, width in itertools.zip_longest(row, cols, ''))\n# create a tuple of fixed rows from the old grid\ngrid = tuple(fix_grid(grid))\n</code>\n</pre>\n", "senID": 0}, {"text": ["See:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["str.ljust"], "childNum": 1, "tag": "a", "senID": 2, "childList": [{"text": "str.ljust", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["itertools.repeat"], "childNum": 1, "tag": "a", "senID": 3, "childList": [{"text": "itertools.repeat", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["itertools.zip_longest"], "childNum": 1, "tag": "a", "senID": 4, "childList": [{"text": "itertools.zip_longest", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}], [{"text": ["I'd suggest you to use list instead of tuple.", "tuples are immutable, and hard to work with."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["First, find the length of the longest row."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n maxlen = max([len(row) for row in yourlist])\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then pad each row by necessary number of strings:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for row in yourlist:\n    row += ['' for i in range(maxlen - len(row))]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Then you can interchange the rows and columns i.e.", "columns should be rows and vice versa.", "For that you can write"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n newlist = [[row[i] for row in yourlist] for i in range(len(row))]\n</code>\n</pre>\n", "senID": 6}, {"text": ["Now, you can take a row (a column of old list) and pad the strings as required."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n for row in newlist:\n    maxlen = max([len(s) for s in row])\n    for i in range(len(row)):\n        row[i] += ' ' * (maxlen - len(row[i]))\n</code>\n</pre>\n", "senID": 8}, {"text": ["Now convert the table back to the original format:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n table = [[row[i] for row in newlist] for i in range(len(row))]\n</code>\n</pre>\n", "senID": 10}, {"text": ["To put it together in a function:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def f(table):\n    maxlen = max([len(row) for row in table])\n    for row in table:\n        row += ['' for i in range(maxlen - len(row))]\n    newtable = [[row[i] for row in table] for i in range(len(row))]\n    for row in newtable:\n        maxlen = max([len(s) for s in row])\n        for i in range(len(row)):\n            row[i] += ' ' * (maxlen - len(row[i]))\n    return [[row[i] for row in newtable] for i in range(len(row))]\n</code>\n</pre>\n", "senID": 12}, {"text": ["This solution works for lists."], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I can only think of doing this by going through it twice - but should not be hard:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def pad_2d_matrix(data):\n    widths = {}\n    for line in data:\n        for index, string in enumerate(line):\n            widths[index] = max(widths.get(index, 0), len(string))\n    result = []\n    max_strings = max(widths.keys())\n    for line in data:\n        result.append([])\n        for index, string in enumerate(line):\n            result[-1].append(string + \" \" * (widths[index] - len(string)   ))\n        for index_2 in range(index, max_strings):\n            result[-1].append(\" \" * widths[index_2])\n    return result\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I agree with everyone else, that there should be two passes.", "Pass 1 computes the maximum width for each column, and pass 2 pads each cell to its column width."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The code below relies on the Python builtin functions map() and reduce().", "The drawback is that the expressions are arguably more cryptic.", "I've tried to offset that with lots of indentation.", "The benefit is that the code benefits from any loop optimisations the implementation has made in these functions."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "map()", "tag": "a", "pos": 0, "childList": [{"text": "map()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#map"}, {"text": "map()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "reduce()", "tag": "a", "pos": -1, "childList": [{"text": "reduce()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#reduce"}, {"text": "reduce()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n g = (\n (\"row a\", \"a1\",\"a2\",\"a3\"),\n (\"another row\", \"b1\"),\n (),     # null row added as a test case\n (\"c\", \"x\", \"y\", \"a long string\")\n)\n\nwidths = reduce(\n        lambda sofar, row: \n            map(\n                lambda longest, cell: \n                    max(longest, 0 if cell is None else len(cell)\n                ), \n            sofar, \n            row\n        ),\n        g, \n        []\n) #reduce()\n\nprint 'widths:', widths\n\nprint 'normalised:', tuple([ \n    tuple(map(\n        lambda cell, width: ('' if cell is None else cell).ljust(width), \n        row, \n        widths\n    )) #tuple(map(\n    for row in g \n]) #tuple([\n</code>\n</pre>\n", "senID": 2}, {"text": ["This gives output (with line breaks added for legibility):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n widths: [11, 2, 2, 13]\nnormalised: (\n    ('row a      ', 'a1', 'a2', 'a3           '), \n    ('another row', 'b1', '  ', '             '), \n    ('           ', '  ', '  ', '             '), \n    ('c          ', 'x ', 'y ', 'a long string')\n)\n</code>\n</pre>\n", "senID": 4}, {"text": ["I've tested this code.", "The ... if cell is None else cell expressions are verbose, but necessary to make the expressions actually work."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "... if cell is None else cell", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["just for fun - one liner"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip_longest as zl\n\n\nt=(\n (\"row a\", \"a1\",\"a2\",\"a3\"),\n (\"another row\", \"b1\"),\n (\"c\", \"x\", \"y\", \"a long string\")\n);\n\n\nb=tuple(tuple((\"{: &lt;\"+str(map(max, ( map(lambda x: len(x) if x else 0,i) for i in zl(*t) ))[i])+\"}\").format(j) for i,j in enumerate(list(k)+[\"\"]*(max(map(len,t))-len(k)))) for k in t)\nprint(b)\n</code>\n</pre>\n", "senID": 1}]]