[[{"code": "<pre>\n<code>\n for k, v in dictionary.iteritems():\n    x = [k] * len(v)\n    y = v\n    pyplot.plot(x, y)\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n d = {1 : [1.2, 2.3, 4.9, 2.0], 2 : [4.1, 5.1, 6.3], 3 : [4.9, 6.8, 9.5, 1.1, 7.1]}\n\nres = [([x]*len(y), y) for x, y in d.iteritems()]\n</code>\n</pre>\n", "senID": 0}, {"text": ["res will be a list of tuples, where the first element in the tuple is your list of x-values and second element in the tuple is your list f y-values"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Maybe something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d = {1 : [1.2, 2.3, 4.9, 2.0], 2 : [4.1, 5.1, 6.3], 3 : [4.9, 6.8, 9.5, 1.1, 7.1]}\nresult = []\nfor key, values in d.items():\n    result.append(([key]*len(values), values))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Use this list comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [([k]*len(v), v) for k, v in D.iteritems()]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here's an example of it being used:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; D = {1: [1.2, 2.3, 4.9, 2.0], 2: [4.1, 5.1, 6.3], 3: [4.9, 6.8, 9.5, 1.1, 7.1]}\n&gt;&gt;&gt; LL = [([k]*len(v), v) for k, v in D.iteritems()]\n&gt;&gt;&gt; pprint(LL)\n[([1, 1, 1, 1], [1.2, 2.2999999999999998, 4.9000000000000004, 2.0]),\n ([2, 2, 2], [4.0999999999999996, 5.0999999999999996, 6.2999999999999998]),\n ([3, 3, 3, 3, 3],\n  [4.9000000000000004,\n   6.7999999999999998,\n   9.5,\n   1.1000000000000001,\n   7.0999999999999996])]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["As a list comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n r = [([k]*len(v), v) for k,v in d.items()]\n</code>\n</pre>\n", "senID": 1}, {"text": ["If your dictionary is very large, you'd want to use a generator expression:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from itertools import repeat\nr = ((repeat(k, len(v)), v) for k,v in d.iteritems())\n</code>\n</pre>\n", "senID": 3}, {"text": ["...though note that using repeat means that the first item in each tuple the generator returns is itself a generator.", "That's unnecessary if the dictionary's values don't themselves have many items."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "repeat", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; d = {1 : [1.2, 2.3, 4.9, 2.0], 2 : [4.1, 5.1, 6.3], 3 : [4.9, 6.8, 9.5, 1.1, 7.1]}\n&gt;&gt;&gt; result = [ ([k] * len(d[k]), d[k]) for k in d.keys() ]\n&gt;&gt;&gt; print result\n[([1, 1, 1, 1], [1.2, 2.2999999999999998, 4.9000000000000004, 2.0]), ([2, 2, 2],\n[4.0999999999999996, 5.0999999999999996, 6.2999999999999998]), ([3, 3, 3, 3, 3],\n[4.9000000000000004, 6.7999999999999998, 9.5, 1.1000000000000001, 7.0999999999999996])]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I guess that a wizard will put something nicer, but I would do something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n map(lambda x: ([x]*len(a[x]),a[x]),a)\n</code>\n</pre>\n", "senID": 1}, {"text": ["for a tuple, or "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n map(lambda x: [[x]*len(a[x]),a[x]],a)\n</code>\n</pre>\n", "senID": 3}, {"text": ["for a list."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["btw: a is the dictionary, of course!"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I assume that you work with the 2.x series...", "Regards"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["the map function in python will allow this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n x = [1,2,4]\ny = [1,24,2]\nc = zip(x,y)\nprint c\nd = map(None,x,y)\nprint d\n</code>\n</pre>\n", "senID": 1}, {"text": ["check it out.", "This will give you"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [(1, 1), (2, 24), (4, 2)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["In the case of zip(), if one of the lists are smaller then the others, values will be truncated:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n x = [1,2,4]\na = [1,2,3,4,5]\nc = zip(x,a)\nprint c\nd = map(None,x,a)\nprint d\n\n[(1, 1), (2, 2), (4, 3)]\n[(1, 1), (2, 2), (4, 3), (None, 4), (None, 5)]\n</code>\n</pre>\n", "senID": 5}]]