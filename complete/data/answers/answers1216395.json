[[{"text": ["There's probably a more efficient way to do this using lists and pairs instead of separate variables for each bracket's limit and rate.", "For instance, consider the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # List of (upper-limit, rate) pairs for brackets.\nbrackets = [ (8350, .10), (33950, .15), (82250, .25), (171550, .28), (372950, .33) ]\n\nif __name__ == '__main__':\n\n    salary = float(raw_input(\"Enter your salary\\n\"))\n\n    accounted_for = 0 # Running total of the portion of salary already taxed\n    taxed = 0 # Running total of tax from portion of salary already examined\n\n    for (limit, rate) in brackets:\n        if salary &lt; limit:\n            taxed += ( (salary - accounted_for) * rate )\n            accounted_for = salary\n            break # We've found the highest tax bracket we need to bother with\n        else:\n            taxed += ( (limit - accounted_for) * rate )\n            accounted_for = limit\n\n    # If we went over the max defined tax bracket, use the final rate\n    if accounted_for &lt; salary:\n        taxed += ( (salary - accounted_for) * 0.35 )\n\n    print taxed\n</code>\n</pre>\n", "senID": 1}, {"text": ["The idea is that we don't want to repeat code we don't have to just because we have multiple items of similar data to work with.", "Tax brackets all function the same, aside from differing rates and limits, so we want those to act as inputs to a standard computation as opposed to their own individual functions."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Particularly when working with financial values, you should consider using the decimal module to make sure that there are no floating-point errors in your output."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "decimal", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/decimal.html"}]}, {"text": ["Not a big deal when you're just making a toy to learn a language, but good to know for future reference :)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["4 space indenting!", "Check out this doc, and the import this output for more.", "Looks pretty good to me though, very easy to read. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "doc", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0008/"}, {"text": "import this", "childNum": 1, "tag": "pre", "pos": -1, "childList": [{"text": "import this", "tag": "code"}]}, {"text": "import this", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["You can change lines like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if salary &gt;= 0 and salary &lt;= first_bracket:\n</code>\n</pre>\n", "senID": 1}, {"text": ["to this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if 0 &lt;= salary &lt;= first_bracket:\n</code>\n</pre>\n", "senID": 3}, {"text": ["like you'd do in mathematics.", "It generally makes the code more readable."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Since those functions are fairly simple you could do something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def b1(a):\n    return a * .10\n</code>\n</pre>\n", "senID": 1}, {"text": ["you could also make one unified taxing function:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def tax_me(salary, rate):\n    return salary * rate\n</code>\n</pre>\n", "senID": 3}, {"text": ["Seems like Dav has ya fixed up pretty good :)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Have fun with Python, its a great language."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Structuring the income and tax-rate data as a table (list of tuples or tuple of tuples) is a huge improvement.", "As shown in that example it allows one to approach the rest of the task with a table driven approach (traverse up the table to find the top rate for a given salary, then traverse from that point downward accumulating taxes and accounting for the total salary)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To make all of this my \"Pythonic\" we'd define the functionality as well as the tax rate table above the if __name__== line.", "This would implicitly allow us to import our file into any other code and use that functionary."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "if __name__==", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The part below the if __name__ == line is then a driver which calls the functionality with any input given (or can be used to hold unit tests, so that any module can be called on to test it's own functionality)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "if __name__ ==", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So our code could look something like:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["#!/usr/bin/env python\ntax_table = (\n(8350, 0.10),\n...\n)\n\ndef compute(salary):\n'''Compute taxes for a given salary'''\nresult = 0\naccounted_for = 0\n...\nreturn result\n\nif __name__ == \"__main__\":\nimport sys\ntry:\nsal = float(raw_input(\"Please enter salary: \")\nexcept EnvironmentError, err:\nprint &gt;&gt; sys.stderr, \"Error with your input, aborting\"\nprint &gt;&gt; sys.stderr, \"The error was:\", err\nsys.exit(1)\nprint compute(sal)\n"], "childNum": 43, "tag": "p", "senID": 4, "childList": [{"text": "#!/usr/bin/env python", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "tax_table = (", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "(8350, 0.10),", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "...", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": ")", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "def compute(salary):", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "'''Compute taxes for a given salary'''", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "result = 0", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "accounted_for = 0", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "...", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "return result", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "if __name__ == \"__main__\":", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "import sys", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "try:", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "sal = float(raw_input(\"Please enter salary: \")", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "except EnvironmentError, err:", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "print &gt;&gt; sys.stderr, \"Error with your input, aborting\"", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "print &gt;&gt; sys.stderr, \"The error was:\", err", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "sys.exit(1)", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "print compute(sal)", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["Notice that we've now separated reusable functionality from our usage ... which allows us to re-use the code ... but also facilitates test-driven development and refactoring.", "We can write non-interactive test suites using our same API (so far just a call to the compute() function) and this will allow us to refactor with confidence (and without touching our usage below --- which is our \"application\" in this case)."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "compute()", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["It's not clear that this particular code would benefit from being refactored into one or more classes.", "Certainly the ability to instantiate a class with a different tax table would be handy.", "Then the tax rate could be stored elsewhere (read from a file, pulled off a web server, or queried out of a database; Python make all of those almost equally easy)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["However, we don't have to go \"OO\" to add that functionality to our compute() function."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "compute()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["We could add an optional parameter to the compute function such that it would use a different tax rate table if we provide one, or default to the one we've hard-coded into the module.", "For that we simple change the initial function definition line to: def compute(salary, table=tax_table): ... and we fix up some handling for the upper limit (factoring the 0.35 rate out of the function and into the table, with either \"sys.maxint\" as our limit or the \"None\" object)."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "def compute(salary, table=tax_table):", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["For such a simple exercise it's not worth much worry.", "But in general it's best to put significant effort into defining our desired APIs up front.", "If you can come up with a robust, flexible API then any conforming implementation that meets your initial requirements (correctness and acceptable performance) will allow you to deliver your application."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["More importantly you can then re-implement at will.", "Perhaps a really complex tax  table needs to be searched using something like the bisect module because the linear searches  take too long to find the top tax rate, or some sorts of income tax credits and deductions or number of dependents need to be passed into the compute() function, etc.", "Ideally such changes can be done transparently.", "None of your existing usage should have to change because you've done a re-implemented the internals of our module.", "Even when you've added functionality you shouldn't need to worry about your existing usage (optional parameters and \"key word\" arguments (dictionaries passed after optional arguments) let us do that for functions, and classes can add attributes and methods without disturbing any proper existing usage.", "(Yes, it's possible for subclassing usage to be broken by some changes; but that should not usually be a problem)."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "bisect", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "compute()", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["In Python one can write something as a simple Python module, later re-implement it as a package or re-impement it as a compiled C module or as a package containing some C modules ... all without affecting the usage.", "From the user's perspective the  import statement works identically on Python modules, packages, and compiled modules (\"shared objects\" or DLLs)."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "import", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["Historically this has been a huge advantage to Python in its own development.", "They've been able to add considerable functionality to existing libraries and only rarely been forced through \"deprecate/rename\" contortions.", "Quite a bit of the functionality slated for Python 3.0 was able to be added to Python 2.7 for this reason."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["Tools like PyLint can catch a lot of errors and bad practices, including bad naming conventions.", "PyChecker is nice too."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "PyLint", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.logilab.org/857"}, {"text": "PyChecker", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pychecker.sourceforge.net/"}]}]]