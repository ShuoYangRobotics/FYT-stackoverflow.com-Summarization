[[{"text": ["Using generators is a Pythonic way to generate long sequences while preserving memory:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fibonacci():\n  a, b = 0, 1\n  while True:\n    yield a\n    a, b = b, a + b\n\nimport itertools\nupto_4000000 = itertools.takewhile(lambda x: x &lt;= 4000000, fibonacci())\nprint(sum(x for x in upto_4000000 if x % 2 == 0))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["First I'd do fibo() as a generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fibo(a=-1,b=1,upto=4000000):\n    while a+b&lt;upto:\n        a,b = b,a+b\n        yield b\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then I'd also select for evenness as a generator rather than a list comprehension."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n print sum(i for i in fibo() if not i%2)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["For one thing, I would suggest summing up the terms as you calculate them rather than storing them in an array and summing the array afterwards, since you don't need to do anything with the individual terms other than adding them up.", "(That's just good computational sense in any language)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I would make the following changes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Use iteration instead of recursion", "tag": "none", "senID": 1}, {"text": "Just keep a running total instead of keeping a list of all Fibonacci numbers and then finding the sum of the even ones a posterior", "tag": "none", "senID": 2}]}, {"text": ["Other than that, it's reasonably Pythonic."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "reasonably", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def even_fib_sum(limit):\n    a,b,sum = 0,1,0\n    while a &lt;= limit:\n        if a%2 == 0:\n            sum += a\n        a,b = b,a+b\n    return sum\n\nprint(even_fib_sum(4000000))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I'd use the fibonacci generator as in @constantin' answer but generator expressions could be replaced by a plain for loop:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "@constantin' answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/578379/python-program-to-find-fibonacci-series-more-pythonic-way/578424#578424"}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def fibonacci(a=0, b=1):\n    while True:\n        yield a\n        a, b = b, a + b\n\nsum_ = 0\nfor f in fibonacci():\n    if f &gt; 4000000:\n       break\n    if f % 2 == 0:\n       sum_ += f\n\nprint sum_\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's an alternate direct method\nIt relies on a few properties:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Point 4 can be seen from this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n Sum of first 3N fibonacci numbers\n   =(F(1) + F(2))+ F(3) +(F(4) + F(5))+ F(6) + ... +(F(3N-2) + F(3N-1))+ F(3N) \n   =     F(3)    + F(3) +     F(6)    + F(6) + ... +       F(3N)       + F(3N)\n   = 2( F(3) + F(6) + ... + F(3N) )\n   = 2 ( Sum of odd fibonacci numbers up to F(3N) )\n</code>\n</pre>\n", "senID": 2}, {"text": ["So convert our maximum value of 4000000 calculate the index of the highest Fibonacci number\nless than it. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n int n = floor(log(4000000*sqrt(5))/log(phi));  // ( = 33)\n</code>\n</pre>\n", "senID": 4}, {"text": ["33 is divisible by 3 so it is an even Fibonacci number, if it wasn't we'd need to adjust n like this."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n n = (n/3)*3;\n</code>\n</pre>\n", "senID": 6}, {"text": ["The sum of all Fibonacci numbers up to this point if given by"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n sum = floor( pow( phi, n+2 ) + 0.5 ) - 1; // ( = 9227464 )\n</code>\n</pre>\n", "senID": 8}, {"text": ["The sum of all even numbers is half of this:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n sum_even = sum/2; // ( = 4613732 )\n</code>\n</pre>\n", "senID": 10}, {"text": ["Nice thing about this is that its an O(1) (or O(log(N)) if you include the cost of pow/log) algorithm, and works on doubles.. so we can calculate the sum for very large values."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["NOTE: I edited and moved this answer from a closed duplicate of this question.", "http://stackoverflow.com/questions/3270863"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "http://stackoverflow.com/questions/3270863", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3270863"}]}], [{"text": ["In Python 3 at least if you give a generator to the sum function it will lazily evaluate it so there is no need to reinvent the wheel."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This is what @Constantin did and is correct."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Tested by comparing the memory usage of using generators:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["sum(range(9999999))"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "sum(range(9999999))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["compared with not doing so:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["sum(list(range(9999999)))"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "sum(list(range(9999999)))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The one with the generator does not cause memory exceptions with higher numbers either."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]