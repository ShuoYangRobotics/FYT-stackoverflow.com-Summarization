[[{"text": ["Here is the zip way"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def mapper(keys, values):\n    n = len(keys)\n    return [dict(zip(keys, values[i:i + n]))\n            for i in range(0, len(values), n)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It's not pretty but here's a one-liner using a list comprehension, zip and stepping:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [dict(zip(keys, a)) for a in zip(values[::2], values[1::2])]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Dumb way, but one that comes immediately to my mind:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fields_from_list(keys, values):\n    iterator = iter(values)\n    while True:\n        yield dict((key, iterator.next()) for key in keys)\n\nlist(fields_from_list(keys, values)) # to produce a list.\n</code>\n</pre>\n", "senID": 1}], [{"text": ["zip nearly does what you want; unfortunately, rather than cycling the shorter list, it breaks.", "Perhaps there's a related function that cycles?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ python\n&gt;&gt;&gt; keys = ['name', 'age']\n&gt;&gt;&gt; values = ['Monty', 42, 'Matt', 28, 'Frank', 33]\n&gt;&gt;&gt; dict(zip(keys, values))\n{'age': 42, 'name': 'Monty'}\n</code>\n</pre>\n", "senID": 1}, {"text": ["/EDIT: Oh, you want a list of dict.", "The following works (thanks to Peter, as well):"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "list", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n from itertoos import cycle\n\nkeys = ['name', 'age']\nvalues = ['Monty', 42, 'Matt', 28, 'Frank', 33]\n\nx = zip(cycle(keys), values)\nmap(lambda a: dict(a), zip(x[::2], x[1::2]))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["In the answer by Konrad Rudolph"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Konrad Rudolph", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/244438/map-two-lists-into-one-single-list-of-dictionaries#244461"}]}, {"text": ["Here's a way:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n keys = ['name', 'age']\nvalues = ['Monty', 42, 'Matt', 28, 'Frank', 33]\niter_values = iter(values)\n[dict(zip(keys, iter_values)) for _ in range(len(values) // len(keys))]\n</code>\n</pre>\n", "senID": 2}, {"text": ["I will not call it Pythonic (I think it's too clever), but it might be what are looking for."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["There is no benefit in cycling the keys list using itertools.cycle(), because each traversal of keys corresponds to the creation of one dictionnary."], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "keys", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://www.python.org/doc/2.5.2/lib/itertools-functions.html", "text": "itertools", "childNum": 1, "tag": "a", "childList": [{"text": "itertools", "tag": "code"}]}, {"text": "itertools", "childNum": 0, "tag": "code", "childList": []}, {"text": ".cycle()", "childNum": 0, "tag": "code", "childList": []}, {"text": "keys", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["EDIT: Here's another way:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def iter_cut(seq, size):\n    for i in range(len(seq) / size):\n        yield seq[i*size:(i+1)*size]\n\nkeys = ['name', 'age']\nvalues = ['Monty', 42, 'Matt', 28, 'Frank', 33]\n[dict(zip(keys, some_values)) for some_values in iter_cut(values, len(keys))]\n</code>\n</pre>\n", "senID": 6}, {"text": ["This is much more pythonic: there's a readable utility function with a clear purpose, and the rest of the code flows naturally from it."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Here's my simple approach.", "It seems to be close to the idea that @Cheery had except that I destroy the input list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def pack(keys, values):\n  \"\"\"This function destructively creates a list of dictionaries from the input lists.\"\"\"\n  retval = []\n  while values:\n    d = {}\n    for x in keys:\n      d[x] = values.pop(0)\n    retval.append(d)\n  return retval\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Yet another try, perhaps dumber than the first one:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def split_seq(seq, count):\n    i = iter(seq)\n    while True:\n        yield [i.next() for _ in xrange(count)]\n\n&gt;&gt;&gt; [dict(zip(keys, rec)) for rec in split_seq(values, len(keys))]\n[{'age': 42, 'name': 'Monty'},\n {'age': 28, 'name': 'Matt'},\n {'age': 33, 'name': 'Frank'}]\n</code>\n</pre>\n", "senID": 1}, {"text": ["But it's up to you to decide whether it's dumber."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n [dict(zip(keys,values[n:n+len(keys)])) for n in xrange(0,len(values),len(keys)) ]\n</code>\n</pre>\n", "senID": 0}, {"text": ["UG-LEEE.", "I'd hate to see code that looks like that.", "But it looks right."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def dictizer(keys, values):\n   steps = xrange(0,len(values),len(keys))\n   bites = ( values[n:n+len(keys)] for n in steps)\n   return ( dict(zip(keys,bite)) for bite in bites )\n</code>\n</pre>\n", "senID": 2}, {"text": ["Still a little ugly, but the names help make sense of it."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]