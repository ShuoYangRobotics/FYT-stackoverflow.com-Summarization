[[{"text": ["struct and array, which other answers recommend, are fine for the details of the implementation, and might be all you need if your needs are always to sequentially read all of the file or a prefix of it.", "Other options include buffer, mmap, even ctypes, depending on many details you don't mention regarding your exact needs.", "Maybe a little specialized Cython-coded helper can offer all the extra performance you need, if no suitable and accessible library (in C, C++, Fortran, ...) already exists that can be interfaced for the purpose of handling this humongous file as you need to."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "struct", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "array", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "buffer", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html?highlight=buffer#buffer"}, {"text": "mmap", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/mmap.html"}, {"text": "ctypes", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/ctypes.html"}]}, {"text": ["But clearly there are peculiar issues here -- how can a data file contain pointers, for example, which are intrinsically a concept related to addressing memory?", "Are they maybe \"offsets\" instead, and, if so, how exactly are they based and coded?", "Are your needs at all more advanced than simply sequential reading (e.g., random access), and if so, can you do a first \"indexing\" pass to get all the offsets from start of file to start of record into a more usable, compact, handily-formatted auxiliary file?", "(That binary file of offsets would be a natural for array -- unless the offsets need to be longer than array supports on your machine!).", "What is the distribution of record lengths and compositions and number of records to make up the \"tens of gigabytes\"?", "Etc, etc."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "pointers", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "memory", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "That", "childNum": 0, "tag": "em", "pos": 3, "childList": []}, {"text": "array", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "array", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["You have a very large scale problem (and no doubt very large scale hardware to support it, since you mention that you can easily read all of the file into memory that means a 64bit box with many tens of GB of RAM -- wow!", "), so it's well worth the detailed care to optimize the handling thereof -- but we can't help much with such detailed care unless we know enough detail to do so!-)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["have a look at array module, specifically at array.fromfile method.", "This bit:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "array", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "array.fromfile", "tag": "a", "pos": -1, "childList": [{"text": "array.fromfile", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/array.html#array.array.fromfile"}, {"text": "array.fromfile", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["is rather unfortunate.", "but you could handle it with a try-except clause."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["For a similar task, I defined a class like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class foo(Structure):\n        _fields_ = [(\"myint\", c_uint32)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["created an instance"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n bar = foo()\n</code>\n</pre>\n", "senID": 3}, {"text": ["and did,"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n block = file.read(sizeof(bar))\nmemmove(addressof(bar), block, sizeof(bar))\n</code>\n</pre>\n", "senID": 5}, {"text": ["In the event of variable-size records, you can use a similar method for retrieving lenN, and then read the corresponding data entries.", "Seems trivial to implement.", "However, I have no idea of how fast this method is compared to using pack() and unpack(), perhaps someone else has profiled both methods."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "lenN", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "pack()", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "unpack()", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["For help with parsing the file without reading it into memory you can use the bitstring module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "bitstring", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://python-bitstring.googlecode.com"}]}, {"text": ["Internally this is using the struct module and a bytearray, but an immutable Bits object can be initialised with a filename so it won't read it all into memory."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from bitstring import Bits\n\ns = Bits(filename='your_file')\nwhile s.bytepos != s.length:\n    # Read a byte and interpret as an unsigned integer\n    length = s.read('uint:8')\n    # Read 'length' bytes and convert to a Python string\n    data = s.read(length*8).bytes\n    # Now do whatever you want with the data\n</code>\n</pre>\n", "senID": 3}, {"text": ["Of course you can parse the data however you want."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You can also use slice notation to read the file contents, although note that the indices will be in bits rather than bytes so for example s[-800:] would be the final 100 bytes."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "s[-800:]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["What if you use dump the data file into sqlite3 in memory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sqlite3\nsqlite3.Connection(\":memory:\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can then use sql to process the data."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Besides, you might want to look at generators (or here) and iterators (or here and here)."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "generators", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html#generators"}, {"href": "http://diveintopython3.org/generators.html", "text": "here", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://docs.python.org/tutorial/classes.html#iterators", "text": "iterators", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://diveintopython3.org/advanced-iterators.html", "text": "here", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://diveintopython3.org/iterators.html", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["PyTables is a very good library to handle HDF5, a binary format used in astronomy and meteorology to handle very big datasets:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": ["PyTables"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}]}, {"text": ["It works more or less like an hierarchical database, where you can store multiple tables, inside columns.", "Have a look at it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]