[[{"text": ["From the comment -- not the question."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\"I am simply curious to see if what I am trying to do is possible."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The answer to \"is it possible\" is always \"yes\".", "Always.", "Unless your question involves time travel, anti-gravity or perpetual motion.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Since the answer is always \"yes\", your question is ill-formed.", "The real question is \"what's a good way to have my logging module know the name of the client?", "\" or something like that."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The answer is \"Accept it as a parameter.", "\"  Don't mess around with inspecting or looking for mysterious globals or other tricks."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Just follow the design pattern of logging.getLogger() and use explicitly-named loggers.", "A common idiom is the following"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n logger= logging.getLogger( __name__ )\n</code>\n</pre>\n", "senID": 6}, {"text": ["That handles almost all log naming perfectly."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I think what you want to use is the inspect module, to inspect the python runtime stack.", "Check out this tutorial.", "I think it provides an almost exact example of what you want to do."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "inspect", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/inspect.html"}, {"text": "tutorial", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://telin.ugent.be/~slippens/drupal/node/148"}]}], [{"text": ["The \"currently executing module\" clearly is foo, as that's what contains the function currently running - I think a better description as to what you want is the module of foo's immediate caller (which may itself be foo if you're calling a f() from a function in foo called by a function in bar.", "How far you want to go up depends on what you want this for."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In any case, assuming you want the immediate caller, you can obtain this by walking up the call stack.", "This can be accomplished by calling sys._getframe, with the aprropriate number of levels to walk."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "sys._getframe", "tag": "a", "pos": 1, "childList": [{"text": "sys._getframe", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/sys.html#sys.%5Fgetframe"}, {"text": "sys._getframe", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def f():\n    caller = sys._getframe(1)  # Obtain calling frame\n    print \"Called from module\", caller.f_globals['__name__']\n</code>\n</pre>\n", "senID": 2}, {"text": ["[Edit]:  Actually, using the inspect module as suggested above is probably a cleaner way of obtaining the stack frame.", "The equivalent code is:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "[Edit]", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "inspect", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/inspect.htm"}]}, {"code": "<pre>\n<code>\n def f():\n    caller = inspect.currentframe().f_back\n    print \"Called from module\", caller.f_globals['__name__']\n</code>\n</pre>\n", "senID": 4}, {"text": ["(sys._getframe is documented as being for internal use - the inspect module is a more reliable API)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I don't believe that's possible since that's out of foo's scope.", "foo will only be aware of its internal scope since it may be being called by countless other modules and applications."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["__file__ is the path of current module the call is made."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__file__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["It's been a while since I've done python, but I believe that you can get access to the globals and locals of a caller through its traceback."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "traceback", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/traceback.html"}]}], [{"text": ["This should work for referencing the current module:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\nsys.modules[__name__]\n</code>\n</pre>\n", "senID": 1}]]