[[{"text": ["Some quick points:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "You should not name Python source files \".txt\", you should use \".py\".", "tag": "none", "senID": 1}, {"text": "Your indents look wrong, but that might just be Stack Overflow.", "tag": "none", "senID": 2}, {"text": "You need to call the ", "tag": "none", "senID": 3}, {"text": "The ", "tag": "none", "senID": 4}, {"text": "When ", "tag": "none", "senID": 5}]}], [{"text": ["In addition to all of the other hints and tips, I think you're missing something crucial: your functions actually need to return something."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "return", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["When you create autoparts() or splittext(), the idea is that this will be a function that you can call, and it can (and should) give something back."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "autoparts()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "splittext()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Once you figure out the output that you want your function to have, you need to put it in a return statement."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "return", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For example, if you wanted to splittext to return the list of words, rather than print them, you would need the line return words.", "If you want your autoparts to return the dictionary you've built, you would use return dictionary."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "splittext", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return words", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "autoparts", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "return dictionary", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To be more precise (and to answer your comment/question below): you don't want to \"return a function that makes a dictionary\"; you want to return the dictionary while inside the function.", "So, the last line of your function should be return dictionary (inside the function!", ") See, for example, the (accepted!", ") solution from dbr, above."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "return dictionary", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I think you need to go back to the beginning and read a book or website about python in particular and programming in general, since you are slightly rusty on some of the concepts.", "One good one (others are available, of course) is http://diveintopython.org/"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "http://diveintopython.org/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://diveintopython.org/"}]}], [{"text": ["As people have pointed out, you need to use the py extension for python source files.", "Your files would become \"functiondoc.py\" and \"program.py\".", "This will make your import functiondoc work correctly (as long as they are in the same directory)"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "import functiondoc", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["The biggest problem with the autoparts function is you never returned anything.", "The other big problem is you used the wrong variable.."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "autoparts", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for line in list_of_parts:\n    k, v = line.split()\n    list1.append(k)\n    list2.append(v)\n\n# k and v are now the last line split up, *not* the list you've been constructing.\n# The following incorrect line:\ndictionary = dict(zip(k, v))\n# ...should be:\ndictionary = dict(zip(list1, list2))\n# ..although you shouldn't use zip for this:\n</code>\n</pre>\n", "senID": 2}, {"text": ["You almost never have to use zip, there are times when it can be useful, but for creating a simple dict, it's incorrect..", "Instead of doing.."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "never", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "zip", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n for line in list_of_parts:\n    ...\ndictionary = dict(zip(k, v))\n</code>\n</pre>\n", "senID": 4}, {"text": ["..simply create an empty dict before the loop, then do mydict[key_variable] = value_variable"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["For example, how I might have written the function.."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def autoparts():\n    # open() returns a file object, not the contents of the file,\n    # you need to use .read() or .readlines() to get the actual text\n    input_file = open('list_of_parts.txt', 'r')\n    all_lines = input_file.read_lines() # reads files as a list (one index per line)\n\n    mydict = {} # initialise a empty dictionary\n\n    for line in list_of_parts:\n        k, v = line.split()\n        mydict[k] = v\n\n    return mydict # you have to explicitly return stuff, or it returns None\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Don't bother creating the lists first, just go straight to the dictionary:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n parts_dict={}\nlist_of_parts = open('list_of_parts.txt', 'r')\nfor line in list_of_parts:\n        k, v = line.split()\n        parts_dict[k] = v\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also, are these keys unique?", "Because if not some of the values will get overwritten."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["There are a lot of problems with what you've written so far, but your question was how to call the auto parts function.", "Here's how; first, rename your files to functiondocs.py and program.py - they're python so make them python files."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Next, to call the autoparts function, you simply change your main program listing from:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from functiondoc import *\n\n# A and B are keys in the dict. The values are 'rear_bumper' 'back_seat'\ntext = 'A B'    # Input\n\n# Splits the input into separate strings.\ninput_ = split_line(text)\n</code>\n</pre>\n", "senID": 2}, {"text": ["to:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from functiondoc import *\n\n# Call the autparts function\nautoparts()\n</code>\n</pre>\n", "senID": 4}, {"text": ["In my opinion, it looks like you're asking us to do a CS homework assignment.. but maybe I'm just cynical ;-)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Here's about the simplest way you could do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def filetodict(filename):\n    return dict(line.split() for line in open(filename))\n\nparts = filetodict(\"list_of_parts.txt\")\nprint parts\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here's the output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {'a': 'apple', 'c': 'cheese', 'b': 'bacon', 'e': 'egg', 'd': 'donut'}\n</code>\n</pre>\n", "senID": 3}, {"text": ["The file contents:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n a apple\nb bacon\nc cheese\nd donut\ne egg\n</code>\n</pre>\n", "senID": 5}]]