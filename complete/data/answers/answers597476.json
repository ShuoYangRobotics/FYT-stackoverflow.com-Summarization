[[{"text": ["Generally speaking, in these sorts of situations, you want to make the code \"data driven\".", "That is, put the important information in a container, and loop through it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In your case, the important information is (string, function) pairs."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef fun1():\n    print('fun1')\n\ndef fun2():\n    print('fun2')\n\ndef fun3():\n    print('fun3')\n\nregex_handlers = [\n    (r'regex1', fun1),\n    (r'regex2', fun2),\n    (r'regex3', fun3)\n    ]\n\ndef example(string):\n    for regex, fun in regex_handlers:\n        if re.match(regex, string):\n            fun()  # call the function\n            break\n\nexample('regex2')\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Similar question from back in september: How do you translate this regular-expression idiom from Perl into Python?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "How do you translate this regular-expression idiom from Perl into Python?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/122277"}]}, {"text": ["Using global variables in a module maybe not the best way to do it, but converting it into a class:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nclass Re(object):\n  def __init__(self):\n    self.last_match = None\n  def match(self,pattern,text):\n    self.last_match = re.match(pattern,text)\n    return self.last_match\n  def search(self,pattern,text):\n    self.last_match = re.search(pattern,text)\n    return self.last_match\n\ngre = Re()\nif gre.match(r'foo',text):\n  # do something with gre.last_match\nelif gre.match(r'bar',text):\n  # do something with gre.last_match\nelse:\n  # do something else\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I had the same problem as yours.", "Here\u00b4s my solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nregexp = {\n    'key1': re.compile(r'regexp1'),\n    'key2': re.compile(r'regexp2'),\n    'key3': re.compile(r'regexp3'),\n    # ...\n}\n\ndef test_all_regexp(string):\n    for key, pattern in regexp.items():\n        m = pattern.match(string)\n        if m:\n            # do what you want\n            break\n</code>\n</pre>\n", "senID": 1}, {"text": ["It\u00b4s a slightly modified solution from the answer of Extracting info from large structured text files"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Extracting info from large structured text files", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/481862/extracting-info-from-large-structured-text-files"}]}], [{"text": ["Hmm... you could use something with the with construct... um"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "with", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "with", "tag": "code"}]}, {"text": "with", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class rewrapper()\n    def __init__(self, pattern, target):\n        something\n\n    def __enter__(self):\n        something\n\n    def __exit__(self):\n        something\n\n\n with rewrapper(\"regex1\", string) as match:\n    etc\n\n with rewrapper(\"regex2\", string) as match: \n    and so forth\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Are the manipulations for each regex similar?", "If so, try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for regex in ('regex1', 'regex2', 'regex3', 'regex4'):\n    match = re.match(regex, string)\n    if match:\n        # Manipulate match.group(n)\n        return result\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here your regexs and matches are not repeated twice:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n match = re.match('regex1', string)\nif match:\n    # do stuff\n    return\n\nmatch = re.match('regex2', string)\nif match:\n    # do stuff\n    return\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n class RegexStore(object):\n   _searches = None\n\n   def __init__(self, pat_list):\n      # build RegEx searches\n      self._searches = [(name,re.compile(pat, re.VERBOSE)) for\n                        name,pat in pat_list]\n\n   def match( self, text ):\n      match_all = ((x,y.match(text)) for x,y in self._searches)\n      try:\n         return ifilter(op.itemgetter(1), match_all).next()\n      except StopIteration, e:\n         # instead of 'name', in first arg, return bad 'text' line\n         return (text,None)\n</code>\n</pre>\n", "senID": 0}, {"text": ["You can use this class like so:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n rs = RegexStore( (('pat1', r'.*STRING1.*'),\n                  ('pat2', r'.*STRING2.*')) )\nname,match = rs.match( \"MY SAMPLE STRING1\" )\n\nif name == 'pat1':\n   print 'found pat1'\nelif name == 'pat2':\n   print 'found pat2'\n</code>\n</pre>\n", "senID": 2}]]