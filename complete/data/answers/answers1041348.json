[[{"text": ["The line that your error is on should read"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if number == 0:\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note the colon on the end."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Additionally, you would need to add the same colon after the else and the for.", "The colons work similarly to {} in other languages."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Finally, thats not how for loops work in Python.", "The code you want to use that list would be"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n for x in range(1,number):\n</code>\n</pre>\n", "senID": 5}, {"text": ["Which would have the same effect of what you wrote, if you put that in a C style language."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["EDIT: Oops, the for loop I gave was wrong, it would have included 0.", "I updated the code to correct this."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I understand that you are probably trying to implement this yourself for educational reasons."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, if not, I recommend using the math modules built-in factorial function (note: requires python 2.6 or higher):"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "math", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import math\n&gt;&gt;&gt; math.factorial(5)\n120\n</code>\n</pre>\n", "senID": 2}, {"text": ["This module is written in C, and as such, it'll be much much faster than writing it in python.", "(although, if you aren't computing large factorials, it won't really be too slow either way)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Here's your code, fixed up and working:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\nnumber = int(sys.argv[1])\nfact = 1\nfor x in range(1, number+1):\n    fact *= x\n\nprint fact\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Factorial zero is one, for anyone who didn't know - I had to look it up.", "8-)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You need colons after if, else, for, etc., and the way for works in Python is different from C."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "else", "childNum": 0, "tag": "code", "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Here's a functional factorial, which you almost asked for:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def fact(n): return reduce (lambda x,y: x*y, range(1,n+1))\n... \n&gt;&gt;&gt; fact(5)\n120\n</code>\n</pre>\n", "senID": 1}, {"text": ["It doesn't work for fact(0), but you can worry about that outside the scope of fact :)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "fact", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "hr", "senID": 3}, {"text": ["Masi has asked whether the functional style is more efficient than Richie's implementation.", "According to my quick benchmark (and to my surprise!", ") yes, mine is faster.", "But there's a couple things we can do to change."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["First, we can substitute lambda x,y: x*y with operator.mul as suggested in another comment.", "Python's lambda operator comes with a not-insignificant overhead.", "Second, we can substitute xrange for range.", "xrange should work in linear space, returning numbers as necessary, while range creates the whole list all at once.", "(Note then, that you almost certainly must use xrange for an excessively large range of numbers)"], "childNum": 8, "tag": "p", "senID": 5, "childList": [{"text": "lambda x,y: x*y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "operator.mul", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "xrange", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "range", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "xrange", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "range", "childNum": 0, "tag": "code", "childList": []}, {"text": "xrange", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So the new definition becomes:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import operator\n&gt;&gt;&gt; def fact2(n): return reduce(operator.mul, xrange(1,n+1))\n... \n&gt;&gt;&gt; fact2(5)\n120\n</code>\n</pre>\n", "senID": 7}, {"text": ["To my surprise, this actually resulted in slower performance.", "Here's the Q&amp;D benchmarks:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def fact(n): return (lambda x,y: x*y, range(1,n+1))\n... \n&gt;&gt;&gt; t1 = Timer(\"fact(500)\", \"from __main__ import fact\")\n&gt;&gt;&gt; print t1.timeit(number = 500)\n0.00656795501709\n\n&gt;&gt;&gt; def fact2(n): return reduce(operator.mul, xrange(1,n+1))\n...\n&gt;&gt;&gt; t2 = Timer(\"fact2(500)\", \"from __main__ import fact2\")\n&gt;&gt;&gt; print t2.timeit(number = 500)\n0.35856294632\n\n&gt;&gt;&gt; def fact3(n): return reduce(operator.mul, range(1,n+1))\n... \n&gt;&gt;&gt; t3 = Timer(\"fact3(500)\", \"from __main__ import fact3\")\n&gt;&gt;&gt; print t3.timeit(number = 500)\n0.354646205902\n\n&gt;&gt;&gt; def fact4(n): return reduce(lambda x,y: x*y, xrange(1,n+1))\n... \n&gt;&gt;&gt; t4 = Timer(\"fact4(500)\", \"from __main__ import fact4\")\n&gt;&gt;&gt; print t4.timeit(number = 500)\n0.479015111923\n\n&gt;&gt;&gt; def fact5(n):\n...     x = 1\n...     for i in range(1, n+1):\n...             x *= i\n...     return x\n... \n&gt;&gt;&gt; t5 = Timer(\"fact5(500)\", \"from __main__ import fact5\")\n&gt;&gt;&gt; print t5.timeit(number = 500)\n0.388549804688\n</code>\n</pre>\n", "senID": 9}, {"text": ["Here's my Python version in case anyone wants to cross-check my results:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n Python 2.6.2 (release26-maint, Apr 19 2009, 01:56:41) \n[GCC 4.3.3] on linux2\n</code>\n</pre>\n", "senID": 11}], [{"text": ["really, the simplest option would be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def factorial(n):\n    x = n\n    for j in range(1, n):\n        x = j*x\n    return x\n</code>\n</pre>\n", "senID": 1}, {"text": ["yes, somehow, it works."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["How could you not think of this?", "I don't know."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["A for loop and a multiplier, really simplicity is the best way to go, right?"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["EDIT: Oh, wait, we're working for the most cpu-efficeint way?", "ohhhh....."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["A correct implementation of fact (returning 1 for fact(0)) is as follow:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fact(n): return reduce(operator.mul, xrange(2,n+1), 1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is slightly faster (1.18 time faster) than the more readable "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def fact1(n):\n    x = 1\n    for i in xrange(2,n+1):\n        x*=i\n    return x\n</code>\n</pre>\n", "senID": 3}, {"text": ["P.S: the one can be skipped in both iterations because multiplying by one does not change the value"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["P.P.S: After timing, math.factorial seems slower than reduce:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; t1 = Timer(\"factorial(1000)\", \"from math import factorial\")\n&gt;&gt;&gt; t1.timeit(number=1000)\n0.8635700906120749\n&gt;&gt;&gt; def fact(n): return reduce(operator.mul, xrange(2,n+1), 1)\n&gt;&gt;&gt; t2 = Timer(\"fact(1000)\", 'from __main__ import fact')\n&gt;&gt;&gt; t2.timeit(number=1000)\n0.78937295103149552\n</code>\n</pre>\n", "senID": 6}, {"text": ["The tests were done with python 2.6.2 on win32. "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["But I agree that the speed-up is probably not sufficient to justify writing your own  factorial and math.factorial do some error checking (input must be a non negative integer)"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["The reason Mark Rushakoff's fact(n) function was so much more efficient was that he missed-off the reduce() function.", "Thus it never actually did the calculation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Corrected it reads (and I get):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import operator, timeit, math\n#\ndef fact1(n):  return reduce(lambda x,y: x*y,  range(1,n+1),1)\ndef fact1x(n): return reduce(lambda x,y: x*y, xrange(1,n+1),1)\ndef fact2(n):  return reduce(operator.mul   ,  range(1,n+1),1)\ndef fact2x(n): return reduce(operator.mul   , xrange(1,n+1),1)\n#\ndef factorialtimer():\n    for myfunc in [ \"fact1\", \"fact1x\", \"fact2\", \"fact2x\" ]:\n        mytimer = timeit.Timer(myfunc+\"(1500)\", \"from __main__ import \"+myfunc)\n        print(\"{0:15} : {1:2.6f}\".format(myfunc, mytimer.timeit(number=1000)))\n\n    mytimer = timeit.Timer(\"factorial(1500)\", \"from math import factorial\")\n    print(\"{0:15} : {1:2.6f}\".format(\"math.factorial\", mytimer.timeit(number=1000)))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Resulting output for 1500!, 1000x:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n fact1           : 3.537624\nfact1x          : 4.448408\nfact2           : 4.390820\nfact2x          : 4.333070\nmath.factorial  : 4.091470\n</code>\n</pre>\n", "senID": 4}, {"text": ["And yes, I have checked they all yield the same value!", "I Can't understand why the lambda xrange is so much worse than the lambda range.", "Hmmm.", "Version: \nPythonWin 2.6.2 (r262:71605, Apr 14 2009, 22:40:02) [MSC v.1500 32 bit (Intel)] on win32."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Hmm... on re-running it I get something more believable"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n fact1           : 7.771696\nfact1x          : 7.799568\nfact2           : 7.056820\nfact2x          : 7.247851\nmath.factorial  : 6.875827\n</code>\n</pre>\n", "senID": 7}, {"text": ["And on Python 2.6.5 (r265:79063, Jun 12 2010, 17:07:01) [GCC 4.3.4 20090804 (release) 1] on cygwin:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n fact1           : 6.547000\nfact1x          : 6.411000\nfact2           : 6.068000\nfact2x          : 6.246000\nmath.factorial  : 6.276000\n</code>\n</pre>\n", "senID": 9}, {"text": ["All in the noise really, isn't it?"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}]]