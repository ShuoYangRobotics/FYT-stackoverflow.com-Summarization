[[{"code": "<pre>\n<code>\n mydict = {\"&amp;y\":\"\\033[0;30m\",\n          \"&amp;c\":\"\\033[0;31m\",\n          \"&amp;b\":\"\\033[0;32m\",\n          \"&amp;Y\":\"\\033[0;33m\",\n          \"&amp;u\":\"\\033[0;34m\"}\nmystr = \"The &amp;yquick &amp;cbrown &amp;bfox &amp;Yjumps over the &amp;ulazy dog\"\n\nfor k, v in mydict.iteritems():\n    mystr = mystr.replace(k, v)\n\nprint mystr\nThe \u2190[0;30mquick \u2190[0;31mbrown \u2190[0;32mfox \u2190[0;33mjumps over the \u2190[0;34mlazy dog\n</code>\n</pre>\n", "senID": 0}, {"text": ["I took the liberty of comparing a few solutions:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n mydict = dict([('&amp;' + chr(i), str(i)) for i in list(range(65, 91)) + list(range(97, 123))])\n\n# random inserts between keys\nfrom random import randint\nrawstr = ''.join(mydict.keys())\nmystr = ''\nfor i in range(0, len(rawstr), 2):\n    mystr += chr(randint(65,91)) * randint(0,20) # insert between 0 and 20 chars\n\nfrom time import time\n\n# How many times to run each solution\nrep = 10000\n\nprint 'Running %d times with string length %d and ' \\\n      'random inserts of lengths 0-20' % (rep, len(mystr))\n\n# My solution\nt = time()\nfor x in range(rep):\n    for k, v in mydict.items():\n        mystr.replace(k, v)\n    #print(mystr)\nprint '%-30s' % 'Tor fixed &amp; variable dict', time()-t\n\nfrom re import sub, compile, escape\n\n# Peter Hansen\nt = time()\nfor x in range(rep):\n    sub(r'(&amp;[a-zA-Z])', r'%(\\1)s', mystr) % mydict\nprint '%-30s' % 'Peter fixed &amp; variable dict', time()-t\n\n# Claudiu\ndef multiple_replace(dict, text): \n    # Create a regular expression  from the dictionary keys\n    regex = compile(\"(%s)\" % \"|\".join(map(escape, dict.keys())))\n\n    # For each match, look-up corresponding value in dictionary\n    return regex.sub(lambda mo: dict[mo.string[mo.start():mo.end()]], text)\n\nt = time()\nfor x in range(rep):\n    multiple_replace(mydict, mystr)\nprint '%-30s' % 'Claudio variable dict', time()-t\n\n# Claudiu - Precompiled\nregex = compile(\"(%s)\" % \"|\".join(map(escape, mydict.keys())))\n\nt = time()\nfor x in range(rep):\n    regex.sub(lambda mo: mydict[mo.string[mo.start():mo.end()]], mystr)\nprint '%-30s' % 'Claudio fixed dict', time()-t\n\n# Andrew Y - variable dict\ndef mysubst(somestr, somedict):\n  subs = somestr.split(\"&amp;\")\n  return subs[0] + \"\".join(map(lambda arg: somedict[\"&amp;\" + arg[0:1]] + arg[1:], subs[1:]))\n\nt = time()\nfor x in range(rep):\n    mysubst(mystr, mydict)\nprint '%-30s' % 'Andrew Y variable dict', time()-t\n\n# Andrew Y - fixed\ndef repl(s):\n  return mydict[\"&amp;\"+s[0:1]] + s[1:]\n\nt = time()\nfor x in range(rep):\n    subs = mystr.split(\"&amp;\")\n    res = subs[0] + \"\".join(map(repl, subs[1:]))\nprint '%-30s' % 'Andrew Y fixed dict', time()-t\n</code>\n</pre>\n", "senID": 2}, {"text": ["Results in Python 2.6"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n Running 10000 times with string length 490 and random inserts of lengths 0-20\nTor fixed &amp; variable dict      1.04699993134\nPeter fixed &amp; variable dict    0.218999862671\nClaudio variable dict          2.48400020599\nClaudio fixed dict             0.0940001010895\nAndrew Y variable dict         0.0309998989105\nAndrew Y fixed dict            0.0310001373291\n</code>\n</pre>\n", "senID": 4}, {"text": ["Both claudiu's and andrew's solutions kept going into 0, so I had to increase it to 10 000 runs."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I ran it in Python 3 (because of unicode) with replacements of chars from 39 to 1024 (38 is ampersand, so I didn't wanna include it).", "String length up to 10.000 including about 980 replacements with variable random inserts of length 0-20.", "The unicode values from 39 to 1024 causes characters of both 1 and 2 bytes length, which could affect some solutions."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Python 3", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n mydict = dict([('&amp;' + chr(i), str(i)) for i in range(39,1024)])\n\n# random inserts between keys\nfrom random import randint\nrawstr = ''.join(mydict.keys())\nmystr = ''\nfor i in range(0, len(rawstr), 2):\n    mystr += chr(randint(65,91)) * randint(0,20) # insert between 0 and 20 chars\n\nfrom time import time\n\n# How many times to run each solution\nrep = 10000\n\nprint('Running %d times with string length %d and ' \\\n      'random inserts of lengths 0-20' % (rep, len(mystr)))\n\n# Tor Valamo - too long\n#t = time()\n#for x in range(rep):\n#    for k, v in mydict.items():\n#        mystr.replace(k, v)\n#print('%-30s' % 'Tor fixed &amp; variable dict', time()-t)\n\nfrom re import sub, compile, escape\n\n# Peter Hansen\nt = time()\nfor x in range(rep):\n    sub(r'(&amp;[a-zA-Z])', r'%(\\1)s', mystr) % mydict\nprint('%-30s' % 'Peter fixed &amp; variable dict', time()-t)\n\n# Peter 2\ndef dictsub(m):\n    return mydict[m.group()]\n\nt = time()\nfor x in range(rep):\n    sub(r'(&amp;[a-zA-Z])', dictsub, mystr)\nprint('%-30s' % 'Peter fixed dict', time()-t)\n\n# Claudiu - too long\n#def multiple_replace(dict, text): \n#    # Create a regular expression  from the dictionary keys\n#    regex = compile(\"(%s)\" % \"|\".join(map(escape, dict.keys())))\n#\n#    # For each match, look-up corresponding value in dictionary\n#    return regex.sub(lambda mo: dict[mo.string[mo.start():mo.end()]], text)\n#\n#t = time()\n#for x in range(rep):\n#    multiple_replace(mydict, mystr)\n#print('%-30s' % 'Claudio variable dict', time()-t)\n\n# Claudiu - Precompiled\nregex = compile(\"(%s)\" % \"|\".join(map(escape, mydict.keys())))\n\nt = time()\nfor x in range(rep):\n    regex.sub(lambda mo: mydict[mo.string[mo.start():mo.end()]], mystr)\nprint('%-30s' % 'Claudio fixed dict', time()-t)\n\n# Separate setup for Andrew and gnibbler optimized dict\nmydict = dict((k[1], v) for k, v in mydict.items())\n\n# Andrew Y - variable dict\ndef mysubst(somestr, somedict):\n  subs = somestr.split(\"&amp;\")\n  return subs[0] + \"\".join(map(lambda arg: somedict[arg[0:1]] + arg[1:], subs[1:]))\n\ndef mysubst2(somestr, somedict):\n  subs = somestr.split(\"&amp;\")\n  return subs[0].join(map(lambda arg: somedict[arg[0:1]] + arg[1:], subs[1:]))\n\nt = time()\nfor x in range(rep):\n    mysubst(mystr, mydict)\nprint('%-30s' % 'Andrew Y variable dict', time()-t)\nt = time()\nfor x in range(rep):\n    mysubst2(mystr, mydict)\nprint('%-30s' % 'Andrew Y variable dict 2', time()-t)\n\n# Andrew Y - fixed\ndef repl(s):\n  return mydict[s[0:1]] + s[1:]\n\nt = time()\nfor x in range(rep):\n    subs = mystr.split(\"&amp;\")\n    res = subs[0] + \"\".join(map(repl, subs[1:]))\nprint('%-30s' % 'Andrew Y fixed dict', time()-t)\n\n# gnibbler\nt = time()\nfor x in range(rep):\n    myparts = mystr.split(\"&amp;\")\n    myparts[1:]=[mydict[x[0]]+x[1:] for x in myparts[1:]]\n    \"\".join(myparts)\nprint('%-30s' % 'gnibbler fixed &amp; variable dict', time()-t)\n</code>\n</pre>\n", "senID": 7}, {"text": ["Results:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n Running 10000 times with string length 9491 and random inserts of lengths 0-20\nTor fixed &amp; variable dict      0.0 # disqualified 329 secs\nPeter fixed &amp; variable dict    2.07799983025\nPeter fixed dict               1.53100013733 \nClaudio variable dict          0.0 # disqualified, 37 secs\nClaudio fixed dict             1.5\nAndrew Y variable dict         0.578000068665\nAndrew Y variable dict 2       0.56299996376\nAndrew Y fixed dict            0.56200003624\ngnibbler fixed &amp; variable dict 0.530999898911\n</code>\n</pre>\n", "senID": 9}, {"text": ["(** Note that gnibbler's code uses a different dict, where keys don't have the '&amp;' included.", "Andrew's code also uses this alternate dict, but it didn't make much of a difference, maybe just 0.01x speedup."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["Try this, making use of regular expression substitution, and standard string formatting:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # using your stated values for str and dict:\n&gt;&gt;&gt; import re\n&gt;&gt;&gt; str = re.sub(r'(&amp;[a-zA-Z])', r'%(\\1)s', str)\n&gt;&gt;&gt; str % dict\n'The \\x1b[0;30mquick \\x1b[0;31mbrown \\x1b[0;32mfox \\x1b[0;33mjumps over the \\x1b[0;34mlazy dog'\n</code>\n</pre>\n", "senID": 1}, {"text": ["The re.sub() call replaces all sequences of ampersand followed by single letter with the pattern %(..)s containing the same pattern."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The % formatting takes advantage of a feature of string formatting that can take a dictionary to specify the substitution, rather than the more commonly occurring positional arguments."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["An alternative can do this directly in the re.sub, using a callback:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; def dictsub(m):\n&gt;&gt;&gt;    return dict[m.group()]\n&gt;&gt;&gt; str = re.sub(r'(&amp;[a-zA-Z])', dictsub, str)\n</code>\n</pre>\n", "senID": 5}, {"text": ["This time I'm using a closure to reference the dictionary from inside the callback function.", "This approach could give you a little more flexibility.", "For example, you could use something like dict.get(m.group(), '??", "') to avoid raising exceptions if you had strings with unrecognized code sequences."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "dict.get(m.group(), '??')", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["(By the way, both \"dict\" and \"str\" are builtin functions, and you'll get into trouble if you use those names in your own code much.", "Just in case you didn't know that.", "They're fine for a question like this of course."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Edit:  I decided to check Tor's test code, and concluded that it's nowhere near representative, and in fact buggy.", "The string generated doesn't even have ampersands in it (!).", "The revised code below generates a representative dictionary and string, similar to the OP's example inputs."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I also wanted to verify that each algorithm's output was the same.", "Below is a revised test program, with only Tor's, mine, and Claudiu's code -- because the others were breaking on the sample input.", "(I think they're all brittle unless the dictionary maps basically all possible ampersand sequences, which Tor's test code was doing.", ") This one properly seeds the random number generator so each run is the same.", "Finally, I added a minor variation using a generator which avoids some function call overhead, for a minor performance improvement."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "all", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n from time import time\nimport string\nimport random\nimport re\n\nrandom.seed(1919096)  # ensure consistent runs\n\n# build dictionary with 40 mappings, representative of original question\nmydict = dict(('&amp;' + random.choice(string.letters), '\\x1b[0;%sm' % (30+i)) for i in range(40))\n# build simulated input, with mix of text, spaces, ampersands in reasonable proportions\nletters = string.letters + ' ' * 12 + '&amp;' * 6\nmystr = ''.join(random.choice(letters) for i in range(1000))\n\n# How many times to run each solution\nrep = 10000\n\nprint('Running %d times with string length %d and %d ampersands'\n    % (rep, len(mystr), mystr.count('&amp;')))\n\n# Tor Valamo\n# fixed from Tor's test, so it actually builds up the final string properly\nt = time()\nfor x in range(rep):\n    output = mystr\n    for k, v in mydict.items():\n        output = output.replace(k, v)\nprint('%-30s' % 'Tor fixed &amp; variable dict', time() - t)\n# capture \"known good\" output as expected, to verify others\nexpected = output\n\n# Peter Hansen\n\n# build charset to use in regex for safe dict lookup\ncharset = ''.join(x[1] for x in mydict.keys())\n# grab reference to method on regex, for speed\npatsub = re.compile(r'(&amp;[%s])' % charset).sub\n\nt = time()\nfor x in range(rep):\n    output = patsub(r'%(\\1)s', mystr) % mydict\nprint('%-30s' % 'Peter fixed &amp; variable dict', time()-t)\nassert output == expected\n\n# Peter 2\ndef dictsub(m):\n    return mydict[m.group()]\n\nt = time()\nfor x in range(rep):\n    output = patsub(dictsub, mystr)\nprint('%-30s' % 'Peter fixed dict', time() - t)\nassert output == expected\n\n# Peter 3 - freaky generator version, to avoid function call overhead\ndef dictsub(d):\n    m = yield None\n    while 1:\n        m = yield d[m.group()]\n\ndictsub = dictsub(mydict).send\ndictsub(None)   # \"prime\" it\nt = time()\nfor x in range(rep):\n    output = patsub(dictsub, mystr)\nprint('%-30s' % 'Peter generator', time() - t)\nassert output == expected\n\n# Claudiu - Precompiled\nregex_sub = re.compile(\"(%s)\" % \"|\".join(mydict.keys())).sub\n\nt = time()\nfor x in range(rep):\n    output = regex_sub(lambda mo: mydict[mo.string[mo.start():mo.end()]], mystr)\nprint('%-30s' % 'Claudio fixed dict', time() - t)\nassert output == expected\n</code>\n</pre>\n", "senID": 10}, {"text": ["I forgot to include benchmark results before:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\nRunning 10000 times with string length 1000 and 96 ampersands\n    ('Tor fixed & variable dict     ', 2.9890000820159912)\n    ('Peter fixed & variable dict   ', 2.6659998893737793)\n    ('Peter fixed dict              ', 1.0920000076293945)\n    ('Peter generator               ', 1.0460000038146973)\n    ('Claudio fixed dict            ', 1.562000036239624)\n</pre>\n", "senID": 12}, {"text": ["Also, snippets of the inputs and correct output:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n mystr = 'lTEQDMAPvksk k&amp;z Txp vrnhQ GHaO&amp;GNFY&amp;&amp;a...'\nmydict = {'&amp;p': '\\x1b[0;37m', '&amp;q': '\\x1b[0;66m', '&amp;v': ...}\noutput = 'lTEQDMAPvksk k\u2190[0;57m Txp vrnhQ GHaO\u2190[0;67mNFY&amp;&amp;a P...'\n</code>\n</pre>\n", "senID": 14}, {"text": ["Comparing with what I saw from Tor's test code output:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n mystr = 'VVVVVVVPPPPPPPPPPPPPPPXXXXXXXXYYYFFFFFFFFFFFFEEEEEEEEEEE...'\nmydict = {'&amp;p': '112', '&amp;q': '113', '&amp;r': '114', '&amp;s': '115', ...}\noutput = # same as mystr since there were no ampersands inside\n</code>\n</pre>\n", "senID": 16}], [{"text": ["If the number of keys in the list is large, and the number of the occurences in the string is low (and mostly zero), then you could iterate over the occurences of the ampersands in the string, and use the dictionary keyed by the first character of the substrings.", "I don't code often in python so the style might be a bit off, but here is my take at it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n str = \"The &amp;yquick &amp;cbrown &amp;bfox &amp;Yjumps over the &amp;ulazy dog\"\n\ndict = {\"&amp;y\":\"\\033[0;30m\",\n        \"&amp;c\":\"\\033[0;31m\",\n        \"&amp;b\":\"\\033[0;32m\",\n        \"&amp;Y\":\"\\033[0;33m\",\n        \"&amp;u\":\"\\033[0;34m\"}\n\ndef rep(s):\n  return dict[\"&amp;\"+s[0:1]] + s[1:]\n\nsubs = str.split(\"&amp;\")\nres = subs[0] + \"\".join(map(rep, subs[1:]))\n\nprint res\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course there is a question what happens when there is an ampersand that is coming from the string itself, you would need to escape it in some way before feeding through this process, and then unescape after this process. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Of course, as is pretty much usual with the performance issues, timing the various approaches on your typical (and also worst-case) dataset and comparing them is a good thing to do."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT: place it into a separate function to work with arbitrary dictionary:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def mysubst(somestr, somedict):\n  subs = somestr.split(\"&amp;\")\n  return subs[0] + \"\".join(map(lambda arg: somedict[\"&amp;\" + arg[0:1]] + arg[1:], subs[1:]))\n</code>\n</pre>\n", "senID": 5}, {"text": ["EDIT2: get rid of an unneeded concatenation, seems to still be a bit faster than the previous on many iterations."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def mysubst(somestr, somedict):\n  subs = somestr.split(\"&amp;\")\n  return subs[0].join(map(lambda arg: somedict[\"&amp;\" + arg[0:1]] + arg[1:], subs[1:]))\n</code>\n</pre>\n", "senID": 7}], [{"text": ["If you really want to dig into the topic take a look at this: http://en.wikipedia.org/wiki/Aho-Corasick%5Falgorithm"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://en.wikipedia.org/wiki/Aho-Corasick%5Falgorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Aho-Corasick%5Falgorithm"}]}, {"text": ["The obvious solution by iterating over the dictionary and replacing each element in the string takes O(n*m) time, where n is the size of the dictionary, m is the length of the string."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "O(n*m)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Whereas the Aho-Corasick-Algorithm finds all entries of the dictionary in O(n+m+f) where f is the number of found elements."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "O(n+m+f)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Here is the C Extensions Approach for python"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n const char *dvals[]={\n    //\"0-64\n    \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n    \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n    \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n    \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n    \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n    \"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\n    \"\",\"\",\"\",\"\",\"\",\n    //A-Z\n    \"\",\"\",\"\",\"\",\"\",\n    \"\",\"\",\"\",\"\",\"\",\n    \"\",\"\",\"\",\"\",\"\",\n    \"\",\"\",\"\",\"\",\"\",\n    \"\",\"\",\"\",\"\",\"33\",\n    \"\",\n    //\n    \"\",\"\",\"\",\"\",\"\",\"\",\n    //a-z\n    \"\",\"32\",\"31\",\"\",\"\",\n    \"\",\"\",\"\",\"\",\"\",\n    \"\",\"\",\"\",\"\",\"\",\n    \"\",\"\",\"\",\"\",\"\",\n    \"34\",\"\",\"\",\"\",\"30\",\n    \"\"\n};\n\nint dsub(char*d,char*s){\n    char *ofs=d;\n    do{\n    \tif(*s=='&amp;' &amp;&amp; s[1]&lt;='z' &amp;&amp; *dvals[s[1]]){\n\n    \t\t//\\033[0;\n    \t\t*d++='\\\\',*d++='0',*d++='3',*d++='3',*d++='[',*d++='0',*d++=';';\n\n    \t\t//consider as fixed 2 digits\n    \t\t*d++=dvals[s[1]][0];\n    \t\t*d++=dvals[s[1]][1];\n\n    \t\t*d++='m';\n\n    \t\ts++; //skip\n\n    \t//non &amp;,invalid, unused (&amp;) ampersand sequences will go here.\n    \t}else *d++=*s;\n\n    }while(*s++);\n\n    return d-ofs-1;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Python codes I have tested"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from mylib import *\nimport time\n\nstart=time.time()\n\ninstr=\"The &amp;yquick &amp;cbrown &amp;bfox &amp;Yjumps over the &amp;ulazy dog, skip &amp;Unknown.\\n\"*100000\nx=dsub(instr)\n\nend=time.time()\n\nprint \"time taken\",end-start,\",input str length\",len(x)\nprint \"first few lines\"\nprint x[:1100]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Results"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n time taken 0.140000104904 ,input str length 11000000\nfirst few lines\nThe \\033[0;30mquick \\033[0;31mbrown \\033[0;32mfox \\033[0;33mjumps over the \\033[0;34mlazy dog, skip &amp;Unknown.\nThe \\033[0;30mquick \\033[0;31mbrown \\033[0;32mfox \\033[0;33mjumps over the \\033[0;34mlazy dog, skip &amp;Unknown.\nThe \\033[0;30mquick \\033[0;31mbrown \\033[0;32mfox \\033[0;33mjumps over the \\033[0;34mlazy dog, skip &amp;Unknown.\nThe \\033[0;30mquick \\033[0;31mbrown \\033[0;32mfox \\033[0;33mjumps over the \\033[0;34mlazy dog, skip &amp;Unknown.\nThe \\033[0;30mquick \\033[0;31mbrown \\033[0;32mfox \\033[0;33mjumps over the \\033[0;34mlazy dog, skip &amp;Unknown.\nThe \\033[0;30mquick \\033[0;31mbrown \\033[0;32mfox \\033[0;33mjumps over the \\033[0;34mlazy dog, skip &amp;Unknown.\nThe \\033[0;30mquick \\033[0;31mbrown \\033[0;32mfox \\033[0;33mjumps over the \\033[0;34mlazy dog, skip &amp;Unknown.\nThe \\033[0;30mquick \\033[0;31mbrown \\033[0;32mfox \\033[0;33mjumps over the \\033[0;34mlazy dog, skip &amp;Unknown.\nThe \\033[0;30mquick \\033[0;31mbrown \\033[0;32mfox \\033[0;33mjumps over the \\033[0;34mlazy dog, skip &amp;Unknown.\nThe \\033[0;30mquick \\033[0;31mbrown \\033[0;32mfox \\033[0;33mjumps over the \\033[0;34mlazy dog, skip &amp;Unknown.\n</code>\n</pre>\n", "senID": 5}, {"text": ["Its suppose to able to run at O(n), and \nOnly took 160 ms (avg) for 11 MB string in My Mobile Celeron 1.6 GHz PC"], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "O(n)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "160 ms (avg)", "childNum": 0, "tag": "strong", "childList": []}, {"text": "11 MB", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["It will also skip unknown characters as is, for example &amp;Unknown will return as is"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "&amp;Unknown", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Let me know If you have any problem with compiling, bugs, etc..."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Here is a version using split/join"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n mydict = {\"y\":\"\\033[0;30m\",\n          \"c\":\"\\033[0;31m\",\n          \"b\":\"\\033[0;32m\",\n          \"Y\":\"\\033[0;33m\",\n          \"u\":\"\\033[0;34m\"}\nmystr = \"The &amp;yquick &amp;cbrown &amp;bfox &amp;Yjumps over the &amp;ulazy dog\"\n\nmyparts = mystr.split(\"&amp;\")\nmyparts[1:]=[mydict[x[0]]+x[1:] for x in myparts[1:]]\nprint \"\".join(myparts)\n</code>\n</pre>\n", "senID": 1}, {"text": ["In case there are ampersands with invalid codes you can use this to preserve them"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n myparts[1:]=[mydict.get(x[0],\"&amp;\"+x[0])+x[1:] for x in myparts[1:]]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Peter Hansen pointed out that this fails when there is double ampersand.", "In that case use this version"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n mystr = \"The &amp;yquick &amp;cbrown &amp;bfox &amp;Yjumps over the &amp;&amp;ulazy dog\"\nmyparts = mystr.split(\"&amp;\")\nmyparts[1:]=[mydict.get(x[:1],\"&amp;\"+x[:1])+x[1:] for x in myparts[1:]]\nprint \"\".join(myparts)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["This seems like it does what you want - multiple string replace at once using RegExps.", "Here is the relevant code:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "This", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/81330/"}]}, {"code": "<pre>\n<code>\n def multiple_replace(dict, text): \n    # Create a regular expression  from the dictionary keys\n    regex = re.compile(\"(%s)\" % \"|\".join(map(re.escape, dict.keys())))\n\n    # For each match, look-up corresponding value in dictionary\n    return regex.sub(lambda mo: dict[mo.string[mo.start():mo.end()]], text)\n\nprint multiple_replace(dict, str)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A general solution for defining replacement rules is to use regex substitution using a function to provide the map (see re.sub())."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re.sub()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html#re.sub"}]}, {"code": "<pre>\n<code>\n import re\n\nstr = \"The &amp;yquick &amp;cbrown &amp;bfox &amp;Yjumps over the &amp;ulazy dog\"\n\ndict = {\"&amp;y\":\"\\033[0;30m\",\n        \"&amp;c\":\"\\033[0;31m\",\n        \"&amp;b\":\"\\033[0;32m\",\n        \"&amp;Y\":\"\\033[0;33m\",\n        \"&amp;u\":\"\\033[0;34m\"}\n\ndef programmaticReplacement( match ):\n    return dict[ match.group( 1 ) ]\n\ncolorstring = re.sub( '(\\&amp;.)', programmaticReplacement, str )\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is particularly nice for non-trivial substitutions (e.g anything requiring mathmatical operations to create the substitute)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Not sure about the speed of this solution either, but you could just loop through your dictionary and repeatedly call the built-in "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["str.replace(old, new) "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "str.replace(old, new)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This might perform decently well if the original string isn't too long, but it would obviously suffer as the string got longer."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The problem with doing this mass replace in Python is immutability of the strings: every time you will replace one item in the string then entire new string will be reallocated again and again from the heap."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So if you want the fastest solution you either need to use mutable container (e.g.", "list), or write this machinery in the plain C (or better in Pyrex or Cython).", "In any case I'd suggest to write simple parser based on simple finite-state machine, and feed symbols of your string one by one."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Suggested solutions based on regexps working in similar way, because regexp working using fsm behind the scene."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Since someone mentioned using a simple parser, I thought I'd cook one up using pyparsing.", "By using pyparsing's transformString method, pyparsing internally scans through the source string, and builds a list of the matching text and intervening text.", "When all is done, transformString then ''.join's this list, so there is no performance problem in building up strings by increments.", "(The parse action defined for ANSIreplacer does the conversion from the matched &amp;_ characters to the desired escape sequence, and replaces the matched text with the output of the parse action.", "Since only matching sequences will satisfy the parser expression, there is no need for the parse action to handle undefined &amp;_ sequences.", ") "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The FollowedBy('&amp;') is not strictly necessary, but it shortcuts the parsing process by verifying that the parser is actually positioned at an ampersand before doing the more expensive checking of all of the markup options."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from pyparsing import FollowedBy, oneOf\n\nescLookup = {\"&amp;y\":\"\\033[0;30m\",\n            \"&amp;c\":\"\\033[0;31m\",\n            \"&amp;b\":\"\\033[0;32m\",\n            \"&amp;Y\":\"\\033[0;33m\",\n            \"&amp;u\":\"\\033[0;34m\"}\n\n# make a single expression that will look for a leading '&amp;', then try to \n# match each of the escape expressions\nANSIreplacer = FollowedBy('&amp;') + oneOf(escLookup.keys())\n\n# add a parse action that will replace the matched text with the \n# corresponding ANSI sequence\nANSIreplacer.setParseAction(lambda toks: escLookup[toks[0]])\n\n# now use the replacer to transform the test string; throw in some extra\n# ampersands to show what happens with non-matching sequences\nsrc = \"The &amp;yquick &amp;cbrown &amp;bfox &amp;Yjumps over the &amp;ulazy dog &amp; &amp;Zjumps back\"\nout = ANSIreplacer.transformString(src)\nprint repr(out)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n 'The \\x1b[0;30mquick \\x1b[0;31mbrown \\x1b[0;32mfox \\x1b[0;33mjumps over \n the \\x1b[0;34mlazy dog &amp; &amp;Zjumps back'\n</code>\n</pre>\n", "senID": 4}, {"text": ["This will certainly not win any performance contests, but if your markup starts to get more complicated, then having a parser foundation will make it easier to extend."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; a=[]\n&gt;&gt;&gt; str = \"The &amp;yquick &amp;cbrown &amp;bfox &amp;Yjumps over the &amp;ulazy dog\"\n&gt;&gt;&gt; d={\"&amp;y\":\"\\033[0;30m\",                                                              \n... \"&amp;c\":\"\\033[0;31m\",                                                                 \n... \"&amp;b\":\"\\033[0;32m\",                                                                 \n... \"&amp;Y\":\"\\033[0;33m\",                                                                 \n... \"&amp;u\":\"\\033[0;34m\"}     \n&gt;&gt;&gt; for item in str.split():\n...  if item[:2] in d:\n...    a.append(d[item[:2]]+item[2:])\n...  else: a.append(item)\n&gt;&gt;&gt; print ' '.join(a)\n</code>\n</pre>\n", "senID": 0}]]