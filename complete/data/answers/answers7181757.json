[[{"text": ["To give a short answer..."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "To give a short answer...", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Python only offers native operators for two types of division: \"true\" division, and \"round down\" division.", "So what you want isn't available as a single function.", "However, it is possible to easily implement a number of different types of division-with-rounding using some short expressions. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Per the title's request: given strictly integer inputs, \"round up\" division can be implemented using (a+(-a%b))//b, and \"round away from zero\" division can be implemented using the more complex a//b if a*b&lt;0 else (a+(-a%b))//b.", "One of those is probably what you want.", "As to why..."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "(a+(-a%b))//b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a//b if a*b&lt;0 else (a+(-a%b))//b", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["To give a longer answer..."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "To give a longer answer...", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["First, let me answer the subquestion about why 3/2==1 and math.ceil(3/2)==1.0, by way of explaining how the Python division operator works.", "There are two main issues at play..."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "3/2==1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "math.ceil(3/2)==1.0", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["floatvsintdivision: Under Python 2, division behaves differently depending on the type of the inputs.", "If both a and b are integers, a/b performs \"round down\" or \"floor integer\" division (eg 3/2==1, but -3/2==-2).", "This is equivalent to int(math.floor(float(a)/b)) . "], "childNum": 9, "tag": "p", "senID": 5, "childList": [{"text": "floatvsintdivision:", "childNum": 2, "tag": "strong", "pos": 0, "childList": [{"text": "float", "tag": "code"}, {"text": "int", "tag": "code"}]}, {"text": "float", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "a/b", "childNum": 0, "tag": "code", "childList": []}, {"text": "3/2==1", "childNum": 0, "tag": "code", "childList": []}, {"text": "-3/2==-2", "childNum": 0, "tag": "code", "childList": []}, {"text": "int(math.floor(float(a)/b))", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["But if at least one of a and b are floats, Python performs \"true\" division, and gives you a float result (eg 3.0/2==1.5, and -3.0/2==-1.5).", "This is why you'll sometimes see the construction float(a)/b: it's being used to force true division even both inputs are integers (eg float(3)/2==1.5).", "This is why your example math.ceil(3/2) returns 1.0, whereas math.ceil(float(3)/2) returns 2.0.", "The result has already been rounded down before it even reaches math.ceil()."], "childNum": 12, "tag": "p", "senID": 6, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "float", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "3.0/2==1.5", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "-3.0/2==-1.5", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "float(a)/b", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "float(3)/2==1.5", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "math.ceil(3/2)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "1.0", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "math.ceil(float(3)/2)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "2.0", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "math.ceil()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["\"true division\" by default: In 2001, it was decided (PEP 238) that Python's division operator should be changed so that it always performs \"true\" division, regardless of whether the inputs are floats or integers (eg, this would make 3/2==1.5).", "In order to not break existing scripts, the change in default behavior was deferred until Python 3.0; in order to get this behavior under Python 2.x, you have to enable it per-file by adding from __future__ import division to the top of the file.", "Otherwise the old type-dependant behavior is used."], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "\"true division\" by default", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "PEP 238", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0238/"}, {"text": "3/2==1.5", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "from __future__ import division", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["But \"round down\" division is still frequently needed, so the PEP didn't do way with it entirely.", "Instead, it introduced a new division operator: a//b, which always performs round down division, even if the inputs include floats.", "This can be used without doing anything special under both Python 2.2+ and 3.x. "], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "a//b", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "always", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["That out of that way, division-with-rounding:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "That out of that way, division-with-rounding:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["In order to simplify things, the following expressions all use the a//b operator when working on integers, since it will behave the same under all python versions.", "As well, I'm making an assumption that 0&lt;=a%b&lt;b if b is positive, and b&lt;=a%b&lt;=0 if b is negative.", "This is how Python behaves, but other languages may have slightly different modulus operators. "], "childNum": 4, "tag": "p", "senID": 10, "childList": [{"text": "a//b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "0&lt;=a%b&lt;b", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "b&lt;=a%b&lt;=0", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The four basic types of integer division with rounding:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": ["\"round down\" aka \"floor integer\" aka \"round to minus infinity\" divsion: python offers this natively via a//b. "], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "\"round down\"", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "a//b", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["\"round up\" aka \"ceiling integer\" aka \"round to positive infinity\" division: this can be achieved via int(math.ceil(float(a)/b)) or (a+(-a%b))//b.", "The latter equation works because -a%b is 0 if a is a multiple of b, and is otherwise the amount we need to add to a to get to the next highest multiple."], "childNum": 7, "tag": "p", "senID": 13, "childList": [{"text": "\"round up\"", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "int(math.ceil(float(a)/b))", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "(a+(-a%b))//b", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "-a%b", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["\"round towards zero\" aka \"truncated\" division - this can be achieved via int(float(a)/b).", "Doing this without using floating point is trickier... since Python only offers round-down integer division, and the % operator has a similar round-down bias, we don't have any non-floating-point operators which round symmetrically about 0.", "So the only way I can think of is to construct a piecewise expression out of round-down and round-up: a//b if a*b&gt;0 else (a+(-a%b))//b. "], "childNum": 4, "tag": "p", "senID": 14, "childList": [{"text": "\"round towards zero\"", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "int(float(a)/b)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "%", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "a//b if a*b&gt;0 else (a+(-a%b))//b", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["\"round away from zero\" aka \"round to (either) infinity\" division - unfortunately, this is even trickier than round-towards-zero.", "We can't leverage the truncating behavior of the int operator anymore, so I can't think of a simple expression even when including floating-point ops.", "So I have to go with the inverse of the round-to-zero expression, and use a//b if a*b&lt;0 else (a+(-a%b))//b."], "childNum": 3, "tag": "p", "senID": 15, "childList": [{"text": "\"round away from zero\"", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "a//b if a*b&lt;0 else (a+(-a%b))//b", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}]}, {"text": ["Note that if you're only using positive integers, (a+b-1)//b provides round up / away from zero even more efficiently than any of the above solutions, but falls apart for negatives."], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "(a+b-1)//b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Hope that helps... and happy to make edits if anyone can suggest better equations for round to/away from zero.", "I find the ones I have particularly unsatisfactory. "], "childNum": 0, "tag": "p", "senID": 17, "childList": []}], [{"text": ["Integral division in Python 3:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["3 // 2 == 1"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "3 // 2 == 1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Non-integral division in Python 3:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["3 / 2 == 1.5"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "3 / 2 == 1.5", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["What you're talking about is not a division by all means."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["When you divide two integers, the result is an integer.", "3 / 2 equals 1, not 1.5.", "See the documentation, note 1:"], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "3 / 2", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "1.5", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"href": "http://docs.python.org/library/stdtypes.html#numeric-types-int-float-long-complex", "text": "the documentation", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Once you get 1 from the division, there is no way to turn that into 2."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "2", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To get 1.5, you need floating-point division: 3.0 / 2.", "You can then call math.ceil to get 2."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "1.5", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "3.0 / 2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "math.ceil", "childNum": 0, "tag": "code", "childList": []}, {"text": "2", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You are mistaken; there is no mathematical function that divides, then rounds up.", "The best you can do is write your own function that takes two floats and calls math.ceil."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "math.ceil", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["What you probably want is something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n math.ceil(3.0/2.0)\n# or\nmath.ceil(float(3)/float(2))\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could also do an import from future:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import division\nmath.ceil(3/2) # == 2\n</code>\n</pre>\n", "senID": 3}, {"text": ["But, if you do this, to get the current behavior of integer division you need to use the double slash:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n 3 // 2 == 1 # True\n</code>\n</pre>\n", "senID": 5}], [{"text": ["The intent of the OP's question is \"How to implement division with round-towards-infinity in Python\" (suggest you change the title)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\"How to implement division with round-towards-infinity in Python\"", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This is a perfectly legitimate rounding mode as per the IEEE-754 standard (read this overview), and the term for it is \"round towards infinity\" (or \"round away from zero\").", "Most of the 9 downvotes were beating up on the OP unfairly.", "Yes, there is no single-function way to do this in native Python, but we can use round(float(a)/b) or else subclass numbers.Number and override __div__()."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "IEEE-754 standard", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/IEEE_754-2008#Rounding_algorithms"}, {"text": "this overview", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.eetimes.com/design/programmable-logic/4014804/An-introduction-to-different-rounding-algorithms"}, {"text": "round(float(a)/b)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "numbers.Number", "childNum": 0, "tag": "code", "childList": []}, {"text": "__div__()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The OP would need to clarify whether they want -3/2 to round to -2 or -1 (or don't-care for negative operands).", "Since they already said they don't want round-upwards, we can infer -3/2 should round to -2."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Enough theory.", "For implementations:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "If you just want the fast-and-dirty one-line solution for round-towards-infinity , use ", "tag": "none", "senID": 4}, {"text": ["math.ceil(float(a)/b) gives you round-upwards, which you said you don't want"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "math.ceil(float(a)/b)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["But if this is your default division operation, or you are doing a lot of this, then do like the pseudocode below: inherit from one of the subclasses ofnumbers.NumberReal, Rational or Integral (new in 2.6), redefine __div__() or else define a non-default alternative __divra__() operation.", "You could define a class member or classmethod rounding_mode and look it up during divisions.", "Be careful of __rdiv__() and mixing with ordinary floats though."], "childNum": 6, "tag": "p", "senID": 6, "childList": [{"text": "inherit from one of the subclasses ofnumbers.NumberReal, Rational or Integral (new in 2.6)", "tag": "a", "pos": 0, "childList": [{"text": "numbers.Number", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/numbers.html"}, {"text": "numbers.Number", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__div__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__divra__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "rounding_mode", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__rdiv__()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import numbers\n\nclass NumberWithRounding(numbers.Integral):\n    # Here you could implement a classmethod setRoundingMode() or member rounding_mode\n    def __div__(self,other):\n        # here you could consider value of rounding_mode, or else hardwire it like:\n        return round(float(self)/other)\n    # You also have to raise ImplementationError/ pass/ or implement the other 31\n    # methods for Float: __abs__(),...,__xor__() Just shortcut that for now...\n</code>\n</pre>\n", "senID": 8}], [{"text": ["I think that what you're looking for is this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["assuming you have x (3) and y (2),"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["result = (x + y - 1) // y;"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "result = (x + y - 1) // y;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["this is the equivalent of a ceiling without the use of floating points."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Of course, y cannot be 0."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Integer division with ceiling rounding (to +Inf), floor rounding (to -Inf), and truncation (to 0) is available in gmpy2."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; gmpy2.c_div(3,2)\nmpz(2)\n&gt;&gt;&gt; help(gmpy2.c_div)\nHelp on built-in function c_div in module gmpy2:\nc_div(...)\n    c_div(x,y): returns the quotient of x divided by y. The quotient\n    is rounded towards +Inf (ceiling rounding). x and y must be integers.\n&gt;&gt;&gt; help(gmpy2.f_div)\nHelp on built-in function f_div in module gmpy2:\nf_div(...)\n    f_div(x,y): returns the quotient of x divided by y. The quotient\n    is rounded towards -Inf (floor rounding). x and y must be integers.\n&gt;&gt;&gt; help(gmpy2.t_div)\nHelp on built-in function t_div in module gmpy2:\nt_div(...)\n    t_div(x,y): returns the quotient of x divided by y. The quotient\n    is rounded towards 0. x and y must be integers.\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["gmpy2 is available at http://code.google.com/p/gmpy/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://code.google.com/p/gmpy/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/gmpy/"}]}, {"text": ["(Disclaimer: I'm the current maintainer of gmpy and gmpy2."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Firstly, you want to be using floating-point division in the arguments.", "Use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import division\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you always want to round up, so f(3/2)==2 and f(1.4)==2, then you want f to be math.trunc(math.ceil(x))."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "f(3/2)==2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "f(1.4)==2", "childNum": 0, "tag": "code", "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "childList": []}, {"text": "math.trunc(math.ceil(x))", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you want to get the closest integer, but have ties round up, then you want math.trunc(x + 0.5).", "That way f(3/2)==2 and f(1.4)==1."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "math.trunc(x + 0.5)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "f(3/2)==2", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "f(1.4)==1", "childNum": 0, "tag": "code", "childList": []}]}]]