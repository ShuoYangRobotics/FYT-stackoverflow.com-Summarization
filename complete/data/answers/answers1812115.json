[[{"text": ["If you see Python's documentation, it clearly mentions that os.rename() is an atomic operation.", "So in your case, writing data to a temporary file and then renaming it to the original file would be quite safe. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Another way could work like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "let original file be abc.xml", "tag": "none", "senID": 2}, {"text": "create abc.xml.tmp and write new data to it", "tag": "none", "senID": 3}, {"text": "rename abc.xml to abc.xml.bak", "tag": "none", "senID": 4}, {"text": "rename abc.xml.tmp to abc.xml", "tag": "none", "senID": 5}, {"text": "after new abc.xml is properly put in place, remove abc.xml.bak", "tag": "none", "senID": 6}]}, {"text": ["As you can see that you have the abc.xml.bak with you which you can use to restore if there are any issues related with the tmp file and of copying it back."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["A simplistic solution.", "Use tempfile to create a temporary file and if writing succeeds the just rename the file to your original configuration file. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "tempfile", "tag": "a", "pos": 1, "childList": [{"text": "tempfile", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/tempfile.html"}, {"text": "tempfile", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For locking a file, see portalocker."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "portalocker", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/65203/"}]}], [{"text": ["The standard solution is this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["At no time is anything lost or corruptable.", "The only glitch can happen during the renames.", "But you haven't lost anything or corrupted anything.", "The original is recoverable right up until the final rename."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If you want to be POSIXly correct and save you have to:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Note that calling fsync has unpredictable effects on performance -- Linux on ext3 may stall for disk I/O whole numbers of seconds as a result, depending on other outstanding I/O."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Notice that rename is not an atomic operation in POSIX -- at least not in relation to file data as you expect.", "However, most operating systems and filesystems will work this way.", "But it seems you missed the very large linux discussion about Ext4 and filesystem guarantees about atomicity.", "I don't know exactly where to link but here is a start: ext4 and data loss."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "rename", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "ext4 and data loss", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://lwn.net/Articles/322823"}]}, {"text": ["Notice however that on many systems, rename will be as safe in practice as you expect.", "However it is in a way not possible to get both -- performance and reliability across all possible linux confiugrations!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["With a write to a temporary file, then a rename of the temporary file, one would expect the operations are dependent and would be executed in order."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The issue however is that most, if not all filesystems separate metadata and data.", "A rename is only metadata.", "It may sound horrible to you, but filesystems value metadata over data (take Journaling in HFS+ or Ext3,4 for example)!", "The reason is that metadata is lighter, and if the metadata is corrupt, the whole filesystem is corrupt -- the filesystem must of course preserve it self, then preserve the user's data, in that order."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Ext4 did break the rename expectation when it first came out, however heuristics were added to resolve it.", "The issue is not a failed rename, but a successful rename.", "Ext4 might sucessfully register the rename, but fail to write out the file data if a crash comes shortly thereafter.", "The result is then a 0-length file and neither orignal nor new data."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "rename", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["So in short, POSIX makes no such guarantee.", "Read the linked Ext4 article for more information! "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["In Win API I found quite nice function ReplaceFile that does what name suggests even with optional back-up.", "There is always way with DeleteFile, MoveFile combo."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "ReplaceFile", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://msdn.microsoft.com/en-us/library/aa365512%28VS.85%29.aspx"}, {"text": "DeleteFile", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://msdn.microsoft.com/en-us/library/aa363915%28VS.85%29.aspx"}, {"href": "http://msdn.microsoft.com/en-us/library/aa365239%28VS.85%29.aspx", "text": "MoveFile", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["In general what you want to do is really good.", "And I cannot think of any better write scheme."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Perhaps this helps http://stackoverflow.com/questions/489861/locking-a-file-in-python"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://stackoverflow.com/questions/489861/locking-a-file-in-python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/489861/locking-a-file-in-python"}]}], [{"text": ["Per RedGlyph's suggestion, I'm added an implementation of ReplaceFile that uses ctypes to access the Windows APIs.", "I first added this to jaraco.windows.api.filesystem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ReplaceFile = windll.kernel32.ReplaceFileW\nReplaceFile.restype = BOOL\nReplaceFile.argtypes = [\n\tLPWSTR,\n\tLPWSTR,\n\tLPWSTR,\n\tDWORD,\n\tLPVOID,\n\tLPVOID,\n\t]\n\nREPLACEFILE_WRITE_THROUGH = 0x1\nREPLACEFILE_IGNORE_MERGE_ERRORS = 0x2\nREPLACEFILE_IGNORE_ACL_ERRORS = 0x4\n</code>\n</pre>\n", "senID": 1}, {"text": ["I then tested the behavior using this script."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from jaraco.windows.api.filesystem import ReplaceFile\nimport os\n\nopen('orig-file', 'w').write('some content')\nopen('replacing-file', 'w').write('new content')\nReplaceFile('orig-file', 'replacing-file', 'orig-backup', 0, 0, 0)\nassert open('orig-file').read() == 'new content'\nassert open('orig-backup').read() == 'some content'\nassert not os.path.exists('replacing-file')\n</code>\n</pre>\n", "senID": 3}, {"text": ["While this only works in Windows, it appears to have a lot of nice features that other replace routines would lack.", "See the API docs for details."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "API docs", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://msdn.microsoft.com/en-us/library/aa365512%28VS.85%29.aspx"}]}], [{"text": ["You could use the fileinput module to handle the backing-up and in-place writing for you:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import fileinput\nfor line in fileinput.input(filename,inplace=True, backup='.bak'):\n    # inplace=True causes the original file to be moved to a backup\n    # standard output is redirected to the original file.\n    # backup='.bak' specifies the extension for the backup file.\n\n    # manipulate line\n    newline=process(line)\n    print(newline)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you need to read in the entire contents before you can write the newline's,\nthen you can do that first, then print entire new contents with"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n newcontents=process(contents)\nfor line in fileinput.input(filename,inplace=True, backup='.bak'):\n    print(newcontents)\n    break\n</code>\n</pre>\n", "senID": 3}, {"text": ["If the script ends abruptly, you will still have the backup."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]