[[{"text": ["For Python, struct.unpack does the job (to make a 4-byte string into an int -- struct.pack goes the other way):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "struct.unpack", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/struct.html?highlight=struct.pack#struct.pack"}, {"text": "struct.pack", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import struct\n&gt;&gt;&gt; struct.unpack('i', 'isoy')[0]\n2037347177\n&gt;&gt;&gt; struct.pack('i', 2037347177)\n'isoy'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["(you can use different formats to ensure big-endian or little-endian encoding, if you need that -- '&gt;i' and '&lt;i' respectively -- instead of just plain 'i' which uses whatever encoding is native to the machine)."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "'&gt;i'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'&lt;i'", "childNum": 0, "tag": "code", "childList": []}, {"text": "'i'", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["To 32-bit unsigned integer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n uint x = BitConverter.ToUInt32(Encoding.ASCII.GetBytes(\"isoy\"), 0); // 2037347177\n</code>\n</pre>\n", "senID": 1}, {"text": ["To string:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n string s = Encoding.ASCII.GetString(BitConverter.GetBytes(x));      // \"isoy\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["BitConverter uses the native endianness of the machine."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "BitConverter", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://msdn.microsoft.com/en-us/library/system.bitconverter.aspx"}]}], [{"text": ["Using PowerShell syntax you can do it this way (pretty much like dtb solution):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n PS&gt; $x = [BitConverter]::ToUInt32([byte[]][char[]]'isoy', 0)\nPS&gt; [char[]][BitConverter]::GetBytes($x) -join ''\nisoy\n</code>\n</pre>\n", "senID": 1}, {"text": ["You do have to watch out for endian-ness on the Linux side.", "If it is running on an Intel processor I believe should be fine (same endian-ness as the PowerShell side)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n // string -&gt; int    \n\nuint ret = 0;\nfor ( int i = 0; i &lt; 4; ++i )\n{\n  ret |= ( str[i] &lt;&lt; ( i * 8 ) );\n}\n\n// int -&gt; string\nfor ( int i = 0; i &lt; 4; ++i )\n{\n  str[i] = ( ret &gt;&gt; ( i * 8 ) ) &amp; 0xff;\n}\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Please take a look at the struct standard library module in Python's Manual.", "It has two functions for this: struct.pack and struct.unpack.", "You can use the 'L' (unsigned long) format character for this."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "struct.pack", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "struct.unpack", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Aside from byte packing, you can also consider that your 26-character alphabet can be encoded as 0-25 instead of A-Z."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So without worrying about big and little endians, you can go from \"letters\" to a number like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n val=letter0+letter1*26+letter2*26*26+letter3*26*26*26;\n</code>\n</pre>\n", "senID": 2}, {"text": ["to go from val back to letters, you do something like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n letter0=val%26;\nletter1=(val/26)%26;\nletter2=(val/(26*26))%26;\nletter3=(val/(26*26*26))%26;\n</code>\n</pre>\n", "senID": 4}, {"text": ["where \"%\" is your language's modulus operator and \"/\" is an integer division."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["You'll obviously need a way to get from 'A'-'Z' to 0-25 and back.", "That's language dependent."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["You can easily put this into loops.", "I show the loops unrolled to make things a bit more obvious."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["It's more common to pack letters into bytes, so you can use shift and and bitwise operations to encode and decode.", "But by doing it the way I show above, you could pack six letters into a 32-bit number, rather than just four.", "Which is nice, since you can hold things like stock market ticker symbols in a single 32-bit value (mutual funds ticker symbols are 5 characters)."], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "shift", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "and", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "six", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}]]