[[{"text": ["In fact, there's been at least one attempt to add a compose function to functools.", "I guess I understand why they didn't...", "But hey, that doesn't mean we can't make one ourselves:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "at least one attempt", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bugs.python.org/issue1506122"}, {"text": "compose", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "functools", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def compose(f1, f2):\n    def composition(*args, **kwargs):\n        return f1(f2(*args, **kwargs))\n    return composition\n\ndef compose_many(*funcs):\n    if len(funcs) == 1:\n        return funcs[0]\n    if len(funcs) == 2:\n        return compose(funcs[0], funcs[1])\n    else:\n        return compose(funcs[0], compose_many(*funcs[1:]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Tested:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def append_foo(s):\n...     return s + ' foo'\n... \n&gt;&gt;&gt; def append_bar(s):\n...     return s + ' bar'\n... \n&gt;&gt;&gt; append_bar(append_foo('my'))\n'my foo bar'\n&gt;&gt;&gt; compose(append_bar, append_foo)('my')\n'my foo bar'\n&gt;&gt;&gt; def append_baz(s):\n...     return s + ' baz'\n... \n&gt;&gt;&gt; compose_many(append_baz, append_bar, append_foo)('my')\n'my foo bar baz'\n</code>\n</pre>\n", "senID": 3}, {"text": ["Come to think of it, this probably isn't the best solution to your problem.", "But it was fun to write."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["This question has been already asked and has quite a nice answear: Python: How do I pass a variable by reference?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python: How do I pass a variable by reference?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/986006/python-how-do-i-pass-a-variable-by-reference"}]}], [{"text": ["the others already explained why that's not possible, but you could:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for modify in some_func, other_func, yet_another_func:\n var = modify(var)\n</code>\n</pre>\n", "senID": 1}, {"text": ["or as pst said:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n var = yet_another_func(other_func(some_func(var)))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Strings are immutable in python, so your second example can't work.", "In the first example you are binding the name var to a completely new object on each line."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "var", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Typically multiple assignments to a single name like that are a code smell.", "Perhaps if you posted a larger sample of code someone here could show you a better way?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I'm just gonna put this right here (since none of the answers seem to have addressed it yet)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you're commonly repeating the same sequences of functions, consider wrapping them in a higher level function:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def metafunc(var):\n    var = somefunc(var)\n    var = otherfunc(var)\n    var = thirdfunc(var)\n    return lastfunc(var)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then when you call the function metafunc you know exactly what's happening to your var: nothing.", "All you get out of the function call is whatever metafunc returns.", "Additionally you can be certain that nothing is happening in parts of your program that you forgot about.", "This is really important especially in scripting languages where there's usually a lot going on behind the scenes that you don't know about/remember."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "metafunc", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "var", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "metafunc", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "don't", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}, {"text": ["There are benefits and drawbacks to this, the theoretical discussion is under the category of pure functional programming.", "Some real-world interactions (such as i/o operations) require non-pure functions because they need real-world implications beyond the scope of your code's execution.", "The principle behind this is defined briefly here:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["http://en.wikipedia.org/wiki/Functional_programming#Pure_functions"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "http://en.wikipedia.org/wiki/Functional_programming#Pure_functions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Functional_programming#Pure_functions"}]}], [{"text": ["The problem is that str, int and float (long too, if you're in Py 2.x (True and False are really ints, so them too)) are what you call 'immutable types' in Python.", "That means that you can't modify their internal states: all manipulations of an str (or int or float) will result in a \"new\" instance of the str (or whatever) while the old value will remain in Python's cache until the next garbage collection cycle."], "childNum": 10, "tag": "p", "senID": 0, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "float", "childNum": 0, "tag": "code", "childList": []}, {"text": "long", "childNum": 0, "tag": "code", "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "childList": []}, {"text": "float", "childNum": 0, "tag": "code", "childList": []}, {"text": "\"new\"", "childNum": 0, "tag": "em", "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Basically, there's nothing you can do.", "Sorry."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]