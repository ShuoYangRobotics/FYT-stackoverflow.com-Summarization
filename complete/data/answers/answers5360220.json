[[{"text": ["I don't think there's any function in the standard library that does exactly what you need.", "Just using itertools.combinations can get you a list of all possible individual pairs, but doesn't actually solve the problem of all valid pair combinations."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.combinations", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You could solve this easily with:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import itertools\ndef all_pairs(lst):\n    for p in itertools.permutations(lst):\n        i = iter(p)\n        yield zip(i,i)\n</code>\n</pre>\n", "senID": 2}, {"text": ["But this will get you duplicates as it treats (a,b) and (b,a) as different, and also gives all orderings of pairs.", "In the end, I figured it's easier to code this from scratch than trying to filter the results, so here's the correct function."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def all_pairs(lst):\n    if len(lst) &lt; 2:\n        yield lst\n        return\n    a = lst[0]\n    for i in range(1,len(lst)):\n        pair = (a,lst[i])\n        for rest in all_pairs(lst[1:i]+lst[i+1:]):\n            yield [pair] + rest\n</code>\n</pre>\n", "senID": 4}, {"text": ["It's recursive, so it will run into stack issues with a long list, but otherwise does what you need."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n>>> for x in all_pairs([0,1,2,3,4,5]):\n    print x\n\n[(0, 1), (2, 3), (4, 5)]\n[(0, 1), (2, 4), (3, 5)]\n[(0, 1), (2, 5), (3, 4)]\n[(0, 2), (1, 3), (4, 5)]\n[(0, 2), (1, 4), (3, 5)]\n[(0, 2), (1, 5), (3, 4)]\n[(0, 3), (1, 2), (4, 5)]\n[(0, 3), (1, 4), (2, 5)]\n[(0, 3), (1, 5), (2, 4)]\n[(0, 4), (1, 2), (3, 5)]\n[(0, 4), (1, 3), (2, 5)]\n[(0, 4), (1, 5), (2, 3)]\n[(0, 5), (1, 2), (3, 4)]\n[(0, 5), (1, 3), (2, 4)]\n[(0, 5), (1, 4), (2, 3)]\n</pre>\n", "senID": 6}], [{"text": ["Yet another solution.", "Conceptually similar to @shang's, but it does not assume that groups are of size 2 (a pair):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\ndef generate_groups(lst, n):\n    if not lst:\n        yield []\n    else:\n        for group in (((lst[0],) + xs) for xs in itertools.combinations(lst[1:], n-1)):\n            for groups in generate_groups([x for x in lst if x not in group], n):\n                yield [group] + groups\n\npprint(list(generate_groups([0, 1, 2, 3, 4, 5], 2)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which yields the same output others have already found:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [[(0, 1), (2, 3), (4, 5)],\n [(0, 1), (2, 4), (3, 5)],\n [(0, 1), (2, 5), (3, 4)],\n [(0, 2), (1, 3), (4, 5)],\n [(0, 2), (1, 4), (3, 5)],\n [(0, 2), (1, 5), (3, 4)],\n [(0, 3), (1, 2), (4, 5)],\n [(0, 3), (1, 4), (2, 5)],\n [(0, 3), (1, 5), (2, 4)],\n [(0, 4), (1, 2), (3, 5)],\n [(0, 4), (1, 3), (2, 5)],\n [(0, 4), (1, 5), (2, 3)],\n [(0, 5), (1, 2), (3, 4)],\n [(0, 5), (1, 3), (2, 4)],\n [(0, 5), (1, 4), (2, 3)]]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Try the following recursive generator function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def pairs_gen(L):\n    if len(L) == 2:\n        yield [(L[0], L[1])]\n    else:\n        first = L.pop(0)\n        for i, e in enumerate(L):\n            second = L.pop(i)\n            for list_of_pairs in pairs_gen(L):\n                list_of_pairs.insert(0, (first, second))\n                yield list_of_pairs\n            L.insert(i, second)\n        L.insert(0, first)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for pairs in pairs_gen([0, 1, 2, 3, 4, 5]):\n...     print pairs\n...\n[(0, 1), (2, 3), (4, 5)]\n[(0, 1), (2, 4), (3, 5)]\n[(0, 1), (2, 5), (3, 4)]\n[(0, 2), (1, 3), (4, 5)]\n[(0, 2), (1, 4), (3, 5)]\n[(0, 2), (1, 5), (3, 4)]\n[(0, 3), (1, 2), (4, 5)]\n[(0, 3), (1, 4), (2, 5)]\n[(0, 3), (1, 5), (2, 4)]\n[(0, 4), (1, 2), (3, 5)]\n[(0, 4), (1, 3), (2, 5)]\n[(0, 4), (1, 5), (2, 3)]\n[(0, 5), (1, 2), (3, 4)]\n[(0, 5), (1, 3), (2, 4)]\n[(0, 5), (1, 4), (2, 3)]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Take a look at itertools.combinations."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "itertools.combinations", "tag": "a", "pos": 0, "childList": [{"text": "itertools.combinations", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.combinations"}, {"text": "itertools.combinations", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n matt@stanley:~$ python\nPython 2.6.5 (r265:79063, Apr 16 2010, 13:57:41) \n[GCC 4.4.3] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; list(itertools.combinations(range(6), 2))\n[(0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n L = [1, 1, 2, 3, 4]\nanswer = []\nfor i in range(len(L)):\n    for j in range(i+1, len(L)):\n        if (L[i],L[j]) not in answer:\n            answer.append((L[i],L[j]))\n\nprint answer\n[(1, 1), (1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Hope this helps"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n def f(l):\n    if l == []:\n        yield []\n        return\n    ll = l[1:]\n    for j in range(len(ll)):\n        for end in f(ll[:j] + ll[j+1:]):\n            yield [(l[0], ll[j])] + end\n</code>\n</pre>\n", "senID": 0}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for x in f([0,1,2,3,4,5]):\n    print x\n\n&gt;&gt;&gt; \n[(0, 1), (2, 3), (4, 5)]\n[(0, 1), (2, 4), (3, 5)]\n[(0, 1), (2, 5), (3, 4)]\n[(0, 2), (1, 3), (4, 5)]\n[(0, 2), (1, 4), (3, 5)]\n[(0, 2), (1, 5), (3, 4)]\n[(0, 3), (1, 2), (4, 5)]\n[(0, 3), (1, 4), (2, 5)]\n[(0, 3), (1, 5), (2, 4)]\n[(0, 4), (1, 2), (3, 5)]\n[(0, 4), (1, 3), (2, 5)]\n[(0, 4), (1, 5), (2, 3)]\n[(0, 5), (1, 2), (3, 4)]\n[(0, 5), (1, 3), (2, 4)]\n[(0, 5), (1, 4), (2, 3)]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["How about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n items = [\"me\", \"you\", \"him\"]\n[(items[i],items[j]) for i in range(len(items)) for j in range(i+1, len(items))]\n\n[('me', 'you'), ('me', 'him'), ('you', 'him')]\n</code>\n</pre>\n", "senID": 1}, {"text": ["or "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n items = [1, 2, 3, 5, 6]\n[(items[i],items[j]) for i in range(len(items)) for j in range(i+1, len(items))]\n\n[(1, 2), (1, 3), (1, 5), (1, 6), (2, 3), (2, 5), (2, 6), (3, 5), (3, 6), (5, 6)]\n</code>\n</pre>\n", "senID": 3}]]