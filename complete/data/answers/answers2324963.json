[[{"text": ["The code in a join function knows upfront all the strings its being asked to concatenate and how large those strings are hence it can calculate the final string length before beginning the operation.", "Hence it need only allocate memory for the final string once and then it can place each source string (and delimiter) in the correct place in memory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["On the other hand a single += operation on a string has no choice but to simply allocate enough memory for the final string which is the concatenation of just two strings.", "Subsequent += must do the same, each allocating memory which on the next += will be discarded.", "Each time the ever growing string is copied from one place in memory to another."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The reason is that strings in Python (and many other languages) are immutable objects - that is, once created, they can't be changed.", "Instead, concatenating a string actually makes a new string which consists of the contents of the two smaller strings being concatenated, and then replaces the old string with the new one."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "immutable objects", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Immutable_object"}, {"text": "new", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Since creating a string takes a certain amount of time (need to allocate memory, copy the contents of the string to that memory, et cetera), making many strings takes longer than making a single string.", "Doing N concatenations requires creating N new strings in the process.", "join(), on the other hand, only has to create a single string (the final result) and thus works much faster."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "N", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "N", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "join()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["See http://stackoverflow.com/questions/476772/python-string-join-performance and one specific anwser that describes it very well:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://stackoverflow.com/questions/476772/python-string-join-performance", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/476772/python-string-join-performance"}]}], [{"text": ["This is because a larger and larger chunk of memory has to be allocated for the string concatenation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n x = 'a' # String of size 1 allocated\nx += 'b' # String of size 2 allocated, x copied, and 'b' added. Old x discarded\nx += 'b' # String of size 3 allocated, x copied, and 'c' added. Old x discarded\nx += 'b' # String of size 4 allocated, x copied, and 'd' added. Old x discarded\nx += 'b' # String of size 5 allocated, x copied, and 'e' added. Old x discarded\n</code>\n</pre>\n", "senID": 1}, {"text": ["So what happens is you perform large allocations and copies,  but then turn around and throw them away.", "Very wasteful."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n x = ['a', 'b', ..., 'z'] # 26 small allocations\nx = ''.join(x) # A single, large allocation\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The other responses have basically covered it, but if you want even more detail, Joel Spolsky has an article where he describes \"Schlemiel the painter's algorithm\", which is extremely relevant and nicely makes the case for why understanding this sort of low level implementation detail is still very important even if you're working in a high level language like Python."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Schlemiel the painter's algorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.joelonsoftware.com/articles/fog0000000319.html"}]}], [{"text": ["Well, this is heavily language dependant, but in general the idea there is, that one big operation is faster than many small ones.", "In your second example, the join knows all the elements that it has to join and thus can just allocate the neccesary resources and put the characters in.", "The concatenation in your first example has to reallocate resources at every single step (worst case)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I don't know the internals of join, but in the first version you create a new string every time you call the += operator.", "Since strings are immutable, every time new memory is allocated and a copy is made."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Now, the join (which is a string method) could only do a single allocation, since it can calculate the size beforehand."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]