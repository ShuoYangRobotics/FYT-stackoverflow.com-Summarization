[[{"text": ["I would stick with the factory function approach.", "It's very standard python and easy to read and understand.", "You could make it more generic to handle more options in several ways such as by passing in the discriminator function and a map of results to classes.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If the first example works it's more by luck than by design.", "What if you wanted to have an __init__ defined in your subclass?  "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You shouldn't need metaclasses for this.", "Take a look at the __new__ method.", "This will allow you to take control of the creation of the object, rather than just the initialisation, and so return an object of your choosing."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__new__", "tag": "a", "pos": 1, "childList": [{"text": "__new__", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/reference/datamodel.html#object.__new__"}, {"text": "__new__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n class Project(object):\n  \"Base class and factory.\"\n  def __new__(cls, url):\n    if is_url_local(url):\n       return super(Project, cls).__new__(ProjectLocal, url) \n    else:\n       return super(Project, cls).__new__(ProjectRemote, url) \n\n  def __init__(self, url):\n    self.url = url\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The following links may be helpful:\nhttp://www.suttoncourtenay.org.uk/duncan/accu/pythonpatterns.html#factory\nhttp://code.activestate.com/recipes/86900/"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "http://www.suttoncourtenay.org.uk/duncan/accu/pythonpatterns.html#factory", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.suttoncourtenay.org.uk/duncan/accu/pythonpatterns.html#factory"}, {"href": "http://code.activestate.com/recipes/86900/", "text": "http://code.activestate.com/recipes/86900/", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["In addition, as you are using new style classes, using __new__ as the factory function (and not in a base class, a separate class is better) is what is usually done (as far as I know)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["A factory function is generally simpler (as other people have already posted)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In addition, it isn't a good idea to set the __class__ attribute the way you have done."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I hope you find the answer and the links helpful."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["All the best."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I usually have a seperate factory class to do this.", "This way you don't have to use meta classes or assignments to self.__class__"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "self.__class__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I also try to avoid to put the knowledge about which classes are available for creation into the factory.", "Rather, I have all the available classes register themselves withe the factory during module import.", "The give there class and some information about when to select this class to the factory (this could be a name, a regex or a callable (e.g.", "a class method of the registering class))."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Works very well for me and also implements such things like encapsulation and information hiding."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I think the second approach using a factory function is a lot cleaner than making the implementation of your base class depend on its subclasses."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Yeah, as mentioned by @scooterXL, factory function is the best approach in that case, but I like to note a case for factories as classmethods."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Consider the following class hierarchy:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Base(object):\n\n    def __init__(self, config):\n        \"\"\" Initialize Base object with config as dict.\"\"\"\n        self.config = config\n\n    @classmethod\n    def from_file(cls, filename):\n        config = read_and_parse_file_with_config(filename)\n        return cls(filename)\n\nclass ExtendedBase(Base):\n\n    def behaviour(self):\n        pass # do something specific to ExtendedBase\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now you can create Base objects from config dict and from config file:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; Base({\"k\": \"v\"})\n&gt;&gt;&gt; Base.from_file(\"/etc/base/base.conf\")\n</code>\n</pre>\n", "senID": 4}, {"text": ["But also, you can do the same with ExtendedBase for free:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; ExtendedBase({\"k\": \"v\"})\n&gt;&gt;&gt; ExtendedBase.from_file(\"/etc/extended/extended.conf\")\n</code>\n</pre>\n", "senID": 6}, {"text": ["So, this classmethod factory can be also considered as auxiliary constructor."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]]