[[{"text": ["One of the best architectures is already part of Linux OS's.", "No special libraries required."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You want a \"fan-out\" design."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Each subprocess should probably be a pipeline of distinct processes that read and write from stdin."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You don't need a queue data structure, that's exactly what an in-memory pipeline is -- a queue of bytes between two concurrent processes."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["One strategy is to assign each worker an offset so if you have eight worker processes you assign then numbers 0 to 7.", "Worker number 0 reads the first record processes it then skips 7 and goes on to process the 8th record etc., worker number 1 reads the second record then skips 7 and processes the 9th record........."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There are a number of advantages to this scheme.", "It doesnt matter how big the file is the work is always divided evenly, processes on the same machine will process at roughly the same rate, and use the same buffer areas so you dont incur any excessive I/O overhead.", "As long as the file hasnt been updated you can rerun individual threads to recover from failures."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You dont mention how you are processing the lines; possibly the most important piece of info."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Is each line independant?", "Is the calculation dependant on one line coming before the next?", "Must they be processed in blocks?", "How long does the processing for each line take?", "Is there a processing step that must incorporate \"all\" the data at the end?", "Or can intermediate results be thrown away and just a running total maintained?", "Can the file be initially split by dividing filesize by count of threads?", "Or does it grow as you process it?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If the lines are independant and the file doesn't grow, the only coordination you need is to farm out \"starting addresses\" and \"lengths\" to each of the workers; they can independantly open and seek into the file and then you must simply coordinate their results; perhaps by waiting for N results to come back into a queue."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If the lines are not independant, the answer will depend highly on the structure of the file."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["It depends a lot on the format of your file."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Does it make sense to split it anywhere?", "Or do you need to split it at a new line?", "Or do you need to make sure that you split it at the end of an object definition?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Instead of splitting the file, you should use multiple readers on the same file, using os.lseek to jump to the appropriate part of the file."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "os.lseek", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Update: Poster added that he wants to split on new lines.", "Then I propose the following:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Let's say you have 4 processes.", "Then the simple solution is to os.lseek to 0%, 25%, 50% and 75% of the file, and read bytes until you hit the first new line.", "That's your starting point for each process.", "You don't need to split the file to do this, just seek to the right location in the large file in each process and start reading from there."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I know you specifically asked about Python, but I will encourage you to look at Hadoop (http://hadoop.apache.org/): it implements the Map and Reduce algorithm which was specifically designed to address this kind of problem. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://hadoop.apache.org/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://hadoop.apache.org/"}]}, {"text": ["Good luck"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Fredrik Lundh's Some Notes on Tim Bray's Wide Finder Benchmark is an interesting read, about a very similar use case, with a lot of good advice.", "Various other authors also implemented the same thing, some are linked from the article, but you might want to try googling for \"python wide finder\" or something to find some more.", "(there was also a solution somewhere based on the multiprocessing module, but that doesn't seem to be available anymore)"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Some Notes on Tim Bray's Wide Finder Benchmark", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/wide-finder.htm"}, {"text": "multiprocessing", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["If the run time is long, instead of having each process read its next line through a Queue, have the processes read batches of lines.", "This way the overhead is amortized over several lines (e.g.", "thousands or more)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Queue", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]