[[{"text": ["This can sort of turn into a religious war.", "It's a matter of whether you want to be explicit or whether you want to avoid being too verbose.", "In general, following the Zen of Python, it's better to be explicit, but sometimes people just don't find it practical to list every import from particular module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Zen of Python", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0020/"}]}], [{"text": ["My general rule is that if I didn't write the module, I don't import it all.", "My biggest fear is actually over writing local variables that might have been defined in the imported module.", "So to keep from having to type in long module names, I use the import as feature.", "Using your module as an example I would do the following:  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import PyQt4.QtCore as qt\n</code>\n</pre>\n", "senID": 1}, {"text": ["That being said, I have many support modules that I write that I will import everything.", "Like the pyqt module, I name them with a descriptive name that helps show which module it came from."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit per comment\n When I use import*, my support modules do not contain classes or anything that can create a new instance.", "They tend to be groups of functions that modify existing instances only.", "To help clarify my opinion: If I am the owner of the source code and I will be the primary maintainer, I will use the import* otherwise I would use the import as.  "], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Edit per comment", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"text": ["Another reason that I use the import as feature is to allow me to mock modules for debugging purposes.", "In a project that I am working on now, I use pyVisa to talk to a number of GPIB devices.", "When I'm not connected to the devices GPIB network, I can use a dummy_visa module to write to the stdout(to verify I am sending the correct format) and return a random number (to test my application).", "See below  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n if visa_debug:\n    import dummy_visa as visa\nelse:\n    import visa\ngpib = visa.Instrument(\"GPIB0::10\")\ngpib.write(\"MEAS:VOLT?\")\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Making an explicit exception for modules that already include a namespace in their naming convention (such as the Q* of PyQT) is perfectly reasonably.", "However, I recommend being clear that the default is still \"don't use it\" and simply list this exception in your coding guidelines."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Q*", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["import * is also acceptable when it is used as a namespace manipulation trick within an application (the two forms of that I am familiar with are optional C acceleration modules that are imported at the end of the pure Python version, and \"flattening\" a package namespace in __init__).", "The key point is that the importing module and the module being imported are under the control of the same set of developers, and hence avoiding namespace clashes is completely within their control."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "import *", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The final exception is for convenience at the interactive prompt."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In other situations, it is best to either import specific names or reference them indirectly through the module name (or, if there are some commonly reference items, do both:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["import module  # Can access anything\n   from module import a, b, c # But we reference these a lot, so retrieve them directly"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I find import * gets abused, and can become a maintenance headache, so I avoid it for this and the other reasons you state.", "That said I feel it's okay for short interactive sessions, e.g.", "from pylab import *."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "import *", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "from pylab import *", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["In production code, for packages like PyQt4.QtCore where you plan to use many of the symbols, I'd use one of the following syntaxes which make it explicit which namespace the symbols come from:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "PyQt4.QtCore", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from PyQt4 import QtCore\n# explicit where the symbol came from\nQtCore.QTime()\n\nimport PyQt4.QtCore as QT\n# less desirable since you need to look in the header to find out what QT is\n# but I still prefer it to import *\nQT.QTime()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["In general, if you're going to use from X import Y, it's a good idea to be explicit about what you're importing.", "That's not just because it's safer, but also because it makes your code more readable (and upgrades to the third-party modules you're using won't have as much potential to incidentally break your code)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "from X import Y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In some code examples demonstrating big packages, like Qt or matplotlib, the examples will use from module import * because they're often only importing from one module, and it saves typing and lets their example code get to the point.", "There's no reason you can't do it in your code, but at least use it in moderation, especially if it's in big source files or other people will be looking at your code."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "from module import *", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "can't", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["Tutorial, chapter 6:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "chapter 6", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/modules.html"}]}, {"text": ["Tutorial, chapter 10:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "chapter 10", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/stdlib.html"}]}, {"text": ["So it seems that it is definitely a bad idea sometimes; not-the-best idea most of the time; and an acceptable shortcut in cases where you'd want to type less, eg in interactive sessions."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The PyQt design is water under the bridge.", "I'm not sure it's the best thing, but it's probably influenced by the way Qt was designed.", "AFAIK, Qt didn't use C++ namespaces historically (I'm not sure if it uses them now), and therefore had to use prefixes.", "But all of those design decisions probably happened more than 10 years ago, and that shouldn't affect your design decisions now."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "now", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["I know that if I was designing a library now, I would definitely choose to use package namespaces (which you would import explicitly in Python) over prefixes.", "Let's say my prefix is Pfx - if the library user doesn't care writing PfxFunc() every time he needs a function, he certainly wouldn't care about the extra character in Pfx.Func(), especially when he can use import with specific symbol names to shorten that even more."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "PfxFunc()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Pfx.Func()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Consider this case"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from foo import *\nfrom bar import *\n\nx=baz()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now suppose foo has a function called baz() that we are using in our code and everything is working fine.", "Months or years pass, the author of bar adds a function called baz().", "Someone updates the egg ang bingo - we have a potentially hard to detect bug in the program."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "baz()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "bar", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "baz()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Not to mention that just looking at those three lines of code, I can't tell where baz comes from without going and looking at foo and bar"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "baz", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "childList": []}, {"text": "bar", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The only time I'd use import * would be in the interpreter to save some typing"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "import *", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]