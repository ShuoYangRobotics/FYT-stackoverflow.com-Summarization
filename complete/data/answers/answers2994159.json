[[{"text": ["It's hard to give a great answer without knowing more about your constraints, but if you can store a hash for each line of each file then you should be ok.  At the very least you'll need to be able to store the hash list for one file, which you then would sort and write to disk, then you can march through the two sorted lists together."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The only reason why I can imagine the above not working as written would be because your hashing function doesn't always give the same output for a given input.", "You could test that a second run through old.csv generates the same list.", "It may have to do with errant spaces, tabs-instead-of-spaces, differing capitalization, \"automatic"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Mind, even if the hashes are equivalent you don't know that the lines match; you only know that they might match.", "You still need to check that the candidate lines do match.", "(You may also get the situation where more than one line in the input file generates the same hash, so you'll need to handle that as well."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["After you fill your hashes variable, you should consider turning it into a set (hashes = set(hashes)) so that your lookups can be faster than linear."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "hashes", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "hashes = set(hashes)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Given the loose syntactic definition of CSV, it is possible for two rows to be semantically equal while being lexically different.", "The various Dialect definitions give some clue as two how two rows could be individually well-formed but incommensurable.", "And this example shows how they could be in the same dialect and not string equivalent:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Dialect definitions", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/csv.html#csv-fmt-params"}]}, {"code": "<pre>\n<code>\n 0, 0\n0, 0.0\n</code>\n</pre>\n", "senID": 1}, {"text": ["More information would help yield a better answer your question."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["More information would be needed on what exactly \"failing miserably\" means.", "If you are just not getting correct comparison between the two, perhaps Hashlib might solve that."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Hashlib", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/hashlib.html?highlight=hash#module-hashlib"}]}, {"text": ["I've run into trouble previously when using the built in hash library, and solved it with that."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit: As someone suggested on another post, the issue could be with assuming that the two files are required to have each line be EXACTLY the same.", "You might want to try parsing the csv fields and appending them to a string with identical formatting (maybe trim spaces, force lowercase, etc) before computing the hash."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I'm pretty sure that the \"failing miserably\" line refers to a failure in time that comes from your current algorithm being O(N^2) which is quite bad for how big your files are.", "As has been mentioned, you can use a set to alieviate this problem (will become O(N)) or if you aren't able to do that for some reason then you can sort the list of hashes and use a binary search on it (will become O(N log N) which is also doable.", "You can use the bisect module if you go the binary search route."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "bisect", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Also, it has been mentioned that you may have the problem of a clash in the hashes: two lines yielding the same hash when the lines aren't exactly the same.", "If you discover that this is a problem that you are experiencing, you will have to store info with each hash about where to seek the line corresponding to the hash in the old.csv file and then seek the line out and compare the two lines."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "old.csv", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["An alternative to your current method is to sort the two files beforehand (using some sort of merge sort to disk perhaps or shell sort) and, keeping pointers to lines in each file, compare the two lines.", "Check if they match, and if not then advance the line that is measured as being lesser.", "This algorithm is also O(N log N) as long as an O(N log N) method is used for sorting.", "The sorting could also be done by putting each file into a database and having the database sort them. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This is likely a problem with (mis)using hash.", "See this SO question; as the answers there point out, you probably want hashlib."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "hash", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "this SO question", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/793761/built-in-python-hash-function"}, {"href": "http://docs.python.org/library/hashlib.html", "text": "hashlib", "childNum": 1, "tag": "a", "childList": [{"text": "hashlib", "tag": "code"}]}, {"text": "hashlib", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You need to say what your problem really is.", "Your description \"I need to ensure that a row from one file does not appear in the other file\" is consistent with the body of your second loop being if hash(...) in hashes: print \"Found (an interloper)\" rather that what you have."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "if hash(...) in hashes: print \"Found (an interloper)\"", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["We can't tell you \"why didn't the above method work\" because you haven't told us what the symptoms of \"failed miserably\" and \"didn't work\" are."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Have you perhaps considered running a sort (if possible) - you'll have to go over twice of course - but might solve the mem problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]