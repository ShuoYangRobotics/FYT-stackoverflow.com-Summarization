[[{"text": ["I would try:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\noutput = defaultdict(lambda: 0)\nfor item in the_list: output[item] += 1\nreturn sorted(output.items())\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Taking advantage of the qualification \"between 0 and 12\":"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; the_list = [5, 7, 6, 5, 5, 4, 4, 7, 5, 4]\n&gt;&gt;&gt; answer1 = [0] * 13\n&gt;&gt;&gt; for i in the_list:\n...    answer1[i] += 1\n...\n&gt;&gt;&gt; answer1\n[0, 0, 0, 0, 3, 4, 1, 2, 0, 0, 0, 0, 0]\n&gt;&gt;&gt; # You might be able to use that as-is:\n...\n&gt;&gt;&gt; for i, v in enumerate(answer1):\n...     if v: print i, v\n...\n4 3\n5 4\n6 1\n7 2\n&gt;&gt;&gt; # Otherwise you can build the list that you specified:\n...\n&gt;&gt;&gt; answer2 = [(i, v) for i, v in enumerate(answer1) if v]\n&gt;&gt;&gt; answer2\n[(4, 3), (5, 4), (6, 1), (7, 2)]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Change where you sort for a savings of about 20%."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Change this: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def dupli(the_list):\n    return [(item, the_list.count(item)) for item in sorted(set(the_list))]\n</code>\n</pre>\n", "senID": 2}, {"text": ["To this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def dupli(the_list):\n    count = the_list.count # this optimization added courtesy of Sven's comment\n    result = [(item, count(item)) for item in set(the_list)]\n    result.sort()\n    return result\n</code>\n</pre>\n", "senID": 4}, {"text": ["The reason this is faster is that the sorted iterator must create a temporary list, whereas sorting the result sorts in place."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "sorted", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["edit:\nHere's another approach that is 35% faster than your original:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def dupli(the_list):\n    counts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    for n in the_list:\n        counts[n] += 1\n    return [(i, counts[i]) for i in (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12) if counts[i]]\n</code>\n</pre>\n", "senID": 7}, {"text": ["Note:  You may want to randomize the values for the_list.", "My final version of dupli tests even faster with other random data sets (import random; the_list=[random.randint(0,12) for i in xrange(10)])"], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "the_list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dupli", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "import random; the_list=[random.randint(0,12) for i in xrange(10)]", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["It might be faster to write your own function that counts the numbers in one pass through the list.", "You're calling the count function for every number in the set, and each of those calls requires a pass through the list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n counts = {}\nfor n in the_list:\n    if n not in counts:\n        counts[n] = 0\n    counts[n] += 1\nsorted(counts.items())\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This seems fairly optimal in terms of space and speed:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def dupli2(list_):                                    \n    dict_ = {}                                       \n    for item in list_:                               \n        dict_[item] = dict_.get(item, 0) + 1         \n    return sorted(dict_.items())\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def dupli3(list_):                                            \n    last = None                                               \n    list_ = sorted(list_)                                     \n\n    i = 0                                                     \n    for item in list_:                                        \n        if item != last and last is not None:                 \n            yield last, i                                     \n            i = 0                                             \n        i += 1                                                \n        last = item                                           \n\n    yield last, i\n</code>\n</pre>\n", "senID": 3}, {"text": ["Not sure about the speed though.", "For that I'd recommend that you either do it in C or use Psyco ;)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["With Psyco:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n In [33]: %timeit list(dupli3(test.the_list))\n100000 loops, best of 3: 6.46 us per loop\n\nIn [34]: %timeit list(dupli2(test.the_list))\n100000 loops, best of 3: 2.37 us per loop\n\nIn [35]: %timeit list(dupli(test.the_list))\n100000 loops, best of 3: 2.7 us per loop\n</code>\n</pre>\n", "senID": 6}], [{"text": ["itertools.groupby is perfect for this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import groupby\n&gt;&gt;&gt; the_list = [5, 7, 6, 5, 5, 4, 4, 7, 5, 4]\n&gt;&gt;&gt; gb = groupby(sorted(the_list))\n&gt;&gt;&gt; print [(i,len(list(j))) for i,j in gb]\n[(4, 3), (5, 4), (6, 1), (7, 2)]\n</code>\n</pre>\n", "senID": 1}]]