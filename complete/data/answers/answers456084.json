[[{"text": ["How about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n A = '1, 2,,3,4  '\nB = [int(x) for x in A.split(',') if x.strip()]\n</code>\n</pre>\n", "senID": 1}, {"text": ["x.strip() trims whitespace from the string, which will make it empty if the string is all whitespace.", "An empty string is \"false\" in a boolean context, so it's filtered by the if part of the list comprehension."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Mmm, functional goodness (with a bit of generator expression thrown in):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = \"1,2,,3,4,\"\nprint map(int, filter(None, (i.strip() for i in a.split(','))))\n</code>\n</pre>\n", "senID": 1}, {"text": ["For full functional joy:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import string\na = \"1,2,,3,4,\"\nprint map(int, filter(None, map(string.strip, a.split(','))))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Generally, I try to avoid regular expressions, but if you want to split on a bunch of different things, they work.", "Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nresult = [int(x) for x in filter(None, re.split('[,\\n,\\t]', A))]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = \"1,2,,3,4,\"\n&gt;&gt;&gt; map(int,filter(None,a.split(\",\")))\n[1, 2, 3, 4]\n</code>\n</pre>\n", "senID": 1}, {"text": ["filter will remove all false values (i.e.", "empty strings), which are then mapped to int."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: Just tested this against the above posted versions, and it seems to be significantly faster, 15% or so compared to the strip() one and more than twice as fast as the isdigit() one"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This will work, and never raise an exception, if all the numbers are ints.", "The isdigit() call is false if there's a decimal point in the string."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "isdigit()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; nums = ['1,,2,3,\\n,4\\n', '1,2,3,4', ',1,2,3,4,\\t\\n', '\\n\\t,1,2,3,,4\\n']\n&gt;&gt;&gt; for n in nums:\n...     [ int(i.strip()) for i in n if i.strip() and i.strip().isdigit() ]\n... \n[1, 2, 3, 4]\n[1, 2, 3, 4]\n[1, 2, 3, 4]\n[1, 2, 3, 4]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Why not just wrap in a try except block which catches anything not an integer?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Why accept inferior substitutes that cannot segfault your interpreter?", "With ctypes you can just call the real thing!", ":-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # strtok in Python\nfrom ctypes import c_char_p, cdll\n\ntry: libc = cdll.LoadLibrary('libc.so.6')\nexcept WindowsError:\n     libc = cdll.LoadLibrary('msvcrt.dll')\n\nlibc.strtok.restype = c_char_p\ndat = c_char_p(\"1,,2,3,4\")\nsep = c_char_p(\",\\n\\t\")\nresult = [libc.strtok(dat, sep)] + list(iter(lambda: libc.strtok(None, sep), None))\nprint(result)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'd guess regular expressions are the way to go: http://docs.python.org/library/re.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/re.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html"}]}]]