[[{"text": ["Keys cannot be changed.", "You will need to add a new key with the modified value then remove the old one, or create a new dict with a dict comprehension or the like."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["For example like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def appendabc(somedict):\n    return dict(map(lambda (key, value): (str(key)+\"abc\", value), somedict.items()))\n\ndef transform(multilevelDict):\n    new = appendabc(multilevelDict)\n\n    for key, value in new.items():\n        if isinstance(value, dict):\n            new[key] = transform(value)\n\n    return new\n\nprint transform({1:2, \"bam\":4, 33:{3:4, 5:7}})\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will append \"abc\" to each key in the dictionary and any value that is a dictionary."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: There's also a really cool Python 3 version, check it out:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def transform(multilevelDict):\n    return {str(key)+\"abc\" : (transform(value) if isinstance(value, dict) else value) for key, value in multilevelDict.items()}\n\nprint(transform({1:2, \"bam\":4, 33:{3:4, 5:7}}))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["My understanding is that you can't change the keys, and that you would need to make a new set of keys and assign their values to the ones the original keys were pointing to."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I'd do something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def change_keys(d):\n  if type(d) is dict:\n    return dict([(k+'abc', change_keys(v)) for k, v in d.items()])\n  else:\n    return d\n\nnew_dict = change_keys(old_dict)\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n #! /usr/bin/env python\n\nd = {'fruit':'orange', 'colors':{'dark':4,'light':5}}\n\ndef add_abc(d):\n  newd = dict()\n  for k,v in d.iteritems():\n    if isinstance(v, dict):\n      v = add_abc(v)\n    newd[k + \"abc\"] = v\n  return newd\n\nd = add_abc(d)\nprint d\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; mydict={'fruit':'orange','colors':{'dark':4,'light':5}}\n\n&gt;&gt;&gt; def f(mydict):\n...  return dict((k+\"abc\",f(v) if hasattr(v,'keys') else v) for k,v in mydict.items())\n... \n&gt;&gt;&gt; f(mydict)\n{'fruitabc': 'orange', 'colorsabc': {'darkabc': 4, 'lightabc': 5}}\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Something like that"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def applytoallkeys( dic, func ):\n    def yielder():\n        for k,v in dic.iteritems():\n            if isinstance( v, dict):\n                yield func(k), applytoallkeys( v, func )\n            else:\n                yield func(k), v\n    return dict(yielder())\n\ndef appendword( s ):\n    def appender( x ):\n        return x+s\n    return appender\n\nd = {'fruit':'orange','colors':{'dark':4,'light':5}}\nprint applytoallkeys( d, appendword('asd') )\n</code>\n</pre>\n", "senID": 1}, {"text": ["I kinda like functional style, you can read just the last line and see what it does ;-)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could do this with recursion:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import collections\nin_dict={'fruit':'orange','colors':{'dark':4,'light':5}}\n\ndef transform_dict(d):\n    out_dict={}\n    for k,v in d.iteritems():\n        k=k+'abc'\n        if isinstance(v,collections.MutableMapping):\n            v=transform_dict(v)            \n        out_dict[k]=v\n    return out_dict\nout_dict=transform_dict(in_dict)\nprint(out_dict)\n\n# {'fruitabc': 'orange', 'colorsabc': {'darkabc': 4, 'lightabc': 5}}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["you should also consider that there is the possibility of nested dicts in nested lists, which will not be covered by the above solutions.", "This function ads a prefix and/or a postfix to every key within the dict."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def transformDict(multilevelDict, prefix=\"\", postfix=\"\"):\n\"\"\"adds a prefix and/or postfix to every key name in a dict\"\"\"\nnew_dict = multilevelDict\nif prefix != \"\" or postfix != \"\":\n    new_key = \"%s#key#%s\" % (prefix, postfix)\n    new_dict = dict(map(lambda (key, value): (new_key.replace('#key#', str(key)), value), new_dict.items()))\n    for key, value in new_dict.items():\n        if isinstance(value, dict):\n            new_dict[key] = transformDict(value, prefix, postfix)\n        elif isinstance(value, list):\n            for index, item in enumerate(value):\n                if isinstance(item, dict):\n                    new_dict[key][index] = transformDict(item, prefix, postfix)\nreturn new_dict\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I use the following utility function that I wrote that takes a target dict and another dict containing the translation and switches all the keys according to it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def rename_keys(d, keys):\n    return dict([(keys.get(k), v) for k, v in d.items()])\n</code>\n</pre>\n", "senID": 1}, {"text": ["So with the initial data:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n data = { 'a' : 1, 'b' : 2, 'c' : 3 }\ntranslation = { 'a' : 'aaa', 'b' : 'bbb', 'c' : 'ccc' }\n</code>\n</pre>\n", "senID": 3}, {"text": ["We get the following:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; data\n{'a': 1, 'c': 3, 'b': 2}\n&gt;&gt;&gt; rename_keys(data, translation)\n{'aaa': 1, 'bbb': 2, 'ccc': 3}\n</code>\n</pre>\n", "senID": 5}]]