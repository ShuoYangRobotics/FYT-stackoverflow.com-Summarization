[[{"text": ["Why not just generate the right number of uniformly distributed random numbers, tot them up and scale ?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["EDIT: To be a bit clearer: you want N numbers which sum to S ?", "So generate N uniformly distributed random numbers on the interval [0,1) or whatever your RNG produces.", "Add them up, they will total s (say) whereas you want them to total S, so multiply each number by S/s.", "Now the numbers are uniformly randomly distributed on [0,S/s) I think."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Here's how I would do it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Now, the lengths of those intervals will always sum up to max, since they simply represent segments inside [0,max]."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "max", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "max", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Code (in Python):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #! /usr/bin/env python\nimport random\n\ndef random_numbers(n,sum_to):\n    values=[0]+[random.randint(0,sum_to) for i in xrange(n-1)]+[sum_to]\n    values.sort()\n    intervals=[values[i+1]-values[i] for i in xrange(len(values)-1)]\n    return intervals\n\nif __name__=='__main__':\n    print random_numbers(5,100)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If you are looking for normally-distributed numbers with as little correlation as possible, and need to be rigorous* about this, I would suggest you take the following mathematical approach and translate into code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(*rigorous: the problem with other approaches is that you can get \"long tails\" in your distributions -- in other words, it is rare but possible to have outliers that are very different from your expected output)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Generate N-1 independent and identically distributed (IID) gaussian random variables v", "tag": "none", "senID": 2}, {"text": "Create a column vector V where V = [0 v", "tag": "none", "senID": 3}, {"text": "Use a fixed weighting matrix W, where W consists of an orthonormal matrix** whose top row is [1 1 1 1 1 1 1 ... 1] / sqrt(N).", "tag": "none", "senID": 4}, {"text": "Your output vector is the product WV + SU/N where S is the desired sum and U is the column vector of 1's. In other words, the i'th output variable = the dot product of (row #i of matrix W) and column vector V, added to S/N.", "tag": "none", "senID": 5}]}, {"text": ["The standard deviation of each output variable will be (I believe, can't verify right now) sqrt(N/N-1) * the standard deviation of the input random variables."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["**orthonormal matrix: this is the hard part, I put in a question at math.stackexchange.com and there's a simple matrix W that works, and can be defined algorithmically with only 3 distinct values, so that you don't actually have to construct the matrix."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "a question at math.stackexchange.com", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://math.stackexchange.com/questions/7122"}]}, {"text": ["W is the Householder reflection of v-w where v = [sqrt(N), 0, 0, 0, ... ] and w = [1 1 1 1 1 ... 1] can be defined by:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n W(1,i) = W(i,1) = 1/sqrt(N)\nW(i,i) = 1 - K   for i &gt;= 2 \nW(i,j) = -K      for i,j &gt;= 2, i != j\nK = 1/sqrt(N)/(sqrt(N)-1)\n</code>\n</pre>\n", "senID": 9}, {"text": ["The problem with Mark's approach:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["is that if you do this, you get a \"long tail\" distribution.", "Here's an example in MATLAB:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt; X = rand(100000,10);\n &gt;&gt; Y = X ./ repmat(sum(X,2),1,10);\n &gt;&gt; plot(sort(Y))\n</code>\n</pre>\n", "senID": 12}, {"text": ["I've generated 100,000 sets of N=10 numbers in matrix X, and created matrix Y where each row of Y is the corresponding row of X divided by its sum (so that each row of Y sums to 1.0)"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["Plotting the sorted values of Y (each column sorted separately) yields approximately the same cumulative distribution:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"src": "http://i.stack.imgur.com/o9dl8.png", "tag": "img", "senID": 15}, {"text": ["A true uniform distribution would yield a straight line from 0 to the maximum value.", "You'll notice that it's sort of vaguely similar to a true uniform distribution, except at the end where there's a long tail.", "There's an excess of numbers generated between 0.2 and 0.5.", "The tail gets worse for larger values of N, because although the average value of the numbers goes down (mean = 1 / N), the maximum value stays at 1.0: the vector consisting of 9 values of 0.0 and 1 value of 1.0 is valid and can be generated this way, but is pathologically rare."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["If you don't care about this, go ahead and use this method.", "And there are probably ways to generate \"almost\"-uniform or \"almost\"-gaussian distributions with desired sums, that are much simpler and more efficient than the one I describe above.", "But I caution you to be careful and understand the consequences of the algorithm you choose."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["One fixup that leaves things sort-of-uniformly distributed without the long tail, is as follows:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["Example in MATLAB for N=10:"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt; X = rand(100000,10);\n &gt;&gt; Y = X ./ repmat(sum(X,2),1,10);\n &gt;&gt; i = sum(X,2)&gt;(10/2)*max(X,[],2);\n &gt;&gt; plot(sort(Y(i,:)))\n</code>\n</pre>\n", "senID": 20}, {"src": "http://i.stack.imgur.com/BVBm8.png", "tag": "img", "senID": 21}], [{"text": ["All right, we're going to tackle the problem assuming the requirement is to generate a random vector of length N that is uniformly distributed over the allowed space, restated as follows:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "uniformly distributed", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Given "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "a desired length L,", "tag": "none", "senID": 2}, {"text": "a desired total sum S,", "tag": "none", "senID": 3}, {"text": "a range of allowed values [0,B] for each scalar value,", "tag": "none", "senID": 4}]}, {"text": ["generate a random vector V of length N such that the random variable V is uniformly distributed throughout its permitted space."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["We can simplify the problem by noting that we can calculate V = U * S where U is a similar random vector with desired total sum 1, and a range of allowed values [0,b] where b = B/S.", "The value b must be between 1/N and 1."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["First consider N = 3.", "The space of allowed values {U} is a portion of a plane perpendicular to the vector [1 1 1] that passes through the point [1/3 1/3 1/3] and which lies inside the cube whose components range between 0 and b.", "This set of points {U} is shaped like a hexagon."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["(TBD: picture.", "I can't generate one right now, I need access to MATLAB or another program that can do 3D plots.", "My installation of Octave can't."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["It is best to use an orthonormal weighting matrix W (see my other answer) with one vector = [1 1 1]/sqrt(3).", "One such matrix is"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n octave-3.2.3:1&gt; A=1/sqrt(3)\n   A =  0.57735\noctave-3.2.3:2&gt; K=1/sqrt(3)/(sqrt(3)-1)\n   K =  0.78868\noctave-3.2.3:3&gt; W = [A A A; A 1-K -K; A -K 1-K]\n   W =\n\n     0.57735   0.57735   0.57735\n     0.57735   0.21132  -0.78868\n     0.57735  -0.78868   0.21132\n</code>\n</pre>\n", "senID": 10}, {"text": ["which, again, is orthonormal (W*W = I)"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["If you consider the points of the cube [0 0 b],[0 b b],[0 b 0],[b b 0],[b 0 0], and [b 0 b] these form a hexagon and are all a distance of b*sqrt(2/3) from the cube's diagonal.", "These do not satisfy the problem in question, but are useful in a minute.", "The other two points [0 0 0] and [b b b] are on the cube's diagonal."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["The orthonormal weighting matrix W allows us to generate points that are uniformly distributed within {U}, because orthonormal matrices are coordinate transformations that rotate/reflect and do not scale or skew."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["We will generate points that are uniformly distributed in the coordinate system defined by the 3 vectors of W. The first component is the axis of the diagonal of the cube.", "The sum of U's components depends completely upon this axis and not at all on the others.", "Therefore the coordinate along this axis is forced to be 1/sqrt(3) which corresponds to the point [1/3, 1/3, 1/3]."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["The other two components are in directions perpendicular to the cube's diagonal.", "Since the maximum distance from the diagonal is b*sqrt(2/3), we will generate uniformly distributed numbers (u,v) between -b*sqrt(2/3) and +b*sqrt(2/3)."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["This gives us a random variable U' = [1/sqrt(3) u v].", "We then compute U = U' * W. Some of the resulting points will be outside the allowable range (each component of U must be between 0 and b), in which case we reject that and start over."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["In other words:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["The solution is similar for higher dimensions (uniformly distributed points within a portion of the hyperplane perpendicular to a hypercube's main diagonal):"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["Precalculate a weighting matrix W of rank N."], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["The range k(N) is a function of N that represents the maximum distance of the vertices of a hypercube of side 1 from its main diagonal.", "I'm not sure of the general formula but it's sqrt(2/3) for N = 3, sqrt(6/5) for N = 5, there's probably a formula for it somewhere."], "childNum": 0, "tag": "p", "senID": 20, "childList": []}], [{"text": ["The following is quite simple, and returns uniform results:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def gen_list(numbs, limit_sum):\n    limits = sorted([random.uniform(0, limit_sum) for _ in xrange(numbs-1)])\n    limits = [0] + limits + [limit_sum]\n    return [x1-x0 for (x0, x1) in zip(limits[:-1], limits[1:])]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The idea is simply that if you need, say, 5 numbers between 0 and 20, you can simply put 4 \"limits\" between 0 and 20, and you get a partition of the (0, 20) interval.", "The random numbers that you want are simply the lengths of the 5 intervals in the sorted list [0, random1, random2, random3, random4, 20]."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["PS: oops!", "looks like it's the same idea as MAK's response, albeit coded without using indexes!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You could keep a running total rather than having to call sum(my_sum) repeatedly."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sum(my_sum)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]