[[{"text": ["Yet another solution I just thought of:  The simplest way to get the same behaviour as your original code is"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Immutable = collections.namedtuple(\"Immutable\", [\"a\", \"b\"])\n</code>\n</pre>\n", "senID": 1}, {"text": ["It does not solve the problem that attributes can be accessed via [0] etc., but at least it's considerably shorter and provides the additional advantage of being compatible with pickle and copy."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "[0]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "pickle", "childNum": 0, "tag": "code", "childList": []}, {"text": "copy", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["namedtuple creates a type similar to what I described in this answer, i.e.", "derived from tuple and using __slots__.", "It is available in Python 2.6 or above."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "namedtuple", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "this answer", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4828080/how-to-make-an-immutable-object-in-python/4828108#4828108"}, {"text": "tuple", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__slots__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["The easiest way to do this is using __slots__:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class A(object):\n    __slots__ = []\n</code>\n</pre>\n", "senID": 1}, {"text": ["Instances of A are immutable now, since you can't set any attributes on them."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "A", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you want the class instances to contain data, you can combine this with deriving from tuple:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "tuple", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from operator import itemgetter\nclass Point(tuple):\n    __slots__ = []\n    def __new__(cls, x, y):\n        return tuple.__new__(cls, (x, y))\n    x = property(itemgetter(0))\n    y = property(itemgetter(1))\n\np = Point(2, 3)\np.x\n# 2\np.y\n# 3\n</code>\n</pre>\n", "senID": 4}, {"text": ["Edit: If you want to get rid of indexing either, you can override __getitem__():"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "__getitem__()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class Point(tuple):\n    __slots__ = []\n    def __new__(cls, x, y):\n        return tuple.__new__(cls, (x, y))\n    @property\n    def x(self):\n        return tuple.__getitem__(self, 0)\n    @property\n    def y(self):\n        return tuple.__getitem__(self, 1)\n    def __getitem__(self, item):\n        raise TypeError\n</code>\n</pre>\n", "senID": 6}, {"text": ["Note that you can't use operator.itemgetter for the properties in thise case, since this would rely on Point.__getitem__() instead of tuple.__getitem__().", "Fuerthermore this won't prevent the use of tuple.__getitem__(p, 0), but I can hardly imagine how this should constitute a problem."], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "operator.itemgetter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Point.__getitem__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "tuple.__getitem__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "tuple.__getitem__(p, 0)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I don't think the \"right\" way of creating an immutable object is writing a C extension.", "Python usually relies on library implementers and library users being consenting adults, and instead of really enforcing an interface, the interface should be clearly stated in the documentation.", "This is why I don't consider the possibility of circumventing an overridden __setattr__() by calling object.__setattr__() a problem.", "If someone does this, it's on her own risk."], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "consenting adults", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/tutor/2003-October/025932.html"}, {"text": "__setattr__()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "object.__setattr__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Another idea would be to completely disallow __setattr__ and use object.__setattr__ in the constructor:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__setattr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "object.__setattr__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class Point(object):\n    def __init__(self, x, y):\n        object.__setattr__(self, \"x\", x)\n        object.__setattr__(self, \"y\", y)\n    def __setattr__(self, *args):\n        raise TypeError\n    def __delattr__(self, *args):\n        raise TypeError\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course you could use object.__setattr__(p, \"x\", 3) to modify a Point instance p, but your original implementation suffers from the same problem (try tuple.__setattr__(i, \"x\", 42) on an Immutable instance)."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "object.__setattr__(p, \"x\", 3)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Point", "childNum": 0, "tag": "code", "childList": []}, {"text": "p", "childNum": 0, "tag": "code", "childList": []}, {"text": "tuple.__setattr__(i, \"x\", 42)", "childNum": 0, "tag": "code", "childList": []}, {"text": "Immutable", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You can apply the same trick in your original implementation: get rid of __getitem__(), and use tuple.__getitem__() in your property functions."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "__getitem__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tuple.__getitem__()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You could use Cython to create an extension type for Python:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Cython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.cython.org/index.html"}]}, {"code": "<pre>\n<code>\n cdef class Immutable:\n    cdef readonly object a, b\n    cdef object __weakref__ # enable weak referencing support\n\n    def __init__(self, a, b):\n        self.a, self.b = a, b\n</code>\n</pre>\n", "senID": 1}, {"text": ["It works both Python 2.x and 3."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # compile on-the-fly\nimport pyximport; pyximport.install() # $ pip install cython\nfrom immutable import Immutable\n\no = Immutable(1, 2)\nassert o.a == 1, str(o.a)\nassert o.b == 2\n\ntry: o.a = 3\nexcept AttributeError:\n    pass\nelse:\n    assert 0, 'attribute must be readonly'\n\ntry: o[1]\nexcept TypeError:\n    pass\nelse:\n    assert 0, 'indexing must not be supported'\n\ntry: o.c = 1\nexcept AttributeError:\n    pass\nelse:\n    assert 0, 'no new attributes are allowed'\n\no = Immutable('a', [])\nassert o.a == 'a'\nassert o.b == []\n\no.b.append(3) # attribute may contain mutable object\nassert o.b == [3]\n\ntry: o.c\nexcept AttributeError:\n    pass\nelse:\n    assert 0, 'no c attribute'\n\no = Immutable(b=3,a=1)\nassert o.a == 1 and o.b == 3\n\ntry: del o.b\nexcept AttributeError:\n    pass\nelse:\n    assert 0, \"can't delete attribute\"\n\nd = dict(b=3, a=1)\no = Immutable(**d)\nassert o.a == d['a'] and o.b == d['b']\n\no = Immutable(1,b=3)\nassert o.a == 1 and o.b == 3\n\ntry: object.__setattr__(o, 'a', 1)\nexcept AttributeError:\n    pass\nelse:\n    assert 0, 'attributes are readonly'\n\ntry: object.__setattr__(o, 'c', 1)\nexcept AttributeError:\n    pass\nelse:\n    assert 0, 'no new attributes'\n\ntry: Immutable(1,c=3)\nexcept TypeError:\n    pass\nelse:\n    assert 0, 'accept only a,b keywords'\n\nfor kwd in [dict(a=1), dict(b=2)]:\n    try: Immutable(**kwd)\n    except TypeError:\n        pass\n    else:\n        assert 0, 'Immutable requires exactly 2 arguments'\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you don't mind indexing support then collections.namedtuple suggested by @Sven Marnach is preferrable:"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "collections.namedtuple", "tag": "a", "pos": 0, "childList": [{"text": "collections.namedtuple", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields"}, {"text": "collections.namedtuple", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://stackoverflow.com/questions/4828080/how-to-make-an-immutable-object-in-python/4828831#4828831", "text": "@Sven Marnach", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n Immutable = collections.namedtuple(\"Immutable\", \"a b\")\n</code>\n</pre>\n", "senID": 5}], [{"text": ["You could create a @immutable decorator that either overrides the __setattr__ and change the __slots__ to an empty list, then decorate the __init__ method with it."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "@immutable", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__setattr__", "childNum": 0, "tag": "code", "childList": []}, {"text": "and", "childNum": 0, "tag": "em", "childList": []}, {"text": "__slots__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: As the OP noted, changing the __slots__ attribute only prevents the creation of new attributes, not the modification."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "creation of new attributes", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Edit2: Here's an implementation:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit3: Using __slots__ breaks this code, because if stops the creation of the object's __dict__.", "I'm looking for an alternative."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__dict__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Edit4: Well, that's it.", "It's a but hackish, but works as an exercise :-)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class immutable(object):\n    def __init__(self, immutable_params):\n        self.immutable_params = immutable_params\n\n    def __call__(self, new):\n        params = self.immutable_params\n\n        def __set_if_unset__(self, name, value):\n            if name in self.__dict__:\n                raise Exception(\"Attribute %s has already been set\" % name)\n\n            if not name in params:\n                raise Exception(\"Cannot create atribute %s\" % name)\n\n            self.__dict__[name] = value;\n\n        def __new__(cls, *args, **kws):\n            cls.__setattr__ = __set_if_unset__\n\n            return super(cls.__class__, cls).__new__(cls, *args, **kws)\n\n        return __new__\n\nclass Point(object):\n    @immutable(['x', 'y'])\n    def __new__(): pass\n\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\np = Point(1, 2) \np.x = 3 # Exception: Attribute x has already been set\np.z = 4 # Exception: Cannot create atribute z\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I don't think it is entirely possible except by using either a tuple or a namedtuple.", "No matter what you if you override __setattr__() the user can always bypass it by calling object.__setattr__() directly, so any solution that depends on __setattr__ is guaranteed not to work."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__setattr__()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "object.__setattr__()", "childNum": 0, "tag": "code", "childList": []}, {"text": "__setattr__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This is about the nearest you can get without using some sort of tuple:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Immutable:\n    __slots__ = ['a', 'b']\n    def __init__(self, a, b):\n        object.__setattr__(self, 'a', a)\n        object.__setattr__(self, 'b', b)\n    def __setattr__(self, *ignored):\n        raise NotImplementedError\n    __delattr__ = __setattr__\n</code>\n</pre>\n", "senID": 2}, {"text": ["but it breaks if you try hard enough:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; t = Immutable(1, 2)\n&gt;&gt;&gt; t.a\n1\n&gt;&gt;&gt; object.__setattr__(t, 'a', 2)\n&gt;&gt;&gt; t.a\n2\n</code>\n</pre>\n", "senID": 4}, {"text": ["but Sven's use of namedtuple is genuinely immutable."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "namedtuple", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Update"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Since the question has been updated to ask how to do it properly in C, here's my answer on how to do it properly in Cython:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["First immutable.pyx:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "immutable.pyx", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n cdef class Immutable:\n    cdef object _a, _b\n\n    def __init__(self, a, b):\n        self._a = a\n        self._b = b\n\n    property a:\n        def __get__(self):\n            return self._a\n\n    property b:\n        def __get__(self):\n            return self._b\n\n    def __repr__(self):\n        return \"&lt;Immutable {0}, {1}&gt;\".format(self.a, self.b)\n</code>\n</pre>\n", "senID": 9}, {"text": ["and a setup.py to compile it (using the command setup.py build_ext --inplace:"], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "setup.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "setup.py build_ext --inplace", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from distutils.core import setup\nfrom distutils.extension import Extension\nfrom Cython.Distutils import build_ext\n\next_modules = [Extension(\"immutable\", [\"immutable.pyx\"])]\n\nsetup(\n  name = 'Immutable object',\n  cmdclass = {'build_ext': build_ext},\n  ext_modules = ext_modules\n)\n</code>\n</pre>\n", "senID": 11}, {"text": ["Then to try it out:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from immutable import Immutable\n&gt;&gt;&gt; p = Immutable(2, 3)\n&gt;&gt;&gt; p\n&lt;Immutable 2, 3&gt;\n&gt;&gt;&gt; p.a = 1\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: attribute 'a' of 'immutable.Immutable' objects is not writable\n&gt;&gt;&gt; object.__setattr__(p, 'a', 1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: attribute 'a' of 'immutable.Immutable' objects is not writable\n&gt;&gt;&gt; p.a, p.b\n(2, 3)\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 13}], [{"text": ["I've made immutable classes by overriding __setattr__, and allowing the set if the caller is __init__:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__setattr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import inspect\nclass Immutable(object):\n    def __setattr__(self, name, value):\n        if inspect.stack()[2][3] != \"__init__\":\n            raise Exception(\"Can't mutate an Immutable: self.%s = %r\" % (name, value))\n        object.__setattr__(self, name, value)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This isn't quite enough yet, since it allows anyone's ___init__ to change the object, but you get the idea."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "___init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Class and decorator for create immutable objects:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Immutable(object):\n     _mutable = False\n     def __setattr__(self, name,value):\n        if self._mutable or name == '_mutable':\n             super(Immutable,self).__setattr__(name,value)\n        else:\n             raise TypeError(\"Can't modify\")\n\n     def __delattr__(self,name):\n         if self._mutable:\n             super(Immutable,self).__delattr__(name)\n         else:\n             raise TypeError(\"Can't modify\")\n\n\ndef mutablemethod(f):\n    def func(self,*args, **kwargs):\n        if isinstance(self,Immutable):\n            old_mutable = self._mutable\n            self._mutable = True\n            res = f(self,*args, **kwargs)\n            self._mutable = old_mutable\n        else:\n            res = f(self,*args, **kwargs)\n        return res\n    return func\n\n\n\nif __name__ == '__main__':\n\n    class A(Immutable):\n        '''\n           Define __init__ can set attributes for instance\n        '''\n        @mutablemethod\n        def __init__(self,value):\n            super(A,self).__init__(self)\n            self.value = value\n\n        def try_change(self,value):\n            self.value = value\n\n    a = A(\"test\")\n    a.try_change(\"TEST to change\")\n    a.value = \"TEST to change\"\n</code>\n</pre>\n", "senID": 1}]]