[[{"text": ["1) Modifying a mutable object through a reference will always modify the \"original\".", "Honestly, this is betraying a misunderstanding of references.", "The newer reference is just as much the \"original\" as is any other reference.", "So long as both names point to the same object, modifying the object through either name will be reflected when accessed through the other name."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "always", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["2) Not exactly like what you want.", "gc.get_referrers returns all references to the object."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "gc.get_referrers", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "all", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l = [1, 2]\n&gt;&gt;&gt; d = {0: l}\n&gt;&gt;&gt; t = (l, )\n&gt;&gt;&gt; import gc\n&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; pprint.pprint(gc.get_referrers(l))\n[{'__builtins__': &lt;module '__builtin__' (built-in)&gt;,\n  '__doc__': None,\n  '__name__': '__main__',\n  '__package__': None,\n  'd': {0: [1, 2]},\n  'gc': &lt;module 'gc' (built-in)&gt;,\n  'l': [1, 2],\n  'pprint': &lt;module 'pprint' from '/usr/lib/python2.6/pprint.pyc'&gt;,\n  't': ([1, 2],)},   # This is globals()\n\n {0: [1, 2]},  # This is d\n ([1, 2],)]   # this is t\n</code>\n</pre>\n", "senID": 2}, {"text": ["Note that the actual object referenced by l is not included in the returned list because it does not contain a reference to itself.", "globals() is returned because that does contain a reference to the original list."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "l", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "globals()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "does", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["3) If by valid, you mean \"will not be garbage collected\" then this is correct barring a highly unlikely bug.", "It would be a pretty sorry garbage collector that \"stole\" your data."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Every variable in Python is a reference. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Every", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["For lists, you are focusing on the results of the append() method, and loosing sight of the bigger picture of Python data structures.", "There are other methods on lists, and there are advantages and consequences to how a list is constructed.", "It is helpful to think of list as view on to other objects referred to in the list.", "They do not \"containing\" anything other than the rules and ways of accessing the data referred to by objects within them. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "append()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The list.append(x) method specifically is equivalent to l[len(l):]=[list] "], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "list.append(x)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/tutorial/datastructures.html", "text": "method specifically", "childNum": 0, "tag": "a", "childList": []}, {"text": "l[len(l):]=[list]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l1=range(3)\n&gt;&gt;&gt; l2=range(20,23)\n&gt;&gt;&gt; l3=range(30,33)\n&gt;&gt;&gt; l1[len(l1):]=[l2]    # equivalent to 'append' for subscriptable sequences \n&gt;&gt;&gt; l1[len(l1):]=l3      # same as 'extend'\n&gt;&gt;&gt; l1\n[0, 1, 2, [20, 21, 22], 30, 31, 32]\n&gt;&gt;&gt; len(l1)\n7\n&gt;&gt;&gt; l1.index(30)\n4\n&gt;&gt;&gt; l1.index(20)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: list.index(x): x not in list\n&gt;&gt;&gt; 20 in l1\nFalse\n&gt;&gt;&gt; 30 in l1\nTrue\n</code>\n</pre>\n", "senID": 4}, {"text": ["By putting the list constructor around l2 in l1[len(l1):]=[l2], or calling l.append(l2), you create a reference that is bound to l2.", "If you change l2, the references will show the change as well.", "The length of that in the list is a single element -- the reference to the appended sequence. "], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "l1[len(l1):]=[l2]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "l.append(l2)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["With no constructor shortcut as in l1[len(l1):]=l3, you copy each element of the sequence. "], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "l1[len(l1):]=l3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you use other common list methods, such as l.index(something), or in you will not find elements inside of the data references.", "l.sort() will not sort properly.", "They are \"shallow\" operations on the object, and by using l1[len(l1):]=[l2] you are now creating a recursive data structure. "], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "l.index(something)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "in", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "l.sort()", "childNum": 0, "tag": "code", "childList": []}, {"text": "l1[len(l1):]=[l2]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you use l1[len(l1):]=l3, you are making a true (shallow) copy of the elements in l3.  "], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "l1[len(l1):]=l3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "l3", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["These are fairly fundamental Python idioms, and most of the time they 'do the right thing.", "' You can, however, get surprising results, such as:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; m=[[None]*2]*3\n&gt;&gt;&gt; m\n[[None, None], [None, None], [None, None]]\n&gt;&gt;&gt; m[0][1]=33\n&gt;&gt;&gt; m\n[[None, 33], [None, 33], [None, 33]]   # probably not what was intended...\n&gt;&gt;&gt; m[0] is m[1] is m[2]               # same object, that's why they all changed\nTrue\n</code>\n</pre>\n", "senID": 10}, {"text": ["Some Python newbies try to create a multi dimension by doing something like m=[[None]*2]*3 The first sequence replication works as expected; it creates 2 copies of None.", "It is the second that is the issue: it creates three copies of the reference to the first list.", "So entering m[0][1]=33 modifies the list inside the list bound to m and then all the bound references change to show that change."], "childNum": 4, "tag": "p", "senID": 11, "childList": [{"text": "m=[[None]*2]*3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sequence replication", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/operator.html#mapping-operators-to-functions"}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "m[0][1]=33", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Compare to:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; m=[[None]*2,[None]*2,[None]*2]\n&gt;&gt;&gt; m\n[[None, None], [None, None], [None, None]]\n&gt;&gt;&gt; m[0][1]=33\n&gt;&gt;&gt; m\n[[None, 33], [None, None], [None, None]]\n</code>\n</pre>\n", "senID": 13}, {"text": ["You can also use nested list comprehensions  to do the same like so:"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "nested list comprehensions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#nested-list-comprehensions"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; m=[[ None for i  in range(2)] for j in range(3)]\n&gt;&gt;&gt; m\n[[None, None], [None, None], [None, None]]\n&gt;&gt;&gt; m[0][1]=44\n&gt;&gt;&gt; m\n[[None, 44], [None, None], [None, None]]\n&gt;&gt;&gt; m[0] is m[1] is m[2]                      # three different lists....\nFalse\n</code>\n</pre>\n", "senID": 15}, {"text": ["For lists and references, Fredrik Lundh has this text for a good intro."], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "this text", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/python-list.htm"}]}, {"text": ["As to your specific questions:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["1) In Python, Everything is a label or a reference to an object.", "There is no 'original' (a C++ concept) and there is no distinction between 'reference', pointer, or actual data (a C / Perl concept)"], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "Everything", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["2) Fredrik Lundh has a great analogy about in reference to a question similar to this:"], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "to a question similar to this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/pyfaq/how-can-my-code-discover-the-name-of-an-object.htm"}]}, {"text": ["You can find this list with some effort, but why?", "Just call it what you are going to call it -- like a found cat."], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"text": ["3) True.  "], "childNum": 0, "tag": "p", "senID": 21, "childList": []}], [{"text": ["Yes.", "Actually non-mutable objects are always a reference as well.", "You just can't change them to perceive this. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That is odd, but it can be done."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can compare objects for \"samenes\" with the is operator.", "Like in l1 is t[0]"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "is", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "l1 is t[0]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["And you can get all referred-to objects with the function \ngc.get_referrers in the garbage collector module (gc) --\nYou can check which of these referrers point o your object with the isoperator.", "So,yes, it can be done.", "I just don't think it would be a good idea.", "It is more likely the is operator offer\na way for you to do waht you need alone"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "gc.get_referrers", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "is", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "is", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Yes. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Python has reference semantics: variables do not store values as in C++, but instead label them.", "The concept of \"the original\" is flawed: if two variables label the same value, it is totally irrelevant which one \"came first\".", "It doesn't matter if the object is mutable or not (except that immutable objects won't make it so easy to tell what's going on behind the scenes).", "To make copies in a more general-purpose way, try the copy module."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "store", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "label", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "copy", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Not easily.", "Refer to aaronasterling's answer for details.", "You could also try something like k for k, v in locals().items() if v is the_object, but you'll also have to search globals(), you'll miss some stuff and it might cause some kind of problems due to recursing with the names 'k' and 'v' (I haven't tested)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "k for k, v in locals().items() if v is the_object", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "globals()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Absolutely."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [], [{"code": "<pre>\n<code>\n 1a. Is a mutable object always a reference?\n</code>\n</pre>\n", "senID": 0}, {"text": ["There is no difference between mutable and non-mutable objects.", "Seeing the variable names as references is helpful for people with a C-background (but implies they can be dereferenced, which they can not)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n 1b. Can you always assume that modifying it modifies the original\n</code>\n</pre>\n", "senID": 2}, {"text": ["Please, it's not \"the original\".", "It's the same object.", "b = a means b and a now are the same object."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n 1c. (Unless you specifically make a copy with l2=l1[:] kind of idiom)?\n</code>\n</pre>\n", "senID": 4}, {"text": ["Right, because then it is not the same object anymore.", "(Although the entries n the list will be the same objects as the original list)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n 2. Can I assemble a list of all the same references in Python?\n</code>\n</pre>\n", "senID": 6}, {"text": ["Yes, probably, but you will never ever ever need it, so that would be a waste of energy.", ":)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n 3. It is my assumption that no matter what, the data will remain valid so long as there is some reference to it.\n</code>\n</pre>\n", "senID": 8}, {"text": ["Yes, an object will not be garbage collected as long as you have a reference to it.", "(Using the word \"valid\" here seems incorrect, but I assume this is what you mean)."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}]]