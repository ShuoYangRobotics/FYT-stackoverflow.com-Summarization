[[{"text": ["The simplest way in most cases is probably:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class ObjectWrapper(BaseClass):\n    def __init__(self, baseObject):\n        self.__class__ = type(baseObject.__class__.__name__,\n                              (self.__class__, baseObject.__class__),\n                              {})\n        self.__dict__ = baseObject.__dict__\n\n    def overriddenMethod(self):\n        ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["Working in this way, i.e.", "by reassigning self's __class__ and __dict__ in this fashion, you need only provide your overrides -- Python's normal attribute getting and setting mechanisms will do the rest... mostly."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "__class__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__dict__", "childNum": 0, "tag": "code", "childList": []}, {"text": "mostly", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["You'll be in trouble only if baseObject.__class__ defines __slots__, in which case the multiple inheritance approach doesn't work and you do need the cumbersome __getattr__ (as others said, at least you don't need to worry that it will be called with attributes you're overriding, as it won't!-), __setattr__ (a greater pain, as it DOES get called for every attribute), etc; and making isinstance and special methods work takes painstaking and cumbersome detailed work."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "baseObject.__class__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__slots__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__getattr__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__setattr__", "childNum": 0, "tag": "code", "childList": []}, {"text": "isinstance", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Essentially, __slots__ means that a class is a special, each instance a lightweight \"value object\" NOT to be subject to further sophisticated manipulation, wrapping, etc, because the need to save a few bytes per instance of that class overrides all the normal concerns about flexibility and so on; it's therefore not surprising that dealing with such extreme, rare classes in the same smooth and flexible way as you can deal with 99%+ of Python objects is truly a pain.", "So DO you need to deal with __slots__ (to the point of writing, testing, debugging and maintaining hundreds of lines of code just for those corner cases), or will the 99% solution in half a dozen lines suffice?-)"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__slots__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["__getattr__ has the advantage that it's only called when the attribute does not exist, so you should not need an explicit list -- anything you don't define will automatically get proxied."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["__setattr__ is trickier because it's always called.", "Make sure you use a superclass call or object.__setattr__ when setting your own attributes; using setattr() within __setattr__ will cause infinite recursion."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The final bit, affecting isinstance, is very difficult.", "You can do it with an assigment to your wrapper instance's .__class__ variable (but this also overrides class dictionary resolution order), or by dynamically constructing your wrapper type using a metaclass.", "Since isinstance is so rare in Python code, it seems overkill to actually try to trick it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["More information on special attribute access methods."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "More information on special attribute access methods.", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://python.org/doc/2.2/ref/attribute-access.html"}]}, {"text": ["Even more information on them, plus some help with metaclasses."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Even more information on them, plus some help with metaclasses.", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html#customizing-class-creation"}]}], [{"text": ["Start with this and mess with stuff in the loop to suit your needs:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import inspect\nclass Delegate(object):\n    def __init__(self, implementation):\n        self.__class__ = implementation.__class__\n        for n, m in inspect.getmembers(implementation, callable):\n            if not n.startswith('_'):\n                setattr(self, n, m)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The ability to wrap not-new-style-objects is left as an exercise to the reader :)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["See my answer to this question."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1382871/dynamically-attaching-a-method-to-an-existing-python-object-generated-with-swig/1383646#1383646"}]}], [{"text": ["__getattr__ is only called for things that Python can't find in __dict__, so you don't have to worry about overriddenMethod, etc."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__getattr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__dict__", "childNum": 0, "tag": "code", "childList": []}, {"text": "overriddenMethod", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For more details, see section 5 \"Proxy\" in this article."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "this article", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/workshops/1997-10/proceedings/savikko.html"}]}], [{"text": ["By 'existing object' you mean an instance of another class?", "Sounds to me as though you just need to inherit from the base class.", "When you create your new object, pass in the details of the base object, or add a method in your new class which copies the data of the base class instance into itself."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]