[[{"text": ["You haven't said exactly when you want output.", "I'm assuming that you want one smoothed reading for each raw reading, and the smoothed reading is to be the arithmetic mean of the raw reading and any others in the previous 100 (delta) seconds."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Short answer: use a collections.deque ... it will never hold more than \"delta\" seconds of readings.", "The way I've set it up you can treat the deque just like a list, and easily calculate the mean or some fancy gizmoid that gives more weight to recent readings."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Long answer:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; the_data = [tuple(map(float, x.split())) for x in \"\"\"\\\n... 6       0.738158581\n... 21      0.801697222\n[snip]\n... 251     8.76853608\n... 278     9.092367123\"\"\".splitlines()]\n&gt;&gt;&gt; import collections\n&gt;&gt;&gt; delta = 100.0\n&gt;&gt;&gt; q = collections.deque()\n&gt;&gt;&gt; for t, v in the_data:\n...     while q and q[0][0] &lt;= t - delta:\n...         # jettison outdated readings\n...         _unused = q.popleft()\n...     q.append((t, v))\n...     count = len(q)\n...     print t, sum(item[1] for item in q) / count, count\n...\n...\n6.0 0.738158581 1\n21.0 0.7699279015 2\n39.0 1.112360133 3\n49.0 1.52907127225 4\n54.0 1.791208525 5\n79.0 2.13137915133 6\n91.0 2.49500989771 7\n97.0 2.8309395405 8\n100.0 3.12993279856 9\n118.0 3.74976297144 9\n131.0 4.41385300278 9\n147.0 4.99420529389 9\n157.0 5.8325615685 8\n176.0 6.033109419 9\n202.0 7.15545189083 6\n223.0 7.4342562845 6\n251.0 7.9150342134 5\n278.0 8.4246097095 4\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["One-stop shop: get your fancy gizmoid here.", "Here's the code:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n numerator = sum(item[1] * upsilon ** (t - item[0]) for item in q)\ndenominator = sum(upsilon ** (t - item[0]) for item in q)\ngizmoid = numerator / denominator\n</code>\n</pre>\n", "senID": 6}, {"text": ["where upsilon should be a little less than 1.0 (&lt;= zero is illegal, just above zero does little smoothing, one gets you the arithmetic mean plus wasted CPU time, and greater than one gives the inverse of your purpose)."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I'm using a sum result to which I'm adding the new members and subtracting the old ones.", "However in this way one may suffer accumulating floating point inaccuracies."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Therefore I implement a \"Deque\" with a list.", "And whenever my Deque reallocates to a smaller size.", "I recalculate the sum at the same occasion."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I'm also calculating the average up to point x including point x so there's at least one sample point to average."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def getAvgValues(data, avgSampleTime):\n  lastTime = 0\n  prevValsBuf = []\n  prevValsStart = 0\n  tot = 0\n  for t, v in data:\n    avgStart = t - avgSampleTime\n    # remove too old values\n    while prevValsStart &lt; len(prevValsBuf):\n      pt, pv = prevValsBuf[prevValsStart]\n      if pt &gt; avgStart:\n        break\n      tot -= pv\n      prevValsStart += 1\n    # add new item\n    tot += v\n    prevValsBuf.append((t, v))\n    # yield result\n    numItems = len(prevValsBuf) - prevValsStart\n    yield (t, tot / numItems)\n    # clean prevVals if it's time\n    if prevValsStart * 2 &gt; len(prevValsBuf):\n      prevValsBuf = prevValsBuf[prevValsStart:]\n      prevValsStart = 0\n      # recalculate tot for not accumulating float precision error\n      tot = sum(v for (t, v) in prevValsBuf)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Your data seems to be roughly linear:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"src": "http://rix0r.nl/~rix0r/share/shot-20090621.144851.gif", "tag": "img", "senID": 1}, {"text": ["What kind of smoothing are you looking for?", "A least squares fit of a line to this data set?", "Some sort of low-pass filter?", "Or something else?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Please tell us the application so we can advise you a bit better."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT: For example, depending on the application, interpolating a line between the first and last point may be good enough for your purposes."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["This one makes it linear:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def process_data(datafile):\n    previous_n = 0\n    previous_t = 0\n    for line in datafile:\n        t, number = line.strip().split()\n        t = int(t)\n        number = float(number)\n        delta_n = number - previous_n\n        delta_t = t - previous_t\n        n_per_t = delta_n / delta_t\n        for t0 in xrange(delta_t):\n            yield previous_t + t0, previous_n + (n_per_t * t0)\n        previous_n = n\n        previous_t = t\n\nf = open('datafile.dat')\n\nfor sample in process_data(f):\n    print sample\n</code>\n</pre>\n", "senID": 1}], [{"text": ["O(1) memory in case you can iterate the input more than once - you can use one iterator for the \"left\" and one for the \"right\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def getAvgValues(makeIter, avgSampleTime):\n  leftIter = makeIter()\n  leftT, leftV = leftIter.next()\n  tot = 0\n  count = 0\n  for rightT, rightV in makeIter():\n    tot += rightV\n    count += 1\n    while leftT &lt;= rightT - avgSampleTime:\n      tot -= leftV\n      count -= 1\n      leftT, leftV = leftIter.next()\n    yield rightT, tot / count\n</code>\n</pre>\n", "senID": 1}], [{"text": ["While it gives an exponentially decaying average, rather than a total average, I think you may want what I called an exponential moving average with varying alpha, which is really a single-pole low-pass filter.", "There's now a solution to that question, and it runs in time linear to the number of data points.", "See if it works for you."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "exponential moving average with varying alpha", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1023860/exponential-moving-average-sampled-at-varying-times"}]}], [{"text": ["what about something like this, keep storing values till time difference with last time is > 100, average and yield such values\ne.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def getAvgValues(data):\n    lastTime = 0\n    prevValues = []\n    avgSampleTime=100\n\n    for t, v in data:\n        if t - lastTime &lt; avgSampleTime:\n            prevValues.append(v)\n        else:\n            avgV = sum(prevValues)/len(prevValues)\n            lastTime = t\n            prevValues = [v]\n            yield (t,avgV)\n\nfor v in getAvgValues(data):\n    print v\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Sounds like you need a simple rounding formula.", "To round any number to an arbitrary interval:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["round(num/interval)*interval"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can substitute round with floor or ceiling for \"leading up to\" or \"since\" affects.", "It can work in any language, including SQL. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]