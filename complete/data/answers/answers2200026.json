[[{"text": ["It makes no sense to use with here.", "Instead use a list comprehension:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "with", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n funcs = [getFunc(url, links) for url in urls]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A bit unconventional, but you can have a decorator register the func and bind any loop variables as default arguments:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n urls = [many urls]\nlinks = []\nfuncs = []\n\nfor url in urls:\n    @funcs.append\n    def func(url=url):\n        page = open(url)\n        link = searchForLink(page)\n        links.append(link)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Lose the line &lt;STATEMENT&gt;(funcs):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "&lt;STATEMENT&gt;(funcs):", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I mean:  why would you do this?", "Why define a new function for each page?", "Why not just do this?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n urls = [many urls]\nlinks = []\nfor url in urls:\n    page = open(url)\n    link = searchForLink(page)\n    links.append(link)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["There are only two ways to create functions: def and lambda.", "Lambdas are meant for tiny functions, so they may not be very appropriate for your case.", "However, if you really want to, you can enclose two lambdas within each other:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "def", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n urls = [many urls]\nlinks = []\nfuncs = [(lambda x:\n            lambda:\n              links.append(searchForLink(open(x))))(u)\n         for u in urls]\n</code>\n</pre>\n", "senID": 1}, {"text": ["A little too LISPish for my taste."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You should not use \"with\" to do this (even though, given that it's Python, you almost certainly could, using some bizarre side-effect and Python's dynamicism).  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The purpose of \"with\" in Python is, as described in the docs, \"to wrap the execution of a block with methods defined by a context manager.", "This allows common try...except...finally usage patterns to be encapsulated for convenient reuse."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "as described in the docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/compound_stmts.html#the-with-statement"}]}, {"text": ["I think you're confusing Python's \"with\" with the Javascript/VisualBasic \"with\", which may be cosmetically similar but which is effectively unrelated."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Javascript", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://developer.mozilla.org/index.php?title=En/Core_JavaScript_1.5_Reference/Statements/With"}, {"href": "http://msdn.microsoft.com/en-us/library/wc500chb%28VS.80%29.aspx", "text": "VisualBasic", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Good old itertools."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html"}]}, {"code": "<pre>\n<code>\n from itertools import imap\nlinks.extend(imap(searchForLink, imap(open, urls)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Although, maybe you'd prefer functional."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "functional", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://oakwinter.com/code/functional/"}]}, {"code": "<pre>\n<code>\n from functional import *\nfuncs = [partial(compose(compose(links.append, searchForLink), open), url) for url in urls]\nfor func in funcs: func()\n</code>\n</pre>\n", "senID": 3}, {"text": ["I don't think it's worthwhile creating a class for with use: it's more work to create __enter__ and __exit__ than it is to just write a helper function."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "with", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__enter__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__exit__", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You may be better using generators to achieve the delayed computation you're after."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def MakeLinks(urls):\n    for url in urls:\n        page = open(url)\n        link = searchForLink(page)\n        yield link\n\nlinks = MakeLinks(urls)\n</code>\n</pre>\n", "senID": 1}, {"text": ["When you want the links:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for link in links:\n    print link\n</code>\n</pre>\n", "senID": 3}, {"text": ["The urls will be looked up during this loop, and not all at once (which it looks like you're tring to avoid)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]