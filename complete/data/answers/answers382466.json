[[{"text": ["Index on the fields you want to use for lookup.", "O(n+m)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n matches = []\nbiglist1_indexed = {}\n\nfor item in biglist1:\n\tbiglist1_indexed[(item[\"transaction\"], item[\"date\"])] = item\n\nfor item in biglist2:\n\tif (item[\"transaction\"], item[\"date\"]) in biglist1_indexed:\n\t\tmatches.append(item)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is probably thousands of times faster than what you're doing now."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["What you want to do is to use correct data structures: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In O(m*n)..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for item in biglist2:\n    for transaction in biglist1:\n       if (item['transaction'] == transaction['transaction'] &amp;&amp;\n           item['date'] == transaction['date'] &amp;&amp;\n           item['foo'] == transaction['foo'] ) :\n\n          list_transactionnamematches.append(transaction)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Forgive my rusty python syntax, it's been a while, so consider this partially pseudocode"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\nbiglist1.sort(key=(operator.itemgetter(2),operator.itemgetter(0)))\nbiglist2.sort(key=(operator.itemgetter(2),operator.itemgetter(0)))\ni1=0;\ni2=0;\nwhile i1 &lt; len(biglist1) and i2 &lt; len(biglist2):\n    if (biglist1[i1]['date'],biglist1[i1]['transaction']) == (biglist2[i2]['date'],biglist2[i2]['transaction']):\n        biglist3.append(biglist1[i1])\n        i1++\n        i2++\n    elif (biglist1[i1]['date'],biglist1[i1]['transaction']) &lt; (biglist2[i2]['date'],biglist2[i2]['transaction']):\n        i1++\n    elif (biglist1[i1]['date'],biglist1[i1]['transaction']) &gt; (biglist2[i2]['date'],biglist2[i2]['transaction']):\n        i2++\n    else:\n        print \"this wont happen if i did the tuple comparison correctly\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["This sorts both lists into the same order, by (date,transaction).", "Then it walks through them side by side, stepping through each looking for relatively adjacent matches.", "It assumes that (date,transaction) is unique, and that I am not completely off my rocker with regards to tuple sorting and comparison."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The approach I would probably take to this is to make a very, very lightweight class with one instance variable and one method.", "The instance variable is a pointer to a dictionary; the method overrides the built-in special method __hash__(self), returning a value calculated from all the values in the dictionary except id."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__hash__(self)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "id", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["From there the solution seems fairly obvious:  Create two initially empty dictionaries:  N and M (for no-matches and matches.", ")  Loop over each list exactly once, and for each of these dictionaries representing a transaction (let's call it a Tx_dict), create an instance of the new class (a Tx_ptr).", "Then test for an item matching this Tx_ptr in N and M: if there is no matching item in N, insert the current Tx_ptr into N; if there is a matching item in N but no matching item in M, insert the current Tx_ptr into M with the Tx_ptr itself as a key and a list containing the Tx_ptr as the value; if there is a matching item in N and in M, append the current Tx_ptr to the value associated with that key in M."], "childNum": 22, "tag": "p", "senID": 1, "childList": [{"text": "N", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "M", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "no-matches", "childNum": 0, "tag": "em", "childList": []}, {"text": "matches", "childNum": 0, "tag": "em", "childList": []}, {"text": "Tx_dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "Tx_ptr", "childNum": 0, "tag": "code", "childList": []}, {"text": "Tx_ptr", "childNum": 0, "tag": "code", "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "childList": []}, {"text": "M", "childNum": 0, "tag": "code", "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "childList": []}, {"text": "Tx_ptr", "childNum": 0, "tag": "code", "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "childList": []}, {"text": "M", "childNum": 0, "tag": "code", "childList": []}, {"text": "Tx_ptr", "childNum": 0, "tag": "code", "childList": []}, {"text": "M", "childNum": 0, "tag": "code", "childList": []}, {"text": "Tx_ptr", "childNum": 0, "tag": "code", "childList": []}, {"text": "Tx_ptr", "childNum": 0, "tag": "code", "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "childList": []}, {"text": "M", "childNum": 0, "tag": "code", "childList": []}, {"text": "Tx_ptr", "childNum": 0, "tag": "code", "childList": []}, {"text": "M", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["After you've gone through every item once, your dictionary M will contain pointers to all the transactions which match other transactions, all neatly grouped together into lists for you."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "M", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit:  Oops!", "Obviously, the correct action if there is a matching Tx_ptr in N but not in M is to insert a key-value pair into M with the current Tx_ptr as the key and as the value, a list of the current Tx_ptr and the Tx_ptr that was already in N."], "childNum": 10, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "Tx_ptr", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "childList": []}, {"text": "M", "childNum": 0, "tag": "code", "childList": []}, {"text": "M", "childNum": 0, "tag": "code", "childList": []}, {"text": "Tx_ptr", "childNum": 0, "tag": "code", "childList": []}, {"text": "Tx_ptr", "childNum": 0, "tag": "code", "childList": []}, {"text": "and", "childNum": 0, "tag": "em", "childList": []}, {"text": "Tx_ptr", "childNum": 0, "tag": "code", "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Have a look at Psyco.", "Its a Python compiler that can create very fast, optimized machine code from your source."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://sourceforge.net/projects/psyco/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://sourceforge.net/projects/psyco/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://sourceforge.net/projects/psyco/"}]}, {"text": ["While this isn't a direct solution to your code's efficiency issues, it could still help speed things up without needing to write any new code.", "That said, I'd still highly recommend optimizing your code as much as possible AND use Psyco to squeeze as much speed out of it as possible."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Part of their guide specifically talks about using it to speed up list, string, and numeric computation heavy functions."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["http://psyco.sourceforge.net/psycoguide/node8.html"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://psyco.sourceforge.net/psycoguide/node8.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://psyco.sourceforge.net/psycoguide/node8.html"}]}], [{"text": ["I'm also a newbie.", "My code is structured in much the same way as his. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for A in biglist:\n    for B in biglist:\n        if ( A.get('somekey') &lt;&gt; B.get('somekey') and #don't match to itself\n             len( set(A.get('list')) - set(B.get('list')) ) &gt; 10:\n            [do stuff...]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This takes hours to run through a list of 10000 dictionaries.", "Each dictionary contains lots of stuff but I could potentially pull out just the ids ('somekey') and lists ('list') and rewrite as a single dictionary of 10000 key:value pairs. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Question: how much faster would that be?", "And I assume this is faster than using a list of lists, right?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]