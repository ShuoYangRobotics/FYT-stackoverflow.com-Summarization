[[{"text": ["If you're using DJANGO lib, you can simply :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from django.utils import text, html\n\n    class class_name():\n\n\n        def trim_string(self, stringf, limit, offset = 0):\n            return stringf[offset:limit]\n\n        def trim_html_words(self, html, limit, offset = 0):\n            return text.truncate_html_words(html, limit)\n\n\n        def remove_html(self, htmls, tag, limit = 'all', offset = 0):\n            return html.strip_tags(htmls)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Anyways, here's the code from truncate_html_words from django :"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef truncate_html_words(s, num):\n    \"\"\"\n    Truncates html to a certain number of words (not counting tags and comments).\n    Closes opened tags if they were correctly closed in the given html.\n    \"\"\"\n    length = int(num)\n    if length &lt;= 0:\n        return ''\n    html4_singlets = ('br', 'col', 'link', 'base', 'img', 'param', 'area', 'hr', 'input')\n    # Set up regular expressions\n    re_words = re.compile(r'&amp;.*?;|&lt;.*?&gt;|([A-Za-z0-9][\\w-]*)')\n    re_tag = re.compile(r'&lt;(/)?([^ ]+?)(?: (/)| .*?)?&gt;')\n    # Count non-HTML words and keep note of open tags\n    pos = 0\n    ellipsis_pos = 0\n    words = 0\n    open_tags = []\n    while words &lt;= length:\n        m = re_words.search(s, pos)\n        if not m:\n            # Checked through whole string\n            break\n        pos = m.end(0)\n        if m.group(1):\n            # It's an actual non-HTML word\n            words += 1\n            if words == length:\n                ellipsis_pos = pos\n            continue\n        # Check for tag\n        tag = re_tag.match(m.group(0))\n        if not tag or ellipsis_pos:\n            # Don't worry about non tags or tags after our truncate point\n            continue\n        closing_tag, tagname, self_closing = tag.groups()\n        tagname = tagname.lower()  # Element names are always case-insensitive\n        if self_closing or tagname in html4_singlets:\n            pass\n        elif closing_tag:\n            # Check for match in open tags list\n            try:\n                i = open_tags.index(tagname)\n            except ValueError:\n                pass\n            else:\n                # SGML: An end tag closes, back to the matching start tag, all unclosed intervening start tags with omitted end tags\n                open_tags = open_tags[i+1:]\n        else:\n            # Add it to the start of the open tags list\n            open_tags.insert(0, tagname)\n    if words &lt;= length:\n        # Don't try to close tags if we don't need to truncate\n        return s\n    out = s[:ellipsis_pos] + ' ...'\n    # Close any tags still open\n    for tag in open_tags:\n        out += '&lt;/%s&gt;' % tag\n    # Return string\n    return out\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This will serve your requirement.An easy to use HTML parser and bad markup corrector"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.crummy.com/software/BeautifulSoup/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.crummy.com/software/BeautifulSoup/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/"}]}], [{"text": ["I don't think you need a full-fledged parser - you only need to tokenize the the input string into one of:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "text", "tag": "none", "senID": 1}, {"text": "open tag", "tag": "none", "senID": 2}, {"text": "close tag", "tag": "none", "senID": 3}, {"text": "self-closing tag ", "tag": "none", "senID": 4}, {"text": "character entity", "tag": "none", "senID": 5}]}, {"text": ["Once you have a stream of tokens like that, it's easy to use a stack to keep track of what tags need closing.", "I actually ran into this problem a while ago and wrote a small library to do this:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["https://github.com/eentzel/htmltruncate.py"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "https://github.com/eentzel/htmltruncate.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://github.com/eentzel/htmltruncate.py"}]}, {"text": ["It's worked well for me, and handles most of the corner cases well, including arbitrarily nested markup, counting character entities as a single character, returning an error on malformed markup, etc."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["It will produce:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n &lt;h1&gt;This is a hea&lt;/h1&gt;\n</code>\n</pre>\n", "senID": 10}, {"text": ["on your example.", "This could perhaps be changed, but it's hard in the general case - what if you're trying to truncate to 10 characters, but the &lt;h1&gt; tag isn't closed for another, say, 300 characters?"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "&lt;h1&gt;", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I found the answer by slacy very helpful and would upvote it if I had the reputation,  - however there was one extra thing to note.", "In my environment I had html5lib installed as well as BeautifulSoup4.", "BeautifulSoup used the html5lib parser and this resulted in my html snippet being wrapped in html and body tags which is not what I wanted."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; truncate_html(\"&lt;p&gt;sdfsdaf&lt;/p&gt;\", 4)\nu'&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;s&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'\n</code>\n</pre>\n", "senID": 1}, {"text": ["To resolve these issues I told BeautifulSoup to use the python parser:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from bs4 import BeautifulSoup\ndef truncate_html(html, length): \n    return unicode(BeautifulSoup(html[:length], \"html.parser\"))\n\n&gt;&gt;&gt; truncate_html(\"&lt;p&gt;sdfsdaf&lt;/p&gt;\", 4)\nu'&lt;p&gt;s&lt;/p&gt;'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["My initial thought would be use an XML parser (maybe python's sax parser), then probably count the text characters in each xml element.", "I would ignore the tags characters count to make it more consistent as well as simpler, but either should be possible."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "python's sax parser", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/xml.sax.html"}]}], [{"text": ["I'd recommend first completely parsing the HTML then truncate.", "A great HTML parser for python is lxml.", "After parsing and truncating, you can print it back in to HTML format."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "lxml", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://codespeak.net/lxml/"}]}], [{"text": ["Look at HTML Tidy to cleanup/reformat/reindent HTML."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "HTML Tidy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://tidy.sourceforge.net/"}]}], [{"text": ["You can do this in one line with BeautifulSoup (assuming you want to truncate at a certain number of source characters, not at a number of content characters): "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from BeautifulSoup import BeautifulSoup\n\ndef truncate_html(html, length): \n    return unicode(BeautifulSoup(html[:length]))\n</code>\n</pre>\n", "senID": 1}]]