[[{"text": ["Some measurements.", "I took 10MB of free e-book text and computed trigram frequencies, producing a 24MB file.", "Storing it in different simple Python data structures took this much space in kB, measured as RSS from running ps, where d is a dict, keys and freqs are lists, and a,b,c,freq are the fields of a trigram record:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n 295760     S. Lott's answer\n237984     S. Lott's with keys interned before passing in\n203172 [*] d[(a,b,c)] = int(freq)\n203156     d[a][b][c] = int(freq)\n189132     keys.append((a,b,c)); freqs.append(int(freq))\n146132     d[intern(a),intern(b)][intern(c)] = int(freq)\n145408     d[intern(a)][intern(b)][intern(c)] = int(freq)\n 83888 [*] d[a+' '+b+' '+c] = int(freq)\n 82776 [*] d[(intern(a),intern(b),intern(c))] = int(freq)\n 68756     keys.append((intern(a),intern(b),intern(c))); freqs.append(int(freq))\n 60320     keys.append(a+' '+b+' '+c); freqs.append(int(freq))\n 50556     pair array\n 48320     squeezed pair array\n 33024     squeezed single array\n</code>\n</pre>\n", "senID": 1}, {"text": ["The entries marked [*] have no efficient way to look up a pair (a,b); they're listed only because others have suggested them (or variants of them).", "(I was sort of irked into making this because the top-voted answers were not helpful, as the table shows."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["'Pair array' is the scheme below in my original answer (\"I'd start with the array with keys\nbeing the first two words...\"), where the value table for each pair is\nrepresented as a single string.", "'Squeezed pair array' is the same,\nleaving out the frequency values that are equal to 1 (the most common\ncase).", "'Squeezed single array' is like squeezed pair array, but gloms key and value together as one string (with a separator character).", "The squeezed single array code:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import collections\n\ndef build(file):\n    pairs = collections.defaultdict(list)\n    for line in file:  # N.B. file assumed to be already sorted\n        a, b, c, freq = line.split()\n        key = ' '.join((a, b))\n        pairs[key].append(c + ':' + freq if freq != '1' else c)\n    out = open('squeezedsinglearrayfile', 'w')\n    for key in sorted(pairs.keys()):\n        out.write('%s|%s\\n' % (key, ' '.join(pairs[key])))\n\ndef load():\n    return open('squeezedsinglearrayfile').readlines()\n\nif __name__ == '__main__':\n    build(open('freqs'))\n</code>\n</pre>\n", "senID": 4}, {"text": ["I haven't written the code to look up values from this structure (use bisect, as mentioned below), or implemented the fancier compressed structures also described below."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Original answer: A simple sorted array of strings, each string being a space-separated concatenation of words, searched using the bisect module, should be worth trying for a start.", "This saves space on pointers, etc.", "It still wastes space due to the repetition of words; there's a standard trick to strip out common prefixes, with another level of index to get them back, but that's rather more complex and slower.", "(The idea is to store successive chunks of the array in a compressed form that must be scanned sequentially, along with a random-access index to each chunk.", "Chunks are big enough to compress, but small enough for reasonable access time.", "The particular compression scheme applicable here: if successive entries are 'hello george' and 'hello world', make the second entry be '6world' instead.", "(6 being the length of the prefix in common.", ") Or maybe you could get away with using zlib?", "Anyway, you can find out more in this vein by looking up dictionary structures used in full-text search.", ") So specifically, I'd start with the array with keys being the first two words, with a parallel array whose entries list the possible third words and their frequencies.", "It might still suck, though -- I think you may be out of luck as far as batteries-included memory-efficient options."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "Original answer:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "zlib", "tag": "a", "pos": 7, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-zlib.html"}]}, {"text": ["Also, binary tree structures are not recommended for memory efficiency here.", "E.g., this paper tests a variety of data structures on a similar problem (unigrams instead of trigrams though) and finds a hashtable to beat all of the tree structures by that measure."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "this paper", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.cdf.toronto.edu/~csc148h/fall/assignment3/bursttries.pdf"}]}, {"text": ["I should have mentioned, as someone else did, that the sorted array could be used just for the wordlist, not bigrams or trigrams; then for your 'real' data structure, whatever it is, you use integer keys instead of strings -- indices into the wordlist.", "(But this keeps you from exploiting common prefixes except in the wordlist itself.", "Maybe I shouldn't suggest this after all."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Use tuples.", "Tuples can be keys to dictionaries, so you don't need to nest dictionaries."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n d = {}\nd[ word1, word2, word3 ] = 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also as a plus, you could use defaultdict   "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "so that elements that don't have entries always return 0", "tag": "none", "senID": 3}, {"text": "and so that u can say ", "tag": "none", "senID": 4}]}, {"text": ["example:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\nd = defaultdict(int)\nd[\"first\",\"word\",\"tuple\"] += 1\n</code>\n</pre>\n", "senID": 6}, {"text": ["If you need to find all words \"word3\" that are tupled with (word1,word2) then search for it in dictionary.keys() using list comprehension"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["if you have a tuple, t, you can get the first two items using slices:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = (1,2,3)\n&gt;&gt;&gt; a[:2]\n(1, 2)\n</code>\n</pre>\n", "senID": 9}, {"text": ["a small example for searching tuples with list comprehensions:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; b = [(1,2,3),(1,2,5),(3,4,6)]\n&gt;&gt;&gt; search = (1,2)\n&gt;&gt;&gt; [a[2] for a in b if a[:2] == search]\n[3, 5]\n</code>\n</pre>\n", "senID": 11}, {"text": ["You see here, we got a list of all items that appear as the third item in the tuples that start with (1,2)"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["A couple attempts:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I figure you're doing something similar to this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import with_statement\n\nimport time\nfrom collections import deque, defaultdict\n\n# Just used to generate some triples of words\ndef triplegen(words=\"/usr/share/dict/words\"):\n    d=deque()\n    with open(words) as f:\n        for i in range(3):\n            d.append(f.readline().strip())\n\n        while d[-1] != '':\n            yield tuple(d)\n            d.popleft()\n            d.append(f.readline().strip())\n\nif __name__ == '__main__':\n    class D(dict):\n        def __missing__(self, key):\n            self[key] = D()\n            return self[key]\n    h=D()\n    for a, b, c in triplegen():\n        h[a][b][c] = 1\n    time.sleep(60)\n</code>\n</pre>\n", "senID": 2}, {"text": ["That gives me ~88MB."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Changing the storage to"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n h[a, b, c] = 1\n</code>\n</pre>\n", "senID": 5}, {"text": ["takes ~25MB"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["interning a, b, and c makes it take about 31MB.", "My case is a bit special because my words never repeat on the input.", "You might try some variations yourself and see if one of these helps you."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["You could try to use same dictionary, only one level deep."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n topDictionary[word1+delimiter+word2+delimiter+word3]\n</code>\n</pre>\n", "senID": 1}, {"text": ["delimiter could be plain \" \".", "(or use (word1,word2,word3))"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This would be easiest to implement.", "I believe you will see a little improvement, if it is not enough...\n...i'll think of something..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Ok, so you are basically trying to store a sparse 3D space.", "The kind of access patterns you want to this space is crucial for the choice of algorithm and data structure.", "Considering your data source, do you want to feed this to a grid?", "If you don't need O(1) access:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In order to get memory efficiency you want to subdivide that space into subspaces with a similar number of entries.", "(like a BTree).", "So a data structure with :"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 6, "lis": [{"text": "firstWordRange", "tag": "none", "senID": 2}, {"text": "secondWordRange", "tag": "none", "senID": 3}, {"text": "thirdWordRange", "tag": "none", "senID": 4}, {"text": "numberOfEntries", "tag": "none", "senID": 5}, {"text": "a sorted block of entries.", "tag": "none", "senID": 6}, {"text": "next and previous blocks in all 3 dimensions", "tag": "none", "senID": 7}]}], [{"text": ["In this case, ZODB\u00b9 BTrees might be helpful, since they are much less memory-hungry.", "Use a BTrees.OOBtree (Object keys to Object values) or BTrees.OIBTree (Object keys to Integer values), and use 3-word tuples as your key."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ZODB", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.zope.org/Products/StandaloneZODB"}]}, {"text": ["Something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from BTrees.OOBTree import OOBTree as BTree\n</code>\n</pre>\n", "senID": 2}, {"text": ["The interface is, more or less, dict-like, with the added bonus (for you) that .keys, .items, .iterkeys and .iteritems have two min, max optional arguments:"], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": ".keys", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".items", "childNum": 0, "tag": "code", "childList": []}, {"text": ".iterkeys", "childNum": 0, "tag": "code", "childList": []}, {"text": ".iteritems", "childNum": 0, "tag": "code", "childList": []}, {"text": "min, max", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; t=BTree()\n&gt;&gt;&gt; t['a', 'b', 'c']= 10\n&gt;&gt;&gt; t['a', 'b', 'z']= 11\n&gt;&gt;&gt; t['a', 'a', 'z']= 12\n&gt;&gt;&gt; t['a', 'd', 'z']= 13\n&gt;&gt;&gt; print list(t.keys(('a', 'b'), ('a', 'c')))\n[('a', 'b', 'c'), ('a', 'b', 'z')]\n</code>\n</pre>\n", "senID": 4}, {"text": ["\u00b9 Note that if you are on Windows and work with Python >2.4, I know there are packages for more recent python versions, but I can't recollect where."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["PS They exist in the CheeseShop \u263a"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "CheeseShop", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/ZODB3"}]}], [{"text": ["Are you implementing Markovian text generation?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If your chains map 2 words to the probabilities of the third I'd use a dictionary mapping K-tuples to the 3rd-word histogram.", "A trivial (but memory-hungry) way to implement the histogram would be to use a list with repeats, and then random.choice gives you a word with the proper probability."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "random.choice", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Here's an implementation with the K-tuple as a parameter:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import random\n\n# can change these functions to use a dict-based histogram\n# instead of a list with repeats\ndef default_histogram():          return []\ndef add_to_histogram(item, hist): hist.append(item)\ndef choose_from_histogram(hist):  return random.choice(hist)\n\nK=2 # look 2 words back\nwords = ...\nd = {}\n\n# build histograms\nfor i in xrange(len(words)-K-1):\n  key = words[i:i+K]\n  word = words[i+K]\n\n  d.setdefault(key, default_histogram())\n  add_to_histogram(word, d[key])\n\n# generate text\nstart = random.randrange(len(words)-K-1)\nkey = words[start:start+K]\nfor i in NUM_WORDS_TO_GENERATE:\n  word = choose_from_histogram(d[key])\n  print word,\n  key = key[1:] + (word,)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Scipy has sparse matrices, so if you can make the first two words a tuple, you can do something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy as N\nfrom scipy import sparse\n\nword_index = {}\ncount = sparse.lil_matrix((word_count*word_count, word_count), dtype=N.int)\n\nfor word1, word2, word3 in triple_list:\n    w1 = word_index.setdefault(word1, len(word_index))\n    w2 = word_index.setdefault(word2, len(word_index))\n    w3 = word_index.setdefault(word3, len(word_index))\n    w1_w2 = w1 * word_count + w2\n    count[w1_w2,w3] += 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If memory is simply not big enough, pybsddb can help store a disk-persistent map."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pybsddb", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.jcea.es/programacion/pybsddb.htm"}]}], [{"text": ["You could use a numpy multidimensional array.", "You'll need to use numbers rather than strings to index into the array, but that can be solved by using a single dict to map words to numbers."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy\nw = {'word1':1, 'word2':2, 'word3':3, 'word4':4}\na = numpy.zeros( (4,4,4) )\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then to index into your array, you'd do something like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a[w[word1], w[word2], w[word3]] += 1\n</code>\n</pre>\n", "senID": 3}, {"text": ["That syntax is not beautiful, but numpy arrays are about as efficient as anything you're likely to find.", "Note also that I haven't tried this code out, so I may be off in some of the details.", "Just going from memory here."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Here's a tree structure that uses the bisect library to maintain a sorted list of words.", "Each lookup in O(log2(n))."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "O", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import bisect\n\nclass WordList( object ):\n    \"\"\"Leaf-level is list of words and counts.\"\"\"\n    def __init__( self ):\n        self.words= [ ('\\xff-None-',0) ]\n    def count( self, wordTuple ):\n        assert len(wordTuple)==1\n        word= wordTuple[0]\n        loc= bisect.bisect_left( self.words, word )\n        if self.words[loc][0] != word:\n            self.words.insert( loc, (word,0) )        \n        self.words[loc]= ( word, self.words[loc][1]+1 )\n    def getWords( self ):\n        return self.words[:-1]\n\nclass WordTree( object ):\n    \"\"\"Above non-leaf nodes are words and either trees or lists.\"\"\"\n    def __init__( self ):\n        self.words= [ ('\\xff-None-',None)  ]\n    def count( self, wordTuple ):\n        head, tail = wordTuple[0], wordTuple[1:]\n        loc= bisect.bisect_left( self.words, head )\n        if self.words[loc][0] != head:\n            if len(tail) == 1:\n                newList= WordList()\n            else:\n                newList= WordTree()\n            self.words.insert( loc, (head,newList) )\n        self.words[loc][1].count( tail )\n    def getWords( self ):\n        return self.words[:-1]\n\nt = WordTree()\nfor a in ( ('the','quick','brown'), ('the','quick','fox') ):\n    t.count(a)\n\nfor w1,wt1 in t.getWords():\n    print w1\n    for w2,wt2 in wt1.getWords():\n        print \" \", w2\n        for w3 in wt2.getWords():\n            print \"  \", w3\n</code>\n</pre>\n", "senID": 1}, {"text": ["For simplicity, this uses a dummy value in each tree and list.", "This saves endless if-statements to determine if the list was actually empty before we make a comparison.", "It's only empty once, so the if-statements are wasted for all n-1 other words."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "n", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["You could put all words in a dictionary.", "key would be word, and value is number (index)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Then you use it like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n Word1=indexDict[word1]\nWord2=indexDict[word2]\nWord3=indexDict[word3]\n\ntopDictionary[Word1][Word2][Word3]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Insert in indexDict with:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n if word not in indexDict:\n    indexDict[word]=len(indexDict)\n</code>\n</pre>\n", "senID": 4}]]