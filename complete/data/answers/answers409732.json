[[{"text": ["If you only have one reference to the list, the following may be easier:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n bool_list = [False] * len(bool_list)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This creates a new list populated with False elements."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "False", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["See my answer to Python dictionary clear for a similar example."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Python dictionary clear", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/369898/python-dictionary-clear#369925"}]}], [{"text": ["Here's another version:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n bool_list = [False for item in bool_list]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Summary\nPerformance-wise, numpy or a list multiplication are clear winners, as they are 10-20x faster than other approaches."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Summary", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I did some performance testing on the various options proposed.", "I used Python 2.5.2, on Linux (Ubuntu 8.10), with a 1.5 Ghz Pentium M."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Original:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Original:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n python timeit.py -s 'bool_list = [True] * 1000' 'for x in xrange(len(bool_list)): bool_list[x] = False'\n</code>\n</pre>\n", "senID": 3}, {"text": ["1000 loops, best of 3: 280 usec per loop"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Slice-based replacement with a list comprehension:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Slice-based replacement with a list comprehension:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n python timeit.py -s 'bool_list = [True] * 1000' 'bool_list[:] = [False for element in bool_list]'\n</code>\n</pre>\n", "senID": 6}, {"text": ["1000 loops, best of 3: 215 usec per loop"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Slice-based replacement with a generator comprehension:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Slice-based replacement with a generator comprehension:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n python timeit.py -s 'bool_list = [True] * 1000' 'bool_list[:] = (False for element in bool_list)'\n</code>\n</pre>\n", "senID": 9}, {"text": ["1000 loops, best of 3: 265 usec per loop"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Enumerate:"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "Enumerate", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n python timeit.py -s 'bool_list = [True] * 1000' 'for i, v in enumerate(bool_list): bool_list[i] = False'\n</code>\n</pre>\n", "senID": 12}, {"text": ["1000 loops, best of 3: 385 usec per loop"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["Numpy:"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "Numpy", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n python timeit.py -s 'import numpy' -s 'bool_list = numpy.zeros((1000,), dtype=numpy.bool)' 'bool_list[:] = False'\n</code>\n</pre>\n", "senID": 15}, {"text": ["10000 loops, best of 3: 15.9 usec per loop"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["Slice-based replacement with list multiplication:"], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "Slice-based replacement with list multiplication:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n python timeit.py -s 'bool_list = [True] * 1000' 'bool_list[:] = [False] * len(bool_list)'\n</code>\n</pre>\n", "senID": 18}, {"text": ["10000 loops, best of 3: 23.3 usec per loop"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["Reference replacement with list multiplication"], "childNum": 1, "tag": "p", "senID": 20, "childList": [{"text": "Reference replacement with list multiplication", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n python timeit.py -s 'bool_list = [True] * 1000' 'bool_list = [False] * len(bool_list)'\n</code>\n</pre>\n", "senID": 21}, {"text": ["10000 loops, best of 3: 11.3 usec per loop"], "childNum": 0, "tag": "p", "senID": 22, "childList": []}], [{"code": "<pre>\n<code>\n bool_list[:] = [False] * len(bool_list)\n</code>\n</pre>\n", "senID": 0}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n bool_list[:] = [False for item in bool_list]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["If you're willing to use numpy arrays, it's actually really easy to do things like this using array slices."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org/"}]}, {"code": "<pre>\n<code>\n import numpy\n\nbool_list = numpy.zeros((100,), dtype=numpy.bool)\n\n# do something interesting with bool_list as if it were a normal list\n\nbool_list[:] = False\n# all elements have been reset to False now\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I wouldn't use the range and len.", "It's a lot cleaner to use enumerate()"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i, v in enumerate(bool_list): #i, v = index and value\n    bool_list[i] = False\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's left with an unused variable in this case, but it still looks cleaner in my opinion.", "There's no noticeable change in performance either."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["For value types such as int, bool and string, your 2nd example is about as pretty as its going to get.", "Your first example will work on any reference types like classes, dicts, or other lists."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I think "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n bool_list = [False for element in bool_list]\n</code>\n</pre>\n", "senID": 1}, {"text": ["is as pythonic as it gets.", "Using lists like this should generaly be faster then a for loop in python too."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]