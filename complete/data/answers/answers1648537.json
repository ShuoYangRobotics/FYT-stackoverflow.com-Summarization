[[{"text": ["One way to do it is to use findall with a regex that greedily matches things that can go between separators.", "eg:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "findall", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = \"Wilbur Smith (Billy, son of John), Eddie Murphy (John), Elvis Presley, Jane Doe (Jane Doe)\"\n&gt;&gt;&gt; r = re.compile(r'(?:[^,(]|\\([^)]*\\))+')\n&gt;&gt;&gt; r.findall(s)\n['Wilbur Smith (Billy, son of John)', ' Eddie Murphy (John)', ' Elvis Presley', ' Jane Doe (Jane Doe)']\n</code>\n</pre>\n", "senID": 1}, {"text": ["The regex above matches one or more:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "non-comma, non-open-paren characters", "tag": "none", "senID": 3}, {"text": "strings that start with an open paren, contain 0 or more non-close-parens, and then a close paren", "tag": "none", "senID": 4}]}, {"text": ["One quirk about this approach is that adjacent separators are treated as a single separator.", "That is, you won't see an empty string.", "That may be a bug or a feature depending on your use-case."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Also note that regexes are not suitable for cases where nesting is a possibility.", "So for example, this would split incorrectly:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n \"Wilbur Smith (son of John (Johnny, son of James), aka Billy), Eddie Murphy (John)\"\n</code>\n</pre>\n", "senID": 7}, {"text": ["If you need to deal with nesting your best bet would be to partition the string into parens, commas, and everthing else (essentially tokenizing it -- this part could still be done with regexes) and then walk through those tokens reassembling the fields, keeping track of your nesting level as you go (this keeping track of the nesting level is what regexes are incapable of doing on their own)."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["I think the best way to approach this would be to use python's built-in csv module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "csv", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/csv.html"}]}, {"text": ["Because the csv module only allows a one character quotechar, you would need to do a replace on your inputs to convert () to something like | or \".", "Then make sure you are using an appropriate dialect and off you go."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "allows", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/csv.html#csv-fmt-params"}, {"text": "quotechar", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "|", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"code": "<pre>\n<code>\n s = re.split(r',\\s*(?=[^)]*(?:\\(|$))', x)\n</code>\n</pre>\n", "senID": 0}, {"text": ["The lookahead matches everything up to the next open-parenthesis or to the end of the string, iff there's no close-parenthesis in between.", "That ensures that the comma is not inside a set of parentheses."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "iff", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["An attempt on human-readable regex:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nregex = re.compile(r\"\"\"\n    # name starts and ends on word boundary\n    # no '(' or commas in the name\n    (?P&lt;name&gt;\\b[^(,]+\\b)\n    \\s*\n    # everything inside parentheses is a role\n    (?:\\(\n      (?P&lt;role&gt;[^)]+)\n    \\))? # role is optional\n    \"\"\", re.VERBOSE)\n\ns = (\"Wilbur Smith (Billy, son of John), Eddie Murphy (John), Elvis Presley,\"\n     \"Jane Doe (Jane Doe)\")\nprint re.findall(regex, s)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [('Wilbur Smith', 'Billy, son of John'), ('Eddie Murphy', 'John'), \n ('Elvis Presley', ''), ('Jane Doe', 'Jane Doe')]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I certainly agree with @Wogan above, that using the CSV moudle is a good approach.", "Having said that if you still want to try a regex solution give this a try, but you will have to adapt it to Python dialect"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n string.split(/,(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*(?![^\\\"]*\\\"))/)\n</code>\n</pre>\n", "senID": 1}, {"text": ["HTH"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["My answer will not use regex."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I think simple character scanner with state \"in_actor_name\" should work.", "Remember then state \"in_actor_name\" is terminated either by ')' or by comma in this state."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "in_actor_name", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "in_actor_name", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["My try:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n s = 'Wilbur Smith (Billy, son of John), Eddie Murphy (John), Elvis Presley, Jane Doe (Jane Doe)'\n\nin_actor_name = 1\nrole = ''\nname = ''\nfor c in s:\n    if c == ')' or (c == ',' and in_actor_name):\n    \tin_actor_name = 1\n    \tname = name.strip()\n    \tif name:\n    \t\tprint \"%s: %s\" % (name, role)\n    \tname = ''\n    \trole = ''\n    elif c == '(':\n    \tin_actor_name = 0\n    else:\n    \tif in_actor_name:\n    \t\tname += c\n    \telse:\n    \t\trole += c\nif name:\n    print \"%s: %s\" % (name, role)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n Wilbur Smith: Billy, son of John\nEddie Murphy: John\nElvis Presley: \nJane Doe: Jane Doe\n</code>\n</pre>\n", "senID": 5}], [{"text": ["split by \")\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s=\"Wilbur Smith (Billy, son of John), Eddie Murphy (John), Elvis Presley, Jane Doe (Jane Doe)\"\n&gt;&gt;&gt; s.split(\")\")\n['Wilbur Smith (Billy, son of John', ', Eddie Murphy (John', ', Elvis Presley, Jane Doe (Jane Doe', '']\n&gt;&gt;&gt; for i in s.split(\")\"):\n...   print i.split(\"(\")\n...\n['Wilbur Smith ', 'Billy, son of John']\n[', Eddie Murphy ', 'John']\n[', Elvis Presley, Jane Doe ', 'Jane Doe']\n['']\n</code>\n</pre>\n", "senID": 1}, {"text": ["you can do further checking to get those names that doesn't come with ()."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's a general technique I've used in the past for such cases:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Use the sub function of the re module with a function as replacement argument.", "The function keeps track of opening and closing parens, brackets and braces, as well as single and double quotes, and performs a replacement only outside of such bracketed and quoted substrings.", "You can then replace the non-bracketed/quoted commas with another character which you're sure doesn't appear in the string (I use the ASCII/Unicode group-separator: chr(29) code), then do a simple string.split on that character.", "Here's the code: "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "sub", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "re", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import re\ndef srchrepl(srch, repl, string):\n    \"\"\"Replace non-bracketed/quoted occurrences of srch with repl in string\"\"\"\n\n    resrchrepl = re.compile(r\"\"\"(?P&lt;lbrkt&gt;[([{])|(?P&lt;quote&gt;['\"])|(?P&lt;sep&gt;[\"\"\"\n                            + srch + \"\"\"])|(?P&lt;rbrkt&gt;[)\\]}])\"\"\")\n    return resrchrepl.sub(_subfact(repl), string)\n\ndef _subfact(repl):\n    \"\"\"Replacement function factory for regex sub method in srchrepl.\"\"\"\n    level = 0\n    qtflags = 0\n    def subf(mo):\n        nonlocal level, qtflags\n        sepfound = mo.group('sep')\n        if  sepfound:\n            if level == 0 and qtflags == 0:\n                return repl\n            else:\n                return mo.group(0)\n        elif mo.group('lbrkt'):\n            level += 1\n            return mo.group(0)\n        elif mo.group('quote') == \"'\":\n            qtflags ^= 1            # toggle bit 1\n            return \"'\"\n        elif mo.group('quote') == '\"':\n            qtflags ^= 2            # toggle bit 2\n            return '\"'\n        elif mo.group('rbrkt'):\n            level -= 1\n            return mo.group(0)\n    return subf\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you don't have nonlocal in your version of Python, just change it to global and define level and qtflags at the module level."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "global", "childNum": 0, "tag": "code", "childList": []}, {"text": "level", "childNum": 0, "tag": "code", "childList": []}, {"text": "qtflags", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Here's how it's used: "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; GRPSEP = chr(29)\n&gt;&gt;&gt; string = \"Wilbur Smith (Billy, son of John), Eddie Murphy (John), Elvis Presley, Jane Doe (Jane Doe)\"\n&gt;&gt;&gt; lst = srchrepl(',', GRPSEP, string).split(GRPSEP)\n&gt;&gt;&gt; lst\n['Wilbur Smith (Billy, son of John)', ' Eddie Murphy (John)', ' Elvis Presley', ' Jane Doe (Jane Doe)']\n</code>\n</pre>\n", "senID": 5}], [{"text": ["None of the answers above are correct if there are any errors or noise in your data."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's easy to come up with a good solution if you know the data is right every time.", "But what happens if there are formatting errors?", "What do you want to have happen?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Suppose there are nesting parentheses?", "Suppose there are unmatched parentheses?", "Suppose the string ends with or begins with a comma, or has two in a row?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["All of the above solutions will produce more or less garbage and not report it to you."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Were it up to me, I'd start with a pretty strict restriction on what \"correct\" data was - no nesting parentheses, no unmatched parentheses, and no empty segments before, between or after comments - validate as I went, and then raise an exception if I wasn't able to validate."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]