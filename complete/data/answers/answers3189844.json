[[{"text": ["Welcome to network programming!", "You've just fallen into the same mistaken assumption that everyone makes the first time through in assuming that client sends &amp; server recives should be symmetric.", "Unfortunately, this is not the case.", "The OS allows reception to occur in arbitrarily sized chunks.", "It's fairly easy to work around though, just buffer your data until the amount you've read in equals the amount you wish to receive.", "Something along the lines of this will do the trick:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "everyone", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n buff=''\nwhile len(buff) &lt; 1024:\n    buff += s.recv( 1024 - len(buff) )\n</code>\n</pre>\n", "senID": 1}], [{"text": ["TCP is a stream protocol, it doesn't conserve message boundaries, as you have just discovered."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["As others have pointed out you're probably processing an incomplete message.", "You need to either have fixed sized messages or have a delimiter (don't forget to escape your data!", ") so you know when a complete message has been received."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["What TCP can guarantee is that all your data arrives, in the right order, at some point.", "(Unless something unexpected happens, by which it won't arrive.", ") But it's very possible that the data you send will still arrive in chunks.", "Much of it is because of limited send- and receive-buffers.", "What you should do is to continue doing your recv calls until you have enough data to process it.", "You might might have to call send multiple times; use its return value to keep track of how much data has been sent/buffered so far."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "at some point", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "recv", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "send", "childNum": 0, "tag": "code", "pos": 5, "childList": []}]}, {"text": ["When you do print socket.SO_RCVBUF, you actually print the symbolic SO_RCVBUF contant (except that Python doesn't really have constants); the one used to tell setsockopt what you want to change.", "To get the current value, you should instead call getsockopt."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "print socket.SO_RCVBUF", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "contant", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "setsockopt", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "getsockopt", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["For many applications, the complexities of TCP are neatly abstracted by Python's asynchat module. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "asynchat", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/asynchat.html"}]}], [{"text": ["Here is the nice snippet of code that I wrote some time ago, may be not the best , but it could be good example of big files transfer over the local network.", "http://setahost.com/sending-files-in-local-network-with-python/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://setahost.com/sending-files-in-local-network-with-python/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://setahost.com/sending-files-in-local-network-with-python/"}]}], [{"text": ["Not related to TCP (as that has been answered already), but appending to a string repeatedly will be rather inefficient if you're expecting to receive a lot.", "It might be better to append to a list and then turn the list into a string when you finished receiving by using ''.join(list)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "''.join(list)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]