[[{"text": ["More readable Perl, and handles multiple files sanely."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env perl\nuse constant LINES =&gt; 2;\nmy @buffer = ();\nwhile (&lt;&gt;) {\n    /pattern/ and unshift @buffer, \"\\n\";\n    push @buffer, $_;\n    print splice @buffer, 0, -LINES;\n}\ncontinue {\n    if (eof(ARGV)) {\n        print @buffer;\n        @buffer = ();\n    }\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Something a bit like your original approach in sed:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sed '/regexp/i\\\n\n$H\nx'\n</code>\n</pre>\n", "senID": 1}, {"text": ["The basic idea is to print everything delayed by one line (xchange the hold and pattern spaces - printing is implicit).", "That needs to be done because until we check whether the next line matches the regexp we don't know whether to insert a newline or not. "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "x", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "i", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["(The $H there is just a trick to make the last line print.", "It appends the last line into the hold buffer so that the final implicit print command outputs it too."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Simple:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sed '1{x;d};$H;/regexp/{x;s/^/\\n/;b};x'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Describe it"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #!/bin/sed\n\n# trick is juggling previous and current line in hold and pattern space\n\n1 {         # at firs line\n  x         # place first line to hold space\n  d         # skip to end and avoid printing\n}\n$H          # append last line to hold space to force print\n/regexp/ {  # regexp found (in current line - pattern space)\n  x         # swap previous and current line between hold and pattern space\n  s/^/\\n/   # prepend line break before previous line\n  b         # jump at end of script which cause print previous line\n}\nx           # if regexp does not match just swap previous and current line to print previous one\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit: Little bit simpler version."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n sed '$H;/regexp/{x;s/^/\\n/;b};x;1d'\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n perl -ne 'END{print @x} push@x,$_; if(@x&gt;2){splice @x,1,0,\"\\n\" if /[[:alpha:]]\\d[[:alpha:]]\\s?\\d[[:alpha:]]\\d/;print splice @x,0,-2}'\n</code>\n</pre>\n", "senID": 0}, {"text": ["If I cat your file into this, I get what you want... it's ugly, but you wanted shell (i.e., one-liner) :-)  If I were to do this in full perl, I'd be able to clean it up a lot to make it approach readable.", ":-)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Here's an approach that works for Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\ndef address_change( aFile ):\n    address= []\n    for line in aFile:\n        if regex.match( line ):\n            # end of the address\n            print address[0]\n            print \n            print address[1:]\n            print line\n            address= []\n         else:\n            address.append( line )\naddress_change( sys.stdin )\n</code>\n</pre>\n", "senID": 1}, {"text": ["This allows you to reformat a complete address to your heart's content.", "You can expand this to create define an Address class if your formatting is complex."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Address", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I tried"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sed '/regexp/a\\\\n'\n</code>\n</pre>\n", "senID": 1}, {"text": ["but it inserted two newlines.", "If that does not bother you, take it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit:\nNow that you state that you need to insert two lines above the matching regexp the suggested regex won't work."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I am not even sure if it would work at all with sed, as you need to remember past lines.", "Sounds like a job for a higher level language like python or perl :-)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]