[[{"text": ["That is exactly how I would write it.", "It's simple and it makes sense.", "I see no problem with the pass statements."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pass", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["If you want to reduce the repetition and you anticipate adding future types, you could roll this up into a loop.", "Then you could change the pass to a functionally-equivalent continue statement, if that's more pleasing to your eyes:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "pass", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "continue", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n for getter in (get_random_foo, get_random_bar):\n    try:\n        return getter()\n    except IndexError:\n        continue  # Ignore the exception and try the next type.\n\nraise IndexError, \"No foos, no bars\"\n</code>\n</pre>\n", "senID": 2}], [{"text": ["pass is fine (there's a reason it's in the language!-), but a pass-free alternative just takes a bit more nesting:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "pass", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "reason", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n try: return get_random_foo()\nexcept IndexError:\n    try: return get_random_bar()\n    except IndexError:\n        raise IndexError \"no foos, no bars\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Python's Zen (import this from the interactive interpreter prompt) says \"flat is better than nested\", but nesting is also in the language, for you to use when you decide (presumably being enlightened) that you can do better than that wise koan!-)  (As in, \"if you meet the Buddha on the road\"...)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "import this", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "also", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["It looks a little weird to me that get_random_foo() is raising an IndexError when it doesn't take an index as a param (but it might make more sense in context).", "Why not have get_random_foo(), or a wrapper, catch the error and return None instead?"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "get_random_foo()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "get_random_foo()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def get_random_foo_wrapper():\n    try:\n        return get_random_foo()\n    except IndexError:\n        return None\n\ndef get_random_foo_or_bar():\n    \"I'd rather have a foo than a bar.\"\n\n    return get_random_foo_wrapper() or get_random_bar_wrapper() or None\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: I should mention that if foo &amp; bar are objects that may evaluate to False (0 or '' say) then the or comparison will skip over them which is BAD"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "or", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If it's just those two, could always just..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    return get_random_foo()\nexcept IndexError:\n    try:\n        return get_random_bar()\n    except IndexError:\n        raise IndexError, \"No foos, no bars\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["If it's more than two, what you have written seems perfectly acceptable."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Building on Peter Gibson's suggestion, you could create a generic wrapper function that swallows a given exception.", "And then you could write a function that returns such a generic wrapper for a provided exception.", "Or heck, for a provided list of exceptions."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "returns", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "list", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n def maketrap(*exceptions):\n    def trap(func, *args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except exceptions:\n            return None\n    return trap\n\ndef get_random_foo_or_bar():\n    mytrap = maketrap(IndexError)\n    return mytrap(get_random_foo) or mytrap(get_random_bar) or None\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you don't really need the exception message (just the type):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def get_random_foo_or_bar():\n    try:\n        return get_random_foo()\n    except IndexError:\n        return get_random_bar()    # if failing at this point,\n                                   # the whole function will raise IndexError\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Is it necessary that get_random_foo/bar() raise an IndexError if it's unable to succeed?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If they returned None, you could do:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def get_random_foo_or_bar():\n    return get_random_foo() or get_random_bar()\n</code>\n</pre>\n", "senID": 2}]]