[[{"text": ["You need to somehow test for the type, if it's a string or a tuple.", "I'd do it like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n keywords = library.get_keywords()\nif not isinstance(keywords, tuple):\n    keywords = (keywords,) # Note the comma\nfor keyword in keywords:\n    do_your_thang(keyword)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["For your first problem, I'm not really sure if this is the best answer, but I think you need to check yourself whether the returned value is a string or tuple and act accordingly. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As for your second problem, any variable can be turned into a single valued tuple by placing a , next to it:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": ",", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x='abc'\n&gt;&gt;&gt; x\n'abc'\n&gt;&gt;&gt; tpl=x,\n&gt;&gt;&gt; tpl\n('abc',)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Putting these two ideas together:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def make_tuple(k):\n...     if isinstance(k,tuple):\n...             return k\n...     else:\n...             return k,\n... \n&gt;&gt;&gt; make_tuple('xyz')\n('xyz',)\n&gt;&gt;&gt; make_tuple(('abc','xyz'))\n('abc', 'xyz')\n</code>\n</pre>\n", "senID": 4}, {"text": ["Note: IMHO it is generally a bad idea to use isinstance, or any other form of logic that needs to check the type of an object at runtime.", "But for this problem I don't see any way around it. "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["There's always monkeypatching!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # Store a reference to the real library function\nreally_get_keywords = library.get_keywords\n\n# Define out patched version of the function, which uses the real\n# version above, adjusting its return value as necessary\ndef patched_get_keywords():\n    \"\"\"Make sure we always get a tuple of keywords.\"\"\"\n    result = really_get_keywords()\n    return result if isinstance(result, tuple) else (result,)\n\n# Install the patched version\nlibrary.get_keywords = patched_get_keywords\n</code>\n</pre>\n", "senID": 1}, {"text": ["NOTE: This code might burn down your house and sleep with your wife."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "NOTE:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Rather than checking for a length of 1, I'd use the isinstance built-in instead."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; isinstance('a_str', tuple)\nFalse\n&gt;&gt;&gt; isinstance(('str1', 'str2', 'str3'), tuple)\nTrue\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Your tuple_maker doesn't do what you think it does.", "An equivalent definition of tuple maker to yours is"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "tuple_maker", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tuple maker", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def tuple_maker(input):\n    return input\n</code>\n</pre>\n", "senID": 1}, {"text": ["What you're seeing is that tuple_maker(\"a string\") returns a string, while tuple_maker([\"str1\",\"str2\",\"str3\"]) returns a list of strings; neither return a tuple!"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "tuple_maker(\"a string\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tuple_maker([\"str1\",\"str2\",\"str3\"])", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Tuples in Python are defined by the presence of commas, not brackets.", "Thus (1,2) is a tuple containing the values 1 and 2, while (1,) is a tuple containing the single value 1."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "(1,2)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}, {"text": "2", "childNum": 0, "tag": "code", "childList": []}, {"text": "(1,)", "childNum": 0, "tag": "code", "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To convert a value to a tuple, as others have pointed out, use tuple."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "tuple", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; tuple([1])\n(1,)\n&gt;&gt;&gt; tuple([1,2])\n(1,2)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Is it absolutely necessary that it returns tuples, or will any iterable do?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import collections\ndef iterate(keywords):\n    if not isinstance(keywords, collections.Iterable):\n        yield keywords\n    else:\n        for keyword in keywords:\n            yield keyword\n\n\nfor keyword in iterate(library.get_keywords()):\n    print keyword\n</code>\n</pre>\n", "senID": 1}], [{"text": ["for your first problem you could check if the return value is tuple using "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n type(r) is tuple\n#alternative\nisinstance(r, tuple)\n# one-liner\ndef as_tuple(r): return [ tuple([r]), r ][type(r) is tuple]\n</code>\n</pre>\n", "senID": 1}, {"text": ["the second thing i like to use tuple([1]).", "think it is a matter of taste.", "could probably also write a wrapper, for example def tuple1(s): return tuple([s])"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "tuple([1])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "def tuple1(s): return tuple([s])", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}]]