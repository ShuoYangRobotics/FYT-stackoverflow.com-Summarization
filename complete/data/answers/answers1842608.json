[[{"text": ["Here is an excellent tutorial on how to write regular expressions in Python."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "excellent tutorial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.amk.ca/python/howto/regex/"}]}], [{"text": ["What makes your problem a little bit tricky is that you want to match inside of a multiline string.", "You need to use the re.MULTILINE flag to make that work."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re.MULTILINE", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Then, you need to match some groups inside your source string, and use those groups in the final output.", "Here is code that works to solve your problem:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import re\n\n\ns_pat = \"^\\s*REPLACE\\(([^)]+)\\)(.*)$\"\npat = re.compile(s_pat, re.MULTILINE)\n\ns_input = \"\"\"\\\nHello\nREPLACE(str1) this is to replace\nREPLACE(str2) this is to replace\"\"\"\n\n\ndef mksub(m):\n    return '&lt;replace name=\"%s\"&gt;%s&lt;/replace&gt;' % m.groups()\n\n\ns_output = re.sub(pat, mksub, s_input)\n</code>\n</pre>\n", "senID": 2}, {"text": ["The only tricky part is the regular expression pattern.", "Let's look at it in detail."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["^ matches the start of a string.", "With re.MULTILINE, this matches the start of a line within a multiline string; in other words, it matches right after a newline in the string."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "^", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "re.MULTILINE", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["\\s* matches optional whitespace."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "\\s*", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["REPLACE matches the literal string \"REPLACE\"."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "REPLACE", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["\\( matches the literal string \"(\"."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "\\(", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["( begins a \"match group\"."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "(", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["[^)] means \"match any character but a \")\"."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "[^)]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["+ means \"match one or more of the preceding pattern."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": [") closes a \"match group\"."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": ")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["\\) matches the literal string \")\""], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "\\)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["(.", "*) is another match group containing \".", "*\"."], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "(.*)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["$ matches the end of a string.", "With re.MULTILINE, this matches the end of a line within a multiline string; in other words, it matches a newline character in the string."], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "$", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "re.MULTILINE", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["matches any character, and * means to match zero or more of the preceding pattern.", "Thus .", "* matches anything, up to the end of the line."], "childNum": 3, "tag": "p", "senID": 15, "childList": [{"text": ".", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "*", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": ".*", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So, our pattern has two \"match groups\".", "When you run re.sub() it will make a \"match object\" which will be passed to mksub().", "The match object has a method, .groups(), that returns the matched substrings as a tuple, and that gets substituted in to make the replacement text."], "childNum": 3, "tag": "p", "senID": 16, "childList": [{"text": "re.sub()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "mksub()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": ".groups()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["EDIT: You actually don't need to use a replacement function.", "You can put the special string \\1 inside the replacement text, and it will be replaced by the contents of match group 1.", "(Match groups count from 1; the special match group 0 corresponds the the entire string matched by the pattern.", ")  The only tricky part of the \\1 string is that \\ is special in strings.", "In a normal string, to get a \\, you need to put two backslashes in a row, like so: \"\\\\1\"  But you can use a Python \"raw string\" to conveniently write the replacement pattern.", "Doing so you get this:"], "childNum": 5, "tag": "p", "senID": 17, "childList": [{"text": "\\1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\\1", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "\\", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "\\", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\"\\\\1\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["import re"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n s_pat = \"^\\s*REPLACE\\(([^)]+)\\)(.*)$\"\npat = re.compile(s_pat, re.MULTILINE)\n\ns_repl = r'&lt;replace name=\"\\1\"&gt;\\2&lt;/replace&gt;'\n\ns_input = \"\"\"\\\nHello\nREPLACE(str1) this is to replace\nREPLACE(str2) this is to replace\"\"\"\n\n\ns_output = re.sub(pat, s_repl, s_input)\n</code>\n</pre>\n", "senID": 19}], [{"text": ["Here is a solution using pyparsing.", "I know you specifically asked about a regex solution, but if your requirements change, you might find it easier to expand a pyparsing parser.", "Or a pyparsing prototype solution might give you a little more insight into the problem leading toward a regex or other final implementation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n src = \"\"\"\\\nHello\nREPLACE(str1) this is to replace\nREPLACE(str2) this is to replace\n\"\"\"\n\nfrom pyparsing import Suppress, Word, alphas, alphanums, restOfLine\n\nLPAR,RPAR = map(Suppress,\"()\")\nident = Word(alphas, alphanums)\nreplExpr = \"REPLACE\" + LPAR + ident(\"name\") + RPAR + restOfLine(\"body\")\nreplExpr.setParseAction(\n    lambda toks : '&lt;replace name=\"%(name)s\"&gt;%(body)s &lt;/replace&gt;' % toks\n    )\n\nprint replExpr.transformString(src)\n</code>\n</pre>\n", "senID": 1}, {"text": ["In this case, you create the expression to be matched with pyparsing, define a parse action to do the text conversion, and then call transformString to scan through the input source to find all the matches, apply the parse action to each match, and return the resulting output.", "The parse action serves a similar function to mksub in @steveha's solution."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In addition to the parse action, pyparsing also supports naming individual elements of the expression - I used \"name\" and \"body\" to label the two parts of interest, which are represented in the re solution as groups 1 and 2.", "You can name groups in an re, the corresponding re would look like:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "can", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n s_pat = \"^\\s*REPLACE\\((?P&lt;name&gt;[^)]+)\\)(?P&lt;body&gt;.*)$\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["Unfortunately, to access these groups by name, you have to invoke the group() method on the re match object, you can't directly do the named string interpolation as in my lambda parse action.", "But this is Python, right?", "We can wrap that callable with a class that will give us dict-like access to the groups by name:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "group()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class CallableDict(object):\n    def __init__(self,fn):\n        self.fn = fn\n    def __getitem__(self,name):\n        return self.fn(name)\n\ndef mksub(m):    \n    return '&lt;replace name=\"%(name)s\"&gt;%(body)s&lt;/replace&gt;' %  CallableDict(m.group)\n\ns_output = re.sub(pat, mksub, s_input)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Using CallableDict, the string interpolation in mksub can now call m.group for each field, by making it look like we are retrieving the ['name'] and ['body'] elements of a dict."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "CallableDict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Maybe like this ?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nmystr = \"\"\"Hello\nREPLACE(str1) this is to replace\nREPLACE(str2) this is to replace\"\"\"\n\nprog = re.compile(r'REPLACE\\((.*?)\\)\\s(.*)')\n\nfor line in mystr.split(\"\\n\"):\n    print prog.sub(r'&lt; replace name=\"\\1\" &gt; \\2',line)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Something like this should work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re,sys\n\nf = open( sys.argv[1], 'r' )\nfor i in f:\n    g = re.match( r'REPLACE\\((.*)\\)(.*)', i )\n    if g is None:\n        print i\n    else:\n        print '&lt;replace name=\\\"%s\\\"&gt;%s&lt;/replace&gt;' % (g.group(1),g.group(2))\nf.close()\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import re\n\na=\"\"\"Hello\nREPLACE(str1) this is to replace\nREPLACE(str2) this is to replace\"\"\"\n\nregex = re.compile(r\"^REPLACE\\(([^)]+)\\)\\s+(.*)$\", re.MULTILINE)\n\nb=re.sub(regex, r'&lt; replace name=\"\\1\" &gt; \\2 &lt; /replace &gt;', a)\n\nprint b\n</code>\n</pre>\n", "senID": 0}, {"text": ["will do the replace in one line."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]