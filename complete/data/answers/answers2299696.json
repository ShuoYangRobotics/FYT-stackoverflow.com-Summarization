[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; sorted_scores = [\n...     ('Apolo Ohno', 0),\n...     ('Shanie Davis', -1),\n...     ('Bodie Miller', -2),\n...     ('Lindsay Vohn', -3),  \n...     ('Shawn White', -3),\n...     ('Bryan Veloso',-4)\n... ]\n&gt;&gt;&gt; \n&gt;&gt;&gt; res = {}\n&gt;&gt;&gt; prev = None\n&gt;&gt;&gt; for i,(k,v) in enumerate(sorted_scores):\n...     if v!=prev:\n...         place,prev = i+1,v\n...     res[k] = place\n... \n&gt;&gt;&gt; print res\n{'Apolo Ohno': 1, 'Bryan Veloso': 6, 'Shanie Davis': 2, 'Lindsay Vohn': 4, 'Bodie Miller': 3, 'Shawn White': 4}\n</code>\n</pre>\n", "senID": 0}, {"text": ["Remember that dicts are unordered, so to iterate in order of place, you need to do this"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from operator import itemgetter\n&gt;&gt;&gt; print sorted(res.items(),key=itemgetter(1))\n[('Apolo Ohno', 1), ('Shanie Davis', 2), ('Bodie Miller', 3), ('Lindsay Vohn', 4), ('Shawn White', 4), ('Bryan Veloso', 6)]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The way to do this is not to calculate the element's position is some arbitrary sequence, but rather to calculate how many other elements have a better score."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["EDIT:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["By popular demand, O(n)'ed and everything:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n positions = {}\ncur_score = None # Score we're examining\ncur_count = 0 # Number of others that we've seen with this score\n\nfor ix, (name, score) in enumerate(sorted_scores):\n  if score == cur_score: # Same score for this player as previous\n    cur_count += 1\n  else: # Different score from before\n    cur_score = score\n    cur_count = 0\n  positions[name] = ix - cur_count + 1 # Add 1 because ix is 0-based\n\nprint positions\n</code>\n</pre>\n", "senID": 3}], [{"text": ["=== Update after change/clarification of specs ==="], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "=== Update after change/clarification of specs ===", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # coding: ascii\n\ndef ranks_from_scores(sorted_scores):\n    \"\"\"sorted_scores: a list of tuples (object_id, score), sorted by score DESCENDING\n       return a mapping of object IDs to ranks\n    \"\"\"\n    ranks = {}\n    previous_score = object()\n    for index, (obj_id, score) in enumerate(sorted_scores):\n        if score != previous_score:\n            previous_score = score\n            rank = index + 1\n        ranks[obj_id] = rank\n    return ranks\n\nfrom operator import itemgetter\nimport pprint\n\nscores0 = dict([\n    ('Apolo Ohno', 0),\n    ('Shanie Davis', -1),\n    ('Bodie Miller', -2),\n    ('Lindsay Vohn', -3),\n    ('Shawn White', -3)\n    ])\n\nscores1 = {\n    'lorem': 100,\n    'ipsum': 200,\n    'dolor': 300,\n    'sit': 300,\n    'amet': 300,\n    'quia': 400,\n    'consectetur': 500,\n    'adipiscing': 500,\n    'elit': 600,\n    }\n\nscores2 = {\n    'lorem': 100,\n    'ipsum': 200,\n    'dolor': 300,\n    'sit': 300,\n    'amet': 300,\n    'quia': 400,\n    'consectetur': 500,\n    'adipiscing': 500,\n    'elit': 6000,\n    }\n\nimport pprint\nfuncs = (ranks_from_scores, ) # Watch this space!\ntests = (scores0, scores1, scores2)\n\nfor test in tests:\n    print\n    test_list = sorted(test.items(), key=itemgetter(1), reverse=True)\n    print \"Input:\", test_list\n    for func in funcs:\n        result = func(test_list)\n        print \"%s -&gt;\" % func.__name__\n        pprint.pprint(result)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Results:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Input: [('Apolo Ohno', 0), ('Shanie Davis', -1), ('Bodie Miller', -2), ('Lindsay\n Vohn', -3), ('Shawn White', -3)]\nranks_from_scores -&gt;\n{'Apolo Ohno': 1,\n 'Bodie Miller': 3,\n 'Lindsay Vohn': 4,\n 'Shanie Davis': 2,\n 'Shawn White': 4}\n\nInput: [('elit', 600), ('consectetur', 500), ('adipiscing', 500), ('quia', 400),\n ('dolor', 300), ('sit', 300), ('amet', 300), ('ipsum', 200), ('lorem', 100)]\nranks_from_scores -&gt;\n{'adipiscing': 2,\n 'amet': 5,\n 'consectetur': 2,\n 'dolor': 5,\n 'elit': 1,\n 'ipsum': 8,\n 'lorem': 9,\n 'quia': 4,\n 'sit': 5}\n\nInput: [('elit', 6000), ('consectetur', 500), ('adipiscing', 500), ('quia', 400)\n, ('dolor', 300), ('sit', 300), ('amet', 300), ('ipsum', 200), ('lorem', 100)]\nranks_from_scores -&gt;\n{'adipiscing': 2,\n 'amet': 5,\n 'consectetur': 2,\n 'dolor': 5,\n 'elit': 1,\n 'ipsum': 8,\n 'lorem': 9,\n 'quia': 4,\n 'sit': 5}\n</code>\n</pre>\n", "senID": 3}, {"text": ["=== original submission ==="], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "=== original submission ===", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This code assumes that you really want the highest score to get rank 1, not the lowest score getting rank 1 (or 0!", ")."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n # coding: ascii\n\ndef ranks_from_scores(scores, debug=False):\n    \"\"\"scores (a mapping of object IDs to scores)\n       return a mapping of object IDs to ranks\n    \"\"\"\n    alist = [(v, k) for k, v in scores.items()]\n    alist.sort(reverse=True)\n    if debug: print 'alist:', alist\n    bdict = {}\n    previous_score = object()\n    for posn, (score, obj_id) in enumerate(alist):\n        if score != previous_score:\n            previous_score = score\n            rank = posn + 1\n        bdict[obj_id] = rank\n    if debug:\n        print 'bdict:', bdict\n        blist = [(v, k) for k, v in bdict.items()]\n        print 'blist:', sorted(blist)\n    return bdict\n\nranks_from_scores(\n    {'q': 10, 'w': 20, 'e': 20, 'r': 20, 't': 30},\n    debug=True,\n    )\n</code>\n</pre>\n", "senID": 6}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n alist: [(30, 't'), (20, 'w'), (20, 'r'), (20, 'e'), (10, 'q')]\nbdict: {'q': 5, 'r': 2, 'e': 2, 't': 1, 'w': 2}\nblist: [(1, 't'), (2, 'e'), (2, 'r'), (2, 'w'), (5, 'q')]\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Looks like you can use the sorted and enumerate builtins, the groupby method from itertools and the itemgetter method from operator.", "Assumes higher scores are better... (if lower scores are better, change reverse=True to reverse=False)"], "childNum": 8, "tag": "p", "senID": 0, "childList": [{"text": "sorted", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "enumerate", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "groupby", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "itertools", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "itemgetter", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "operator", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "reverse=True", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "reverse=False", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import groupby\n&gt;&gt;&gt; from operator import itemgetter\n&gt;&gt;&gt; scores = {\n...     'lorem': 100,\n...     'ipsum': 200,\n...     'dolor': 300,\n...     'sit': 300,\n...     'amet': 300,\n...     'quia': 400,\n...     'consectetur': 500,\n...     'adipiscing': 500,\n...     'elit': 600,\n...     }\n&gt;&gt;&gt; sorted_items = sorted(scores.items(), key=itemgetter(1), reverse=True)\n&gt;&gt;&gt; groups = groupby(sorted_items, itemgetter(1))\n&gt;&gt;&gt; for rank, (score, items) in enumerate(groups):\n...     print rank+1, map(itemgetter(0), items)\n... \n1 ['elit']\n2 ['consectetur', 'adipiscing']\n3 ['quia']\n4 ['dolor', 'sit', 'amet']\n5 ['ipsum']\n6 ['lorem']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Solution"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Solution", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Here's one simple way to do it by modifying your code a little rather than importing modules:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n prev = None\nrank = 0\nincr = 1\npositions = {}\nfor key, value in sorted_list:\n    if value is not None:\n        if value != prev:\n            rank += incr\n            incr = 1\n        else:\n            incr += 1\n        positions[key] = rank\n        prev = value\n</code>\n</pre>\n", "senID": 2}, {"text": ["A Test "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "A Test", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["For"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n sorted_list = [\n    ('Apolo Ohno', 0),\n    ('Shanie Davis', -1),\n    ('Bodie Miller', -2),\n    ('Lindsay Vohn', -3),  \n    ('Shawn White', -3),\n    ('Bryan Veloso',-4)\n]\n</code>\n</pre>\n", "senID": 5}, {"text": ["I get positions as:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n {'Apolo Ohno': 1, \n'Shanie Davis': 2,\n 'Bodie Miller': 3,\n 'Lindsay Vohn': 4,\n 'Shawn White': 4,\n 'Bryan Veloso': 6}\n</code>\n</pre>\n", "senID": 7}, {"text": ["which I think is what you are going for even though you aren't quite clear about whether there should be a 6 after the two 4's."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["I'm having to make a bunch of assumptions about what it is you want to do, but here's an attempt:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n scores = {\n    'lorem': 100,\n    'ipsum': 200,\n    'dolor': 300,\n    'sit': 300,\n    'amet': 300,\n    'quia': 400,\n    'consectetur': 500,\n    'adipiscing': 500,\n    'elit': 600,\n    }\n\ngroups = {}\nfor (member, score) in scores.items():\n    if score not in groups:\n        groups[score] = [member]\n    else:\n        groups[score].append(member)\n\npositions = {}\nfor (rank, (score, members)) in enumerate(groups.items()):\n    for member in members:\n        positions[member] = rank\n</code>\n</pre>\n", "senID": 1}, {"text": ["Showing my working:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import pprint\n&gt;&gt;&gt; scores = {\n...     'lorem': 100,\n...     'ipsum': 200,\n...     'dolor': 300,\n...     'sit': 300,\n...     'amet': 300,\n...     'quia': 400,\n...     'consectetur': 500,\n...     'adipiscing': 500,\n...     'elit': 600,\n...     }\n&gt;&gt;&gt; groups = {}\n&gt;&gt;&gt; for (member, score) in scores.items():\n...     if score not in groups:\n...         groups[score] = [member]\n...     else:\n...         groups[score].append(member)\n...\n&gt;&gt;&gt; pprint.pprint(groups)\n{100: ['lorem'],\n 200: ['ipsum'],\n 300: ['sit', 'dolor', 'amet'],\n 400: ['quia'],\n 500: ['consectetur', 'adipiscing'],\n 600: ['elit']}\n&gt;&gt;&gt; positions = {}\n&gt;&gt;&gt; for (rank, (score, members)) in enumerate(groups.items()):\n...     for member in members:\n...         positions[member] = rank\n...\n&gt;&gt;&gt; pprint.pprint(positions)\n{'adipiscing': 4,\n 'amet': 2,\n 'consectetur': 4,\n 'dolor': 2,\n 'elit': 5,\n 'ipsum': 1,\n 'lorem': 0,\n 'quia': 3,\n 'sit': 2}\n&gt;&gt;&gt; pprint.pprint(sorted(positions.items(), key=lambda i: i[1]))\n[('lorem', 0),\n ('ipsum', 1),\n ('sit', 2),\n ('dolor', 2),\n ('amet', 2),\n ('quia', 3),\n ('consectetur', 4),\n ('adipiscing', 4),\n ('elit', 5)]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here is a simple way to do it"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n last = None\nposition = 0\ndelta = 1\nfor key, value in sorted_list:\n    if value is not None:\n        if value != last:\n            position += delta\n            delta = 1\n        else:\n            delta += 1\n        # i believe this is supposed to be [key] not [value] in OP's code\n        positions[key] = position\n        last = value\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; sorted_scores = [\n...     ('Apolo Ohno', 0),\n...     ('Shanie Davis', -1),\n...     ('Bodie Miller', -2),\n...     ('Lindsay Vohn', -3),  \n...     ('Shawn White', -3),\n...     ('Bryan Veloso',-4)\n... ]\n&gt;&gt;&gt; \n&gt;&gt;&gt; from itertools import groupby\n&gt;&gt;&gt; from operator import itemgetter\n&gt;&gt;&gt; \n&gt;&gt;&gt; place=1\n&gt;&gt;&gt; res={}\n&gt;&gt;&gt; for _,items in groupby(sorted_scores,key=itemgetter(1)):\n...     for i,item in enumerate(items):\n...         res[item[0]]= place\n...     place+=i+1\n... \n&gt;&gt;&gt; print res\n{'Apolo Ohno': 1, 'Bryan Veloso': 6, 'Shanie Davis': 2, 'Lindsay Vohn': 4, 'Bodie Miller': 3, 'Shawn White': 4}\n</code>\n</pre>\n", "senID": 0}, {"text": ["Remember that dicts are unordered, so to iterate in order of place, you need to do this"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print sorted(res.items(),key=itemgetter(1))\n[('Apolo Ohno', 1), ('Shanie Davis', 2), ('Bodie Miller', 3), ('Lindsay Vohn', 4), ('Shawn White', 4), ('Bryan Veloso', 6)]\n</code>\n</pre>\n", "senID": 2}]]