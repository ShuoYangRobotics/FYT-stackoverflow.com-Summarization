[[{"text": ["You can try to implement some sort of declarative syntax for your data."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "declarative syntax", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.oreillynet.com/pub/a/python/2003/07/31/declarative%5Fpython.html"}]}, {"text": ["Which may result in something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Image(SomeClassWithMetamagic):\n    type = PackedValue(2)\n    attribute = PackedValue('attributes') # accessed via self.__dict__\n\n#or using decorators\n    @pack(\"&lt;II\")\n    def get_size():\n        pass\n\n#and a generic function in the Superclass\n    def get_packed():\n        stuff\n</code>\n</pre>\n", "senID": 2}, {"text": ["etc..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Other examples would be SQLAlchemy's declarative_base, ToscaWidgets and sprox"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n from StringIO import StringIO\nimport struct\n\nclass BinaryIO(StringIO):\n    def writepack(self, fmt, *values):\n        self.write(struct.pack('&lt;' + fmt, *values))\n\ndef to_binary_example():\n    data = BinaryIO()\n    data.writepack('I', 42)\n    data.writepack('II', 1, 2)\n    return data.getvalue()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If you just want nicer syntax, you can abuse generators/decorators:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from functools import wraps    \n\ndef packed(g):\n  '''a decorator that packs the list data items\n     that is generated by the decorated function\n  '''\n  @wraps(g)\n  def wrapper(*p, **kw):\n    data = []\n    for params in g(*p, **kw):\n      fmt = params[0]\n      fields = params[1:]\n      data.append(struct.pack('&lt;'+fmt, *fields))\n    return ''.join(data)    \n  return wrapper\n\n@packed\ndef as_binary(self):\n  '''just |yield|s the data items that should be packed\n     by the decorator\n  '''\n  yield 'I', [2]\n  yield 'II', self.image.size[0], self.image.size[1]\n  yield 'I', len(self.attributes)\n\n  for attribute in self.attributes:\n    yield 'I', attribute.id\n    yield 'H', attribute.type\n    if attribute.type == 0:\n      yield 'I', attribute.typeEx\n</code>\n</pre>\n", "senID": 1}, {"text": ["Basically this uses the generator to implement a \"monad\", an abstraction usually found in functional languages like Haskell.", "It separates the generation of some values from the code that decides how to combine these values together.", "It's more a functional programming approach then \"pythonic\", but I think it improves readability."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["How about protocol buffers google's extensive cross language  format and protocol of sharing data. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "protocol buffers", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/protobuf/"}]}], [{"code": "<pre>\n<code>\n def to_binary(self):\n    struct_i_pack = struct.Struct('&lt;I').pack\n    struct_ii_pack = struct.Struct('&lt;II').pack\n    struct_h_pack = struct.Struct('&lt;H').pack\n    struct_ih_pack = struct.Struct('&lt;IH').pack\n    struct_ihi_pack = struct.Struct('&lt;IHI').pack\n\n    return ''.join([\n        struct_i_pack(2),\n        struct_ii_pack(*self.image.size),\n        struct_i_pack(len(self.attributes)),\n        ''.join([\n            struct_ih_pack(a.id, a.type) if a.type else struct_ihi_pack(a.id, a.type, a.typeEx)\n            for a in attributes\n        ])\n    ])\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You could refactor your code to wrap boilerplate in a class.", "Something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def to_binary(self):\n    'Return the binary representation as a string.'\n    binary = BinaryWrapper()\n\n    # Binary version number.\n    binary.pack('&lt;I', [2])\n\n    # alternatively, you can pass an array\n    stuff = [\n        ('&lt;II', *self.image.size),          # Image size.\n        ('&lt;I', len(self.attributes)),       # Attribute count\n    ]\n    binary.pack_all(stuff)\n\n    return binary.get_packed()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The worst problem is that you need corresponding code in C++ to read the output.", "Can you reasonably arrange to have both the reading and writing code mechanically derive from or use a common specification?", "How to go about that depends on your C++ needs as much as Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can get rid of the repetition while still as readable easily like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def to_binary(self):     \n    output = struct.pack(\n        '&lt;IIII', 2, self.image.size[0], self.image.size[1], len(self.attributes)\n    )\n    return output + ''.join(\n        struct.pack('&lt;IHI', attribute.id, attribute.type, attribute.typeEx)\n        for attribute in self.attributes\n    )\n</code>\n</pre>\n", "senID": 1}]]