[[{"text": ["Python's support for large integers is fine.", "I think your problem is that you're doing very slow algorithms for both brute-force finding the factor and testing whether your factor is prime.", "If you just invert the order of those two tests (ie, test whether it's a factor, then test whether it's prime), it'll go a lot faster."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But perhaps the problem was about using more sophisticated algorithms.", "Maybe you should use the Rabin-Miller test instead of brute-force."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Rabin-Miller test", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/410681-rabin-miller-probabilistic-prime-test/"}]}], [{"text": ["Rather than starting out with a huge number for testing, try your algorithm on smaller numbers.", "Then try progressively larger numbers.", "Plot the amount of time the function takes - I'd suggest using the timeit module.", "Then extrapolate and estimate how long the function will take on the number you're trying."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "timeit", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["I think you'll find that your algorithm is taking so long that it looks like it never finishes."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Your loop condition of"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while(i &lt; a/2):\n</code>\n</pre>\n", "senID": 1}, {"text": ["is making your algorithm take O(N) time."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["A simple modification will improve this to O(&radic;N)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n hi = int(math.sqrt(a) + 1)     # +1 in case of rounding error.\nwhile i &lt;= hi:\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I've found that Python does a great job with large integers.", "As already mentioned, you are using two brute force tests to crack this nut."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a = 600851475143\nq = 2\n\nwhile q &lt;= a / 2:\n    if not a % q:\n        a /= q\n        p = q\n    else:\n        q += 1\n\nprint p\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I wrote some hobby code that has to do with prime numbers in the past, which I've adapted to work for your purposes.", "Here is the code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def isPrime(n, primes=[]):\n    \"\"\" Return True iff n is a prime number.\n            If primes is non-empty, return true iff n is co-prime to every number in primes. \"\"\"\n\n    if not len(primes):\n            if n &lt;= 2:\n                    return True\n            elif n%2 == 0:\n                    return False\n            else:\n                    prime = True\n                    for i in range(3, n, 2):\n                            if n%i == 0:\n                                    prime = False\n                    if prime:\n                            return True\n    else:\n            for p in primes:\n                    if not n%p:\n                            return False\n            return True\n\ndef next(n, primes):\n    \"\"\" Return a number p such that\n            1. p is co-prime to every number in primes\n            2. p&gt;n and p-n is as small as possible\"\"\"\n\n    curr = n+1\n    while 1:\n            if isPrime(curr, primes):\n                    return curr\n            else:\n                    curr += 1\n\ndef generate(n):\n    \"\"\" Yield the first n prime numbers\"\"\"\n\n    primes = [2]\n    curr = 2\n    for _ in range(n-1):\n            p = next(curr, primes)\n            primes.append(p)\n            curr = p\n            yield p\n\ndef primeNumbers(n):\n    \"\"\" return a list of prime numbers such that all numbers in the list are at most n\n            1 is a prime number\"\"\"\n\n    answer = []\n    if n &lt;= 2:\n            answer.append(n)\n    else:\n            for i in range(3, n+1, 2):\n                    prime = True\n                    for p in answer:\n                            if i%p == 0:\n                                    prime = False\n                                    break\n                    if prime:\n                            answer.append(i)\n\n    return answer\n\ndef PFIND(n):\n    primes = primeNumbers(n)\n    primes.reverse()\n    for p in primes:\n        if n%p == 0:\n            return p\n</code>\n</pre>\n", "senID": 1}, {"text": ["That should do it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Hope this helps"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Python's long number support is very verbose and well tested, so I doubt that's the problem.", "One thing I noticed about your code is that it hasn't be optimized at all and computes the value a/2 several times during in each iteration of the loop.", "However even if you fixed that it would likely still be too slow because finding prime factors can be a very time consuming especially for larger numbers. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "a/2", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "finding prime factors", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Prime_factor"}]}, {"text": ["For that reason I think the best approach would be to find a better algorithm.", "Here's code derived from one I found which calculates all the prime factors of a number.", "I converted it to Python and simplified it to just keep track of the largest factor it finds.", "It quickly returned the correct answer for your test case, whose prime factors are {71, 839, 1471, &amp; 6857}. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def maxprimefactor(n):\n    \"\"\" find the largest prime factor of a positive integer \"\"\"\n    maxfactor = None\n    divisor = 2\n    while divisor*divisor &lt;= n:\n        if n % divisor:\n            divisor += 1\n        else:\n            maxfactor = divisor\n            n /= divisor\n    if n != 1:\n        maxfactor = n\n\n    return maxfactor if maxfactor else 1\n\nprint maxprimefactor(600851475143)\n# 6857\n</code>\n</pre>\n", "senID": 2}]]