[[{"text": ["Your code looks very strange, but I assume it's very simplified.", "If it's just about getting rid of the i[0], do this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "i[0]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def get():\n...     for i in range(3):\n...             yield 0\n... \n&gt;&gt;&gt; r = []\n&gt;&gt;&gt; r.extend(get())\n&gt;&gt;&gt; r\n[0, 0, 0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["To me, this looks like get can only ever return a list of length 1.", "If that's the case, drop the braces:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def get():\n...     for i in range(3):\n...             yield 0\n&gt;&gt;&gt; # Or, shorter ...\n&gt;&gt;&gt; get = lambda: (0 for i in range(3))\n&gt;&gt;&gt; r = []\n&gt;&gt;&gt; r.extend(get())\n&gt;&gt;&gt; r\n[0, 0, 0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The reason you are having to use i[0] is because get() is a generator that returns a list of size 1 every time it is called.", "So your code i[0] for i in get() is the same as i[0] for i in  ([0],[0],[0]).", "The reason your code works is that i[0] gets the first element off the returned element which is itself the list [0]."], "childNum": 7, "tag": "p", "senID": 0, "childList": [{"text": "i[0]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "get()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "i[0] for i in get()", "childNum": 0, "tag": "code", "childList": []}, {"text": "i[0] for i in  ([0],[0],[0])", "childNum": 0, "tag": "code", "childList": []}, {"text": "i[0]", "childNum": 0, "tag": "code", "childList": []}, {"text": "list [0]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["What I gather from your question is that you want to have i for i in [0,0,0].", "As mentioned in other answers this can be achieved by changing you generator to yield the int 0 instead of the list [0].", "You can see the result of the generator in the following example code:"], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "i for i in [0,0,0]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "[0]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for i in get():\n...   print(\"i={} and i[0]={}\".format(i, i[0]))\n... \ni=[0] and i[0]=0\ni=[0] and i[0]=0\ni=[0] and i[0]=0\n</code>\n</pre>\n", "senID": 2}, {"text": ["As you can see, your generator returns a [0] every iteration and that is the reason you have to use i[0] to get the first element of each list."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "[0]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "i[0]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Also, since r is just the results of the generator, you can simplify by just doing the following:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "r", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def gen():\n...   for i in range(3):\n...     yield 0\n... \n&gt;&gt;&gt; r = list(gen())\n&gt;&gt;&gt; r\n[0, 0, 0]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["This kind of imperative code (stateful, with inplace updates) is asking for trouble.", "That seems the canonical use for a functional flatten (concat):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "flatten", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#recipes"}, {"href": "http://zvon.org/other/haskell/Outputprelude/concat_f.html", "text": "concat", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import chain\n\ndef flatten(listOfLists):\n    return chain.from_iterable(listOfLists)\n\ndef get():\n    for i in range(3):\n        yield [0]\n\nprint(list(flatten(get())))\n# [0, 0, 0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Don't yield an array if you don't want one:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def get():\n...  for i in range(3):\n...   yield 0\n... \n&gt;&gt;&gt; r = []\n&gt;&gt;&gt; r.extend(i for i in get())\n&gt;&gt;&gt; r\n[0, 0, 0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could try this instead:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def get():\n    return [0] * 3\n\nr = [] \nr.extend(get())\nr\n[0, 0, 0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["??"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def get():\n    for i in xrange(3):\n        yield 0\n\nr = list(get())\n\nprint r\n</code>\n</pre>\n", "senID": 1}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n gen = (0 for i in xrange(3))\n\nr = list(gen)\n\nprint r\n</code>\n</pre>\n", "senID": 3}]]