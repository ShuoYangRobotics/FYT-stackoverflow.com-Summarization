[[{"text": ["Try this out:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from email.utils import parseaddr\n\n&gt;&gt;&gt; parseaddr('From: vg@m.com')\n('', 'vg@m.com')\n\n&gt;&gt;&gt; parseaddr('From: Van Gale &lt;vg@m.com&gt;')\n('Van Gale', 'vg@m.com')\n\n&gt;&gt;&gt; parseaddr('    From: Van Gale &lt;vg@m.com&gt;   ')\n('Van Gale', 'vg@m.com')\n\n&gt;&gt;&gt; parseaddr('blah abdf    From: Van Gale &lt;vg@m.com&gt;   and this')\n('Van Gale', 'vg@m.com')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Unfortunately it only finds the first email in each line because it's expecting header lines, but maybe that's ok?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n import email\nmsg = email.message_from_string(str)\n\n# or\n# f = open(file)\n# msg = email.message_from_file(f)\n\nmsg['from']\n\n# and optionally\nfrom email.utils import parseaddr\naddr = parseaddr(msg['from'])\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n mailsrch = re.compile(r'[\\w\\-][\\w\\-\\.]+@[\\w\\-][\\w\\-\\.]+[a-zA-Z]{1,4}')\n</code>\n</pre>\n", "senID": 0}, {"text": ["Expression breakdown:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["[\\w-]: any word character (alphanumeric, plus underscore) or a dash"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[\\w-]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["[\\w-.", "]+: any word character, a dash, or a period/dot, one or more times"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "[\\w-.]+", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["@: literal @ symbol"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "@", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["[\\w-][\\w-.", "]+: any word char or dash, followed by any word char, dash, or period one or more times."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "[\\w-][\\w-.]+", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["[a-zA-Z]{1,4}: any alphabetic character 1-4 times."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "[a-zA-Z]{1,4}", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["To make this match only lines starting with From:, and wrapped in &lt; and &gt; symbols: "], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "From:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\nfoundemail = []\nmailsrch = re.compile(r'^From:\\s+.*&lt;([\\w\\-][\\w\\-\\.]+@[\\w\\-][\\w\\-\\.]+[a-zA-Z]{1,4})&gt;', re.I | re.M)\nfoundemail.extend(mailsrch.findall(open('text.txt').read()))\n\nprint foundemail\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Use the email and mailbox packages to parse the plain text version of the email.", "This will convert it to an object that will enable to extract all the addresses in the 'From' field."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can also do a lot of other analysis on the message, if you need to process other header fields, or the message body."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As a quick example, the following (untested) code should read all the message in a unix style mailbox, and print all the 'from' headers."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import mailbox\nimport email\n\nmbox = mailbox.PortableUnixMailbox(open(filename, 'rU'), email.message_from_file)\n\nfor msg in mbox:\n   from = msg['From']\n   print from\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I'd do it by expanding the regular expression you're using to include the extra text you want to match.", "So first, let me explain what that regex does:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [\\w\\-][\\w\\-\\.]+@[\\w\\-][\\w\\-\\.]+[a-zA-Z]{1,4}\n</code>\n</pre>\n", "senID": 1}, {"tag": "ul", "num": 6, "lis": [{"text": ["[\\w\\-]"], "childNum": 0, "tag": "code", "senID": 2, "childList": []}, {"text": ["[\\w\\-\\.", "]+"], "childNum": 0, "tag": "code", "senID": 3, "childList": []}, {"text": [], "childNum": 0, "tag": "code", "senID": 4, "childList": []}, {"text": ["[\\w\\-]"], "childNum": 0, "tag": "code", "senID": 5, "childList": []}, {"text": ["[\\w\\-\\.", "]+"], "childNum": 0, "tag": "code", "senID": 6, "childList": []}, {"text": ["[a-zA-Z]{1,4}"], "childNum": 0, "tag": "code", "senID": 7, "childList": []}]}, {"text": ["Now, to modify this for your purposes, let's add regex parts to match \"From\", the name, and the angle brackets:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n From: [\\w\\s]+?&lt;([\\w\\-][\\w\\-\\.]+@[\\w\\-][\\w\\-\\.]+[a-zA-Z]{1,4})&gt;\n</code>\n</pre>\n", "senID": 9}, {"tag": "ul", "num": 5, "lis": [{"text": ["From: "], "childNum": 0, "tag": "code", "senID": 10, "childList": []}, {"text": ["[\\w\\s]+?"], "childNum": 0, "tag": "code", "senID": 11, "childList": []}, {"text": ["&lt;"], "childNum": 0, "tag": "code", "senID": 12, "childList": []}, {"text": "The same regular expression you had before is now surrounded by parentheses. This makes it a ", "tag": "none", "senID": 13}, {"text": ["&gt;"], "childNum": 0, "tag": "code", "senID": 14, "childList": []}]}, {"text": ["Since the regex now uses capturing groups, your code will need to change a little as well:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n import re\nfoundemail = []\n\nmailsrch = re.compile(r'From: [\\w\\s]+?&lt;([\\w\\-][\\w\\-\\.]+@[\\w\\-][\\w\\-\\.]+[a-zA-Z]{1,4})&gt;')\n\nfor line in open(\"text.txt\"):\n    foundemail.extend([m.group(1) for m in mailsrch.finditer(line)])\n\nprint foundemail\n</code>\n</pre>\n", "senID": 16}, {"text": ["The code [m.group(1) for m in mailsrch.finditer(line)] produces a list out of the first capturing group (remember, that was the part in parentheses) from each match found by the regular expression."], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "[m.group(1) for m in mailsrch.finditer(line)]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["if you can be reasonably sure that lines containing these email addresses start with whitespace followed by \"From:\" you can simply do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n addresslines = []\nfor line in open(\"text.txt\"):\n    if line.strip().startswith(\"From:\"):\n        addresslines.append(line)\n</code>\n</pre>\n", "senID": 1}, {"text": ["then later - or on adding them to the list - you can refine the addresslines items to give out exactly what you want"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["\"[stuff]@[stuff][stuff1-4 letters]\" is about right, but if you wanted to you could decode the regular expression using a trick I just found out about, here.", "Do the compile() in an interactive Python session like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/101268/hidden-features-of-python"}]}, {"code": "<pre>\n<code>\n mailsrch = re.compile(r'[\\w\\-][\\w\\-\\.]+@[\\w\\-][\\w\\-\\.]+[a-zA-Z]{1,4}', 128)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It will print out the following:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n in \n  category category_word\n  literal 45\nmax_repeat 1 65535 \n  in \n    category category_word\n    literal 45\n    literal 46\nliteral 64 \nin \n  category category_word\n  literal 45\nmax_repeat 1 65535 \n  in \n    category category_word\n    literal 45\n    literal 46\nmax_repeat 1 4 \n  in \n    range (97, 122)\n    range (65, 90)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Which, if you can kind of get used to it, shows you exactly how the RE works."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Roughly speaking, you can:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from email.utils import parseaddr\n\nfoundemail = []\nfor line in open(\"text.txt\"):\n    if not line.startswith(\"From:\"): continue\n    n, e = parseaddr(line)\n    foundemail.append(e)\nprint foundemail\n</code>\n</pre>\n", "senID": 1}, {"text": ["This utilizes the built-in python parseaddr function to parse the address out of the from line (as demonstrated by other answers), without the overhead necessarily of parsing the entire message (e.g.", "by using the more full featured email and mailbox packages).", "The script here simply skips any lines that do not begin with \"From:\".", "Whether the overhead matters to you depends on how big your input is and how often you will be doing this operation."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]