[[{"text": ["If you want a class with \"locked-down\" instance attributes, it's not hard to make one, e.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class LockedDown(object):\n  __locked = False\n  def __setattr__(self, name, value):\n    if self.__locked:\n      if name[:2] != '__' and name not in self.__dict__:\n        raise ValueError(\"Can't set attribute %r\" % name)\n    object.__setattr__(self, name, value)\n  def _dolock(self):\n    self.__locked = True\n\nclass Example(LockedDown):\n  def __init__(self):\n    self.mistakes = 0\n    self._dolock()\n  def onemore(self):\n    self.mistakes += 1\n    print self.mistakes\n  def reset(self):\n    self.mitsakes = 0\n\nx = Example()\nfor i in range(3): x.onemore()\nx.reset()\n</code>\n</pre>\n", "senID": 1}, {"text": ["As you'll see, the calls to x.onemore work just fine, but reset raises an exception because of the mis-spelling of the attribute as mitsakes.", "The rules of engagement here are that __init__ must set all attributes to initial values, then call self._dolock() to forbid any further addition of attributes.", "I'm exempting \"super-private\" attributes (ones starting with __), which stylistically should be used very rarely, for totally specific roles, and with extremely limited scope (making it trivial to spot typos in the super-careful inspection that's needed anyway to confirm the need for super-privacy), but that's a stylistic choice, easy to reverse; similarly for the choice to make the locked-down state \"irreversible\" (by \"normal\" means -- i.e.", "requiring very explicit workaround to bypass)."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "x.onemore", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "reset", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "mitsakes", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "self._dolock()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["This doesn't apply to other kinds of names, such as function-local ones; again, no big deal because each function should be very small, and is a totally self-contained scope, trivially easy to inspect (if you write 100-lines functions, you have other, serious problems;-)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Is this worth the bother?", "No, because semi-decent unit tests should obviously catch all such typos with the greatest of ease, as a natural side effect of thoroughly exercising the class's functionality.", "In other words, it's not as if you need to have more unit tests just to catch the typos: the unit tests you need anyway to catch trivial semantic errors (off-by-one, +1 where -1 is meant, etc., etc.", ") will already catch all typos, too."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "more", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Robert Martin and Bruce Eckel both articulated this point 7 years ago in separate and independent articles -- Eckel's blog is temporarily down right now, but Martin's right here, and when Eckel's site revives the article should be here.", "The thesis is controversial (Jeff Attwood and his commenters debate it here, for example), but it's interesting to note that Martin and Eckel are both well-known experts of static languages such as C++ and Java (albeit with love affairs, respectively, with Ruby and Python), and they're far from the only ones to have discovered the importance of unit-tests... and how a good unit-tests suite, as a side effect, makes a static language's rigidity redundant."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.artima.com/weblogs/viewpost.jsp?thread=4639"}, {"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.mindview.net/WebLog/log-0025"}, {"href": "http://www.codinghorror.com/blog/archives/000070.html", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["By the way, one way to check your test suites is \"error injection\": systematically go over your codebase introducing one mis-spelling -- run the tests to make sure they do fail, if they don't add one that does fail, correct the spelling mistake, repeat.", "Can be fairly well automated (not the \"add a test\" part, but the finding of potential errors that aren't covered by the suite), as can some other forms of error injections (change every integer constant, one by one, to one more, and to one less; change each &lt; to &lt;= etc; swap each if and while condition to its reverse; ...), while other forms of error-injection yet require a lot more human savvy.", "Unfortunately I don't know of publicly available suites of error injection frameworks (for any language) -- might make a cool open source project;-)."], "childNum": 5, "tag": "p", "senID": 6, "childList": [{"text": "does", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "&lt;", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "&lt;=", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "if", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "while", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["In python it helps to think of declaring variables as binding values to names."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Try not to misspell them, or you will have new ones (assuming you are talking about assignment statements - referencing them will cause an exception)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you are talking about instance variables, you won't be able to use them afterwards."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For example, if you had a class myclass and in its __init__ method wrote self.myvar = 0, then trying to reference self.myvare will cause an error, rather than give you a default value."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "myclass", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}, {"text": "self.myvar = 0", "childNum": 0, "tag": "code", "childList": []}, {"text": "self.myvare", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["It's a silly artifact of Python's inspiration by \"teaching languages\", and it serves to make the language more accessible by removing the stumbling block of \"declaration\" entirely.", "For whatever reason (probably represented as \"simplicity\"), Python never gained an optional stricture like VB's \"Option Explicit\" to introduce mandatory declarations.", "Yes, it can be a source of bugs, but as the other answers here demonstrate, good coders can develop habits that allow them to compensate for pretty much any shortcoming in the language -- and as shortcomings go, this is a pretty minor one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Python never forces you to create a variable only when you use it.", "You can always bind None to a name and then use the name elsewhere later."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["To avoid a situation with misspelling variable names, I use a text-editor with an autocompletion function and binded "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n python -c \"import py_compile; py_compile.compile('{filename}')\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["to a function to be called when I save a file."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you do any serious development you'll use a (integrated) development environment.", "Pylint will be part of it and tell you all your misspellings.", "No need to make such a feature part of the langauge."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Pylint", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.logilab.org/857"}]}], [{"text": ["Test."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Example, with file variable.py:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "variable.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #! /usr/bin/python\n\nsomevar = 5\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then, make file variable.txt (to hold the tests):"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "variable.txt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import variables\n&gt;&gt;&gt; variables.somevar == 4\nTrue\n</code>\n</pre>\n", "senID": 4}, {"text": ["Then do:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n python -m doctest variable.txt\n</code>\n</pre>\n", "senID": 6}, {"text": ["And get:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n **********************************************************************\nFile \"variables.txt\", line 2, in variables.test\nFailed example:\n    variables.somevar == 4\nExpected:\n    True\nGot:\n    False\n**********************************************************************\n1 items had failures:\n   1 of   2 in variables.test\n***Test Failed*** 1 failures.\n</code>\n</pre>\n", "senID": 8}, {"text": ["This shows a variable declared incorrectly."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Try:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import variables\n&gt;&gt;&gt; variables.someothervar == 5\nTrue\n</code>\n</pre>\n", "senID": 11}, {"text": ["Note that the variable is not named the same."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n **********************************************************************\nFile \"variables.test\", line 2, in variables.test\nFailed example:\n    variables.someothervar == 5\nException raised:\n    Traceback (most recent call last):\n      File \"/usr/local/lib/python2.6/doctest.py\", line 1241, in __run\n        compileflags, 1) in test.globs\n      File \"&lt;doctest variables.test[1]&gt;\", line 1, in &lt;module&gt;\n        variables.someothervar == 5\n    AttributeError: 'module' object has no attribute 'someothervar'\n**********************************************************************\n1 items had failures:\n   1 of   2 in variables.test\n***Test Failed*** 1 failures.\n</code>\n</pre>\n", "senID": 13}, {"text": ["This shows a misspelled variable."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import variables\n&gt;&gt;&gt; variables.somevar == 5\nTrue\n</code>\n</pre>\n", "senID": 15}, {"text": ["And this returns with no error."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["I've done enough VBScript development to know that typos are a problem in variable name, and enough VBScript development to know that Option Explicit is a crutch at best.", "(&lt;- 12 years of ASP VBScript experience taught me that the hard way."], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "Option Explicit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Variable declaration does not prevent bugs.", "Any more than lack of variable declaration causes bugs."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Variable declarations prevent one specific type of bug, but it creates other types bugs."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Prevent.", "Writing code where there's an attempt to set (or change) a variable with the wrong type of data.  "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Prevent", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Causes.", "Stupid workarounds to coerce a number of unrelated types together so that assignments will \"just work\".", "Example:  The C language union.", "Also, variable declarations force us to use casts.", "Which also forces us to suppress warnings on casts at compile time because we \"know\" it will \"just work\".", "And it doesn't."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Causes", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "union", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Lack of variable declarations does not cause bugs.", "The most common \"threat scenario\" is some kind of \"mis-assignment\" to a variable."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Raising an uncaught exception in production use is annoying and shows a lack of quality.", "It's stupid, but it's also a detected, known failure mode with a traceback to the exact root cause."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["\"can't it cause bugs because you misspelled a variable's name\""], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "\"can't it cause bugs because you misspelled a variable's name\"", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Yes.", "It can."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["But consider this Java code."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n public static void maine( String[] argv ) {\n    int main;\n    int mian;\n}\n</code>\n</pre>\n", "senID": 9}, {"text": ["A misspelling here is equally fatal.", "Statically typed Java has done nothing to prevent a misspelled variable name from causing a bug."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "nothing", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}]]