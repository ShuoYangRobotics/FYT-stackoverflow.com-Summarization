[[{"text": ["Replacing internal stuff like this is always dangerous because it can have nasty side effects.", "So what you indeed want, is to have the monkey patching be as local as possible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["We use Michael Foord's excellent mock library: http://www.voidspace.org.uk/python/mock/ that has a @patch decorator which patches certain functionality, but the monkey patch only lives in the scope of the testing function, and everything is automatically restored after the function runs out of its scope."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "http://www.voidspace.org.uk/python/mock/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.voidspace.org.uk/python/mock/"}, {"text": "@patch", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The only problem is that the internal datetime module is implemented in C, so by default you won't be able to monkey patch it.", "We fixed this by making our own simple implementation which can be mocked."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "datetime", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "can", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["The total solution is something like this (the example is a validator function used within a Django project to validate that a date is in the future).", "Mind you I took this from a project but took out the non-important stuff, so things may not actually work when copy-pasting this, but you get the idea, I hope :)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["First we define our own very simple implementation of datetime.date.today in a file called utils/date.py:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "datetime.date.today", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "utils/date.py", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import datetime\n\ndef today():\n    return datetime.date.today()\n</code>\n</pre>\n", "senID": 5}, {"text": ["Then we create the unittest for this validator in tests.py:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "tests.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import datetime\nimport mock\nfrom unittest2 import TestCase\n\nfrom django.core.exceptions import ValidationError\n\nfrom .. import validators\n\nclass ValidationTests(TestCase):\n    @mock.patch('utils.date.today')\n    def test_validate_future_date(self, today_mock):\n        # Pin python's today to returning the same date\n        # always so we can actually keep on unit testing in the future :)\n        today_mock.return_value = datetime.date(2010, 1, 1)\n\n        # A future date should work\n        validators.validate_future_date(datetime.date(2010, 1, 2))\n\n        # The mocked today's date should fail\n        with self.assertRaises(ValidationError) as e:\n            validators.validate_future_date(datetime.date(2010, 1, 1))\n        self.assertEquals([u'Date should be in the future.'], e.exception.messages)\n\n        # Date in the past should also fail\n        with self.assertRaises(ValidationError) as e:\n            validators.validate_future_date(datetime.date(2009, 12, 31))\n        self.assertEquals([u'Date should be in the future.'], e.exception.messages)\n</code>\n</pre>\n", "senID": 7}, {"text": ["The final implementation looks like this:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n from django.utils.translation import ugettext_lazy as _\nfrom django.core.exceptions import ValidationError\n\nfrom utils import date\n\ndef validate_future_date(value):\n    if value &lt;= date.today():\n        raise ValidationError(_('Date should be in the future.'))\n</code>\n</pre>\n", "senID": 9}, {"text": ["Hope this helps"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["You could write your own datetime module replacement class, implementing the methods and classes from datetime that you want to replace.", "For example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import datetime as datetime_orig\n\nclass DatetimeStub(object):\n    \"\"\"A datetimestub object to replace methods and classes from \n    the datetime module. \n\n    Usage:\n        import sys\n        sys.modules['datetime'] = DatetimeStub()\n    \"\"\"\n    class datetime(datetime_orig.datetime):\n\n        @classmethod\n        def now(cls):\n            \"\"\"Override the datetime.now() method to return a\n            datetime one year in the future\n            \"\"\"\n            result = datetime_orig.datetime.now()\n            return result.replace(year=result.year + 1)\n\n    def __getattr__(self, attr):\n        \"\"\"Get the default implementation for the classes and methods\n        from datetime that are not replaced\n        \"\"\"\n        return getattr(datetime_orig, attr)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Let's put this in its own module we'll call  datetimestub.py"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "datetimestub.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Then, at the start of your test, you can do this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import sys\nimport datetimestub\n\nsys.modules['datetime'] = datetimestub.DatetimeStub()\n</code>\n</pre>\n", "senID": 4}, {"text": ["Any subsequent import of the datetime module will then use the datetimestub.DatetimeStub instance, because when a module's name is used as a key in the sys.modules dictionary, the module will not be imported: the object at sys.modules[module_name] will be used instead."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "datetime", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "datetimestub.DatetimeStub", "childNum": 0, "tag": "code", "childList": []}, {"text": "sys.modules", "childNum": 0, "tag": "code", "childList": []}, {"text": "sys.modules[module_name]", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Slight variation to Steef's solution.", "Rather than replacing datetime globally instead you could just replace the datetime module in just the module you are testing, e.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import models # your module with the Event model\nimport datetimestub\n\nmodels.datetime = datetimestub.DatetimeStub()\n</code>\n</pre>\n", "senID": 1}, {"text": ["That way the change is much more localised during your test."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["What if you mocked the self.end_date instead of the datetime?", "Then you could still test that the function is doing what you want without all the other crazy workarounds suggested."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This wouldn't let you stub all date/times like your question initially asks, but that might not be completely necessary."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\ntoday = datetime.date.today()\n\nevent1 = Event()\nevent1.end_date = today - datetime.timedelta(days=1) # 1 day ago\nevent2 = Event()\nevent2.end_date = today + datetime.timedelta(days=1) # 1 day in future\n\nself.assertTrue(event1.is_over())\nself.assertFalse(event2.is_over())\n</pre>\n", "senID": 2}], [{"text": ["This doesn't perform system-wide datetime replacement, but if you get fed up with trying to get something to work you could always add an optional parameter to make it easier for testing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_over(self, today=datetime.datetime.now()):\n    return today &gt; self.date_end\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'd suggest taking a look at testfixtures test_datetime:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://packages.python.org/testfixtures/datetime.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://packages.python.org/testfixtures/datetime.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://packages.python.org/testfixtures/datetime.html"}]}], [{"text": ["Two choices."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's the Strategy version."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Strategy", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class DateTimeFactory( object ):\n    \"\"\"Today and now, based on server's defined locale.\n\n    A subclass may apply different rules for determining \"today\".  \n    For example, the broswer's time-zone could be used instead of the\n    server's timezone.\n    \"\"\"\n    def getToday( self ):\n        return datetime.date.today()\n    def getNow( self ):\n        return datetime.datetime.now()\n\nclass Event( models.Model ):\n    dateFactory= DateTimeFactory() # Definitions of \"now\" and \"today\".\n    ... etc. ...\n\n    def is_over( self ):\n        return dateFactory.getToday() &gt; self.date_end \n\n\nclass DateTimeMock( object ):\n    def __init__( self, year, month, day, hour=0, minute=0, second=0, date=None ):\n        if date:\n            self.today= date\n            self.now= datetime.datetime.combine(date,datetime.time(hour,minute,second))\n        else:\n            self.today= datetime.date(year, month, day )\n            self.now= datetime.datetime( year, month, day, hour, minute, second )\n    def getToday( self ):\n        return self.today\n    def getNow( self ):\n        return self.now\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now you can do this"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class SomeTest( unittest.TestCase ):\n    def setUp( self ):\n        tomorrow = datetime.date.today() + datetime.timedelta(1)\n        self.dateFactoryTomorrow= DateTimeMock( date=tomorrow )\n        yesterday = datetime.date.today() + datetime.timedelta(1)\n        self.dateFactoryYesterday=  DateTimeMock( date=yesterday )\n    def testThis( self ):\n        x= Event( ... )\n        x.dateFactory= self.dateFactoryTomorrow\n        self.assertFalse( x.is_over() )\n        x.dateFactory= self.dateFactoryYesterday\n        self.asserTrue( x.is_over() )\n</code>\n</pre>\n", "senID": 4}, {"text": ["In the long run, you more-or-less must do this to account for browser locale separate from server locale.", "Using default datetime.datetime.now() uses the server's locale, which may piss off users who are in a different time zone."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "must", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "datetime.datetime.now()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]