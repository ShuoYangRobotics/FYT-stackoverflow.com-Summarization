[[{"text": ["When Python 2.7 comes out you can use its collections.Counter class"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "collections.Counter class", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/collections.html#collections.Counter"}]}, {"text": ["otherwise see counter receipe"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "counter receipe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/576611/"}]}, {"text": ["Under Python 2.7a3 "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from collections import Counter\ninput =  ['a', 'a', 'b', 'b', 'b']\nc = Counter( input )\n\nprint( c.items() )\n</code>\n</pre>\n", "senID": 3}, {"text": ["output is"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If your items are grouped (i.e.", "similar items come together in a bunch), the most efficient method to use is itertools.groupby:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.groupby", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [(g[0], len(list(g[1]))) for g in itertools.groupby(['a', 'a', 'b', 'b', 'b'])]\n[('a', 2), ('b', 3)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I know this isn't a one-liner... but to me I like it because it's clear to me that we pass over the initial list of values once (instead of calling count on it):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import defaultdict\n&gt;&gt;&gt; l = ['a', 'a', 'b', 'b', 'b']\n&gt;&gt;&gt; d = defaultdict(int)\n&gt;&gt;&gt; for i in l:\n...  d[i] += 1\n... \n&gt;&gt;&gt; d\ndefaultdict(&lt;type 'int'&gt;, {'a': 2, 'b': 3})\n&gt;&gt;&gt; list(d.iteritems())\n[('a', 2), ('b', 3)]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Another way to do this would be"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n mylist = [1, 1, 2, 3, 3, 3, 4, 4, 4, 4]\nmydict = {}\nfor i in mylist:\n    if i in mydict: mydict[i] += 1\n    else: mydict[i] = 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["then to get the list of tuples,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n mytups = [(i, mydict[i]) for i in mydict]\n</code>\n</pre>\n", "senID": 3}, {"text": ["This only goes over the list once, but it does have to traverse the dictionary once as well.", "However, given that there are a lot of duplicates in the list, then the dictionary should be a lot smaller, hence faster to traverse."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Nevertheless, not a very pretty or concise bit of code, I'll admit."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["the \"old school way\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; alist=['a', 'a', 'b', 'b', 'b']\n&gt;&gt;&gt; d={}\n&gt;&gt;&gt; for i in alist:\n...    if not d.has_key(i): d[i]=1  #also: if not i in d\n...    else: d[i]+=1\n...\n&gt;&gt;&gt; d\n{'a': 2, 'b': 3}\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; mylist=['a', 'a', 'b', 'b', 'b']\n&gt;&gt;&gt; [ (i,mylist.count(i)) for i in set(mylist) ]\n[('a', 2), ('b', 3)]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["A solution without hashing:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def lcount(lst):\n   return reduce(lambda a, b: a[0:-1] + [(a[-1][0], a[-1][1]+1)] if a and b == a[-1][0] else a + [(b, 1)], lst, [])\n\n&gt;&gt;&gt; lcount([])\n[]\n&gt;&gt;&gt; lcount(['a'])\n[('a', 1)]\n&gt;&gt;&gt; lcount(['a', 'a', 'a', 'b', 'b'])\n[('a', 3), ('b', 2)]\n</code>\n</pre>\n", "senID": 1}]]