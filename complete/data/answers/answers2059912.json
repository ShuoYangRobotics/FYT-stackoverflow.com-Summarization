[[{"text": ["Do not try to duplicate the work that the filesystem already does.", "You are not going to do better than it already does."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Your scheme is flawed in many ways and it will not get you an order-of-magnitude improvement."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Flaws and potential problems:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You are always going to be working with a snapshot of the file system.", "You will never know with any certainty that it is not significantly disjoint from reality.", "If that is within the working parameters of your application, no sweat."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The filesystem monitor program still has to recursively walk the file system, so the work is still being done."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In order to increase the accuracy of the cache, you have to increase the frequency with which the filesystem monitor runs.", "The more it runs, the less actual time that you are saving."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Your client application likely won't be able to read the index file while it is being updated by the filesystem monitor program, so you'll lose time while the client waits for the index to be readable."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I could go on."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["If, in fact, you don't care about working with a snapshot of the filesystem that may be very disjoint from reality, I think that you'd be much better off with keeping the index in memory and updating from with the application itself.", "That will scrub any file contention issues that will otherwise arise."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Doesn't Windows Desktop Search provide such an index as a byproduct?", "On the mac the spotlight index can be queried for filenames like this: mdfind -onlyin .", "-name '*'."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "mdfind -onlyin . -name '*'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Of course it's much faster than walking the directory."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The best answer came from Micha\u0142 Marczyk toward the bottom of the comment list on the initial question.", "He pointed out that what I'm describing is very close to the UNIX locate program.", "I found a Windows version here: http://locate32.net/index.php.", "It solved my problem."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Micha\u0142 Marczyk", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/232707/michal-marczyk"}, {"text": "http://locate32.net/index.php", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://locate32.net/index.php"}]}, {"text": ["Edit:  Actually the Everything search engine looks even better.", "Apparently Windows keeps journals of changes to the filesystem, and Everything uses that to keep the database up to date."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Everything", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.voidtools.com/"}]}], [{"text": ["I would like to recommend you just use a combination of os.walk (to get directory trees) &amp; os.stat (to get file information) for this.", "Using the std-lib will ensure it works on all platforms, and they do the job nicely.", "And no need to index anything."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "os.walk", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "os.stat", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["As other have stated, I don't really think you're going to buy much by attempting to index and re-index the filesystem, especially if you're already limiting your functionality by path and parameters."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I'm new to Python, but I'm using a combination of list comprehensions, iterator and a generator should scream according to reports I've read."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class DirectoryIterator:\n    def __init__(self, start_dir, pattern):\n        self.directory = start_dir\n        self.pattern = pattern\n\n def __iter__(self):\n     [([DirectoryIterator(dir, self.pattern) for dir in dirnames], [(yield os.path.join(dirpath, name)) for name in filenames if re.search(self.pattern, name) ]) for dirpath, dirnames, filenames in os.walk(self.directory)]\n\n ###########\n\n for file_name in DirectoryIterator(\".\", \"\\.py$\"): print file_name\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The short answer is \"no\".", "You will not be able to build an indexing system in Python that will outpace the file system by an order of magnitude."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\"Indexing\" a filesystem is an intensive/slow task, regardless of the caching implementation.", "The only realistic way to avoid the huge overhead of building filesystem indexes is to \"index as you go\" to avoid the big traversal.", "(After all, the filesystem itself is already a data indexer."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There are operating system features that are capable of doing this \"build as you go\" filesystem indexing.", "It's the very foundation of services like Spotlight on OSX and Windows Desktop Search."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["To have any hope of getting faster speeds than walking the directories, you'll want to leverage one of those OS or filesystem level tools."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Also, try not to mislead yourself into thinking solutions are faster just because you've \"moved\" the work to a different time/process.", "Your example code does exactly that.", "You traverse the directory structure of your sample files while you're building the same files and create the index, and then later just read that file."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "while you're building the same files", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["There are two lessons, here.", "(a) To create a proper test it's essential to separate the \"setup\" from the \"test\".", "Here your performance test essentially says, \"Which is faster, traversing a directory structure or reading an index that's already been created in advance?", "\"  Clearly this is not an apples to oranges comparison."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["However, (b) you've stumbled on the correct answer at the same time.", "You can get a list of files much faster if you use an already existing index.", "This is where you'd need to leverage something like the Windows Desktop Search or Spotlight indexes."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "if you use an already existing index", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Make no mistake, in order to build an index of a filesystem you must, by definition, \"visit\" every file.", "If your files are stored in a tree, then a recursive traversal is likely going to be the fastest way you can visit every file.", "If the question is \"can I write Python code to do exactly what os.walk does but be an order of magnitude faster than os.walk\" the answer is a resounding no.", "If the question is \"can I write Python code to index every file on the system without taking the time to actually visit every file\" then the answer is still no."], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "os.walk", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "os.walk", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "no", "childNum": 0, "tag": "em", "pos": 3, "childList": []}, {"text": "no", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["(Edit in response to \"I don't think you understand what I'm trying to do\")"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Edit in response to \"I don't think you understand what I'm trying to do\"", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Let's be clear here, virtually everyone here understands what you're trying to do.", "It seems that you're taking \"no, this isn't going to work like you want it to work\" to mean that we don't understand."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Let's look at this from another angle.", "File systems have been an essential component to modern computing from the very beginning.", "The categorization, indexing, storage, and retrieval of data is a serious part of computer science and computer engineering and many of the most brilliant minds in computer science are working on it constantly."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["You want to be able to filter/select files based on attributes/metadata/data of the files.", "This is an extremely common task utilized constantly in computing.", "It's likely happening several times a second even on the computer you're working with right now."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["If it were as simple to speed up this process by an order of magnitude(!", ") by simply keeping a text file index of the filenames and attributes, don't you think every single file system and operating system in existence would do exactly that?"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "If it were as simple to speed up this process by an order of magnitude(!) by simply keeping a text file index of the filenames and attributes, don't you think every single file system and operating system in existence would do exactly that?", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["That said, of course caching the results of your specific queries could net you some small performance increases.", "And, as expected, file system and disk caching is a fundamental part of every modern operating system and file system."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["But your question, as you asked it, has a clear answer: No.", "In the general case, you're not going to get an order of magnitude faster reimplementing os.walk.", "You may be able to get a better amortized runtime by caching, but you're not going to be beat it by an order of magnitude if you properly include the work to build the cache in your profiling."], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "No", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "os.walk", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]