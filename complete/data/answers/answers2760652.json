[[{"text": ["Not using Popen.communicate() or call() will result in a zombie process."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Popen.communicate()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "call()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you don't need the output of the command, you can use subprocess.call():"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "subprocess.call()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import subprocess\n&gt;&gt;&gt; subprocess.call(['grep', 'jdoe', '/etc/passwd'])\n0\n</code>\n</pre>\n", "senID": 2}, {"text": ["If the output is important, you should use Popen() and communicate() to get the stdout and stderr."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Popen()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "communicate()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from subprocess import Popen, PIPE\n&gt;&gt;&gt; process = Popen(['ls', '-l', '/tmp'], stdout=PIPE, stderr=PIPE)\n&gt;&gt;&gt; stdout, stderr = process.communicate()\n&gt;&gt;&gt; stderr\n''\n&gt;&gt;&gt; print stdout\ntotal 0\n-rw-r--r-- 1 jdoe jdoe 0 2010-05-03 17:05 bar\n-rw-r--r-- 1 jdoe jdoe 0 2010-05-03 17:05 baz\n-rw-r--r-- 1 jdoe jdoe 0 2010-05-03 17:05 foo\n</code>\n</pre>\n", "senID": 4}], [{"text": ["A zombie process is not a real process; it's just a remaining entry in the process table until the parent process requests the child's return code.", "The actual process has ended and requires no other resources but said process table entry."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["We probably need more information about the processes you run in order to actually help more."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["However, in the case that your Python program knows when the child processes have ended (e.g.", "by reaching the end of the child stdout data), then you can safely call process.wait():"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "knows", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "process.wait()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import subprocess\n\nprocess= subprocess.Popen( ('ls', '-l', '/tmp'), stdout=subprocess.PIPE)\n\nfor line in process.stdout:\n        pass\n\nsubprocess.call( ('ps', '-l') )\nprocess.wait()\nprint \"after wait\"\nsubprocess.call( ('ps', '-l') )\n</code>\n</pre>\n", "senID": 3}, {"text": ["Example output:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n $ python so2760652.py\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n0 S   501 21328 21326  0  80   0 -  1574 wait   pts/2    00:00:00 bash\n0 S   501 21516 21328  0  80   0 -  1434 wait   pts/2    00:00:00 python\n0 Z   501 21517 21516  0  80   0 -     0 exit   pts/2    00:00:00 ls &lt;defunct&gt;\n0 R   501 21518 21516  0  80   0 -   608 -      pts/2    00:00:00 ps\nafter wait\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n0 S   501 21328 21326  0  80   0 -  1574 wait   pts/2    00:00:00 bash\n0 S   501 21516 21328  0  80   0 -  1467 wait   pts/2    00:00:00 python\n0 R   501 21519 21516  0  80   0 -   608 -      pts/2    00:00:00 ps\n</code>\n</pre>\n", "senID": 5}, {"text": ["Otherwise, you can keep all the children in a list, and now and then .poll for their return codes.", "After every iteration, remember to remove from the list the children with return codes different than None (i.e.", "the finished ones)."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": ".poll", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I'm not sure what you mean \"I need to run my script with no_wait()\", but I think this example does what you need.", "Processes will not be zombies for very long.", "The parent process will only wait() on them when they are actually already terminated and thus they will quickly unzombify."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "wait()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python2.6\nimport subprocess\nimport sys\nimport time\n\nchildren = []\n#Step 1: Launch all the children asynchronously\nfor i in range(10):\n    #For testing, launch a subshell that will sleep various times\n    popen = subprocess.Popen([\"/bin/sh\", \"-c\", \"sleep %s\" % (i + 8)])\n    children.append(popen)\n    print \"launched subprocess PID %s\" % popen.pid\n\n#reverse the list just to prove we wait on children in the order they finish,\n#not necessarily the order they start\nchildren.reverse()\n#Step 2: loop until all children are terminated\nwhile children:\n    #Step 3: poll all active children in order\n    children[:] = [child for child in children if child.poll() is None]\n    print \"Still running: %s\" % [popen.pid for popen in children]\n    time.sleep(1)\n\nprint \"All children terminated\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["The output towards the end looks like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Still running: [29776, 29774, 29772]\nStill running: [29776, 29774]\nStill running: [29776]\nStill running: []\nAll children terminated\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The python runtime takes responsibility for getting rid of zombie process once their process objects have been garbage collected.", "If you see the zombie lying around it means you have kept a process object and not called wait, poll or terminate on it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I'm not entirely sure what you mean by no_wait().", "Do you mean you can't block waiting for child processes to finish?", "Assuming so, I think this will do what you want:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "no_wait()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n os.wait3(os.WNOHANG)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you simply use subprocess.Popen, you'll be fine - here's how:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "subprocess.Popen", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import subprocess\n\ndef spawn_some_children():\n    subprocess.Popen([\"sleep\", \"3\"])\n    subprocess.Popen([\"sleep\", \"3\"])\n    subprocess.Popen([\"sleep\", \"3\"])\n\ndef do_some_stuff():\n    spawn_some_children()\n    # do some stuff\n    print \"children went out to play, now I can do my job...\"\n    # do more stuff\n\nif __name__ == '__main__':\n    do_some_stuff()\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can use .poll() on the object returned by Popen to check whether it finished (without waiting).", "If it returns None, the child is still running."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": ".poll()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Make sure you don't keep references to the Popen objects - if you do, they will not be garbage collected, so you end up with zombies.", "Here's an example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import subprocess\n\ndef spawn_some_children():\n    children = []\n    children.append(subprocess.Popen([\"sleep\", \"3\"]))\n    children.append(subprocess.Popen([\"sleep\", \"3\"]))\n    children.append(subprocess.Popen([\"sleep\", \"3\"]))\n    return children\n\ndef do_some_stuff():\n    children = spawn_some_children()\n    # do some stuff\n    print \"children went out to play, now I can do my job...\"\n    # do more stuff\n\n    # if children finish while we are in this function,\n    # they will become zombies - because we keep a reference to them\n</code>\n</pre>\n", "senID": 4}, {"text": ["In the above example, if you want to get rid of the zombies, you can either .wait() on each of the children or .poll() until the result is not None."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": ".wait()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".poll()", "childNum": 0, "tag": "code", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Either way is fine - either not keeping references, or using.wait()or.poll()."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "Either way is fine - either not keeping references, or using.wait()or.poll().", "childNum": 2, "tag": "strong", "pos": 0, "childList": [{"text": ".wait()", "tag": "code"}, {"text": ".poll()", "tag": "code"}]}, {"text": ".wait()", "childNum": 0, "tag": "code", "childList": []}, {"text": ".poll()", "childNum": 0, "tag": "code", "childList": []}]}]]