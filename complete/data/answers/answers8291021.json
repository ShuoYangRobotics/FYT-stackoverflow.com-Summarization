[[{"text": ["Your regex is consuming non whitespace characters only (\\S).", "That is why it stops matching when it encounters a space character."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\\S", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Change that to .*.", "This will greedily match all characters except newlines (\\n)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": ".*", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\n", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n re.findall(r'ke\\w+ = .+$', s)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or this, to capture only what's after the equals sign:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n re.findall(r'ke\\w+ = (.+)$', s)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You need to do keyword=re.findall(r'ke\\w+ = \\S.", "*',s) instead of keyword=re.findall(r'ke\\w+ = \\S+',s)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "keyword=re.findall(r'ke\\w+ = \\S.*',s)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "keyword=re.findall(r'ke\\w+ = \\S+',s)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Also, not sure if it serves what you want but following your example you could also do re.split as following:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "re.split", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = 'keyword = NORTH FACE'\n&gt;&gt;&gt; re.split(' = ', s)\n['keyword', 'NORTH FACE']\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 2}], [{"text": ["No need for regex.", "Try partition or split:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "partition", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#str.partition"}, {"href": "http://docs.python.org/library/stdtypes.html#str.split", "text": "split", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n lines = '''\\\nkeyword = NORTH FACE\nkeyword = GUESS\nkeyword = DRESSES\nkeyword = RALPH LAUREN\n'''.splitlines()\n\nfor line in lines:\n    line.partition(' = ')[2]\nprint\nfor line in lines:\n    print line.split(' = ')[1]\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n<code>\n NORTH FACE\nGUESS\nDRESSES\nRALPH LAUREN\n\nNORTH FACE\nGUESS\nDRESSES\nRALPH LAUREN\n</code>\n</pre>\n", "senID": 2}, {"text": ["Given the new information in the comment and making a guess as to the datafile format (Update the question with a REAL example!", "):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndata = '''\\\nkeyword = NORTH FACE\nscore = 88466\nnormalizedKeyword = NORTH FACE\n\nkeyword = DRESSES\nscore = 79379\nnormalizedKeyword = DRESSES\n'''\n\nL = re.findall(r'keyword = (.*)\\nscore = (.*)\\n',data)\nfor i in L:\n    print ','.join(i)\n</code>\n</pre>\n", "senID": 4}, {"code": "<pre>\n<code>\n NORTH FACE,88466\nDRESSES,79379\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Try:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s=\"\"\"\n... keyword = NORTH FACE\n... keyword = GUESS\n... keyword = DRESSES\n... keyword = RALPH LAUREN\n... \"\"\"\n&gt;&gt;&gt; re.findall(r'ke\\w+ = .*',s)\n['keyword = NORTH FACE', 'keyword = GUESS', 'keyword = DRESSES', 'keyword = RALPH LAUREN']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Not sure if this is what you seek ..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["From one of your comments, if you have adjacent lines that you want the values to pair up, but may be surrounded by non-paired lines, you have to do a few things."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Expanded regex:\n(?", ":^|\\n) [^\\S\\n]*\n(?", ":keyword) [^\\S\\n]* = [^\\S\\n]* (\\w(?", ":[^\\S\\n]*\\w+)*) [^\\S\\n]* \\n\n\\s*\n(?", ":score)   [^\\S\\n]* = [^\\S\\n]* (\\w(?", ":[^\\S\\n]*\\w+)*) [^\\S\\n]*\n(?=\\n|$) "], "childNum": 10, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "(?:^|\\n) [^\\S\\n]*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "(?:keyword) [^\\S\\n]* = [^\\S\\n]* (\\w(?:[^\\S\\n]*\\w+)*) [^\\S\\n]* \\n", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}, {"text": "\\s*", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 4, "childList": []}, {"text": "(?:score)   [^\\S\\n]* = [^\\S\\n]* (\\w(?:[^\\S\\n]*\\w+)*) [^\\S\\n]*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 5, "childList": []}, {"text": "(?=\\n|$)", "childNum": 0, "tag": "code", "childList": []}]}]]