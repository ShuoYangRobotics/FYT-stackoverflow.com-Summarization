[[{"text": ["I've had a look at your code, and it looks like you make a lot of function calls and attribute lookups as part of your 'checking' or looking ahead before leaping.", "You also have a lot of code dedicated to track the same condition, i.e many bits of code looking at creating 'unique' IDs. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["instead of trying to assign some kind of unique string to each ballot, couldn't you just\nuse the ballotID (an integer number?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["now you could have a dictionary (uniqueBallotIDs) mapping ballotID and the actual ballot object."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["the process might be something like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def appendBallot(self, ballot, ballotID=None):\n   if ballotID is None:\n       ballotID = self._getuniqueid() # maybe just has a counter? up to you.\n   # check to see if we have seen this ballot before.\n   if not self._isunique(ballotID):\n       # code for non-unique ballot ids.\n   else:\n       # code for unique ballot ids.\n\n   self.ballotOrder.append(i)\n</code>\n</pre>\n", "senID": 4}, {"text": ["You might be able to handle some of your worries about the dictionary missing a given key\nby using a defaultdict (from the collections module).", "collection docs"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "collection docs", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html"}]}, {"text": ["Edit for completeness I will include a sample usage of the defaultdict:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import defaultdict            \n\n&gt;&gt;&gt; ballotIDmap = defaultdict(list)\n&gt;&gt;&gt; ballotID, ballot = 1, object() # some nominal ballotID and object.\n&gt;&gt;&gt; # I will now try to save my ballotID.\n&gt;&gt;&gt; ballotIDmap[ballotID].append(ballot)\n&gt;&gt;&gt; ballotIDmap.items()\n[(1, [&lt;object object at 0x009BB950&gt;])]\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Yeah I came across that same problem as well."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The only way I know to work around this is to wrap your large function into several smaller function calls.", "This will allow the profiler to take into account each of the smaller function calls."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Interesting enough, the process of doing this (for me, anyway) made it obvious where the inefficiencies were, so I didn't even have to run the profiler."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I have used this decorator in my code, and it helped me with my pyparsing tuning work."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this decorator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mg.pov.lt/blog/profiling.html"}]}, {"text": ["-- Paul"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Profilers can be like that.", "The method I use is this.", "It gets right to the heart of the problem in no time."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/375913/what-can-i-use-to-profile-c-code-in-linux/378024#378024"}]}], [{"text": ["I'll support Fragsworth by saying that you'll want to split up your function into smaller ones."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Having said that, you are reading the output correctly: the tottime is the one to watch.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Now for where your slowdown is likely to be:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Since there seem to be 100000 calls to appendBallot, and there aren't any obvious loops, I'd suggest it is in your assert.", "Because you are executing:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n assert(ballotID not in self.ballotIDs)\n</code>\n</pre>\n", "senID": 4}, {"text": ["This will actually act as a loop.", "Thus, the first time you call this function, it will iterate through a (probably empty) array, and then assert if the value was found.", "The 100000th time it will iterate through the entire array."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["And there is actually a possible bug here: if a ballot is deleted, then the next ballot added would have the same id as the last added one (unless that were the one deleted).", "I think you would be better off using a simple counter.", "That way you can just increment it each time you add a ballot.", "Alternatively, you could use a UUID to get unique ids."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Alternatively, if you are looking at some level of persistence, use an ORM, and get it to do the ID generation, and unique checking for you."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["You have two problems in this little slice of code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # Assign a ballot ID if one has not been given\nif ballotID is None:\n    ballotID = len(self.ballotIDs)\nassert(ballotID not in self.ballotIDs)\nself.ballotIDs.append(ballotID)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Firstly it appears that self.ballotIDs is a list, so the assert statement will cause quadratic behaviour.", "As you didn't give any documentation at all for your data structures, it's not possible to be prescriptive, but if the order of appearance doesn't matter, you could use a set instead of a list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Secondly, the logic (in the absence of documentation on what a ballotID is all about, and what a not-None ballotID arg means) seems seriously bugged:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n obj.appendBallot(ballota, 2) # self.ballotIDs -&gt; [2]\nobj.appendBallot(ballotb)    # self.ballotIDs -&gt; [2, 1]\nobj.appendBallot(ballotc)    # wants to add 2 but triggers assertion\n</code>\n</pre>\n", "senID": 4}, {"text": ["Other comments:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Instead of adict.has_key(key), use key in adict -- it's faster and looks better."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "adict.has_key(key)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "key in adict", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You may like to consider reviewing your data structures ... they appear to be slightly baroque; there may be a fair bit of CPU time involved in building them."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]]