[[{"text": ["Unfortunately, I believe you have to do this by monkey-patching (which, to my opinion, indicates a design defect in the standard library json package).", "E.g., this code:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "json", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import json\nfrom json import encoder\nencoder.FLOAT_REPR = lambda o: format(o, '.2f')\n\nprint json.dumps(23.67)\nprint json.dumps([23.67, 23.97, 23.87])\n</code>\n</pre>\n", "senID": 1}, {"text": ["emits:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 23.67\n[23.67, 23.97, 23.87]\n</code>\n</pre>\n", "senID": 3}, {"text": ["as you desire.", "Obviously, there should be an architected way to override FLOAT_REPR so that EVERY representation of a float is under your control if you wish it to be; but unfortunately that's not how the json package was designed:-(."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "FLOAT_REPR", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "json", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n import simplejson\n\nclass PrettyFloat(float):\n    def __repr__(self):\n        return '%.15g' % self\n\ndef pretty_floats(obj):\n    if isinstance(obj, float):\n        return PrettyFloat(obj)\n    elif isinstance(obj, dict):\n        return dict((k, pretty_floats(v)) for k, v in obj.items())\n    elif isinstance(obj, (list, tuple)):\n        return map(pretty_floats, obj)             \n    return obj\n\nprint simplejson.dumps(pretty_floats([23.67, 23.97, 23.87]))\n</code>\n</pre>\n", "senID": 0}, {"text": ["emits"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n [23.67, 23.97, 23.87]\n</code>\n</pre>\n", "senID": 2}, {"text": ["No monkeypatching necessary."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you're stuck with Python 2.5 or earlier versions: The monkey-patch trick does not seem to work with the original simplejson module if the C speedups are installed:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ python\nPython 2.5.4 (r254:67916, Jan 20 2009, 11:06:13) \n[GCC 4.2.1 (SUSE Linux)] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import simplejson\n&gt;&gt;&gt; simplejson.__version__\n'2.0.9'\n&gt;&gt;&gt; simplejson._speedups\n&lt;module 'simplejson._speedups' from '/home/carlos/.python-eggs/simplejson-2.0.9-py2.5-linux-i686.egg-tmp/simplejson/_speedups.so'&gt;\n&gt;&gt;&gt; simplejson.encoder.FLOAT_REPR = lambda f: (\"%.2f\" % f)\n&gt;&gt;&gt; simplejson.dumps([23.67, 23.97, 23.87])\n'[23.670000000000002, 23.969999999999999, 23.870000000000001]'\n&gt;&gt;&gt; simplejson.encoder.c_make_encoder = None\n&gt;&gt;&gt; simplejson.dumps([23.67, 23.97, 23.87])\n'[23.67, 23.97, 23.87]'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can do what you need to do, but it isn't documented:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import json\n&gt;&gt;&gt; json.encoder.FLOAT_REPR = lambda f: (\"%.2f\" % f)\n&gt;&gt;&gt; json.dumps([23.67, 23.97, 23.87])\n'[23.67, 23.97, 23.87]'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you're using Python 2.7, a simple solution is to simply round your floats explicitly to the desired precision."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sys.version\n'2.7.1 (r271:86832, Nov 27 2010, 18:30:46) [MSC v.1500 32 bit (Intel)]'\n&gt;&gt;&gt; json.dumps(1.0/3.0)\n'0.3333333333333333'\n&gt;&gt;&gt; json.dumps(round(1.0/3.0, 2))\n'0.33'\n</code>\n</pre>\n", "senID": 1}, {"text": ["This works because Python 2.7 made float rounding more consistent.", "Unfortunately this does not work in Python 2.6: "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "float rounding more consistent", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/whatsnew/2.7.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sys.version\n'2.6.6 (r266:84292, Dec 27 2010, 00:02:40) \\n[GCC 4.4.5]'\n&gt;&gt;&gt; json.dumps(round(1.0/3.0, 2))\n'0.33000000000000002'\n</code>\n</pre>\n", "senID": 3}, {"text": ["The solutions mentioned above are workarounds for 2.6, but none are entirely adequate.", "Monkey patching json.encoder.FLOAT_REPR does not work if your Python runtime uses a C version of the JSON module.", "The PrettyFloat class in Tom Wuttke's answer works, but only if %g encoding works globally for your application.", "The %.15g is a bit magic, it works because float precision is 17 significant digits and %g does not print trailing zeroes."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I spent some time trying to make a PrettyFloat that allowed customization of precision for each number.", "Ie, a syntax like"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; json.dumps(PrettyFloat(1.0 / 3.0, 4))\n'0.3333'\n</code>\n</pre>\n", "senID": 6}, {"text": ["It's not easy to get this right.", "Inheriting from float is awkward.", "Inheriting from Object and using a JSONEncoder subclass with its own default() method should work, except the json module seems to assume all custom types should be serialized as strings.", "Ie: you end up with the Javascript string \"0.33\" in the output, not the number 0.33.", "There may be a way yet to make this work, but it's harder than it looks."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Alex Martelli's solution will work for single threaded apps, but may not work for multi-threaded apps that need to control the number of decimal places per thread.", "Here is a solution that should work in multi threaded apps:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import threading\nfrom json import encoder\n\ndef FLOAT_REPR(f):\n    \"\"\"\n    Serialize a float to a string, with a given number of digits\n    \"\"\"\n    decimal_places = getattr(encoder.thread_local, 'decimal_places', 0)\n    format_str = '%%.%df' % decimal_places\n    return format_str % f\n\nencoder.thread_local = threading.local()\nencoder.FLOAT_REPR = FLOAT_REPR     \n\n#As an example, call like this:\nimport json\n\nencoder.thread_local.decimal_places = 1\njson.dumps([1.56, 1.54]) #Should result in '[1.6, 1.5]'\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can merely set encoder.thread_local.decimal_places to the number of decimal places you want, and the next call to json.dumps() in that thread will use that number of decimal places"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you need to do this without overriding the global json.encoder.FLOAT_REPR, here's one way.", "This works with python 2.6, using pure python implementation of json module."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MyEncoder(json.JSONEncoder):\n    \"\"\"\n    JSON encoder.\n\n    Notes:\n      - _iterecode and _iterencode_dict are lame overrides to allow for\n        float formatting override. Poor design in STL...\n        http://stackoverflow.com/questions/1447287/\n    \"\"\"\n\n    FLOAT_FRMT = '{0:.2f}'\n\n    def floatstr(self, obj):\n        return self.FLOAT_FRMT.format(obj)\n\n    def _iterencode(self, obj, markers=None):\n        # stl JSON lame override #1\n        new_obj = obj\n        if isinstance(obj, float):\n            if not math.isnan(obj) and not math.isinf(obj):\n                new_obj = self.floatstr(obj)\n        return super(MyEncoder, self)._iterencode(new_obj, markers=markers)\n\n    def _iterencode_dict(self, dct, markers=None):\n        # stl JSON lame override #2\n        new_dct = {}\n        for key, value in dct.iteritems():\n            if isinstance(key, float):\n                if not math.isnan(key) and not math.isinf(key):\n                    key = self.floatstr(key)\n            new_dct[key] = value\n        return super(MyEncoder, self)._iterencode_dict(new_dct, markers=markers)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import MyEncoder\n&gt;&gt;&gt; enc = MyEncoder()  \n&gt;&gt;&gt; enc.encode([23.67, 23.97, 23.87])\n'[\"23.67\", \"23.97\", \"23.87\"]'\n</code>\n</pre>\n", "senID": 3}]]