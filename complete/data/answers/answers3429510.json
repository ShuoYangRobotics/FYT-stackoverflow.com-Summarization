[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import count, groupby\n&gt;&gt;&gt; L=[1, 2, 3, 4, 6, 7, 8, 9, 12, 13, 19, 20, 22, 23, 40, 44]\n&gt;&gt;&gt; G=(list(x) for _,x in groupby(L, lambda x,c=count(): next(c)-x))\n&gt;&gt;&gt; print \",\".join(\"-\".join(map(str,(g[0],g[-1])[:len(g)])) for g in G)\n1-4,6-9,12-13,19-20,22-23,40,44\n</code>\n</pre>\n", "senID": 0}, {"text": ["The idea here is to pair each element with count().", "Then the difference between the value and count() is constant for consecutive values.", "groupby() does the rest of the work"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As Jeff suggests, an alternative to count() is to use enumerate().", "This adds some extra cruft that needs to be stripped out in the print statement"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "count()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "enumerate()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n G=(list(x) for _,x in groupby(enumerate(L), lambda (i,x):i-x))\nprint \",\".join(\"-\".join(map(str,(g[0][1],g[-1][1])[:len(g)])) for g in G)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Update: for the sample list given here, the version with enumerate runs about 5% slower than the version using count() on my computer"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Whether this is pythonic is up for debate.", "But it is very compact.", "The real meat is in the Rangify() function.", "There's still room for improvement if you want efficiency or Pythonism."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Rangify()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n def CreateRangeString(zones):\n    #assuming sorted and distinct\n    deltas = [a-b for a, b in zip(zones[1:], zones[:-1])]\n    deltas.append(-1)\n    def Rangify((b, p), (z, d)):\n        if p is not None:\n            if d == 1: return (b, p)\n            b.append('%d-%d'%(p,z))\n            return (b, None)\n        else:\n            if d == 1: return (b, z)\n            b.append(str(z))\n            return (b, None)\n    return ','.join(reduce(Rangify, zip(zones, deltas), ([], None))[0])\n</code>\n</pre>\n", "senID": 1}, {"text": ["To describe the parameters:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["deltas"], "childNum": 0, "tag": "code", "senID": 3, "childList": []}, {"text": ["Rangify()"], "childNum": 0, "tag": "code", "senID": 4, "childList": []}]}], [{"text": ["To concatenate strings you should use ','.join.", "This removes the 2nd loop. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "','.join", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def createRangeString(zones):\n        rangeIdx = 0\n        ranges   = [[zones[0], zones[0]]]\n        for zone in list(zones):\n            if ranges[rangeIdx][1] in (zone, zone-1):\n                ranges[rangeIdx][1] = zone\n            else:\n                ranges.append([zone, zone])\n                rangeIdx += 1\n\n       return ','.join(\n                map(\n                  lambda p: '%s-%s'%tuple(p) if p[0] != p[1] else str(p[0]),\n                  ranges\n                )\n              )\n</code>\n</pre>\n", "senID": 1}, {"text": ["Although I prefer a more generic approach:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from itertools import groupby\n\n# auxiliary functor to allow groupby to compare by adjacent elements.\nclass cmp_to_groupby_key(object):\n  def __init__(self, f):\n    self.f = f\n    self.uninitialized = True\n  def __call__(self, newv):\n    if self.uninitialized or not self.f(self.oldv, newv):\n      self.curkey = newv\n      self.uninitialized = False\n    self.oldv = newv\n    return self.curkey\n\n# returns the first and last element of an iterable with O(1) memory.\ndef first_and_last(iterable):\n  first = next(iterable)\n  last = first\n  for i in iterable:\n    last = i\n  return (first, last)\n\n# convert groups into list of range strings\ndef create_range_string_from_groups(groups):\n  for _, g in groups:\n    first, last = first_and_last(g)\n    if first != last:\n      yield \"{0}-{1}\".format(first, last)\n    else:\n      yield str(first)\n\ndef create_range_string(zones):\n  groups = groupby(zones, cmp_to_groupby_key(lambda a,b: b-a&lt;=1))\n  return ','.join(create_range_string_from_groups(groups))\n\nassert create_range_string([0,1,2,3]) == '0-3'\nassert create_range_string([0, 1, 2, 4, 8]) == '0-2,4,8'\nassert create_range_string([1,2,3,4,6,7,8,9,12,13,19,20,22,22,22,23,40,44]) == '1-4,6-9,12-13,19-20,22-23,40,44'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This is more verbose, mainly because I have used generic functions that I have and that are minor variations of itertools functions and recipes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import tee, izip_longest\ndef pairwise_longest(iterable):\n    \"variation of pairwise in http://docs.python.org/library/itertools.html#recipes\"\n    a, b = tee(iterable)\n    next(b, None)\n    return izip_longest(a, b)\n\ndef takeuntil(predicate, iterable):\n    \"\"\"returns all elements before and including the one for which the predicate is true\n    variation of http://docs.python.org/library/itertools.html#itertools.takewhile\"\"\"\n    for x in iterable:\n        yield x\n        if predicate(x):\n            break\n\ndef get_range(it):\n    \"gets a range from a pairwise iterator\"\n    rng = list(takeuntil(lambda (a,b): (b is None) or (b-a&gt;1), it))\n    if rng:\n        b, e = rng[0][0], rng[-1][0]\n        return \"%d-%d\" % (b,e) if b != e else \"%d\" % b\n\ndef create_ranges(zones):\n    it = pairwise_longest(zones)\n    return \",\".join(iter(lambda:get_range(it),None))\n\nk=[0,1,2,4,5,7,9,12,13,14,15]\nprint create_ranges(k) #0-2,4-5,7,9,12-15\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is my solution.", "You need to keep track of various pieces of information while you iterate through the list and create the result - this screams generator to me.", "So here goes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def rangeStr(start, end):\n    '''convert two integers into a range start-end, or a single value if they are the same''' \n    return str(start) if start == end else \"%s-%s\" %(start, end)\n\ndef makeRange(seq):\n    '''take a sequence of ints and return a sequence\n    of strings with the ranges\n    '''\n    # make sure that seq is an iterator\n    seq = iter(seq)\n    start = seq.next()\n    current = start\n    for val in seq:\n        current += 1\n        if val != current:\n            yield rangeStr(start, current-1)\n            start = current = val\n    # make sure the last range is included in the output\n    yield rangeStr(start, current)\n\ndef stringifyRanges(seq):\n    return ','.join(makeRange(seq))\n\n&gt;&gt;&gt; l = [1,2,3, 7,8,9, 11, 20,21,22,23]\n&gt;&gt;&gt; l2 = [1,2,3, 7,8,9, 11, 20,21,22,23, 30]\n&gt;&gt;&gt; stringifyRanges(l)\n'1-3,7-9,11,20-23'\n&gt;&gt;&gt; stringifyRanges(l2)\n'1-3,7-9,11,20-23,30'\n</code>\n</pre>\n", "senID": 1}, {"text": ["My version will work correctly if given an empty list, which I think some of the others will not.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; stringifyRanges( [] )\n''\n</code>\n</pre>\n", "senID": 3}, {"text": ["makeRanges will work on any iterator that returns integers and lazily returns a sequence of strings so can be used on infinite sequences."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["edit: I have updated the code to handle single numbers that are not part of a range."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["edit2: refactored out rangeStr to remove duplication."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "edit2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n def createRangeString(zones):\n    \"\"\"Create a string with integer ranges in the format of '%d-%d'\n    &gt;&gt;&gt; createRangeString([0, 1, 2, 4, 8])\n    \"0-2,4,8\"\n    &gt;&gt;&gt; createRangeString([1,2,3,4,6,7,8,9,12,13,19,20,22,22,22,23,40,44])\n    \"1-4,6-9,12-13,19-20,22-23,40,44\"\n    \"\"\"\n    buffer = []\n\n    try:\n        st = ed = zones[0]\n        for i in zones[1:]:\n            delta = i - ed\n            if delta == 1: ed = i\n            elif not (delta == 0):\n                buffer.append((st, ed))\n                st = ed = i\n        else: buffer.append((st, ed))\n    except IndexError:\n        pass\n\n    return ','.join(\n            \"%d\" % st if st==ed else \"%d-%d\" % (st, ed)\n            for st, ed in buffer)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["how  about this mess..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def rangefy(mylist):\n    mylist, mystr, start = mylist + [None], \"\", 0\n    for i, v in enumerate(mylist[:-1]):\n            if mylist[i+1] != v + 1:\n                    mystr += [\"%d,\"%v,\"%d-%d,\"%(start,v)][start!=v]\n                    start = mylist[i+1]\n    return mystr[:-1]\n</code>\n</pre>\n", "senID": 1}]]