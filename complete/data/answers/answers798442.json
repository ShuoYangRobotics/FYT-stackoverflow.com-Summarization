[[{"text": ["My favorite way to wrap methods of a built-in collection:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Fooset(set):\n    def __init__(self, s=(), foo=None):\n        super(Fooset,self).__init__(s)\n        if foo is None and hasattr(s, 'foo'):\n            foo = s.foo\n        self.foo = foo\n\n\n\n    @classmethod\n    def _wrap_methods(cls, names):\n        def wrap_method_closure(name):\n            def inner(self, *args):\n                result = getattr(super(cls, self), name)(*args)\n                if isinstance(result, set) and not hasattr(result, 'foo'):\n                    result = cls(result, foo=self.foo)\n                return result\n            inner.fn_name = name\n            setattr(cls, name, inner)\n        for name in names:\n            wrap_method_closure(name)\n\nFooset._wrap_methods(['__ror__', 'difference_update', '__isub__', \n    'symmetric_difference', '__rsub__', '__and__', '__rand__', 'intersection',\n    'difference', '__iand__', 'union', '__ixor__', \n    'symmetric_difference_update', '__or__', 'copy', '__rxor__',\n    'intersection_update', '__xor__', '__ior__', '__sub__',\n])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Essentially the same thing you're doing in your own answer, but with fewer loc.", "It's also easy to put in a metaclass if you want to do the same thing with lists and dicts as well."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It looks like set bypasses __init__ in the c code.", "However you will end an instance of Fooset, it just won't have had a chance to copy the field."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "c code", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Objects/setobject.c?view=markup"}, {"text": "Fooset", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Apart from overriding the methods that return new sets I'm not sure you can do too much in this case.", "Set is clearly built for a certain amount of speed, so does a lot of work in c."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["set1 | set2 is an operation that won't modify either existing set, but return a new set instead.", "The new set is created and returned.", "There is no way to make it automatically copy arbritary attributes from one or both of the sets to the newly created set, without customizing the | operator yourself by defining the__or__method."], "childNum": 9, "tag": "p", "senID": 0, "childList": [{"text": "set1 | set2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}, {"text": "|", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/reference/datamodel.html#object.%5F%5For%5F%5F", "text": "defining the__or__method", "childNum": 1, "tag": "a", "childList": [{"text": "__or__", "tag": "code"}]}, {"text": "__or__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class MySet(set):\n    def __init__(self, *args, **kwds):\n        super(MySet, self).__init__(*args, **kwds)\n        self.foo = 'nothing'\n    def __or__(self, other):\n        result = super(MySet, self).__or__(other)\n        result.foo = self.foo + \"|\" + other.foo\n        return result\n\nr = MySet('abc')\nr.foo = 'bar'\ns = MySet('cde')\ns.foo = 'baz'\n\nt = r | s\n\nprint r, s, t\nprint r.foo, s.foo, t.foo\n</code>\n</pre>\n", "senID": 1}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n MySet(['a', 'c', 'b']) MySet(['c', 'e', 'd']) MySet(['a', 'c', 'b', 'e', 'd'])\nbar baz bar|baz\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Assuming the other answers are correct, and overriding all the methods is the only way to do this, here's my attempt at a moderately elegant way of doing this.", "If more instance variables are added, only one piece of code needs to change.", "Unfortunately if a new binary operator is added to the set object, this code will break, but I don't think there's a way to avoid that.", "Comments welcome!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foocopy(f):\n\tdef cf(self, new):\n\t\tr = f(self, new)\n\t\tr.foo = self.foo\n\t\treturn r\n\treturn cf\n\nclass Fooset(set):\n\tdef __init__(self, s = []):\n\t\tset.__init__(self, s)\n\t\tif isinstance(s, Fooset):\n\t\t\tself.foo = s.foo\n\t\telse:\n\t\t\tself.foo = 'default'\n\n\tdef copy(self):\n\t\tx = set.copy(self)\n\t\tx.foo = self.foo\n\t\treturn x\n\n\t@foocopy\n\tdef __and__(self, x):\n\t\treturn set.__and__(self, x)\n\n\t@foocopy\n\tdef __or__(self, x):\n\t\treturn set.__or__(self, x)\n\n\t@foocopy\n\tdef __rand__(self, x):\n\t\treturn set.__rand__(self, x)\n\n\t@foocopy\n\tdef __ror__(self, x):\n\t\treturn set.__ror__(self, x)\n\n\t@foocopy\n\tdef __rsub__(self, x):\n\t\treturn set.__rsub__(self, x)\n\n\t@foocopy\n\tdef __rxor__(self, x):\n\t\treturn set.__rxor__(self, x)\n\n\t@foocopy\n\tdef __sub__(self, x):\n\t\treturn set.__sub__(self, x)\n\n\t@foocopy\n\tdef __xor__(self, x):\n\t\treturn set.__xor__(self, x)\n\n\t@foocopy\n\tdef difference(self, x):\n\t\treturn set.difference(self, x)\n\n\t@foocopy\n\tdef intersection(self, x):\n\t\treturn set.intersection(self, x)\n\n\t@foocopy\n\tdef symmetric_difference(self, x):\n\t\treturn set.symmetric_difference(self, x)\n\n\t@foocopy\n\tdef union(self, x):\n\t\treturn set.union(self, x)\n\n\nf = Fooset([1,2,4])\nf.foo = 'bar'\nassert( (f | f).foo == 'bar')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think that the recommended way to do this is not to subclass directly from the built-in set, but rather to make use of the Abstract Base ClassSet available in collections."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/collections.html#collections.Set", "text": "Abstract Base ClassSet", "childNum": 1, "tag": "a", "childList": [{"text": "Set", "tag": "code"}]}, {"text": "Set", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/collections.html#abcs-abstract-base-classes", "text": "collections", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Using the ABC Set gives you some methods for free as a mix-in so you can have a minimal Set class by defining only __contains__(), __len__() and __iter__().", "If you want some of the nicer set methods like intersection() and difference(), you probably do have to wrap them."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "__contains__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__len__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__iter__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "intersection()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "difference()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Here's my attempt (this one happens to be a frozenset-like, but you can inherit from MutableSet to get a mutable version):"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "MutableSet", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from collections import Set, Hashable\n\nclass CustomSet(Set, Hashable):\n    \"\"\"An example of a custom frozenset-like object using\n    Abstract Base Classes.\n    \"\"\"\n    ___hash__ = Set._hash\n\n    wrapped_methods = ('difference',\n                       'intersection',\n                       'symetric_difference',\n                       'union',\n                       'copy')\n\n    def __repr__(self):\n        return \"CustomSet({0})\".format(list(self._set))\n\n    def __new__(cls, iterable):\n        selfobj = super(CustomSet, cls).__new__(CustomSet)\n        selfobj._set = frozenset(iterable)\n        for method_name in cls.wrapped_methods:\n            setattr(selfobj, method_name, cls._wrap_method(method_name, selfobj))\n        return selfobj\n\n    @classmethod\n    def _wrap_method(cls, method_name, obj):\n        def method(*args, **kwargs):\n            result = getattr(obj._set, method_name)(*args, **kwargs)\n            return CustomSet(result)\n        return method\n\n    def __getattr__(self, attr):\n        \"\"\"Make sure that we get things like issuperset() that aren't provided\n        by the mix-in, but don't need to return a new set.\"\"\"\n        return getattr(self._set, attr)\n\n    def __contains__(self, item):\n        return item in self._set\n\n    def __len__(self):\n        return len(self._set)\n\n    def __iter__(self):\n        return iter(self._set)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["For me this works perfectly using Python 2.5.2 on Win32.", "Using you class definition and the following test:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f = Fooset([1,2,4])\ns = sets.Set((5,6,7))\nprint f, f.foo\nf.foo = 'bar'\nprint f, f.foo\ng = f | s\nprint g, g.foo\nassert( (f | f).foo == 'bar')\n</code>\n</pre>\n", "senID": 1}, {"text": ["I get this output, which is what I expect:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Fooset([1, 2, 4]) default\nFooset([1, 2, 4]) bar\nFooset([1, 2, 4, 5, 6, 7]) bar\n</code>\n</pre>\n", "senID": 3}]]