[[{"text": ["Don't.", "I agree with Andreys comment on the previous question that is doesn't make sense to have dictionaries as keys, and especially not nested ones.", "Your data-model is obviously quite complex, and dictionaries are probably not the right answer.", "You should try some OO instead."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["With recursion!"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "recursion", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1611797/using-nested-python-dictionaries-as-keys/1611814#1611814"}]}, {"code": "<pre>\n<code>\n def make_hashable(h):\n    items = h.items()\n    for item in items:\n        if type(items) == dict:\n            item = make_hashable(item)\n    return frozenset(items)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can add other type tests for any other mutable types you want to make hashable.", "It shouldn't be hard."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Based off solution by Chris Lutz.", "Note that this doesn't handle objects that are changed by iteration, such as streams, nor does it handle cycles."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import collections\n\ndef make_hashable(obj):\n    \"\"\"WARNING: This function only works on a limited subset of objects\n    Make a range of objects hashable. \n    Accepts embedded dictionaries, lists or tuples (including namedtuples)\"\"\"\n    if isinstance(obj, collections.Hashable):\n        #Fine to be hashed without any changes\n        return obj\n    elif isinstance(obj, collections.Mapping):\n        #Convert into a frozenset instead\n        items=list(obj.items())\n        for i, item in enumerate(items):\n                items[i]=make_hashable(item)\n        return frozenset(items)\n    elif isinstance(obj, collections.Iterable):\n        #Convert into a tuple instead\n        ret=[type(obj)]\n        for i, item in enumerate(obj):\n                ret.append(make_hashable(item))\n        return tuple(ret)\n    #Use the id of the object\n    return id(obj)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you really must, make your objects hashable.", "Subclass whatever you want to put in as a key, and provide a __hash__ function which returns an unique key to this object. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To illustrate:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; (\"a\",).__hash__()\n986073539\n&gt;&gt;&gt; {'a': 'b'}.__hash__()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'NoneType' object is not callable\n</code>\n</pre>\n", "senID": 2}, {"text": ["If your hash is not unique enough you will get collisions.", "May be slow as well."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I totally disagree with comments &amp; answers saying that this shouldn't be done for data model purity reason."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A dictionary associates an object with another object using the former one as a key.", "Dictionaries can't be used as keys because they're not hashable.", "This doesn't make any less meaningful/practical/necessary to map dictionaries to other objects."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As I understand the Python binding system, you can bind any dictionary to a number of variables (or the reverse, depends on your terminology) which means that these variables all know the same unique 'pointer' to that dictionary.", "Wouldn't it be possible to use that identifier as the hashing key ?", "If your data model ensures/enforces that you can't have two dictionaries with the same content used as keys then that seems to be a safe technique to me."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I should add that I have no idea whatsoever of how that can/should be done though."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I'm not entirely whether this should be an answer or a comment.", "Please correct me if needed."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I encountered this issue when using a decorator that caches the results of previous calls based on call signature.", "I do not agree with the comments/answers here to the effect of \"you should not do this\", but I think it is important to recognize the potential for surprising and unexpected behavior when going down this path.", "My thought is that since instances are both mutable and hashable, and it does not seem practical to change that, there is nothing inherently wrong with creating hashable equivalents of non-hashable types or objects.", "But of course that is only my opinion."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For anyone who requires Python 2.5 compatibility, the below may be useful.", "I based it on the earlier answer."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from itertools import imap\ntuplemap = lambda f, data: tuple(imap(f, data))\ndef make_hashable(obj):\n  u\"Returns a deep, non-destructive conversion of given object to an equivalent hashable object\"\n  if isinstance(obj, list):\n    return tuplemap(make_hashable, iter(obj))\n  elif isinstance(obj, dict):\n    return frozenset(tuplemap(make_hashable, obj.iteritems()))\n  elif hasattr(obj, '__hash__') and callable(obj.__hash__):\n    try:\n      obj.__hash__()\n    except:\n      if hasattr(obj, '__iter__') and callable(obj.__iter__):\n        return tuplemap(make_hashable, iter(obj))\n      else:\n        raise NotImplementedError, 'object of type %s cannot be made hashable' % (type(obj),)\n    else:\n      return obj\n  elif hasattr(obj, '__iter__') and callable(obj.__iter__):\n    return tuplemap(make_hashable, iter(obj))\n  else:\n    raise NotImplementedError, 'object of type %s cannot be made hashable' % (type, obj)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Based off solution by Chris Lutz again. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import collections\n\ndef hashable(obj):\n    if isinstance(obj, collections.Hashable):\n        return obj\n    if isinstance(obj, collections.Mapping):\n        items = [(k,hashable(v)) for (k,v) in obj.items()]\n        return frozenset(items)\n    if isinstance(obj, collections.Iterable):\n        return tuple([hashable(item) for item in obj])\n    return TypeError(type(obj))\n</code>\n</pre>\n", "senID": 1}]]