[[{"text": ["Just to clarify: the code in the body of a module is not executed every time the module is imported - it is run only once, after which future imports find the already created module, rather than recreating it.", "Take a look at sys.modules to see the list of cached modules."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["However, if your problem is the time it takes for the first import after the program is run, you'll probably need to use some other method than a python dict.", "Probably best would be to use an on-disk form, for instance a sqlite database, one of the dbm modules."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For a minimal change in your interface, the shelve module may be your best option - this puts a pretty transparent interface between the dbm modules that makes them act like an arbitrary python dict, allowing any picklable value to be stored.", "Here's an example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # Create dict with a million items:\nimport shelve\nd = shelve.open('path/to/my_persistant_dict')\nd.update(('key%d' % x, x) for x in xrange(1000000))\nd.close()\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then in the next process, use it.", "There should be no large delay, as lookups are only performed for the key requested on the on-disk form, so everything doesn't have to get loaded into memory:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d = shelve.open('path/to/my_persistant_dict')\n&gt;&gt;&gt; print d['key99999']\n99999\n</code>\n</pre>\n", "senID": 5}, {"text": ["It's a bit slower than a real dict, and it will still take a long time to load if you do something that requires all the keys (eg.", "try to print it), but may solve your problem."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "will", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Calculate your global var on the first use."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Proxy:\n    @property\n    def global_name(self):\n        # calculate your global var here, enable cache if needed\n        ...\n\n_proxy_object = Proxy()\nGLOBAL_NAME = _proxy_object.global_name\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or better yet, access necessery data via special data object."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Data:\n    GLOBAL_NAME = property(...)\n\ndata = Data()\n</code>\n</pre>\n", "senID": 3}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from some_module import data\n\nprint(data.GLOBAL_NAME)\n</code>\n</pre>\n", "senID": 5}, {"text": ["See Django settings."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Django settings", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev/topics/settings/"}]}], [{"text": ["I assume you've pasted the dict literal into the source, and that's what's taking a minute?", "I don't know how to get around that, but you could probably avoid instantiating this dict upon import... You could lazily-instantiate it the first time it's actually used."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "import", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["You could try using the marshal module instead of the c?Pickle one; it could be faster.", "This module is used by python to store values in a binary format.", "Note especially the following paragraph, to see if marshal fits your needs:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "marshal", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/All_You_Zombies%E2%80%94"}]}, {"text": ["Just to be on the safe side, before unmarshalling the dict, make sure that the Python version that unmarshals the dict is the same as the one that did the marshal, since there are no guarantees for backwards compatibility."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If the 'shelve' solution turns out to be too slow or fiddly, there are other possibilities:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": ["shove"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["Durus"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}, {"text": ["ZopeDB"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}, {"text": ["pyTables"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}]}], [{"text": ["shelve gets really slow with large data sets.", "I've been using redis quite successfully, and wrote a FreqDist wrapper around it.", "It's very fast, and can be accessed concurrently."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "shelve", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "redis", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://streamhacker.com/2009/05/20/building-a-nltk-freqdist-on-redis/"}, {"text": "FreqDist wrapper", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://bitbucket.org/japerk/nltk-extras/src/tip/probability.py"}]}], [{"text": ["You can use a shelve to store your data on disc instead of loading the whole data into memory.", "So startup time will be very fast, but the trade-off will be slower access time. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "shelve", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-shelve.html"}]}, {"text": ["Shelve will pickle the dict values too, but will do the (un)pickle not at startup for all the items, but only at access time for each item itself."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["A couple of things that will help speed up imports:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["With that said, I agree that you shouldn't be experiencing any delay in importing modules after the first time you import it.", "Here are a couple of other general thoughts:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["With that said, it's a tad bit difficult to give you any specific advice without a little bit more context.", "More specifically, where are you importing it?", "And what are the computations?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [], [{"text": ["Expanding on the delayed-calculation idea, why not turn the dict into a class that supplies (and caches) elements as necessary?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You might also use psyco to speed up overall execution..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["OR you could just use a database for storing the values in?", "Check out SQLObject, which makes it very easy to store stuff to a database."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "OR", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["There's another pretty obvious solution for this problem.", "When code is reloaded the original scope is still available."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So... doing something like this will make sure this code is executed only once."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n try:\n    FD\nexcept NameError:\n    FD = FreqDist(word for word in brown.words())\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I'm going through this same issue... \nshelve, databases, etc... are all too slow for this type of problem.", "You'll need to take the hit once, insert it into an inmemory key/val store like Redis.", "It will just live there in memory (warning it could use up a good amount of memory so you may want a dedicated box).", "You'll never have to reload it and you'll just get looking in memory for keys"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n r = Redis()\nr.set(key, word)\n\nword = r.get(key)\n</code>\n</pre>\n", "senID": 1}]]