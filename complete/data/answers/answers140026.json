[[{"text": ["Building a DSL to be interpreted by Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Step 1.", "Build the run-time classes and objects.", "These classes will have all the cursor loops and SQL statements and all of that algorithmic processing tucked away in their methods.", "You'll make heavy use of the Command and Strategy design patterns to build these classes.", "Most things are a command, options and choices are plug-in strategies.", "Look at the design for Apache Ant's Task API -- it's a good example."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "Command", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://exciton.cs.rice.edu/javaresources/DesignPatterns/command.htm"}, {"text": "Strategy", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://exciton.cs.rice.edu/javaresources/DesignPatterns/StrategyPattern.htm"}, {"text": "Task", "tag": "a", "pos": 5, "childList": [], "childNum": 0, "href": "http://ant.apache.org/manual/develop.html"}]}, {"text": ["Step 2.", "Validate that this system of objects actually works.", "Be sure that the design is simple and complete.", "You're tests will construct the Command and Strategy objects, and then execute the top-level Command object.", "The Command objects will do the work. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["At this point you're largely done.", "Your run-time is just a configuration of objects created from the above domain.", "[This isn't as easy as it sounds.", "It requires some care to define a set of classes that can be instantiated and then \"talk among themselves\" to do the work of your application."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Note that what you'll have will require nothing more than declarations.", "What's wrong with procedural?", "One you start to write a DSL with procedural elements, you find that you need more and more features until you've written Python with different syntax.", "Not good."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Further, procedural language interpreters are simply hard to write.", "State of execution, and scope of references are simply hard to manage."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["You can use native Python -- and stop worrying about \"getting out of the sandbox\".", "Indeed, that's how you'll unit test everything, using a short Python script to create your objects.", "Python will be the DSL.  "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["[\"But wait\", you say, \"If I simply use Python as the DSL people can execute arbitrary things.", "\"  Depends on what's on the PYTHONPATH, and sys.path.", "Look at the site module for ways to control what's available."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "site", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-site.html"}]}, {"text": ["A declarative DSL is simplest.", "It's entirely an exercise in representation.", "A block of Python that merely sets the values of some variables is nice.", "That's what Django uses."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["You can use the ConfigParser as a language for representing your run-time configuration of objects."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "ConfigParser", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-ConfigParser.html"}]}, {"text": ["You can use JSON or YAML as a language for representing your run-time configuration of objects.", "Ready-made parsers are totally available."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "JSON", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/python-json/"}, {"text": "YAML", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://pyyaml.org/"}]}, {"text": ["You can use XML, too.", "It's harder to design and parse, but it works fine.", "People love it.", "That's how Ant and Maven (and lots of other tools) use declarative syntax to describe procedures.", "I don't recommend it, because it's a wordy pain in the neck.", "I recommend simply using Python."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Or, you can go off the deep-end and invent your own syntax and write your own parser."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["I think we're going to need a bit more information here.", "Let me know if any of the following is based on incorrect assumptions."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First of all, as you pointed out yourself, there already exists a DSL for selecting rows from arbitrary tables-- it is called \"SQL\".", "Since you don't want to reinvent SQL, I'm assuming that you only need to query from a single table with a fixed format."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If this is the case, you probably don't need to implement a DSL (although that's certainly one way to go); it may be easier, if you are used to Object Orientation, to create a Filter object.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["More specifically, a \"Filter\" collection that would hold one or more SelectionCriterion objects.", "You can implement these to inherit from one or more base classes representing types of selections (Range, LessThan, ExactMatch, Like, etc.", ") Once these base classes are in place, you can create column-specific inherited versions which are appropriate to that column.", "Finally, depending on the complexity of the queries you want to support, you'll want to implement some kind of connective glue to handle AND and OR and NOT linkages between the various criteria."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If you feel like it, you can create a simple GUI to load up the collection; I'd look at the filtering in Excel as a model, if you don't have anything else in mind."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Finally, it should be trivial to convert the contents of this Collection to the corresponding SQL, and pass that to the database."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["However: if what you are after is simplicity, and your users understand SQL, you could simply ask them to type in the contents of a WHERE clause, and programmatically build up the rest of the query.", "From a security perspective, if your code has control over the columns selected and the FROM clause, and your database permissions are set properly, and you do some sanity checking on the string coming in from the users, this would be a relatively safe option."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["\"implement a Domain Specific Language\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\"nobody is going to want to install a server that downloads and executes arbitrary Python code at runtime\""], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I want a DSL but I don't want Python to be that DSL.", "Okay.", "How will you execute this DSL?", "What runtime is acceptable if not Python?"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "is", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["What if I have a C program that happens to embed the Python interpreter?", "Is that acceptable?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["And -- if Python is not an acceptable runtime -- why does this have a Python tag?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Why not create a language that when it \"compiles\" it generates SQL or whatever query language your datastore requires ?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You would be basically creating an abstraction over your persistence layer.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You mentioned Python.", "Why not use Python?", "If someone can \"type in\" an expression in your DSL, they can type in Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You'll need some rules on structure of the expression, but that's a lot easier than implementing something new."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You said nobody is going to want to install a server that downloads and executes arbitrary code at runtime.", "However, that is exactly what your DSL will do (eventually) so there probably isn't that much of a difference.", "Unless you're doing something very specific with the data then I don't think a DSL will buy you that much and it will frustrate the users who are already versed in SQL.", "Don't underestimate the size of the task you'll be taking on."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To answer your question however, you will need to come up with a grammar for your language, something to parse the text and walk the tree, emitting code or calling an API that you've written (which is why my comment that you're still going to have to ship some code).  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There are plenty of educational texts on grammars for mathematical expressions you can refer to on the net, that's fairly straight forward.", "You may have a parser generator tool like ANTLR or Yacc you can use to help you generate the parser (or use a language like Lisp/Scheme and marry the two up).", "Coming up with a reasonable SQL grammar won't be easy.", "But google 'BNF SQL' and see what you come up with."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Best of luck."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["It really sounds like SQL, but perhaps it's worth to try using SQLite if you want to keep it simple?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["It sounds like you want to create a grammar not a DSL.", "I'd look into ANTLR which will allow you to create a specific parser that will interpret text and translate to specific commands.", "ANTLR provides libraries for Python, SQL, Java, C++, C, C# etc."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ANTLR", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://antlr.org/"}]}, {"text": ["Also, here is a fine example of an ANTLR calculation engine created in C#"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "calculation engine", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.codeproject.com/KB/recipes/sota_expression_evaluator.aspx"}]}]]