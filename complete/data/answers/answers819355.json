[[{"text": ["I like to use netaddr for that:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "netaddr", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/netaddr"}]}, {"code": "<pre>\n<code>\n from netaddr import CIDR, IP\n\nif IP(\"192.168.0.1\") in CIDR(\"192.168.0.0/24\"):\n    print \"Yay!\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This article shows you can do it with socket and struct modules without too much extra effort.", "I added a little to the article as follows:"], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "This article", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/66517/"}, {"text": "socket", "tag": "a", "pos": -1, "childList": [{"text": "socket", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/socket.html"}, {"text": "socket", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "struct", "tag": "a", "pos": -1, "childList": [{"text": "struct", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/struct.html"}, {"text": "struct", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import socket,struct\n\ndef makeMask(n):\n    \"return a mask of n bits as a long integer\"\n    return (2L&lt;&lt;n-1) - 1\n\ndef dottedQuadToNum(ip):\n    \"convert decimal dotted quad string to long integer\"\n    return struct.unpack('L',socket.inet_aton(ip))[0]\n\ndef networkMask(ip,bits):\n    \"Convert a network address to a long integer\" \n    return dottedQuadToNum(ip) &amp; makeMask(bits)\n\ndef addressInNetwork(ip,net):\n   \"Is an address in a network\"\n   return ip &amp; net == net\n\naddress = dottedQuadToNum(\"192.168.1.1\")\nnetworka = networkMask(\"10.0.0.0\",24)\nnetworkb = networkMask(\"192.168.0.0\",24)\nprint (address,networka,networkb)\nprint addressInNetwork(address,networka)\nprint addressInNetwork(address,networkb)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This outputs:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n False\nTrue\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you just want a single function that takes strings it would look like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import socket,struct\n\ndef addressInNetwork(ip,net):\n   \"Is an address in a network\"\n   ipaddr = struct.unpack('L',socket.inet_aton(ip))[0]\n   netaddr,bits = net.split('/')\n   netmask = struct.unpack('L',socket.inet_aton(netaddr))[0] &amp; ((2L&lt;&lt;int(bits)-1) - 1)\n   return ipaddr &amp; netmask == netmask\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Using ipaddr (in the Python stdlib since Python2.7/3.1):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ipaddr", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/ipaddr-py/"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from ipaddr import IP\n&gt;&gt;&gt; IP('192.168.0.1') in IP('192.168.0.0/24')\nTrue\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I don't know of anything in the standard library, but PySubnetTree is a Python library that will do subnet matching."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PySubnetTree", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.icir.org/robin/pysubnettree/"}]}], [{"text": ["ipaddr is a nice library as well."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ipaddr", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/ipaddr-py/"}]}], [{"text": ["This code is working for me on Linux x86.", "I haven't really given any thought to endianess issues, but I have tested it against the \"ipaddr\" module using over 200K IP addresses tested against 8 different network strings, and the results of ipaddr are the same as this code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def addressInNetwork(ip, net):\n   import socket,struct\n   ipaddr = int(''.join([ '%02x' % int(x) for x in ip.split('.') ]), 16)\n   netstr, bits = net.split('/')\n   netaddr = int(''.join([ '%02x' % int(x) for x in netstr.split('.') ]), 16)\n   mask = (0xffffffff &lt;&lt; (32 - int(bits))) &amp; 0xffffffff\n   return (ipaddr &amp; mask) == (netaddr &amp; mask)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print addressInNetwork('10.9.8.7', '10.9.1.0/16')\nTrue\n&gt;&gt;&gt; print addressInNetwork('10.9.8.7', '10.9.1.0/24')\nFalse\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Thank you for your script!", "I have work quite a long on it to make everything working...", "So I'm sharing it here"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "Using netaddr Class is 10 times slower than using binary conversion, so if you'd like to use it on a big list of IP, you should consider not using netaddr class", "tag": "none", "senID": 1}, {"text": ["makeMask function is not working!", "Only working for /8,/16,/24 Ex:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}]}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n>>> calcDottedNetmask(21)\n>>> '255.255.248.0'\n</code>\n</pre>\n", "senID": 3}, {"tag": "ul", "num": 1, "lis": [{"text": "Another problem is the process of matching if an IP belongs to a network! Basic Operation should be to compare (ipaddr &amp; netmask) and (network &amp; netmask).", "tag": "none", "senID": 4}]}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n>>> addressInNetwork('188.104.8.64','172.16.0.0/12')\n>>>True which is completely WRONG!!\n</code>\n</pre>\n", "senID": 5}, {"text": ["So my new addressInNetwork function looks-like:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\nimport socket,struct\ndef addressInNetwork(ip,net):\n    '''This function allows you to check if on IP belogs to a Network'''\n    ipaddr = struct.unpack('=L',socket.inet_aton(ip))[0]\n    netaddr,bits = net.split('/')\n    netmask = struct.unpack('=L',socket.inet_aton(calcDottedNetmask(bits)))[0]\n    network = struct.unpack('=L',socket.inet_aton(netaddr))[0] & netmask\n    return (ipaddr & netmask) == (network & netmask)\n\ndef calcDottedNetmask(mask):\n    bits = 0\n    for i in xrange(32-int(mask),32):\n        bits |= (1 > 24, (bits & 0xff0000) >> 16, (bits & 0xff00) >> 8 , (bits & 0xff))\n</code>\n</pre>\n", "senID": 7}, {"text": ["And now, answer is right!"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n>>> addressInNetwork('188.104.8.64','172.16.0.0/12')\nFalse\n</code>\n</pre>\n", "senID": 9}, {"text": ["I hope that it will help other people, saving time for them!"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["Marc's code is nearly correct... A complete version of the code is -"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def addressInNetwork3(ip,net):\n    '''This function allows you to check if on IP belogs to a Network'''\n    ipaddr = struct.unpack('=L',socket.inet_aton(ip))[0]\n    netaddr,bits = net.split('/')\n    netmask = struct.unpack('=L',socket.inet_aton(calcDottedNetmask(int(bits))))[0]\n    network = struct.unpack('=L',socket.inet_aton(netaddr))[0] &amp; netmask\n    return (ipaddr &amp; netmask) == (network &amp; netmask)\n\ndef calcDottedNetmask(mask):\n    bits = 0\n    for i in xrange(32-mask,32):\n        bits |= (1 &lt;&lt; i)\n    return \"%d.%d.%d.%d\" % ((bits &amp; 0xff000000) &gt;&gt; 24, (bits &amp; 0xff0000) &gt;&gt; 16, (bits &amp; 0xff00) &gt;&gt; 8 , (bits &amp; 0xff))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Obviously from the same sources as above..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["A very Important note is that the first code has a small glitch - The IP address 255.255.255.255 also shows up as a Valid IP for any subnet...", "I had a heck of time getting this code to work and thanks to Marc for the correct answer..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; from netaddr import all_matching_cidrs\n&gt;&gt;&gt; all_matching_cidrs(\"212.11.70.34\", [\"192.168.0.0/24\",\"212.11.64.0/19\"] )\n[IPNetwork('212.11.64.0/19')]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Here is the usage for this method:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; help(all_matching_cidrs)\n\nHelp on function all_matching_cidrs in module netaddr.ip:\n\nall_matching_cidrs(ip, cidrs)\n    Matches an IP address or subnet against a given sequence of IP addresses and subnets.\n\n    @param ip: a single IP address or subnet.\n\n    @param cidrs: a sequence of IP addresses and/or subnets.\n\n    @return: all matching IPAddress and/or IPNetwork objects from the provided\n    sequence, an empty list if there was no match.\n</code>\n</pre>\n", "senID": 2}, {"text": ["Basically you provide an ip address as the first argument and a list of cidrs as the second argument.", "A list of hits are returned."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]