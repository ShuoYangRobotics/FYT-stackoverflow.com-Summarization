[[{"code": "<pre>\n<code>\n from itertools import izip_longest\n\nd = { 'a': ['s','b'], 'b': ['x1','y1','z1'] }\n\nprint([i for t in izip_longest(*[d[k] for k in sorted(d)])\n                  for i in t if i is not None])\n</code>\n</pre>\n", "senID": 0}, {"text": ["(N.B.", "izip_longest was renamed to zip_longest in Python 3."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "izip_longest", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "zip_longest", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Explanation:"], "childNum": 0, "tag": "h2", "senID": 2, "childList": []}, {"text": ["izip_longest creates a tuple for the first elements, a tuple for the second elements etc.", "In this case [('s', 'x1'), ('b', 'y1'), (None, 'z1')].", "After that it's simply creating a list while filtering out None."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "izip_longest", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[('s', 'x1'), ('b', 'y1'), (None, 'z1')]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["You need izip_longest here instead of just zip otherwise the result will be [('s', 'x1'), ('b', 'y1')]."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "izip_longest", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "zip", "childNum": 0, "tag": "code", "childList": []}, {"text": "[('s', 'x1'), ('b', 'y1')]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["With intermediate steps:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n sorted_lists = [d[k] for k in sorted(d)]\ntuples = izip_longest(*sorted_lists)\nresult = [i for t in tuples for i in t if i is not None]\nprint(result)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["While Im not stoked about the appending and whatnot, this at least gets your exact result."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n keys = sorted(d.keys())\ntotal = max([len(v) for v in d.values()])\noutput = []\nfor i in xrange(total):\n    for key in keys:\n        try: output.append(d[key][i])\n        except IndexError: pass\n\n&gt;&gt;&gt; output\n['s', 'x1', 'b', 'y1', 'z1']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think what he wants is first print all thefirstelement of different values in dict &amp; then second and so on until minimum of a list is reached.", "Then, he just prints the remaining."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "first print all thefirstelement of different values in dict &amp; then second and so on until minimum of a list is reached.", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "first", "tag": "em"}]}, {"text": "first", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n d={'a':['s','b'],'b':['x1','y1','z1']}\n\nmin = len(d['a']) if (len(d['a']) &lt; len(d['b']) ) else len(d['b'])\n\nfor i in range(0,min):\n    p = d.keys()\n    print d[p[0]][i], d[p[1]][i],\n\nprint d['b'][min:][0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["maybe zip() http://docs.python.org/library/functions.html#zip can help you (I know it's not exactly you want, but maybe you'll find out how to get correct result:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "zip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/functions.html#zip", "text": "http://docs.python.org/library/functions.html#zip", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; zip(*d.values())\n[('s', 'x1'), ('b', 'y1')]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I can't believe there are so many answers to such a vague question!", "But then again I'm no better.", ":-) My first thought was to do this the way that had already been done using izip_longest, but I wasn't a fan of using None as a special value-- what if None was an element of the list, after all? "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So instead, and assuming the \"standard interpretation\", how about:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d = {'a': ['s', 'b'], 'b': ['x1', 'y1', 'z1']}\n&gt;&gt;&gt; [x[2] for x in sorted((i,k,v) for k in d for i,v in enumerate(d[k]))]\n['s', 'x1', 'b', 'y1', 'z1']\n</code>\n</pre>\n", "senID": 2}, {"text": ["This only requires that the keys be sortable, and if they're not then we're wrong anyway."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["(Okay, to be perfectly honest, I first came up with zip(*sorted(chain(*(enumerate(d[k]) for k in sorted(d)))))[1], but I've been using itertools too much lately and that has too many parentheses for my liking."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "zip(*sorted(chain(*(enumerate(d[k]) for k in sorted(d)))))[1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n result = []\nd = { 'a':['s','b'], 'b':['x1','y1','z1'] }\n\nresult.append(d['a'][0])\nresult.append(d['b'][0])\nresult.append(d['a'][1])\nresult.append(d['b'][1])\nresult.append(d['b'][2])\nprint(result)\n</code>\n</pre>\n", "senID": 0}, {"text": ["That will give you the answer you want.", "I'm not sure what you were looking for in particular."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If I'm reading this correctly:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n result = []\n for x in d.values():\n     for y in x:\n          result.append(y)\n return result\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course this assumes every value in d is iterable."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Your question is a little unclear to me but are you trying to achieve this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d = { 'a': ['s','b'], 'b': ['x1','y1','z1'] }\n&gt;&gt;&gt; data = []\n&gt;&gt;&gt; for value in d.values():\n...      for val in value:\n...           data.append(val)\n...\n&gt;&gt;&gt; data\n['s', 'b', 'x1', 'y1', 'z1']\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; print \",\".join([d['a'][0],d['b'][0],d['a'][1],d['b'][1],d['b'][2]])\ns,x1,b,y1,z1\n</code>\n</pre>\n", "senID": 0}, {"text": ["Can't help you much more without knowing more about your problem.", "Of course there are nice ways of outputting"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you're wanting order of keys and values, You could try something such as:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; tuples=[tuple([k]+d[k]) for k in d]\n&gt;&gt;&gt; tuples.sort()\n&gt;&gt;&gt; tuples\n[('a', 's', 'b'), ('b', 'x1', 'y1', 'z1')]\n&gt;&gt;&gt; tuples_without_keys=[i[1:] for i in tuples]\n&gt;&gt;&gt; tuples_without_keys\n[('s', 'b'), ('x1', 'y1', 'z1')]\n&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; ans=itertools.izip_longest(*tuples_without_keys)\n&gt;&gt;&gt; ans=list(ans)\n&gt;&gt;&gt; ans\n[('s', 'x1'), ('b', 'y1'), (None, 'z1')]\n&gt;&gt;&gt; [i for k in ans for i in k if i is not None]\n['s', 'x1', 'b', 'y1', 'z1']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here's an answer just as lazy, vague, and helpful as the OP's question."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also, this smells like a homework question; if it is, it should be mentioned in the question."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import random\nd = { 'a': ['s','b'], 'b': ['x1','y1','z1'] }\noutput = d['a']+d['b']\nwhile output != ['s','x1','b','y1','z1']:\n    random.shuffle(output)\nprint output\n</code>\n</pre>\n", "senID": 2}, {"text": ["Please clarify your question if you want more helpful answers."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]