[[{"text": ["all and any are all you need."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "all", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "any", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you feel creative, you can also do:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import operator\ndef my_all(a_list):\n  return reduce(operator.and_, a_list, True)\n\ndef my_any(a_list):\n  return reduce(operator.or_, a_list, False)\n</code>\n</pre>\n", "senID": 2}, {"text": ["keep in mind that those aren't evaluated in short circuit, whilst the built-ins are ;-)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["another funny way:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def my_all_v2(a_list):\n  return len(filter(None,a_list)) == len(a_list)\n\ndef my_any_v2(a_list):\n  return len(filter(None,a_list)) &gt; 0\n</code>\n</pre>\n", "senID": 5}, {"text": ["and yet another:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def my_all_v3(a_list):\n  for i in a_list:\n    if not i:\n      return False\n  return True\n\ndef my_any_v3(a_list):\n  for i in a_list:\n    if i:\n      return True\n  return False\n</code>\n</pre>\n", "senID": 7}, {"text": ["and we could go on all day, but yes, the pythonic way is to use all and any :-)"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "all", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "any", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["By the way, Python has not tail recursion elimination, so don't try to translate LISP code directly ;-)"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["ANDing and ORing is easy:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; some_list = [True] * 100\n# OR\n&gt;&gt;&gt; any(some_list)\nTrue\n#AND\n&gt;&gt;&gt; all(some_list)\nTrue\n&gt;&gt;&gt; some_list[0] = False\n&gt;&gt;&gt; any(some_list)\nTrue\n&gt;&gt;&gt; all(some_list)\nFalse\n</code>\n</pre>\n", "senID": 1}, {"text": ["NOTing is also fairly easy:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [not x for x in some_list]\n[True, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False, False]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Of course, how you would use those results might require some interesting applications of DeMorgan's theorem."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Reduce can do this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Reduce", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html"}]}, {"code": "<pre>\n<code>\n reduce(lambda a,b: a and b, alist, True)\n</code>\n</pre>\n", "senID": 1}, {"text": ["As fortran mentioned, all is the most succinct way to do it.", "But reduce answers the more general question \"How to apply a logical operator to all elements in a python list?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The idiom for such operations is to use the reduce function (global in Python 2.X, in module functools in Python 3.X) with an appropriate binary operator either taken from the operator module or coded explicitly.", "In your case, it's operator.and_"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "reduce", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "functools", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "operator", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "operator.and_", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n reduce(operator.and_, [True, True, False])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["As the other answers show, there are multiple ways to accomplish this task.", "Here's another solution that uses functions from the standard library:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from functools import partial\n\napply_and = all\napply_or = any\napply_not = partial(map, lambda x: not x)\n\nif __name__ == \"__main__\":\n    ls = [True, True, False, True, False, True]\n    print \"Original: \", ls\n    print \"and: \", apply_and(ls)\n    print \"or: \", apply_or(ls)\n    print \"not: \", apply_not(ls)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's another solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def my_and(a_list):\n    return not (False in a_list)\n\ndef my_or(a_list):\n    return True in a_list\n</code>\n</pre>\n", "senID": 1}, {"text": ["ANDing all elements will return True if all elements are True, hence no False in a list.", "ORing is similar, but it should return True if at least one True value is present in a list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]