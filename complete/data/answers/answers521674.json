[[{"text": ["The first thing that comes to mind for me is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n verts = [None]*1000\n</code>\n</pre>\n", "senID": 1}, {"text": ["But do you really need to preinitialize it?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Not quite sure why everyone is giving you a hard time for wanting to do this - there are several scenarios where you'd want a fixed size initialised list.", "And you've correctly deduced that arrays are sensible in these cases."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import array\nverts=array.array('i',(0,)*1000)\n</code>\n</pre>\n", "senID": 1}, {"text": ["For the non-pythonistas, the (0,)*1000 term is creating a tuple containing 1000 zeros.", "The comma forces python to recognise (0) as a tuple, otherwise it would be evaluated as 0."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "(0,)*1000", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(0)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I've used a tuple instead of a list because they are generally have lower overhead."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["One obvious and probably not efficient way is "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n verts = [0 for x in range(1000)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that this can be extended to 2-dimension easily.", "For example, to get a 10x100 \"array\" you can do "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n verts = [[0 for x in range(100)] for y in range(10)]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You should consider using a dict type instead of pre-initialized list.", "The cost of a dictionary look-up is small and comparable to the cost of accessing arbitrary list element."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["And when using a mapping you can write:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n aDict = {}\naDict[100] = fetchElement()\nputElement(fetchElement(), fetchPosition(), aDict)\n</code>\n</pre>\n", "senID": 2}, {"text": ["And the putElement function can store item at any given position.", "And if you need to check if your collection contains element at given index it is more Pythonic to write:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "putElement", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if anIndex in aDict:\n    print \"cool!\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["Than:  "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n if not myList[anIndex] is None:\n    print \"cool!\"\n</code>\n</pre>\n", "senID": 6}, {"text": ["Since the latter assumes that no real element in your collection can be None.", "And if that happens - your code misbehaves."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "real", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["And if you desperately need performance and that's why you try to pre-initialize your variables, and write the fastest code possible - change your language.", "The fastest code can't be written in Python.", "You should try C instead and implement wrappers to call your pre-initialized and pre-compiled code from Python."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Without knowing more about the problem domain, it's hard to answer your question.", "Unless you are certain that you need to do something more, the pythonic way to initialize a list is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\nverts = []\n</pre>\n", "senID": 1}, {"text": ["Are you actually seeing a performance problem?", "If so, what is the performance bottleneck?", "Don't try to solve a problem that you don't have.", "It's likely that performance cost to dynamically fill an array to 1000 elements is completely irrelevant to the program  that you're really trying to write."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "completely irrelevant", "childNum": 0, "tag": "i", "pos": 3, "childList": []}]}, {"text": ["The array class is useful if the things in your list are always going to be a specific primitive fixed-length type (e.g.", "char, int, float).", "But, it doesn't require pre-initialization either."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You could do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n verts = list(xrange(1000))\n</code>\n</pre>\n", "senID": 1}, {"text": ["That would give you a list of 1000 elements in size and which happens to be initialised with values from 0-999.", "As list does a __len__ first to size the new list it should be fairly efficient. "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__len__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]