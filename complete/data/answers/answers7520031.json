[[{"text": ["This is easiest to do for your example, without changing Car, and changing as little else as possible, with __getattr__:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Car", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__getattr__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class Car(object):\n    def __init__(self, name, tank_size=10, mpg=30):\n        self.name = name\n        self.tank_size = tank_size\n        self.mpg = mpg\n\nclass Favorite(object):\n    def __init__(self, car):\n        self.car = car\n    def __getattr__(self, attr):\n        return getattr(self.car, attr)\n    @property\n    def range(self):\n        return self.mpg * self.tank_size\n\ncars = []\ncars.append(Car(\"Toyota\", 11, 29))\ncars.append(Car(\"Ford\", 15, 12))\ncars.append(Car(\"Honda\", 12, 25))\n\nmy_current_fav = Favorite(cars[1])\n\nprint my_current_fav.range\n</code>\n</pre>\n", "senID": 1}, {"text": ["Any attribute not found on an instance of Favorite will be looked up on the Favorite instances car attribute, which you set when you make the Favorite."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "Favorite", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Favorite", "childNum": 0, "tag": "code", "childList": []}, {"text": "car", "childNum": 0, "tag": "code", "childList": []}, {"text": "Favorite", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Your example of range isn't a particularly good one for something to add to Favorite, because it should just be a property of car, but I used it for simplicity."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "range", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Favorite", "childNum": 0, "tag": "code", "childList": []}, {"text": "property", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: Note that a benefit of this method is if you change your favorite car, and you've not stored anything car-specific on Favorite, you can change the existing favorite to a different car with:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "Favorite", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n my_current_fav.car = cars[0] # or Car('whatever')\n</code>\n</pre>\n", "senID": 5}], [{"text": ["If you have access to the class (and it sounds like you do), just create a function inside the class instead."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def range(self):\n    return self.tank_size * self.mpg\n</code>\n</pre>\n", "senID": 1}], [{"text": ["With regards to your example, you could make range a read-only property of class Car that would be computed on demand.", "No need for extra classes."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "range", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "property", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#property"}, {"text": "Car", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Why don't you just create a method:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Car(object):\n    def __init__(self, name, tank_size=10, mpg=30):\n        self.name = name\n        self.tank_size = tank_size\n        self.mpg = mpg\n\n    def range(self):\n        return self.tank_size * self.mpg\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Sounds like range() should  be a method of the class.", "Methods are very cheap - the objects don't store them.", "The downside is it is computed each time you access the value of range. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "range()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "range", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n class Car(object):\n   def __init__(self, name, tank_size=10, mpg=30):\n       [AS ABOVE]\n   def range(self):\n      return self.tank_size * self.mpg\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you prefer it to behave like a field, i.e.", "compute only once, you can store the value in the object during the range method:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "range", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def range(self):\n     if not hasattr(self,'_rangeval'):\n         self._rangeval = self.tank_size * self.mpg\n     return self._rangeval\n</code>\n</pre>\n", "senID": 3}, {"text": ["This takes advantage of the fact that you can dynamically create fields in objects."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I don't understand why the default would be 180 when the default of the computed values is 300.", "If this strange behaviour is important, you will need to set another flag to see if the other parameters have been initialised to the default or not."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I'm not sure I understand what you're trying to do, so I'm going to cover a few different possible understandings of what you're thinking."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First off, worrying about things being \"expensive\" is usually not that Pythonic.", "If it really mattered, you would be using a lower-level language most of the time.", "But in general, if you want something to be calculated rather than stored, the natural way is to use a method.", "Add it to the Car class.", "It does not cost per-object, unless of course you explicitly replace the method on a per-object basis."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "does not cost", "childNum": 0, "tag": "strong", "pos": 4, "childList": []}]}, {"text": ["Here's how it works: when you make a call to a_car.range(), the range attribute is looked up in a_car first.", "If it's not found there, then (skipping lots and lots of details here!", ") the class of a_car is identified as Car, and the attribute is looked up there.", "You define range as a Car method, so it gets found there, and is determined to be something that's actually callable, so it gets called.", "As a special syntax rule, a_car gets passed as the first parameter to the method (all of which partly explains why you need to have an explicit parameter - named self by convention - for methods in Python, unlike many other languages with an implicit this)."], "childNum": 11, "tag": "p", "senID": 2, "childList": [{"text": "a_car.range()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "range", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "a_car", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "skipping lots and lots of details here!", "childNum": 0, "tag": "em", "childList": []}, {"text": "a_car", "childNum": 0, "tag": "code", "childList": []}, {"text": "Car", "childNum": 0, "tag": "code", "childList": []}, {"text": "range", "childNum": 0, "tag": "code", "childList": []}, {"text": "Car", "childNum": 0, "tag": "code", "childList": []}, {"text": "a_car", "childNum": 0, "tag": "code", "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "childList": []}, {"text": "this", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You can definitely store a subclass of Car in the same list as a bunch of ordinary Cars.", "No problem there.", "Heck, you can store a Banana in the same list as a bunch of Cars if you like; Python is dynamically typed, and doesn't care.", "It will figure out what kind of object something is at the exact moment that it becomes relevant."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "Car", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Car", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "Banana", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Car", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["What you can't easily do is cause an existing Car to become a MyFavouriteCar.", "If you created a new MyFavouriteCar that my_favourite_car refers to (don't say \"points at\", please; object references are a higher-level abstraction, and unlike Java there is no \"null pointer\" in Python - None is an object), then you could replace an existing car in the list with it, but it's still a different object (even if it's somehow based on the original Car that it replaces).", "You can design in such a way that this doesn't matter; or you can resort to evil hackery (which I won't explain here); or you can (much better in your case) just offer the functionality to all Cars, because it's really free to do so."], "childNum": 7, "tag": "p", "senID": 4, "childList": [{"text": "Car", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "MyFavouriteCar", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "MyFavouriteCar", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "my_favourite_car", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Car", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "just offer the functionality to all Cars, because it's really free to do so", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["From the Zen of Python: Special cases aren't special enough."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Special cases aren't special enough", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["You talk about my_current_fav being a 'pointer' -- I just want to make sure you realize that, in fact, "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "my_current_fav", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n my_current_fav = cars[1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["binds a name to cars[1] -- in other words, my_current_fav is cars[1] == True.", "There is no pointing going on.", "If you really want a pointer-stlye you can do something like this:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "cars[1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "my_current_fav is cars[1] == True", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n class Favorite(object):\n    def __init__(self, car_list, index):\n        self.car_list = car_list\n        self.index = index\n    def __getattr__(self, attr):\n        return getattr(self.car_list[self.index], attr)\n    def __index__(self):\n        return self.index\n    @property\n    def range(self):\n        return self.mpg * self.tank_size\n\nmy_current_fav = Favorite(cars, 1)\n\nprint my_current_fav.name\nprint my_current_fav.range\nprint cars[my_current_fav]\n</code>\n</pre>\n", "senID": 3}]]