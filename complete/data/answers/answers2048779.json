[[{"text": ["In python, use the nsmallest function in the heapq module -- it's designed for exactly this kind of task."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "nsmallest function in the heapq module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/heapq.html#heapq.nsmallest"}]}, {"text": ["Example (tested) for Python 2.5 and 2.6:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import heapq, glob\n\ndef my_iterable():\n    for fname in glob.glob(\"in_s*.txt\"):\n        f = open(fname, \"r\")\n        for line in f:\n            items = line.split()\n            yield fname, items[0], float(items[6])\n        f.close()\n\nresult = heapq.nsmallest(10, my_iterable(), lambda x: x[2])\nprint result\n</code>\n</pre>\n", "senID": 2}, {"text": ["Update after above answer accepted"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Update after above answer accepted", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Looking at the source code for Python 2.6, it appears that there's a possibility that it does list(iterable) and works on that ... if so, that's not going to work with a thousand files each with millions of lines.", "If the first answer gives you MemoryError etc, here's an alternative which limits the size of the list to n (n == 10 in your case)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "list(iterable)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Note: 2.6 only; if you need it for 2.5 use a conditional heapreplace() as explained in the docs.", "Uses heappush() and heappushpop() which don't have the key arg :-( so we have to fake it."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "heapreplace()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "heappush()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "heappushpop()", "childNum": 0, "tag": "code", "childList": []}, {"text": "key", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import glob\nfrom heapq import heappush, heappushpop\nfrom pprint import pprint as pp\n\ndef my_iterable():\n    for fname in glob.glob(\"in_s*.txt\"):\n        f = open(fname, \"r\")\n        for line in f:\n            items = line.split()\n            yield -float(items[6]), fname, items[0]\n        f.close()\n\ndef homegrown_nlargest(n, iterable):\n    \"\"\"Ensures heap never has more than n entries\"\"\"\n    heap = []\n    for item in iterable:\n        if len(heap) &lt; n:\n            heappush(heap, item)\n        else:\n            heappushpop(heap, item)\n    return heap\n\nresult =  homegrown_nlargest(10, my_iterable())\nresult = sorted(result, reverse=True)\nresult = [(fname, fld0, -negfld6) for negfld6, fname, fld0 in result]\npp(result)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["I would:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "take first 10 items, ", "tag": "none", "senID": 1}, {"text": "sort them and then ", "tag": "none", "senID": 2}, {"text": "for every line read from files insert the element into those top10:\n", "tag": "none", "senID": 3}]}, {"text": ["I wouldn't post the complete program here as it looks like homework."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Yes, if it wasn't ten, this would be not optimal"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Try something like this in python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n min_values = []\n\ndef add_to_min(file_name, one, seven):\n    # checks to see if 7th column is a lower value than exiting values\n    if len(min_values) == 0 or seven &lt; max(min_values)[0]:\n        # let's remove the biggest value\n        min_values.sort()\n        if len(min_values) != 0:\n            min_values.pop()\n        # and add the new value tuple\n        min_values.append((seven, file_name, one))\n\n# loop through all the files\nfor file_name in os.listdir(&lt;dir&gt;):\n    f = open(file_name)\n    for line in file_name.readlines():\n        columns = line.split()\n        add_to_min(file_name, columns[0], float(columns[6]))\n\n# print answers\nfor (seven, file_name, one) in min_values:\n    print file_name, one, seven\n</code>\n</pre>\n", "senID": 1}, {"text": ["Haven't tested it, but it should get you started."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Version 2, just runs the sort a single time (after a prod by S. Lott):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n values = []\n# loop through all the files and make a long list of all the rows\nfor file_name in os.listdir(&lt;dir&gt;):\n    f = open(file_name)\n    for line in file_name.readlines():\n        columns = line.split()\n        values.append((file_name, columns[0], float(columns[6]))\n\n# sort values, print the 10 smallest\nvalues.sort()\nfor (seven, file_name, one) in values[:10]\n    print file_name, one, seven\n</code>\n</pre>\n", "senID": 4}, {"text": ["Just re-read you question, with millions of rows, you might run out of RAM...."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["A small improvement of your shell solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ cat in.txt\nin_s1.txt\nin_s2.txt\n...\n$ cat in.txt | while read i\ndo\n  cat $i | sed -e \"s/^/$i /\" # add filename as first column\ndone |\nsort -n -k8 | head -10 | cut -d\" \" -f1,2,8\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If your files are million lines, you might want to consider using \"buffering\".", "the below script goes through those million lines, each time comparing field 7 with those in the buffer.", "If a value is smaller than those in the buffer, one of them in buffer is replaced by the new lower value. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for file in in_*.txt\n    do\n        awk -vt=$t 'NR&lt;=10{\n            c=c+1\n            val[c]=$7\n            tag[c]=$1\n        }\n        NR&gt;10{\n            for(o=1;o&lt;=c;o++){\n                if ( $7 &lt;= val[o] ){\n                    val[o]=$7\n                    tag[o]=$1\n                    break\n                }\n            }\n        }\n        END{\n            for(i=1;i&lt;=c;i++){\n                print val[i], tag[i] | \"sort\"\n            }\n\n        }' $file\n    done\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This might be close to what you're looking for:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for file in *; do sort -k6n \"$file\" | head -n 10 | cut -f1,7 -d \" \" | sed \"s/^/$file /\" &gt; \"${file}.out\"; done\n\ncat *.out | sort -k3n | head -n 10 &gt; final_result.out\n</code>\n</pre>\n", "senID": 1}]]