[[{"text": ["A concise way to do this is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \"\".join(reversed([a[i:i+2] for i in range(0, len(a), 2)]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This works by first breaking the string into pairs:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [a[i:i+2] for i in range(0, len(a), 2)]\n['AB', 'CD', 'EF', 'GH']\n</code>\n</pre>\n", "senID": 3}, {"text": ["then reversing that, and finally concatenating the result back together."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Lots of fun ways to do this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s=\"ABCDEFGH\"\n&gt;&gt;&gt; \"\".join(map(str.__add__, s[-2::-2] ,s[-1::-2]))\n'GHEFCDAB'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If anybody is interested, this is the timing for all* the answers."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["EDIT (had got it wrong the first time):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import timeit\nimport struct\n\nstring = \"ABCDEFGH\"\n\n# Expected resutlt =&gt; GHEFCDAB\n\ndef rev(a):\n    new = \"\"\n\n    for x in range(-1, -len(a), -2):\n        new += a[x-1] + a[x]\n\n    return new\n\ndef rev2(a):\n    return \"\".join(reversed([a[i:i+2] for i in range(0, len(a), 2)]))\n\ndef rev3(a):\n    return \"\".join(map(str.__add__, a[-2::-2] ,a[-1::-2]))\n\ndef rev4(a):\n    return \"\".join(map(\"\".join, reversed(zip(*[iter(a)]*2))))\n\n\ndef rev5(a):\n    n = len(a) / 2\n    fmt = '%dh' % n\n    return struct.pack(fmt, *reversed(struct.unpack(fmt, a)))\n\ndef rev6(a):\n    return \"\".join([a[x:x+2] for x in range(0,len(a),2)][::-1])\n\n\nprint \"Greg Hewgill %f\" %timeit.Timer(\"rev2(string)\", \"from __main__ import rev2, string\").timeit(100000)\nprint \"gnibbler %f\" %timeit.Timer(\"rev3(string)\", \"from __main__ import rev3, string\").timeit(100000)\nprint \"gnibbler second %f\" %timeit.Timer(\"rev4(string)\", \"from __main__ import rev4, string\").timeit(100000)\nprint \"Alok %f\" %timeit.Timer(\"rev5(string)\", \"from __main__ import rev5, struct, string\").timeit(100000)\nprint \"elliot42 %f\" %timeit.Timer(\"rev6(string)\", \"from __main__ import rev6, struct, string\").timeit(100000)\nprint \"me %f\" %timeit.Timer(\"rev(string)\", \"from __main__ import rev, string\").timeit(100000)\n</code>\n</pre>\n", "senID": 2}, {"text": ["results for string = \"ABCDEFGH\":"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "string = \"ABCDEFGH\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n Greg Hewgill 0.853000\ngnibbler 0.428000\ngnibbler second 0.707000\nAlok 0.763000\nelliot42 0.237000\nme 0.200000\n</code>\n</pre>\n", "senID": 4}, {"text": ["results for string = \"ABCDEFGH\"*5:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "string = \"ABCDEFGH\"*5", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n Greg Hewgill 2.246000\ngnibbler 0.811000\ngnibbler second 1.205000\nAlok 0.972000\nelliot42 0.594000\nme 0.584000\n</code>\n</pre>\n", "senID": 6}, {"text": ["results for string = \"ABCDEFGH\"*10:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "string = \"ABCDEFGH\"*10", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n Greg Hewgill 2.058000\ngnibbler 1.178000\ngnibbler second 1.926000\nAlok 1.210000\nelliot42 0.935000\nme 1.082000\n</code>\n</pre>\n", "senID": 8}, {"text": ["results for string = \"ABCDEFGH\"*100:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "string = \"ABCDEFGH\"*100", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n Greg Hewgill 9.762000\ngnibbler 9.134000\ngnibbler second 14.782000\nAlok 5.775000\nelliot42 7.351000\nme 18.140000\n</code>\n</pre>\n", "senID": 10}, {"text": ["*Sorry @Lacrymology could not make your's work!"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["Here is a general form.", "The size of the grouping can easily be changed to a different number of characters at a time.", "The string length should be an exact multiple of the grouping size"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; \"\".join(map(\"\".join, reversed(zip(*[iter(\"ABCDEFGH\")]*2))))\n'GHEFCDAB'\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import array\n&gt;&gt;&gt; s=\"abcdef\"\n&gt;&gt;&gt; a=array.array('H',s)\n&gt;&gt;&gt; a.byteswap()\n&gt;&gt;&gt; a.tostring()\n'badcfe'\n</code>\n</pre>\n", "senID": 0}, {"text": ["Finish up by using a.reverse() instead of a.byteswap() if you wanted to swap element order rather than byte order."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I took the liberty of editing Trufa's benchmark script a bit.", "The modified script generated a graphical plot showing approximately linear scaling for all functions."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "modified script", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.algonet.se/~yann/stackoverflow/revtest.py"}, {"href": "http://www.algonet.se/~yann/stackoverflow/revplot.png", "text": "graphical plot", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["You can use this, but don't tell anyone I wrote this code :-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import struct\n\ndef pair_reverse(s):\n    n = len(s) / 2\n    fmt = '%dh' % n\n    return struct.pack(fmt, *reversed(struct.unpack(fmt, s)))\n\npair_reverse('ABCDEFGH')\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n st = \"ABCDEFGH\"\n\"\".join([st[x:x+2] for x in range(0,len(st),2)][::-1])\n</code>\n</pre>\n", "senID": 0}, {"text": ["EDIT: Curses, apparently 27 minutes slower than another poster.", "But I like the reverse slice notation better."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Some more information on the reverse slice here: &quot;&quot;.join(reversed(val)) vs val[::-1]...which is pythonic?"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "&quot;&quot;.join(reversed(val)) vs val[::-1]...which is pythonic?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1695385/joinreversedval-vs-val-1-which-is-pythonic/1695416#1695416"}]}], [{"text": ["just a shot"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n st = \"ABCDEFGH\"\ns = [st[2*n:2*n+1] for n in range(len(st)/2)]\nreturn s[::-1].join('')\n</code>\n</pre>\n", "senID": 1}, {"text": ["this assumes that len(st) is even, otherwise change that to range(len(st)/2+1) and I'm even sure there's a better way to do that split into twos."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If your python complains about s[::-1] you can use reversed(s)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["And yet another way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = \"ABCDEFGH\"\nnew = \"\"\n\nfor x in range(-1, -len(a), -2):\n    new += a[x-1] + a[x]\n\nprint new\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This looks like homework.", "So here's a very unorthodox approach that you might find interesting:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = \"ABCDEFGH\"\n&gt;&gt;&gt; ''.join([s[::2][::-1][i]+s[::-2][i] for i in range(len(s[::2]))])\n'GHEFCDAB'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Good Luck!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["My friend Rob pointed out a beautiful recursive solution:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Rob", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/4798/rob-rolnick"}]}, {"code": "<pre class=\"lang-python prettyprint-override\">\n<code>\n def f(s):\n    return \"\" if not s else f(s[2:]) + s[:2]\n</code>\n</pre>\n", "senID": 1}]]