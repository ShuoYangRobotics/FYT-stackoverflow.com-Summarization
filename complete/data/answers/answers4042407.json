[[{"text": ["Both Luper and Vladimir are correct imho but you'll need both in order to complete your requirements."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["Although, the constants don't need to be in the settings.py, you could put them anywhere and import them from that place into your view/model/module code.", "I sometimes put them into the __init__.py if I don't care to have them to be considered globally relevant."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "need", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "__init__.py", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["a context processor like this will ensure that selected variables are globally in the template scope"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]}, {"text": ["But this might be overkill if you're new to django; perhaps you're just asking how to put variables into the template scope...?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from django.conf import settings\n\n...\n# do stuff with settings.MIN_TIME_TEST as you wish\n\nrender_to_response(\"the_template.html\", { \n    \"MIN_TIME_TEST\": settings.MIN_TIME_TEST \n}, context_instance=RequestContext(request)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Consider putting it into settings.py of your application.", "Of course, in order to use it in template you will need to make it available to template as any other usual variable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Use context processors to have your constants available in all templates (settings.py is a nice place to define them as Vladimir said)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "context processors", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev/ref/templates/api/#writing-your-own-context-processors"}]}], [{"text": ["In the context processor you can use something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import settings\n\ncontext = {}\nfor item in dir(settings):\n    #use some way to exclude __doc__, __name__, etc..\n    if item[0:2] != '__':\n        context[item] = getattr(settings, item)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["To build on other people's answers, here's a simple way you'd implement this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In your settings file:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n GLOBAL_SETTINGS = {\n    'MIN_TIME_TEST': 'blah',\n    'RANDOM_GLOBAL_VAR': 'blah',\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then, building off of John Mee's context processor:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "John Mee's context processor", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4042407/defining-constants-in-django/4042578#4042578"}]}, {"code": "<pre>\n<code>\n def settings(request):\n    \"\"\"\n    Put selected settings variables into the default template context\n    \"\"\"\n    from django.conf import settings\n    return settings.GLOBAL_SETTINGS\n</code>\n</pre>\n", "senID": 4}, {"text": ["This will resolve the DRY issue."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Or, if you only plan to use the global settings occasionally and want to call them from within the view:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def view_func(request):\n    from django.conf import settings\n    # function code here\n    ctx = {} #context variables here\n    ctx.update(settings.GLOBAL_SETTINGS)\n    # whatever output you want here\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Variant on John Mee's last part, with a little elaboration on the same idea Jordan Reiter discusses."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Suppose you have something in your settings akin to what Jordan suggested -- in other words, something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n GLOBAL_SETTINGS = {\n   'SOME_CONST': 'thingy',\n   'SOME_OTHER_CONST': 'other_thingy',\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["Suppose further you already have a dictionary with some of the variables you'd like to pass your template, perhaps passed as arguments to your view.", "Let's call it my_dict.", "Suppose you want the values in my_dict to override those in the settings.GLOBAL_SETTINGS dictionary."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "my_dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "settings.GLOBAL_SETTINGS", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["You might do something in your view like:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def my_view(request, *args, **kwargs)\n    from django.conf import settings\n    my_dict = some_kind_of_arg_parsing(*args,**kwargs)\n    tmp = settings.GLOBAL_SETTINGS.copy()\n    tmp.update(my_dict)\n    my_dict = tmp\n    render_to_response('the_template.html', my_dict, context_instance=RequestContext(request))\n</code>\n</pre>\n", "senID": 5}, {"text": ["This lets you have the settings determined globally, available to your templates, and doesn't require you to manually type out each of them."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["If you don't have any additional variables to pass the template, nor any need to override, you can just do:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "don't", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n render_to_response('the_template.html', settings.GLOBAL_SETTINGS, context_instance=RequestContext(request))\n</code>\n</pre>\n", "senID": 8}, {"text": ["The main difference between what I'm discussing here &amp; what Jordan has, is that for his, settings.GLOBAL_SETTINGS overrides anything it may have in common w/ your context dictionary, and with mine, my context dictionary overrides settings.GLOBAL_SETTINGS.", "YMMV."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "settings.GLOBAL_SETTINGS", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "settings.GLOBAL_SETTINGS", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Context processors are better suited at handling more dynamic object data--they're defined as a mapping in the documentation and in many of the posts here they're being modified or passed around to views--it doesn't make sense that a template may lose access to global information because, for example, your forgot to use a specialized context processor in the view.", "The data is global by definition &amp; that couples the view to the template."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://docs.djangoproject.com/en/dev/ref/templates/api/"}]}, {"text": ["A better way is to define a custom template tag.", "This way:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "templates aren't relying on views to have global information passed into them", "tag": "none", "senID": 2}, {"text": "it's DRY-er: the app defining the global settings can be exported to many projects, eliminating common code across projects", "tag": "none", "senID": 3}, {"text": "templates decide whether they have access to the global information, not the view functions", "tag": "none", "senID": 4}]}, {"text": ["In the example below I deal with your problem--loading in this MIN_TIME_TEST variable--and a problem I commonly face, loading in URLs that change when my environment changes."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I have 4 environments--2 dev and 2 production:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Dev: django-web server, url: localhost:8000", "tag": "none", "senID": 7}, {"text": "Dev: apache web server: url: sandbox.com -> resolves to 127.0.0.1", "tag": "none", "senID": 8}, {"text": "Prod sandbox server, url: sandbox.domain.com", "tag": "none", "senID": 9}, {"text": "Prod server: url: domain.com", "tag": "none", "senID": 10}]}, {"text": ["I do this on all my projects &amp; keep all the urls in a file, global_settings.py so it's accessible from code.", "I define a custom template tag {% site_url %} that can be (optionally) loaded into any template"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["I create an app called global_settings, and make sure it's included in my settings.INSTALLED_APPS tuple."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Django compiles templated text into nodes with a render() method that tells how the data should be displayed--I created an object that renders data by returnning values in my global_settings.py based on the name passed in."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["It looks like this:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n from django import template\nimport global_settings\n\nclass GlobalSettingNode(template.Node):\n    def __init__(self, settingname):\n        self.settingname = settingname;\n    def render(self, context):\n        if hasattr(global_settings, self.settingname):\n            return getattr(global_settings, self.settingname)\n        else:\n            raise template.TemplateSyntaxError('%s tag does not exist' % self.settingname)\n</code>\n</pre>\n", "senID": 15}, {"text": ["Now, in global_settings.py I register a couple tags: site_url for my example and min_test_time for your example.", "This way, when {% min_time_test %} is invoked from a template, it'll call get_min_time_test which resolves to load in the value=5.", "In my example, {% site_url %} will do a name-based lookup so that I can keep all 4 URLs defined at once and choose which environment I'm using.", "This is more flexible for me than just using Django's built in settings.Debug=True/False flag."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n from django import template\nfrom templatenodes import GlobalSettingNode\nregister = template.Library()\n\n\nMIN_TIME_TEST = 5\n\nDEV_DJANGO_SITE_URL = 'http://localhost:8000/'\nDEV_APACHE_SITE_URL = 'http://sandbox.com/'\nPROD_SANDBOX_URL = 'http://sandbox.domain.com/'\nPROD_URL = 'http://domain.com/'\n\nCURRENT_ENVIRONMENT = 'DEV_DJANGO_SITE_URL'\n\n\n\ndef get_site_url(parser, token):\n    return GlobalSettingNode(CURRENT_ENVIRONMENT)\n\ndef get_min_time_test(parser, token):\n    return GlobalSettingNode('MIN_TIME_TEST')\n\nregister.tag('site_url', get_site_url)\nregister.tag('min_time_test', get_min_time_test)\n</code>\n</pre>\n", "senID": 17}, {"text": ["Note that for this to work, django is expecting global_settings.py to be located in a python packaged called templatetags under your Django app.", "My Django app here is called global_settings, so my directory structure looks like:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["/project-name/global_settings/templatetags/global_settings.py\netc."], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["Finally the template chooses whether to load in global settings or not, which is beneficial for performance.", "Add this line to your template to expose all the tags registered in global_settings.py:"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"code": "<pre>\n<code>\n {% load global_settings %}\n</code>\n</pre>\n", "senID": 21}, {"text": ["Now, other projects that need MIN_TIME_TEST or these environments exposed can simply install this app =)"], "childNum": 0, "tag": "p", "senID": 22, "childList": []}]]