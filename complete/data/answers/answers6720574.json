[[{"text": ["Still keeping in mind that @Walter is correct in his comments to your question, this is a silly implementation of what you asked for, inspired by the final bit of your question, in which you suggest that 1 and 3 could just be replaced with [1 and 3]."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "3", "childNum": 0, "tag": "code", "childList": []}, {"text": "[1", "childNum": 0, "tag": "code", "childList": []}, {"text": "3]", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; s = repr([1, 2, 2, 1, 2, 3, 2, 3])\n&gt;&gt;&gt; s = re.sub('1', '[1', s)\n&gt;&gt;&gt; s = re.sub('3', '3]', s)\n&gt;&gt;&gt; l = eval(s)\n&gt;&gt;&gt; l\n[[1, 2, 2, [1, 2, 3], 2, 3]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["What it does is working on the representation of the list (a string) and substituting the way you suggested using regular expressions.", "Finally, it evaluate the string (getting back a list)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I call this implementation \"silly\" because it does the trick, but it's ugly and truly unpythonic.", "That said, it does the trick, so if you are simply using it for a one-off conversion of some data you need to use..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["HTH!"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n def whatever(a):\n    b = []\n    tmp = []\n    last = None\n\n    for elem in a:\n        if tmp:\n            tmp.append(elem)\n            if elem == 3:\n                b.append(tmp)\n                tmp = []\n        elif last == 2 and elem == 1:\n            tmp.append(1)\n        else:\n            b.append(elem)\n        last = elem\n    return b\n\nprint whatever([1, 2, 2, 1, 2, 3, 2, 3])\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n def nest(lst, low, high):\n    pattern = list(range(low, high + 1))\n    pattern_length = len(pattern)\n    for low_index in range(len(lst)):\n        if lst[low_index:(low_index + pattern_length)] == pattern:\n            lst[low_index:(low_index + pattern_length)] = [pattern]\n</code>\n</pre>\n", "senID": 0}, {"text": ["It isn't recursive though, but I believe that recursive algorithms in Python are evil since it hasn't tail call optimisation."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I like state machines:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip, tee\n\ndef pairwise(iterable):\n    a, b = tee(iterable)\n    next(b)\n    return izip(a, b)\n\nclass Flat(object):\n    def append_next(self, alist, e0, e1):\n        alist.append(e0)\n        if e0 == 2 and e1 == 1:\n            alist.append([])\n            self.__class__ = Nested\n    def append_last(self, alist, e):\n        alist.append(e)\n\nclass Nested(object):\n    def append_next(self, alist, e0, e1):\n        alist[-1].append(e0)\n        if e0 == 3:\n            self.__class__ = Flat\n    def append_last(self, alist, e):\n        alist[-1].append(e)\n\ndef nested(flat_list):\n    if len(flat_list) &lt;= 1:\n        return list(flat_list)\n    state = Flat()\n    nested_list = []\n    for x, y in pairwise(flat_list):\n        state.append_next(nested_list, x, y)\n    state.append_last(nested_list, y)\n    return nested_list\n\ns = [1, 2, 2, 1, 2, 3, 2, 3]\n\nprint nested(s)\n</code>\n</pre>\n", "senID": 1}, {"text": ["gives:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [1, 2, 2, [1, 2, 3], 2, 3]\n</code>\n</pre>\n", "senID": 3}, {"text": ["But this might be more pythonic:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def nested(flat_list):\n    if len(flat_list) &lt;= 1:\n        return list(flat_list)\n    pairs = pairwise(flat_list)\n    nested_list = []\n    while True:\n        for x, y in pairs:\n            nested_list.append(x)\n            if x == 2 and y == 1:\n                nested_list.append([])\n                break\n        else:\n            nested_list.append(y)\n            break\n        for x, y in pairs:\n            nested_list[-1].append(x)\n            if x == 3:\n                break\n        else:\n            nested_list[-1].append(y)\n            break\n    return nested_list\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Pease bear with me - it is 2:50(night) - here is my version - not very beatiful but it works pretty well for me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def buildNewList(inputList):\n    last = 0\n    res = []\n    for i,c in enumerate(inputList):\n        if i == 0:\n            prev = c\n        if i &lt; last:\n            continue\n        if c == 1 and prev == 2:\n            if 3 in inputList[i:]:\n                last = i + 1 + inputList[i:].index(3)\n                res.append(buildNewList(inputList[i: last]))\n            else:\n                last = len(inputList)\n                res.append(buildNewList(inputList[i:len(inputList)]))\n        else:\n            res.append(c)\n        prev = c\n    return res\n\n\nl1 = buildNewList([1, 2, 2, 1, 2, 3, 2, 3])\n&gt;&gt;&gt; [1, 2, 2, [1, 2, 3], 2, 3]\n\nl2 = buildNewList([1, 2, 2, 1, 2, 3, 2, 1, 2, 3])\n&gt;&gt;&gt; [1, 2, 2, [1, 2, 3], 2, [1, 2, 3]]\n\nl3 = buildNewList([1,2,3,1,2,3])\n&gt;&gt;&gt; [1, 2, 3, 1, 2, 3]\n\nl4 = buildNewList([1,2,1,1,2,1])\n&gt;&gt;&gt; [1, 2, [1, 1, 2, [1]]]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["That is an entertaining problem!", "Here is my solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def treeize(treeizable, tree=None, stopper=object()):\n    if tree is None:\n        tree = []\n\n    if treeizable[:1] == [stopper]:\n        tree.append(treeizable.pop(0))       \n        return tree\n    elif treeizable[0:2] == [2, 1]:\n        tree.append(treeizable.pop(0))\n        subtree = []\n        treeize(treeizable, subtree, stopper=3)\n        tree.append(subtree)\n        return treeize(treeizable, tree, stopper)\n    elif treeizable:\n        tree.append(treeizable.pop(0))\n        return treeize(treeizable, tree, stopper)\n    else:\n        return tree\n</code>\n</pre>\n", "senID": 1}, {"text": ["This function receives a flat list treeizable that should be converted to a nested list tree.", "The stopper parameter marks when the current list is done - being this a nested or the toplevel list.", "(Since the default value of stopper is an instance of object, it is impossible that there will be a stopper on a list called with the default value, because instances of object are different between themselves)."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "treeizable", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tree", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "stopper", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "stopper", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "object", "childNum": 0, "tag": "code", "childList": []}, {"text": "object", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def treeize(treeizable, tree=None, stopper=object()):\n</code>\n</pre>\n", "senID": 3}, {"text": ["For easing our work, the default value of tree is None and, if it has the default value, then it is set to a list.", "It is made because it is problematic to have mutable values as default parameter objects.", "Also, it would be annoying to have to type the function with an empty list everytime."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "tree", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "it is problematic to have mutable values as default parameter objects", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/q/1132941/287976"}]}, {"code": "<pre>\n<code>\n if tree is None:\n        tree = []\n</code>\n</pre>\n", "senID": 5}, {"text": ["If the first value of the flat list is the \"stopper\", then it is added to the tree and the tree is returned.", "Note that, by using treeizable.pop(0) I am actually removing the value from the flat list.", "Since the stopper is only set when defining a nested list so, when we found it, no more need to be done: the \"subtree\" (that is, the nested list) is complete.", "Also, note that I get the first element of the list with a slice of the list.", "I made it because it is boring to have to type if treeizable and treeizable[0] == stopper.", "Since slicing does not have problems with inexistent indexes, I got the slice and compared it to another list made in place with only the stopper:"], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "treeizable.pop(0)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "removing", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "if treeizable and treeizable[0] == stopper", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"code": "<pre>\n<code>\n if treeizable[:1] == [stopper]:\n        tree.append(treeizable.pop(0))       \n        return tree\n</code>\n</pre>\n", "senID": 7}, {"text": ["If the beginning of the list is the \"beginner\", then I pop the first element from the list, append it to the tree and create a new tree - that is, a empty list.", "Now I call treeize() with the remaining list and the empty subtree, also passing 3 as the stopper value.", "treeize() will recursively generate a new tree that I append to my initial tree.", "After that, just call treeize() with the remaining of the list (which does not contain the elements of the subtree anymore) and the original list.", "Note that the stopper should be the same stopper received by the original call."], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "treeize()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "treeize()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "treeize()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n elif treeizable[0:2] == [2, 1]:\n        tree.append(treeizable.pop(0))\n        subtree = []\n        treeize(treeizable, subtree, stopper=3)\n        tree.append(subtree)\n        return treeize(treeizable, tree, stopper)\n</code>\n</pre>\n", "senID": 9}, {"text": ["If none of the previous conditions (the first element is a stopper, the beginning of the list is [2, 1]) is true, then I verify if there is something in the list.", "In this case, I pop the first element, add to the tree and call treeize() with the rest of the list."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "[2, 1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "treeize()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n elif treeizable:\n        tree.append(treeizable.pop(0))\n        return treeize(treeizable, tree, stopper)\n</code>\n</pre>\n", "senID": 11}, {"text": ["In the case that not even the previous condition is true... then we have an empty list.", "This means that all elements were put in the tree.", "Just return the tree to the user:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n else:\n        return tree\n</code>\n</pre>\n", "senID": 13}, {"text": ["This seems to have worked:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; treeize.treeize([1, 2, 2, 1, 2, 2, 1, 2, 2, 1, 2, 3, 2, 4, 5, 3,  3, 2, 3, 4])\n[1, 2, 2, [1, 2, 2, [1, 2, 2, [1, 2, 3], 2, 4, 5, 3], 3], 2, 3, 4]\n</code>\n</pre>\n", "senID": 15}, {"text": ["Your question has a taste of homework.", "In principle, we should not answer it but it is so interesting that I couldn't help myself :) If it is a homework, however, do not try to use this solution as your because it would be wrong and your teacher would surely find it on Google :P"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}]]