[[{"text": ["Somebody wrote: \"\"\"Python is smart enough.", "As long as the object you're iterating over has a __len__ or __length_hint__ method, Python will call it to determine the size and preallocate the array.", "\"\"\""], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__len__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__length_hint__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["As far as I can tell, there is no preallocation in a list comprehension.", "Python has no way of telling from the size of the INPUT what the size of the OUTPUT will be."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "there is no preallocation in a list comprehension", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Look at this Python 2.6 code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo(func, iterable):\n...     return [func(i) for i in iterable]\n...\n&gt;&gt;&gt; import dis; dis.dis(foo)\n  2           0 BUILD_LIST               0 #### build empty list\n              3 DUP_TOP\n              4 STORE_FAST               2 (_[1])\n              7 LOAD_FAST                1 (iterable)\n             10 GET_ITER\n        &gt;&gt;   11 FOR_ITER                19 (to 33)\n             14 STORE_FAST               3 (i)\n             17 LOAD_FAST                2 (_[1])\n             20 LOAD_FAST                0 (func)\n             23 LOAD_FAST                3 (i)\n             26 CALL_FUNCTION            1\n             29 LIST_APPEND      #### stack[-2].append(stack[-1]); pop()\n             30 JUMP_ABSOLUTE           11\n        &gt;&gt;   33 DELETE_FAST              2 (_[1])\n             36 RETURN_VALUE\n</code>\n</pre>\n", "senID": 3}, {"text": ["It just builds an empty list, and appends whatever the iteration delivers."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Now look at this code, which has an 'if' in the list comprehension:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def bar(func, iterable):\n...     return [func(i) for i in iterable if i]\n...\n&gt;&gt;&gt; import dis; dis.dis(bar)\n  2           0 BUILD_LIST               0\n              3 DUP_TOP\n              4 STORE_FAST               2 (_[1])\n              7 LOAD_FAST                1 (iterable)\n             10 GET_ITER\n        &gt;&gt;   11 FOR_ITER                30 (to 44)\n             14 STORE_FAST               3 (i)\n             17 LOAD_FAST                3 (i)\n             20 JUMP_IF_FALSE           17 (to 40)\n             23 POP_TOP\n             24 LOAD_FAST                2 (_[1])\n             27 LOAD_FAST                0 (func)\n             30 LOAD_FAST                3 (i)\n             33 CALL_FUNCTION            1\n             36 LIST_APPEND\n             37 JUMP_ABSOLUTE           11\n        &gt;&gt;   40 POP_TOP\n             41 JUMP_ABSOLUTE           11\n        &gt;&gt;   44 DELETE_FAST              2 (_[1])\n             47 RETURN_VALUE\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 6}, {"text": ["The same code, plus some code to avoid the LIST_APPEND."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["In Python 3.X, you need to dig a little deeper:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "In Python 3.X, you need to dig a little deeper:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import dis\n&gt;&gt;&gt; def comprehension(f, iterable): return [f(i) for i in iterable]\n...\n&gt;&gt;&gt; dis.dis(comprehension)\n  1           0 LOAD_CLOSURE             0 (f)\n              3 BUILD_TUPLE              1\n              6 LOAD_CONST               1 (&lt;code object &lt;listcomp&gt; at 0x00C4B8D\n8, file \"&lt;stdin&gt;\", line 1&gt;)\n              9 MAKE_CLOSURE             0\n             12 LOAD_FAST                1 (iterable)\n             15 GET_ITER\n             16 CALL_FUNCTION            1\n             19 RETURN_VALUE\n&gt;&gt;&gt; dis.dis(comprehension.__code__.co_consts[1])\n  1           0 BUILD_LIST               0\n              3 LOAD_FAST                0 (.0)\n        &gt;&gt;    6 FOR_ITER                18 (to 27)\n              9 STORE_FAST               1 (i)\n             12 LOAD_DEREF               0 (f)\n             15 LOAD_FAST                1 (i)\n             18 CALL_FUNCTION            1\n             21 LIST_APPEND              2\n             24 JUMP_ABSOLUTE            6\n        &gt;&gt;   27 RETURN_VALUE\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 9}, {"text": ["It's the same old schtick: start off with building an empty list, then iterate over the iterable, appending to the list as required.", "I see no preallocation here."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "It's the same old schtick: start off with building an empty list, then iterate over the iterable, appending to the list as required. I see no preallocation here.", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["The optimisation that you are thinking about is used inside a single opcode e.g.", "the implementation of list.extend(iterable) can preallocate if iterable can accurately report its length.", "list.append(object) is given a single object, not an iterable."], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "list.extend(iterable)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "iterable", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "list.append(object)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["There is no difference in computational complexity between using an autoresizing array and preallocating an array.", "At worst, it costs about O(2N).", "See here: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://stackoverflow.com/questions/200384/constant-amortized-time/249695#249695"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://stackoverflow.com/questions/200384/constant-amortized-time/249695#249695", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/200384/constant-amortized-time/249695#249695"}]}, {"text": ["The cost of the function calls plus whatever happens in your function is going to make this extra n insignificant.", "This isn't something you should worry about.", "Just use the list comprehension."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you use the timeit module, you may come to the opposite conclusion: list comprehension is faster than preallocation:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "timeit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n f=lambda x: x+1\nN=1000000\ndef lc():\n    return [f(i) for i in range(N)]\ndef prealloc():\n    mylist = [None]*N\n    for i in range(N): mylist[i]=f(i)\n    return mylist\ndef xr():\n    return map(f,xrange(N))\n\nif __name__=='__main__':\n    lc()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Warning: These are the results on my computer.", "You should try these tests yourself, as your results may be different depending on your version of Python and your hardware.", "(See the comments."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Warning", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n % python -mtimeit -s\"import test\" \"test.prealloc()\"\n10 loops, best of 3: 370 msec per loop\n% python -mtimeit -s\"import test\" \"test.lc()\"\n10 loops, best of 3: 319 msec per loop\n% python -mtimeit -s\"import test\" \"test.xr()\"\n10 loops, best of 3: 348 msec per loop\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that unlike Javier's answer, I include mylist = [None]*N as part of the code timeit is to time when using the \"pre-allocation\" method.", "(It's not just part of the setup, since it is code one would need only if using pre-allocation."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "mylist = [None]*N", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["PS.", "the time module (and time (unix) command) can give unreliable results.", "If you wish to time Python code, I'd suggest sticking with the timeit module."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "time", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "time", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"href": "http://stackoverflow.com/questions/1622943/timeit-versus-timing-decorator", "text": "can give unreliable results", "childNum": 0, "tag": "a", "childList": []}, {"text": "timeit", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Going to have to disagree with Javier here..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["With the following code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n print '%5s | %6s | %6s' % ('N', 'l.comp', 'manual')\nprint '------+--------+-------'\nfor N in 10, 100, 1000, 10000:\n    num_iter = 1000000 / N\n\n    # Time for list comprehension.\n    t1 = timeit.timeit('[func(i) for i in range(N)]', setup='N=%d;func=lambda x:x' % N, number=num_iter)\n\n    # Time to build manually.\n    t2 = timeit.timeit('''mylist = [None]*N\nfor i in range(N): mylist[i] = func(i)''', setup='N=%d;func=lambda x:x' % N, number=num_iter)\n\n    print '%5d | %2.4f | %2.4f' % (N, t1, t2)\n</code>\n</pre>\n", "senID": 2}, {"text": ["I get the following table:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n N | l.comp | manual\n------+--------+-------\n   10 | 0.3330 | 0.3597\n  100 | 0.2371 | 0.3138\n 1000 | 0.2223 | 0.2740\n10000 | 0.2185 | 0.2771\n</code>\n</pre>\n", "senID": 4}, {"text": ["From this table it appears that the list comprehension faster than pre-allocation in every case of these varying lengths."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Interesting question.", "As of the following test, it seems that preallocation does not improve performance in the current CPython implementation (Python 2 code but result ranking is the same, except that there's no xrange in Python 3):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n N = 5000000\n\ndef func(x):\n    return x**2\n\ndef timeit(fn):\n    import time\n    begin = time.time()\n    fn()\n    end = time.time()\n    print \"%-18s: %.5f seconds\" % (fn.__name__, end - begin)\n\ndef normal():\n    mylist = [func(i) for i in range(N)]\n\ndef normalXrange():\n    mylist = [func(i) for i in xrange(N)]\n\ndef pseudoPreallocated():\n    mylist = [None] * N\n    for i in range(N): mylist[i] = func(i)\n\ndef preallocated():\n    mylist = [None for i in range(N)]\n    for i in range(N): mylist[i] = func(i)\n\ndef listFromGenerator():\n    mylist = list(func(i) for i in range(N))\n\ndef lazy():\n    mylist = (func(i) for i in xrange(N))\n\n\n\ntimeit(normal)\ntimeit(normalXrange)\ntimeit(pseudoPreallocated)\ntimeit(preallocated)\ntimeit(listFromGenerator)\ntimeit(lazy)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Results (ranking in parentheses):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n normal            : 7.57800 seconds (2)\nnormalXrange      : 7.28200 seconds (1)\npseudoPreallocated: 7.65600 seconds (3)\npreallocated      : 8.07800 seconds (5)\nlistFromGenerator : 7.84400 seconds (4)\nlazy              : 0.00000 seconds\n</code>\n</pre>\n", "senID": 3}, {"text": ["but with psyco.full():"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "psyco.full()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n normal            : 7.25000 seconds  (3)\nnormalXrange      : 7.26500 seconds  (4)\npseudoPreallocated: 6.76600 seconds  (1)\npreallocated      : 6.96900 seconds  (2)\nlistFromGenerator : 10.50000 seconds (5)\nlazy              : 0.00000 seconds\n</code>\n</pre>\n", "senID": 5}, {"text": ["As you can see, pseudo-preallocation is faster with psyco.", "In any case, there's not much of a difference between the xrange solution (which I'd recommend) and the other solutions.", "If you don't process all elements of the list later, you could also use the lazy method (shown in the code above) which will create a generator that produces elements by the time you iterate over it."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "xrange", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Using list comprehension to accomplish what you're trying to do would be more pythonic way to do it.", "Despite performance penalty:)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]