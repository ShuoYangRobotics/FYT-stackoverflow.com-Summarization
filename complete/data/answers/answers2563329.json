[[{"text": ["How many of these blocks might appear in a document?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Often slow Regex execution is the result of catastrophic backtracking, as described here: http://www.regular-expressions.info/catastrophic.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.regular-expressions.info/catastrophic.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.regular-expressions.info/catastrophic.html"}]}, {"text": ["I don't know what regex technology you're using, but you could try to use lookaround assertions, as described here:\nhttp://www.regular-expressions.info/lookaround.html"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.regular-expressions.info/lookaround.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.regular-expressions.info/lookaround.html"}]}, {"text": ["These allow you to first just match what you want, ABC inside parentheses, and then validate that it is preceded by some value and followed by some other value."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "ABC", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Are you sure the regex is correct and pulls out ABC as a match?", "What language's regex engine is this?", "Using my regular expression debugger shows that:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\"BT.*?((.*?)).", "*?ET\" doesn't pull out ABC and in fact must find the string 'ET' then backtrack back to find everything else."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "\"BT.*?((.*?)).*?ET\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["\"BT.*?\\\\((.*?)\\\\).", "*?ET\" works as expected with a single pass left to right."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "\"BT.*?\\\\((.*?)\\\\).*?ET\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["You can't just parse the PDF with a regex to extract the text.", "In most cases the text in inside compressed binary blobs or encoded.", "A PDF with the text shown like this is very much the exception."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["There's not really enough info for a definite answer--or maybe you're assuming we know more about PDF than you do.", "Are there always parenthesized chunks inside these BT...ET sections?", "Is there always only one of them?", "Is the BT or ET always at the beginning of a line?", "If so, I would suggest"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "BT...ET", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "BT", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "ET", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n (?m)^BT[^()]*\\((.*?)\\)[^()]*?^ET\n</code>\n</pre>\n", "senID": 1}, {"text": ["If I knew how PDF represented literal parentheses, I could probably come up with something more efficient."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: According to the PDF spec, literal parentheses have to be escaped with a backslash, and there are a bunch of other backslash-escape sequences.", "So try this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n (?s)\\bBT\\b[^()]*\\(((?:[^()\\\\]*(?:\\\\.[^()\\\\]*)*))\\)\n</code>\n</pre>\n", "senID": 4}, {"text": ["This part--[^()\\\\]*(?:\\\\.", "[^()\\\\]*)*--matches a block of text which may contain escaped characters (including parens), but not unescaped parens.", "I know it looks ugly, but it's the most efficient way, since Python doesn't support atomic groups or possessive quantifiers."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "[^()\\\\]*(?:\\\\.[^()\\\\]*)*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["(?s) allows .", "to match newlines, and \\bBT\\b makes sure the BT isn't part of a longer \"word\".", "I'm reasonably confident that this is all I need to match all of the actual text content, so I don't bother matching the stuff after the closing paren."], "childNum": 4, "tag": "p", "senID": 6, "childList": [{"text": "(?s)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\\bBT\\b", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "BT", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["here's one without regex.", "simple string parsing using Python internals."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; xtract=\"\"\"\n... BT\n...    /F13 12 Tf\n...    288 720 Td\n...    (ABC) Tj\n... ET\n...\n... \"\"\"\n&gt;&gt;&gt; for chunk in xtract.split(\"ET\"):\n...     if \"BT\" in chunk:\n...         for brace in chunk.split(\")\"):\n...             if \"(\" in brace:\n...                  print brace[brace.find(\"(\")+1:]\n...\nABC\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Since there will be only one bracketed expression between a BT and an ET, you could try the following regular expression for speed:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "BT", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ET", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n r\"(?s)\\bBT\\b[^(]*\\(([^)]*)\\).*?\\bET\\b\"\n</code>\n</pre>\n", "senID": 1}]]