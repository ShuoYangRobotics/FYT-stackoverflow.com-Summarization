[[{"text": ["Here is the code that should work"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n match = 'aardvark'\n    f = 'wlist.txt'\n    success = False\n    try:\n        for word in open(f):\n            if word.strip() == match: # Change here \n                success = True\n                break\n    except IOError:\n        print f, \"not found!\"\n    if success:\n        print \"The word has been found with a value of\", word\n    else:\n        print \"Word not found\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["As others have already said, your problem stems from the fact that the newline characters are part of the words you are reading in.", "The best way to get rid of these is to use the strip() method of str."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "strip()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In addition, your code does too much to accomplish a simple task.", "All you need to do is build a set from your word list and look for the occurrence of your word in the set.", "A set is far better for this task than a list because checking for the occurrence of an element in a set is much faster.", "So something like this should work."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "much", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n try:\n    with open('wordlist.txt', 'rU') as infile:\n        wordSet = set(line.strip() for line in infile)\nexcept IOError:\n       print 'error opening file'\n\naWord = 'aardvark'\n\nif aWord in wordSet:\n    print 'found word', aWord\nelse:\n    print 'word not found'\n</code>\n</pre>\n", "senID": 2}, {"text": ["Note: if aWord in wordSet is so much faster it isn't funny.", "If you're looking for a word closer to the end of the word list, set is nearly 60000 times faster for a 267000 word list.", "And it's still marginally faster even if you're looking for the very first word."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "if aWord in wordSet", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "so", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "60000", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "even", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}], [{"text": ["Everyone's given you good advice about how to do this, but do you really need to use python?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n grep aardvark wlist.txt\n</code>\n</pre>\n", "senID": 1}, {"text": ["It'll almost certainly destroy any python based solution for speed.", "fgrep will probably be even quicker."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Iteration on file objects includes newlines."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Try replacing word == match with word[0:-1] == match to remove the newline character at the end of word."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "word == match", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "word[0:-1] == match", "childNum": 0, "tag": "code", "childList": []}, {"text": "word", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: Alternately, replace word == match with word.rstrip() == match as suggested in this question."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "word == match", "childNum": 0, "tag": "code", "childList": []}, {"text": "word.rstrip() == match", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://stackoverflow.com/questions/275018/how-can-i-remove-chomp-a-newline-in-python", "text": "this question.", "childNum": 0, "tag": "a", "childList": []}]}], [{"code": "<pre>\n<code>\n file = open(f)\nwords = set( (line.strip() for line in file.readlines()) )\nfile.close()\n\nif match in words:\n    print \"The word has been found with a value of\", word\nelse:\n    print \"Word not found\"\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Here is my very simple suggestion:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "very", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n wordlist = map(str.strip, open(\"wlist.txt\", \"r\").readlines())\nif word in wordlist:\n   print \"The word has been found with a value of\", word\nelse:\n   print \"Word not found\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Your problem is much simpler to solve.", "You have not realized that you can read the entire list in memory at a very modest cost - your file is less than 1 MB, it fits perfectly well in memory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The solution to your problem is to read the entire thing into an array and use standard list methods to look for membership:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # this is the only thing you need to get all the words in memory\nwords = [w.strip() for w in open(\"words.txt\", \"rb\").readlines()]\n\n# this is the only thing you need to find wether a word is in the list\nprint 'aaron' in words\n# returns 'True'\n\n# now you can go around many times and ask for membership of any word, \n# or any list of words (use a loop) - the array is already in memory \n# and will stay there until you close the program - it's only 1 mega!\n</code>\n</pre>\n", "senID": 2}, {"text": ["It can be argued that my solution is not clever, but I think it is practical - premature optimization is the root of all evil, and by trying to write a clever loop, you are missing out in a perfectly simple approach that given your problem works perfectly well (by the way, the first call to the function takes less than a second for a 60-thousand-word text file, every search is also extremely fast)."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "premature optimization is the root of all evil", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "given your problem", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Notice: youdon't need aset(you don't care if a word is repeated - the answer is the same)."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "Notice: youdon't need aset(you don't care if a word is repeated - the answer is the same).", "childNum": 2, "tag": "strike", "pos": 0, "childList": [{"text": "don't need aset", "tag": "strong"}, {"text": "set", "tag": "code"}]}, {"text": "don't need aset", "childNum": 1, "tag": "strong", "childList": [{"text": "set", "tag": "code"}]}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Don't solve the wrong problem!"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["PS.", "A lot of people seem to think that 58k words is \"a lot\" - it is (58 + average length) kB (if the words are ~10 letters each, that's 580 kB - about half a meg).", "When I hear people saying that you should not open that in memory, I wonder how do they open their pictures!", "It is a paradigm that needs to be broken.", "People will claim \"but your program is not robust, because if the list becomes 100 million gizillion lines, it will break\", and that's fair in a world where the English language will increase its vocabulary by 10 orders of magnitude.", "We often forget that general means general for your domain."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "but your program is not robust, because if the list becomes 100 million gizillion lines, it will break", "childNum": 0, "tag": "em", "pos": 4, "childList": []}, {"text": "general", "childNum": 0, "tag": "em", "pos": 5, "childList": []}, {"text": "general for your domain", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Edit: As per @Chinmay comments, using a set over a list has dramatic access consequences.", "Using a 58K word list, I ran two 1000 access exercises: list, and set (access time in microseconds):"], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "Edit", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n container    min    max   mean\nlist           3   1646  724.4\nset            1     31    1.6\n</code>\n</pre>\n", "senID": 8}, {"text": ["So, as @Chinmay points out, the mean access time is almost three orders of magnitude smaller for a set.", "This can make a difference if you are accessing the words many times (which you presumably are)."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["So, I sand corrected and modify the code to:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n # create a set of words\nwords = set(w.strip() for w in open('file.txt').readlines())\n\n# test access using the `in` operator, as :\n'aaron' in words\n# will return True\n</code>\n</pre>\n", "senID": 11}, {"text": ["My point remains: the solution to this problem is much simpler than creating a class to implement the membership operator."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "class", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n class WordMatcher(object):\n    @classmethod\n    def fromFile(cls, fname):\n        with open(fname) as inf:\n            return cls(inf)\n\n    def __init__(self, words):\n        super(WordMatcher,self).__init__()\n        self.words = set(word.strip().lower() for word in words)\n\n    def __contains__(self, word):\n        return word.strip().lower() in self.words\n\n    def goodWords(self, lst):\n        _sw = self.words\n        for word in lst:\n            word = word.strip().lower()\n            if word in _sw:\n                yield word\n\nwordlist = WordMatcher.fromFile('wordlist.txt')\n\n'abase' in wordlist   # -&gt; True\nlist(wordlist.goodWords(['Abandon', 'abased\\n', 'xyzzy']))  # -&gt; ['abandon','abased']\n</code>\n</pre>\n", "senID": 0}], [{"text": ["The problem in the code you posted is that iterating over an open file includes the newline characters.", "Other answers deal with that issue."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "newline", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["This answer is to point out that the strategy is very inefficient if the search is to be done often. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If the search will be performed a number of times, then it is best to to store the word list as a Trie, which enables O(m) lookups, with m being the length of the searched string, while constructing the Trie has complexity similar to searching the word list for one word.", "The Trie can be stored to disk (pickled?", ") for fast retrieval."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "Trie", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Trie"}, {"text": "O(m)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "m", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Looking up a word against the dictionary using the posted code takes time proportional to the size of the dictionary, which is O(n).", "Building the Trie is O(n+C), with a big C, which makes it worth it only if there are going to be frequent searches."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "O(n)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "O(n+C)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "C", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I took a look, and the Web says that there are several implementations of Trie in Python ready to try ."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]