[[{"text": ["By explicit, do you mean \"explicitly passed as an argument to each class function\"?", "If so, then Python is the only one I know off-hand. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Most OO languages support this or self in some form, but most of them let you define class functions without always defining self as the first argument."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "this", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Depending on your point of view, Lua.", "To quote the reference: \"A call v:name(args) is syntactic sugar for v.name(v,args), except that v is evaluated only once.", "\"  You can also define methods using either notation.", "So you could say that Lua has an optional explicit self."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["F# (presumably from its OCAML heritage) requires an explicit name for all self-references; though the name is any arbitrary identifier e.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n override x.BeforeAnalysis() = \n    base.BeforeAnalysis()\n    DoWithLock x.AddReference\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here we're defining an overriding member function BeforeAnalysis which calls another member function AddReference.", "The identifier x here is arbitrary, but is required in both the declaration and any reference to members of the \"this\"/\"self\" instance."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "BeforeAnalysis", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "AddReference", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["The programming language Oberon 2 has an explicitly named but not explicitly passed 'this' or 'self' argument for member functions of classes (known as type bound procedures in Oberon terminology)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "named", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["The following example is an Insert method on a type Text, where the identifier 't' is specified to bind to the explicit 'this' or 'self' reference."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n PROCEDURE (t: Text) Insert (string: ARRAY OF CHAR; pos: LONGINT);\nBEGIN ...\nEND Insert;\n</code>\n</pre>\n", "senID": 2}, {"text": ["More details on Object Orientation in Oberon are here."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.statlab.uni-heidelberg.de/projects/oberon/kurs/www/Oberon2.OOP.html"}]}], [{"text": ["any Object-Oriented language has a notion of this or self within member functions."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Object-Oriented language", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Object-oriented%5Fprogramming"}]}], [{"text": ["Modula-3 does.", "Which is not too surprising since Python's class mechanism is a mixture of the ones found in Modula-3 and C++."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Modula-3", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Modula-3#Object_Oriented"}, {"text": "a mixture of the ones found in Modula-3 and C++", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html#"}]}], [{"text": ["many object oriented languages if not all of them"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["for example c++ support \"this\" instead of \"self\""], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["but you dont have to pass it, it is passed passively"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["hope that helps ;)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Clojure isn't an OOP language but does use explicit self parameters in some circumstances: most notably when you implement a protocol, and the \"self\" argument (you can name it anything you like) is the first parameter to a protocol method.", "This argument is then used for polymorphic dispatch to determine the right function implementation, e.g."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Clojure", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://clojure.org/"}]}, {"code": "<pre>\n<code>\n (defprotocol MyProtocol\n  (foo [this that]))\n\n(extend-protocol MyProtocol String\n  (foo [this that]\n    (str this \" and \" that)))\n\n(extend-protocol MyProtocol Long\n  (foo [this that]\n    (* this that)))\n\n(foo \"Cat\" \"Dog\")\n=&gt; \"Cat and Dog\"\n\n(foo 10 20)\n=&gt; 200\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also, the first parameter to a function is often used by convention to mean the object that is being acted upon, e.g.", "the following code to append to a vector:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n (conj [1 2 3] 4)\n=&gt; [1 2 3 4]\n</code>\n</pre>\n", "senID": 3}]]