[[{"text": ["Try this regular expression:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ^[^A]*((AA)+[^A]*)*$\n</code>\n</pre>\n", "senID": 1}, {"text": ["And if the As don\u2019t need to be consecutive:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "A", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n ^[^A]*(A[^A]*A[^A]*)*$\n</code>\n</pre>\n", "senID": 3}], [{"text": ["'A*' means match any number of A's.", "Even 0."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "'A*'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "A", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Here's how to match a string with an even number of a's, upper or lower:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n re.compile(r'''\n    ^\n    [^a]*\n    (\n        (\n            a[^a]*\n        ){2}\n    # if there must be at least 2 (not just 0), change the\n    # '*' on the following line to '+'\n    )* \n    $\n    ''',re.IGNORECASE|re.VERBOSE)\n</code>\n</pre>\n", "senID": 2}, {"text": ["You probably are using a as an example.", "If you want to match a specific character other than a, replace a with %s and then insert"], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "%s", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n [...]\n$\n'''%( other_char, other_char, other_char )\n[...]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["'*' means 0 or more occurences\n'AA' should do the trick."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The question is if you want the thing to match 'AAA'.", "In that case you would have to do something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n r = re.compile('(^|[^A])(AA)+(?!A)',)\nr.search(p)\n</code>\n</pre>\n", "senID": 2}, {"text": ["That would work for match even (and only even) number of'A'."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Now if you want to match 'if there is any even number of subsequent letters', this would do the trick:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n re.compile(r'(.)\\1')\n</code>\n</pre>\n", "senID": 5}, {"text": ["However, this wouldn't exclude the 'odd' occurences.", "But it is not clear from your question if you really want that."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Update:\nThis works for you test cases:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n re.compile('^([^A]*)AA([^A]|AA)*$')\n</code>\n</pre>\n", "senID": 8}], [{"text": ["First of all, note that /A*/ matches the empty string."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "/A*/", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Secondly, there are some things that you just can't do with regular expressions.", "This'll be a lot easier if you just walk through the string and count up all occurences of the letter you're looking for."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["A* means match \"A\" zero or more times."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For an even number of \"A\", try: (AA)+"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This searches for a block with an odd number of A's.", "If you found one, the string is bad for you:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (?&lt;!A)A(AA)*(?!A)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If I understand correctly, the Python code should look like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if re.search(\"(?&lt;!A)A(AA)*(?!A)\", \"AeAAi\"):\n   print \"fail\"\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Why work so hard coming up with a hard to read pattern?", "Just search for all occurrences of the pattern and count how many you find. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n len(re.findall(\"A\", \"AbcAbcAbcA\")) % 2 == 0\n</code>\n</pre>\n", "senID": 1}, {"text": ["That should be instantly understandable by all experienced programmers, whereas a pattern like \"(?\n\n"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Simple is better."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["It's impossible to count arbitrarily using regular expressions.", "For example, making sure that you have matching parenthesis.", "To count you need 'memory' which requires something at least as strong as a pushdown automaton, although in this case you can use the regular expression that @Gumbo provided."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "impossible", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "arbitrarily", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "pushdown automaton", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Pushdown_automaton"}]}, {"text": ["The suggestion to use finditeris the best workaround for the general case."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "finditer", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]