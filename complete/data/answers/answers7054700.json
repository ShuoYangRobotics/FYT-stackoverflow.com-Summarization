[[{"text": ["It sounds to me like you have to decide which you'd rather do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["1) Save the values so you don't have to recalculate them, but use more space to do so."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["2) Recalculate them each time, but save on space because you don't have to store them."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you think about it, no matter what kind of generator/list/whatever you're using, one of those two things has to happen.", "And I don't think there's a simple hard rule to say which is better.", "(Personally I'd say pick one and don't look back.", "You have your whole life ahead of you."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you frequently get an item at a known offset from a previously retrieved item, is to change .get to return not only the item, but it's position in the list.", "Then you could implement prevItem as:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": ".get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "prevItem", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def previtem(self, pos):\n    return self.itemlist[pos - 1]\n\nitem, pos = c.get(itemnum)\nitem2 = c.prevItem(pos)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If, instead, you are doing some sort of operation on item to get a new itemnum, you should store them in a dict instead of a list.", "This way, get is just a dictionary lookup (much faster than list search):"], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "item", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itemnum", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}, {"text": "get", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def get(self, itemnum):\n    return self.premade_dict[itemnum]\n</code>\n</pre>\n", "senID": 3}, {"text": ["So one way or the other you should be able to replace some searches with cheaper operations."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Depends how you want to use a generator.", "Generators are good at only executing code when it is really needed.", "Seems your for loop with break already does this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You could change your class interface though."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def getItems(cond):\n    # find item, remember index\n    yield item\n    # find previous item, possibly much more efficient with the index\n    yield previtem\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now upon calling getItems(), you can walk the returned generator for 1 or 2 items and only as much code as needed will be executed."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["A list of two thousand dictionaries is quite normal.", "A typical website admin has many such lists, I'd imagine.", "If you seldom have to deal with problems like this, you might be fine with an ad hoc solution-- it may be worth considering a dictionary of dictionaries too so you don't have to iterate through every key every time.", "But the more routine way to address this data structure, from what I gather, is to use a database.", "Each of your dictionaries can have some key (ideally the condition you're checking for in your loop).", "The database can be instructed to index the data by this key and if you look at the work it does to retrieve the dictionary you want, you may be surprised to find the answer is almost none-- it pretty much just cuts the deck to the card you requested, so to speak (though it does have to do some work to setup the index, which is something like a sort operation).  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python offers many great ways to map code to databases of all kinds.", "Check out the powerful, but complex sqlalchemy, the built-in std library sqlite3 module, or join me in experimenting with mongoengine and nosql databases.", "(There are many many more too of course, but you can easily find another post here with a general overview).", "Good luck."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You can try this subclass of OrderedDict.", "My earlier submission was incorrect (mentioned at the bottom):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "OrderedDict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from collections import OrderedDict\n\nclass MyOrderedDict(OrderedDict):\n    def index(self, key):\n        if key not in self.keys():\n            raise KeyError\n        return list(d.keys()).index(key)\n    def prev(self, key):\n        idx = self.index(key) - 1\n        if idx &lt; 0:\n            raise IndexError\n        return list(d.keys())[idx]\n    def next(self, key):\n        _list = list(d.keys())\n        idx = self.index(key)\n        if idx &gt; len(_list):\n            raise IndexError\n        return _list[idx+1]\n\n# &gt;&gt;&gt; d = MyOrderedDict(((3, 'Three'), (2, 'Two'), (4, 'Four'), (1, 'One')))\n# &gt;&gt;&gt; d.index(3)\n# 0\n# &gt;&gt;&gt; d.index(2)\n# 1\n# &gt;&gt;&gt; d.prev(2)\n# 3\n# &gt;&gt;&gt; d.prev(3)\n# Traceback (most recent call last):\n#   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n#   File \"&lt;stdin&gt;\", line 9, in prev\n# IndexError\n# &gt;&gt;&gt; d.next(4)\n# 1\n# &gt;&gt;&gt; d.next(1)\n# Traceback (most recent call last):\n#   File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n#   File \"&lt;stdin&gt;\", line 16, in next\n# IndexError: list index out of range\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit - as @agf commented below, this is incorrect."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You're looking for a fast way to retrieve an item frommyClass, so you should use a dictionary.", "But at the same time you want the data to be in some sort of order, so that you can do aprevItemon it.", "Why don't you store your data in acollections.OrderedDictadded in Python 2.7, 3.1.ref"], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "You're looking for a fast way to retrieve an item frommyClass, so you should use a dictionary.  But at the same time you want the data to be in some sort of order, so that you can do aprevItemon it.  Why don't you store your data in acollections.OrderedDictadded in Python 2.7, 3.1.ref", "childNum": 4, "tag": "strike", "pos": -1, "childList": [{"text": "myClass", "tag": "code"}, {"text": "prevItem", "tag": "code"}, {"text": "collections.OrderedDict", "tag": "code"}, {"text": "ref", "tag": "a"}]}, {"text": "myClass", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "prevItem", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "collections.OrderedDict", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"href": "http://www.python.org/dev/peps/pep-0372/", "text": "ref", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["You should use a list because you can do one trivial optimization with it: Sort it by the attribute you're looking for (in .get) and do a binary search."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": ".get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In a list of 2000 items the average number of comparisons goes down from 1000 to 10!", "Getting the previous (and next) item becomes trivial too."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["See the bisect module for the bisection algorithm."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "the bisect module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/bisect.html"}]}]]