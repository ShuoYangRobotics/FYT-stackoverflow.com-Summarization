[[{"text": ["Assuming that list1, list2, etc, all are numerical, consider using numpy arrays instead of lists.", "For large sequences of integers or floats you'll see a huge speedup."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "list1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["If you go that route, your loop above could be written like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n ctr = np.arange(N)\nlist1 = n1 - n1[0] - ctr * c1\nlist2 = n2 - n2[0] - ctr * c2\nlist3 = c3 - ctr\nlist4 = c4 - ctr\n</code>\n</pre>\n", "senID": 2}, {"text": ["And as a full stand-alone example for timing:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import numpy as np\nN = 100000\n\n# Generate some random data...\nn1 = np.random.random(N)\nn2 = np.random.random(N)\nc1, c2, c3, c4 = np.random.random(4)\n\nctr = np.arange(N)\nlist1 = n1 - n1[0] - ctr * c1\nlist2 = n2 - n2[0] - ctr * c2\nlist3 = c3 - ctr\nlist4 = c4 - ctr\n</code>\n</pre>\n", "senID": 4}, {"text": ["Of course, if your list1, list2, etc are non-numerical (i.e.", "lists of python objects other than floats or ints), then this won't help."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "list1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["There was a bit of a mistake originally (see below) These are more properly cached."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # These can be cached as they do not change.\nbase_in1 = in1[0]\nbase_in2 = in2[0]\nfor ctr in xrange(N):\n    # these are being looked up several times. Look-ups take time in almost every\n    # language. Look them up once and then use the new value.\n    cin1 = in1[ctr]\n    cin2 = in2[ctr]\n    list1[ctr] = cin1 - base_in1 - ctr * c1\n    list2[ctr] = cin2 - base_in2 - ctr * c2\n    list3[ctr] = c3 - cin1\n    list4[ctr] = c4 - cin2\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Mistake below):"], "childNum": 0, "tag": "h2", "senID": 2, "childList": []}, {"text": ["Originally I thought that this could be solved by caching constants:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # these values never change\nctr1 = ctr * c1\nctr2 = ctr * c2\nin10 = ctr1 + in1[0]\nin20 = ctr2 + in2[0]\nfor ctr in xrange(N):\n    # these are being looked up several times. That costs time.\n    # look them up once and then use the new value.\n    cin1 = in1[ctr]\n    cin2 = in2[ctr]\n    list1[ctr] = cin1 - in10\n    list2[ctr] = cin2 - in20\n    list3[ctr] = c3 - cin1\n    list4[ctr] = c4 - cin2\n</code>\n</pre>\n", "senID": 4}, {"text": ["But as Tim pointed out, I had missed the ctr in my original attempt."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "ctr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Optimization depends on the compiler but there are a couple of things you can try.", "Glad to see you are profiling the code!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can try:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["From what I've noticed, Python is bad at successive mathematical expressions and will slow down tremendously.", "Your best options are likely to use numpy as someone else said so the code runs in C. One more Python optimization to try is to use list comprehensions.", "List comprehensions are usually faster than map."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n in = in1[0]\nlist1 = [x - in - i * c1 for i, x in enumerate(in1)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This method doesn't involve using xrange at all (uses Python's very strong iteration functions)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Example using timeit."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import timeit\n&gt;&gt;&gt; timeit.timeit(stmt=\"[x * 2 for x in xrange(1000)]\", number=10000)\n8.27007...\n&gt;&gt;&gt; timeit.timeit(stmt=\"map(lambda x: x * 2, xrange(1000))\", number=10000)\n19.5969...\n&gt;&gt;&gt; timeit.timeit(stmt=\"\"\"lst=[0]*1000\nfor x in xrange(1000):\n    lst[x] = x * 2\n\"\"\", number=10000)\n13.7785...\n# this last one doesn't actually do what you want it to do, but for comparison\n# it's faster because it doesn't have to store any data from the computation\n&gt;&gt;&gt; timeit.timeit(stmt=\"for x in xrange(1000): x * 2\", number=10000)\n6.98619...\n</code>\n</pre>\n", "senID": 4}, {"text": ["(if you need help constructing the other 4 list comprehensions, just comment)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Edit: Some timeit examples."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["You could try re-writing it as several loops:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for ctr in xrange(N):\n    list1[ctr] = in1[ctr] - in1[0] - ctr * c1\n\nfor ctr in xrange(N):\n    list2[ctr] = in2[ctr] - in2[0] - ctr * c2\n\nfor ctr in xrange(N):\n    list3[ctr] = c3 - in1[ctr]\n\nfor ctr in xrange(N):\n    list4[ctr] = c4 - in2[ctr]\n</code>\n</pre>\n", "senID": 1}, {"text": ["It may not be as stupid as it sounds.", "Measure it.", "One problem with this kind of code can be locality of reference.", "If you're jumping around memory you can work against cache.", "You may find zipping through arrays individually may be kinder on your cache. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You could also think of doing them in parallel threads."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["itertools.count is faster.", "map generates a list in Python 2, you'll want itertools.imap there."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "itertools.count", "tag": "a", "pos": 0, "childList": [{"text": "itertools.count", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/py3k/library/itertools.html#itertools.count"}, {"text": "itertools.count", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "map", "tag": "a", "pos": 1, "childList": [{"text": "map", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#map"}, {"text": "map", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/itertools.html#itertools.imap", "text": "itertools.imap", "childNum": 1, "tag": "a", "childList": [{"text": "itertools.imap", "tag": "code"}]}, {"text": "itertools.imap", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["A map only helps if you have random access.", "In your case, a list is the correct data type."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Try to extract the constantsin1[0] - ctr * c1andin2[0] - ctr * c2out of the loop.", "Opps.", "ctr is not a constant.", "You can try x1 = c1 and then x1 += c1 but I don't think the addition is much faster than multiply on todays CPUs."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "constantsin1[0] - ctr * c1andin2[0] - ctr * c2out of the loop", "childNum": 2, "tag": "s", "pos": 0, "childList": [{"text": "in1[0] - ctr * c1", "tag": "code"}, {"text": "in2[0] - ctr * c2", "tag": "code"}]}, {"text": "in1[0] - ctr * c1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "in2[0] - ctr * c2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "ctr", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Then, you should have a look at the array module or Numpy.", "Instead of creating list3 like in your code, create a copy of in1, invert all elements (*-1) and then add c3 to each element.", "The mass mutation methods of array/Numpy will make this much faster."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "array module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/array.html"}, {"text": "Numpy", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org/"}, {"text": "list3", "childNum": 0, "tag": "code", "childList": []}, {"text": "in1", "childNum": 0, "tag": "code", "childList": []}, {"text": "*-1", "childNum": 0, "tag": "code", "childList": []}, {"text": "c3", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Other than that, there is little you can do without touching the rest of the code.", "For example, instead of actually calculating list3 and list4, you could create objects that return the values when they are necessary.", "But my guess is that you need all values, so this wouldn't help."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "list3", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "list4", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["If that's not fast enough, you will have to use a different language or write a C module."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Use numpy.", "The loop gets replaced by a few differences of arrays, the evaluation of which is done in C. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org/"}]}], [{"text": ["It is somewhat faster to use list comprehensions to calculate the contents of your lists than to use a for loop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random\n\nN = 40000\nc1 = 4\nc2 = 9\nc3 = 11\nc4 = 8\nin1 = [random.randint(1, 50000) for _ in xrange(N)]\nin2 = [random.randint(1, 50000) for _ in xrange(N)]\nlist1 = [None for _ in xrange(N)]\nlist2 = [None for _ in xrange(N)]\nlist3 = [None for _ in xrange(N)]\nlist4 = [None for _ in xrange(N)]\nin1_0 = in1[0]\nin2_0 = in2[0]\n\ndef func():\n    for ctr in xrange(N):\n        list1[ctr] = in1[ctr] - in1_0 - ctr * c1\n        list2[ctr] = in2[ctr] - in2_0 - ctr * c2\n        list3[ctr] = c3 - in1[ctr]\n        list4[ctr] = c4 - in2[ctr]\n\ndef func2():\n    global list1, list2, list3, list4\n    list1 = [(in1[ctr] - in1_0 - ctr * c1) for ctr in xrange(N)]\n    list2 = [(in2[ctr] - in2_0 - ctr * c2) for ctr in xrange(N)]\n    list3 = [(c3 - in1[ctr]) for ctr in xrange(N)]\n    list4 = [(c4 - in2[ctr]) for ctr in xrange(N)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["And then timeit results:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n % python -mtimeit -s 'import flup' 'flup.func()'\n10 loops, best of 3: 42 msec per loop\n% python -mtimeit -s 'import flup' 'flup.func2()'\n10 loops, best of 3: 34.1 msec per loop\n</code>\n</pre>\n", "senID": 3}]]