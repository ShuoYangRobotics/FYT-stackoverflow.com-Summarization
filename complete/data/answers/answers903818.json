[[{"text": ["You can write a little helper decorator that will make the call for you.", "The advantage is that it's easy to tell who is going to call what by looking at the code.", "And you can add as many function calls as you want.", "It works like registering a callback function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from functools import wraps\n\ndef oncall(call):\n    def helper(fun):\n        @wraps(fun)\n        def wrapper(*args, **kwargs):\n            result = fun(*args, **kwargs)\n            call()\n            return result\n        return wrapper\n    return helper\n\nclass c1:\n   @classmethod\n   def f1(cls):\n      print 'f1'\n\nclass c2:\n   @classmethod\n   @oncall(c1.f1)\n   def f2(cls):\n      print 'f2'\n\n&gt;&gt;&gt; c2.f2()\nf2\nf1\n&gt;&gt;&gt; c1.f1()\nf1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I believe that what you are trying to do would fit into the realm of Aspect Oriented Programming.", "However I have never used this methodology and don't even know if it can/has been implemented in Python."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Aspect Oriented Programming", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Aspect-oriented%5Fprogramming"}]}, {"text": ["Edit I just took a look at the link I provided and saw that there are 8 Python implementations mentioned.", "So the hard work has already been done for you :-)"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "8 Python implementations", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Aspect-oriented%5Fprogramming#Implementations"}]}], [{"text": ["You can do aspect-oriented programming with function and method decorators since Python 2.2:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n @decorator(decorator_args)\ndef functionToBeDecorated(function_args) :\n    pass\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It really depends on why you don't want to call F2 directly from within F1.", "You could always create a third class (C3) which encapsulates both C1 and C2.", "When F3 is called, it will call both F1 and F2.", "This is known as the Mediator pattern - http://en.wikipedia.org/wiki/Mediator_pattern"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://en.wikipedia.org/wiki/Mediator_pattern", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Mediator_pattern"}]}], [{"text": ["Not knowing what is you are trying to achieve, i would suggest taking a look at pydispatcher.", "It allows you to implement the Observer pattern "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Basically, you register F2 with the dispatcher so that it will be called when a specific 'signal' is emitted.", "Your F1 'emits a signal' that says \"I've been called\".", "The dispatcher then calls F2 (or any number of functions that have registered themselves with that particular signal).", "Its actually really simpler than it sounds, easy to use, and de-couples your code (F1 does not need to know about F2)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(arhh..", "I'm a new user and not allowed to include hyperlinks, but pydispatcher is easy to google for)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You catch all accesses to F1 with __getattr__ .", "This will allow you to do extra processing or return your own function in place of F1"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__getattr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class C1:\n  def __getattr__(self,name):\n    if name == 'F1': C2.F2()\n    return self[name]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I should warn you that this will call C2.F2 even if F1 is only being accessed (not run).", "It's rare but not impossible that F1 might simply be accessed for another purpose like f = myC1.F1 .", "To run F2 only on a call of F1 you need to expand this example to combine F2 with the returned function object.", "in other words:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "f = myC1.F1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def F1F2():\n   self.F1()\n   C2.F2()\nreturn F1F2\n</code>\n</pre>\n", "senID": 3}]]