[[{"text": ["I don't know about the local scope, but you could provide an alternative global name space temporarily.", "Something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import types\n\ndef my_decorator(fn):\n    def decorated(*args,**kw):\n        my_globals={}\n        my_globals.update(globals())\n        my_globals['z']='value of z'\n        call_fn=types.FunctionType(fn.func_code,my_globals)\n        return call_fn(*args,**kw)\n    return decorated\n\n@my_decorator\ndef func(x, y):\n    print z\n\nfunc(0,1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which should print \"value of z\""], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Echoing Hop's answer"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python doesn't have dynamically scoped variables, but you can simulate it.", "Here's an example that simulates it by creating a global binding, but restores the previous value on exit:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://codepad.org/6vAY8Leh"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://codepad.org/6vAY8Leh", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://codepad.org/6vAY8Leh"}]}, {"code": "<pre>\n<code>\n def adds_dynamic_z_decorator(f):\n  def replacement(*arg,**karg):\n    # create a new 'z' binding in globals, saving previous\n    if 'z' in globals():\n      oldZ = (globals()['z'],)\n    else:\n      oldZ = None\n    try:\n      globals()['z'] = None\n      #invoke the original function\n      res = f(*arg, **karg)\n    finally:\n      #restore any old bindings\n      if oldZ:\n        globals()['z'] = oldZ[0]\n      else:\n        del(globals()['z'])\n    return res\n  return replacement\n\n@adds_dynamic_z_decorator\ndef func(x,y):\n  print z\n\ndef other_recurse(x):\n  global z\n  print 'x=%s, z=%s' %(x,z)\n  recurse(x+1)\n  print 'x=%s, z=%s' %(x,z)\n\n@adds_dynamic_z_decorator\ndef recurse(x=0):\n  global z\n  z = x\n  if x &lt; 3:\n    other_recurse(x)\n\nprint 'calling func(1,2)'\nfunc(1,2)\n\nprint 'calling recurse()'\nrecurse()\n</code>\n</pre>\n", "senID": 3}, {"text": ["I make no warranties on the utility or sanity of the above code.", "Actually, I warrant that it is insane, and you should avoid using it unless you want a flogging from your Python peers."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "is", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["This code is similar to both eduffy's and John Montgomery's code, but ensures that 'z' is created and properly restored \"like\" a local variable would be -- for instance, note how 'other_recurse' is able to see the binding for 'z' specified in the body of 'recurse'.  "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["a) don't do it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["b) seriously, why would you do that?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["c) you could declare z as global within your decorator, so z will not be in globals() until after the decorator has been called for the first time, so the assert won't bark."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["d) why??"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I'll first echo the \"please don't\", but that's your choice.", "Here's a solution for you:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n assert 'z' not in globals ()\n\nclass my_dec:\n    def __init__ (self, f):\n    \tself.f = f\n    def __call__ (self,x,y):\n\t    z = x+y\n\t    self.f(x,y,z)\n\n@my_dec\ndef func (x,y,z):\n    print z\n\nfunc (1,3)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It does require z in the formal parameters, but not the actual."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "z", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I could probably get a similar effect from using the class infrastructure as well, but I wanted to see if it was doable with raw functions."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "I could probably get a similar effect from using the class infrastructure as well, but I wanted to see if it was doable with raw functions.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Well, Python is an object-oriented language.", "You should do this in a class, in my opinion.", "Making a nice class interface would surely simplify your problem.", "This isn't what decorators were made for."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "isn't", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}], [{"text": ["Explicit is better than implicit."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Is this good enough?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def provide_value(f):\n    f.foo = \"Bar\"\n    return f\n\n@provide_value\ndef g(x):\n    print g.foo\n</code>\n</pre>\n", "senID": 2}, {"text": ["(If you really want evil, assigning to f.func_globals seems fun."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Others have given a few ways of making a working decorator, many have advised against doing so because it's so stylistically different from normal python behavior that it'll really confuse anyone trying to understand the code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you're needing to recalculate things a lot, would it make sense to group them together in an object?", "Compute z1...zN in the constructor, then the functions that use these values can access the pre-computed answers as part of the instance."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]