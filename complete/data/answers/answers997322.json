[[{"text": ["Bubble sort is a horrible algorithm to sort with.", "That is quite possibly the reason.", "If speed is necessary, I would try another algorithm like quick sort or merge sort. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["That's not quite a bubble sort... unless I've made a trivial error, this would be closer to a python bubble sort:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n swapped = True\nwhile swapped:\n  swapped = False\n  for i in xrange(len(l)-1):\n    if l[i] &gt; l[i+1]:\n      l[i],l[i+1] = l[i+1],l[i]\n      swapped = True\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that the whole idea is that the \"bubble\" moves along the array, swapping adjacent values until it moves through the list, with nothing swapped.", "There are a few optimizations that can be made (such as shrinking the size of the inner loop), but they are usually only worth bothering with when you are \"homework oriented\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: Fixed length() -> len()"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Bubble sort may be horrible and slow etc, but would you rather have an O(N^2) algorithm over 100 items, or O(1) one that required a dial-up connection?"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "horrible", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "slow", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["And a list of 100 itmes shouldnt take 2 hours.", "I don't know python, but are you by any chance copying entire lists when you make those assignments?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here's a bubble sort in Python from Google:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def bubbleSort(theList, max):\n    for n in range(0,max): #upper limit varies based on size of the list\n        temp = 0\n        for i in range(1, max): #keep this for bounds purposes\n            temp = theList[i]\n            if theList[i] &lt; theList[i-1]:\n                theList[i] = theList[i-1]\n                theList[i-1] = temp\n</code>\n</pre>\n", "senID": 3}, {"text": ["and another, from wikipedia:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def bubblesort(l):\n    \"Sorts l in place and returns it.\"\n    for passesLeft in range(len(l)-1, 0, -1):\n        for index in range(passesLeft):\n            if l[index] &lt; l[index + 1]:\n               l[index], l[index + 1] = l[index + 1], l[index]\n    return l\n</code>\n</pre>\n", "senID": 5}, {"text": ["The order of bubble sort is N(N-1).", "This is essentially N^2, because for every element you require to scan the list and compare every element."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["By the way, you will probably find C++ to be the fastest, then Java, then Python."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["What do you mean by numpy solution ?", "Numpy has some sort facilities, which are instantenous for those reasonably small arrays:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy as np\na = np.random.randn(100000)\n# Take a few ms on a decent computer\nnp.sort(a)\n</code>\n</pre>\n", "senID": 1}, {"text": ["There are 3 sorts of sort algorithms available, all are Nlog(N) on average."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I believe you mentioned that you were trying to use that as a benchmark to compare speeds."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I think generally Python is a bit faster than Ruby, but not really near Java/C/C++/C#.", "Java is within 2x of the C's, but all the interpreted languages were around 100x slower.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You might Google \"Programming Language Game\" for a LOT of comparisons of apps/languages/etc.", "Check out a Python JIT for possibly better performance."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You might also compare it to Ruby to see a more fair test.  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Edit: Just for fun (nothing to do with the question) check this--"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n public class Test {\n    public static void main(String[]s) {\n        int size=Integer.valueOf(s[0]).intValue();\n        Random r=new Random();\n        int[] l=new int[size];\n        for(int i=0;i&lt;size;i++)\n            l[i]=r.nextInt();\n        long ms=(new Date()).getTime();\n        System.out.println(\"built\");\n        if(fast) {\n            Arrays.sort(l);\n        else {\n            int temp;\n            for(int i=0;i&lt;size;i++)\n                for(int j=0;j&lt;size;j++)\n                    if(l[i]&gt;l[j]) {                        \n                        temp=l[i];\n                        l[j]=l[i];\n                        l[j]=temp;                        \n                    }\n            }\n        ms=(new Date()).getTime()-ms;\n        System.out.println(\"done in \"+ms/1000);\n    }\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["The fun thing about this:  The Java run times are on the order of:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\nArray size  Slow Time   Fast time\n 100k         2s          0s\n  1M         23s          0s\n 10M         39m          2s\n100M         NO          23s\n</pre>\n", "senID": 7}, {"text": ["Not that this addition has anything to do with the question, but holy cow the built-in impelemntation is FAST.", "I think it took longer to generate than sort (Guess that makes sense with calls to Random and memory allocation."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Had to go into the CLI and -Xmx1000M to get that last one to even run."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["For one, you're doing too many loops.", "Your inner loop should proceed from i + 1 to the end of the list, not from 0.", "Secondly, as noted by others, bubble sort has a O(N^2) complexity so for 100000 elements, you are looping 10,000,000,000 times.", "This is compounded by the fact that looping is one of the areas where interpreted languages have the worst performance.", "It all adds up to incredibly poor performance.", "This is why any computations that require such tight looping are usually written in C/C++ and wrapped for use by languages like Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Here some code I put together to compare a base bubble sort against a more streamlined version (base vs modified) - the modified is about 2-3 times faster, still a slow sort, but faster"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from array import *\nfrom random import *\nfrom time import *\n\ndef randarray(typecode, numElements, minValue, maxValue):\n    a = array(typecode)\n    for i in xrange(0, numElements):\n        a.append(randint(minValue, maxValue))\n    return a\n\ndef basesort(l):\n    for i in xrange(len(l)):\n        for j in xrange(len(l)):\n            if l[i]&lt;l[j]:\n                l[i], l[j] = l[j], l[i]\n    return l\n\ndef modifiedsort(l):\n    NotComplete = True\n    i = 0\n    arange = xrange(len(l))\n    while NotComplete:\n        NotComplete = False\n        for j in xrange(len(l) - i):\n            if l[i]&lt;l[j]:\n                l[i], l[j] = l[j], l[i]\n                NotComplete = True\n        i += 1\n\nNum = 1000\nb = randarray('i', Num, 1, 100000)\nm = b[:]\n\nprint 'perform base bubble sort'\nt = time()\nbasesort(b)\nbasetime =  time() - t\nprint basetime\n#print a\nprint 'complete'\n\nprint 'perform modified bubble sort'\nt = time()\nmodifiedsort(m)\nmodtime =  time() - t\nprint modtime\n#print a\nprint 'complete'\n\nprint 'mod sort is ', basetime / modtime,' fast then base sort'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think that you are basically wasting your time using bubble on such a large dataset.", "There are 3 reasons why it is slow:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["1) Python is slow\n2) Bubble sort is slow\n3) The bubble sort listed is coded incorrectly/inefficiently."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Regardless of how it is coded, it will be O(N^2).", "Why not use a merge/tree sort ..or if you want to try quicksort (also worst case O(N^2)) it might be faster for your particular dataset.", "I believe quicksort is empirically faster if the data already has a lot of ordering in it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Bubblesort in general does not scale well to most possible inputs as the number of elements in the input grows.", "(I.e., it's O(N^2)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As N grows, given a random input array of size N, you are much less likely to get an array that sorts quickly with bubblesort (e.g., almost sorted arrays).", "You are far more likely to get an array that takes a long time to sort."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["However, the real kicker here is that the code you posted is not a bubble sort.", "Traditionally, bubblesort will terminate early if no swaps were made as well as not attempt to swap values that are already sorted.", "(After P number of passes, the P last items will be in the correct order, so you don't need to process them.", ") The actual code posted will always examine every pair in the array, so it will always run the inner loop N^2 times.", "For 100000 elements, that's 10000000000 iterations."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Bubble sort makes  O(N2) compare operations (or iterations).", "For N = 100,000, that means that there will be 10,000,000,000 iterations.", "If that takes 2 hours (call it 10,000 seconds), then it means you get 1,000,000 iterations per second - or 1 microsecond per iteration.", "That's not great speed, but it isn't too bad.", "And I'm waving hands and ignoring constant multiplication factors."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "2", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}]}, {"text": ["If you used a quicksort, then you'd get Nlog(N) iterations, which would mean about 1,000,000 iterations, which would take 1 second in total.", "(log10(N) is 5; I rounded it up to 10 for simplicity."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "10", "childNum": 0, "tag": "sub", "pos": 1, "childList": []}]}, {"text": ["So, you have just amply demonstrated why bubble sort is inappropriate for large data sets, and 100,000 items is large enough to demonstrate that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you're interested in making your own sort, you can change a bubble sort to a comb sort with just a couple lines of code.", "Comb sort is nearly as good as the best sorts.", "Of course, making your own sort is best left as a learning exercise."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://en.wikipedia.org/wiki/Comb_sort"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://en.wikipedia.org/wiki/Comb_sort", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Comb_sort"}]}], [{"text": ["That doesn't look like bubble sort to me, and if it is, it's a very inefficient implementation of it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Because it is going execute the comparison and possibly the swap 100,000 x 100,000 times.", "If the computer is fast enough to execute the innermost statement 1,000,000 times per second, that still is 167 minutes which is slightly short of 3 hours."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["On a side note, why are there so many of these inane questions on SO?", "Isn't being able to do simple algebra a prerequisite for programming?", ";-)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Isn't being able to do simple algebra a prerequisite for programming?", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.codinghorror.com/blog/archives/001249.html"}]}], [{"text": ["First of all, for the purpose of this reply, I'm assuming - since you claim it yourself - that you're only doing this to benchmark different languages.", "So I won't go into \"bubble sort is just slow\" territory.", "The real question is why it's so much slower in Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The answer is that Python is inherently much slower than C++ or even Java.", "You don't see it in a typical event-driven or I/O-bound application, since there most time is spent either idling while waiting for input, or waiting for I/O calls to complete.", "In your case, however, the algorithm is entirely CPU bound, and thus you are directly measuring the performance of Python bytecode interpreter.", "Which, by some estimates, is 20-30x slower than executing the corresponding native code, which is what happens with both C++ and Java."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In general, any time you write a long-running CPU-bound loop in Python, you should expect this kind of performance.", "The only way to fix this is to move the entire loop into C. Moving just the body (e.g.", "using NumPy) won't help you much, since loop iteration itself will still be executed by Python intepreter."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "the entire loop", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["Like the other posts say, bubble sort is horrible.", "It pretty much should be avoided at all costs due to the bad proformance, like you're experiencing.", "Luckily for you there are lots of other sorting algorithms, http://en.wikipedia.org/wiki/Sorting_algorithm, for examples."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "http://en.wikipedia.org/wiki/Sorting_algorithm", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Sorting%5Falgorithm"}]}, {"text": ["In my experience in school is that quicksort and mergesort are the other two basic sorting algorithms introduced with, or shortly after, bubble sort.", "So I would recommend you look into those for learning more effective ways to sort."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If you must code your own, use an insertion sort.", "Its about the same amount of code, but several times faster."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I forgot to add, if you have some idea of the size of the dataset and the distribution of keys then you can use a radix sort which would be O(N).", "To get the idea of radix sort, consider the case where you are sorting say numbers more or less distributed between 0, 100,000.", "Then you just create something similar to a hash table, say an array of 100,000 lists, and add each number to the bucket.", "Here's an implementation I wrote in a few minutes that generates some random data, sorts it, and prints out a random segment.", "The time is less than 1 sec to execute for an array of 100,000 integers."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Option Strict On\nOption Explicit On"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Module Module1"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Private Const MAX_SIZE As Integer = 100000\nPrivate m_input(MAX_SIZE) As Integer\nPrivate m_table(MAX_SIZE) As List(Of Integer)\nPrivate m_randomGen As New Random()\nPrivate m_operations As Integer = 0\n\nPrivate Sub generateData()\n    ' fill with random numbers between 0 and MAX_SIZE - 1\n    For i = 0 To MAX_SIZE - 1\n        m_input(i) = m_randomGen.Next(0, MAX_SIZE - 1)\n    Next\n\nEnd Sub\n\nPrivate Sub sortData()\n    For i As Integer = 0 To MAX_SIZE - 1\n        Dim x = m_input(i)\n        If m_table(x) Is Nothing Then\n            m_table(x) = New List(Of Integer)\n        End If\n        m_table(x).Add(x)\n        ' clearly this is simply going to be MAX_SIZE -1\n        m_operations = m_operations + 1\n    Next\nEnd Sub\n\n Private Sub printData(ByVal start As Integer, ByVal finish As Integer)\n    If start &lt; 0 Or start &gt; MAX_SIZE - 1 Then\n        Throw New Exception(\"printData - start out of range\")\n    End If\n    If finish &lt; 0 Or finish &gt; MAX_SIZE - 1 Then\n        Throw New Exception(\"printData - finish out of range\")\n    End If\n    For i As Integer = start To finish\n        If m_table(i) IsNot Nothing Then\n            For Each x In m_table(i)\n                Console.WriteLine(x)\n            Next\n        End If\n    Next\nEnd Sub\n\n' run the entire sort, but just print out the first 100 for verification purposes\nPrivate Sub test()\n    m_operations = 0\n    generateData()\n    Console.WriteLine(\"Time started = \" &amp; Now.ToString())\n    sortData()\n    Console.WriteLine(\"Time finished = \" &amp; Now.ToString &amp; \" Number of operations = \" &amp; m_operations.ToString())\n    ' print out a random 100 segment from the sorted array\n    Dim start As Integer = m_randomGen.Next(0, MAX_SIZE - 101)\n    printData(start, start + 100)\nEnd Sub\n\nSub Main()\n    test()\n    Console.ReadLine()\nEnd Sub\n</code>\n</pre>\n", "senID": 3}, {"text": ["End Module\nTime started = 6/15/2009 4:04:08 PM\nTime finished = 6/15/2009 4:04:08 PM Number of operations = 100000\n21429\n21430\n21430\n21431\n21431\n21432\n21433\n21435\n21435\n21435\n21436\n21437\n21437\n21439\n21441\n..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You can do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l.reverse()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Script ee.py:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "ee.py", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n l = []\nfor i in xrange(100000):\n    l.append(i)\n\nl.reverse()\n</code>\n</pre>\n", "senID": 3}, {"text": ["lyrae@localhost:~/Desktop$ time python ee.py"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n real    0m0.047s\nuser    0m0.044s\nsys    0m0.004s\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Basically you are just looping 10 billion times, and that's going to be slow in any interpreted language.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The reason why we don't do everything in assembly is because speed is traded against clarity, pre-written libraries, and ease of implementing specific algorithms or concepts.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["None of which are applicable to simply looping 10 billion times while maybe swapping a couple of values.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you're actually wanting a faster python implementation of this, then use one of the JIT versions (PyPy, Psyco), they should speed this up considerably."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["But really, you're testing is flawed: you're testing the wrong thing.", "There's no room for tradeoffs of speed vs utility in a simple loop.", "So, no oppurtunity to say the performance hit of a higher level language is worth it: code it in assembly or at least C."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]