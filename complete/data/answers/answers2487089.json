[[{"text": ["Really-thorough unit tests are the most important technique (yes, I do always aim for 100% coverage), as they also catch many other typos (e.g.", "where I write + and meant -), off-by-one issues, etc.", "Integration and load tests exercising every feature are the second line of defense against all kinds of errors (mostly, though, deeper and harder ones;-)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "-", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Next are tools such as pylint and pychecker and colorizing editors (I don't use real IDEs, but they would also help similarly to how my trusty gvim editor does;-)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "pylint", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.logilab.org/857"}, {"href": "http://pychecker.sourceforge.net/", "text": "pychecker", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Techniques such as mandatory code reviews (e.g., cfr a video of an interview of mine on the subject here), while crucial, should focus on other issues -- issues that automated tools just won't catch, such as completeness and correctness of comments/docstrings, choice of good/speedy algorithms, and the like (see here for a summary of the talk I gave on the subject at the same conference as I got that interview at, and a link to the slides' PDF)."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://news.oreilly.com/2008/07/alex-martelli-at-oscon-googles.html"}, {"text": "other", "childNum": 0, "tag": "em", "childList": []}, {"text": "won't", "childNum": 0, "tag": "em", "childList": []}, {"href": "http://www.oscon.com/oscon2008/public/schedule/detail/2538", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["There are errors other than \"typos\".", "If you don't test something, knowing that something's found misspelled variable names won't assure you of much anyway."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Some editors (for example, NetBeans) analyse your code and underline \"suspicious\" parts, for example unused variables, which may be sign of a typo.", "NB also highlights the identifier above the cursor elsewhere on the screen, which also helps."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Of course, no clever IDE trick can replace proper testing."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["TDD -- write your tests first, then the simplest code to pass the test.", "That way you can be more sure that you don't have any untested code.", "This will help make sure you have fewer typos or other errors in your code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Pair programming/code reviews -- two pairs of eyes are better than one pair."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["IDE with intellisense -- not a panacea, but a great help in not making typos.", "If you use intellisense, you typically get substitution errors, not typos.", "These shouldn't be hard to find with tests."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["In my case, I use unit testing extensively (developing in Python).", "Because there are many lightweight testing frameworks well integrated into the language (or IDE if you prefer), using them cause you almost no pain ;)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Look at this example: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def unpack_args(func):\n    def deco_func(*args):\n        if isinstance(args, tuple):\n            args = args[0]\n\n        return func(*args)\n\n    return deco_func\n\n\ndef func1(*args):\n    \"\"\"\n    &gt;&gt;&gt; func1(1,2,3)\n    (1, 2, 3)\n    &gt;&gt;&gt; func1(*func2(1,2,3))\n    (1, 2, 3)\n    &gt;&gt;&gt; func1(func2(1,2,3))\n    ((1, 2, 3),)\n    \"\"\"\n    return args\n\ndef func2(*args):\n    \"\"\"\n    &gt;&gt;&gt; func2(1,2,3)\n    (1, 2, 3)\n    \"\"\"\n    return args\n\n@unpack_args\ndef func3(*args):\n    return args\n\n\ndef test():\n    \"\"\"\n    &gt;&gt;&gt; func3(func2(1,2,3))\n    (1, 2, 3)\n    \"\"\"\n    import doctest\n    doctest.testmod(verbose=True)\n\n\ntest()\n\n    -----------------------------\n    Results: \n\nTrying:\n    func1(1,2,3)\nExpecting:\n    (1, 2, 3)\nok\nTrying:\n    func1(*func2(1,2,3))\nExpecting:\n    (1, 2, 3)\nok\nTrying:\n    func1(func2(1,2,3))\nExpecting:\n    ((1, 2, 3),)\nok\nTrying:\n    func2(1,2,3)\nExpecting:\n    (1, 2, 3)\nok\nTrying:\n    func3(func2(1,2,3))\nExpecting:\n    (1, 2, 3)\nok\n3 items had no tests:\n    __main__\n    __main__.func3\n    __main__.unpack_args\n3 items passed all tests:\n   3 tests in __main__.func1\n   1 tests in __main__.func2\n   1 tests in __main__.test\n5 tests in 6 items.\n5 passed and 0 failed.\nTest passed.\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I presume by 'typo' you mean mistyping variable/function/class names.", "This is less of an issue in Python than in Perl, since Perl (and I believe Ruby) by default will automatically create a variable and initialise it to zero or \"\" on its first use.", "Python does not do this since it is an error to use a variable that has not been explicitly created, so in that sense it is already in 'strict' mode."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I use Vim with the pyflakes plugin, which underlines most kinds of typos as soon as you type them.", "I also use pylint and pychecker frequently since they can catch many other kinds of errors."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "pyflakes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.vim.org/scripts/script.php?script_id=2441"}]}, {"text": ["Another thing I do is make heavy use of Vim's auto completion - I only type a name in full once, then on subsequent uses of the name type the first few letters and use  &lt;ctrl-n&gt; or &lt;ctrl-p&gt; to cycle through the matches."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "&lt;ctrl-n&gt;", "childNum": 1, "tag": "kbd", "pos": 0, "childList": [{"text": "&lt;ctrl-n&gt;", "tag": "code"}]}, {"text": "&lt;ctrl-n&gt;", "childNum": 0, "tag": "code", "childList": []}, {"text": "&lt;ctrl-p&gt;", "childNum": 1, "tag": "kbd", "childList": [{"text": "&lt;ctrl-p&gt;", "tag": "code"}]}, {"text": "&lt;ctrl-p&gt;", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I also use Test Driven Development with the aim of 100% unit test coverage."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I find that the combination of all these practices means that problems caused by typos are virtually non-existent."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Many unit test tools can show the percentage of lines they tested.", "The closer this percentage is to 100% the less likely variable name typo was done."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I write all my Python code in eclipse IDE.", "As Mladen Jablanovi\u0107 has suggested, eclipse underlines suspicious parts."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Next step is to run the code.", "Now there are two kinds of errors that I am likely to face."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Hope this helps"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["In ruby, a misspelled local variable would cause the program to die horribly, which is fine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A misspelled instance variable doesn't cause the program to die horribly, which is bad.", "To detect such cases, use warnings.", "Unfortunately, you can't easily tell ruby to treat warnings as errors."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "use warnings", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://eigenclass.org/hiki/ruby-warnings-SEX-and-stds"}, {"text": "treat warnings as errors", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/660737/can-you-ask-ruby-to-treat-warnings-as-errors"}]}], [{"text": ["In Groovy, the abstract syntax tree (AST) that makes up a program is readily available.", "So tools can be written that inspect the AST and issue warnings for things that are probably errors."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, GroovyLint will warn you if you try to call a method that doesn't exist at compile-time, but is very close to one that does exist. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "GroovyLint", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.groovylint.com"}]}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Test{\n    static def foobar(){ return 5; }\n}\n\nTest.fooBar() //Here GroovyLint suggests calling foobar instead of fooBar.\n</code>\n</pre>\n", "senID": 3}]]