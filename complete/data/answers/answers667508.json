[[{"text": ["Here the simplest algorithm, if you want just to drop messages when they arrive too quickly (instead of queuing them, which makes sense because the queue might get arbitrarily large):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n rate = 5.0; // unit: messages\nper  = 8.0; // unit: seconds\nallowance = rate; // unit: messages\nlast_check = now(); // floating-point, e.g. usec accuracy. Unit: seconds\n\nwhen (message_received):\n  current = now();\n  time_passed = current - last_check;\n  last_check = current;\n  allowance += time_passed * (rate / per);\n  if (allowance &gt; rate):\n    allowance = rate; // throttle\n  if (allowance &lt; 1.0):\n    discard_message();\n  else:\n    forward_message();\n    allowance -= 1.0;\n</code>\n</pre>\n", "senID": 1}, {"text": ["There are no datastructures, timers etc.", "in this solution and it works cleanly :) To see this, 'allowance' grows at speed 5/8 units per seconds at most, i.e.", "at most five units per eight seconds.", "Every message that is forwarded deducts one unit, so you can't send more than five messages per every eight seconds."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A Token Bucket is fairly simple to implement."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Start with a bucket with 5 tokens."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Every 5/8 seconds: If the bucket has less than 5 tokens, add one."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Each time you want to send a message: If the bucket has \u22651 token, take one token out and send the message.", "Otherwise, wait/drop the message/whatever."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["(obviously, in actual code, you'd use an integer counter instead of real tokens and you can optimize out the every 5/8s step by storing timestamps)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "hr", "senID": 5}, {"text": ["Reading the question again, if the rate limit is fully reset each 8 seconds, then here is a modification:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Start with a timestamp, last_send, at a time long ago (e.g., at the epoch).", "Also, start with the same 5-token bucket."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "last_send", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Strike the every 5/8 seconds rule."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Each time you send a message: First, check if last_send \u2265 8 seconds ago.", "If so, fill the bucket (set it to 5 tokens).", "Second, if there are tokens in the bucket, send the message (otherwise, drop/wait/etc.).", "Third, set last_send to now."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "last_send", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "last_send", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["That should work for that scenario."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"tag": "hr", "senID": 11}, {"text": ["I've actually written an IRC bot using a strategy like this (the first approach).", "Its in Perl, not Python, but here is some code to illustrate:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["The first part here handles adding tokens to the bucket.", "You can see the optimization of adding tokens based on time (2nd to last line) and then the last line clamps bucket contents to the maximum (MESSAGE_BURST)"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n my $start_time = time;\n    ...\n    # Bucket handling\n    my $bucket = $conn-&gt;{fujiko_limit_bucket};\n    my $lasttx = $conn-&gt;{fujiko_limit_lasttx};\n    $bucket += ($start_time-$lasttx)/MESSAGE_INTERVAL;\n    ($bucket &lt;= MESSAGE_BURST) or $bucket = MESSAGE_BURST;\n</code>\n</pre>\n", "senID": 14}, {"text": ["$conn is a data structure which is passed around.", "This is inside a method that runs routinely (it calculates when the next time it'll have something to do, and sleeps either that long or until it gets network traffic).", "The next part of the method handles sending.", "It is rather complicated, because messages have priorities associated with them."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n # Queue handling. Start with the ultimate queue.\n    my $queues = $conn-&gt;{fujiko_queues};\n    foreach my $entry (@{$queues-&gt;[PRIORITY_ULTIMATE]}) {\n            # Ultimate is special. We run ultimate no matter what. Even if\n            # it sends the bucket negative.\n            --$bucket;\n            $entry-&gt;{code}(@{$entry-&gt;{args}});\n    }\n    $queues-&gt;[PRIORITY_ULTIMATE] = [];\n</code>\n</pre>\n", "senID": 16}, {"text": ["That's the first queue, which is run no matter what.", "Even if it gets our connection killed for flooding.", "Used for extremely important thinks, like responding to the server's PING.", "Next, the rest of the queues:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n # Continue to the other queues, in order of priority.\n    QRUN: for (my $pri = PRIORITY_HIGH; $pri &gt;= PRIORITY_JUNK; --$pri) {\n            my $queue = $queues-&gt;[$pri];\n            while (scalar(@$queue)) {\n                    if ($bucket &lt; 1) {\n                            # continue later.\n                            $need_more_time = 1;\n                            last QRUN;\n                    } else {\n                            --$bucket;\n                            my $entry = shift @$queue;\n                            $entry-&gt;{code}(@{$entry-&gt;{args}});\n                    }\n            }\n    }\n</code>\n</pre>\n", "senID": 18}, {"text": ["Finally, the bucket status is saved back to the $conn data structure (actually a bit later in the method; it first calculates how soon it'll have more work)"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"code": "<pre>\n<code>\n # Save status.\n    $conn-&gt;{fujiko_limit_bucket} = $bucket;\n    $conn-&gt;{fujiko_limit_lasttx} = $start_time;\n</code>\n</pre>\n", "senID": 20}, {"text": ["As you can see, the actual bucket handling code is very small \u2014 about four lines.", "The rest of the code is priority queue handling.", "The bot has priority queues so that e.g., someone chatting with it can't prevent it from doing its important kick/ban duties."], "childNum": 0, "tag": "p", "senID": 21, "childList": []}], [{"text": ["Use this decorator @RateLimited(ratepersec) before your function that enqueues."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Basically, this checks if 1/rate secs have passed since the last time and if not, waits the remainder of the time, otherwise it doesn't wait.", "This effectively limits you to rate/sec.", "The decorator can be applied to any function you want rate-limited."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In your case, if you want a maximum of 5 messages per 8 seconds, use @RateLimited(0.625) before your sendToQueue function."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import time\n\ndef RateLimited(maxPerSecond):\n    minInterval = 1.0 / float(maxPerSecond)\n    def decorate(func):\n        lastTimeCalled = [0.0]\n        def rateLimitedFunction(*args,**kargs):\n            elapsed = time.clock() - lastTimeCalled[0]\n            leftToWait = minInterval - elapsed\n            if leftToWait&gt;0:\n                time.sleep(leftToWait)\n            ret = func(*args,**kargs)\n            lastTimeCalled[0] = time.clock()\n            return ret\n        return rateLimitedFunction\n    return decorate\n\n@RateLimited(2)  # 2 per second at most\ndef PrintNumber(num):\n    print num\n\nif __name__ == \"__main__\":\n    print \"This should print 1,2,3... at about 2 per second.\"\n    for i in range(1,100):\n        PrintNumber(i)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["One solution is to attach a timestamp to each queue item and to discard the item after 8 seconds have passed.", "You can perform this check each time the queue is added to."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This only works if you limit the queue size to 5 and discard any additions whilst the queue is full."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Keep the time that the last five lines were sent.", "Hold the queued messages until the time the fifth-most-recent message (if it exists) is a least 8 seconds in the past (with last_five as an array of times):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n now = time.time()\nif len(last_five) == 0 or (now - last_five[-1]) &gt;= 8.0:\n    last_five.insert(0, now)\n    send_message(msg)\nif len(last_five) &gt; 5:\n    last_five.pop()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n long check_time = System.currentTimeMillis();\nint msgs_sent_count = 0;\n\nprivate boolean isRateLimited(int msgs_per_sec) {\n    if (System.currentTimeMillis() - check_time &gt; 1000) {\n        check_time = System.currentTimeMillis();\n        msgs_sent_count = 0;\n    }\n\n    if (msgs_sent_count &gt; (msgs_per_sec - 1)) {\n        return true;\n    } else {\n        msgs_sent_count++;\n    }\n\n    return false;\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["to block processing until the message can be sent, thus queuing up further messages,  antti's beautiful solution may also be modified like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n rate = 5.0; // unit: messages\nper  = 8.0; // unit: seconds\nallowance = rate; // unit: messages\nlast_check = now(); // floating-point, e.g. usec accuracy. Unit: seconds\n\nwhen (message_received):\n  current = now();\n  time_passed = current - last_check;\n  last_check = current;\n  allowance += time_passed * (rate / per);\n  if (allowance &gt; rate):\n    allowance = rate; // throttle\n  if (allowance &lt; 1.0):\n    time.sleep( (1-allowance) * (per/rate))\n    forward_message();\n    allowance = 0.0;\n  else:\n    forward_message();\n    allowance -= 1.0;\n</code>\n</pre>\n", "senID": 1}, {"text": ["it just waits until enough allowance is there to send the message.", "to not start with two times the rate, allowance may also initialized with 0."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]