[[{"text": ["Here's a Python (2.6) version (if you have Python 2.5, add a first line that says"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import with_statement\n</code>\n</pre>\n", "senID": 1}, {"text": ["and the script will also work)...:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import sys\n\ndef main(N):\n   rN = range(N)\n   for iout, iin in enumerate(xrange(1, 99999, N)):\n       with open('data_new_%s.txt' % (iout+1), 'w') as out:\n           for di in rN:\n               try: fin = open('data%s.txt' % (iin + di), 'r')\n               except IOError: return\n               out.write(fin.read())\n               fin.close()\n\nif __name__ == '__main__':\n    if len(sys.argv) &gt; 1:\n        N = int(sys.argv[1])\n    else:\n        N = 5\n    main(N)\n</code>\n</pre>\n", "senID": 3}, {"text": ["As you see from other answers &amp; comments, opinions on performance differ -- some believe that the Python startup (and imports of modules) will make this slower than bash (but the import part at least is bogus: sys, the only needed module, is a built-in module, requires no \"loading\" and therefore basically negligible overhead to import it); I suspect avoiding the repeated fork/exec of cat may slow bash down; others think that I/O will dominate anyway, making the two solutions equivalent.", "You'll have to benchmark with your own files, on your own system, to solve this performance doubt."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "sys", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "cat", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Best in what sense?", "Bash can do this quite well, but it may be harder for you to write a good bash script if you are more familiar with another scripting language.", "Do you want to optimize for something specific?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That said, here's a bash implementation:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n declare blocksize=5\n declare i=1\n declare blockstart=1\n declare blockend=$blocksize\n declare -a fileset \n while [ -f data${i}.txt ] ; do\n         fileset=(\"${fileset[@]}\" $data${i}.txt)\n         i=$(($i + 1))\n         if [ $i -gt $blockend ] ; then\n                  cat \"${fileset[@]}\" &gt; data_new_${blockstart}.txt\n                  fileset=() # clear\n                  blockstart=$(($blockstart + $blocksize))\n                  blockend=$(($blockend+ $blocksize))\n         fi\n done\n</code>\n</pre>\n", "senID": 2}, {"text": ["EDIT: I see you now say \"Best\" == \"Simplest code\", but what's simple depends on you.", "For me Perl is simpler than Python, for some Awk is simpler than bash.", "It depends on what you know best."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT again: inspired by dtmilano, I've changed mine to use cat once per blocksize, so now cat will be called 'only' 4000 times."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I like this one which saves on executing processes, only 1 cat per block"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #! /bin/bash\n\nN=5 # block size\nS=1 # start\nE=20000 # end\n\nfor n in $(seq $S $N $E)\ndo\n    CMD=\"cat \"\n    i=$n\n    while [ $i -lt $((n + N)) ]\n    do\n        CMD+=\"data$((i++)).txt \"\n    done\n    $CMD &gt; data_new_$((n / N + 1)).txt\ndone\n</code>\n</pre>\n", "senID": 1}], [{"text": ["how about a one liner ?", ":)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ls data[0-9]*txt|sort -nk1.5|awk 'BEGIN{rn=5;i=1}{while((getline _&lt;$0)&gt;0){print _ &gt;\"data_new_\"i\".txt\"}close($0)}NR%rn==0{i++}'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Since this can easily be done in any shell I would simply use that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This should do it:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #!/bin/sh\nFILES=$1\nFILENO=1\n\nfor i in data[0-9]*.txt; do\n    FILES=`expr $FILES - 1`\n    if [ $FILES -eq 0 ]; then\n        FILENO=`expr $FILENO + 1`\n        FILES=$1\n    fi\n\n    cat $i &gt;&gt; \"data_new_${FILENO}.txt\"\ndone\n</code>\n</pre>\n", "senID": 2}, {"text": ["Python version:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nimport os\nimport sys\n\nif __name__ == '__main__':\n    files_per_file = int(sys.argv[1])\n\n    i = 0\n    while True:\n        i += 1\n        source_file = 'data%d.txt' % i\n        if os.path.isfile(source_file):\n            dest_file = 'data_new_%d.txt' % ((i / files_per_file) + 1)\n            file(dest_file, 'wa').write(file(source_file).read())\n        else:\n            break\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Let's say, if you have a simple script that concatenates files and keeps a counter for you, like the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/bash\nCOUNT=0\nif [ -f counter ]; then\n  COUNT=`cat counter`\nfi\nCOUNT=$[$COUNT+1]\necho $COUNT &gt; counter\ncat $@ &gt; $COUNT.data\n</code>\n</pre>\n", "senID": 1}, {"text": ["The a command line will do:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n find -name \"*\" -type f -print0 | xargs -0 -n 5 path_to_the_script\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Simple enough?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["make_cat.py"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n limit = 1000\nn = 5\nfor i in xrange( 0, (limit+n-1)//n ):\n     names = [ \"data{0}.txt\".format(j) for j in range(i*n,i*n+n) ]\n     print \"cat {0} &gt;data_new_{1}.txt\".format( \" \".join(names), i )\n</code>\n</pre>\n", "senID": 2}, {"text": ["Script"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n python make_cat.py | sh\n</code>\n</pre>\n", "senID": 4}]]