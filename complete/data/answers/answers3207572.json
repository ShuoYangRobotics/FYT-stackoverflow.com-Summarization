[[{"text": ["self isn't a keyword in python, its just a normal variable name.", "When creating instance methods, you can name the first parameter whatever you want, self is just a convention."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You should almost always prefer passing arguments to functions over setting properties for input, but if you must, you can do so using the actual functions name to access variables within it:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def a:\n    if a.foo:\n        #blah\n\na.foo = false\na()\n</code>\n</pre>\n", "senID": 2}, {"text": ["see python function attributes - uses and abuses for when this comes in handy.", ":D"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "python function attributes - uses and abuses", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/338101/python-function-attributes-uses-and-abuses"}]}], [{"code": "<pre>\n<code>\n def foo():\n    print(foo.fields)\nfoo.fields=[1,2,3]\n\nfoo()\n# [1, 2, 3]\n</code>\n</pre>\n", "senID": 0}, {"text": ["There is nothing wrong with adding attributes to functions.", "Many memoizers use this to cache results in the function itself. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For example, notice the use of func.cache:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "func.cache", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from decorator import decorator\n@decorator\ndef memoize(func, *args, **kw):\n    # Author: Michele Simoniato\n    # Source: http://pypi.python.org/pypi/decorator\n    if not hasattr(func, 'cache'):\n        func.cache = {}\n    if kw: # frozenset is used to ensure hashability\n        key = args, frozenset(kw.iteritems())\n    else:\n        key = args\n    cache = func.cache # attribute added by memoize\n    if key in cache:\n        return cache[key]\n    else:\n        cache[key] = result = func(*args, **kw)\n        return result\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def x(): pass\n&gt;&gt;&gt; x\n&lt;function x at 0x100451050&gt;\n&gt;&gt;&gt; x.hello = \"World\"\n&gt;&gt;&gt; x.hello\n\"World\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can set attributes on functions, as these are just plain objects, but I actually never saw something like this in real code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Plus.", "self is not a keyword, just another variable name, which happens to be the particular instance of the class.", "self is passed implicitly, but received explicitly."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["if you want globally set parameters for a callable 'thing' you could always create a class and implement the __call__ method?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__call__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["There is no special way, within a function's body, to refer to the function object whose code is executing.", "Simplest is just to use funcname.field (with funcname being the function's name within the namespace it's in, which you indicate is the case -- it would be harder otherwise)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "funcname.field", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "funcname", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["This isn't something you should do.", "I can't think of any way to do what you're asking except some walking around on the call stack and some weird introspection -- which isn't something that should happen in production code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That said, I think this actually does what you asked:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import inspect\n\n_code_to_func = dict()\ndef enable_function_self(f):\n    _code_to_func[f.func_code] = f\n    return f\n\ndef get_function_self():\n    f = inspect.currentframe()\n    code_obj = f.f_back.f_code\n    return _code_to_func[code_obj]\n\n@enable_function_self\ndef foo():\n    me = get_function_self()\n    print me\n\nfoo()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["While I agree with the the rest that this is probably not good design, the question did intrigue me.", "Here's my first solution, which I may update once I get decorators working.", "As it stands, it relies pretty heavily on being able to read the stack, which may not be possible in all implementations (something about sys._getframe() not necessarily being present...)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys, inspect\n\ndef cute():\n    this = sys.modules[__name__].__dict__.get(inspect.stack()[0][3])\n    print \"My face is...\" + this.face\n\ncute.face = \"very cute\"\ncute()\n</code>\n</pre>\n", "senID": 1}, {"text": ["What do you think?", ":3"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could use the following (hideously ugly) code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Generic_Object(object):\n    pass\n\ndef foo(a1, a2, self=Generic_Object()): \n    self.args=(a1,a2)\n    print \"len(self.args):\", len(self.args)\n    return None\n</code>\n</pre>\n", "senID": 1}, {"text": ["... as you can see it would allow you to use \"self\" as you described.", "You can't use an \"object()\" directly because you can't \"monkey patch(*)\" values into an object() instance.", "However, normal subclasses of object (such as the Generic_Object() I've shown here) can be \"monkey patched\""], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "object()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Generic_Object()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["If you wanted to always call your function with a reference to some object as the first argument that would be possible.", "You could put the defaulted argument first, followed by a *args and optional **kwargs parameters (through which any other arguments or dictionaries of options could be passed during calls to this function)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["This is, as I said hideously ugly.", "Please don't ever publish any code like this or share it with anyone in the Python community.", "I'm only showing it here as a sort of strange educational exercise."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "hideously ugly", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "hideously ugly", "tag": "em"}]}, {"text": "hideously ugly", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["An instance method is like a function in Python.", "However, it exists within the namespace of a class (thus it must be accessed via an instance ... myobject.foo() for example) and it is called with a reference to \"self\" (analagous to the \"this\" pointer in C++) as the first argument.", "Also there's a method resolution process which causes the interpreter to search the namespace of the instance, then it's class, and then each of the parent classes and so on ... up through the inheritance tree."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "myobject.foo()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["An unbound function is called with whatever arguments you pass to it.", "There can't bee any sort of automatically pre-pended object/instance reference to the argument list.", "Thus, writing a function with an initial argument named \"self\" is meaningless.", "(It's legal because Python doesn't place any special meaning on the name \"self.", "\"  But meaningless because callers to your function would have to manually supply some sort of object reference to the argument list and it's not at all clear what that should be.", "Just some bizarre \"Generic_Object\" which then floats around in the global variable space?", ")."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I hope that clarifies things a bit.", "It sounds like you're suffering from some very fundamental misconceptions about how Python and other object-oriented systems work."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "(\"Monkey patching\" is a term used to describe the direct manipulation of an objects attributes -- or \"instance variables\" by code that is not part of the class hierarchy of which the object is an instance).", "tag": "none", "senID": 8}]}], [{"text": ["As another alternative, you can make the functions into bound class methods like so:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class _FooImpl(object):\n    a = \"Hello \"\n    @classmethod\n    def foo(cls, param):\n        return cls.a + param\nfoo = _FooImpl.foo\n\n# later...\nprint foo(\"World\") # yes, Hello World\n\n# and if you have to change an attribute:\nfoo.im_self.a = \"Goodbye \"\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want functions to share attribute namespaecs, you just make them part of the same class.", "If not, give each its own class."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can't do that \"function accessing its own attributes\" correctly for all situations - see for details here http://stackoverflow.com/questions/3109289/how-can-python-function-access-its-own-attributes - but here is a quick demonstration:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://stackoverflow.com/questions/3109289/how-can-python-function-access-its-own-attributes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3109289/how-can-python-function-access-its-own-attributes"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def f(): return f.x\n... \n&gt;&gt;&gt; f.x = 7\n&gt;&gt;&gt; f()\n7\n&gt;&gt;&gt; g = f\n&gt;&gt;&gt; g()\n7\n&gt;&gt;&gt; del f\n&gt;&gt;&gt; g()\nTraceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;interactive input&gt;\", line 1, in f\nNameError: global name 'f' is not defined\n</code>\n</pre>\n", "senID": 1}, {"text": ["Basically most methods directly or indirectly rely on accessing the function object through lookup by name in globals; and if original function name is deleted, this stops working.", "There are other kludgey ways of accomplishing this, like defining class, or factory - but thanks to your explanation it is clear you don't really need that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Just do the mentioned keyword catch-all argument, like so:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def fn1(oneArg):\n    // do the due\n\ndef fn2(oneArg, **kw):\n    if 'option1' in kw:\n        print 'called with option1=', kw['option1']\n    //do the rest\n\nfn2(42)\nfn2(42, option1='something')\n</code>\n</pre>\n", "senID": 4}, {"text": ["Not sure what you mean in your comment of handling TypeError - that won't arise when using **kw.", "This approach works very well for some python system functions - check min(), max(), sort().", "Recently sorted(dct,key=dct.get,reverse=True) came very handy to me in CodeGolf challenge :)"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "sorted(dct,key=dct.get,reverse=True)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["What exactly are you hoping \"self\" would point to, if the function is defined outside of any class?", "If your function needs some global information to execute properly, you need to send this information to the function in the form of an argument. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want your function to be context aware, you need to declare it within the scope of an object.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]