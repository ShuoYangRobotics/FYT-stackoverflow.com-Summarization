[[{"text": ["One you might want to look at is Werkzeug - it is a WSGI utility toolkit.", "It includes a runserver function that takes the wsgiref server and adds automatic code reloading (you can also configure it to reload when configuration files change) and an awesome debugger."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Werkzeug", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://werkzeug.pocoo.org/"}]}, {"text": ["On a side note, your disdain for frameworks makes it sound like you're planning to handle all the WSGI stuff from scratch, in which case I would recommend you use Werkzeug's utility functions to handle parsing requests and generating responses.", "It's a lot more fun than doing it yourself.", "(And for the love of Guido, PLEASE don't use cgi.FieldStorage!"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "cgi.FieldStorage", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["Check out run_simple from werkzeug:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://werkzeug.pocoo.org/documentation/0.5.1/serving.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://werkzeug.pocoo.org/documentation/0.5.1/serving.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://werkzeug.pocoo.org/documentation/0.5.1/serving.html"}]}, {"text": ["In addition to giving you automatic code reloading, you can use use_debugger=True to include their pretty spiffy debugger on top of your app (which includes console in each line of the traceback)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["So far I've been using CherryPy, and compared to Django (which, while not in your list, is the only other dev server I used) I like it heaps more.", "It does what is says: it is only there when you need it, and gets out of the way for the rest of the time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Using Django seemed like I needed to subscribe to the Django way of doing things.", "Although Django provides heaps more functionality out of the box (default admin interface, widgets on your webpages) , using CherryPy seems like just another import that has very good (often surprising you with extra) functionality."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I'd recommend paste or CherryPy.", "They're the easiest to get up and running with."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Also, you missed web.py, which is both small and supports code reload."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["One really easy way is CGI (together with a regular web server, and using wsgiref.handlers.CGIHandler).", "Terrible for performance on a production server, but great for development.", "You can write a single script that works as both a mod_wsgi WSGIScriptAlias (exposing an application object), and as a mod_cgi ScriptAlias (calling wsgiref when __name__=='__main__')."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "wsgiref.handlers.CGIHandler", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "application", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "wsgiref", "childNum": 0, "tag": "code", "childList": []}, {"text": "__name__=='__main__'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Many WSGI environments have a way to reload the basic script, for example mod_wsgi's WSGIScriptReloading, which is on by default.", "Unfortunately, you're likely to be putting much of your code in modules, which isn't so easy to reload.", "In mod_wsgi you can also do it by sending a SIGINT to perform a reload when in daemon mode.", "Unfortunately you still have to sniff every module you're using for mtime updates in order to know whether you have to reload.", "And it doesn't work in embedded mode."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "WSGIScriptReloading", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["A messy but feasible approach is to sniff all modules that are part of your application, and if any have been updated since the last check, reload them all.", "You have to reload them at once, by removing them all from the sys.modules lookup (remove None-valued entries too whilst you're there, to avoid relative import lookup problems), in order to ensure they don't keep cross-references to the old versions of themselves.", "And of course they must not leave other references to themselves outside of your application.", "You can see an example of this in action in the ModuleUpdater class here."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "sys.modules", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "ModuleUpdater", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"href": "http://www.doxdesk.com/file/software/py/v/wsgiwrap-0.6.py", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["(This software isn't ready for release, but has been providing module reloading for my WSGI apps for a few years and seems to be stable.", "The idea is to put all your WSGI app in an application class in a package, which you can import from a single WSGI/CGI/command-line entry point script; you include the deployment config in that script."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You can use paste.reloader with any wsgi-server, aside of other paste modules."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n# run paste reloader\nimport paste.reloader as reloader\nreloader.install()\n\n# run wsgiref server\nfrom wsgiref import simple_server\nsimple_server.make_server('', 8080, main_wsgi_app).serve_forever()\n</pre>\n", "senID": 1}, {"text": ["Is that minimalistic enough?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]