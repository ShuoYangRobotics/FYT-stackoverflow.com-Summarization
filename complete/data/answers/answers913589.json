[[{"text": ["I had this same problem and I found another technique for reordering fields in the Django CookBook:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Django CookBook", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.djangoproject.com/wiki/CookBookNewFormsFieldOrdering"}]}, {"code": "<pre>\n<code>\n class edit_form(forms.Form):\n    summary = forms.CharField()\n    description = forms.CharField(widget=forms.TextArea)\n\n\nclass create_form(edit_form):\n    name = forms.CharField()\n\n    def __init__(self, *args, **kwargs):\n        super(edit_form, self).__init__(*args, **kwargs)\n        self.fields.keyOrder = ['name', 'summary', 'description']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I used the solution posted by Selene but found that it removed all fields which weren't assigned to keyOrder.", "The form that I'm subclassing has a lot of fields so this didn't work very well for me.", "I coded up this function to solve the problem using akaihola's answer, but if you want it to work like Selene's all you need to do is set throw_away to True."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "throw_away", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def order_fields(form, field_list, throw_away=False):\n    \"\"\"\n    Accepts a form and a list of dictionary keys which map to the\n    form's fields. After running the form's fields list will begin\n    with the fields in field_list. If throw_away is set to true only\n    the fields in the field_list will remain in the form.\n\n    example use:\n    field_list = ['first_name', 'last_name']\n    order_fields(self, field_list)\n    \"\"\"\n    if throw_away:\n        form.fields.keyOrder = field_list\n    else:\n        for field in field_list[::-1]:\n            form.fields.insert(0, field, form.fields.pop(field))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is how I'm using it in my own code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class NestableCommentForm(ExtendedCommentSecurityForm):\n    # TODO: Have min and max length be determined through settings.\n    comment = forms.CharField(widget=forms.Textarea, max_length=100)\n    parent_id = forms.IntegerField(widget=forms.HiddenInput, required=False)\n\n    def __init__(self, *args, **kwargs):\n        super(NestableCommentForm, self).__init__(*args, **kwargs)\n        order_fields(self, ['comment', 'captcha'])\n</code>\n</pre>\n", "senID": 3}], [{"text": ["See the notes in this SO question on the way Django's internals keep track of field order; the answers include suggestions on how to \"reorder\" fields to your liking (in the end it boils down to messing with the .fields attribute)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "this SO question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/350799/how-does-django-know-the-order-to-render-form-fields"}, {"text": ".fields", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Like Selenes answer, just a short comment - guess it is a typo and\nthat the call to super should be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n super(create_form, self).__init__(*args, **kwargs)\n</code>\n</pre>\n", "senID": 1}, {"text": ["and not:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n super(edit_form, self).__init__(*args, **kwargs)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You could also create a decorator to order fields (inspired by Joshua's solution):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def order_fields(*field_list):\n    def decorator(form):\n        original_init = form.__init__\n        def init(self, *args, **kwargs):\n            original_init(self, *args, **kwargs)        \n            for field in field_list[::-1]:\n                self.fields.insert(0, field, self.fields.pop(field))\n        form.__init__ = init\n        return form            \n    return decorator\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will ensure that all the fields passed to the decorator come first.", "You can use it like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n @order_fields('name')\nclass CreateForm(EditForm):\n    name = forms.CharField()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Alternate methods for changing the field order:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Pop-and-insert:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n self.fields.insert(0, 'name', self.fields.pop('name'))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Pop-and-append:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n self.fields['summary'] = self.fields.pop('summary')\nself.fields['description'] = self.fields.pop('description')\n</code>\n</pre>\n", "senID": 4}, {"text": ["Pop-and-append-all:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n for key in ('name', 'summary', 'description'):\n    self.fields[key] = self.fields.pop(key)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Ordered-copy:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n self.fields = SortedDict( [ (key, self.fields[key])\n                            for key in ('name', 'summary' ,'description') ] )\n</code>\n</pre>\n", "senID": 8}, {"text": ["But Selene's approach from the Django CookBook still feels clearest of all."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}]]