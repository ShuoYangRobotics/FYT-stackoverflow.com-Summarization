[[{"text": ["model._meta.get_all_field_names() will give you all the model's field names, then you can use model._meta.get_field() to work your way to the verbose name, and getattr() to get the value from the model."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "model._meta.get_all_field_names()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "model._meta.get_field()", "childNum": 0, "tag": "code", "childList": []}, {"text": "getattr()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You can use Django's to-python queryset serializer."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "to-python", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Just put the following code in your view:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from django.core import serializers\ndata = serializers.serialize( \"python\", SomeModel.objects.all() )\n</code>\n</pre>\n", "senID": 2}, {"text": ["And then in the template:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n {% for instance in data %}\n    {% for field, value in instance.fields.items %}\n        {{ field }}: {{ value }}\n    {% endfor %}\n{% endfor %}\n</code>\n</pre>\n", "senID": 4}, {"text": ["Its great advantage is the fact that it handles relation fields."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["For the subset of fields try:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n data = serializers.serialize('python', SomeModel.objects.all(), fields=('name','size'))\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Finally found a good solution to this on the dev mailing list (http://groups.google.com/group/django-developers/browse_thread/thread/44cd834438cfda77/557f53697658ab04?lnk=gst&amp;q=template+model#557f53697658ab04):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In the view add:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from django.forms.models import model_to_dict\n\ndef show(request, object_id):\n    object = FooForm(data=model_to_dict(Foo.objects.get(pk=object_id)))\n    return render_to_response('foo/foo_detail.html', {'object': object})\n</code>\n</pre>\n", "senID": 2}, {"text": ["in the template add:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n {% for field in object %}\n    &lt;li&gt;&lt;b&gt;{{ field.label }}:&lt;/b&gt; {{ field.data }}&lt;/li&gt;\n{% endfor %}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["There should really be a built-in way to do this.", "I wrote this utility build_pretty_data_view that takes a model object and form instance (a form based on your model) and returns a SortedDict."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "build_pretty_data_view", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "SortedDict", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Benefits to this solution include:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "It preserves order using Django's built-in ", "tag": "none", "senID": 2}, {"text": "When tries to get the label/verbose_name, but falls back to the field name if one is not defined. ", "tag": "none", "senID": 3}, {"text": "It will also optionally take an ", "tag": "none", "senID": 4}, {"text": "If your form class includes a ", "tag": "none", "senID": 5}]}, {"text": ["To use this solution, first add this file/function somewhere, then import it into your views.py."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "views.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["utils.py"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "utils.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim: ai ts=4 sts=4 et sw=4\nfrom django.utils.datastructures import SortedDict\n\n\ndef build_pretty_data_view(form_instance, model_object, exclude=(), append=()):\n    i=0\n    sd=SortedDict()\n\n    for j in append:\n        try:\n            sdvalue={'label':j.capitalize(),\n                     'fieldvalue':model_object.__getattribute__(j)}\n            sd.insert(i, j, sdvalue)\n            i+=1\n        except(AttributeError):\n            pass\n\n    for k,v in form_instance.fields.items():\n        sdvalue={'label':\"\", 'fieldvalue':\"\"}\n        if not exclude.__contains__(k):\n            if v.label is not None:\n                sdvalue = {'label':v.label,\n                           'fieldvalue': model_object.__getattribute__(k)}\n            else:\n                sdvalue = {'label':k,\n                           'fieldvalue': model_object.__getattribute__(k)}\n            sd.insert(i, k, sdvalue)\n            i+=1\n    return sd\n</code>\n</pre>\n", "senID": 8}, {"text": ["So now in your views.py you might do something like this"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "views.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from django.shortcuts import render_to_response\nfrom django.template import RequestContext\nfrom utils import build_pretty_data_view\nfrom models import Blog\nfrom forms import BlogForm\n.\n.\ndef my_view(request):\n   b=Blog.objects.get(pk=1)\n   bf=BlogForm(instance=b)\n   data=build_pretty_data_view(form_instance=bf, model_object=b,\n                        exclude=('number_of_comments', 'number_of_likes'),\n                        append=('user',))\n\n   return render_to_response('my-template.html',\n                          RequestContext(request,\n                                         {'data':data,}))\n</code>\n</pre>\n", "senID": 10}, {"text": ["Now in your my-template.html template you can iterate over the data like so..."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "my-template.html", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n {% for field,value in data.items %}\n\n    &lt;p&gt;{{ field }} : {{value.label}}: {{value.fieldvalue}}&lt;/p&gt;\n\n{% endfor %}\n</code>\n</pre>\n", "senID": 12}, {"text": ["Good Luck.", "Hope this helps someone!"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["Here's another approach using a model method.", "This version resolves picklist/choice fields, skips empty fields, and lets you exclude specific fields. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def get_all_fields(self):\n    \"\"\"Returns a list of all field names on the instance.\"\"\"\n    fields = []\n    for f in self._meta.fields:\n\n        fname = f.name        \n        # resolve picklists/choices, with get_xyz_display() function\n        get_choice = 'get_'+fname+'_display'\n        if hasattr( self, get_choice):\n            value = getattr( self, get_choice)()\n        else:\n            try :\n                value = getattr(self, fname)\n            except User.DoesNotExist:\n                value = None\n\n        # only display fields with values and skip some fields entirely\n        if f.editable and value and f.name not in ('id', 'status', 'workshop', 'user', 'complete') :\n\n            fields.append(\n              {\n               'label':f.verbose_name, \n               'name':f.name, \n               'value':value,\n              }\n            )\n    return fields\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then in your template:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {% for f in app.get_all_fields %}\n    &lt;dt&gt;{{f.label|capfirst}}&lt;/dt&gt;\n    &lt;dd&gt;\n    {{f.value|escape|urlize|linebreaks}}\n    &lt;/dd&gt;\n{% endfor %}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Yeah it's not pretty, you'll have to make your own wrapper.", "Take a look at builtin databrowse app, which has all the functionality you need really."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "databrowse", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.djangoproject.com/browser/django/trunk/django/contrib/databrowse/datastructures.py"}]}], [{"text": ["Instead of editing every model I would recommend to write one template tag which will return all field of any model given.", "Every object has list of fields ._meta.fields.", "Every field object has attribute name that will return it's name and method value_to_string() that supplied with your model object will return its value.", "The rest is as simple as it's said in Django documentation."], "childNum": 10, "tag": "p", "senID": 0, "childList": [{"text": "one template tag", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "any model", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "._meta.fields", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}, {"text": "name", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "value_to_string()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "object", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 3, "childList": []}, {"href": "https://docs.djangoproject.com/en/dev/howto/custom-template-tags/", "text": "Django documentation", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Here is my example how this templatetag might look like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from django.conf import settings\n    from django import template\n\n    if not getattr(settings, 'DEBUG', False):\n        raise template.TemplateSyntaxError('get_fields is available only when DEBUG = True')\n\n\n    register = template.Library()\n\n    class GetFieldsNode(template.Node):\n        def __init__(self, object, context_name=None):\n            self.object = template.Variable(object)\n            self.context_name = context_name\n\n        def render(self, context):\n            object = self.object.resolve(context)\n            fields = [(field.name, field.value_to_string(object)) for field in object._meta.fields]\n\n            if self.context_name:\n                context[self.context_name] = fields\n                return ''\n            else:\n                return fields\n\n\n    @register.tag\n    def get_fields(parser, token):\n        bits = token.split_contents()\n\n        if len(bits) == 4 and bits[2] == 'as':\n            return GetFieldsNode(bits[1], context_name=bits[3])\n        elif len(bits) == 2:\n            return GetFieldsNode(bits[1])\n        else:\n            raise template.TemplateSyntaxError(\"get_fields expects a syntax of \"\n                           \"{% get_fields &lt;object&gt; [as &lt;context_name&gt;] %}\")\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I've come up with the following method, which works for me because in every case the model will have a ModelForm associated with it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def GetModelData(form, fields):\n    \"\"\"\n    Extract data from the bound form model instance and return a\n    dictionary that is easily usable in templates with the actual\n    field verbose name as the label, e.g.\n\n    model_data{\"Address line 1\": \"32 Memory lane\",\n               \"Address line 2\": \"Brainville\",\n               \"Phone\": \"0212378492\"}\n\n    This way, the template has an ordered list that can be easily\n    presented in tabular form.\n    \"\"\"\n    model_data = {}\n    for field in fields:\n        model_data[form[field].label] = eval(\"form.data.%s\" % form[field].name)\n    return model_data\n\n@login_required\ndef clients_view(request, client_id):\n    client = Client.objects.get(id=client_id)\n    form = AddClientForm(client)\n\n    fields = (\"address1\", \"address2\", \"address3\", \"address4\",\n              \"phone\", \"fax\", \"mobile\", \"email\")\n    model_data = GetModelData(form, fields)\n\n    template_vars = RequestContext(request,\n        {\n            \"client\": client,\n            \"model_data\": model_data\n        }\n    )\n    return render_to_response(\"clients-view.html\", template_vars)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here is an extract from the template I am using for this particular view:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &lt;table class=\"client-view\"&gt;\n    &lt;tbody&gt;\n    {% for field, value in model_data.items %}\n        &lt;tr&gt;\n            &lt;td class=\"field-name\"&gt;{{ field }}&lt;/td&gt;&lt;td&gt;{{ value }}&lt;/td&gt;\n        &lt;/tr&gt;\n    {% endfor %}\n    &lt;/tbody&gt;\n&lt;/table&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["The nice thing about this method is that I can choose on a template-by-template basis the order in which I would like to display the field labels, using the tuple passed in to GetModelData and specifying the field names.", "This also allows me to exclude certain fields (e.g.", "a User foreign key) as only the field names passed in via the tuple are built into the final dictionary."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I'm not going to accept this as the answer because I'm sure someone can come up with something more \"Djangonic\" :-)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Update: I'm choosing this as the final answer because it is the simplest out of those given that does what I need.", "Thanks to everyone who contributed answers."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["This may be considered a hack but I've done this before using modelform_factory to turn a model instance into a form."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The Form class has a lot more information inside that's super easy to iterate over and it will serve the same purpose at the expense of slightly more overhead.", "If your set sizes are relatively small I think the performance impact would be negligible."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The one advantage besides convenience of course is that you can easily turn the table into an editable datagrid at a later date."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I'm using this, https://github.com/miracle2k/django-tables."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "https://github.com/miracle2k/django-tables", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://github.com/miracle2k/django-tables"}]}, {"code": "<pre>\n<code>\n &lt;table&gt;\n&lt;tr&gt;\n    {% for column in table.columns %}\n    &lt;th&gt;&lt;a href=\"?sort={{ column.name_toggled }}\"&gt;{{ column }}&lt;/a&gt;&lt;/th&gt;\n    {% endfor %}\n&lt;/tr&gt;\n{% for row in table.rows %}\n    &lt;tr&gt;\n    {% for value in row %}\n        &lt;td&gt;{{ value }}&lt;/td&gt;\n    {% endfor %}\n    &lt;/tr&gt;\n{% endfor %}\n&lt;/table&gt;\n</code>\n</pre>\n", "senID": 1}]]