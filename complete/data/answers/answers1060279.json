[[{"text": ["Why are the two nested iterations?", "For me it produces the same list of data with only one iteration:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for single_date in (start_date + timedelta(n) for n in range(day_count)):\n    print ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["And not list get stored, only one generator is iterated over.", "Also the \"if\" in the generator seems to be unnecessary."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["After all, a linear sequence should only require one iterator, not two."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Update after discussion with John Machin:"], "childNum": 0, "tag": "h2", "senID": 4, "childList": []}, {"text": ["Maybe the most elegant solution is using a generator function to completely hide/abstract the iteration over the range of dates:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def daterange(start_date, end_date):\n    for n in range((end_date - start_date).days):\n        yield start_date + timedelta(n)\n\nfor single_date in daterange(start_date, end_date):\n    print strftime(\"%Y-%m-%d\", single_date.timetuple())\n</code>\n</pre>\n", "senID": 6}, {"text": ["NB: For consistency withe built-in range() function this iteration stops before reaching the end_date.", "So for inclusive iteration use the next day, as you would with range()."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "range()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "before", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}], [{"text": ["This might be more clear:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d = start_date\ndelta = datetime.timedelta(days=1)\nwhile d &lt;= end_date:\n    print d.strftime(\"%Y-%m-%d\")\n    d += delta\n</code>\n</pre>\n", "senID": 1}], [{"text": ["use the dateutil library:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "dateutil", "tag": "a", "pos": 0, "childList": [{"text": "dateutil", "tag": "code"}], "childNum": 1, "href": "http://labix.org/python-dateutil"}, {"text": "dateutil", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from datetime import date\nfrom dateutil.rrule import rrule, DAILY\na = date(2009, 5, 30)\nb = date(2009, 6, 9)\nfor dt in rrule(DAILY, dtstart=a, until=b):\n    print dt.strftime(\"%Y-%m-%d\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["This python library has many more advanced features, some very useful, like relativedeltas - and is implemented as a single .py python file that can be easily included into your project."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "relativedelta", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n import datetime\n\ndef daterange(start, stop, step=datetime.timedelta(days=1), inclusive=False):\n  # inclusive=False to behave like range by default\n  if step.days &gt; 0:\n    while start &lt; stop:\n      yield start\n      start = start + step\n      # not +=! don't modify object passed in if it's mutable\n      # since this function is not restricted to\n      # only types from datetime module\n  elif step.days &lt; 0:\n    while start &gt; stop:\n      yield start\n      start = start + step\n  if inclusive and start == stop:\n    yield start\n\n# ...\n\nfor date in daterange(start_date, end_date, inclusive=True):\n  print strftime(\"%Y-%m-%d\", date.timetuple())\n</code>\n</pre>\n", "senID": 0}, {"text": ["This function does more than you strictly require, by supporting negative step, etc.", "As long as you factor out your range logic, then you don't need the separate day_count and most importantly the code becomes easier to read as you call the function from multiple places."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "day_count", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["for i in range(16):\n print datetime.date.today()+datetime.timedelta(days=i)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n import datetime\n\ndef daterange(start, stop, step_days=1):\n    current = start\n    step = datetime.timedelta(step_days)\n    if step_days &gt; 0:\n        while current &lt; stop:\n            yield current\n            current += step\n    elif step_days &lt; 0:\n        while current &gt; stop:\n            yield current\n            current += step\n    else:\n        raise ValueError(\"daterange() step_days argument must not be zero\")\n\nif __name__ == \"__main__\":\n    from pprint import pprint as pp\n    lo = datetime.date(2008, 12, 27)\n    hi = datetime.date(2009, 1, 5)\n    pp(list(daterange(lo, hi)))\n    pp(list(daterange(hi, lo, -1)))\n    pp(list(daterange(lo, hi, 7)))\n    pp(list(daterange(hi, lo, -7))) \n    assert not list(daterange(lo, hi, -1))\n    assert not list(daterange(hi, lo))\n    assert not list(daterange(lo, hi, -7))\n    assert not list(daterange(hi, lo, 7))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["What about the following for doing a range incremented by days:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for d in map( lambda x: startDate+datetime.timedelta(days=x), xrange( (stopDate-startDate).days ) ):\n  # Do stuff here\n</code>\n</pre>\n", "senID": 1}, {"tag": "ul", "num": 1, "lis": [{"text": "startDate and stopDate are datetime.date objects", "tag": "none", "senID": 2}]}, {"text": ["For a generic version:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for d in map( lambda x: startTime+x*stepTime, xrange( (stopTime-startTime).total_seconds() / stepTime.total_seconds() ) ):\n  # Do stuff here\n</code>\n</pre>\n", "senID": 4}, {"tag": "ul", "num": 2, "lis": [{"text": "startTime and stopTime are datetime.date or datetime.datetime object\n(both should be the same type)", "tag": "none", "senID": 5}, {"text": "stepTime is a timedelta object", "tag": "none", "senID": 6}]}, {"text": ["Note that .total_seconds() is only supported after python 2.7 If you are stuck with an earlier version you can write your own function:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def total_seconds( td ):\n  return float(td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) / 10**6\n</code>\n</pre>\n", "senID": 8}]]