[[{"code": "<pre>\n<code>\n a[0] = 1;\na[n_] := a[n] = 1 - 1/(a[n-1] + 3)\n</code>\n</pre>\n", "senID": 0}, {"text": ["(Note the memoization trick."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "memoization trick", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/129877/how-do-i-write-a-generic-memoize-function/173038#173038"}]}, {"text": ["Also, a[n] converges (very quickly) to sqrt(3)-1:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Solve[x == 1 - 1/(x+3), x]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Java"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n double A = 1;\nint n = 0;\nwhile (true) {\n  System.out.println(n + \" \" + A);\n  A = 1 - 1 / (A + 3);\n  n++;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Python"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n A = 1.0\nn = 0\nwhile 1:\n  print n, A\n  A = 1 - 1 / (A + 3)\n  n += 1\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Mathematica:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a[0] := 1\na[k_] := 1 - 1/(a[k - 1] + 3)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I substituted k = n + 1 because that makes the expression simpler.", "The result is equivalent."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Python, simplest:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def a(n):\n  if n == 0: return 1\n  return 1 - 1 / float(a(n-1) + 3)\n\n# limit is sqrt(3) - 1\nlimit = 3.0 ** 0.5 - 1.0\n\n# get 9 digits' precision\ni = 0\nwhile abs(a(i) - limit) &gt; 1.0e-9:\n  i += 1\n\nprint i\n</code>\n</pre>\n", "senID": 1}, {"text": ["This emits 8, suggesting that optimizations such as recursion elimination or memoizing are likely not warranted."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "8", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Of course normally we'd want to get the limit numerically rather than analytically, so the normal way to loop would be rather different -- and best encapsulated in a higher-order function...:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # get a function's limit numerically\ndef limit(f, eps=1.0e-11):\n  previous_value = f(0)\n  next_value = f(1)\n  i = 2\n  while abs(next_value - previous_value) &gt; eps:\n    previous_value = next_value\n    next_value = f(i)\n    i += 1\n  return next_value\n</code>\n</pre>\n", "senID": 4}, {"text": ["Nontrivial looping logic is usually best encapsulated in a generator:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def next_prev(f):\n  previous_value = f(0)\n  i = 1\n  while True:\n    next_value = f(i)\n    yield next_value, previous_value\n    i += 1\n    previous_value = next_value\n</code>\n</pre>\n", "senID": 6}, {"text": ["with the help of this generator, the limit HOF becomes much simpler:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "limit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def limit(f, eps=1.0e-11):\n  for next_value, previous_value in next_prev(f):\n    if abs(next_value - previous_value) &lt; eps:\n      return next_value\n</code>\n</pre>\n", "senID": 8}, {"text": ["Note how useful the separation is: next_prev embodies the concept of \"get the next and previous value of the function\", limit just deals with \"when should the loop terminate\"."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "next_prev", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "limit", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Last but not least, itertools often offers a good alternative to generators, letting you encapsulate finicky iteration logic in speedy ways (though it does take some getting used to...;-):"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "itertools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html"}]}, {"code": "<pre>\n<code>\n import itertools\n\ndef next_prev(f):\n  values = itertools.imap(f, itertools.count())\n  prv, nxt = itertools.tee(values)\n  nxt.next()\n  return itertools.izip(prv, nxt)\n</code>\n</pre>\n", "senID": 11}], [{"text": ["Python"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n next = lambda x: 1.0 - (1.0 / (float(x) + 3.0))\nlast, z, count = -1, 0.0, 0\nwhile last != z:\n  print count, z\n  last, z, count = z, next(z), count+1\n</code>\n</pre>\n", "senID": 1}, {"text": ["I try to avoid writing \"while True\" or such if I can avoid it.", "Almost certainly no code that I write will loop forever.", "In this case, it ran sixteen times for me.", "Sixteen is a lot less than \u2135-null."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "forever", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["A one-liner in Mathematica which gives a list of exact elements of your sequence:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In[66]:= NestWhileList[1 - 1/(#1 + 3) &amp;, 1, \n RealExponent[Subtract[##]] &gt; -8 &amp;, 2]\n\nOut[66]= {1, 3/4, 11/15, 41/56, 153/209, 571/780, 2131/2911, \\\n7953/10864, 29681/40545}\n</code>\n</pre>\n", "senID": 1}, {"text": ["The difference between the last two elements is less than 10^-8.", "It thus have taken 8 iterations:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n In[67]:= Length[%]\n\nOut[67]= 9\n</code>\n</pre>\n", "senID": 3}]]