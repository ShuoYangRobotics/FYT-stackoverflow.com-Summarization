[[{"text": ["Here is a scary one to get the ball rolling."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; makere = lambda n: ''.join(['(.*?)(.+)(.*?)(.+)(.*?)'] + ['(.*)(\\\\2)(.*)(\\\\4)(.*)'] * (n - 1))\n&gt;&gt;&gt; inp = ['asometxt0moretxt', 'bsometxt1moretxt', 'aasometxt10moretxt', 'zzsometxt999moretxt']\n&gt;&gt;&gt; re.match(makere(len(inp)), ''.join(inp)).groups()\n('a', 'sometxt', '0', 'moretxt', '', 'b', 'sometxt', '1', 'moretxt', 'aa', '', 'sometxt', '10', 'moretxt', 'zz', '', 'sometxt', '999', 'moretxt', '')\n</code>\n</pre>\n", "senID": 1}, {"text": ["I hope its sheer ugliness will inspire better solutions :)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This solution finds the two longest common substrings and uses them to delimit the input strings:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def an_answer_to_stackoverflow_question_1914394(lst):\n    \"\"\"\n    &gt;&gt;&gt; lst = ['asometxt0moretxt', 'bsometxt1moretxt', 'aasometxt10moretxt', 'zzsometxt999moretxt']\n    &gt;&gt;&gt; an_answer_to_stackoverflow_question_1914394(lst)\n    (['sometxt', 'moretxt'], [('a', '0'), ('b', '1'), ('aa', '10'), ('zz', '999')])\n    \"\"\"\n    delimiters = find_delimiters(lst)\n    return delimiters, list(split_strings(lst, delimiters))\n</code>\n</pre>\n", "senID": 1}, {"text": ["find_delimiters and friends finds the delimiters:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "find_delimiters", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\n\ndef find_delimiters(lst):\n    \"\"\"\n    &gt;&gt;&gt; lst = ['asometxt0moretxt', 'bsometxt1moretxt', 'aasometxt10moretxt', 'zzsometxt999moretxt']\n    &gt;&gt;&gt; find_delimiters(lst)\n    ['sometxt', 'moretxt']\n    \"\"\"\n    candidates = list(itertools.islice(find_longest_common_substrings(lst), 3))\n    if len(candidates) == 3 and len(candidates[1]) == len(candidates[2]):\n        raise ValueError(\"Unable to find useful delimiters\")\n    if candidates[1] in candidates[0]:\n        raise ValueError(\"Unable to find useful delimiters\")\n    return candidates[0:2]\n\ndef find_longest_common_substrings(lst):\n    \"\"\"\n    &gt;&gt;&gt; lst = ['asometxt0moretxt', 'bsometxt1moretxt', 'aasometxt10moretxt', 'zzsometxt999moretxt']\n    &gt;&gt;&gt; list(itertools.islice(find_longest_common_substrings(lst), 3))\n    ['sometxt', 'moretxt', 'sometx']\n    \"\"\"\n    for i in xrange(min_length(lst), 0, -1):\n        for substring in common_substrings(lst, i):\n            yield substring\n\n\ndef min_length(lst):\n    return min(len(item) for item in lst)\n\ndef common_substrings(lst, length):\n    \"\"\"\n    &gt;&gt;&gt; list(common_substrings([\"hello\", \"world\"], 2))\n    []\n    &gt;&gt;&gt; list(common_substrings([\"aabbcc\", \"dbbrra\"], 2))\n    ['bb']\n    \"\"\"\n    assert length &lt;= min_length(lst)\n    returned = set()\n    for i, item in enumerate(lst):\n        for substring in all_substrings(item, length):\n            in_all_others = True\n            for j, other_item in enumerate(lst):\n                if j == i:\n                    continue\n                if substring not in other_item:\n                    in_all_others = False\n            if in_all_others:\n                if substring not in returned:\n                    returned.add(substring)\n                    yield substring\n\ndef all_substrings(item, length):\n    \"\"\"\n    &gt;&gt;&gt; list(all_substrings(\"hello\", 2))\n    ['he', 'el', 'll', 'lo']\n    \"\"\"\n    for i in range(len(item) - length + 1):\n        yield item[i:i+length]\n</code>\n</pre>\n", "senID": 3}, {"text": ["split_strings splits the strings using the delimiters:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "split_strings", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\ndef split_strings(lst, delimiters):\n    \"\"\"\n    &gt;&gt;&gt; lst = ['asometxt0moretxt', 'bsometxt1moretxt', 'aasometxt10moretxt', 'zzsometxt999moretxt']\n    &gt;&gt;&gt; list(split_strings(lst, find_delimiters(lst)))\n    [('a', '0'), ('b', '1'), ('aa', '10'), ('zz', '999')]\n    \"\"\"\n    for item in lst:\n        parts = re.split(\"|\".join(delimiters), item)\n        yield tuple(part for part in parts if part != '')\n</code>\n</pre>\n", "senID": 5}], [{"text": ["This seems to be an example of the longest common subsequence problem.", "One way could be to look at how diffs are generated.", "The Hunt-McIlroy algorithm seems to have been the first, and is such the simplest, especially since it apparently is non-heuristic."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "longest common subsequence problem", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Longest%5Fcommon%5Fsubsequence%5Fproblem"}, {"text": "diffs", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Diff"}, {"text": "Hunt-McIlroy algorithm", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Hunt-McIlroy%5Falgorithm"}]}, {"text": ["The first link contains detailed discussion and (pseudo) code examples.", "Assuming, of course, Im not completely of the track here."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I guess you should start by identifying substrings (patterns) that frequently occur in the strings.", "Since naively counting substrings in a set of strings is rather computationally expensive, you'll need to come up with something smart."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I've done substring counting on a large amount of data using generalized suffix trees (example here).", "Once you know the most frequent substrings/patterns in the data, you can take it from there."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "generalized suffix trees", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Generalised%5Fsuffix%5Ftree"}, {"text": "(example here)", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://cosmion.net/jeroen/software/gst/"}]}], [{"text": ["This look much like the LZW algorithm for data (text) compression.", "There should be python implementations out there, which you may be able to adapt to your need."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "LZW", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Welch"}]}, {"text": ["I assume you have no a priori knowledge of these sub strings that repeat often."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["How about subbing out the known text, and then splitting?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n[re.sub('(sometxt|moretxt)', ',', x).split(',') for x in lst]\n# results in\n[['a', '0', ''], ['b', '1', ''], ['aa', '10', ''], ['zz', '999', '']]\n</code>\n</pre>\n", "senID": 1}]]