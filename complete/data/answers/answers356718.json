[[{"text": ["You can have the factory methods, it is fine.", "But why not just call it as it is?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Color(r, g, b)\nColor(*[r, g, b])\nColor(**{'r': r, 'g': g, 'b': b})\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is the python way.", "As for the from object constructor, I would prefer something like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Color(*Color2.as_list())\n</code>\n</pre>\n", "senID": 3}, {"text": ["Explicit is better than implicit - Python Zen"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Explicit is better than implicit", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["In general, use factory methods, marked up as @classmethods.", "They'll also work correctly on subclasses.", "From a design perspective, they are more explicit, especially when given a good name. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@classmethod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In this case, mixing everything together is probably more convenient, but it also makes the contract for your constructor more difficult."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Python doesn't accept multiple methods with the same name, period.", "One method does one thing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I've seen different approaches recommended on how to handle this ... classmethods (like you outlined above) or factory functions.", "I like keyword arguments the most."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Color (object):\n\n   def __init__(self, **parms):\n      if parms.get('list'):\n         self.r, self.g, self.b = parms['list'] \n      elif parms.get('color'):\n         color = parms['color']\n         self.r = color.r\n         self.g = color.g\n         self.b = color.b\n      else:\n         self.r = parms['red']\n         self.g = parms['green']\n         self.b = parms['blue']\n\nc1 = Color(red=220, green=0, blue=270)\nc2 = Color(list=[220, 0, 70])\nc3 = Color(color=c1)\n</code>\n</pre>\n", "senID": 2}, {"text": ["This fits the Python way of being explicit and readable, plus it easily allows you to add new arguments if needed. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT: Plus I don't have to look at the actual constructor code to understand the arguments.", "The explanation is supplied by the keyword."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["On the __add__ issue:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__add__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["First, you cannot get \"three integers\", I assume you mean a 3-tuple of integers?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In that case, you won't get around some isinstance calls:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "isinstance", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def __add__(self, other):\n    if isinstance(other, Color):\n        ...\n    elif isinstance(other, (int, long)):\n        ...\n    elif len(other) == 3 and all(isinstance(e, (int, long)) for e in other):\n        ...\n    else:\n        raise TypeError(\"Can only add Color to Color, int or three-tuple\")\n</code>\n</pre>\n", "senID": 3}, {"text": ["You might also want to add implementations of __radd__, so that you can handle"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "__radd__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 1 + Color(1, 2, 3)\n</code>\n</pre>\n", "senID": 5}, {"text": ["but that's just"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def __radd__(self, other):\n    return self.__add__(other)\n</code>\n</pre>\n", "senID": 7}, {"text": ["although strictly, it will never be called when type(other) is Color. "], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "type(other) is Color", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Also, do not forget __iadd__ to support +=."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "__iadd__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["My first advise is to use factory methods."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Although if you really want a single method, give it something to dispatch on for\nhandling the parameters. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def __init__(self, method, *args, **kw):\n    getattr(self, '_init_'+method)(*args, **kw)\n\ndef _init_coponents(self, r, g, b):\n    ...\ndef _init_fromColor(self, color):\n    ...\n</code>\n</pre>\n", "senID": 2}, {"text": ["And use like:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n c1 = Color('components', 0, 0, 0,)\nc2 = Color('fromColor', c1)\n</code>\n</pre>\n", "senID": 4}, {"text": ["While this adds another parameter, it is still way better than type tests and keeps stuff explicit.", "It provides nice exceptions out of the box on illegal calls, and is easily extendable even in subclasses."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Python always fully replaces methods with the same name.", "Unlike C# that, if I remember correctly, will make the methods with the same name options for different argument input."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If there's only a variation of one in the keywords, like either 3 or 4 arguments of the same type, I'd say using a preset of the last argument, or all of them, would be the way to go."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["However, if you want lists, tuples and other types, you should probably go for the arbitrary arguments list and test the contents of that in the function"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def function(*args):\n    if type(args[0]) is int:\n        dothis()\n    #and so on\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You can check the type of the argument passed to your constructor inside:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def __init__(self, r = 0, g = 0, b = 0):\n    # if r is a list\n    if (type(r) == type([1,2,3])):\n        r, g, b = r[0], r[1], r[2]\n    # if r is a color\n    if (type(r) == type(self)):\n        r, g, b = r.r, r.g, r.b\n    self.r = r\n    self.g = g\n    self.b = b\n</code>\n</pre>\n", "senID": 1}, {"text": ["Maybe that will help."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]