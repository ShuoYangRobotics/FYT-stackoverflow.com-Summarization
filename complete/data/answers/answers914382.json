[[{"text": ["Using bash/UNIX commands:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sed -e 's/[[:space:]]\\+/\\n/g' $FILE | sort -fu | wc -l\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In Perl:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n my %words; \nwhile (&lt;&gt;) { \n    map { $words{lc $_} = 1 } split /\\s/); \n} \nprint scalar keys %words, \"\\n\";\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In Python 2.4 (possibly it works on earlier systems as well):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #! /usr/bin/python2.4\nimport sys\nh = set()\nfor line in sys.stdin.xreadlines():\n  for term in line.split():\n    h.add(term)\nprint len(h)\n</code>\n</pre>\n", "senID": 1}, {"text": ["In Perl:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ perl -ne 'for (split(\" \", $_)) { $H{$_} = 1 } END { print scalar(keys%H), \"\\n\" }' &lt;file.txt\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Using just standard Unix utilities:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &lt; somefile tr 'A-Z[:blank:][:punct:]' 'a-z\\n' | sort | uniq -c\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you're on a system without Gnu tr, you'll need to replace \"[:blank:][:punct:]\" with a list of all the whitespace and punctuation characters you'd like to consider to be separators of words, rather than part of a word, e.g., \"\\t.,;\"."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "tr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[:blank:][:punct:]", "childNum": 0, "tag": "code", "childList": []}, {"text": "\\t.,;", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you want the output sorted in descending order of frequency, you can append \"| sort -r -n\" to the end of this."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "| sort -r -n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Note that this will produce an irrelevant count of whitespace tokens as well; if you're concerned about this, after the tr you can use sed to filter out the empty lines."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "tr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Here is a Perl one-liner:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n perl -lne '$h{lc $_}++ for split /[\\s.,]+/; END{print scalar keys %h}' file.txt\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or to list the count for each item:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n perl -lne '$h{lc $_}++ for split /[\\s.,]+/; END{printf \"%-12s %d\\n\", $_, $h{$_} for sort keys %h}' file.txt\n</code>\n</pre>\n", "senID": 3}, {"text": ["This makes an attempt to handle punctuation so that \"foo.", "\" is counted with \"foo\" while \"don't\" is treated as a single word, but you can adjust the regex to suit your needs. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Simply (52 strokes):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n perl -nE'@w{map lc,split/\\W+/}=();END{say 0+keys%w}'\n</code>\n</pre>\n", "senID": 1}, {"text": ["For older perl versions (55 strokes):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n perl -lne'@w{map lc,split/\\W+/}=();END{print 0+keys%w}'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["A shorter version in Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n print len(set(w.lower() for w in open('filename.dat').read().split()))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Reads the entire file into memory, splits it into words using whitespace, converts each word to lower case, creates a (unique) set from the lowercase words, counts them and prints the output."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Also possible using a one liner:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n python -c \"print len(set(w.lower() for w in open('filename.dat').read().split()))\"\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Here is an awk oneliner."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ gawk -v RS='[[:space:]]' 'NF&amp;&amp;!a[toupper($0)]++{i++}END{print i}' somefile\n</code>\n</pre>\n", "senID": 1}, {"tag": "ul", "num": 2, "lis": [{"text": "'NF' means 'if there is a charactor'.", "tag": "none", "senID": 2}, {"text": "'!a[topuuer[$0]++]' means 'show only \nuniq words'.", "tag": "none", "senID": 3}]}]]