[[{"text": ["Why regexp?", "I should use split(' ') and use value next to 'version', or simplier:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n print results.split(' ')[5]\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you must use regexp then try:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n rx = re.compile('version\\s+([\\d.]+)\\s+')\nrxx = rx.search(results)\nif rxx:\n    print rxx.group(1)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["here's a non regex way"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s=\"Name Info Type Call version 1.0.40.437 Fri Oct  2 10:54:35 BST 2009\".split()\n&gt;&gt;&gt; for n,i in enumerate(s):\n...   if \"version\" in i:\n...     print s[n+1]\n...\n1.0.40.437\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; r = re.compile(r'version (\\S*)')\n&gt;&gt;&gt; r.findall(results)\n['1.0.40.437']\n</code>\n</pre>\n", "senID": 0}, {"text": ["Non regexp way"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; m=results.split()\n&gt;&gt;&gt; m[m.index('version')+1]\n'1.0.40.437'\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; results = \"Name Info Type Call version 1.0.40.437 Fri Oct  2 10:54:35 BST 2009\"\n&gt;&gt;&gt; m = re.search(\"version ([^ ]+)\", results)\n&gt;&gt;&gt; if m:\n...   version = m.group(1)\n...   print \"matched, found:\", version\n... else:\n...   print \"didn't find a version\"\n... \nmatched, found: 1.0.40.437\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I can spot a couple of things:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["You say results is a string, but you're iterating through it - so l is a character each time."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "results", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "l", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["re.match only matches at the beginning of a string.", "Use re.search instead."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "re.match", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "beginning", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "re.search", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]}], [{"text": ["I'm going to assume that the version format is fixed (ie.", "version.major.minor.revision)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "version.major.minor.revision", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n reVersion = re.compile( 'version\\s+((((\\d+)\\.(\\d+))\\.(\\d+)).(\\S+))\\s+', re.I )\n\nfor result in results:\n    versionMatch = reVersion.match( result )\n    if versionMatch:\n        version = versionMatch.groups()\n        print( version[0] ) # 1.0.40.437  full version\n        print( version[1] ) # 1.0.40      version.major.minor - no revision\n        print( version[2] ) # 1.0         version.major\n        print( version[3] ) # 1           version\n        print( version[4] ) # 0           major\n        print( version[5] ) # 40          minor\n        print( version[6] ) # 437         revision\n</code>\n</pre>\n", "senID": 1}]]