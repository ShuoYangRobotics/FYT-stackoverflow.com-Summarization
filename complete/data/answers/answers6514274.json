[[{"text": ["The psycopg2 documentation explicitly recommends using normal python % or {} formatting to substitute in table and column names (or other bits of dynamic syntax), and then using the parameter mechanism to substitute values into the query."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "psycopg2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I disagree with everyone who is saying \"don't ever use dynamic table/column names, you're doing something wrong if you need to\".", "I write programs to automate stuff with databases every day, and I do it all the time.", "We have lots of databases with lots of tables, but they are all built on repeated patterns, so generic code to handle them is extremely useful.", "Hand-writing the queries every time would be far more error prone and dangerous."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "extremely", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["It comes down to what \"safe\" means.", "The conventional wisdom is that using normal python string manipulation to put values into your queries is not \"safe\".", "This is because there are all sorts of things that can go wrong if you do that, and such data very often comes from the user and is not in your control.", "You need a 100% reliable way of escaping these values properly so that a user cannot inject SQL in a data value and have the database execute it.", "So the library writers do this job; you never should."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If, however, you're writing generic helper code to operate on things in databases, then these considerations don't apply as much.", "You are implicitly giving anyone who can call such code access to everything in the database; that's the point of the helper code.", "So now the safety concern is making sure that user-generated data can never be used in such code.", "This is a general security issue in coding, and is just the same problem as blindly execing a user-input string.", "It's a distinct issue from inserting values into your queries, because there you want to be able to safely handle user-input data."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "that's the point of the helper code", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "exec", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "values", "childNum": 0, "tag": "em", "pos": 4, "childList": []}, {"text": "want", "childNum": 0, "tag": "strong", "childList": []}, {"text": "safely", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["So my recommendation is: do whatever you want to dynamically assemble your queries.", "Use normal python string templating to sub in table and column names, glue on where clauses and joins, all the good (and horrible to debug) stuff.", "But make sure you're aware that whatever values such code touches has to come from you, not your users[1].", "Then you use SQLite's parameter substitution functionality to safely insert user-input values into your queries as values."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "you", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "safely", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"text": ["[1] If (as is the case for a lot of the code I write) your users are the people who have full access to databases anyway and the code is to simplify their work, then this consideration doesn't really apply; you probably are assembling queries on user-specified tables.", "But you should still use SQLite's parameter substitution to save yourself from the inevitable genuine value that eventually contains quotes or percent signs."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "are", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["If you're quite certain that you need to specify column names dynamically, you should use a library that can do so safely (and complains about things that are wrong).", "SQLAlchemy is very good at that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import sqlalchemy\n&gt;&gt;&gt; from sqlalchemy import *\n&gt;&gt;&gt; metadata = MetaData()\n&gt;&gt;&gt; dynamic_column = \"cow\"\n&gt;&gt;&gt; foo_table = Table('foo', metadata,\n...     Column(dynamic_column, Integer))\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["foo_table now represents the table with the dynamic schema, but you can only use it in the context of an actual database connection (so that sqlalchemy knows the dialect, and what to do with the generated sql)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "foo_table", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "represents", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; metadata.bind = create_engine('sqlite:///:memory:', echo=True)\n</code>\n</pre>\n", "senID": 3}, {"text": ["You can then issue the CREATE TABLE ....  with echo=True, sqlalchemy will log the generated sql, but in general, sqlalchemy goes out of its way to keep the generated sql out of your hands (lest you consider using it for evil purposes)."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "CREATE TABLE ...", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "echo=True", "childNum": 0, "tag": "code", "childList": []}, {"text": "log", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; foo_table.create()\n2011-06-28 21:54:54,040 INFO sqlalchemy.engine.base.Engine.0x...2f4c \nCREATE TABLE foo (\n    cow INTEGER\n)\n2011-06-28 21:54:54,040 INFO sqlalchemy.engine.base.Engine.0x...2f4c ()\n2011-06-28 21:54:54,041 INFO sqlalchemy.engine.base.Engine.0x...2f4c COMMIT\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 5}, {"text": ["and yes, sqlalchemy will take care of any column names that need special handling, like when the column name is a sql reserved word"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dynamic_column = \"order\"\n&gt;&gt;&gt; metadata = MetaData()\n&gt;&gt;&gt; foo_table = Table('foo', metadata,\n...     Column(dynamic_column, Integer))\n&gt;&gt;&gt; metadata.bind = create_engine('sqlite:///:memory:', echo=True)\n&gt;&gt;&gt; foo_table.create()\n2011-06-28 22:00:56,267 INFO sqlalchemy.engine.base.Engine.0x...aa8c \nCREATE TABLE foo (\n    \"order\" INTEGER\n)\n2011-06-28 22:00:56,267 INFO sqlalchemy.engine.base.Engine.0x...aa8c ()\n2011-06-28 22:00:56,268 INFO sqlalchemy.engine.base.Engine.0x...aa8c COMMIT\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 7}, {"text": ["and can save you from possible badness:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dynamic_column = \"); drop table users; -- the evil bobby tables!\"\n&gt;&gt;&gt; metadata = MetaData()\n&gt;&gt;&gt; foo_table = Table('foo', metadata,\n...     Column(dynamic_column, Integer))\n&gt;&gt;&gt; metadata.bind = create_engine('sqlite:///:memory:', echo=True)\n&gt;&gt;&gt; foo_table.create()\n2011-06-28 22:04:22,051 INFO sqlalchemy.engine.base.Engine.0x...05ec \nCREATE TABLE foo (\n    \"); drop table users; -- the evil bobby tables!\" INTEGER\n)\n2011-06-28 22:04:22,051 INFO sqlalchemy.engine.base.Engine.0x...05ec ()\n2011-06-28 22:04:22,051 INFO sqlalchemy.engine.base.Engine.0x...05ec COMMIT\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 9}, {"text": ["(apparently, some strange things are perfectly legal identifiers in sqlite)"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["Putting up a bounty didn't produce a solution to this, so I've spent a while figuring out the best one I could.", "I don't have any source confirming that this is the correct way to do it, so use at your own risk."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To convert any string into a SQLite identifier:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Ensure the string can be encoded as UTF-8.", "tag": "none", "senID": 2}, {"text": "Ensure the string does not include any NUL characters.", "tag": "none", "senID": 3}, {"text": "Replace all ", "tag": "none", "senID": 4}, {"text": "Wrap the entire thing in double quotes.", "tag": "none", "senID": 5}]}, {"text": ["My implementation:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre class=\"lang-python prettyprint-override\">\n<code>\n import codecs\n\ndef quote_identifier(s, errors=\"strict\"):\n    encodable = s.encode(\"utf-8\", errors).decode(\"utf-8\")\n\n    nul_index = encodable.find(\"\\x00\")\n\n    if nul_index &gt;= 0:\n        error = UnicodeEncodeError(\"NUL-terminated utf-8\", encodable,\n                                   nul_index, nul_index + 1, \"NUL not allowed\")\n        error_handler = codecs.lookup_error(errors)\n        replacement, _ = error_handler(error)\n        encodable = encodable.replace(\"\\x00\", replacement)\n\n    return \"\\\"\" + encodable.replace(\"\\\"\", \"\\\"\\\"\") + \"\\\"\"\n</code>\n</pre>\n", "senID": 7}, {"text": ["Given a string single argument, it will escape and quote it correctly or raise an exception.", "The second argument can be used to specify any error handler registered in thecodecsmodule.", "The built-in ones are:"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "thecodecsmodule", "tag": "a", "pos": 1, "childList": [{"text": "codecs", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/codecs.html"}, {"text": "codecs", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["This doesn't check for reserved identifiers, so if you try to create a new SQLITE_MASTER table it won't stop you."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "SQLITE_MASTER", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre class=\"lang-python prettyprint-override\">\n<code>\n import sqlite3\n\ndef test_identifier(identifier):\n    \"Tests an identifier to ensure it's handled properly.\"\n\n    with sqlite3.connect(\":memory:\") as c:\n        c.execute(\"CREATE TABLE \" + quote_identifier(identifier) + \" (foo)\")\n        assert identifier == c.execute(\"SELECT name FROM SQLITE_MASTER\").fetchone()[0]\n\ntest_identifier(\"'H\u00e9llo?'\\\\\\n\\r\\t\\\"Hello!\\\" -\u2603\") # works\ntest_identifier(\"\u5317\u65b9\u8bdd\") # works\ntest_identifier(chr(0x20000)) # works\n\nprint(quote_identifier(\"Fo\\x00o!\", \"replace\")) # prints \"Fo?o!\"\nprint(quote_identifier(\"Fo\\x00o!\", \"ignore\")) # prints \"Foo!\"\nprint(quote_identifier(\"Fo\\x00o!\")) # raises UnicodeEncodeError\nprint(quote_identifier(chr(0xD800))) # raises UnicodeEncodeError\n</code>\n</pre>\n", "senID": 10}, {"tag": "ul", "num": 6, "lis": [{"text": "SQLite identifiers are ", "tag": "none", "senID": 11}, {"text": "SQLite identifiers are quoted using double-quotes.\n", "tag": "none", "senID": 12}, {"text": "Double-quotes in SQLite identifiers are escaped as two double quotes.", "tag": "none", "senID": 13}, {"text": "SQLite identifiers preserve case, but they are case-insensitive towards ASCII letters. It is possible to enable unicode-aware case-insensitivity.\n", "tag": "none", "senID": 14}, {"text": "SQLite stops reading queries at the ", "tag": "none", "senID": 15}, {"text": ["sqlite3"], "childNum": 0, "tag": "code", "senID": 16, "childList": []}]}], [{"text": ["The first thing to understand is that table/column names cannot be escaped in the same sense than you can escape strings stored as database values. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "first", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "cannot", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["The reason is that you either have to:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "accept/reject the potential table/column name, i.e. it is not guaranteed that a string is an acceptable column/table name, contrarily to a string to be stored in some database; or,", "tag": "none", "senID": 2}, {"text": "sanitize the string which will have the same effect as creating a digest: the function used is ", "tag": "none", "senID": 3}]}, {"text": ["Having understood that, the second thing to understand is that how you will end up \"escaping\" table/column names depends on your specific context, and so there is more than one way to do this, but whatever the way, you'll need to dig up to figure out exactly what is or is not an acceptable column/table name in sqlite. "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "second", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["To get you started, here is one condition: "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Even better, using certain column names can have unintended side effects:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Both quoted texts are from http://www.sqlite.org/lang_createtable.html"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "http://www.sqlite.org/lang_createtable.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sqlite.org/lang_createtable.html"}]}], [{"text": ["From the sqlite faq, question 24 (the formulation of the question of course does not give a clue that the answer may be useful to your question):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sqlite faq, question 24", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sqlite.org/faq.html#q24"}]}, {"text": ["If the name itself contains double quotes, escape that double quote with another one."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Placeholders are only for values.", "Column and table names are structural, and are akin to variable names; you can't use placeholders to fill them in."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You have three options:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If you find that you need a variable entity name (either relvar or field) then you probably are doing something wrong.", "an alternative pattern would be to use a property map, something like: "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "wrong", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n CREATE TABLE foo_properties(\n    id INTEGER NOT NULL,\n    name VARCHAR NOT NULL,\n    value VARCHAR,\n    PRIMARY KEY(id, name)\n);\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then, you just specify the name dynamically when doing an insert instead of a column."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]