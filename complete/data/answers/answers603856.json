[[{"text": ["The urllib2 library uses OpenerDirector objects to handle the actual opening.", "Fortunately, the python library provides defaults so you don't have to.", "It is, however, these OpenerDirector objects that are adding the extra headers."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To see what they are after the request has been sent (so that you can log it, for example):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n req = urllib2.Request(url='http://google.com')\nresponse = urllib2.urlopen(req)\nprint req.unredirected_hdrs\n\n(produces {'Host': 'google.com', 'User-agent': 'Python-urllib/2.5'} etc)\n</code>\n</pre>\n", "senID": 2}, {"text": ["The unredirected_hdrs is where the OpenerDirectors dump their extra headers.", "Simply looking at req.headers will show only your own headers - the library leaves those unmolested for you."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "req.headers", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If you need to see the headers before you send the request, you'll need to subclass the OpenerDirector in order to intercept the transmission."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Hope that helps."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["EDIT: I forgot to mention that, once the request as been sent, req.header_items() will give you a list of tuples of ALL the headers, with both your own and the ones added by the OpenerDirector.", "I should have mentioned this first since it's the most straightforward :-) Sorry."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "req.header_items()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["EDIT 2: After your question about an example for defining your own handler, here's the sample I came up with.", "The concern in any monkeying with the request chain is that we need to be sure that the handler is safe for multiple requests, which is why I'm uncomfortable just replacing the definition of putheader on the HTTPConnection class directly."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Sadly, because the internals of HTTPConnection and the AbstractHTTPHandler are very internal, we have to reproduce much of the code from the python library to inject our custom behaviour.", "Assuming I've not goofed below and this works as well as it did in my 5 minutes of testing, please be careful to revisit this override if you update your Python version to a revision number (ie: 2.5.x to 2.5.y or 2.5 to 2.6, etc)."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["I should therefore mention that I am on Python 2.5.1.", "If you have 2.6 or, particularly, 3.0, you may need to adjust this accordingly."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Please let me know if this doesn't work.", "I'm having waaaayyyy too much fun with this question:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n import urllib2\nimport httplib\nimport socket\n\n\nclass CustomHTTPConnection(httplib.HTTPConnection):\n\n    def __init__(self, *args, **kwargs):\n        httplib.HTTPConnection.__init__(self, *args, **kwargs)\n        self.stored_headers = []\n\n    def putheader(self, header, value):\n        self.stored_headers.append((header, value))\n        httplib.HTTPConnection.putheader(self, header, value)\n\n\nclass HTTPCaptureHeaderHandler(urllib2.AbstractHTTPHandler):\n\n    def http_open(self, req):\n        return self.do_open(CustomHTTPConnection, req)\n\n    http_request = urllib2.AbstractHTTPHandler.do_request_\n\n    def do_open(self, http_class, req):\n        # All code here lifted directly from the python library\n        host = req.get_host()\n        if not host:\n            raise URLError('no host given')\n\n        h = http_class(host) # will parse host:port\n        h.set_debuglevel(self._debuglevel)\n\n        headers = dict(req.headers)\n        headers.update(req.unredirected_hdrs)\n        headers[\"Connection\"] = \"close\"\n        headers = dict(\n            (name.title(), val) for name, val in headers.items())\n        try:\n            h.request(req.get_method(), req.get_selector(), req.data, headers)\n            r = h.getresponse()\n        except socket.error, err: # XXX what error?\n            raise urllib2.URLError(err)\n        r.recv = r.read\n        fp = socket._fileobject(r, close=True)\n\n        resp = urllib2.addinfourl(fp, r.msg, req.get_full_url())\n        resp.code = r.status\n        resp.msg = r.reason\n\n        # This is the line we're adding\n        req.all_sent_headers = h.stored_headers\n        return resp\n\nmy_handler = HTTPCaptureHeaderHandler()\nopener = urllib2.OpenerDirector()\nopener.add_handler(my_handler)\nreq = urllib2.Request(url='http://www.google.com')\n\nresp = opener.open(req)\n\nprint req.all_sent_headers\n\nshows: [('Accept-Encoding', 'identity'), ('Host', 'www.google.com'), ('Connection', 'close'), ('User-Agent', 'Python-urllib/2.5')]\n</code>\n</pre>\n", "senID": 11}], [{"text": ["If you want to see the literal request text that is sent out, and therefore see every last header exactly as it is represented on the wire, then you can tell urllib to use your own version of an HTTPHandler that prints out (or saves, or whatever) the outgoing HTTP request."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "urllib", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "HTTPHandler", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import httplib, urllib\n\nclass MyHTTPConnection(httplib.HTTPConnection):\n    def send(self, s):\n        print s  # or save them, or whatever!\n        httplib.HTTPConnection.send(self, s)\n\nclass MyHTTPHandler(urllib2.HTTPHandler):\n    def http_open(self, req):\n        return self.do_open(MyHTTPConnection, req)\n\nopener = urllib2.build_opener(MyHTTPHandler)\nresponse = opener.open('http://www.google.com/')\n</code>\n</pre>\n", "senID": 1}, {"text": ["The result of running this code is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n GET / HTTP/1.1\nAccept-Encoding: identity\nHost: www.google.com\nConnection: close\nUser-Agent: Python-urllib/2.6\n</code>\n</pre>\n", "senID": 3}], [{"text": ["How about something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import urllib2\nimport httplib\n\nold_putheader = httplib.HTTPConnection.putheader\ndef putheader(self, header, value):\n    print header, value\n    old_putheader(self, header, value)\nhttplib.HTTPConnection.putheader = putheader\n\nurllib2.urlopen('http://www.google.com')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A low-level solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n import httplib\n\nclass HTTPConnection2(httplib.HTTPConnection):\n    def __init__(self, *args, **kwargs):\n        httplib.HTTPConnection.__init__(self, *args, **kwargs)\n        self._request_headers = []\n        self._request_header = None\n\n    def putheader(self, header, value):\n        self._request_headers.append((header, value))\n        httplib.HTTPConnection.putheader(self, header, value)\n\n    def send(self, s):\n        self._request_header = s\n        httplib.HTTPConnection.send(self, s)\n\n    def getresponse(self, *args, **kwargs):\n        response = httplib.HTTPConnection.getresponse(self, *args, **kwargs)\n        response.request_headers = self._request_headers\n        response.request_header = self._request_header\n        return response\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n conn = HTTPConnection2(\"www.python.org\")\nconn.request(\"GET\", \"/index.html\", headers={\n    \"User-agent\": \"test\",\n    \"Referer\": \"/\",\n})\nresponse = conn.getresponse()\n</code>\n</pre>\n", "senID": 3}, {"text": ["response.status, response.reason:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n 1: 200 OK\n</code>\n</pre>\n", "senID": 5}, {"text": ["response.request_headers:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n [('Host', 'www.python.org'), ('Accept-Encoding', 'identity'), ('Referer', '/'), ('User-agent', 'test')]\n</code>\n</pre>\n", "senID": 7}, {"text": ["response.request_header:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n GET /index.html HTTP/1.1\nHost: www.python.org\nAccept-Encoding: identity\nReferer: /\nUser-agent: test\n</code>\n</pre>\n", "senID": 9}], [{"text": ["A other solution, witch used the idea from How do you get default headers in a urllib2 Request?", "But doesn't copy code from std-lib:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "How do you get default headers in a urllib2 Request?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/603856/how-do-you-get-default-headers-in-a-urllib2-request/603966#603966"}]}, {"code": "<pre>\n<code>\n class HTTPConnection2(httplib.HTTPConnection):\n    \"\"\"\n    Like httplib.HTTPConnection but stores the request headers.\n    Used in HTTPConnection3(), see below.\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        httplib.HTTPConnection.__init__(self, *args, **kwargs)\n        self.request_headers = []\n        self.request_header = \"\"\n\n    def putheader(self, header, value):\n        self.request_headers.append((header, value))\n        httplib.HTTPConnection.putheader(self, header, value)\n\n    def send(self, s):\n        self.request_header = s\n        httplib.HTTPConnection.send(self, s)\n\n\nclass HTTPConnection3(object):\n    \"\"\"\n    Wrapper around HTTPConnection2\n    Used in HTTPHandler2(), see below.\n    \"\"\"\n    def __call__(self, *args, **kwargs):\n        \"\"\"\n        instance made in urllib2.HTTPHandler.do_open()\n        \"\"\"\n        self._conn = HTTPConnection2(*args, **kwargs)\n        self.request_headers = self._conn.request_headers\n        self.request_header = self._conn.request_header\n        return self\n\n    def __getattribute__(self, name):\n        \"\"\"\n        Redirect attribute access to the local HTTPConnection() instance.\n        \"\"\"\n        if name == \"_conn\":\n            return object.__getattribute__(self, name)\n        else:\n            return getattr(self._conn, name)\n\n\nclass HTTPHandler2(urllib2.HTTPHandler):\n    \"\"\"\n    A HTTPHandler which stores the request headers.\n    Used HTTPConnection3, see above.\n\n    &gt;&gt;&gt; opener = urllib2.build_opener(HTTPHandler2)\n    &gt;&gt;&gt; opener.addheaders = [(\"User-agent\", \"Python test\")]\n    &gt;&gt;&gt; response = opener.open('http://www.python.org/')\n\n    Get the request headers as a list build with HTTPConnection.putheader():\n    &gt;&gt;&gt; response.request_headers\n    [('Accept-Encoding', 'identity'), ('Host', 'www.python.org'), ('Connection', 'close'), ('User-Agent', 'Python test')]\n\n    &gt;&gt;&gt; response.request_header\n    'GET / HTTP/1.1\\\\r\\\\nAccept-Encoding: identity\\\\r\\\\nHost: www.python.org\\\\r\\\\nConnection: close\\\\r\\\\nUser-Agent: Python test\\\\r\\\\n\\\\r\\\\n'\n    \"\"\"\n    def http_open(self, req):\n        conn_instance = HTTPConnection3()\n        response = self.do_open(conn_instance, req)\n        response.request_headers = conn_instance.request_headers\n        response.request_header = conn_instance.request_header\n        return response\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: Update the source"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["see urllib2.py:do_request (line 1044 (1067)) and urllib2.py:do_open (line 1073)\n(line 293) self.addheaders = [('User-agent', client_version)] (only 'User-agent' added)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["It sounds to me like you're looking for the headers of the response object, which include Connection: close, etc.", "These headers live in the object returned by urlopen.", "Getting at them is easy enough: "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Connection: close", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from urllib2 import urlopen\nreq = urlopen(\"http://www.google.com\")\nprint req.headers.headers\n</code>\n</pre>\n", "senID": 1}, {"text": ["req.headers is a instance of httplib.HTTPMessage"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "req.headers", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/httplib.html?highlight=httplib.httpmessage#httplib.HTTPMessage", "text": "httplib.HTTPMessage", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["It should send the default http headers (as specified by w3.org) alongside the ones you specify.", "You can use a tool like WireShark if you would like to see them in their entirety."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "w3.org", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html"}, {"text": "WireShark", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.wireshark.org/"}]}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If you would like to log them, you can use WinPcap to capture packets sent by specific applications (in your case, python).", "You can also specify the type of packets and many other details."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "WinPcap", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.winpcap.org/"}]}, {"text": ["-John"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]