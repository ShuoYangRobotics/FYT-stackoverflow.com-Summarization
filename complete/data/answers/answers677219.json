[[{"text": ["Coverage.py now includes branch coverage.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Coverage.py now includes branch coverage", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://nedbatchelder.com/code/coverage/branch.html"}]}, {"text": ["For the curious: the code is not modified before running.", "The trace function tracks which lines follow which in the execution, and compare that information with static analysis of the compiled byte code to find path possibilities not executed."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Are you looking for cyclomatic complexity (Wikipedia)?", "It basically computes the number of paths through a piece of code.", "There are some projects to compute that for Python code, for example PyMetrics or this one.", "Google will certainly bring up more."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "cyclomatic complexity (Wikipedia)", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Cyclomatic%5Fcomplexity"}, {"text": "PyMetrics", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://sourceforge.net/projects/pymetrics/"}, {"text": "this one", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.traceback.org/2008/03/31/measuring-cyclomatic-complexity-of-python-code/"}]}, {"text": ["But I don't know of any further integration with unit tests that will show you the coverage."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I don't know of any branch coverage tools for Python, though I've contemplated writing one.", "My thought was to start with the AST and insert additional instrumentation for each branch point.", "It's doable, but there are some tricky cases."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example,"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n raise SomeException(x)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Branch coverage for this needs to check that SomeException(x) was fully instantiated and didn't raise its own exception."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n assert x, \"Oh No!: %r\" % (x, y)\n</code>\n</pre>\n", "senID": 4}, {"text": ["This needs to check that the text on the right side of the assertion statement is fully evaluated."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n return args.name or os.getenv(\"NAME\") or die(\"no name present\")\n</code>\n</pre>\n", "senID": 6}, {"text": ["Each of the first two terms has to be checked for the true/false path, but not the last.", "In fact, the last might not even return."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["There were a lot of cases to worry about and I had no pressing need for it other than curiosity so I didn't go anywhere with it.", "I was also wondering if I would get a lot of false positives where I would need some way to repress specific warnings."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["If you want to try this route, start with Python 2.6 or 3.0.", "In those releases the AST module is documented and you can create your own AST nodes before generating the code or .pyc file."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["The very same maintainer of coverage.py has an article discussing a way to get coverage information at the bytecode level.", "The method is a bit kludgey: it involves re-assembling .pyc files with tweaked line numbers.", "However, it provides about as much granularity in coverage measurement as you could ask for."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "get coverage information at the bytecode level", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://nedbatchelder.com/blog/200804/wicked%5Fhack%5Fpython%5Fbytecode%5Ftracing.html"}]}], [{"text": ["I haven't used it myself, but if you are willing to replace coverage analysis with mutation testing, I've heard of a mutation tester called \"pester\"."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "mutation testing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Mutation%5Ftesting"}]}, {"text": ["While I was doing googling, I also came across a list of python testing tools which mentions some possible code coverage tools."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "a list of python testing tools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.pycheesecake.org/wiki/PythonTestingToolsTaxonomy"}]}], [{"text": ["Parse and modify the AST is the right answer, IMHO.", "See this paper\nfor a complete description of what you need to do:\n\"Branch Coverage Made Easy for Arbitrary Languages\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.semanticdesigns.com/Company/Publications/TestCoverage.pdf"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.semanticdesigns.com/Company/Publications/TestCoverage.pdf", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.semanticdesigns.com/Company/Publications/TestCoverage.pdf"}]}]]