[[{"text": ["Since I don't know the structure of your data or the nature of the similarity you are seeking, I can only guess at what might work.", "But perhaps you could build some kind of prefix tree using dictionaries.", "As in:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "prefix tree", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Trie"}]}, {"code": "<pre>\n<code>\n trie = {'a':{'b':{'e':{}, 's':{}}, 'c':{'t':{}, 'k':{}}}}\n</code>\n</pre>\n", "senID": 1}, {"text": ["These are most commonly used for looking up strings with common prefixes, but perhaps there's some sense in which the data in your objects can be represented as a string.", "This seems like it would work especially well if there's some order the data can be put in such that earlier data in the string must compare as ==.", "I think I can even imagine the leaves of the trie including all similar, rather than all strictly equivalent, objects."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "==", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["A small toy example of how to work with a trie:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; trie = {'a':{'b':{'e':{}, 's':{}}, 'c':{'t':{}, 'k':{}}}}\n&gt;&gt;&gt; def rec_print(trie, accum=''):\n...     if trie:\n...         for k in trie:\n...             rec_print(trie[k], accum + k)\n...     else:\n...         print accum\n... \n&gt;&gt;&gt; rec_print(trie)\nack\nact\nabs\nabe\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Your approach looks quite good to me if you only want the like objects of a few objects."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "if", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["There is also nothing wrong with defining __hash__() for your own class."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "__hash__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "own", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["If you want to group all your objects in classes of \"like\" objects, then there is a faster approach: you can use the transitivity of your like() method.", "In fact, if like(obj0, obj1) and like(obj1, obj2) are true, then like(obj0, obj2) is automatically true, with no need for further calculations.", "This means that you can directly group all your objects in classes with the efficient"], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "all", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "transitivity", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "like()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "like(obj0, obj1)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "like(obj1, obj2)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "like(obj0, obj2)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n signature = lambda obj: (obj.period, obj.typed_dimensions.keys())\nsorted_objs = sorted(dic.values(), key=signature)\nobjs_in_like_classes = [list(group) for (_, group) in itertools.groupby(sorted_objs, key=signature)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["This groups like objects together, automatically.", "This is simpler, and is likely faster than defining __hash__() and __eq__() and doing the prefetching by yourself, because groupby() uses the transitivity of ==."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "__hash__()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__eq__()", "childNum": 0, "tag": "code", "childList": []}, {"text": "groupby()", "childNum": 0, "tag": "code", "childList": []}, {"text": "==", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["(PS: I prefer Michael J. Barber's \"dictionary of like objects grouped by hashable signature\" approach to this solution, because it is probably a tad faster, and is also more general, as no sorting is necessary."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "PS", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If you need to keep your current approach, you can do it in a slightly cleaner way: you could check whether you really need any of these if other is not None tests.", "If you want to handle comparisons (__eq__) properly, you should also handle the case of other being of a different class (instead of checking only for identity with None); an isinstance() would do.", "like() might be different, if you only ever compare objects of class MyObject.", "In this case, your code should look something like:"], "childNum": 7, "tag": "p", "senID": 6, "childList": [{"text": "if other is not None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__eq__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "other", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "isinstance()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "like()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "MyObject", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def __eq__(self, other):\n    if isinstance(other, MyObject):\n        return (self.period == other.period\n                and self.typed_dimensions == other.typed_dimensions)\n    else:\n        return False\n\ndef like(self, other):\n    return (self.period == other.period  # No need for a backslash\n            and self.typed_dimensions.keys() == other.typed_dimensions.keys())\n</code>\n</pre>\n", "senID": 7}, {"text": ["This would make the code cleaner (but not really faster)."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["You could make your __hash__() function a tad faster by not doing self._hash = None in __init__() and by writing:"], "childNum": 4, "tag": "p", "senID": 9, "childList": [{"text": "__hash__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "em", "childList": []}, {"text": "self._hash = None", "childNum": 0, "tag": "code", "childList": []}, {"text": "__init__()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def __hash__(self):\n    try:\n        return self._hash\n    except AttributeError:\n        self._hash = (hash(self.periodtype) ^\n                      hash(tuple(sorted(self.dimensions.values()))))\n        return self._hash\n</code>\n</pre>\n", "senID": 10}, {"text": ["In fact, try is fast when no exception is raised (which is the most common case by far, in your case)."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "try", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["As for your hash_dict, it can be constructed quite efficiently with:"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "hash_dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n hash_dict = dict(itertools.groupby(dic.values(), key=hash))\n</code>\n</pre>\n", "senID": 13}, {"text": ["(maybe that's what you are already doing)."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}], [{"text": ["Now that we can see the implementation of like, a quite simple approach seems feasible---far simpler than my other answer, for one.", "Define a new signature method on MyObject:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "like", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "signature", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "MyObject", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def signature(self):\n    return (self.period, frozenset(self.dimensions.keys()))\n</code>\n</pre>\n", "senID": 1}, {"text": ["And then iterate through the objects:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import collections\nsig_keys = collections.defaultdict(set)\nfor k, obj in dic.iteritems():\n    sig_keys[obj.signature()].add(k)\n</code>\n</pre>\n", "senID": 3}, {"text": ["With that, sig_keys.values() gives all the sets of identifiers for objects which are alike.", "Lists of objects could instead be directly constructed, if that would better:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "sig_keys.values()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n sig_objs = collections.defaultdict(list)\nfor obj in dic.itervalues():\n    sig_objs[obj.signature()].append(obj)\n</code>\n</pre>\n", "senID": 5}, {"text": ["If you want, you could define __hash__ to return hash(self.signature()) or the equivalent. "], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "__hash__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return hash(self.signature())", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I don't exactly follow your prefetch step, as you didn't explain it in detail, but maybe you could just as well precompute the complete result?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Another possibility, which I would have done, if the like method really looks like that is indexing over the y values."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "like", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Something like index = { 10 : [obj1], 12 : [obj2, obj3] ,... } where they keys are the objects' y attribute.", "Hence, you end up with:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "index = { 10 : [obj1], 12 : [obj2, obj3] ,... }", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def find_keys_in_constant_time(dic, val):\n    precomputed = index[val.y]\n    return precomputed\n</code>\n</pre>\n", "senID": 3}, {"text": ["Of course, it also returns the original val object, but so does your original method."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "val", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["NOTE After seeing the implementation of like, the method described is seen to be more complicated than necessary.", "I'll leave it here, as the approach can be generalized to fuzzier similarity measures, e.g., at least 50% of the dimensions must be the same. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "NOTE", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "like", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["What you're doing looks a lot like an inverted index, although it's impossible to say without really knowing how like is implemented.", "For an inverted index, you use possible object values as the dictionary keys, mapping to lists (or other collections) of objects taking those values.", "With several properties, you can make several dictionaries, handling the different types of object values.", "You then look up all the properties for the object in the inverted index, determining an aggregate similarity for each object based on all properties. "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "inverted index", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Inverted_index"}, {"text": "like", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["To take full advantage of the inverted index, it's better to think of returning all similar objects from one function.", "This helps you handle each possible \"like\" objects just once.", "As an extreme example, you might have an object like another only if all properties are the same; similar objects are then those objects found in all corresponding lists from the inverted index.", "To get all of the similar objects, you could just convert the lists to sets and take the intersection.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here's what it might look like in Python, slightly abbreviated to focus on the dimensions---extension to include period should be easy.", "There is a mapping from object identifier strings to the objects in dic.", "You can thus build an inverted index by mapping from the dimensions to sets of the object identifiers that have that dimension.", "It might be done so: "], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "period", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dic", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import collections\ninvind = collections.defaultdict(set)\nfor k, obj in dic.iteritems():\n    for d in obj.dimensions:\n        invind[d].add(k)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now say that you want to find all objects that have identical dimensions to a specific object test_obj.", "Just look up the sets of object identifiers with at least one of the dimensions, and take the intersection of all those sets.", "A concise way to write such a query is:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "test_obj", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import operator\nsimilar_keys = reduce(operator.and_, [invind[d] for d in test_ojb.dimensions])\nsimilar_objects = [dic[k] for k in similar_keys]\n</code>\n</pre>\n", "senID": 6}, {"text": ["The operate.and_ will calculate the set intersections, reduce extends it to the whole list of sets.", "This is not generally the fastest approach to implement the intersections; instead you can manipulate a set of results in-place with the intersection_update method of sets, stopping early once the set is empty---I'll leave the details, as they're easy but verbose."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "operate.and_", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "reduce", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "intersection_update", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The advantage of this approach is that any objects with no dimensions in common will not be compared at all.", "Depending on how your dimensions occur, it could be a dramatic reduction in the number of tests made.", "You can take the idea further, e.g., using pairs of co-occuring dimensions as the keys in the inverted index.", "This is more expensive to generate the keys, but generally reduces the sizes of the sets of object identifiers---a bit of experimentation, or just a good understanding of the dimensions, should help to make the right tradeoff.  "], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "at all", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["To include the periods in the comparisons, just add another inverted index mapping periods to sets of object identifiers.", "Extending the query for similar objects should be straightforward."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["It's hard to answer he question, as I have no idea what are you requirements.", "What I would do is creating some kind of Related class and populate your items with it.", "How to implement it mainly depends on properties of you like function.", "If your relationship is symmetrical (i.e.", "a is like b if and only if b is like a), than you can cluster related items and instead of iterating items, you iterate clusters and compare with any item within it; if it matches, all items within cluster are in relationship with your element."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "like", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["However, the relationship from you example is not symmetrical, so you probably need another approach.", "You still could cluster by y and z, and on looking up element taking intersection of corresponding cluster_y with union of cluster_z's holding z's greater or equal to element being looked up.", "However, it might add significant memory overhead if the values differs much. "], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "z", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "cluster_y", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "cluster_z", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["And you could do something else by examining your relationship properties.", "We could help if you provided more details."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]