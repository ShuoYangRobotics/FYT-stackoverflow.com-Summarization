[[{"text": ["Make your program more modular.", "Ideally, the main block of code should look something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import config\nimport my_numerics\nimport post_processing\n\nmy_numerics.configure(config.numerics)\nvalues = my_numerics.run()\n\npost_processing.run(values, config.post_processing)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You get the idea.", "It's then easy to make a 'mock' numerics object which returns pre-computed data, and pass that into post-processing."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: I still don't understand.", "Is the following accurate pseudocode for your problem?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for _ in range(lots):\n    do_slow_thing_one()\n\nfor _ in range(many):\n    do_slow_thing_two()\n\nfor _ in range(lots_many)\n    do_slow_thing_three()\n</code>\n</pre>\n", "senID": 4}, {"text": ["That is, you want to interrupt the numerics halfway through their run (not at the end), say at the beginning of the third loop, without having to rerun the first two?"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["If so, even if the loops don't contain much code, you should modularise the design:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n input_data = np.load(some_stuff)\nstage_one = do_thing_one(input_data)\nstage_two = do_thing_two(stage_one)\nstage_three = do_thing_three(stage_two)\n</code>\n</pre>\n", "senID": 7}, {"text": ["The first way of doing this is transferring data between distinct stages through an implicit interface; namely, the dictionary of local variables.", "This is bad, because you haven't defined which variables are being used and hence you can't mock them for testing/debugging purposes.", "The second way defines a (rudimentary) interface between your functions.", "You now no longer care what do_thing_one does, as long as it takes some input data and returns some output data.", "This means that to debug do_thing_three you can just do"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "do_thing_one", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "do_thing_three", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"code": "<pre>\n<code>\n stage_two = np.load(intermediate_stuff)\nstage_three = do_thing_three(stage_two)\n</code>\n</pre>\n", "senID": 9}, {"text": ["As long as the data in stage_two is of the correct format, it doesn't matter where it came from."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "stage_two", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Unit Tests"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Unit Tests", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This is why Unit Tests exist.", "Try pyunit with small \"sample data\", or doctest for extremely simple functions."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "pyunit", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "doctest", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Mini Test-Programs"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Mini Test-Programs", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If for some reason you really need interactivity, I usually write an interactive mini-program as what is effectively a unit test."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def _interactiveTest():\n    ...\n    import code\n    code.interact(local=locals())\n\nif __name__=='__main__':\n    _interactiveTest()\n</code>\n</pre>\n", "senID": 4}, {"text": ["You can often afford to ignore loading large chunks of the main program if you're only testing a specific part; adjust your architecture as necessary to avoid initializing unneeded parts of the program.", "This is the reason people might be saying \"make your program more modular\", and that is what modularity means: small chunks of the program stand alone, letting you reuse them or (in this case) load them separately."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Invoking Interpreter in Program"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Invoking Interpreter in Program", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You can also drop down into an interpreter and pass in the locals (as demonstrated above), at any point in your program.", "This is sort of \"a poor man's debugger\" but I find it efficient enough.", "=)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Monolithic Algorithms"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Monolithic Algorithms", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Been there, done that.", "Sometimes your workflow can't be modularized any further, and things start getting unwieldy."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Your intuition for making checkpoints is a very good one, and the same one I use: If you work in an interpreter environment, or embed an interpreter, you will not have to deal with this issue as often as if you just reran your scripts.", "Serializing your data can work, but it introduces a large overhead of reading and writing from disk; you want your dataset to remain in memory.", "Then you can do something like test1 = algorithm(data), test2 = algorithm(data) (this assumes your algorithm is not an in-place algorithm; if it is, use copy-on-write or make a copy of your datastructures before each test)."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "can", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "test1 = algorithm(data), test2 = algorithm(data)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["If you are still having issues after trying all the above, then either perhaps you are either:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "using your real dataset; you should just a smaller test dataset for prototyping!", "tag": "none", "senID": 12}, {"text": "using an inefficient algorithm.", "tag": "none", "senID": 13}]}, {"text": ["As a last resort, you can profile your code to find bottlenecks."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["Other"], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "Other", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["There are probably powerful python debuggers out there.", "Eclipse has one I think."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["Also I'd personally avoid reload &lt;modulename&gt;, which I've always found caused more headaches than it has solved problems."], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "reload &lt;modulename&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Joblib handles result caching in a quite transparent way.", "Here is an example, from their documentation:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Joblib", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://packages.python.org/joblib/"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from joblib import Memory\n&gt;&gt;&gt; mem = Memory(cachedir='/tmp/joblib')\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; a = np.vander(np.arange(3))\n&gt;&gt;&gt; square = mem.cache(np.square)\n&gt;&gt;&gt; b = square(a)\n________________________________________________________________________________\n[Memory] Calling square...\nsquare(array([[0, 0, 1],\n       [1, 1, 1],\n       [4, 2, 1]]))\n___________________________________________________________square - 0.0s, 0.0min\n\n&gt;&gt;&gt; c = square(a)\n&gt;&gt;&gt; # The above call did not trigger an evaluation because the result is cached\n</code>\n</pre>\n", "senID": 1}, {"text": ["The calculation results are automatically saved on disk, so Joblib might suit your needs."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A google search pointed me to CryoPID, which might do the job if you're developing on a linux-based system.", "It claims to be able to suspend a process and save it to a file, and then later restart it, even on a different computer.", "I've not tested it though."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "CryoPID", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cryopid.berlios.de/"}]}], [{"text": ["The idea from BuildBot might work.", "It uses python's reload() to reload changes modules and then it moves state from old to new objects in a semi-clever fashion. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "BuildBot", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.buildbot.net"}, {"text": "reload()", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#reload"}]}, {"text": ["The buildbot process is always running, but it can be signalled to reload from the outside, in which case this happens. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So, if you stored the intermediate results of your algorithms in objects (sort of what VTK does to reduce computation), you could reload and recreate your algorithm objects, have them reload the old data and then write some logic to re-run the computation on those objects if the python module actually did change. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "VTK", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.vtk.org"}]}, {"text": ["That way, you could have the process re-load itself just if the files on disk changes.", "Note that if there are syntax or runtime errors, things might be a bit hairy and you may need to restart (unless you can to a try-pass and roll back to the old objects)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["So, yeah, checkpoints are needed.", "But it might not be bad to have such a framework anyhow.", ":)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Actually, just modularizing the steps will allow you to cache the data to disk instead.", "That might solve the case.", "It will definitely help for testing, just like @katrielalex said."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I thought about it and finally I wrote down what I first had only vaguely in mind.", "Suggesting redesign still does tell how to skip blocks, load cached data etc."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class DebugCheckpoints:\n    def __init__(self, data, start):\n        self.checkpoint_passed=False\n        self.start=start\n        self.data=data\n\n    def __call__(self, variables):\n        return Checkpoint(self, variables.split())\n\n\nclass CheckpointNotReached(Exception): pass\n\n\nclass Checkpoint:\n    def __init__(self, debug_checkpoints, variables):\n        self.variables=variables\n        self.debug_checkpoints=debug_checkpoints\n\n    def tag(self, tag_name):\n        if self.debug_checkpoints.checkpoint_passed or \\\n           tag_name==self.debug_checkpoints.start:\n            self.debug_checkpoints.checkpoint_passed=True\n        else:\n            raise CheckpointNotReached()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self,exc_type, exc_val, exc_tb):\n        if exc_type==CheckpointNotReached: # check if the context was supposed to be skipped\n            for v in self.variables:\n                globals()[v]=self.debug_checkpoints.data[v] # load globals from data\n            return True\n        else:\n            for v in self.variables:\n                self.debug_checkpoints.data[v]=globals()[v] # save globals to data\n            return False\n\n#------------------------------------------------------------------------------\ndata={\"x\":1, \"w\":4} # this is supposed to be any persistent dict\ncheckpoint=DebugCheckpoints(data, start=\"B\") # start from B, skip block A but still load x and w from data\n\nwith checkpoint(\"x w\") as c: # variable x and w is to be loaded\n    c.tag(\"A\") # this will force cancellation of this block, but x and w will be loaded from data\n    x=1\n    w=4\n    print(\"Doing A\")\n\nwith checkpoint(\"y\") as c:\n    c.tag(\"B\") # as the start is B, this tag will no cancel this block\n    y=2\n    print(\"Doing B\")\n\nwith checkpoint(\"z\") as c:\n    c.tag(\"C\")\n    z=3\n    print(\"Doing C\")\n\nprint(checkpoint.data)\nprint(x,y,z,w)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is an easy framework to introduce checkpoints into the code without writing too much.", "Because merely defining hundreds of one-time function for every little step would probably be coding horror and moreover variables in functions are local (just imaging putting every 5 lines of code into a function).", "I don't want to return all variables from the block and declare everything global (that's also why a decorator hack to implement a checkpoint framework isn't good)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Maybe I redesign some calls when I try out cases, but I think it's a good start.", "Not sure what is supposed to go into the with line and what inside the block (like the .tag).", "I didn't manage to put the checkpoint exception into __enter__? "], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": ".tag", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__enter__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}]]