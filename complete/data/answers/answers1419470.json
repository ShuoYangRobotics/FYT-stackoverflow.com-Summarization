[[{"text": ["There is no good way to get the arguments as a list if they are specified individually in the function signature.", "You can probably do something with inspect or frame hacks, but that will be uglier than simply spelling it out as you have done."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Here you go.", "Yes this is an ugly evil hack.", "Yes the object needs a __dict__ variable.", "But hey, its a neat little one liner!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def __init__(self):\n    self.__dict__.update(locals())\n</code>\n</pre>\n", "senID": 1}, {"text": ["The constructor can take any type of arguments."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class test(object):\n    def __init__(self, a, b, foo, bar=5)...\n\na = test(1,2,3)\ndir(a)\n\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'a', 'b', 'foo', 'bar', 'self']\n</code>\n</pre>\n", "senID": 3}, {"text": ["It will also include self, but you can easily delete that or make your own update function that ignores self."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You could use inspect.getargspec and encapsulate it as a decorator.", "The lookup of optional and keyword arguments is a bit tricky, but this should do it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def inits_args(func):\n    \"\"\"Initializes object attributes by the initializer signature\"\"\"\n    argspec = inspect.getargspec(func)\n    argnames = argspec.args[1:]\n    defaults = dict(zip(argnames[-len(argspec.defaults):], argspec.defaults))\n    @functools.wraps(func)\n    def __init__(self, *args, **kwargs):\n        args_it = iter(args)\n        for key in argnames:\n            if key in kwargs:\n                value = kwargs[key]\n            else:\n                try:\n                    value = args_it.next()\n                except StopIteration:\n                    value = defaults[key]\n            setattr(self, key, value)\n        func(self, *args, **kwargs)\n    return __init__\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can then use it like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Foo(object):\n    @inits_args\n    def __init__(self, spam, eggs=4, ham=5):\n        print \"Foo(%r, %r, %r)\" % (self.spam, self.eggs, self.ham)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Try inspect.getargspec:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "inspect.getargspec", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/inspect.html#inspect.getargspec"}]}, {"code": "<pre>\n<code>\n In [31]: inspect.getargspec(C.__init__)\n\nOut[31]: ArgSpec(args=['self', 'ivar1', 'ivar2', 'ivar3', 'optional'],\n\n                 varargs=None, keywords=None, defaults=(False,))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["See if the new namedtuple (new in Python 2.6) from the collections module might work for you."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can do it using introspection of the arguments, but the code is going to be longer than the code you try to replace.", "Especially if you are handling kw, which you may have to do."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This short code works in most cases (improved from Unknowns example):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class Foo:\n...   def __init__(self, labamba, **kw):\n...       params = locals().copy()\n...       del params['self']\n...       if 'kw' in params:\n...           params.update(params['kw'])\n...           del params['kw']\n...       self.__dict__.update(params)\n</code>\n</pre>\n", "senID": 2}, {"text": ["But it's an ugly hack, making code less readable for no particular reason except laziness, so don't do it.", "And also, how often do you really have classes that have more than 5-6 init parameters?"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "really", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["I like that form the most, not too long and both copy-pasteable and sub-classable:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class DynamicInitClass(object):\n      __init_defargs=('x',)\n      def __init__(self,*args,**attrs):\n        for idx,val in enumerate(args): attrs[self.__init_defargs[idx]]=val\n        for key,val in attrs.iteritems(): setattr(self,key,val)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about deriving from a special class?", "I think it's more explicit and more flexible this way:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "more explicit and more flexible", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class InitMe:\n    def __init__(self, data):\n        if 'self' in data:\n             data = data.copy()\n             del data['self']\n        self.__dict__.update(data)\n\n\nclass MyClassA(InitMe):\n    def __init__(self, ivar1, ivar2, ivar3 = 'default value'):\n        super().__init__(locals())\n\n\nclass MyClassB(InitMe):\n    def __init__(self, foo):\n        super().__init__({'xxx': foo, 'yyy': foo, 'zzz': None})\n# or    super().__init__(dict(xxx=foo, yyy=foo, zzz=None))\n\nclass MyClassC(InitMe):\n    def __init__(self, foo, **keywords):\n        super().__init__(keywords)\n</code>\n</pre>\n", "senID": 1}]]