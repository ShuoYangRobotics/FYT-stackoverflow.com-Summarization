[[{"text": ["Can't quite get it to one line, but here's a simpler version:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def match_new(new_list, old_list) :\n    ids = dict((item['id'], item) for item in new_list)\n    return [ids[item['id']] for item in old_list if item['id'] in ids]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["not knowing the constraints of your data, i will suppose that id is unique in each list, and that your list contains only imutable types (string, int,...) which are hashable."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "id", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # first index each list by id\nnew = {item['id']: item for item in list_new}\nold = {item['id']: item for item in list_old}\n\n# now you can see which ids appeared in the new list\ncreated = set(new.keys())-set(old.keys())\n# or which ids were deleted\ndeleted =  set(old.keys())-set(new.keys())\n# or which ids exists in the 2 lists\nintersect = set(new.keys()).intersection(set(old.keys()))\n\n# using the same 'conversion to set' trick,\n# you can see what is different for each item\ndiff = {id: dict(set(new[id].items())-set(old[id].items())) for id in intersect}\n\n# using your example data set, diff now contains the differences for items which exists in the two lists:\n# {1: {'name': 'bob'}, 2: {'desc': 'bad gay'}, 3: {'name': 'Vasya', 'desc': None}}\n\n# you can now add the new ids to this diff\ndiff.update({id: new[id] for id in created})\n# and get your data back into the original format:\nlist_diff = [dict(data, **{'id': id}) for id,data in diff.items()]\n</code>\n</pre>\n", "senID": 1}, {"text": ["this is using python 3 syntax, but should be easily ported to python 2."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "this is using python 3 syntax, but should be easily ported to python 2.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["edit: here is the same code written for python 2.5: "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n new = dict((item['id'],item) for item in list_new)\nold = dict((item['id'],item) for item in list_old)\n\ncreated = set(new.keys())-set(old.keys())\ndeleted =  set(old.keys())-set(new.keys())\nintersect = set(new.keys()).intersection(set(old.keys()))\n\ndiff = dict((id,dict(set(new[id].items())-set(old[id].items()))) for id in intersect)\n\ndiff.update(dict(id,new[id]) for id in created))\nlist_diff = [dict(data, **{'id': id}) for id,data in diff.items()]\n</code>\n</pre>\n", "senID": 4}, {"text": ["(note how the code is less readable without the dict comprehension)"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "(note how the code is less readable without the dict comprehension)", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["for each dictionary in old_list, search for the dictionary in new_list with the same id, then do:  old_dict.update(new_dict)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "old_dict.update(new_dict)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["eliminate each new_dict, after updating, from new_list and append the remaining, unused dicts after the loop."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Something like this is what you need:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = []\nfor d in list_old:\n    for e in list_new:\n        if e['id'] == d['id']:\n            l.append(dict(e, **d))\nprint l\n</code>\n</pre>\n", "senID": 1}, {"text": ["Read here on how to merge dictionaries."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/38987/how-can-i-merge-two-python-dictionaries-as-a-single-expression"}]}], [{"text": ["You could do something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def match_dict(new_list, old_list):\n    new_dict = dict((obj['id'], obj) for obj in new_list)\n    old_dict = dict((obj['id'], obj) for obj in old_list)\n    for k in new_dict.iterkeys():\n        if k in old_dict:\n            new_dict[k].update(old_dict[k])\n        else:\n            del new_dict[k]\n    return new_dict.values()\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you are doing this often I would suggest storing your data as dictionaries with the id as the key instead of lists, that way you wouldn't have to convert it each time."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["edit: Here is an example showing how to store the data in a dictionary."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n list_new = [{'desc': 'cool guy', 'id': 1, 'name': 'bob'}, {'desc': 'bad guy', 'id': 2, 'name': 'Bill'}, {'desc': None, 'id': 3, 'name': 'Vasya'}]\n# create a dictionary with the value of 'id' as the key\ndict_new = dict((obj['id'], obj) for obj in list_new)\n# now you can access entries by their id instead of having to loop through the list\nprint dict_new[2]\n# {'id': 2, 'name': 'Bill', 'desc': 'bad guy'}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You'd be much better off if your top-level data structure was a dict rather than a list.", "Then it would be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dict_new.update(dict_old)\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, for what you actually have, try this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n result_list = []\nfor item in list_new:\n    found_item = [d for d in list_old if d[\"id\"] == item[\"id\"]]\n    if found_item:\n        result_list.append(dict(item, **found_item[0]))\n</code>\n</pre>\n", "senID": 3}, {"text": ["This actually still has a loop inside a loop (the inner loop is \"hidden\" in the list comprehension) so it's still O(n**2).", "On large data sets it would undoubtedly be noticeably faster to convert it to a dict, update that, and then convert it back to a list."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You could like this one.", "Please, take a look, thanks."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def match_dict(new_list, old_list):\n    id_new = [item_new.get(\"id\") for item_new in list_new]\n    id_old = [item_old.get(\"id\") for item_old in list_old]\n\n    for idx_old in id_old:\n        if idx_old in id_new:\n            list_new[id_new.index(idx_old)].update(list_old[id_old.index(idx_old)])\n\n    return list_new\n\nfrom pprint import pprint\npprint(match_dict(list_new, list_old))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [{'desc': 'cool gay', 'id': 1, 'name': 'boby', 'some_data': '12345'},\n {'desc': 'cool gay', 'id': 2, 'name': 'Bill', 'some_data': '12345'},\n {'desc': 'the man', 'id': 3, 'name': 'vasya', 'some_data': '12345'}]\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n [od for od in list_old if od['id'] in {nd['id'] for nd in list_new}]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Steps:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Create a look up dictionary for list_old by id", "tag": "none", "senID": 1}, {"text": "Loop through list_new dicts creating a merged dict for each if it existed in old", "tag": "none", "senID": 2}]}, {"text": ["Code:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def match_dict(new_list, old_list): \n    old = dict((v['id'], v) for v in old_list)\n    return [dict(d, **old[d['id']]) for d in new_list if d['id'] in old]\n</code>\n</pre>\n", "senID": 4}, {"text": ["EDIT: incorrectly named variables inside function."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]