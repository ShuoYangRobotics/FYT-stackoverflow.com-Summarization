[[{"code": "<pre>\n<code>\n #uncomment to produce the word file\n##words = ['Jellicle', 'Cats', 'are', 'black', 'and', 'white,', 'Jellicle', 'Cats', 'are', 'rather', 'small;', 'Jellicle', 'Cats', 'are', 'merry', 'and', 'bright,', 'And', 'pleasant', 'to', 'hear', 'when', 'they', 'caterwaul.', 'Jellicle', 'Cats', 'have', 'cheerful', 'faces,', 'Jellicle', 'Cats', 'have', 'bright', 'black', 'eyes;', 'They', 'like', 'to', 'practise', 'their', 'airs', 'and', 'graces', 'And', 'wait', 'for', 'the', 'Jellicle', 'Moon', 'to', 'rise.', '']\n##open('novel.txt','w').write('\\n'.join(words))\n\nimport string\ncap_words = [word.strip(string.punctuation) for word in open('novel.txt').read().split() if word.istitle()]\n##print(cap_words) # debug\ntry:\n    from collections import Counter # Python &gt;= 2.7\n    print('Counter')\n    print(Counter(cap_words).most_common(3))\nexcept ImportError:\n    print('Normal dict')\n    wordcount= dict()\n    for word in cap_words:\n         wordcount[word] = (wordcount[word] + 1\n                            if word in wordcount\n                            else 1)\n    print(sorted(wordcount.items(), key = lambda x: x[1], reverse = True)[:3])\n</code>\n</pre>\n", "senID": 0}, {"text": ["I do not get it why you would like to keep different kinds of line termination with 'rU' mode.", "I would use normally normal open as I wrote in edited code above.", "EDIT: You had words together with punctuation, so cleaned up those with strip()"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n print \"\\n\".join(sorted([\"%d %s\" % (lst.count(i), i) \\\n             for i in set(lst) if i.istitle()])[-3:])\n2 And\n5 Cats\n6 Jellicle\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Here are some additional comments:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n words = \"\"\nfor word in open('novel.txt', 'rU'):\n      words += word\nwords = words.split(' ')\nwords= list(words)\nwords = ('\\n'.join(words)).split('\\n')\n</code>\n</pre>\n", "senID": 1}, {"text": ["can be replaced with:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n text = open('novel.txt', 'rU').read() # read everything\nwordlist = text.split() # split on all whitespace\n</code>\n</pre>\n", "senID": 3}, {"text": ["But you don't use your 'must start with a capital letter' requirement yet.", "Time to add:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n capwordlist = (word for word in wordlist if word.istitle())\n</code>\n</pre>\n", "senID": 5}, {"text": ["istitle() means word[0].isupper() and word[1:].islower().", "This means 'SO'.istitle() -&gt; False."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "istitle()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "word[0].isupper() and word[1:].islower()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "'SO'.istitle() -&gt; False", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["That might work for you, but maybe you just want the word[0].isupper() instead."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "word[0].isupper()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This part is good if you can't use collections.Counter (new in 2.7)"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "collections.Counter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n word_counter = {}\n\nfor word in capwordlist:\n\n        if word in word_counter:\n            word_counter[word] += 1\n        else:\n            word_counter[word] = 1      \npopular_words = sorted(word_counter, key = word_counter.get, reverse = True)\ntop_3 = popular_words[:3]\n</code>\n</pre>\n", "senID": 9}, {"text": ["else this simply becomes:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n from collections import Counter\n\nword_counter = Counter(capwords)\ntop_3 = word_counter.most_common(3) # gives `word, count` pairs!\n</code>\n</pre>\n", "senID": 11}, {"text": ["And this:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n for i in range(3):\n      print word_counter[top_3[i]], top_3[i]\n</code>\n</pre>\n", "senID": 13}, {"text": ["can be this:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n for word in top_3:\n    print word_counter[word], word\n</code>\n</pre>\n", "senID": 15}], [{"text": ["One thing i'd avoid is reading all the words in before processing.", "It will work, but IMHO, it's better not to do that if you don't need to, and you don't.", "Here's my solution (with elements liberally stolen from previous ones!", "), done with 2.6.2:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\n\n# a generator function which iterates over the words in a file\ndef words(f):\n    for line in f:\n        for word in line.split():\n            yield word\n\n# returns a generator expression filtering an iterator down to titlecase words\ndef titles(s):\n    return (word for word in s if word.istitle())\n\n# count the titlecase words in the file\ncount = {}\nfor word in titles(words(file(sys.argv[1]))):\n    count[word] = count.get(word, 0) + 1\n\n# build a list of tuples with the count for each word\ncountsAndWords = [(kv[1], kv[0]) for kv in count.iteritems()]\n\n# put them in decreasing order\ncountsAndWords.sort()\ncountsAndWords.reverse()\n\n# print the top three\nfor count, word in countsAndWords[:3]:\n    print word, count\n</code>\n</pre>\n", "senID": 1}, {"text": ["I do a sort of decorate-sort-undecorate on the counts rather than doing the sort with a comparator which does lookups in the count dictionary; it's less elegant, but i believe it will be faster.", "That's probably a sinful thing to do."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["In general, word[0].isupper() will tel you if a word starts with an uppercase letter.", "Combine this into a list comprehension (or your loop)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [x for x in my_list if x[0].isupper()]\n</code>\n</pre>\n", "senID": 1}, {"text": ["(assuming there are no empty strings)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["and you get all words starting with an uppercase letter."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Since you aren't using Python2.7 and don't have Counter"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Counter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from collections import defaultdict\ncounter = defaultdict(int)\nwords = ['Jellicle', 'Cats', 'are', 'black', 'and', 'white,', 'Jellicle', 'Cats', 'are', 'rather', 'small;', 'Jellicle', 'Cats', 'are', 'merry', 'and', 'bright,', 'And', 'pleasant', 'to', 'hear', 'when', 'they', 'caterwaul.', 'Jellicle', 'Cats', 'have', 'cheerful', 'faces,', 'Jellicle', 'Cats', 'have', 'bright', 'black', 'eyes;', 'They', 'like', 'to', 'practise', 'their', 'airs', 'and', 'graces', 'And', 'wait', 'for', 'the', 'Jellicle', 'Moon', 'to', 'rise.', '']\nfor word in (word for word in words if word[0].isupper()):\n    counter[word]+=1\nprint counter\n</code>\n</pre>\n", "senID": 1}], [{"text": ["you could use itertools"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\nwords = ['Jellicle', 'Cats', 'are', 'black', 'and', 'white,', 'Jellicle', 'Cats', 'are', 'rather', 'small;', 'Jellicle', 'Cats', 'are', 'merry', 'and', 'bright,', 'And', 'pleasant', 'to', 'hear', 'when', 'they', 'caterwaul.', 'Jellicle', 'Cats', 'have', 'cheerful', 'faces,', 'Jellicle', 'Cats', 'have', 'bright', 'black', 'eyes;', 'They', 'like', 'to', 'practise', 'their', 'airs', 'and', 'graces', 'And', 'wait', 'for', 'the', 'Jellicle', 'Moon', 'to', 'rise.', '']\ncapwords = (word for word in words if len(word) &gt; 1 and word[0].isupper())\ncapwordssorted = sorted(capwords)\nwordswithcounts = ((k,len(list(g))) for (k,g) in itertools.groupby(capwordssorted))\nprint sorted(wordswithcounts,key=lambda x:x[1],reverse=True)[:3]\n</code>\n</pre>\n", "senID": 1}]]