[[{"text": ["You could just start 'to run the modules as standalones' in a bit a different way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Instead of:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n python foo/bar.py\n</code>\n</pre>\n", "senID": 2}, {"text": ["Use:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n python -mfoo.bar\n</code>\n</pre>\n", "senID": 4}, {"text": ["Of course, the foo/__init__.py file must be present."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "foo/__init__.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Please also note, that you have a circular dependency between foo.py and bar.py \u2013 this won't work.", "I guess it is just a mistake in your example."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "foo.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "bar.py", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Update: it seems it also works perfectly well to use this as the first line of the foo/bar.py:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "foo/bar.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/python -mfoo.bar\n</code>\n</pre>\n", "senID": 8}, {"text": ["Then you can execute the script directly in POSIX systems."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["First, I assume you realize what you've written would lead to a circular import issue, because foo imports bar and viceversa; try adding "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from foo import bar\n</code>\n</pre>\n", "senID": 1}, {"text": ["to test.py, and you'll see it fails.", "The example must be changed in order to work."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["So, what you're asking is really to fallback to absolute import when relative import fails; in fact, if you're executing foo.py or bar.py as the main module, the other modules will just lie at the root level, and if they share the name with another module on the system which one will be picked depends on the order in sys.path.", "Since the current dir is usually the first, local modules will be picked if available - i.e., if you've got an 'os.py' file in the current working dir, it'll be picked instead of the builtin one."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["A possibile suggestion is:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["foo.py"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n try:\n    from . import bar\nexcept ValueError:\n    import bar\n\nif __name__ == \"__main__\":\n    pass\n</code>\n</pre>\n", "senID": 6}, {"text": ["bar.py:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n if __name__ == \"__main__\":\n    pass\n</code>\n</pre>\n", "senID": 8}, {"text": ["By the way calling scripts from the proper position is usually way better."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "way", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n python -mfoo.bar\n</code>\n</pre>\n", "senID": 10}, {"text": ["Is probably the best way to go."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["python -mfoo.bar"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["Why not just put the \"main\" in a different .py file?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Ditch relative imports: you should think of your package namespace as a global one, anyway."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The trick to making this palatable is editing sys.path appropriately.", "Here is some food for thought:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "sys.path", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n# one directory up\n_root_dir = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))\nsys.path.insert(0, _root_dir)for now\n</pre>\n", "senID": 2}], [{"text": ["So far the only solution I found was not to use relative imports at all. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Due to current limitation, I'm wondering when someone is supposed to use relative imports in python."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["On all configurations that I used the sys.path contained the current directory as first argument so just use import foo instead of from .", "import foo because it will do the same."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "sys.path", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "import foo", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "from . import foo", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You need init.py in each folder."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "init", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Relative import works only when you do:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n python test.py\n</code>\n</pre>\n", "senID": 2}, {"text": ["test.py imports foo.py and foo.py can relative import anything from the folder of test.py and above."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You can't do:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n cd foo\npython foo.py\npython bar.py\n</code>\n</pre>\n", "senID": 5}, {"text": ["It will never work."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["You can try the sys.path.append or sys.path.insert solution but you gonna screw up the paths and you'll have problems with the f=open(filename)."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]]