[[{"text": ["Generally, you want to use condition checking for situations which are understandable, expected, and able to be handled.", "You would use exceptions for cases that are incoherent or unhandleable. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So, if you think of your \"add\" function.", "It should NEVER return null.", "That is not a coherent result for adding two things.", "In that case, there is an error in the arguments that were passed in and the function should not attempt to pretend that everything is okay.", "This is a perfect case to throw an exception. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["You would want to use condition checking and return null if you are in a regular or normal execution case.", "For instance, IsEqual could be a good case to use conditions, and return false if one of your conditions fails.", "I.E."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "IsEqual", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n fuction bool IsEqual(obj a, obj b)\n{ \n   if(a is null) return false;\n   if(b is null) return false;\n   if(a.Type != b.Type) return false;\n\n   bool result = false;\n   //Do custom IsEqual comparison code\n   return result;\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["In that scenario, you are returning false both for the exception cases AND the \"objects are not equal case\".", "This means that the consumer (calling party) cannot tell whether the comparison failed or the objects were simply not equal.", "If those cases need to be distinguished, then you should use exceptions instead of conditions."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "not equal", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Ultimately, you want to ask yourself whether the consumer will be able to specifically handle the failure case that you encountered.", "If your method/function cannot do what it needs to do then you probably want to throw an exception. "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "cannot do what it needs to do", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["Exceptions are much more manageable, because they define general families of things that can go wrong.", "In your example there is only one possible problem, so there is no advantage to using exceptions.", "But if you had another class that does division, then it needs to signal that you can't devide by zero.", "Simply returning None wouldn't work anymore."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["On the other hand, exceptions can be subclassed and you can catch specific exceptions, depending on how much you care about the underlying problem.", "For example, you could have a DoesntCompute base exception and subclasses like InvalidType and InvalidArgument.", "If you just want a result, you can wrap all computations in a block that catches DoesntCompute, but you can still do very specific error handling just as easy."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "DoesntCompute", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "InvalidType", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "InvalidArgument", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "DoesntCompute", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["If you're asking, you should probably be using exceptions.", "Exceptions are used to indicate exceptional circumstances, a specific case where things work differently from other cases.", "This is the case for prettymuch all errors and for many other things as well. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In your second implementation of sum_, the user has to check every single time what the value was.", "This is reminiscent of the C/Fortran/other-languages boilerplate (and frequent source of errors) where error codes go unchecked that we avoid.", "You have to write code like this at all levels to be able to propagate errors.", "It gets messy and is especially avoided in Python."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "sum_", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "has to check", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["A couple other notes:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "You often don't need to make your own exceptions. For many cases, the builtin exceptions like ", "tag": "none", "senID": 3}, {"text": "When I do create a new exception, which is pretty useful, I often try to subclass something more specific than ", "tag": "none", "senID": 4}, {"text": ["I would never implement a function like sum_, since typechecking makes your code less flexible, maintainable, and idiomatic. "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "sum_", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}], [{"text": ["You should throw exception when the parameter contains an unexpected value. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["With your examples, I would recommend to throw exception when the two parameters are of different types. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["To throw an exception is an elegant way to abort a service without cluttering up your code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["My main reason for preferring exceptions to status returns has to do with considering what happens if the programmer forgets to do his job.", "With exceptions, you might overlook catching an exception.", "In that case, your system will visibly fail, and you'll have a chance to consider where to add a catch.", "With status returns, if you forget to check the return, it will be silently ignore, and your code will continue on, possibly failing later in a mysterious way.", "I prefer the visible failure to the invisible one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There are other reasons, which I've explained here: Exceptions vs.", "Status Returns."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Exceptions vs. Status Returns", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://nedbatchelder.com/text/exceptions-vs-status.html"}]}], [{"text": ["Maybe sum_ looks fine alone.", "What if, you know, it actually is used?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sum_", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #foo.py\ndef sum_(a, b):\n    if type(a) == type(b):\n        return a + b\n</code>\n</pre>\n", "senID": 1}, {"senID": 2}, {"code": "<pre>\n<code>\n #egg.py\nfrom foo import sum_:\ndef egg(c = 5):\n  return sum_(3, c)\n</code>\n</pre>\n", "senID": 3}, {"senID": 4}, {"code": "<pre>\n<code>\n #bar.py\nfrom egg import egg\ndef bar():\n  return len(egg(\"2\"))\nif __name__ == \"__main__\":\n  print bar()\n</code>\n</pre>\n", "senID": 5}, {"text": ["If you ran bar.py you would get:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "bar.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n Traceback (most recent call last):\n  File \"bar.py\", line 6, in &lt;module&gt;\n    print bar()\n  File \"bar.py\", line 4, in bar\n    return len(egg(\"2\"))\nTypeError: object of type 'NoneType' has no len()\n</code>\n</pre>\n", "senID": 7}, {"text": ["See -- usually one calls a function with the intent to act on its output.", "If you simply \"swallow\" the exception and return a dummy value, who uses your code will have an hard time troubleshooting.", "First off, the traceback is completely useless.", "This alone should be enough reason."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Who wants to fix this bug would have to first doublecheck bar.py, then analize egg.py trying to figure out where exactly the None came from.", "After reading egg.py they'll have to read sum_.py and hopefully notice the implicit return of None; only then they understand the problem: they failed the type check because of the parameter egg.py put in for them."], "childNum": 6, "tag": "p", "senID": 9, "childList": [{"text": "bar.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "egg.py", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "egg.py", "childNum": 0, "tag": "code", "childList": []}, {"text": "sum_.py", "childNum": 0, "tag": "code", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}, {"text": "egg.py", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Put a bit of actual complexity in this and thing get ugly really fast."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Python, unlike C, is written with the Easier to Ask Forgiveness than Permission principle in mind: if something goes wrong, I'll get an exception.", "If you pass me a None where I expect an actual value, things will break, the exception will happen far away from the line actually causing it and people will curse in your general direction in twenty different languages, then change the code to throw a suitable exception (TypeError(\"incompatible operand type\"))."], "childNum": 5, "tag": "p", "senID": 11, "childList": [{"text": "Easier to Ask Forgiveness than Permission", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/glossary.html#term-eafp"}, {"text": "if something goes wrong, I'll get an exception", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "will", "childNum": 0, "tag": "em", "childList": []}, {"text": "TypeError(\"incompatible operand type\")", "childNum": 0, "tag": "code", "childList": []}]}]]