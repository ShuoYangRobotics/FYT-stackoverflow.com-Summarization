[[{"text": ["From the docs:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "the docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/controlflow.html"}]}, {"text": ["For your case, I'd actually suggest looking into using generator expressions and itertools.ifilter, to avoid making unnecessary copies of your big list of files."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "itertools.ifilter", "tag": "a", "pos": 0, "childList": [{"text": "itertools.ifilter", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.ifilter"}, {"text": "itertools.ifilter", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The problem with your method is that del() is removing the entry in the list at that index and re-ordering the list."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "del()", "tag": "a", "pos": 0, "childList": [{"text": "del()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/tutorial/datastructures.html#the-del-statement"}, {"text": "del()", "childNum": 0, "tag": "code", "childList": []}, {"text": "and re-ordering the list", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["For example, if you have five items in a list and call del() on the third index, the contents of the list are shifted down so that a different element takes the third index. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n list = [1,2,3,4,5]\ndel(list[2])\nprint list     # outputs [1, 2, 4, 5]\nprint list[2]  # outputs 4\n</code>\n</pre>\n", "senID": 2}, {"text": ["Since you are looping from 0 to the original size of the list, even if you have removed just one item from the list, you will eventually arrive at indices which are no longer contained in the list."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["A much simpler approach would be to filter the list as you add items to it."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n for f in glob.glob(srcdir + \"/*.txt\"):\n    lf = LogFile(f)\n    if lf.DATE &lt; from_date and lf.DATE &gt; to_date:\n        LOG_FILES.append(lf)\n</code>\n</pre>\n", "senID": 5}, {"text": ["This could probably be made more pythonic but should be readable enough to get the point across."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["[EDIT] Oops, I forgot to invert the \"&lt;\" and \">\" and add an 'equals' sign."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "[EDIT]", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n LOG_FILES = [LogFile(f) for f in glob.glob(srcdir + \"/*.txt\")\n                        if from_date &lt;= f.DATE &lt;= to_date]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This can replace the whole initalization of LOG_FILES.", "It's a list comprehension (if you wish you can make it a generator (which doesn't get evaluated until it's enumerated) by replacing the [ ] with ( ).", "That might be more efficient depending on what you do with it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You need to do this because editing a collection while enumerating it isn't allowed.", "(see above, far more eloquent answers)."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "far more eloquent", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4752866/python-indexerror-when-trying-to-go-through-a-large-list/4752910#4752910"}]}, {"text": ["You can read the expression above like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["\"create a list (or enumerable) of the result of LogFile, when it's handed 'f' for each f in 'glob.glob(...)' but only if the 'if' statement is true."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["See: The List Comprehension section of that link."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "The List Comprehension", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html"}]}], [{"text": ["If you're looping over an array with a fixed upper limit and deleting elements at the same time you will generate index errors.", "Either you must loop over a copy or use a dynamic index.", "Since you stated the array is big we use the latter:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "will", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n limit, i = len(LOG_FILES), 0\nwhile i &lt; limit:\n    if LOG_FILES[i].DATE &lt; from_date and LOG_FILES[i].DATE &gt; to_date:\n        del(LOG_FILES[i])\n        limit -= 1\n    else:\n        i += 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could also use filter:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "filter", "tag": "a", "pos": 0, "childList": [{"text": "filter", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#filter"}, {"text": "filter", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n LOG_FILES = filter(lambda log_file: log_file.DATE &lt; from_date and \\\n                                    log_file.DATE &gt; to_date, LOG_FILES)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There's a problem in the Cpfohl's answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n LOG_FILES = [LogFile(f) for f in glob.glob(srcdir + \"/*.txt\")\n             if f.DATE &gt;= from_date and f.DATE &lt;= to_date]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Since"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for f in glob.glob(srcdir + \"/*.txt\"):\n    LOG_FILES.append(LogFile(f))\n</code>\n</pre>\n", "senID": 3}, {"text": ["therefore a LOG_FILES[i] is a LogFile(f)\nand then a LOG_FILES[i].DATE is a LogFile(f).DATE, not a f.DATE"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["1) deleting elements during the iteration in a list from end to beginning of the list dissolve problems"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "iteration in a list from end to beginning of the list", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n LOG_FILES = [ 1,2,30,2,5,8,30,3,2,37,22,30,27,30,4 ]\n\nprint LOG_FILES\n\nL = len(LOG_FILES)-1\nfor i,x in enumerate(LOG_FILES[::-1]):\n    print i,L-i,' ',LOG_FILES[L-i],x\n    if x&gt;15:\n        del LOG_FILES[L-i]\n\nprint LOG_FILES\n</code>\n</pre>\n", "senID": 1}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [1, 2, 30, 2, 5, 8, 30, 3, 2, 37, 22, 30, 27, 30, 4]\n0 14   4 4\n1 13   30 30\n2 12   27 27\n3 11   30 30\n4 10   22 22\n5 9   37 37\n6 8   2 2\n7 7   3 3\n8 6   30 30\n9 5   8 8\n10 4   5 5\n11 3   2 2\n12 2   30 30\n13 1   2 2\n14 0   1 1\n[1, 2, 2, 5, 8, 3, 2, 4]\n</code>\n</pre>\n", "senID": 3}, {"text": ["2) By the way"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n if LOG_FILES[i].DATE &lt; to_date and LOG_FILES[i].DATE &gt; from_date :\n</code>\n</pre>\n", "senID": 5}, {"text": ["can be written"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n if from_date  &lt; LOG_FILES[i].DATE &lt; to_date:\n</code>\n</pre>\n", "senID": 7}]]