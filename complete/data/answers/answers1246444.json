[[{"text": ["Do you mean this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dict( (n,int(v)) for n,v in (a.split('=') for a in string.split() ) )\n{'a': 0, 'c': 3, 'b': 1}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about a one-liner without list comprehension?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n foo=\"a=0 b=1 c=3\"\n ans=eval( 'dict(%s)'%foo.replace(' ',',')) )\n print ans\n{'a': 0, 'c': 3, 'b': 1}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I sometimes like this approach, especially when the logic for making keys and values is more complicated:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s = \"a=0 b=1 c=3\"\n\ndef get_key_val(x):\n    a,b = x.split('=')\n    return a,int(b)\n\nans = dict(map(get_key_val,s.split()))\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n from cgi import parse_qsl\ntext = \"a=0 b=1 c=3\"\ndic = dict((k, int(v)) for k, v in parse_qsl(text.replace(' ', '&amp;')))\nprint dic\n</code>\n</pre>\n", "senID": 0}, {"text": ["prints"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n {'a': 0, 'c': 3, 'b': 1}\n</code>\n</pre>\n", "senID": 2}], [{"text": ["dict([x.split('=') for x in s.split()])"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I would do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def kv(e): return (e[0], int(e[1]))\nd = dict([kv(e.split(\"=\")) for e in string.split(\" \")])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I like S.Lott's solution, but I came up with another possibility.", "Since you already have a string resembling somehow the way you'd write that, you can just adapt it to python syntax and then eval() it :)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import re\nstring = \"a=0 b=1 c=3\"\nstring2 = \"{\"+ re.sub('( |^)(?P&lt;id&gt;\\w+)=(?P&lt;val&gt;\\d+)', ' \"\\g&lt;id&gt;\":\\g&lt;val&gt;,', string) +\"}\"\ndict = eval(string2)\nprint type(string), type(string2), type(dict)\nprint string, string2, dict\n</code>\n</pre>\n", "senID": 1}, {"text": ["The regex here is pretty raw and won't catch all the possible python identifiers, but I wanted to keep it simple for simplicity's sake.", "Of course if you have control over how the input string is generated, just generate it according to python syntax and eval it away.", "BUT of course you should perform additional sanity checks to make sure that no code is injected there!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]