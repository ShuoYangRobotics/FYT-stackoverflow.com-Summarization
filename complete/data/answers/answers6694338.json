[[{"text": ["consider using a priority queue with one or more worker threads to service the tasks.", "The main thread can add work to the queue, with a timestamp of the soonest it should be serviced.", "Worker threads pop work off the queue, sleep until the time of priority value is reached, do the work, and then pop another item off the queue."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "priority queue", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/queue.html#Queue.PriorityQueue"}]}, {"text": ["How about a more fleshed out answer.", "mklauber makes a good point.", "If there's a chance all of your workers might be sleeping when you have new, more urgent work, then a queue.PriorityQueue isn't really the solution, although a \"priority queue\" is still the technique to use, which is available from the heapq module.", "Instead, we'll make use of a different synchronization primitive; a condition variable, which in python is spelled threading.Condition.  "], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "queue.PriorityQueue", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "heapq", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "threading.Condition", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["The approach is fairly simple, peek on the heap, and if the work is current, pop it off and do that work.", "If there was work, but it's scheduled into the future, just wait on the condition until then, or if there's no work at all, sleep forever."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The producer does it's fair share of the work; every time it adds new work, it notifies the condition, so if there are sleeping workers, they'll wake up and recheck the queue for newer work."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import heapq, time, threading\n\nSTART_TIME = time.time()\nSERIALIZE_STDOUT = threading.Lock()\ndef consumer(message):\n    \"\"\"the actual work function.  nevermind the locks here, this just keeps\n       the output nicely formatted.  a real work function probably won't need\n       it, or might need quite different synchronization\"\"\"\n    SERIALIZE_STDOUT.acquire()\n    print time.time() - START_TIME, message\n    SERIALIZE_STDOUT.release()\n\ndef produce(work_queue, condition, timeout, message):\n    \"\"\"called to put a single item onto the work queue.\"\"\"\n    prio = time.time() + float(timeout)\n    condition.acquire()\n    heapq.heappush(work_queue, (prio, message))\n    condition.notify()\n    condition.release()\n\ndef worker(work_queue, condition):\n    condition.acquire()\n    stopped = False\n    while not stopped:\n        now = time.time()\n        if work_queue:\n            prio, data = work_queue[0]\n            if data == 'stop':\n                stopped = True\n                continue\n            if prio &lt; now:\n                heapq.heappop(work_queue)\n                condition.release()\n                # do some work!\n                consumer(data)\n                condition.acquire()\n            else:\n                condition.wait(prio - now)\n        else:\n            # the queue is empty, wait until notified\n            condition.wait()\n    condition.release()\n\nif __name__ == '__main__':\n    # first set up the work queue and worker pool\n    work_queue = []\n    cond = threading.Condition()\n    pool = [threading.Thread(target=worker, args=(work_queue, cond))\n            for _ignored in range(4)]\n    map(threading.Thread.start, pool)\n\n    # now add some work\n    produce(work_queue, cond, 10, 'Grumpy')\n    produce(work_queue, cond, 10, 'Sneezy')\n    produce(work_queue, cond, 5, 'Happy')\n    produce(work_queue, cond, 10, 'Dopey')\n    produce(work_queue, cond, 15, 'Bashful')\n    time.sleep(5)\n    produce(work_queue, cond, 5, 'Sleepy')\n    produce(work_queue, cond, 10, 'Doc')\n\n    # and just to make the example a bit more friendly, tell the threads to stop after all\n    # the work is done\n    produce(work_queue, cond, float('inf'), 'stop')\n    map(threading.Thread.join, pool)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["This answer has actually two suggestions - my first one and another I have discovered after the first one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I suspect you are looking for the schedmodule."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "schedmodule", "tag": "a", "pos": 0, "childList": [{"text": "sched", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/sched.html"}, {"text": "sched", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["EDIT: my bare suggestion seemed little helpful after I have read it.", "So I decided to test the sched module to see if it can work as I suggested.", "Here comes my test: I would use it with a sole thread, more or less this way:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "sched", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class SchedulingThread(threading.Thread):\n\n    def __init__(self):\n        threading.Thread.__init__(self)\n        self.scheduler = sched.scheduler(time.time, time.sleep)\n        self.queue = []\n        self.queue_lock = threading.Lock()\n        self.scheduler.enter(1, 1, self._schedule_in_scheduler, ())\n\n    def run(self):\n        self.scheduler.run()\n\n    def schedule(self, function, delay):\n        with self.queue_lock:\n            self.queue.append((delay, 1, function, ()))\n\n    def _schedule_in_scheduler(self):\n        with self.queue_lock:\n            for event in self.queue:\n                self.scheduler.enter(*event)\n                print \"Registerd event\", event\n            self.queue = []\n        self.scheduler.enter(1, 1, self._schedule_in_scheduler, ())\n</code>\n</pre>\n", "senID": 3}, {"text": ["First, I'd create a thread class  which would have its own scheduler and a queue.", "At least one event would be registered in the scheduler: one for invoking a method for scheduling events from the queue."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class SchedulingThread(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)\n        self.scheduler = sched.scheduler(time.time, time.sleep)\n        self.queue = []\n        self.queue_lock = threading.Lock()\n        self.scheduler.enter(1, 1, self._schedule_in_scheduler, ())\n</code>\n</pre>\n", "senID": 5}, {"text": ["The method for scheduling events from the queue would lock the queue, schedule each event, empty the queue and schedule itself again, for looking for new events some time in the future.", "Note that the period for looking for new events is short (one second), you may change it:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def _schedule_in_scheduler(self):\n        with self.queue_lock:\n            for event in self.queue:\n                self.scheduler.enter(*event)\n                print \"Registerd event\", event\n            self.queue = []\n        self.scheduler.enter(1, 1, self._schedule_in_scheduler, ())\n</code>\n</pre>\n", "senID": 7}, {"text": ["The class should also have a method for scheduling user events.", "Naturally, this method should lock the queue while updating it:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def schedule(self, function, delay):\n        with self.queue_lock:\n            self.queue.append((delay, 1, function, ()))\n</code>\n</pre>\n", "senID": 9}, {"text": ["Finally, the class should invoke the scheduler main method:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n def run(self):\n        self.scheduler.run()\n</code>\n</pre>\n", "senID": 11}, {"text": ["Here comes an example of using:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n def print_time():\n    print \"scheduled:\", time.time()\n\n\nif __name__ == \"__main__\":\n    st = SchedulingThread()\n    st.start()          \n    st.schedule(print_time, 10)\n\n    while True:\n        print \"main thread:\", time.time()\n        time.sleep(5)\n\n    st.join()\n</code>\n</pre>\n", "senID": 13}, {"text": ["Its output in my machine is:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n $ python schedthread.py\nmain thread: 1311089765.77\nRegisterd event (10, 1, &lt;function print_time at 0x2f4bb0&gt;, ())\nmain thread: 1311089770.77\nmain thread: 1311089775.77\nscheduled: 1311089776.77\nmain thread: 1311089780.77\nmain thread: 1311089785.77\n</code>\n</pre>\n", "senID": 15}, {"text": ["This code is just a quick'n'dirty example, it may need some work.", "However, I have to confess that I am a bit fascinated by the sched module, so did I suggest it.", "You may want to look for other suggestions as well :)"], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "sched", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Looking in Google for solutions like the one I've post, I found this amazing APScheduler module.", "It is so practical and useful that I bet it is your solution.", "My previous example would be way simpler with this module:"], "childNum": 2, "tag": "p", "senID": 17, "childList": [{"text": "amazing APScheduler module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://packages.python.org/APScheduler/"}, {"text": "is", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from apscheduler.scheduler import Scheduler\nimport time\n\nsch = Scheduler()\nsch.start()\n\n@sch.interval_schedule(seconds=10)\n\ndef print_time():\n    print \"scheduled:\", time.time()\n    sch.unschedule_func(print_time)\n\nwhile True:\n    print \"main thread:\", time.time()\n    time.sleep(5)\n</code>\n</pre>\n", "senID": 18}, {"text": ["(Unfortunately I did not find how to schedule an event to execute only once, so the function event should unschedule itself.", "I bet it can be solved with some decorator."], "childNum": 0, "tag": "p", "senID": 19, "childList": []}], [{"text": ["celery"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "celery", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://celeryproject.org/"}]}], [{"text": ["You wrote:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Seems like your choice will be heavily influenced by these details, which are a bit unclear\u2014how is zeromq being used for communication, how much resources will the integration will require, and what are your requirements and available resources."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There's a project called django-ztask which uses zeromq and provides a task decorator similar to celery's one.", "However, it is (obviously) Django-specific and so may not be suitable in your case.", "I haven't used it, prefer celery myself."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "django-ztask", "tag": "a", "pos": 0, "childList": [{"text": "django-ztask", "tag": "strong"}], "childNum": 1, "href": "https://github.com/dmgctrl/django-ztask"}, {"text": "django-ztask", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "zeromq", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "task", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "celery", "tag": "a", "pos": 2, "childList": [{"text": "celery", "tag": "strong"}], "childNum": 1, "href": "http://docs.celeryproject.org/en/latest/index.html"}, {"text": "celery", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Been using celery for a couple of projects (these are hosted at ep.io PaaS hosting, which provides an easy way to use it)."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "ep.io", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Celery looks like quite flexible solution, allowing delaying tasks, callbacks, task expiration &amp; retrying, limiting task execution rate, etc.", "It may be used with Redis, Beanstalk, CouchDB, MongoDB or an SQL database."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Example code (definition of task and asynchronous execution after a delay):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from celery.decorators import task\n\n@task\ndef my_task(arg1, arg2):\n    pass # Do something\n\nresult = my_task.apply_async(\n    args=[sth1, sth2], # Arguments that will be passed to `my_task()` function.\n    countdown=3, # Time in seconds to wait before queueing the task.\n)\n</code>\n</pre>\n", "senID": 6}, {"text": ["See also a section in celery docs."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "a section in celery docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.celeryproject.org/en/latest/userguide/executing.html#eta-and-countdown"}]}], [{"text": ["If you have a bunch of tasks that need to get performed later, and you want them to persist even if you shut down the calling program or your workers, you should really look into Celery, which makes it super easy to create new tasks, have them executed on any machine you'd like, and wait for the results."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Celery", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://celeryproject.org/"}]}, {"text": ["From the Celery page, \"This is a simple task adding two numbers:\""], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from celery.task import task\n\n@task\ndef add(x, y):\n    return x + y\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can execute the task in the background, or wait for it to finish:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; result = add.delay(8, 8)\n&gt;&gt;&gt; result.wait() # wait for and return the result\n16\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Have you looked at the multiprocessing module?", "It comes standard with Python.", "It is similar to the threading module, but runs each task in a process.", "You can use a Pool() object to set up a worker pool, then use the .map() method to call a function with the various queued task arguments."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "multiprocessing", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "threading", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "Pool()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": ".map()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Pyzmq has an ioloop implementation with a similar api to that of the tornado ioloop.", "It implements a DelayedCallback which may help you."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "Pyzmq", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.zeromq.org/bindings%3apython"}, {"text": "ioloop", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "DelayedCallback", "tag": "a", "pos": 1, "childList": [{"text": "DelayedCallback", "tag": "code"}], "childNum": 1, "href": "http://zeromq.github.com/pyzmq/api/generated/zmq.eventloop.ioloop.html#zmq.eventloop.ioloop.DelayedCallback"}, {"text": "DelayedCallback", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Presuming your process has a run loop which can receive signals and the length of time of each action is within bounds of sequential operation, use signals and posix alarm() "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n signal.alarm(time)\nIf time is non-zero, this function requests that a \nSIGALRM signal be sent to the process in time seconds.\n</code>\n</pre>\n", "senID": 1}, {"text": ["This depends on what you mean by \"those \"later\" actions can be a lot\" and if your process already uses signals.", "Due to phrasing of the question it's unclear why an external python package would be needed."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "those \"later\" actions can be a lot", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Another option is to use the Phyton GLib bindings, in particular its timeout functions.  "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Phyton GLib bindings", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://developer.gnome.org/pygobject/stable/glib-functions.html"}, {"text": "timeout", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It's a good choice as long as you don't want to make use of multiple cores and as long as the dependency on GLib is no problem.", "It handles all events in the same thread which prevents synchronization issues.", "Additionally, its event framework can also be used to watch and handle IO-based (i.e.", "sockets) events."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["UPDATE:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "UPDATE:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Here's a live session using GLib:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import time\n&gt;&gt;&gt; import glib\n&gt;&gt;&gt; \n&gt;&gt;&gt; def workon(thing):\n...     print(\"%s: working on %s\" % (time.time(), thing))\n...     return True # use True for repetitive and False for one-time tasks\n... \n&gt;&gt;&gt; ml = glib.MainLoop()\n&gt;&gt;&gt; \n&gt;&gt;&gt; glib.timeout_add(1000, workon, \"this\")\n2\n&gt;&gt;&gt; glib.timeout_add(2000, workon, \"that\")\n3\n&gt;&gt;&gt; \n&gt;&gt;&gt; ml.run()\n1311343177.61: working on this\n1311343178.61: working on that\n1311343178.61: working on this\n1311343179.61: working on this\n1311343180.61: working on this\n1311343180.61: working on that\n1311343181.61: working on this\n1311343182.61: working on this\n1311343182.61: working on that\n1311343183.61: working on this\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Well in my opinion you could use something called \"cooperative multitasking\".", "It's twisted-based thing and its really cool.", "Just look at PyCon presentation from 2010: http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2010-cooperative-multitasking-with-twisted-getting-things-done-concurrently-11-3352182"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2010-cooperative-multitasking-with-twisted-getting-things-done-concurrently-11-3352182", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://blip.tv/pycon-us-videos-2009-2010-2011/pycon-2010-cooperative-multitasking-with-twisted-getting-things-done-concurrently-11-3352182"}]}, {"text": ["Well you will need transport queue to do this too..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Simply you can Inherit your calss from Thread and crated inatce of your class with Param like timeout so for each instace of your class you can say timeout that will make your thread wait fro the that time "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]