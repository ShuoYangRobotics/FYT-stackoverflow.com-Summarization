[[{"text": ["Well, that will tell you whether they're definitely different or probably the same.", "It's possible for two files to have the same hash but not actually have the same data... just very unlikely."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "probably", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "possible", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["In your situation, what is the impact if you get a false positive (i.e.", "if you think they're the same, but they're not)?", "MD5 is probably good enough not to worry about collisions if they would only occur accidentally... but if you've got security (or money) at stake and someone could plant a \"bad\" file with the same hash as a \"good\" file, you shouldn't rely on it."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "accidentally", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Personally, I'd probably just read both files, comparing each byte - for a one off comparison, both the hashing and this approach will require reading the whole file when they're equal; as Daniel points out in the comments, doing a byte-by-byte comparison lets you exit early as soon as you see a difference.", "Comparing the file sizes first is another quick optimization :)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The general advantage of hashing occurs when you store the hash of the existing file somewhere, so that next time you can just read the new file."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "just", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["If you want to do more than just detect if they differ, or don't trust the hashing solution, there are modules called difflib and filecmp that doesn't rely on external programs."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "difflib", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/difflib.html"}, {"href": "http://docs.python.org/library/filecmp.html", "text": "filecmp", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Of course there is a simple test that you should do before comparing the file content at all - if the files are different sizes, then they can not possibly be the same."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Wouldn't it be more efficient to simply read each file and do a byte-by-byte comparison, avoiding the hashing algorithm altogether.", "This avoids the the (very unlikely) chance that two different files produce the same MD5 hash.", "Furthermore, you can bail out of the comparison when the first difference is detected, which for very different files will be very early in the comparison (possible on the first byte!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If you're on a system with md5sum, that's probably good enough."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can do it with Python standard libraries -- checkout out hashlib."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "hashlib", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Depends if you feel comfortable with the probability of collision on the MD5 algorithm.", "Just note it is highly unlikely: so yes, go ahead."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If there is nobody maliciously trying to create collisions, then you would have to compare about 264 files before you would expect to see a collision by random chance.", "However, it is possible for someone to carefully construct two files with the same MD5 sum due to cryptographic weaknesses in MD5.", "Whether the cryptographic weaknesses of MD5 matter or not depends on your application, where the files come from, and what an attacker could stand to gain if he tricked your program into thinking two different files were identical.", "MD5 is still a very good checksum, just not so great as a cryptographic hash. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "64", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}, {"text": "collision by random chance", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Birthday%5Fproblem"}, {"text": "cryptographic weaknesses in MD5", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://eprint.iacr.org/2006/105"}]}], [{"text": ["A hash is useful if you are going to cache it (to compare many different files with each-other).", "If you just want to compare two files, it's a monstrous waste of cycles.", "After all - both files will be read in, and a lot of processing will be used on every bite."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If it's a 1:1 compare, just use:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import filecmp\nfilecmp.cmp(file_name_1,file_name_2)\n</code>\n</pre>\n", "senID": 2}, {"text": ["On the other hand, a good hash is the only way to compare a large number of files with each-other."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "large", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["SHA-1 and MD5 sort of broken - but not for normal files.", "A few researchers can generate 2 nonsense files that might clash, but it's unlikely that anyone can clobber an existing file."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["git uses SHA-1 to compare text, so it's not a terrible choice."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The following will all work:    "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import hashlib\nhash = hashlib.MD5(your_text_here).hexdigest() # safe*\nhash = hashlib.SHA1(your_text_here).hexdigest() # safe*\nhash = hashlib.SHA224(your_text_here).hexdigest() # safe\nhash = hashlib.SHA512(your_text_here).hexdigest() # paranoid\n\n# now put the hash in a dictionary (or database) for your many-to-many comparison.\n\n#  * Meaningful files will not be clobbered. Contrived files can be generated\n#    which might clash together, but it's difficult to do.\n</code>\n</pre>\n", "senID": 7}], [{"text": ["yes, it is enough"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]