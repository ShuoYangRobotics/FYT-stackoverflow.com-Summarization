[[{"text": ["On CPython you can use ctypes to access the C-API of the interpreter, this way you can change builtin types at runtime."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import ctypes as c\n\n\nclass PyObject_HEAD(c.Structure):\n    _fields_ = [\n        ('HEAD', c.c_ubyte * (object.__basicsize__ -\n                              c.sizeof(c.c_void_p))),\n        ('ob_type', c.c_void_p)\n    ]\n\n_get_dict = c.pythonapi._PyObject_GetDictPtr\n_get_dict.restype = c.POINTER(c.py_object)\n_get_dict.argtypes = [c.py_object]\n\ndef get_dict(object):\n    return _get_dict(object).contents.value\n\ndef my_method(self):\n    print 'tada'\nget_dict(str)['my_method'] = my_method\n\nprint ''.my_method()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Although this is interesting to look at and may be quite interesting to figure out... don't ever use it in productive code.", "Just subclass the builtin type or try to figure out if there is another, may be more pythonic, approach to your problem."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "don't", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["In short, you can't.", "The Python Way would be to subclass String and work from there."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Ruby way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \"1\".to_i\n\"1\".to_roman\n</code>\n</pre>\n", "senID": 1}, {"text": ["Python way:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n int(\"1\")\nRoman(\"1\") # or \nRoman.fromstring(\"1\")\n</code>\n</pre>\n", "senID": 3}, {"text": ["Where Roman will work on a fixed list of built-in types or anything with a __int__ method."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "Roman", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__int__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It is an implementation limitation of CPython that you can't set attributes of built-in/extension types.", "It is accompanied by cultural preference to avoid monkey-patching in favor of stand-alone functions, custom classes that have as an attribute desired object (or even subclassing in rare cases)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Python does not support that feature."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["To do that you can subclass str."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["However, while technically possible, most of the time you are subclassing builtins (such as str) you are looking at a 'has-a' kind of relationship, not 'is-a', therefore composition should be used, not inheritance (meaning you should create a class with a string as an instance attribute, rather than subclass string)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You don't.", "Use separate dictionaries to \"attach\" (logically speaking) information to immutable values like strings or numbers (the string or number value as key, the information as corresponding value in the dict)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can't, it isn't Pythonic.", "Monkey-patching isn't a commonly used feature of Python, so for performance -- I believe -- reasons you can't do it on the built it classes or instances thereof."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In fact, it has its own name in Python: duck-punching."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]