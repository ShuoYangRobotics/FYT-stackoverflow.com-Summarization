[[{"text": ["If you want arithmetic overflows to overflow within e.g.", "32 bits, you could use e.g.", "numpy.uint32."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy.uint32", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["That gives you a warning when an overflow occurs."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import numpy\n&gt;&gt;&gt; numpy.uint32(2**32-3) + numpy.uint32(5)\nWarning: overflow encountered in ulong_scalars\n2\n</code>\n</pre>\n", "senID": 2}, {"text": ["I tested its speed though:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;\\python26\\python.exe -m timeit \"2**16 + 2**2\"\n1000000 loops, best of 3: 0.118 usec per loop\n\n&gt;\\python26\\python.exe -m timeit \"2**67 + 2**65\"\n1000000 loops, best of 3: 0.234 usec per loop\n\n&gt;\\python26\\python.exe -m timeit -s \"import numpy; numpy.seterr('ignore')\" \"numpy.uint32(2)**numpy.uint32(67) + numpy.uint32(2)**numpy.uint32(65)\"\n10000 loops, best of 3: 34.7 usec per loop\n</code>\n</pre>\n", "senID": 4}, {"text": ["It's not looking good for speed."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Int vs long is an historical legacy - in python 3, every int is a \"long\".", "If your script speed is limited by int computation, it is likely that you are doing it wrong."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To give you a proper answer, we need more information on what are you trying to do."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You can force your values to return to normal ints if you include an num = int(num) occasionally in your algorithm.", "If the value is long but fits in a native int, it will demote down to int.", "If the value doesn't fit in a native int, it will remain a long."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "num = int(num)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["So you want to throw out the One True Way and go retro on overflows.", "Silly you. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There is no good upside to the C / C++ / C# / Java style of overflow.", "It does not reliably raise an error condition.", "For C and C99 it is \"undefined behavior\" in ANSI and POSIX (C++ mandates modulo return) and it is a known security risk.", "Why do you want this? "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "It does not reliably raise an error condition", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/103654/why-dont-languages-raise-errors-on-integer-overflow-by-default"}]}, {"text": ["The Python method of seamlessly overflowing to a long is the better way.", "I believe this is the same behavior being adapted by Perl 6.   "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Python method", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/release/1.4/ref/ref5.html"}]}, {"text": ["You can use the Decimal module to get more finite overflows:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Decimal module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/decimal.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from decimal import *\n&gt;&gt;&gt; from sys import maxint\n&gt;&gt;&gt; getcontext()\nContext(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999999, Emax=999999999, capitals=1,\nflags=[], traps=[DivisionByZero, Overflow, InvalidOperation])\n\n&gt;&gt;&gt; d=Decimal(maxint)\n&gt;&gt;&gt; d\nDecimal('9223372036854775807')\n&gt;&gt;&gt; e=Decimal(maxint)\n&gt;&gt;&gt; f=d**e\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"/System/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/decimal.py\", line 2225, in __pow__\n    ans = ans._fix(context)\n  File \"/System/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/decimal.py\", line 1589, in _fix\n    return context._raise_error(Overflow, 'above Emax', self._sign)\n  File \"/System/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/decimal.py\", line 3680, in _raise_error\n    raise error(explanation)\ndecimal.Overflow: above Emax\n</code>\n</pre>\n", "senID": 4}, {"text": ["You can set your precision and boundary conditions with Decimal classes and the overflow is nearly immediate.", "You can set what you trap for.", "You can set your max and min.", "Really -- How does it get better than this?", "(I don't know about relative speed to be honest, but I suspect it is faster than numby but slower than native ints obviously...)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["For your specific issue of image processing, this sounds like a natural application to consider some form of saturation arithmetic.", "You also might consider, if you are having overflows on 32 arithmetic, check operands along the way on obvious cases: pow, **, *.", "You might consider overloaded operators and check for the conditions you don't want."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "saturation arithmetic", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Saturated_arithmetic"}, {"text": "overloaded operators", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.brpreiss.com/books/opus7/html/page596.html"}]}, {"text": ["If Decimal, saturation, or overloaded operators don't work -- you can write an extension.", "Heaven help you if you want to throw out the Python way of overflow to go retro..."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "you can write an extension", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/extending/"}]}], [{"text": ["I don't know if it would be faster, neccesarily, but you could use numpy arrays of one element instead of ints."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If the specific calculation you are concerned about is integer exponentiation, then there are some inferences we can draw:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def smart_pow(mantissa, exponent, limit=int(math.ceil(math.log(sys.maxint)/math.log(2)))):\n    if mantissa in (0, 1):\n        return mantissa\n    if exponent &gt; limit:\n        if mantissa == -1: \n            return -1 if exponent&amp;1 else 1\n        if mantissa &gt; 1:\n            return sys.maxint\n        else: \n            return (-1-sys.maxint) if exponent&amp;1 else sys.maxint\n    else: # this *might* overflow, but at least it won't take long\n        return mantissa ** exponent\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Well, if you don't care about accuracy you could all of your math ops modulo maxint."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]