[[{"text": ["If you restrict yourself to the Python standard library, then a list of lists is the closest construct:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n arr = [[1,2],[3,4]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["gives a 2d-like array.", "The rows can be accessed as arr[i] for i in {0,..,len(arr}, but column access is difficult."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "arr[i]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "i", "childNum": 0, "tag": "code", "childList": []}, {"text": "{0,..,len(arr}", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you are willing to add a library dependency, the NumPy package is what you really want.", "You can create a fixed-length array from a list of lists using:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "NumPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org"}]}, {"code": "<pre>\n<code>\n import numpy\narr = numpy.array([[1,2],[3,4]])\n</code>\n</pre>\n", "senID": 4}, {"text": ["Column access is the same as for the list-of-lists, but column access is easy: arr[:,i] for i in {0,..,arr.shape[1]} (the number of columns)."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "arr[:,i]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "i", "childNum": 0, "tag": "code", "childList": []}, {"text": "{0,..,arr.shape[1]}", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In fact NumPy arrays can be n-dimensional."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Empty arrays can be created with"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n numpy.empty(shape)\n</code>\n</pre>\n", "senID": 8}, {"text": ["where shape is a tuple of size in each dimension; shape=(1,3,2) gives a 3-d array with size 1 in the first dimension, size 3 in the second dimension and 2 in the 3rd dimension."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "shape", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "shape=(1,3,2)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you want to store objects in a NumPy array, you can do that as well:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n arr = numpy.empty((1,), dtype=numpy.object)\n arr[0] = 'abc'\n</code>\n</pre>\n", "senID": 11}, {"text": ["For more info on the NumPy project, check out the NumPy homepage."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "NumPy homepage", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org"}]}], [{"text": ["You can create it using nested lists:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n matrix = [[a,b],[c,d],[e,f]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["If it has to be dynamic it's more complicated, why not write a small class yourself?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Matrix(object):\n    def __init__(self, rows, columns, default=0):\n        self.m = []\n        for i in range(rows):\n            self.m.append([default for j in range(columns)])\n\n    def __getitem__(self, index):\n        return self.m[index]\n</code>\n</pre>\n", "senID": 3}, {"text": ["This can be used like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n m = Matrix(10,5)\nm[3][6] = 7\nprint m[3][6] // -&gt; 7\n</code>\n</pre>\n", "senID": 5}, {"text": ["I'm sure one could implement it much more efficient.", ":)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["If you need multidimensional arrays you can either create an array and calculate the offset or you'd use arrays in arrays in arrays, which can be pretty bad for memory.", "(Could be faster though\u2026) I've implemented the first idea like this:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n class Matrix(object):\n    def __init__(self, *dims):\n        self._shortcuts = [i for i in self._create_shortcuts(dims)]\n        self._li = [None] * (self._shortcuts.pop())\n        self._shortcuts.reverse()\n\n    def _create_shortcuts(self, dims):\n        dimList = list(dims)\n        dimList.reverse()\n        number = 1\n        yield 1\n        for i in dimList:\n            number *= i\n            yield number\n\n    def _flat_index(self, index):\n        if len(index) != len(self._shortcuts):\n            raise TypeError()\n\n        flatIndex = 0\n        for i, num in enumerate(index):\n            flatIndex += num * self._shortcuts[i]\n        return flatIndex\n\n    def __getitem__(self, index):\n        return self._li[self._flat_index(index)]\n\n    def __setitem__(self, index, value):\n        self._li[self._flat_index(index)] = value\n</code>\n</pre>\n", "senID": 8}, {"text": ["Can be used like this:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n m = Matrix(4,5,2,6)\nm[2,3,1,3] = 'x'\nm[2,3,1,3] // -&gt; 'x'\n</code>\n</pre>\n", "senID": 10}], [{"text": ["Multidimensional arrays are a little murky.", "There are few reasons for using them and many reasons for thinking twice and using something else that more properly reflects what you're doing.", "[Hint.", "your question was thin on context ;-) ]"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you're doing matrix math, then use numpy."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "numpy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["However, some folks have worked with languages that force them to use multi-dimensional arrays because it's all they've got.", "If your as old as I am (I started programming in the 70's) then you may remember the days when multidimensional arrays were the only data structure you had.", "Or, your experience may have limited you to languages where you had to morph your problem into multi-dimensional arrays."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Say you have a collection n 3D points.", "Each point has an x, y, z, and time value.", "Is this an n x 4 array?", "Or a 4 * n array?", "Not really.  "], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "n", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "n", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "n", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Since each point has 4 fixed values, this is more properly a list of tuples."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n a = [ ( x, y, z, t ), ( x, y, z, t ), ... ]\n</code>\n</pre>\n", "senID": 5}, {"text": ["Better still, we could represent this as a list of objects."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n class Point( object ):\n    def __init__( self, x, y, z, t ):\n        self.x, self.y, self.z, self.t = x, y, z, t\n\na = [ Point(x,y,x,t), Point(x,y,z,t), ... ]\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Take a look at numpy"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org//"}]}, {"text": ["here's a code snippet for you"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import numpy as npy\n\nd = npy.zeros((len(x)+1, len(y)+1, len(x)+len(y)+3))\nd[0][0][0] = 0 # although this is unnecessary since zeros initialises to zero\nd[i][j][k] = npy.inf\n</code>\n</pre>\n", "senID": 2}, {"text": ["I don't think you need to be implementing a scientific application to justify the use of numpy.", "It is faster and more flexible and you can store pretty much anything.", "Given that I think it is probably better to try and justify not using it.", "There are legitimate reasons, but it adds a great deal and costs very little so it deserves consideration."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["P.S.", "Are your array lengths right?", "It looks like a pretty peculiar shaped matrix..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["To create a standard python array of arrays of arbitrary size:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = [[0]*cols for _ in [0]*rows]\n</code>\n</pre>\n", "senID": 1}, {"text": ["It is accessed like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a[0][1] = 5 # set cell at row 0, col 1 to 5\n</code>\n</pre>\n", "senID": 3}, {"text": ["A small python gotcha that's worth mentioning:  It is tempting to just type"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n a = [[0]*cols]*rows\n</code>\n</pre>\n", "senID": 5}, {"text": ["but that'll copy the same column array to each row, resulting in unwanted behaviour.", "Namely:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "same", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a[0][0] = 5\n&gt;&gt;&gt; print a[1][0]\n5\n</code>\n</pre>\n", "senID": 7}], [{"text": ["If you are OK using sparse arrays, you could use a dict to store your values.", "Python's dicts allow you to use tuples as keys, as such, you could assign to and access elements of the \"sparse array\" (which is really a dict here) like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d = {}\nd[0,2,7] = 123 # assign 123 to x=0, y=2, z=7\nv = d[0,2,7]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Probably not relevant for you but if you are doing serious matrix work see numpy"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org/"}]}], [{"text": ["For numeric data, Numpy Arrays:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Numpy Arrays", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org/"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; matrix1 = array(([0,1],[1,3]))\n&gt;&gt;&gt; print matrix1\n[[0 1]\n[1 3]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["For general data (e.g.", "strings), you can use a list of lists, list of tuples, ..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n matrix2 = [['a','b'], ['x','y']]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here's a quick way to create a nested 3-dimensional list initialized with zeros:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # dim1, dim2, dim3 are the dimensions of the array\na =[[[0 for _ in range(dim1)] for _ in range(dim2)] for _ in range(dim1) ]\na[0][0][0] = 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["this is a list of lists of lists, a bit more flexible than an array, you can do:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a[0][0] = [1,2,3,4]\n</code>\n</pre>\n", "senID": 3}, {"text": ["to replace a whole row in the array, or even abuse it like that:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n a[0] = \"Ouch\"\nprint a[0][0] #will print \"O\", since strings are indexable the same way as lists\nprint a[0][0][0] #will raise an error, since \"O\" isn't indexable\n</code>\n</pre>\n", "senID": 5}, {"text": ["but if you need performance, then I agree that numpy is the way to go."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Also, beware of:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n a = [[[0] * 5]*5]*5]\n</code>\n</pre>\n", "senID": 8}, {"text": ["If you try a[0][0][0]=7 on the object above, you will see what's wrong with that."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "a[0][0][0]=7", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Another option is to use a dictionary:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import defaultdict\n&gt;&gt;&gt; array = defaultdict(int) # replace int with the default-factory you want\n&gt;&gt;&gt; array[(0,0)]\n0\n&gt;&gt;&gt; array[(99,99)]\n0\n</code>\n</pre>\n", "senID": 1}, {"text": ["You'll need to keep track of the upper &amp; lower bounds as well."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I've just stepped into a similar need and coded this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def nDimensionsMatrix(dims, elem_count, ptr=[]):\n    if (dims &gt; 1):\n    \tfor i in range(elem_count[dims-1]):\n    \t\tempty = []\n    \t\tptr.append(empty)\n    \t\tnDimensionsMatrix(dims-1, elem_count, empty)\n    \treturn ptr\n    elif dims == 1:\n    \tptr.extend([0 for i in range(elem_count[dims])])\n    \treturn ptr\n\nmatrix = nDimensionsMatrix(3, (2,2,2))\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm not looking at speed, only funcionality ;)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I want to create a matrix with N dimensions and initialize with 0 (a *elem_count* number of elements in each dimension)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Hope its helps someone"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Easy, when using numpy:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n b = ones((2,3,4)) # creates a 2x3x4 array containing all ones.\n</code>\n</pre>\n", "senID": 1}, {"text": ["'ones' can be replaced with 'zeros'"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]