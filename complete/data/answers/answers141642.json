[[{"text": ["The most important limitation, currently, is that you cannot assign to an outer-scope variable.", "In other words, closures are read-only:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def outer(x): \n...     def inner_reads():\n...         # Will return outer's 'x'.\n...         return x\n...     def inner_writes(y):\n...         # Will assign to a local 'x', not the outer 'x'\n...         x = y\n...     def inner_error(y):\n...         # Will produce an error: 'x' is local because of the assignment,\n...         # but we use it before it is assigned to.\n...         tmp = x\n...         x = y\n...         return tmp\n...     return inner_reads, inner_writes, inner_error\n... \n&gt;&gt;&gt; inner_reads, inner_writes, inner_error = outer(5)\n&gt;&gt;&gt; inner_reads()\n5\n&gt;&gt;&gt; inner_writes(10)\n&gt;&gt;&gt; inner_reads()\n5\n&gt;&gt;&gt; inner_error(10)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 11, in inner_error\nUnboundLocalError: local variable 'x' referenced before assignment\n</code>\n</pre>\n", "senID": 1}, {"text": ["A name that gets assigned to in a local scope (a function) is always local, unless declared otherwise.", "While there is the 'global' declaration to declare a variable global even when it is assigned to, there is no such declaration for enclosed variables -- yet.", "In Python 3.0, there is (will be) the 'nonlocal' declaration that does just that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You can work around this limitation in the mean time by using a mutable container type:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def outer(x):\n...     x = [x]\n...     def inner_reads():\n...         # Will return outer's x's first (and only) element.\n...         return x[0]\n...     def inner_writes(y):\n...         # Will look up outer's x, then mutate it.      \n...         x[0] = y\n...     def inner_error(y):\n...         # Will now work, because 'x' is not assigned to, just referenced.\n...         tmp = x[0]\n...         x[0] = y\n...         return tmp\n...     return inner_reads, inner_writes, inner_error\n... \n&gt;&gt;&gt; inner_reads, inner_writes, inner_error = outer(5)\n&gt;&gt;&gt; inner_reads()\n5\n&gt;&gt;&gt; inner_writes(10)\n&gt;&gt;&gt; inner_reads()\n10\n&gt;&gt;&gt; inner_error(15)\n10\n&gt;&gt;&gt; inner_reads()\n15\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The only difficulty I've seen people encounter with Python's in particular is when they try to mix non-functional features like variable reassignment with closures, and are surprised when this doesn't work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def outer ():\n    x = 1\n    def inner ():\n        print x\n        x = 2\n    return inner\nouter () ()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usually just pointing out that a function has its own local variables is enough to deter such silliness."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["@Kevin Little"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Kevin Little", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "#141767"}]}, {"text": ["nonlocal does not solves completely this problem:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n x = 0 # global x\ndef outer():\n    x = 1 # local to `outer`\n    def inner():\n        global x\n        x = 2 # change global\n        print(x) \n        x = 3 # change global\n        return x\n    def inner2():\n##        nonlocal x # can't use `nonlocal` here\n        print(x)     # prints global\n##        x = 4      # can't change `x` here\n        return x\n    x = 5\n    return (inner, inner2)\n\nfor inner in outer():\n    print(inner())\n# -&gt; 2 3 3 3\n</code>\n</pre>\n", "senID": 2}, {"text": ["On the other hand:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n x = 0\ndef outer():\n    x = 1 # local to `outer`\n    def inner():\n##        global x\n        x = 2\n        print(x) # local to `inner` \n        x = 3 \n        return x\n    def inner2():\n        nonlocal x\n        print(x)\n        x = 4  # local to `outer`\n        return x\n    x = 5\n    return (inner, inner2)\n\nfor inner in outer():\n    print(inner())\n# -&gt; 2 3 5 4\n</code>\n</pre>\n", "senID": 4}], [{"text": ["@John Millikin"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "John Millikin", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "#141670"}]}, {"code": "<pre>\n<code>\n def outer():\n    x = 1 # local to `outer()`\n\n    def inner():\n        x = 2     # local to `inner()`\n        print(x)\n        x = 3\n        return x\n\n    def inner2():\n        nonlocal x\n        print(x)  # local to `outer()`\n        x = 4     # change `x`, it is not local to `inner2()`\n        return x\n\n    x = 5         # local to `outer()`\n    return (inner, inner2)\n\nfor inner in outer():\n    print(inner()) \n\n# -&gt; 2 3 5 4\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Fixed in Python 3.0 via the nonlocal keyword.", "See hereand search for \"nonlocal\".For those of you who don't like using the web: "], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "nonlocal", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.artima.com/weblogs/viewpost.jsp?thread=208549"}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}], [{"text": ["A limitation (or \"limitation\") of Python closures, comparing to Javascript closures, is that it cannot be used for effective data hiding"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "cannot", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "data hiding", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n var mksecretmaker = function(){\n    var secrets = [];\n    var mksecret = function() {\n        secrets.push(Math.random())\n    }\n    return mksecret\n}\nvar secretmaker = mksecretmaker();\nsecretmaker(); secretmaker()\n// privately generated secret number list\n// is practically inaccessible\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n<code>\n import random\ndef mksecretmaker():\n    secrets = []\n    def mksecret():\n        secrets.append(random.random())\n    return mksecret\n\nsecretmaker = mksecretmaker()\nsecretmaker(); secretmaker()\n# \"secrets\" are easily accessible,\n# it's difficult to hide something in Python:\nsecretmaker.__closure__[0].cell_contents # -&gt; e.g. [0.680752847190161, 0.9068475951742101]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The better workaround until 3.0 is to include the variable as a defaulted parameter in the enclosed function definition:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\ndef f()\n    x = 5\n    def g(y, z, x=x):\n        x = x + 1\n</pre>\n", "senID": 1}]]