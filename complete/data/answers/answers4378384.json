[[{"text": ["Sven has the right idea.", "You can avoid having to check supersets by just checking the number N - 1 ahead."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def smallest_contiguous(s, N):\n    lst = list(s)\n    lst.sort()\n    Nm = N-1\n    for i in xrange(len(lst) - Nm):\n        if lst[i] + Nm == lst[i + Nm]:\n            return range(lst[i], lst[i]+N)\n    return []\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will only always be correct for a set as input and knowing that the set only contains integers."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["How about this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def smallest_contiguous(s, N):\n    lst = sorted(s)\n    for i in lst:\n        t = range(i, i+N)\n        if s.issuperset(t):\n            return t\n    return []\n</code>\n</pre>\n", "senID": 1}, {"text": ["It might not be the most efficient solution, but it is concise."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: Justin's approach could also be made more concise:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def smallest_contiguous(s, N):\n    lst = sorted(s)\n    for a, b in zip(lst, lst[N - 1:]):\n        if b - a == N - 1:\n            return range(a, b + 1)\n    return []\n</code>\n</pre>\n", "senID": 4}], [{"text": ["That should do it ... look ahead length - 1 steps in the sorted list.", "Since it contains integers only and is sorted, the difference must be length - 1 as well."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "length - 1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "length - 1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def smallest_contiguous(myset, length):\n    if len(myset) &lt; length:\n        return []\n\n    s = sorted(myset)\n    for idx in range(0, len(myset) - length + 1):\n        if s[idx+length-1] - s[idx] == length - 1:\n            return s[idx:idx+length]\n\n    return []\n\ns=set([5,6,10,12,13,15,30,40,41,42,43,44,55,56,90,300,500])\nprint smallest_contiguous(s, 5)\nprint smallest_contiguous(s, 6)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's one I came up with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def smallest_contiguous(s,N):\n    try:\n        result = []\n        while len(result) &lt; N:\n            min_value = min(s)\n            s.remove(min_value)\n            if result == [] or min_value == result[-1] + 1:\n                result.append(min_value)\n            else:\n                result = [min_value]\n        return result\n    except ValueError:\n        return []\n</code>\n</pre>\n", "senID": 1}, {"text": ["It modifies the input set as a side effect."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["itertools to the rescue.", "groupby does all the grunt work here\nThe algorithm is O(n logn) because of the call to sorted()"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sorted()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import groupby, count\n&gt;&gt;&gt; def smallest_contiguous(s, N):\n...     for i,j in groupby(sorted(s), key=lambda i,c=count().next: i-c()):\n...         res = list(j)\n...         if len(res) == N:\n...             return res\n...     return []\n\n... \n&gt;&gt;&gt; smallest_contiguous(s,5)\n[40, 41, 42, 43, 44]\n&gt;&gt;&gt; smallest_contiguous(s,6)\n[]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def smallest_contiguous(s, n):\n    xs = sorted(s)\n    return next(x for i, x in enumerate(xs) if xs[i + n - 1] == x + n - 1)\n</code>\n</pre>\n", "senID": 0}]]