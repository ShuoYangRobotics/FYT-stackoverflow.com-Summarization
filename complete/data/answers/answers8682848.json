[[{"text": ["I sympathize with your sense that boilerplate code is a bad thing.", "But in this case, I'm not sure there even could be a better alternative.", "Let's consider the possibilities. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you're talking about just a few variables, then a series of self.x = x lines is easy to read.", "In fact, I think its explicitness makes that approach preferable from a readability standpoint.", "And while it might be a slight pain to type, that alone isn't quite enough to justify a new language construct that might obscure what's really going on.", "Certainly using vars(self).update() shenanigans would be more confusing than it's worth in this case. "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "self.x = x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "vars(self).update()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["On the other hand, if you're passing nine, ten, or more parameters to __init__, you probably need to refactor anyway.", "So this concern really only applies to cases that involve passing, say, 5-8 parameters.", "Now I can see how eight lines of self.x = x would be annoying both to type and to read; but I'm not sure that the 5-8 parameter case is common enough or troublesome enough to justify using a different method.", "So I think that, while the concern you're raising is a good one in principle, in practice, there are other limiting issues that make it irrelevant. "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self.x = x", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["To make this point more concrete, let's consider a function that takes an object, a dict, and a list of names, and assigns values from the dict to names from the list.", "This ensures that you're still being explicit about which variables are being assigned to self.", "(I would never suggest a solution to this problem that didn't call for an explicit enumeration of the variables to be assigned; that would be a rare-earth bug magnet):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def assign_attributes(obj, localdict, names):\n...     for name in names:\n...         setattr(obj, name, localdict[name])\n...\n&gt;&gt;&gt; class SomeClass():\n...     def __init__(self, a, b, c):\n...         assign_attributes(self, vars(), ['a', 'b', 'c'])\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now, while not horribly unattractive, this is still harder to figure out than a straightforward series of self.x = x lines.", "And it's also longer and more trouble to type than one, two, and maybe even three or four lines, depending on circumstances.", "So you only get certain payoff starting with the five-parameter case.", "But that's also the exact moment that you begin to approach the limit on human short-term memory capacity (= 7 +/- 2 \"chunks\").", "So in this case, your code is already a bit challenging to read, and this would only make it more challenging."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "horribly", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "self.x = x", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "exact", "childNum": 0, "tag": "em", "pos": 3, "childList": []}, {"text": "short-term memory capacity", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Short-term_memory"}]}], [{"text": ["Mod for @pcperini's answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class SomeClass():\n        def __init__(self, a, b=1, c=2):\n            for for name,value in vars().iteritems():\n                if name != 'self':\n                    setattr(self,name,value)\n\n&gt;&gt;&gt; s = SomeClass(7,8)\n&gt;&gt;&gt; print s.a,s.b,s.c\n7 8 2\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could do this, which has the virtue of simplicity:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;  class C(object):\n    def __init__(self, **kwargs):\n        self.__dict__ = dict(kwargs)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This leaves it up to whatever code creates an instance of C to decide what the instance's attributes will be after construction, e.g."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "C", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; c = C(a='a', b='b', c='c')\n&gt;&gt;&gt; c.a, c.b, c.c\n('a', 'b', 'c')\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you want all C objects to have a, b, and c attributes, this approach won't be useful."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "C", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["(BTW, this pattern comes from Guido his own bad self, as a general solution to the problem of defining enums in Python.", "Create a class like the above called Enum, and then you can write code like Colors = Enum(Red=0, Green=1, Blue=2), and henceforth use Colors.Red, Colors.Green, and Colors.Blue."], "childNum": 5, "tag": "p", "senID": 5, "childList": [{"text": "Enum", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Colors = Enum(Red=0, Green=1, Blue=2)", "childNum": 0, "tag": "code", "childList": []}, {"text": "Colors.Red", "childNum": 0, "tag": "code", "childList": []}, {"text": "Colors.Green", "childNum": 0, "tag": "code", "childList": []}, {"text": "Colors.Blue", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It's a worthwhile exercise to figure out what kinds of problems you could have if you set self.__dict__ to kwargs instead of dict(kwargs)."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "self.__dict__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "kwargs", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict(kwargs)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You can do it via setattr(), like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["[setattr(self, key, value) for key, value in kwargs.items()]"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "[setattr(self, key, value) for key, value in kwargs.items()]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Is not very beautiful, but can save some space :)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["So, you'll get:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n kwargs = { 'd':1, 'e': 2, 'z': 3, }\n\n  class P():\n     def __init__(self, **kwargs):\n        [setattr(self, key, value) for key, value in kwargs.items()]\n\n  x = P(**kwargs)\n  dir(x)\n  ['__doc__', '__init__', '__module__', 'd', 'e', 'z']\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Your specific case could also be handled with a namedtuple:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "namedtuple", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; SomeClass = namedtuple(\"SomeClass\", \"a b c\")\n&gt;&gt;&gt; sc = SomeClass(1, \"x\", 200)\n&gt;&gt;&gt; print sc\nSomeClass(a=1, b='x', c=200)\n&gt;&gt;&gt; print sc.a, sc.b, sc.c\n1 x 200\n</code>\n</pre>\n", "senID": 1}], [{"text": ["For that simple use-case I must say I like putting things explicitly (using the Ctrl+1 from PyDev), but sometimes I also end up using a bunch implementation, but with a class where the accepted attributes are created from attributes pre-declared in the class, so that I know what's expected (and I like it more than a namedtuple as I find it more readable -- and it won't confuse static code analysis or code-completion)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I've put on a recipe for it at: http://code.activestate.com/recipes/577999-bunch-class-created-from-attributes-in-class/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://code.activestate.com/recipes/577999-bunch-class-created-from-attributes-in-class/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/577999-bunch-class-created-from-attributes-in-class/"}]}, {"text": ["The basic idea is that you declare your class as a subclass of Bunch and it'll create those attributes in the instance (either from default or from values passed in the constructor):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Point(Bunch):\n    x = 0\n    y = 0\n\np0 = Point()\nassert p0.x == 0\nassert p0.y == 0\n\np1 = Point(x=10, y=20)\nassert p1.x == 10\nassert p1.y == 20\n</code>\n</pre>\n", "senID": 3}, {"text": ["Also, Alex Martelli also provided a bunch implementation: http://code.activestate.com/recipes/52308-the-simple-but-handy-collector-of-a-bunch-of-named/ with the idea of updating the instance from the arguments, but that'll confuse static code-analysis (and IMO can make things harder to follow) so, I'd only use that approach for an instance that's created locally and thrown away inside that same scope without passing it anywhere else)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://code.activestate.com/recipes/52308-the-simple-but-handy-collector-of-a-bunch-of-named/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/52308-the-simple-but-handy-collector-of-a-bunch-of-named/"}]}], [{"text": ["Disclaimer"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Do not use this: I was simply trying to create the answer closest to OPs initial intentions.", "As pointed out in comments, this relies on entirely undefined behavior, and explicitly prohibited modifications of the symbol table."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Do not use this:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "entirely undefined behavior", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["It does work though, and has been tested under extremely basic circumstances."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "extremely basic circumstances", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Solution"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class SomeClass():\n    def __init__(self, a, b, c):\n        vars(self).update(dict((k,v) for k,v in vars().iteritems() if (k != 'self')))\n\nsc = SomeClass(1, 2, 3)\n# sc.a == 1\n# sc.b == 2\n# sc.c == 3\n</code>\n</pre>\n", "senID": 4}, {"text": ["Using the vars() built-in function, this snippet iterates through all of the variables available in the __init__ method (which should, at this point, just be self, a, b, and c) and set's self's variables equal to the same, obviously ignoring the argument-reference to self (because self.self seemed like a poor decision."], "childNum": 9, "tag": "p", "senID": 5, "childList": [{"text": "vars()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "childList": []}, {"text": "self.self", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Decorator magic!"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Decorator magic!!", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class SomeClass():\n        @ArgsToSelf\n        def __init__(a, b=1, c=2, d=4, e=5):\n            pass\n\n&gt;&gt;&gt; s=SomeClass(6,b=7,d=8)\n&gt;&gt;&gt; print s.a,s.b,s.c,s.d,s.e\n6 7 2 8 5\n</code>\n</pre>\n", "senID": 1}, {"text": ["while  defining:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import inspect\n&gt;&gt;&gt; def ArgsToSelf(f):\n    def act(self, *args, **kwargs):\n        arg_names,_,_,defaults = inspect.getargspec(f)\n        defaults=list(defaults)\n        for arg in args:\n            setattr(self, arg_names.pop(0),arg)\n        for arg_name,arg in kwargs.iteritems():\n            setattr(self, arg_name,arg)\n            defaults.pop(arg_names.index(arg_name))\n            arg_names.remove(arg_name)\n        for arg_name,arg in zip(arg_names,defaults):\n            setattr(self, arg_name,arg)\n        return f(*args, **kwargs)\n    return act\n</code>\n</pre>\n", "senID": 3}, {"text": ["Of course you could define this decorator once and use it throughout your project.Also, This decorator works on any object function, not only __init__."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}]]