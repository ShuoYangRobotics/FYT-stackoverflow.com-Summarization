[[{"code": "<pre>\n<code>\n def doit( s ):\n\n    # with some side-effect on a\n    a = [] \n\n    def f1( s, m ):\n        a.append( 1 )\n        print 'f1', a, s, m\n\n    def f2( s, m ):\n        a.append( 2 )\n        print 'f2', a, s, m\n\n    def f3( s, m ):\n        a.append( 3 )\n        print 'f3', a, s, m\n\n    re1 = re.compile( 'one' )\n    re2 = re.compile( 'two' )\n    re3 = re.compile( 'three' )\n\n\n    func_re_list = (\n        ( f1, re1 ), \n        ( f2, re2 ), \n        ( f3, re3 ),\n    )\n    for myfunc, myre in func_re_list:\n        m = myre.match( s )\n        if m:\n            myfunc( s, m )\n            break\n\n\ndoit( 'one' ) \ndoit( 'two' ) \ndoit( 'three' )\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This might be a bit over engineering the solution, but you could combine them as a single regexp with named groups and see which group matched.", "This could be encapsulated as a helper class:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nclass MultiRe(object):\n    def __init__(self, **regexps):\n        self.keys = regexps.keys()\n        self.union_re = re.compile(\"|\".join(\"(?P&lt;%s&gt;%s)\" % kv for kv in regexps.items()))\n\n    def match(self, string, *args):\n        result = self.union_re.match(string, *args)\n        if result:\n            for key in self.keys:\n                if result.group(key) is not None:\n                    return key\n</code>\n</pre>\n", "senID": 1}, {"text": ["Lookup would be like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n multi_re = MultiRe(foo='fo+', bar='ba+r', baz='ba+z')\nmatch = multi_re.match('baaz')\nif match == 'foo':\n     # one thing\nelif match == 'bar':\n     # some other thing\nelif match == 'baz':\n     # or this\nelse:\n     # no match\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This is a good application for the undocumented but quite useful re.Scanner class."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re.Scanner", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/457664/"}]}], [{"text": ["A few ideas, none of them good necessarily, but it might fit your code well:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["How about putting the code in a separate function, i.e.", "MatchRegex(), which returns which regex it matched.", "That way, inside the function, you can use a return after you matched the first (or second) regex, meaning you lose the inefficiency."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "MatchRegex()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Of course, you could always go with just nested if statements:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n m = firstre.match(str)\nif m:\n   # Do something\nelse:\n    m = secondre.match(str)\n    ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["I really don't see any reason not to go with nested ifs.", "They're very easy to understand and as efficient as you want.", "I'd go for them just for their simplicity."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You could use"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def do_first(str, res, actions):\n  for re,action in zip(res, actions):\n    m = re.match(str)\n    if m:\n      action(str)\n      return\n</code>\n</pre>\n", "senID": 1}, {"text": ["So, for example, say you've defined"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def do_something_1(str):\n  print \"#1: %s\" % str\n\ndef do_something_2(str):\n  print \"#2: %s\" % str\n\ndef do_something_3(str):\n  print \"#3: %s\" % str\n\nfirstre  = re.compile(\"foo\")\nsecondre = re.compile(\"bar\")\nthirdre  = re.compile(\"baz\")\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then call it with"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n do_first(\"baz\",\n         [firstre,        secondre,       thirdre],\n         [do_something_1, do_something_2, do_something_3])\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Early returns, perhaps?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def doit(s):\n    m = re1.match(s)\n    if m:\n        # Do something\n        return\n\n    m = re2.match(s)\n    if m:\n        # Do something else\n        return\n\n    ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["Ants Aasma's answer is good too.", "If you prefer less scaffolding you can write that out yourself using the verbose regex syntax."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "verbose regex syntax", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html#re.X"}]}, {"code": "<pre>\n<code>\n re = re.compile(r'''(?x)    # set the verbose flag\n    (?P&lt;foo&gt; fo+ )\n  | (?P&lt;bar&gt; ba+r )\n  | #...other alternatives...\n''')\n\ndef doit(s):\n    m = re.match(s)\n    if m.group('foo'):\n        # Do something\n    elif m.group('bar'):\n        # Do something else\n    ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["I've done this a lot.", "It's fast and it works with re.finditer."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "re.finditer", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Do it with an elif in case you just need a True/False out of regex matching:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if regex1.match(str):\n    # do stuff\nelif regex2.match(str):\n    # and so on\n</code>\n</pre>\n", "senID": 1}]]