[[{"text": ["The question isn't completely clear on scope, but I have a hunch that PyPy, embedding other full languages, and similar solutions might be overkill.", "It sounds like iamgopal may really be interested in something more like Interpreter Pattern or Little Language."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Interpreter Pattern", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Interpreter_pattern"}, {"href": "http://c2.com/cgi/wiki?LittleLanguage", "text": "Little Language", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["If the language you want to support is really small (see the Interpreter Pattern link), then hand-coding this yourself in Python won't be too hard.", "You can write a simple parser (Google around; here's one example), then walk the AST and evaluate user expressions."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "one example", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/simple-iterator-parser.htm"}]}, {"text": ["However, if you expect this to be used for a long time or by many people, it may be worth throwing a real language at the problem.", "(I'd recommend Python itself if your users are already familiar with basic Python syntax)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Ren'Py is a modification to Python syntax built on top of Python itself, using the language tools in the stdlib."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Ren'Py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.renpy.org/"}, {"href": "http://docs.python.org/library/language.html", "text": "language tools", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["For your user's sake, don't use an XML based language - XML is an awful basis for a programming language and your users will hate you for it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is a suggestion.", "Use a strict subset of Python for your language.", "Use the compiler module to convert their code into an abstract syntax tree and walk the tree to to validate that the code conforms to your subset before converting the AST into python bytecode."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "compiler module", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/compiler.html"}]}, {"text": ["N.B.", "I just checked the docs and see that the compiler package is deprecated in 2.6 and removed in Python 3.x.", "Does anyone know why that is?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Why not Python itself?", "With some care you can use eval to run user code."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "eval", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["One of the good thing about interpreted scripting languages is that you don't need another extra scripting language!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["PLY (Python Lex-Yacc)\n is something of your interest."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "PLY (Python Lex-Yacc)", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "PLY (Python Lex-Yacc)", "tag": "a"}]}, {"href": "http://www.dabeaz.com/ply/", "text": "PLY (Python Lex-Yacc)", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Numerous template languages such as Cheetah, Django templates, Genshi, Mako, Mighty might serve as an example."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Possibly Common Lisp (or any other Lisp) will be the best choice for that task.", "Because Lisp make it possible to easily extend host language with powerful macroses and construct DSL (domain specific language)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If all you need is simple if statements and expressions, I'm sure it wouldn't be an awful task to parse each line.", "Something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if some flag\n    activate some feature\n    deactivate some feature\nelif some other flag\n    activate some feature\n    activate some feature\nelse\n    logout\n</code>\n</pre>\n", "senID": 1}, {"text": ["Just write a class which, while parsing takes the first word, checks if it's \"if, elif, else,\" etc, and if so, check a flag and set a flag saying you either are or are not executing until the next conditional.", "If it's not a conditional, call a function based on the first keyword that would modify the program state in some way."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The class could store some local execution state (are we in an if statement?", "If so are we executing this branch?", ") and have another class containing some global application state (flags that are checkable by if statements, etc)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["This is probably the wrong thing to do in your situation (it's very prone to bugs, it's dangerous if you don't treat the data in the scripts correctly), but it's at least a start if you do decide to interpret your own mini-language."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Seriously though, if you try this, be very, very, srs careful.", "Don't give the scripts any functionality that they don't definitely need, because you are almost certainly opening security holes by doing something like this."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "definitely", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Don't say I didn't warn you."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]