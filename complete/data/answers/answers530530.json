[[{"text": ["Expressions in default arguments are calculated when the function is defined,notwhen it\u2019s called. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Expressions in default arguments are calculated when the function is defined,notwhen it\u2019s called.", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "not", "tag": "em"}]}, {"text": "not", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Example: consider defaulting an argument to the current time:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Example:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;import time\n&gt;&gt;&gt; def report(when=time.time()):\n...     print when\n...\n&gt;&gt;&gt; report()\n1210294387.19\n&gt;&gt;&gt; time.sleep(5)\n&gt;&gt;&gt; report()\n1210294387.19\n</code>\n</pre>\n", "senID": 2}, {"text": ["The when argument doesn't change.", "It is evaluated when you define the function.", "It won't change until the application is re-started."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "when", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Strategy: you won't trip over this if you default arguments to None and then do something useful when you see it:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "Strategy:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def report(when=None):\n...     if when is None:\n...         when = time.time()\n...     print when\n...\n&gt;&gt;&gt; report()\n1210294762.29\n&gt;&gt;&gt; time.sleep(5)\n&gt;&gt;&gt; report()\n1210294772.23\n</code>\n</pre>\n", "senID": 5}, {"text": ["Exercise: to make sure you've understood: why is this happening?"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Exercise:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def spam(eggs=[]):\n...     eggs.append(\"spam\")\n...     return eggs\n...\n&gt;&gt;&gt; spam()\n['spam']\n&gt;&gt;&gt; spam()\n['spam', 'spam']\n&gt;&gt;&gt; spam()\n['spam', 'spam', 'spam']\n&gt;&gt;&gt; spam()\n['spam', 'spam', 'spam', 'spam']\n</code>\n</pre>\n", "senID": 7}], [{"text": ["You should be aware of how class variables are handled in Python.", "Consider the following class hierarchy:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class AAA(object):\n    x = 1\n\nclass BBB(AAA):\n    pass\n\nclass CCC(AAA):\n    pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now, check the output of the following code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print AAA.x, BBB.x, CCC.x\n1 1 1\n&gt;&gt;&gt; BBB.x = 2\n&gt;&gt;&gt; print AAA.x, BBB.x, CCC.x\n1 2 1\n&gt;&gt;&gt; AAA.x = 3\n&gt;&gt;&gt; print AAA.x, BBB.x, CCC.x\n3 2 3\n</code>\n</pre>\n", "senID": 3}, {"text": ["Surprised?", "You won't be if you remember that class variables are internally handled as dictionaries of a class object.", "If a variable name is not found in the dictionary of current class, the parent classes are searched for it.", "So, the following code again, but with explanations:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n # AAA: {'x': 1}, BBB: {}, CCC: {}\n&gt;&gt;&gt; print AAA.x, BBB.x, CCC.x\n1 1 1\n&gt;&gt;&gt; BBB.x = 2\n# AAA: {'x': 1}, BBB: {'x': 2}, CCC: {}\n&gt;&gt;&gt; print AAA.x, BBB.x, CCC.x\n1 2 1\n&gt;&gt;&gt; AAA.x = 3\n# AAA: {'x': 3}, BBB: {'x': 2}, CCC: {}\n&gt;&gt;&gt; print AAA.x, BBB.x, CCC.x\n3 2 3\n</code>\n</pre>\n", "senID": 5}, {"text": ["Same goes for handling class variables in class instances (treat this example as a continuation of the one above):"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = AAA()\n# a: {}, AAA: {'x': 3}\n&gt;&gt;&gt; print a.x, AAA.x\n3 3\n&gt;&gt;&gt; a.x = 4\n# a: {'x': 4}, AAA: {'x': 3}\n&gt;&gt;&gt; print a.x, AAA.x\n4 3\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Loops and lambdas (or any closure, really): variables are bound by name"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "name", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n funcs = []\nfor x in range(5):\n  funcs.append(lambda: x)\n\n[f() for f in funcs]\n# output:\n# 5 5 5 5 5\n</code>\n</pre>\n", "senID": 1}, {"text": ["A work around is either creating a separate function or passing the args by name:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n funcs = []\nfor x in range(5):\n  funcs.append(lambda x=x: x)\n[f() for f in funcs]\n# output:\n# 1 2 3 4 5\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Dynamic binding makes typos in your variable names surprisingly hard to find.", "It's easy to spend half an hour fixing a trivial bug."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["EDIT: an example..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for item in some_list:\n    ... # lots of code\n... # more code\nfor tiem in some_other_list:\n    process(item) # oops!\n</code>\n</pre>\n", "senID": 2}], [{"text": ["There was a lot of discussion on hidden language features a while back: hidden-features-of-python.", "Where some pitfalls were mentioned (and some of the good stuff too). "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "hidden-features-of-python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/101268/hidden-features-of-python"}]}, {"text": ["Also you might want to check out Python Warts."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Python Warts", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/PythonWarts"}]}, {"text": ["But for me, integer division's a gotcha:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 5/2\n2\n</code>\n</pre>\n", "senID": 3}, {"text": ["You probably wanted:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 5*1.0/2\n2.5\n</code>\n</pre>\n", "senID": 5}, {"text": ["If you really want this (C-like) behaviour, you should write:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 5//2\n2\n</code>\n</pre>\n", "senID": 7}, {"text": ["As that will work with floats too (and it will work when you eventually go to Python 3):"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Python 3", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/3.0/whatsnew/3.0.html#integers"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 5*1.0//2\n2.0\n</code>\n</pre>\n", "senID": 9}, {"text": ["GvR explains how integer division came to work how it does on the history of Python."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "the history of Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://python-history.blogspot.com/2009/03/problem-with-integer-division.html"}]}], [{"text": ["The only gotcha/surprise I've dealt with is with CPython's GIL.", "If for whatever reason you expect python threads in CPython to run concurrently... well they're not and this is pretty well documented by the Python crowd and even Guido himself."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A long but thorough explanation of CPython threading and some of the things going on under the hood and why true concurrency with CPython isn't possible.", "http://jessenoller.com/2009/02/01/python-threads-and-the-global-interpreter-lock/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://jessenoller.com/2009/02/01/python-threads-and-the-global-interpreter-lock/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://jessenoller.com/2009/02/01/python-threads-and-the-global-interpreter-lock/"}]}], [{"text": ["Not including an __init__.py in your packages.", "That one still gets me sometimes."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["James Dumay eloquently reminded me of another Python gotcha: "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "James Dumay eloquently reminded me", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://twitter.com/i386/status/1194993686"}]}, {"text": ["Not all of Python's \u201cincluded batteries\u201d are wonderful. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Not all of Python's \u201cincluded batteries\u201d are wonderful", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["James\u2019 specific example was the HTTP libraries: httplib, urllib, urllib2, urlparse, mimetools, and ftplib.", "Some of the functionality is duplicated, and some of the functionality you'd expect is completely absent, e.g.", "redirect handling.", "Frankly, it's horrible. "], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "httplib", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "urllib", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "urllib2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "urlparse", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "mimetools", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "ftplib", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["If I ever have to grab something via HTTP these days, I use the urlgrabber module forked from the Yum project."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "urlgrabber", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://linux.duke.edu/projects/urlgrabber/"}]}], [{"text": ["Unintentionally mixing oldstyle and newstyle classes can cause seemingly mysterious errors."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "mixing oldstyle and newstyle classes", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Say you have a simple class hierarchy consisting of superclass A and subclass B.", "When B is instantiated, A's constructor must be called first.", "The code below correctly does this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    def __init__(self):\n        self.a = 1\n\nclass B(A):\n    def __init__(self):\n        super(B, self).__init__()\n        self.b = 1\n\nb = B()\n</code>\n</pre>\n", "senID": 2}, {"text": ["But if you forget to make A a newstyle class and define it like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class A:\n    def __init__(self):\n        self.a = 1\n</code>\n</pre>\n", "senID": 4}, {"text": ["you get this traceback:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n Traceback (most recent call last):\n  File \"AB.py\", line 11, in &lt;module&gt;\n    b = B()\n  File \"AB.py\", line 7, in __init__\n    super(B, self).__init__()\nTypeError: super() argument 1 must be type, not classobj\n</code>\n</pre>\n", "senID": 6}, {"text": ["Two other questions relating to this issue are 489269 and 770134"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "489269", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/489269/python-super-raises-typeerror-why"}, {"href": "http://stackoverflow.com/questions/770134/python-cmd-module-subclassing-issue", "text": "770134", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Floats are not printed at full precision by default (without repr):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "repr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n x = 1.0 / 3\ny = 0.333333333333\nprint x  #: 0.333333333333\nprint y  #: 0.333333333333\nprint x == y  #: False\n</code>\n</pre>\n", "senID": 1}, {"text": ["repr prints too many digits:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "repr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n print repr(x)  #: 0.33333333333333331\nprint repr(y)  #: 0.33333333333300003\nprint x == 0.3333333333333333  #: True\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You cannot use locals()['x'] = whatever  to change local variable values as you might expect."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n This works:\n\n&gt;&gt;&gt; x = 1\n&gt;&gt;&gt; x\n1\n&gt;&gt;&gt; locals()['x'] = 2\n&gt;&gt;&gt; x\n2\n\nBUT:\n\n&gt;&gt;&gt; def test():\n...     x = 1\n...     print x\n...     locals()['x'] = 2\n...     print x  # *** prints 1, not 2 ***\n...\n&gt;&gt;&gt; test()\n1\n1\n</code>\n</pre>\n", "senID": 1}, {"text": ["This actually burnt me in an answer here on SO, since I had tested it outside a function and got the change I wanted.", "Afterwards, I found it mentioned and contrasted to the case of globals() in \"Dive Into Python.", "\"  See example 8.12 in:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://diveintopython.org/html_processing/locals_and_globals.html"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://diveintopython.org/html_processing/locals_and_globals.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://diveintopython.org/html_processing/locals_and_globals.html"}]}, {"text": ["(Though it does not note that the change via locals() will work at the top level as I show above."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["One of the biggest surprises I ever had with Python is this one:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = ([42],)\na[0] += [43, 44]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This works as one might expect, except for raising a TypeError after updating the first entry of the tuple!", "So a will be ([42, 43, 44],) after executing the += statement, but there will be an exception anyway.", "If you try this on the other hand"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "([42, 43, 44],)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n a = ([42],)\nb = a[0]\nb += [43, 44]\n</code>\n</pre>\n", "senID": 3}, {"text": ["you won't get an error."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n try:\n    int(\"z\")\nexcept IndexError, ValueError:\n    pass\n</code>\n</pre>\n", "senID": 0}, {"text": ["won't catch ValueError in Python 2.x.", "This has been sorted out in Python 3.x."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n try:\n    int(\"z\")\nexcept IndexError, ValueError:\n    pass\n</code>\n</pre>\n", "senID": 0}, {"text": ["reason this doesn't work is because IndexError is the type of exception you're catching, and ValueError is the name of the variable you're assigning the exception to."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Correct code to catch multiple exceptions is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n try:\n    int(\"z\")\nexcept (IndexError, ValueError):\n    pass\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n def f():\n    x += 1\n\nx = 42\nf()\n</code>\n</pre>\n", "senID": 0}, {"text": ["results in an UnboundLocalError, because local names are detected statically.", "A different example would be"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "UnboundLocalError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def f():\n    print x\n    x = 43\n\nx = 42\nf()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["List slicing has caused me a lot of grief.", "I actually consider the following behavior a bug."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "List slicing", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Define a list x"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = [10, 20, 30, 40, 50]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Access index 2:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x[2]\n30\n</code>\n</pre>\n", "senID": 4}, {"text": ["As you expect."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Slice the list from index 2 and to the end of the list:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x[2:]\n[30, 40, 50]\n</code>\n</pre>\n", "senID": 7}, {"text": ["As you expect."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Access index 7:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x[7]\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nIndexError: list index out of range\n</code>\n</pre>\n", "senID": 10}, {"text": ["Again, as you expect."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["However, try to slice the list from index 7 until the end of the list:"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "However", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x[7:]\n[]\n</code>\n</pre>\n", "senID": 13}, {"text": ["??", "? "], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["The remedy is to put a lot of tests when using list slicing.", "I wish I'd just get an error instead.", "Much easier to debug."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}]]