[[{"text": ["There are several such \"scores\", but they all depend on how you define similarity."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "I think the python library already has a ", "tag": "none", "senID": 1}, {"text": "you can also compute the ", "tag": "none", "senID": 2}, {"text": "NYSIIS?", "tag": "none", "senID": 3}]}], [{"text": ["Have a look at locality-sensitive hashing."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "locality-sensitive hashing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Locality_sensitive_hashing"}]}, {"text": ["There's a very good explanation available here together with some sample code."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://d3s.mff.cuni.cz/~holub/sw/shash/"}]}], [{"text": ["TL;DR: Python BK-tree"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python BK-tree", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/572156-bk-tree/"}]}, {"text": ["Interesting question.", "I have limited experience within this field, but since the Levenshtein distance fulfills the triangle inequality, I figured that there must be a way of computing some sort of absolute distance to an origin in order to find strings in the vicinity of each other without performing direct comparisons against all entries in the entire database."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["While googling on some terms related to this, I found one particularly interesting thesis: Aspects of Metric Spaces in Computation by Matthew Adam Skala."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Aspects of Metric Spaces in Computation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://uwspace.uwaterloo.ca/bitstream/10012/3788/1/thesis.pdf"}]}, {"text": ["At page 26 he discusses similarity measures based on kd-trees and others, but concludes:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["A blog entry about how BK-trees work can be found here."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://blog.notdot.net/2007/4/Damn-Cool-Algorithms-Part-1-BK-Trees"}]}, {"text": ["In the thesis, Skala  goes on describing other solutions to this problem, including VP-trees and GH-trees.", "Chapter 6 analyses distances based on the Levenshtein edit distance.", "He also presents some other interesting distance metrics for strings."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "VP-trees", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Vp-tree"}]}, {"text": ["I also found Foundations of Multidimensional and Metric Data Structures, which seems relevant to your question."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Foundations of Multidimensional and Metric Data Structures", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://rads.stackoverflow.com/amzn/click/0123694469"}]}], [{"text": ["You may be interested in Hamming Distance.", "The Python function hamming_distance() computes the Hamming distance between two strings."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Hamming Distance", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Hamming_distance"}]}, {"code": "<pre>\n<code>\n def hamming_distance(s1, s2):\n    assert len(s1) == len(s2)\n    return sum(ch1 != ch2 for ch1, ch2 in zip(s1, s2))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can always use Levenshtein distance, also, there is a written implementation for that:\nhttp://code.google.com/p/pylevenshtein/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.google.com/p/pylevenshtein/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/pylevenshtein/"}]}, {"text": ["But, for simplicity, you can use builtin difflib module:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import difflib\n&gt;&gt;&gt; l\n{'Hello Earth', 'Hello World!', 'Foo Bar!', 'Foo world!', 'Foo bar', 'Hello World', 'FooBarbar'}\n&gt;&gt;&gt; difflib.get_close_matches(\"Foo World\", l)\n['Foo world!', 'Hello World', 'Hello World!']\n</code>\n</pre>\n", "senID": 2}, {"text": ["http://docs.python.org/library/difflib.html#difflib.get_close_matches"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://docs.python.org/library/difflib.html#difflib.get_close_matches", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/difflib.html#difflib.get_close_matches"}]}], [{"text": ["For a fast way of determining string similarity, you might want to use fuzzy hashing."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "fuzzy hashing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://thedigitalstandard.blogspot.com/2009/11/why-fuzzy-hashing-is-really-cool.html"}]}]]