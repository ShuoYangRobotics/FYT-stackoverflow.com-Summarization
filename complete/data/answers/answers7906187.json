[[{"text": ["If the object isn't valid before it's called, then call that method in __init__ (or use a factory function).", "You don't need any silly singletons, that's for sure."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The model I have been using is that subsequent functions are only available as methods on the return value of previous functions, like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Second(object):\n   def two(self):\n     print \"two\"\n     return Third()\n\nclass Third(object):\n   def three(self):\n     print \"three\"\n\ndef one():\n   print \"one\"\n   return Second()\n\none().two().three()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Properly designed, this style (which I admit is not terribly Pythonic, yet) makes for fluent libraries to handle complex pipeline operations where later steps in the library require both the results of early calculations and fresh input from the calling function."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "yet", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["An interesting result is error handling.", "What I've found is the best way of handling well-understood errors in pipeline steps is having a blank Error class that supposedly can handle every function in the pipeline (except initial one) but those functions (except possibly terminal ones) return only self:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class Error(object):\n   def two(self, *args):\n      print \"two not done because of earlier errors\"\n      return self\n   def three(self, *args):\n      print \"three not done because of earlier errors\"\n\nclass Second(object):\n   def two(self, arg):\n     if arg == 2:\n       print \"two\"\n       return Third()\n     else:\n       print \"two cannot be done\"\n       return Error()\n\nclass Third(object):\n   def three(self):\n     print \"three\"\n\ndef one(arg):\n   if arg == 1:\n      print \"one\"\n      return Second()\n   else:\n      print \"one cannot be done\"\n      return Error()\n\none(1).two(-1).three()\n</code>\n</pre>\n", "senID": 4}, {"text": ["In your example, you'd have the Parser class, which would have almost nothing but a configure function that returned an instance of a ConfiguredParser class, which would do all the thing that only a properly configured parser could do.", "This gives you access to such things as multiple configurations and handling failed attempts at configuration."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "configure", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["As Cat Plus Plus said in other words, wrap the behaviour/functions up in a class and put all the required setup in the __init__ method.", "You might complain that the functions don't seem like they naturally belong together in an object and, hence, this is bad OO design.", "If that's the case, think of your class/object as a form of name-spacing.", "It's much cleaner and more flexible than trying to enforce function calling order somehow or using singletons."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["What it comes down to is how friendly do you want your error messages to be if a function is called before it is configured.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Least friendly is to do nothing extra, and let the functions fail noisily with AttributeErrors, IndexErrors, etc."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "AttributeError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "IndexError", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Most friendly would be having stub functions that raise an informative exception, such as a custom ConfigError:  configuration not initialized.", "When the ConfigParser() function is called it can then replace the stub functions with real functions.", "Something like this:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "ConfigError:  configuration not initialized", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ConfigParser()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n config.py\n----------\nclass ConfigError(Exception):\n    \"configuration errors\"\n\ndef query_data():\n    raise ConfigError(\"parse_config() has not been called\")\n\ndef _query_data():\n    do_actual_work()\n\ndef parse_config(config_file):\n    load_file(config_file)\n    if failure:\n        raise ConfigError(\"bad file\")\n    all_objects = globals()\n    for name in ('query_data', ):\n        working_func = all_objects['_'+name]\n        all_objects[name] = working_func\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you have very many functions you can add decorators to keep track of the function names, but that's an answer for a different question.", ";)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Okay,  I couldn't resist -- here is the decorator version, which makes my solution much easier to actually implement:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class ConfigError(Exception):\n    \"various configuration errors\"\n\nclass NeedsConfig(object):\n    def __init__(self, module_namespace):\n        self._namespace = module_namespace\n        self._functions = dict()\n    def __call__(self, func):\n        self._functions[func.__name__] = func\n        return self._stub\n    @staticmethod\n    def _stub(*args, **kwargs):\n        raise ConfigError(\"parseconfig() needs to be called first\")\n    def go_live(self):\n        for name, func in self._functions.items():\n            self._namespace[name] = func\n</code>\n</pre>\n", "senID": 6}, {"text": ["And a sample run:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n needs_parseconfig = NeedsConfig(globals())\n\n@needs_parseconfig\ndef query_data():\n    print \"got some data!\"\n\n@needs_parseconfig\ndef set_data():\n    print \"set the data!\"\n\ndef okay():\n    print \"Okay!\"\n\ndef parse_config(somefile):\n    needs_parseconfig.go_live()\n\ntry:\n    query_data()\nexcept ConfigError, e:\n    print e\n\ntry:\n    set_data()\nexcept ConfigError, e:\n    print e\n\ntry:\n    okay()\nexcept:\n    print \"this shouldn't happen!\"\n    raise\n\nparse_config('config_file')\nquery_data()\nset_data()\nokay()\n</code>\n</pre>\n", "senID": 8}, {"text": ["and the results:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n parseconfig() needs to be called first\nparseconfig() needs to be called first\nOkay!\ngot some data!\nset the data!\nOkay!\n</code>\n</pre>\n", "senID": 10}, {"text": ["As you can see, the decorator works by remembering the functions it decorates, and instead of returning a decorated function it returns a simple stub that raises a ConfigError if it is ever called.", "When the parse_config() routine is called, it needs to call the go_live() method which will then replace all the error raising stubs with the actual remembered functions."], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "ConfigError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "parse_config()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "go_live()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The simple requirement that a module needs to be \"configured\" before it is used is best handled by a class which does the \"configuration\" in the __init__ method, as in the currently-accepted answer.", "Other module functions become methods of the class.", "There is no benefit in trying to make a singleton ... the caller may well want to have two or more differently-configured gadgets operating simultaneously."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "There is no benefit in trying to make a singleton ... the caller may well want to have two or more differently-configured gadgets operating simultaneously.", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Moving on from that to a more complicated requirement, such as a temporal ordering of the methods:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This can be handled in a quite general fashion by maintaining state in attributes of the object, as is usually done in any OOPable language.", "Each method that has prerequisites must check that those prequisites are satisfied. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Poking in replacement methods is an obfuscation on a par with the COBOL ALTER verb, and made worse by using decorators -- it just wouldn't/shouldn't get past code review."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "COBOL ALTER verb", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.tonymarston.net/cobol/cobolstandards.html#alter"}]}], [{"text": ["A module doesn't do anything it isn't told to do so put your function calls at the bottom of the module so that when you import it, things get ran in the order you specify:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["test.py"], "childNum": 0, "tag": "h2", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import testmod\n</code>\n</pre>\n", "senID": 2}, {"text": ["testmod.py"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def fun1():\n    print('fun1')\n\ndef fun2():\n    print('fun2')\n\nfun1()\nfun2()\n</code>\n</pre>\n", "senID": 4}, {"text": ["When you run test.py, you'll see fun1 is ran before fun2:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n python test.py \nfun1\nfun2\n</code>\n</pre>\n", "senID": 6}]]