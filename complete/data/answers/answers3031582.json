[[{"text": ["Two suggestions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First, a structure that involves 32-deep nesting of subdirectories is inherently flawed.", "Assuming that you really have \"about 10 million files\", one level of subdirectories should absolutely be enough (assuming you use a modern filesystem)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "First", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Second: You say you have \"about 10 million files\" and that each file \"contains an integer string\".", "Assuming that those are 32-bit integers and you store them directly instead of as strings, that amounts to a total dataset size of 40MiB (10M files * 4 bytes per file).", "Assuming that each filename is 32 bytes long, add another 320MiB for \"keys\" to this data."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Second", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["So you'll be able to easily fit the whole dataset into memory.", "I suggest doing just that, and operate over the data held in main memory.", "And unless there is any reason you need an elaborate directory structure, I further suggest storing the data in a single file."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "easily fit the whole dataset into memory", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["I would suggest you rethink your approach, using lots of extremely small files is bound to give you serious performance problems.", "Depending on the purpose of your program some kind of database could be far more efficient. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you're doing lots of I/O you can also just throw more hardware at the problem and use SSDs or keep all the data in RAM (explicitly or by caching).", "With harddrives alone you have no chance of achiving good performance in this scenario."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I've never used it, but e.g.", "Redis is a persistent key-value store that is supposed to be very fast.", "If your data fits this model I would definately try this or something similar.", "You'll find some performance data in this article, which should give you an idea what speeds you can achieve."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Redis", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.google.com/p/redis/"}, {"text": "article", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://www.mysqlperformanceblog.com/2009/08/27/looking-at-redis/"}]}], [{"text": ["I know this isn't a direct answer to your question, but it is a direct solution to your problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You need to research using something like HDF5.", "It is designed for just the type of hierarchical data with millions of individual data points."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "HDF5", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.hdfgroup.org/HDF5/"}]}, {"text": ["You are REALLY in luck because there are awesome Python bindings for HDF5 called pytables.", "I have used it in a very similar way and had tremendous success."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "pytables", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.pytables.org/moin"}]}], [{"text": ["It looks like you are hitting both issues,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "doing too many i/o operations", "tag": "none", "senID": 1}, {"text": "running out of cache", "tag": "none", "senID": 2}]}, {"text": ["I'd suggest revisiting the structure you are using, and using less larger files.", "Keep in minf (as a rule of thumb) than I/O operation less than 128K runtime cost is more or less equal to I/O of 1byte!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You're copying a file, opening it to read, closing it, then reopening it for writing, then recopying it back.", "It would be faster to do it in one go."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["EDIT: the previous version has a bug when the number of digits become less than the current number of digits (e.g.", "if you're subtracting or adding by negative number); this version fixes it, timing result is barely unaffected"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "EDIT: the previous version has a bug when the number of digits become less than the current number of digits (e.g. if you're subtracting or adding by negative number); this version fixes it, timing result is barely unaffected", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def addInFile(path, scoreToAdd):\n    try:\n        fp = open(path, 'r+')\n    except IOError as e:\n        print e\n    else:\n        num = str(scoreToAdd + int(fp.read()))\n        fp.seek(0)\n        fp.write(num)\n        fp.truncate(len(num))\n    finally:\n        fp.close()\n</code>\n</pre>\n", "senID": 2}, {"text": ["alternatively, if you want to avoid file loss and writes to cache, you should do the copying and the summing in one go, then do a an overwrite-dance in another step:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def addInFile(path, scoreToAdd):\n    try:\n        orig = open(path, 'r')\n        tmp = open('/home/lieryan/junks/tmp.txt', 'w')\n    except IOError as e:\n        print e\n    else:\n        num = int(orig.read())\n        tmp.write(str(scoreToAdd + num))\n    finally:\n        orig.close()\n        tmp.close()\n    try:\n        # make sure /tmp/ and path is in the same partition\n        # otherwise the fast shutil.move become a slow shutil.copy\n        shutil.move(path, '/home/lieryan/junks/backup.txt')\n        shutil.move('/home/lieryan/junks/tmp.txt', path)\n        os.remove('/home/lieryan/junks/backup.txt')\n    except (IOError, shutil.Error) as e:\n        print e\n</code>\n</pre>\n", "senID": 4}, {"text": ["also, don't use bare excepts."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Alternatively, how about grouping all the 256 files in the lowest leaf into one bigger file?", "Then you can read multiple numbers in one go, in one cache.", "And if you used a fixed width file, then you can quickly use seek() to get to any entry in the file in O(1)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Some timings, writing 1000 times on the same file:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Your original approach: 1.87690401077", "tag": "none", "senID": 8}, {"text": "My first approach (open with rw+): 0.0926730632782 ", "tag": "none", "senID": 9}, {"text": "My second approach, copy to the same partition: 0.464048147202 ", "tag": "none", "senID": 10}]}, {"text": ["(all functions untested on their error handling path)"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["Resolving all of those subdirectories takes time.", "You're over-taxing the file-system."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Maybe instead of using the directory tree, you could instead encode the path information into the file name, so instead of creating a file with a path like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n /parent/00/01/02/03/04/05/06/07\n       /08/09/0A/0B/0C/0D/0E/0F\n       /10/11/12/13/14/15/16/17\n       /18/19/1A/1B/1C/1D/1E/1F.txt\n</code>\n</pre>\n", "senID": 2}, {"text": ["...you could create a file with a path like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n /parent/00_01_02_03_04_05_06_07_\n        08_09_0A_0B_0C_0D_0E_0F_\n        10_11_12_13_14_15_16_17_\n        18_19_1A_1B_1C_1D_1E_1F.txt\n</code>\n</pre>\n", "senID": 4}, {"text": ["...of course, you'll still have a problem, because now all of your ten million files will be in a single directory, and in my experience (NTFS), a directory with more than a few thousand files in it still over-taxes the file-system."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["You could come up with a hybrid approach:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n /parent/00_01_02_03/04_05_06_07\n       /08_09_0A_0B/0C_0D_0E_0F\n       /10_11_12_13/14_15_16_17\n       /18_19_1A_1B/1C_1D_1E_1F.txt\n</code>\n</pre>\n", "senID": 7}, {"text": ["But that will still give you problems if you exhaustively create all those directories.", "Even though most of those directories are \"empty\" (in that they don't contain any files), the operating system still has to create an INODE record for each directory, and that takes space on disk."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "files", "childNum": 1, "tag": "em", "pos": 1, "childList": [{"text": "files", "tag": "strong"}]}, {"text": "files", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Instead, you should only create a directory when you have a file to put into it.", "Also, if you delete all the files in any given directory, then delete the empty directory."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["How many levels deep should you create the directory hierarchy?", "In my little example, I transformed your 32-level hierarchy into an 8-level hierarchy, but after doing some testing, you might decide on a slightly different mapping.", "It really depends on your data, and how evenly those paths are distributed through the combinatorial solution space.", "You need to optimize a solution with two constraints:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["1) Minimize the number of directories you create, knowing that each directory becomes an INODE in the underlying file-system, and creating too many of them will overwhelm the file system."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["2) Minimize the number of files in each directory, knowing that having too many files per directory (in my experience, more than 1000) overwhelms the file-system."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["There's one other consideration to keep in mind: Storage space on disks is addressed and allocated using \"blocks\".", "If you create a file smaller than the minimum block size, it nevertheless consumes the whole block, wasting disk space.", "In NTFS, those blocks are defined by their \"cluster size\" (which is partially determined by the overall size of the volume), and usually defaults to 4kB:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["http://support.microsoft.com/kb/140365"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "http://support.microsoft.com/kb/140365", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://support.microsoft.com/kb/140365"}]}, {"text": ["So if you create a file with only one byte of data, it will still consume 4kB worth of disk space, wasting 4095 bytes."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["In your example, you said you had about 10 million files, with about 1gB of data.", "If that's true, then each of your files is only about 100 bytes long.", "With a cluster size of 4096, you have about a 98% space-wasted ratio."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["If at all possible, try to consolidate some of those files.", "I don't know what kind of data they contain, but if it's a text format, you might try doing something like this:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n [id:01_23_45_67_89_AB_CD_EF]\nlorem ipsum dolor sit amet consectetur adipiscing elit\n[id:fe_dc_ba_98_76_54_32_10]\nut non lorem quis quam malesuada lacinia\n[id:02_46_81_35_79_AC_DF_BE]\nnulla semper nunc id ligula eleifend pulvinar\n</code>\n</pre>\n", "senID": 18}, {"text": ["...and so on and so forth.", "It might look like you're wasting space with all those verbose headers, but as far as the disk is concerned, this is a much more space-efficient strategy than having separate files for all those little snippets.", "This little example used exactly 230 bytes (including newlines) for three records, so you might try to put about sixteen records into each file (remembering that it's much better to have slightly less than 4096 bytes-per-file than to have slightly more than 4096, wasting a whole extra disk block)."], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["Anyhow, good luck!"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}]]