[[{"code": "<pre>\n<code>\n # Tail\nfrom __future__ import with_statement\n\nfind_str = \"FIREFOX\"                    # String to find\nfname = \"g:/autoIt/ActiveWin.log_2\"     # File to check\n\nwith open(fname, \"r\") as f:\n    f.seek (0, 2)           # Seek @ EOF\n    fsize = f.tell()        # Get Size\n    f.seek (max (fsize-1024, 0), 0) # Set pos @ last n chars\n    lines = f.readlines()       # Read to end\n\nlines = lines[-10:]    # Get last 10 lines\n\n# This returns True if any line is exactly find_str + \"\\n\"\nprint find_str + \"\\n\" in lines\n\n# If you're searching for a substring\nfor line in lines:\n    if find_str in line:\n        print True\n        break\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I think reading the last 2 KB or so of the file should make sure you get 10 lines, and shouldn't be too much of a resource hog."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n file_handle = open(\"somefile\")\nfile_size = file_handle.tell()\nfile_handle.seek(max(file_size - 2*1024, 0))\n\n# this will get rid of trailing newlines, unlike readlines()\nlast_10 = file_handle.read().splitlines()[-10:]\n\nassert len(last_10) == 10, \"Only read %d lines\" % len(last_10)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you are running Python on a POSIX system, you can use 'tail -10' to retrieve the last few lines.", "This may be faster than writing your own Python code to get the last 10 lines.", "Rather than opening the file directly, open a pipe from the command 'tail -10 filename'.", "If you are certain of the log output though (for example, you know that there are never any very long lines that are hundreds or thousands of characters long) then using one of the 'read the last 2KB' approaches listed would be fine."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "never", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}], [{"text": ["I think I remember adapting the code from this blog post from Manu Garg when I had to do something similar."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this blog post from Manu Garg", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://manugarg.blogspot.com/2007/04/tailing-in-python.html"}]}], [{"text": ["Here is a version using mmap that seems pretty efficient.", "The big plus is that mmap will automatically handle the file to memory paging requirements for you."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "mmap", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "mmap", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import os\nfrom mmap import mmap\n\ndef lastn(filename, n):\n    # open the file and mmap it\n    f = open(filename, 'r+')\n    m = mmap(f.fileno(), os.path.getsize(f.name))\n\n    nlcount = 0\n    i = m.size() - 1 \n    if m[i] == '\\n': n += 1\n    while nlcount &lt; n and i &gt; 0:\n        if m[i] == '\\n': nlcount += 1\n        i -= 1\n    if i &gt; 0: i += 2\n\n    return m[i:].splitlines()\n\ntarget = \"target string\"\nprint [l for l in lastn('somefile', 10) if l == target]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could read chunks of 1,000 bytes or so from the end of the file into a buffer until you have 10 lines."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I ran into that problem, parsing the last hour of LARGE syslog files, and used this function from activestate's recipe site... (http://code.activestate.com/recipes/439045/)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.activestate.com/recipes/439045/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/439045/"}]}, {"code": "<pre>\n<code>\n !/usr/bin/env python\n# -*-mode: python; coding: iso-8859-1 -*-\n#\n# Copyright (c) Peter Astrand &lt;astrand@cendio.se&gt;\n\nimport os\nimport string\n\nclass BackwardsReader:\n    \"\"\"Read a file line by line, backwards\"\"\"\n    BLKSIZE = 4096\n\n    def readline(self):\n        while 1:\n            newline_pos = string.rfind(self.buf, \"\\n\")\n            pos = self.file.tell()\n            if newline_pos != -1:\n                # Found a newline\n                line = self.buf[newline_pos+1:]\n                self.buf = self.buf[:newline_pos]\n                if pos != 0 or newline_pos != 0 or self.trailing_newline:\n                    line += \"\\n\"\n                return line\n            else:\n                if pos == 0:\n                    # Start-of-file\n                    return \"\"\n                else:\n                    # Need to fill buffer\n                    toread = min(self.BLKSIZE, pos)\n                    self.file.seek(-toread, 1)\n                    self.buf = self.file.read(toread) + self.buf\n                    self.file.seek(-toread, 1)\n                    if pos - toread == 0:\n                        self.buf = \"\\n\" + self.buf\n\n    def __init__(self, file):\n        self.file = file\n        self.buf = \"\"\n        self.file.seek(-1, 2)\n        self.trailing_newline = 0\n        lastchar = self.file.read(1)\n        if lastchar == \"\\n\":\n            self.trailing_newline = 1\n            self.file.seek(-1, 2)\n\n# Example usage\nbr = BackwardsReader(open('bar'))\n\nwhile 1:\n    line = br.readline()\n    if not line:\n        break\n    print repr(line)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It works really well and is much more efficient then anything like fileObj.readlines()[-10:], which makes python read the entire file into memory and then chops the last ten lines off of it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["read the last few Ks of the file, and split that into lines to return only the last 10."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["it's quite unlikely the start of that chunk to fall on a line boundary, but you'll discard the first lines anyway."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Personally I'd be tempted to break out to the shell and call tail -n10 to load the file.", "But then I'm not really a Python programmer ;)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["tail -n10 | grep"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["First, a function that returns a list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def lastNLines(file, N=10, chunksize=1024):\n    lines = None\n    file.seek(0,2) # go to eof\n    size = file.tell()\n    for pos in xrange(chunksize,size-1,chunksize):\n        # read a chunk\n        file.seek(pos,2)\n        chunk = file.read(chunksize)\n        if lines is None:\n            # first time\n            lines = chunk.splitlines()\n        else:\n            # other times, update the 'first' line with\n            # the new data, and re-split\n            lines[0:1] = (chunk + lines[0]).splitlines()\n        if len(lines) &gt; N:\n            return lines[-N:]\n    file.seek(0)\n    chunk = file.read(size-pos)\n    lines[0:1] = (chunk + lines[0]).splitlines()\n    return lines[-N:]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Second, a function that iterates over the lines in reverse order:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def iter_lines_reversed(file, chunksize=1024):\n    file.seek(0,2)\n    size = file.tell()\n    last_line = \"\"\n    for pos in xrange(chunksize,size-1,chunksize):\n        # read a chunk\n        file.seek(pos,2)\n        chunk = file.read(chunksize) + last_line\n        # split into lines\n        lines = chunk.splitlines()\n        last_line = lines[0]\n        # iterate in reverse order\n        for index,line in enumerate(reversed(lines)):\n            if index &gt; 0:\n                yield line\n    # handle the remaining data at the beginning of the file\n    file.seek(0)\n    chunk = file.read(size-pos) + last_line\n    lines = chunk.splitlines()\n    for line in reversed(lines):\n        yield line\n</code>\n</pre>\n", "senID": 3}, {"text": ["For your example:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n s = \"foo\"\nfor index, line in enumerate(iter_lines_reversed(fileObj)):\n    if line == s:\n        print \"FOUND\"\n        break\n    elif index+1 &gt;= 10:\n        break\n</code>\n</pre>\n", "senID": 5}, {"text": ["Edit: Now gets the file-size automaticly\nEdit2: Now only iterates for 10 lines."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "Edit2:", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["If you're on a unix box, os.popen(\"tail -10 \" + filepath).readlines() will probably be the fastest way.", "Otherwise, it  depends on how robust you want it to be.", "The methods proposed so far will all fall down, one way or another.", "For robustness and speed in the most common case you probably want something like a logarithmic search: use file.seek to go to end of the file minus 1000 characters, read it in, check how many lines it contains, then to EOF minus 3000 characters, read in 2000 characters, count the lines, then EOF minus 7000, read in 4000 characters, count the lines, etc.", "until you have as many lines as you need.", "But if you know for sure that it's always going to be run on files with sensible line lengths, you may not need that."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "os.popen(\"tail -10 \" + filepath).readlines()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You might also find some inspiration in the source code for the unix tail command."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "source code", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.koders.com/c/fid8DEE98A42C35A1346FA89C328CC3BF94E25CF377.aspx"}, {"text": "tail", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Here's an answer like MizardX's, but without its apparent problem of taking quadratic time in the worst case from rescanning the working string repeatedly for newlines as chunks are added."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Compared to the activestate solution (which also seems to be quadratic), this doesn't blow up given an empty file, and does one seek per block read instead of two."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Compared to spawning 'tail', this is self-contained.", "(But 'tail' is best if you have it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Compared to grabbing a few kB off the end and hoping it's enough, this works for any line length."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import os\n\ndef reversed_lines(file):\n    \"Generate the lines of file in reverse order.\"\n    tail = []           # Tail of the line whose head is not yet read.\n    for block in reversed_blocks(file):\n        # A line is a list of strings to avoid quadratic concatenation.\n        # (And trying to avoid 1-element lists would complicate the code.)\n        linelists = [[line] for line in block.splitlines()]\n        linelists[-1].extend(tail)\n        for linelist in reversed(linelists[1:]):\n            yield ''.join(linelist)\n        tail = linelists[0]\n    if tail: yield ''.join(tail)\n\ndef reversed_blocks(file, blocksize=4096):\n    \"Generate blocks of file's contents in reverse order.\"\n    file.seek(0, os.SEEK_END)\n    here = file.tell()\n    while 0 &lt; here:\n        delta = min(blocksize, here)\n        file.seek(here - delta, os.SEEK_SET)\n        yield file.read(delta)\n        here -= delta\n</code>\n</pre>\n", "senID": 4}, {"text": ["To use it as requested:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from itertools import islice\n\ndef check_last_10_lines(file, key):\n    for line in islice(reversed_lines(file), 10):\n        if line == key:\n            print 'FOUND'\n            break\n</code>\n</pre>\n", "senID": 6}, {"text": ["Edit: changed map() to itertools.imap() in head().", "Edit 2: simplified reversed_blocks().", "Edit 3: avoid rescanning tail for newlines."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "Edit 2:", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "Edit 3:", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}], [{"text": ["This solution will read the file only once, but using 2 file object pointers to be able obtain the last N lines of file without re-reading it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def getLastLines (path, n):\n    # return the las N lines from the file indicated in path\n\n    fp = open(path)\n    for i in range(n):\n        line = fp.readline()\n        if line == '':\n            return []\n\n    back = open(path)\n    for each in fp:\n        back.readline()\n\n    result = []\n    for line in back:\n        result.append(line[:-1])\n\n    return result\n\n\n\n\ns = \"foo\"\nlast_bit = getLastLines(r'C:\\Documents and Settings\\ricardo.m.reyes\\My Documents\\desarrollo\\tail.py', 10)\nfor line in last_bit:\n    if line == s:\n        print \"FOUND\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could also count the lines as you reverse through the file, instead of guessing at a byte offset. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n lines = 0\nchunk_size = 1024\n\nf = file('filename')\nf.seek(0, 2)\nf.seek(f.tell() - chunk_size)\n\nwhile True:\n    s = f.read(chunk_size)\n    lines += s.count('\\n')\n    if lines &gt; NUM_OF_LINES:\n        break\n    f.seek(f.tell() - chunk_size*2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now the file is at a good position to run readlines().", "You also could cache the strings you read the first time, to eliminate reading the same portion of the file twice."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "readlines()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Maybe this might be useful:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os.path\n\npath = 'path_to_file'\nos.system('tail -n1 ' + path)\n</code>\n</pre>\n", "senID": 1}]]