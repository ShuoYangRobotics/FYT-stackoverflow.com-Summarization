[[{"text": ["This is a common Python gotcha: [[]]*2 creates two references to the same empty list.", "You want ([], []) or [ [] for _ in xrange(2)] (suitable for long sequences of empty lists)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "[[]]*2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "([], [])", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "[ [] for _ in xrange(2)]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Simpler example that represents your zip code:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n In [1]: dupl = [[]] * 2\n\nIn [2]: dupl[0].append(1)\n\nIn [3]: dupl\nOut[3]: [[1], [1]]\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; a = []\n&gt;&gt;&gt; b = []\n&gt;&gt;&gt; c = a\n&gt;&gt;&gt; a is b\nFalse\n&gt;&gt;&gt; a is a\nTrue\n&gt;&gt;&gt; a is c\nTrue\n</code>\n</pre>\n", "senID": 0}, {"text": ["is demonstrates that your unexpected case is due to having two ways of referencing the same object."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "is", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "same", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d={1:[], 2:[]}\n&gt;&gt;&gt; d[1] is d[2]\nFalse\n&gt;&gt;&gt; dz=dict(zip([1,2],[[]]*2))\n&gt;&gt;&gt; dz[1] is dz[2]\nTrue\n</code>\n</pre>\n", "senID": 2}, {"text": ["If this is not intended behavior, I would probably write"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dz = dict( (k, []) for k in [1, 2] )\n&gt;&gt;&gt; dz[1] is dz[2]\nFalse\n</code>\n</pre>\n", "senID": 4}, {"text": ["or (assuming new enough Python, and this is what you want)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import collections\n&gt;&gt;&gt; dz = collections.defaultdict(list)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["In d, the values of the dict are initially two separate empty lists.", "In dz, they are the same empty list."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "d", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dz", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["[[]]*2 creates a list which contains the same list twice, not a list containing two different lists."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "[[]]*2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n x=[[]]*2\nprint x[0] is x[1]\n# True\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The * operator used to copy elements makes a shallow copy instead of a real copy.", "Essentially, it is duplicating the reference to the same empty list and a change to either reference changes the contents of the same, shared list."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "*", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "shallow copy", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["I'm not sure if this is relevant to what you're eventually going to do with your dict but if you want to have the default content in a dict be a certain value, you can use collections.defaultdict"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/release/2.6.6/library/collections.html#collections.defaultdict", "text": "collections.defaultdict", "childNum": 1, "tag": "a", "childList": [{"text": "collections.defaultdict", "tag": "code"}]}, {"text": "collections.defaultdict", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n d = collections.defaultdict(list)\nd['a'].append(3)\nprint d\ndefaultdict(&lt;type 'list'&gt;, {'a': [3]})\n</code>\n</pre>\n", "senID": 2}], [{"text": ["OK, thanks for the answers.", "Using copy() solves the problem, indeed."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In [1]: import copy"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In [2]: udict = lambda a,e: dict(zip(a,[copy.copy(e) for _ in xrange(len(a))]))"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In [3]: dzx = udict([1,2],[])"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["In [4]: dzx[1].append('word')"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In [5]: dzx"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Out[5]: {1: ['word'], 2: []}"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]