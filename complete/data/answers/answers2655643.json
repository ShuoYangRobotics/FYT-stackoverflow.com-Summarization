[[{"tag": "ul", "num": 3, "lis": [{"text": ["You do not need file pointers, which Python does not have or want. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To go through a file line by line without reading the whole thing into memory, just iterate over the file object itself, i.e."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Going back a line isn't something you can do super-easily.", "If you never need to go back more than one line, check out the pairwise recipe in the itertoolsdocumentation."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "pairwise", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://docs.python.org/library/itertools.html", "text": "itertoolsdocumentation", "childNum": 1, "tag": "a", "childList": [{"text": "itertools", "tag": "code"}]}, {"text": "itertools", "childNum": 0, "tag": "code", "childList": []}]}]}], [{"text": ["If you do want to use a file pointer directly (I think Mike Graham's suggestion is better though), you can use the file object's seek() method which lets you set the internal pointer, combined with the read() method, which support an option argument specifying how many bytes you'd like to read."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "seek()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#file.seek"}, {"href": "http://docs.python.org/library/stdtypes.html#file.read", "text": "read()", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["OK, here's what I came up with.", "Thanks Brenda for the idea of building a class.", "Thanks Josh for the idea to use C like functions seek() and read()"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #!/bin/python\n\n# Usage: BufRead.py inputfile\n\nimport sys, os, string\nfrom inspect import currentframe\n\n# Debug function usage\n#\n# if DEBUG:\n#   debugLogMsg(currentframe().f_lineno,currentframe().f_code.co_filename)\n#   print ...\ndef debugLogMsg(line,file,msg=\"\"):\n  print \"%s:%s %s\" % (file,line,msg)\n\n# Set DEBUG off.\nDEBUG = 0\n\nclass BufRead: \n  def __init__(self,filename): \n    self.__filename           = filename \n    self.__file               = open(self.__filename,'rb') \n    self.__fileposition       = self.__file.tell()\n    self.__file.seek(0, os.SEEK_END)\n    self.__filesize           = self.__file.tell() \n    self.__file.seek(self.__fileposition, os.SEEK_SET) \n\n  def close(self): \n    if self.__file is not None: \n      self.__file.close() \n      self.__file = None \n\n  def seekstart(self):\n    if self.__file == None:\n      self.__file.seek(0, os.SEEK_SET)\n      self.__fileposition = self.__file.tell()\n\n  def seekend(self):\n    if self.__file == None:\n      self.__file.seek(-1, os.SEEK_END)\n      self.__fileposition = self.__file.tell()\n\n  def getc(self):\n    if self.__file == None:\n      return None \n    self.__fileposition = self.__file.tell()\n    if self.__fileposition &lt; self.__filesize:\n      byte = self.__file.read(1)\n      self.__fileposition = self.__file.tell()\n      return byte\n    else:\n      return None\n\n  def ungetc(self):\n    if self.__file == None:\n      return None \n    self.__fileposition = self.__file.tell()\n    if self.__fileposition &gt; 0:\n      self.__fileposition = self.__fileposition - 1\n      self.__file.seek(self.__fileposition, os.SEEK_SET)\n      byte = self.__file.read(1)\n      self.__file.seek(self.__fileposition, os.SEEK_SET)\n      return byte\n    else:\n      return None\n\n  # uses getc() and ungetc()\n  def getline(self):\n    if self.__file == None:\n      return None \n    self.__fileposition = self.__file.tell()\n\n    if self.__fileposition &lt; self.__filesize:\n      startOfLine = False\n      line = \"\"\n\n      while True:\n        if self.__fileposition == 0:\n          startOfLine = True\n          break\n        else:\n          c = self.ungetc()\n          if c == '\\n':\n            c = self.getc()\n            startOfLine = True\n            break\n\n      if startOfLine:\n        c = self.getc()\n        if c == '\\n':\n          return '\\n'\n        else:\n          self.ungetc()\n\n        while True:\n          c = self.getc()\n          if c == '\\n':\n            line += c\n            c = self.getc()\n            if c == None:\n              return line\n            if c == '\\n':\n              self.ungetc()\n            return line\n          elif c == None:\n            return line\n          else:\n            line += c\n    else:\n      return None\n\n  # uses getc() and ungetc()\n  def ungetline(self):\n    if self.__file == None:\n      return None \n    self.__fileposition = self.__file.tell()\n\n    if self.__fileposition &gt; 0:\n      endOfLine = False\n      line = \"\"\n\n      while True:\n        if self.__fileposition == self.__filesize:\n          endOfLine = True\n          break\n        else:\n          c = self.getc()\n          if c == '\\n':\n            c = self.ungetc()\n            endOfLine = True\n            break\n\n      if endOfLine:\n        c = self.ungetc()\n        if c == '\\n':\n          return '\\n'\n        else:\n          self.getc()\n\n        while True:\n          c = self.ungetc()\n          if c == None:\n            return line\n          if c == '\\n':\n            line += c\n            c = self.ungetc()\n            if c == None:\n              return line\n            if c == '\\n':\n              self.getc()\n            return line\n          elif c == None:\n            return line\n          else:\n            line = c + line\n    else:\n      return None\n\ndef main():\n  if len(sys.argv) == 2:\n    print sys.argv[1]\n    b = BufRead(sys.argv[1])\n\n    sys.stdout.write(\n      '----------------------------------\\n' \\\n      '- TESTING GETC                    \\n' \\\n      '----------------------------------\\n')\n\n    while True:\n      c = b.getc()\n      if c == None: \n        sys.stdout.write('\\n')\n        break\n      else:\n        sys.stdout.write(c)\n\n    sys.stdout.write(\n      '----------------------------------\\n' \\\n      '- TESTING UNGETC                  \\n' \\\n      '----------------------------------\\n')\n\n    while True:\n      c = b.ungetc()\n      if c == None: \n        sys.stdout.write('\\n')\n        break\n      else:\n        sys.stdout.write(c)\n\n    sys.stdout.write(\n      '----------------------------------\\n' \\\n      '- TESTING GETLINE                 \\n' \\\n      '----------------------------------\\n')\n\n    b.seekstart()\n\n    while True:\n      line = b.getline()\n      if line == None:\n        sys.stdout.write('\\n')\n        break\n      else:\n        sys.stdout.write(line)\n\n    sys.stdout.write(\n      '----------------------------------\\n' \\\n      '- TESTING UNGETLINE               \\n' \\\n      '----------------------------------\\n')\n\n    b.seekend()\n\n    while True:\n      line = b.ungetline()\n      if line == None:\n        sys.stdout.write('\\n')\n        break\n      else:\n        sys.stdout.write(line)\n\n    b.close()\n\nif __name__==\"__main__\": main()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Write a class the reads and buffers input for you, and implement ungetc on it -- something like this perhaps (warning: untested, written while compiling):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class BufRead:\n    def __init__(self,filename):\n        self.filename = filename\n        self.fn = open(filename,'rb')\n        self.buffer = []\n        self.bufsize = 256\n        self.ready = True\n    def close(self):\n        if self.fn is not None:\n            self.fn.close()\n            self.fn = None\n        self.ready = False\n    def read(self,size=1):\n        l = len(self.buffer)\n        if not self.ready: return None\n        if l &lt;= size:\n            s = self.buffer[:size]\n            self.buffer = self.buffer[size:]\n            return s\n        s = self.buffer\n        size = size - l\n        self.buffer = self.fn.read(min(self.bufsize,size))\n        if self.buffer is None or len(self.buffer) == 0:\n            self.ready = False\n            return s\n        return s + self.read(size)\n    def ungetc(self,ch):\n        if self.buffer is None:\n            self.buffer = [ch]\n        else:   \n            self.buffer.append(ch)\n        self.ready = True\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I don't want to do billions of unbuffered single char file reads plus I wanted a way\nto debug the position of the file pointer.", "Hence, I resolved to return the file position\nin addition to a char or line and to use mmap to map the file to memory.", "(and let mmap\nhandle paging)  I think this will be a bit of a problem if the file is really, really big.", "(as in larger than the amount of physical memory)  That's when mmap would start going into\nthe virtual memory and things could get really slow.", "For now, it processes a 50 MB file   in about 4 min."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n import sys, os, string, re, time\nfrom mmap import mmap\n\nclass StreamReaderDb: \n  def __init__(self,stream):\n    self.__stream             = mmap(stream.fileno(), os.path.getsize(stream.name))  \n    self.__streamPosition     = self.__stream.tell()\n    self.__stream.seek(0                    , os.SEEK_END)\n    self.__streamSize         = self.__stream.tell() \n    self.__stream.seek(self.__streamPosition, os.SEEK_SET) \n\n  def setStreamPositionDb(self,streamPosition):\n    if self.__stream == None:\n      return None \n    self.__streamPosition = streamPosition\n    self.__stream.seek(self.__streamPosition, os.SEEK_SET)\n\n  def streamPositionDb(self):\n    if self.__stream == None:\n      return None \n    return self.__streamPosition\n\n  def streamSize(self):\n    if self.__stream == None:\n      return None \n    return self.__streamSize\n\n  def close(self): \n    if self.__stream is not None: \n      self.__stream.close() \n      self.__stream = None \n\n  def seekStart(self):\n    if self.__stream == None:\n      return None \n    self.setStreamPositionDb(0)\n\n  def seekEnd(self):\n    if self.__stream == None:\n      return None \n    self.__stream.seek(-1, os.SEEK_END)\n    self.setStreamPositionDb(self.__stream.tell())\n\n  def getcDb(self):\n    if self.__stream == None:\n      return None,None \n    self.setStreamPositionDb(self.__stream.tell())\n    if self.streamPositionDb() &lt; self.streamSize():\n      byte = self.__stream.read(1)\n      self.setStreamPositionDb(self.__stream.tell())\n      return byte,self.streamPositionDb()\n    else:\n      return None,self.streamPositionDb()\n\n  def unGetcDb(self):\n    if self.__stream == None:\n      return None,None \n    self.setStreamPositionDb(self.__stream.tell())\n    if self.streamPositionDb() &gt; 0:\n      self.setStreamPositionDb(self.streamPositionDb() - 1)\n      byte = self.__stream.read(1)\n      self.__stream.seek(self.streamPositionDb(), os.SEEK_SET)\n      return byte,self.streamPositionDb()\n    else:\n      return None,self.streamPositionDb()\n\n  def seekLineStartDb(self):\n    if self.__stream == None:\n      return None\n    self.setStreamPositionDb(self.__stream.tell())\n\n    if self.streamPositionDb() &lt; self.streamSize():\n      # Back up to the start of the line\n      while True:\n        if self.streamPositionDb() == 0:\n          return self.streamPositionDb() \n        else:\n          c,fp = self.unGetcDb()\n          if c == '\\n':\n            c,fp = self.getcDb()\n            return fp\n    else:\n      return None\n\n  def seekPrevLineEndDb(self):\n    if self.__stream == None:\n      return None\n    self.setStreamPositionDb(self.__stream.tell())\n\n    if self.streamPositionDb() &lt; self.streamSize():\n      # Back up to the start of the line\n      while True:\n        if self.streamPositionDb() == 0:\n          return self.streamPositionDb() \n        else:\n          c,fp = self.unGetcDb()\n          if c == '\\n':\n            return fp\n    else:\n      return None\n\n  def seekPrevLineStartDb(self):\n    if self.__stream == None:\n      return None\n    self.setStreamPositionDb(self.__stream.tell())\n\n    if self.streamPositionDb() &lt; self.streamSize():\n      # Back up to the start of the line\n      while True:\n        if self.streamPositionDb() == 0:\n          return self.streamPositionDb() \n        else:\n          c,fp = self.unGetcDb()\n          if c == '\\n':\n            return self.seekLineStartDb()\n    else:\n      return None\n\n  def seekLineEndDb(self):\n    if self.__stream == None:\n      return None \n    self.setStreamPositionDb(self.__stream.tell())\n\n    if self.streamPositionDb() &gt; 0:\n      while True:\n        if self.streamPositionDb() == self.streamSize():\n          return self.streamPositionDb()\n        else:\n          c,fp = self.getcDb()\n          if c == '\\n':\n            c,fp = self.unGetcDb()\n            return fp\n    else:\n      return None\n\n  def seekNextLineEndDb(self):\n    if self.__stream == None:\n      return None \n    self.setStreamPositionDb(self.__stream.tell())\n\n    if self.streamPositionDb() &gt; 0:\n      while True:\n        if self.streamPositionDb() == self.streamSize():\n          return self.streamPositionDb()\n        else:\n          c,fp = self.getcDb()\n          if c == '\\n':\n            return fp\n    else:\n      return None\n\n  def seekNextLineStartDb(self):\n    if self.__stream == None:\n      return None \n    self.setStreamPositionDb(self.__stream.tell())\n\n    if self.streamPositionDb() &gt; 0:\n      while True:\n        if self.streamPositionDb() == self.streamSize():\n          return self.streamPositionDb()\n        else:\n          c,fp = self.getcDb()\n          if c == '\\n':\n            return self.seekLineStartDb()\n    else:\n      return None\n\n  # uses getc() and ungetc()\n  def getLineDb(self):\n    if self.__stream == None:\n      return None,None \n    self.setStreamPositionDb(self.__stream.tell())\n\n    line = \"\"\n\n    if self.seekLineStartDb() != None:\n      c,fp = self.getcDb()\n      if c == '\\n':\n        return c,self.streamPositionDb()\n      else:\n        self.unGetcDb()\n\n      while True:\n        c,fp = self.getcDb()\n        if c == '\\n':\n          line += c\n          c,fp = self.getcDb()\n          if c == None:\n            return line,self.streamPositionDb()\n          self.unGetcDb()\n          return line,self.streamPositionDb()\n        elif c == None:\n          return line,self.streamPositionDb()\n        else:\n          line += c\n    else:\n      return None,self.streamPositionDb()\n\n  # uses getc() and ungetc()\n  def unGetLineDb(self):\n    if self.__stream == None:\n      return None,None \n    self.setStreamPositionDb(self.__stream.tell())\n\n    line = \"\"\n\n    if self.seekLineEndDb() != None:\n      c,fp = self.unGetcDb()\n      if c == '\\n':\n        return c,self.streamPositionDb()\n      else:\n        self.getcDb()\n\n      while True:\n        c,fp = self.unGetcDb()\n        if c == None:\n          return line,self.streamPositionDb()\n        if c == '\\n':\n          line += c\n          c,fp = self.unGetcDb()\n          if c == None:\n            return line,self.streamPositionDb()\n          self.getcDb()\n          return line,self.streamPositionDb()\n        elif c == None:\n          return line,self.streamPositionDb()\n        else:\n          line = c + line\n    else:\n      return None,self.streamPositionDb()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The question was initially prompted by my need to build a lexical analyzer.", "getc() and ungetc() are useful at first (to get the read bugs out the way and\nto build the state machine)  After the state machine is done,\ngetc() and ungetc() become a liability as they take too long to read\ndirectly from storage.  "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["When the state machine was complete (debugged any IO problems,\nfinalized the states), I optimized the lexical analyzer.  "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["Reading the source file in chunks (or pages) into memory and running\nthe state machine on each page yields the best time result."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["I found that considerable time is saved if getc() and ungetc() are not used\nto read from the file directly.  "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}]]