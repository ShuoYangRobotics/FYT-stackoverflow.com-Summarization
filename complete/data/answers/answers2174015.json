[[{"text": ["Regular expressions are not suitable for parsing \"nested\" structures.", "Try, instead, a full-fledged parsing kit such as pyparsing -- examples of using pyparsing specifically to parse SQL can be found here and here, for example (you'll no doubt need to take the examples just as a starting point, and write some parsing code of your own, but, it's definitely not too difficult)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "pyparsing", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}, {"href": "http://michelhollands.net/blog/2007/10/24/using-pyparsing/", "text": "here", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://michelhollands.net/blog/2007/11/02/using-pyparsing-2/", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Either a table-driven parser as Alex Martelli suggests or a hand-written recursive descent parser.", "They're not hard and quite rewarding to write."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; string = 'ltrim(rtrim(to_char(base_field_name, format))) renamed_field_name'\n&gt;&gt;&gt; rx = re.compile('^(.*?\\()*(.+?)(,.*?)*(,|\\).*?)*$')\n&gt;&gt;&gt; rx.search(string).group(2)\n'base_field_name'\n&gt;&gt;&gt; rx.search('base_field_name').group(2)\n'base_field_name'\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This may be good enough:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nprint re.match(r\".*\\(([^\\)]+)\\)\", \"ltrim(to_char(field_name, format)))\").group(1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You would need to do further processing.", "For example pick up the function name as well and pull the field name according to function signature."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n .*(\\w+)\\(([^\\)]+)\\)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here's a really hacky parser that does what you want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It works by calling 'eval' on the text to be parsed, mapping all identifiers to a function which returns its first argument (which I'm guessing is what you want given your example). "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class FakeFunction(object):\n    def __init__(self, name):\n        self.name = name\n    def __call__(self, *args):\n        return args[0]\n    def __str__(self):\n        return self.name\n\nclass FakeGlobals(dict):\n    def __getitem__(self, x):\n        return FakeFunction(x)\n\ndef ExtractBaseFieldName(x):\n    return eval(x, FakeGlobals())\n\nprint ExtractBaseFieldName('ltrim(rtrim(to_char(base_field_name, format)))')\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Do you really need regular expressions?", "To get the one you've got up there I'd use"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s[s.rfind('(')+1:s.find(')')].split(',')[0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["with 's' containing the original string."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Of course, it's not a general solution, but..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]