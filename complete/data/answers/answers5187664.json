[[{"text": ["As for arbitrary big numbers you could have a look at The GNU Multiple Precision Arithmetic Library (for C/C++)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "The GNU Multiple Precision Arithmetic Library", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://gmplib.org/"}]}], [{"text": ["EDIT: I like this version better than the previous.", "It's a general solution that accepts both integers and decimal fractions; with n = 2 and precision = 100000, it takes about two minutes.", "Thanks to Paul McGuire for his suggestions &amp; other suggestions welcome!"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def sqrt_list(n, precision):\n    ndigits = []        # break n into list of digits\n    n_int = int(n)\n    n_fraction = n - n_int\n\n    while n_int:                            # generate list of digits of integral part\n        ndigits.append(n_int % 10)\n        n_int /= 10\n    if len(ndigits) % 2: ndigits.append(0)  # ndigits will be processed in groups of 2\n\n    decimal_point_index = len(ndigits) / 2  # remember decimal point position\n    while n_fraction:                       # insert digits from fractional part\n        n_fraction *= 10\n        ndigits.insert(0, int(n_fraction))\n        n_fraction -= int(n_fraction)\n    if len(ndigits) % 2: ndigits.insert(0, 0)  # ndigits will be processed in groups of 2\n\n    rootlist = []\n    root = carry = 0                        # the algorithm\n    while root == 0 or (len(rootlist) &lt; precision and (ndigits or carry != 0)):\n        carry = carry * 100\n        if ndigits: carry += ndigits.pop() * 10 + ndigits.pop()\n        x = 9\n        while (20 * root + x) * x &gt; carry:\n                x -= 1\n        carry -= (20 * root + x) * x\n        root = root * 10 + x\n        rootlist.append(x)\n    return rootlist, decimal_point_index\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The nicest way is probably using the continued fraction expansion [1; 2, 2, ...] the square root of two."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "[1; 2, 2, ...]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def root_two_cf_expansion():\n    yield 1\n    while True:\n        yield 2\n\ndef z(a,b,c,d, contfrac):\n    for x in contfrac:\n        while a &gt; 0 and b &gt; 0 and c &gt; 0 and d &gt; 0:\n            t = a // c\n            t2 = b // d\n            if not t == t2:\n                break\n            yield t\n            a = (10 * (a - c*t))\n            b = (10 * (b - d*t))\n            # continue with same fraction, don't pull new x\n        a, b = x*a+b, a\n        c, d = x*c+d, c\n    for digit in rdigits(a, c):\n        yield digit\n\ndef rdigits(p, q):\n    while p &gt; 0:\n        if p &gt; q:\n           d = p // q\n           p = p - q * d\n        else:\n           d = (10 * p) // q\n           p = 10 * p - q * d\n        yield d\n\ndef decimal(contfrac):\n    return z(1,0,0,1,contfrac)\n</code>\n</pre>\n", "senID": 1}, {"text": ["decimal((root_two_cf_expansion()) returns an iterator of all the decimal digits.", "t1 and t2 in the algorithm are minimum and maximum values of the next digit.", "When they are equal, we output that digit."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "decimal((root_two_cf_expansion())", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "t1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "t2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Note that this does not handle certain exceptional cases such as negative numbers in the continued fraction."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["(This code is an adaptation of Haskell code for handling continued fractions that has been floating around."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["For work?", "Use a library!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For fun?", "Good for you :)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "For fun? Good for you :)", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Write a program to imitate what you would do with pencil and paper.", "Start with 1 digit, then 2 digits, then 3, ..., ..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Don't worry about Newton or anybody else.", "Just do it your way."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You could try using the mapping:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["a/b -&gt; (a+2b)/(a+b) starting with a= 1, b= 1.", "This converges to sqrt(2) (in fact gives the continued fraction representations of it)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "a/b -&gt; (a+2b)/(a+b)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a= 1, b= 1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Now the key point: This can be represented as a matrix multiplication (similar to fibonacci)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If a_n and b_n are the nth numbers in the steps then"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["[1 2] [a_n  b_n]T   =   [a_(n+1) b_(n+1)]T \n[1 1]  "], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "T", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}, {"text": "T", "childNum": 0, "tag": "sup", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["which now gives us"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["[1 2]n [a_1 b_1]T    =   [a_(n+1) b_(n+1)]T\n[1 1]            "], "childNum": 4, "tag": "p", "senID": 6, "childList": [{"text": "n", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}, {"text": "T", "childNum": 0, "tag": "sup", "childList": []}, {"text": "T", "childNum": 0, "tag": "sup", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["Thus if the 2x2 matrix is A, we need to compute An which can be done by repeated squaring and only uses integer arithmetic (so you don't have to worry about precision issues)."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "n", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}]}, {"text": ["Also note that the a/b you get will always be in reduced form (as gcd(a,b) = gcd(a+2b, a+b)), so if you are thinking of using a fraction class to represent the intermediate results, don't!"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Since the nth denominators is like (1+sqrt(2))^n, to get 3 million digits you would likely need to compute till the 3671656th term."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "th", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}]}, {"text": ["Note, even though you are looking for the ~3.6 millionth term, repeated squaring will allow you to compute the nth term in O(Log n) multiplications and additions."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Also, this can easily be made parallel, unlike the iterative ones like Newton-Raphson etc."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["Well, the following is the code that I wrote.", "It generated a million digits after the decimal for the square root of 2 in about 60800 seconds for me, but my laptop was sleeping when it was running the program, it should be faster that.", "You can try to generate 3 million digits, but it might take a couple days to get it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def sqrt(number,digits_after_decimal=20):\nimport time\nstart=time.time()\noriginal_number=number\nnumber=str(number)\nlist=[]\nfor a in range(len(number)):\n    if number[a]=='.':\n        decimal_point_locaiton=a\n        break\n    if a==len(number)-1:\n        number+='.'\n        decimal_point_locaiton=a+1\nif decimal_point_locaiton/2!=round(decimal_point_locaiton/2):\n    number='0'+number\n    decimal_point_locaiton+=1\nif len(number)/2!=round(len(number)/2):\n    number+='0'\nnumber=number[:decimal_point_locaiton]+number[decimal_point_locaiton+1:]\ndecimal_point_ans=int((decimal_point_locaiton-2)/2)+1\nfor a in range(0,len(number),2):\n    if number[a]!='0':\n        list.append(eval(number[a:a+2]))\n    else:\n        try:\n            list.append(eval(number[a+1]))\n        except IndexError:\n            pass\np=0\nc=list[0]\nx=0\nans=''\nfor a in range(len(list)):\n    while c&gt;=(20*p+x)*(x):\n        x+=1\n    y=(20*p+x-1)*(x-1)\n    p=p*10+x-1\n    ans+=str(x-1)\n    c-=y\n    try:\n        c=c*100+list[a+1]\n    except IndexError:\n        c=c*100\nwhile c!=0:\n    x=0\n    while c&gt;=(20*p+x)*(x):\n        x+=1\n    y=(20*p+x-1)*(x-1)\n    p=p*10+x-1\n    ans+=str(x-1)\n    c-=y\n    c=c*100\n    if len(ans)-decimal_point_ans&gt;=digits_after_decimal:\n            break\nans=ans[:decimal_point_ans]+'.'+ans[decimal_point_ans:]\ntotal=time.time()-start\nreturn ans,total\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Python already supports big integers out of the box, and if that's the only thing holding you back in C/C++ you can always write a quick container class yourself."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The only problem you've mentioned is a lack of big integers.", "If you don't want to use a library for that, then are you looking for help writing such a class?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Here is a short version for calculating the square root of an integer a to digits of precision.", "It works by finding the integer square root of a after multiplying by 10 raised to the 2 x digits."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "a", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "digits", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "a", "childNum": 0, "tag": "strong", "childList": []}, {"text": "digits", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n def sqroot(a, digits):\n    a = a * (10**(2*digits))\n    x_prev = 0\n    x_next = 1 * (10**digits)\n    while x_prev != x_next:\n        x_prev = x_next\n        x_next = (x_prev + (a // x_prev)) &gt;&gt; 1\n    return x_next\n</code>\n</pre>\n", "senID": 1}, {"text": ["Just a few caveats."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You'll need to convert the result to a string and add the decimal point at the correct location (if you want the decimal point printed)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Converting a very large integer to a string isn't very fast."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Dividing very large integers isn't very fast (in Python) either."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Depending on the performance of your system, it may take an hour or longer to calculate the square root of 2 to 3 million decimal places."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I haven't proven the loop will always terminate.", "It may oscillate between two values differing in the last digit.", "Or it may not. "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Here's a more efficient integer square root function (in Python 3.x) that should terminate in all cases.", "It starts with a number much closer to the square root, so it takes fewer steps.", "Note that int.bit_length requires Python 3.1+.", "Error checking left out for brevity."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def isqrt(n):\n    x = (n &gt;&gt; n.bit_length() // 2) + 1\n    result = (x + n // x) // 2\n    while abs(result - x) &gt; 1:\n        x = result\n        result = (x + n // x) // 2\n    while result * result &gt; n:\n        result -= 1\n    return result\n</code>\n</pre>\n", "senID": 1}]]