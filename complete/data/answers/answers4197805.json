[[{"text": ["you can get any iterable to prefetch next item with this recipe:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import tee, islice, izip_longest\ndef get_next(some_iterable, window=1):\n    items, nexts = tee(some_iterable, 2)\n    nexts = islice(nexts, window, None)\n    return izip_longest(items, nexts)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for line, next_line in get_next(myfile):\n    if next_line and next_line.startswith(\"0\"):\n        ... do stuff\n</code>\n</pre>\n", "senID": 3}, {"text": ["The code allows you to pass the window parameter as a larger value, if you want to look 2 or more lines ahead."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "window", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can have a prev_line where you store previous line and process that whenever you read a line only given your condition."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "prev_line", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n prev_line = None\nfor line in file:\n    if prev_line is not None and the start of the next line == \"0\":\n        perform pre-processing on prev_line\n        ...\n    continue with normal processing\n    ...\n    prev_line = line\n</code>\n</pre>\n", "senID": 2}, {"text": ["You may need to do additional processing for the last line if necessary, depending on your logic."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Along the lines of nosklo's answer, I tend to use the following pattern:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The function pairwise from the excellent itertools recipes is ideal for this:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "pairwise", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/itertools.html#recipes", "text": "itertools recipes", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import tee\n\ndef pairwise(iterable):\n    \"s -&gt; (s0,s1), (s1,s2), (s2, s3), ...\"\n    a, b = tee(iterable)\n    next(b, None)\n    return izip(a, b)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Using it in your code gets us:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for line, next_line in pairwise(file):\n    if next_line.startswith(\"0\"):\n        pass #perform pre-processing\n        #...\n    pass #continue with normal processing\n</code>\n</pre>\n", "senID": 4}, {"text": ["Generally, for this type of processing (lookahead in the iterable), I tend to use a window function.", "Pairwise is a special case of a window of size 2."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "window function", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-dev/2006-May/065304.html"}]}], [{"text": ["You simply need to buffer one line."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for line in file:\n  if (prevLine is not None):\n    //test line as look ahead and then act on prevLine\n  prevLine = line\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This should work too.", "I always prefer calling next over setting something = None for the first round."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "next", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "something = None", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n prev_line = next(the_file)\nfor current_line in the_file:\n    if current_line.startswith('0'):\n        do_stuff( prev_line )\n    # continue with normal processing\n    # ...\n    prev_line = current_line\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm not a Python expert but I'd imagine you'd need to use 2 loops for this.", "The first run through of the for loop should build a list of indexes for which you'll need to perform a special operation.", "Then on the second run through you can compare the current index with your list to determine if you need to perform that special operation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]