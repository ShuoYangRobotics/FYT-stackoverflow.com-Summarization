[[{"text": ["The answer from @Taymon using list.index was great."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "list.index", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["FWIW, here's a functional approach using the itertools module.", "It works with any iterable input, not just lists:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "itertools module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#module-itertools"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import compress, count, imap, islice\n&gt;&gt;&gt; from functools import partial\n&gt;&gt;&gt; from operator import eq\n\n&gt;&gt;&gt; def nth_item(n, item, iterable):\n        indicies = compress(count(), imap(partial(eq, item), iterable))\n        return next(islice(indicies, n, None), -1)\n</code>\n</pre>\n", "senID": 2}, {"text": ["The example is nice because it shows off how to effectively combine Python's functional toolset.", "Note, that once the pipeline is set-up, there are no trips around Python's eval loop -- everything gets done at C speed, with a tiny memory footprint, with lazy evaluation, with no variable assignments, and with separately testable components.", "IOW, it is everything functional programmers dream about :-)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Sample run:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = [False,True,True,False,True,False,True,False,False,False,True,False,True]\n&gt;&gt;&gt; nth_item(50, True, x)\n-1\n&gt;&gt;&gt; nth_item(0, True, x)\n1\n&gt;&gt;&gt; nth_item(1, True, x)\n2\n&gt;&gt;&gt; nth_item(2, True, x)\n4\n&gt;&gt;&gt; nth_item(3, True, x)\n6\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I can't say for certain that this is the fastest way, but I imagine it'd be pretty good:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n i = -1\nfor j in xrange(n):\n    i = x.index(True, i + 1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The answer is i."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "i", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["if efficiency is a concern i think its better to iterate the normally ( O(N) ) instead of list comprehension which takes O(L) where L is length of list"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Example : Consider a very huge list and you want to find the first occurence N=1 it is obviously better to stop as soon as you find the first occurence"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n count = 0\n\nfor index,i in enumerate(L):\n\n    if i:\n\n     count = count + 1\n\n     if count==N:\n       return index\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n [y for y in enumerate(x) if y[1]==True][z][0]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Note: Here Z is the n'th occurance,"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["A solution that first creates a list object and returns the nth-1 element of this list : function occurence()"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "occurence()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["And a solution that fulfill functional programmers'dreams too, I think, using generators, because I love them : function occur() "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "occur()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n S = 'stackoverflow.com is a fantastic amazing site'\nprint 'object S is string %r' % S\nprint \"indexes of 'a' in S :\",[indx for indx,elem in enumerate(S) if elem=='a']\n\ndef occurence(itrbl,x,nth):\n    return [indx for indx,elem in enumerate(itrbl)\n            if elem==x ][nth-1] if x in itrbl \\\n           else None\n\ndef occur(itrbl,x,nth):\n    return (i for pos,i in enumerate(indx for indx,elem in enumerate(itrbl)\n                                     if elem==x)\n            if pos==nth-1).next() if x in itrbl\\\n            else   None\n\nprint \"\\noccurence(S,'a',4th) ==\",occurence(S,'a',4)\nprint \"\\noccur(S,'a',4th) ==\",occur(S,'a',4)\n</code>\n</pre>\n", "senID": 2}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n object S is string 'stackoverflow.com is a fantastic amazing site'\nindexes of 'a' in S : [2, 21, 24, 27, 33, 35]\n\noccur(S,'a',4th) == 27\n\noccurence(S,'a',4th) == 27\n</code>\n</pre>\n", "senID": 4}, {"text": ["The second solution seems complex but it isn't really.", "It doesn't need to run completely through the iterable: the process stops as soon as the wanted occurence is found."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Here is another way to find the nth occurrence of x in a list itrbl:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "nth", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}, {"text": "itrbl", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def nthoccur(nth,x,itrbl):\n    count,index = 0,0\n    while count &lt; nth:\n        if index &gt; len(itrbl) - 1:\n            return None\n        elif itrbl[index] == x:\n            count += 1\n            index += 1\n        else:\n            index += 1\n    return index - 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you're concerned with performance, you are best off seeing if there are algorithmic optimizations you can make.", "For example, if you are calling this function many times on the same values, you may wish to cache previous computations (e.g.", "once you find the 50th occurrence of an element, you can find any previous occurrence in O(1) time)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "O(1)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Otherwise, you want to make sure your technique works on (lazy) iterators."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The most *in*elegant and performance-happy way I can think of implementing it is as:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "in", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def indexOfNthOccurrence(N, element, stream):\n    \"\"\"for N&gt;0, returns index or None\"\"\"\n    seen = 0\n    for i,x in enumerate(stream):\n        if x==element:\n            seen += 1\n            if seen==N:\n                return i\n</code>\n</pre>\n", "senID": 3}, {"text": ["(if you really care about the performance difference between enumerate and other techniques, you will need to resort to profiling, especially with the numpy functions, which may resort to C)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["To preprocess the entire stream and support O(1) queries:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "O(1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from collections import *\ncache = defaultdict(list)\nfor i,elem in enumerate(YOUR_LIST):\n    cache[elem] += [i]\n\n# e.g. [3,2,3,2,5,5,1]\n#       0 1 2 3 4 5 6\n# cache: {3:[0,2], 1:[6], 2:[1,3], 5:[4,5]}\n</code>\n</pre>\n", "senID": 6}]]