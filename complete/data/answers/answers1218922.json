[[{"text": ["The heapq module in the standard library offers the nlargest() function to do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n top100 = heapq.nlargest(100, iterable [,key])\n</code>\n</pre>\n", "senID": 1}, {"text": ["It won't sort the entire list, so you won't waste time on the elements you don't need."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Selection algorithms should help here. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Selection algorithms", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Selection%5Falgorithm"}]}, {"text": ["A very easy solution is to find the 100th biggest element, then run through the list picking off elements that are bigger than this element.", "That will give you the 100 biggest elements.", "This is linear in the length of the list; this is best possible."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There are more sophisticated algorithms.", "A heap, for example, is very amenable to this problem.", "The heap based algorithm is n log k where n is the length of the list and k is the number of largest elements that you want to select."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "heap", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://tinyurl.com/6qo3yu"}, {"text": "n log k", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}, {"text": "k", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["There's a discussion of this problem on the Wikipedia page for selection algorithms."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "problem", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Selection%5Falgorithm#Selecting%5Fk%5Fsmallest%5For%5Flargest%5Felements"}]}, {"text": ["Edit: Another poster has pointed out that Python has a built in solution to this problem.", "Obviously that is far easier than rolling your own, but I'll keep this post up in case you would like to learn about how such algorithms work."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You can use a Heap data structure.", "A heap will not necessarily be ordered, but it is a fairly fast way to keep semi-ordered data, and it has the benefit of the smallest item always being the first element in the heap."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A heap has two basic operations that will help you: Add and Replace."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Basically what you do is add items to it until you get to a 100 items (your top N number per your question).", "Then after that, you replace the first item with every new item, as long as the new item is bigger than the first item."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Whenever you replace the first item with something bigger, the internal code in the heap will adjust the heap contents so that if the new item is not the smallest, it will bubble up into the heap, and the smallest item will \"bubble down\" to the first element, ready to be replaced along the way."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The best way to do this is to maintain a heap sorted priority queue that you pop off of once it has 100 entries in it. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["While you don't care if the results are sorted it is intuitively obvious you will get this for free.", "In order to know you have the top 100, you need to order your current list of top numbers in order via some efficient data structure.", "That structure will know the minimum, the maximum, and the relative position of each element in some natural way that you can assert it's position next to it's neighbors. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As has been mentioned in python you would use heapq.", "In java PriorityQueue:\nhttp://java.sun.com/javase/6/docs/api/java/util/PriorityQueue.html "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://java.sun.com/javase/6/docs/api/java/util/PriorityQueue.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://java.sun.com/javase/6/docs/api/java/util/PriorityQueue.html"}]}], [{"text": ["Here is a solution I have used that is independent of libraries and that\nwill work in any programming language that has arrays:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Initialisation:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n Make an array of 100 elements and initialise all elements\nwith a low value (less than any value in your input list).\n\nInitialise an integer variable to 0 (or any value in\n[0;99]), say index_minvalue, that will point to the\ncurrent lowest value in the array.\n\nInitialise a variable, say minvalue, to hold the current \nlowest value in the array.\n</code>\n</pre>\n", "senID": 2}, {"text": ["For each value, say current_value, in the input list:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n if current_value &gt; minvalue\n\n  Replace value in array pointed to by index_minvalue\n  with current_value\n\n  Find new lowest value in the array and set index_minvalue to\n  its array index. (linear search for this will be OK as the array\n  is quickly filled up with large values)\n\n  Set minvalue to current_value\n\nelse\n  &lt;don't do anything!&gt;\n</code>\n</pre>\n", "senID": 4}, {"text": ["minvalue will quickly get a high value and thus most values\nin the input list will only need to be compared to minvalue\n(the result of the comparison will mostly be false)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["For the algorithms weenies in the audience: you can do this with a simple variation on Tony Hoare's algorithm Find:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Find", "tag": "a", "pos": 0, "childList": [{"text": "Find", "tag": "em"}], "childNum": 1, "href": "http://portal.acm.org/citation.cfm?id=362489"}, {"text": "Find", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n find(topn, a, i, j)\n   pick a random element x from a[i..j]\n   partition the subarray a[i..j] (just as in Quicksort) \n     into subarrays of elements &lt;x, ==x, &gt;x\n   let k be the position of element x\n   if k == 0 you're finished\n   if k &gt; topn, call find(topn, a, i, k)\n   if k &lt; topn, call find(topn-k, k, j)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This algorithm puts the largest topn elements into the first topn elements of array a, without sorting them.", "Of course, if you want them sorted, or for sheer simplicity, a heap is better, and calling the library function is better still.", "But it's a cool algorithm."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "topn", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "topn", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "without", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}]]