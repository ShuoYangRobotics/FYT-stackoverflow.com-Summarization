[[{"text": ["This'll get you a dict minus attributes... dunno if this is useful to anyone.", "I was looking for an xml to dict solution myself when i came up with this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import xml.etree.ElementTree as etree\n\ntree = etree.parse('test.xml')\nroot = tree.getroot()\n\ndef xml_to_dict(el):\n  d={}\n  if el.text:\n    d[el.tag] = el.text\n  else:\n    d[el.tag] = {}\n  children = el.getchildren()\n  if children:\n    d[el.tag] = map(xml_to_dict, children)\n  return d\n</code>\n</pre>\n", "senID": 1}, {"text": ["This: http://www.w3schools.com/XML/note.xml"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.w3schools.com/XML/note.xml", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.w3schools.com/XML/note.xml"}]}, {"text": ["Would equal this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n {'note': [{'to': 'Tove'},\n          {'from': 'Jani'},\n          {'heading': 'Reminder'},\n          {'body': \"Don't forget me this weekend!\"}]}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I'm not sure if converting the info set to nested dicts first is easier.", "Using ElementTree, you can do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import xml.etree.ElementTree as ET\ndoc = ET.parse(\"template.xml\")\nlvl1 = doc.findall(\"level1-name\")[0]\nlvl1.remove(lvl1.find(\"leaf1\")\nlvl1.remove(lvl1.find(\"leaf2\")\n# or use del lvl1[idx]\ndoc.write(\"config-new.xml\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["ElementTree was designed so that you don't have to convert your XML trees to lists and attributes first, since it uses exactly that internally."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It also support as small subset of XPath."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "XPath", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/element-xpath.htm"}]}], [{"text": ["For easy manipulation of XML in python, I like the Beautiful Soup library.", "It works something like this:\nSample XML File:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Beautiful Soup", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &lt;root&gt;\n  &lt;level1&gt;leaf1&lt;/level1&gt;\n  &lt;level2&gt;leaf2&lt;/level2&gt;\n&lt;/root&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Python code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from BeautifulSoup import BeatifulStoneSoup, Tag, NavigableString\n\nsoup = BeautifulStoneSoup('config-template.xml') # get the parser for the xml file\nsoup.contents[0].name\n# u'root'\n</code>\n</pre>\n", "senID": 3}, {"text": ["You can use the node names as methods:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n soup.root.contents[0].name\n# u'level1'\n</code>\n</pre>\n", "senID": 5}, {"text": ["It is also possible to use regexes:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import re\ntags_starting_with_level = soup.findAll(re.compile('^level'))\nfor tag in tags_starting_with_level: print tag.name\n# level1\n# level2\n</code>\n</pre>\n", "senID": 7}, {"text": ["Adding and inserting new nodes is pretty straightforward:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n # build and insert a new level with a new leaf\nlevel3 = Tag(soup, 'level3')\nlevel3.insert(0, NavigableString('leaf3')\nsoup.root.insert(2, level3)\n\nprint soup.prettify()\n# &lt;root&gt;\n#  &lt;level1&gt;\n#   leaf1\n#  &lt;/level1&gt;\n#  &lt;level2&gt;\n#   leaf2\n#  &lt;/level2&gt;\n#  &lt;level3&gt;\n#   leaf3\n#  &lt;/level3&gt;\n# &lt;/root&gt;\n</code>\n</pre>\n", "senID": 9}], [{"text": ["My modification of Daniel's answer, to give a marginally neater dictionary:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def xml_to_dictionary(element):\n    l = len(namespace)\n    dictionary={}\n    tag = element.tag[l:]\n    if element.text:\n        if (element.text == ' '):\n            dictionary[tag] = {}\n        else:\n            dictionary[tag] = element.text\n    children = element.getchildren()\n    if children:\n        subdictionary = {}\n        for child in children:\n            for k,v in xml_to_dictionary(child).items():\n                if k in subdictionary:\n                    if ( isinstance(subdictionary[k], list)):\n                        subdictionary[k].append(v)\n                    else:\n                        subdictionary[k] = [subdictionary[k], v]\n                else:\n                    subdictionary[k] = v\n        if (dictionary[tag] == {}):\n            dictionary[tag] = subdictionary\n        else:\n            dictionary[tag] = [dictionary[tag], subdictionary]\n    if element.attrib:\n        attribs = {}\n        for k,v in element.attrib.items():\n            attribs[k] = v\n        if (dictionary[tag] == {}):\n            dictionary[tag] = attribs\n        else:\n            dictionary[tag] = [dictionary[tag], attribs]\n    return dictionary\n</code>\n</pre>\n", "senID": 1}, {"text": ["namespace is the xmlns string, including braces, that ElementTree prepends to all tags, so here I've cleared it as there is one namespace for the entire document"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["NB that I adjusted the raw xml too, so that 'empty' tags would produce at most a ' ' text property in the ElementTree representation"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n spacepattern = re.compile(r'\\s+')\nmydictionary = xml_to_dictionary(ElementTree.XML(spacepattern.sub(' ', content)))\n</code>\n</pre>\n", "senID": 4}, {"text": ["would give for instance"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n {'note': {'to': 'Tove',\n         'from': 'Jani',\n         'heading': 'Reminder',\n         'body': \"Don't forget me this weekend!\"}}\n</code>\n</pre>\n", "senID": 6}, {"text": ["it's designed for specific xml that is basically equivalent to json, should handle element attributes such as"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &lt;elementName attributeName='attributeContent'&gt;elementContent&lt;/elementName&gt;\n</code>\n</pre>\n", "senID": 8}, {"text": ["too"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["there's the possibility of merging the attribute dictionary / subtag dictionary similarly to how repeat subtags are merged, although nesting the lists seems kind of appropriate :-)"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["Have you tried this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n print xml.etree.ElementTree.tostring( conf_new )\n</code>\n</pre>\n", "senID": 1}], [{"text": ["most direct way to me :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n root        = ET.parse(xh)\ndata        = root.getroot()\nxdic        = {}\nif data &gt; None:\n    for part in data.getchildren():\n        xdic[part.tag] = part.text\n</code>\n</pre>\n", "senID": 1}]]