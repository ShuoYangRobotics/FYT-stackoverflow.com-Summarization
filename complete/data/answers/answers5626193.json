[[{"text": ["No, it's not like any of those things.", "It's simply the dynamic replacement of attributes at runtime."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For instance, consider a class that has a method get_data.", "This method does an external lookup (on a database or web API, for example), and various other methods in the class call it.", "However, in a unit test, you don't want to depend on the external data source - so you dynamically replace the get_data method with a stub that returns some fixed data."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "get_data", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "get_data", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Because Python classes are mutable, and methods are just attributes of the class, you can do this as much as you like - and, in fact, you can even replace classes and functions in a module in exactly the same way."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Jeff Atwood wrote an article about that."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "an article", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.codinghorror.com/blog/2008/07/monkeypatching-for-humans.html"}]}], [{"text": ["First: monkey patching is an evil hack (in my opinion)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It is often used to replace a method on the module or class level with a custom implementation."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The most common usecase is adding a workaround for a bug in a module or class when you can't replace the original code.", "In this case you replace the \"wrong\" code through monkey patching with an implementation inside your own module/package."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A simple example looks like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from SomeOtherProduct.SomeModule import SomeClass\n\ndef speak(self):\n    return \"ook ook eee eee eee!\"\n\nSomeClass.speak = speak\n</code>\n</pre>\n", "senID": 1}, {"text": ["Source: MonkeyPatch page on Zope wiki."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Source:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://wiki.zope.org/zope2/MonkeyPatch", "text": "MonkeyPatch", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["According to Wikipedia:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Wikipedia", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Monkey_patch"}]}], [{"text": ["Monkey patching can only be done in dynamic languages, of which python is a good example.", "Changing a method at runtime instead of updating the object definition is one example;similarly, adding attributes (whether methods or variables) at runtime is considered monkey patching.", "These are often done when working with modules you don't have the source for, such that the object definitions can't be easily changed."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is considered bad because it means that an object's definition does not completely or accurately describe how it actually behaves."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]