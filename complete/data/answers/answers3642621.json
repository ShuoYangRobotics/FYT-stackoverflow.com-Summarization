[[{"text": ["You can use the else clause of the for loop:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "else", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/compound_stmts.html#for"}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n for reg in regexes:\n    m = reg.match(name)\n    if m: break\nelse:\n    print 'ARGL NOTHING MATCHES THIS!!!'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you just want to know if any of the regex match then you could use the builtin any function:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "any", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if any(reg.match(name) for reg in regexes):\n     ....\n</code>\n</pre>\n", "senID": 1}, {"text": ["however this will not tell you which regex matched."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Alternatively you can combine multiple patterns into a single regex with |:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "|", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n regex = re.compile(r\"(regex1)|(regex2)|...\")\n</code>\n</pre>\n", "senID": 4}, {"text": ["Again this will not tell you which regex matched, but you will have a match object that you can use for further information.", "For example you can find out which of the regex succeeded from the group that is not None:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; match = re.match(\"(a)|(b)|(c)|(d)\", \"c\")\n&gt;&gt;&gt; match.groups()\n(None, None, 'c', None)\n</code>\n</pre>\n", "senID": 6}, {"text": ["However this can get complicated however if any of the sub-regex have groups in them as well, since the numbering will be changed."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["This is probably faster than matching each regex individually since the regex engine has more scope for optimising the regex."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Since you have a finite set in this case, you could use short ciruit evaluation:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "short ciruit evaluation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Short-circuit_evaluation"}]}, {"code": "<pre>\n<code>\n m = compiled_regex_1.match(name) or\n    compiled_regex_2.match(name) or\n    compiled_regex_3.match(name) or\n    print(\"ARGHHHH!\")\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In Python 2.6 or better:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools as it\n\nm = next(it.ifilter(None, (r.match(name) for r in regexes)), None)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The ifilter call could be made into a genexp, but only a bit awkwardly, i.e., with the usual trick for name binding in a genexp (aka the \"phantom nested for clause idiom\"):"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "ifilter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n m = next((m for r in regexes for m in (r.match(name),) if m), None)\n</code>\n</pre>\n", "senID": 3}, {"text": ["but itertools is generally preferable where applicable."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The bit needing 2.6 is the next built-in, which lets you specify a default value if the iterator is exhausted.", "If you have to simulate it in 2.5 or earlier,"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "2.6", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "next", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def next(itr, deft):\n  try: return itr.next()\n  except StopIteration: return deft\n</code>\n</pre>\n", "senID": 6}], [{"text": ["I use something like Dave Kirby suggested, but add named groups to the regexps, so that I know which one matched."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n regexps = {\n  'first': r'...',\n  'second': r'...',\n}\n\ncompiled = re.compile('|'.join('(?P&lt;%s&gt;%s)' % item for item in regexps.iteritems()))\nmatch = compiled.match(my_string)\nprint match.lastgroup\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Eric is in better track in taking bigger picture of what OP is aiming, I would use if else though.", "I would also think that using print function in or expression is little questionable.", "+1 for Nathon of correcting OP to use proper else statement."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "or", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Then my alternative:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # alternative to any builtin that returns useful result,\n# the first considered True value\ndef first(seq):\n    for item in seq:\n        if item: return item\n\nregexes = [\n    compiled_regex_1,\n    compiled_regex_2,\n    compiled_regex_3,\n]\n\nm = first(reg.match(name) for reg in regexes)\nprint(m if m else 'ARGL NOTHING MATCHES THIS!!!')\n</code>\n</pre>\n", "senID": 2}]]