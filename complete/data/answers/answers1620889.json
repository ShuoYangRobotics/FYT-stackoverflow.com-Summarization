[[{"text": ["I don't know Python, but here's a quick example thrown together using Beautiful Soup, which I often see recommended for Python HTML parsing."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Beautiful Soup", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/"}]}, {"code": "<pre>\n<code>\n import BeautifulSoup\n\nsoup = BeautifulSoup(fileString)\n\nbodyTag = soup.html.body.string\n</code>\n</pre>\n", "senID": 1}, {"text": ["That will (in theory) deal with all the complexities of HTML, which is very difficult with pure regex-based answers, because it's not what regex was designed for."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here is some example code which uses regex to find all the text between &lt;body&gt;...&lt;/body&gt; tags.", "Although this demonstrates some features of python's re module, note that the Beautiful Soup module is very easy to use and is a better tool to use if you plan on parsing HTML or XML.", "(See below for an example of how you could parse this using BeautifulSoup."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "&lt;body&gt;...&lt;/body&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Beautiful Soup", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/documentation.html"}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nimport re\n\n# Here we have a string with a multiline &lt;body&gt;...&lt;/body&gt;\nfileString='''baz&lt;body&gt;foo\nbaby foo\nbaby foo\nbaby foo\n&lt;/body&gt;&lt;body&gt;bar&lt;/body&gt;'''\n\n# re.DOTALL tells re that '.' should match any character, including newlines.\nx = re.search('(&lt;body&gt;.*?&lt;/body&gt;)', fileString, re.DOTALL)\nfor match in x.groups():\n    print(match)\n# &lt;body&gt;foo\n# baby foo\n# baby foo\n# baby foo\n# &lt;/body&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you wish to collect all matches, you could use re.findall:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n print(re.findall('(&lt;body&gt;.*?&lt;/body&gt;)', fileString, re.DOTALL))\n# ['&lt;body&gt;foo\\nbaby foo\\nbaby foo\\nbaby foo\\n&lt;/body&gt;', '&lt;body&gt;bar&lt;/body&gt;']\n</code>\n</pre>\n", "senID": 3}, {"text": ["and if you plan to use this pattern more than once, you can pre-compile it:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n pat=re.compile('(&lt;body&gt;.*?&lt;/body&gt;)', re.DOTALL)\nprint(pat.findall(fileString))\n# ['&lt;body&gt;foo\\nbaby foo\\nbaby foo\\nbaby foo\\n&lt;/body&gt;', '&lt;body&gt;bar&lt;/body&gt;']\n</code>\n</pre>\n", "senID": 5}, {"text": ["And here is how you could do it with BeautifulSoup:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nfrom BeautifulSoup import BeautifulSoup\n\nfileString='''baz&lt;body&gt;foo\nbaby foo\nbaby foo\nbaby foo\n&lt;/body&gt;&lt;body&gt;bar&lt;/body&gt;'''\nsoup = BeautifulSoup(fileString)\nprint(soup.body)\n# &lt;body&gt;foo\n# baby foo\n# baby foo\n# baby foo\n# &lt;/body&gt;\n\nprint(soup.findAll('body'))\n# [&lt;body&gt;foo\n# baby foo\n# baby foo\n# baby foo\n# &lt;/body&gt;, &lt;body&gt;bar&lt;/body&gt;]\n</code>\n</pre>\n", "senID": 7}], [{"text": ["You cannot parse HTML with regex.", "HTML is not a regular language.", "Use an HTML parser like lxml instead."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n x = re.match('.*(&lt;body&gt;.*?&lt;/body&gt;)', fileString)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Consider minidom for HTML parsing."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n x = re.search('(&lt;body&gt;.*&lt;/body&gt;)', fileString)\nx.group(1)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Less typing than the match answers"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Does your fileString contain multiple lines?", "In that case you may need to specify it or skip the lines explicitly:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "multiple lines", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n x = re.match(r\"(?:.|\\n)*(&lt;body&gt;(?:.|\\n)*&lt;/body&gt;)\", fileString)\n</code>\n</pre>\n", "senID": 1}, {"text": ["or, more simply with the re module:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n x = re.match(r\".*(&lt;body&gt;.*&lt;/body&gt;)\", fileString, re.DOTALL)\n</code>\n</pre>\n", "senID": 3}, {"text": ["x.groups()[0] should contain your string if x is not None."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "x.groups()[0]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]