[[{"text": ["I don't think there's going to be a nice, elegant solution to this (I'd love to be proven wrong of course) so I would suggest something straightforward:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def nSplit(lst, delim, count=2):\n    output = [[]]\n    delimCount = 0\n    for item in lst:\n        if item == delim:\n            delimCount += 1\n        elif delimCount &gt;= count:\n            output.append([item])\n            delimCount = 0\n        else:\n            output[-1].append(item)\n            delimCount = 0\n    return output\n</code>\n</pre>\n", "senID": 1}, {"text": ["&nbsp;"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; nSplit(['a', 'b', 'X', 'X', 'c', 'd', 'X', 'X', 'f', 'X', 'g'], 'X', 2)\n[['a', 'b'], ['c', 'd'], ['f', 'g']]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here's a way to do it with itertools.groupby():"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.groupby()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\n\nclass MultiDelimiterKeyCallable(object):\n    def __init__(self, delimiter, num_wanted=1):\n        self.delimiter = delimiter\n        self.num_wanted = num_wanted\n\n        self.num_found = 0\n\n    def __call__(self, value):\n        if value == self.delimiter:\n            self.num_found += 1\n            if self.num_found &gt;= self.num_wanted:\n                self.num_found = 0\n                return True\n        else:\n            self.num_found = 0\n\ndef split_multi_delimiter(items, delimiter, num_wanted):\n    keyfunc = MultiDelimiterKeyCallable(delimiter, num_wanted)\n\n    return (list(item\n                 for item in group\n                 if item != delimiter)\n            for key, group in itertools.groupby(items, keyfunc)\n            if not key)\n\nitems = ['a', 'b', 'X', 'X', 'c', 'd', 'X', 'X', 'f', 'X', 'g']\n\nprint list(split_multi_delimiter(items, \"X\", 2))\n</code>\n</pre>\n", "senID": 1}, {"text": ["I must say that cobbal's solution is much simpler for the same results."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n a = ['a', 'b', 'X', 'X', 'c', 'd', 'X', 'X', 'f', 'X', 'g']\nb = [[b for b in q if b != 'X'] for q in \"\".join(a).split(\"\".join(['X' for i in range(2)]))]\n</code>\n</pre>\n", "senID": 0}, {"text": ["this gives"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["[['a', 'b'], ['c', 'd'], ['f', 'g']]"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[['a', 'b'], ['c', 'd'], ['f', 'g']]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["where the 2 is the number of elements you want.", "there is most likely a better way to do this."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Use a generator function to maintain state of your iterator through the list, and the count of the number of separator chars seen so far:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = ['a', 'b', 'X', 'X', 'c', 'd', 'X', 'X', 'f', 'X', 'g'] \n\ndef splitOn(ll, x, n):\n    cur = []\n    splitcount = 0\n    for c in ll:\n        if c == x:\n            splitcount += 1\n            if splitcount == n:\n                yield cur\n                cur = []\n                splitcount = 0\n        else:\n            cur.append(c)\n            splitcount = 0\n    yield cur\n\nprint list(splitOn(l, 'X', 2))\nprint list(splitOn(l, 'X', 1))\nprint list(splitOn(l, 'X', 3))\n\nl += ['X','X']\nprint list(splitOn(l, 'X', 2))\nprint list(splitOn(l, 'X', 1))\nprint list(splitOn(l, 'X', 3))\n</code>\n</pre>\n", "senID": 1}, {"text": ["prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [['a', 'b'], ['c', 'd'], ['f', 'g']]\n[['a', 'b'], [], ['c', 'd'], [], ['f'], ['g']]\n[['a', 'b', 'c', 'd', 'f', 'g']]\n[['a', 'b'], ['c', 'd'], ['f', 'g'], []]\n[['a', 'b'], [], ['c', 'd'], [], ['f'], ['g'], [], []]\n[['a', 'b', 'c', 'd', 'f', 'g']]\n</code>\n</pre>\n", "senID": 3}, {"text": ["EDIT: I'm also a big fan of groupby, here's my go at it:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from itertools import groupby\ndef splitOn(ll, x, n):\n    cur = []\n    for isdelim,grp in groupby(ll, key=lambda c:c==x):\n        if isdelim:\n            nn = sum(1 for c in grp)\n            while nn &gt;= n:\n                yield cur\n                cur = []\n                nn -= n\n        else:\n            cur.extend(grp)\n    yield cur\n</code>\n</pre>\n", "senID": 5}, {"text": ["Not too different from my earlier answer, just lets groupby take care of iterating over the input list, creating groups of delimiter-matching and not-delimiter-matching characters.", "The non-matching characters just get added onto the current element, the matching character groups do the work of breaking up new elements.", "For long lists, this is probably a bit more efficient, as groupby does all its work in C, and still only iterates over the list once."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Very ugly, but I wanted to see if I could pull this off as a one-liner and I thought I would share.", "I beg you not to actually use this solution for anything of any importance though.", "The ('X', 3) at the end is the delimiter and the number of times it should be repeated."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "('X', 3)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n (lambda delim, count: map(lambda x:filter(lambda y:y != delim, x), reduce(lambda x, y: (x[-1].append(y) if y != delim or x[-1][-count+1:] != [y]*(count-1) else x.append([])) or x, ['a', 'b', 'X', 'X', 'c', 'd', 'X', 'X', 'f', 'X', 'g'], [[]])))('X', 2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Here's a breakdown.", "I also eliminated some redundant code that was far more obvious when written out like this.", "(changed above also)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # Wrap everything in a lambda form to avoid repeating values\n(lambda delim, count:\n    # Filter all sublists after construction\n    map(lambda x: filter(lambda y: y != delim, x), reduce(\n        lambda x, y: (\n            # Add the value to the current sub-list\n            x[-1].append(y) if\n                # but only if we have accumulated the\n                # specified number of delimiters\n                y != delim or x[-1][-count+1:] != [y]*(count-1) else\n\n                # Start a new sublist\n                (x.append([]) and False)) or x,\n        ['a', 'b', 'X', 'X', 'c', 'd', 'X', 'X', 'f', 'X', 'g'], [[]])\n    )\n)('X', 2)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Here's a clean nice solution using zip and generators"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #1 define traditional sequence split function \n#if you only want it for lists, you can use indexing to make it shorter\ndef split(it, x):\n    to_yield = []\n    for y in it:\n        if x == y:\n            yield to_yield\n            to_yield = []\n        else:\n            to_yield.append(y)\n    if to_yield:\n        yield to_yield\n\n#2 zip the sequence with its tail \n#you could use itertools.chain to avoid creating unnecessary lists\nzipped = zip(l, l[1:] + [''])\n\n#3. remove ('X',not 'X')'s from the resulting sequence, and leave only the first position of each\n# you can use list comprehension instead of generator expression\nfiltered = (x for x,y in zipped if not (x == 'X' and y != 'X'))\n\n#4. split the result using traditional split\nresult = [x for x in split(filtered, 'X')]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This way  split() is more reusable."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It's surprising python doesn't have one built in."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["edit:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You can easily adjust it for longer split sequences, repeating steps 2-3 and zipping filtered with l[i:] for 0&lt; i &lt;= n.  "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Here's another way of doing this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def split_multi_delimiter(items, delimiter, num_wanted):\n    def remove_delimiter(objs):\n        return [obj for obj in objs if obj != delimiter]\n\n    ranges = [(index, index+num_wanted) for index in xrange(len(items))\n              if items[index:index+num_wanted] == [delimiter] * num_wanted]\n\n    last_end = 0\n    for range_start, range_end in ranges:\n        yield remove_delimiter(items[last_end:range_start])\n        last_end = range_end\n\n    yield remove_delimiter(items[last_end:])\n\nitems = ['a', 'b', 'X', 'X', 'c', 'd', 'X', 'X', 'f', 'X', 'g']\nprint list(split_multi_delimiter(items, \"X\", 2))\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n In [6]: input = ['a', 'b', 'X', 'X', 'cc', 'XX', 'd', 'X', 'ee', 'X', 'X', 'f']\n\nIn [7]: [s.strip('_').split('_') for s in '_'.join(input).split('X_X')]\nOut[7]: [['a', 'b'], ['cc', 'XX', 'd', 'X', 'ee'], ['f']]\n</code>\n</pre>\n", "senID": 0}, {"text": ["This assumes you can use a reserved character such as _ which is not found in the input."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "_", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Too clever by half, and only offered because the obvious right way to do it seems so brute-force and ugly:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class joiner(object):\n  def __init__(self, N, data = (), gluing = False):\n    self.data = data\n    self.N = N\n    self.gluing = gluing\n  def __add__(self, to_glue):\n    # Process an item from itertools.groupby, by either\n    # appending the data to the last item, starting a new item,\n    # or changing the 'gluing' state according to the number of\n    # consecutive delimiters that were found.\n    N = self.N\n    data = self.data\n    item = list(to_glue[1])\n    # A chunk of delimiters;\n    # return a copy of self with the appropriate gluing state.\n    if to_glue[0]: return joiner(N, data, len(item) &lt; N)\n    # Otherwise, handle the gluing appropriately, and reset gluing state.\n    a, b = (data[:-1], data[-1] if data else []) if self.gluing else (data, [])\n    return joiner(N, a + (b + item,))\n\ndef split_on_multiple(data, delimiter, N):\n  # Split the list into alternating groups of delimiters and non-delimiters,\n  # then use the joiner to join non-delimiter groups when the intervening\n  # delimiter group is short.\n  return sum(itertools.groupby(data, delimiter.__eq__), joiner(N)).data\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Regex, I choose you!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef split_multiple(delimiter, input):\n    pattern = ''.join(map(lambda x: ',' if x == delimiter else ' ', input))\n    filtered = filter(lambda x: x != delimiter, input)\n    result = []\n    for k in map(len, re.split(';', ''.join(re.split(',',\n        ';'.join(re.split(',{2,}', pattern)))))):\n        result.append([])\n        for n in range(k):\n            result[-1].append(filtered.__next__())\n    return result\n\nprint(split_multiple('X',\n    ['a', 'b', 'X', 'X', 'c', 'd', 'X', 'X', 'f', 'X', 'g']))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Oh, you said Python, not Perl."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n import re    \nmap(list, re.sub('(?&lt;=[a-z])X(?=[a-z])', '', ''.join(lst)).split('XX'))\n</code>\n</pre>\n", "senID": 0}, {"text": ["This does a list -> string -> list conversion and assumes that the non-delimiter characters are all lower case letters."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["A very simple way to do this would be"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sdata=[[]]\nfor d in data:\n    if d == 'X':\n        if len(sdata[-1])!=0:\n            sdata.append([])\n        else:\n            continue\n    else:\n        sdata[-1].append(d)\n</code>\n</pre>\n", "senID": 1}]]