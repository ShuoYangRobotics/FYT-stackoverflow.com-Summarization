[[{"text": ["There's two parts to this answer.", "First you need to expose your interface in Python in a way which allows Python implementations to override parts of it at will.", "Then you need to show your C++ program (in main how to call Python."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "main", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["The first part is pretty easy to do with SWIG.", "I modified your example scenario slightly to fix a few issues and added an extra function for testing:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n // myif.h\nclass myif {\n   public:\n     virtual float myfunc(float a) = 0;\n};\n\ninline void runCode(myif *inst) {\n  std::cout &lt;&lt; inst-&gt;myfunc(5) &lt;&lt; std::endl;\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["For now I'll look at the problem without embedding Python in your application, i.e.", "you start excetion in Python, not in int main() in C++.", "It's fairly straightforward to add that later though."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "int main()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["First up is getting cross-language polymorphism working:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "cross-language polymorphism working", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.swig.org/Doc2.0/SWIGDocumentation.html#Python_directors"}]}, {"code": "<pre>\n<code>\n %module(directors=\"1\") module\n\n// We need to include myif.h in the SWIG generated C++ file\n%{\n#include &lt;iostream&gt;\n#include \"myif.h\"\n%}\n\n// Enable cross-language polymorphism in the SWIG wrapper. \n// It's pretty slow so not enable by default\n%feature(\"director\") myif;\n\n// Tell swig to wrap everything in myif.h\n%include \"myif.h\"\n</code>\n</pre>\n", "senID": 5}, {"text": ["To do that we've enabled SWIG's director feature globally and specifically for our interface.", "The rest of it is pretty standard SWIG though."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I wrote a test Python implementation:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import module\n\nclass MyCl(module.myif):\n  def __init__(self):\n    module.myif.__init__(self)\n  def myfunc(self,a):\n    return a*2.0\n\ncl = MyCl()\n\nprint cl.myfunc(100.0)\n\nmodule.runCode(cl)\n</code>\n</pre>\n", "senID": 8}, {"text": ["With that I was then able to compile and run this:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\nswig -python  -c++ -Wall myif.i \ng++ -Wall -Wextra -shared -o _module.so myif_wrap.cxx -I/usr/include/python2.7 -lpython2.7\n\npython mycl.py \n200.0\n10\n</pre>\n", "senID": 10}, {"text": ["Exactly what you'd hope to see from that test."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Next up we need to implement a real version of your mymain.cc.", "I've put together a sketch of what it might look like:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;iostream&gt;\n#include \"myif.h\"\n#include &lt;Python.h&gt;\n\nint main()\n{\n  Py_Initialize();\n\n  const double input = 5.0;\n\n  PyObject *main = PyImport_AddModule(\"__main__\");\n  PyObject *dict = PyModule_GetDict(main);\n  PySys_SetPath(\".\");\n  PyObject *module = PyImport_Import(PyString_FromString(\"mycl\"));\n  PyModule_AddObject(main, \"mycl\", module);\n\n  PyObject *instance = PyRun_String(\"mycl.MyCl()\", Py_eval_input, dict, dict);\n  PyObject *result = PyObject_CallMethod(instance, \"myfunc\", (char *)\"(O)\" ,PyFloat_FromDouble(input));\n\n  PyObject *error = PyErr_Occurred();\n  if (error) {\n    std::cerr &lt;&lt; \"Error occured in PyRun_String\" &lt;&lt; std::endl;\n    PyErr_Print();\n  }\n\n  double ret = PyFloat_AsDouble(result);\n  std::cout &lt;&lt; ret &lt;&lt; std::endl;\n\n  Py_Finalize();\n  return 0;\n}\n</code>\n</pre>\n", "senID": 13}, {"text": ["It's basically just standard embedding Python in another application.", "It works and gives exactly what you'd hope to see also:"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "embedding Python in another application", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/extending/embedding.html"}]}, {"code": "<pre>\ng++ -Wall -Wextra -I/usr/include/python2.7 main.cc -o main -lpython2.7\n./main\n200.0\n10\n10\n</pre>\n", "senID": 15}, {"text": ["The final piece of the puzzle is being able to convert the PyObject* that you get from creating the instance in Python into a myif *.", "SWIG again makes this reasonably straightforward. "], "childNum": 2, "tag": "p", "senID": 16, "childList": [{"text": "PyObject*", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "myif *", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["First we need to ask SWIG to expose its runtime in a headerfile for us.", "We do this with an extra call to SWIG:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\nswig -Wall -c++ -python -external-runtime runtime.h\n</pre>\n", "senID": 18}, {"text": ["Next we need to re-compile our SWIG module, explicitly giving the table of types SWIG knows about a name so we can look it up from within our main.cc.", "We recompile the .so using:"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"code": "<pre>\ng++ -DSWIG_TYPE_TABLE=myif -Wall -Wextra -shared -o _module.so myif_wrap.cxx -I/usr/include/python2.7 -lpython2.7\n</pre>\n", "senID": 20}, {"text": ["Then we add a helper function for converting the PyObject* to myif* in our main.cc:"], "childNum": 2, "tag": "p", "senID": 21, "childList": [{"text": "PyObject*", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "myif*", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n #include \"runtime.h\"\n// runtime.h was generated by SWIG for us with the second call we made\n\nmyif *python2interface(PyObject *obj) {\n  void *argp1 = 0;\n  swig_type_info * pTypeInfo = SWIG_TypeQuery(\"myif *\");\n\n  const int res = SWIG_ConvertPtr(obj, &amp;argp1,pTypeInfo, 0);\n  if (!SWIG_IsOK(res)) {\n    abort();\n  }\n  return reinterpret_cast&lt;myif*&gt;(argp1);\n}\n</code>\n</pre>\n", "senID": 22}, {"text": ["Now this is in place we can use it from within main():"], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "main()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n int main()\n{\n  Py_Initialize();\n\n  const double input = 5.5;\n\n  PyObject *main = PyImport_AddModule(\"__main__\");\n  PyObject *dict = PyModule_GetDict(main);\n  PySys_SetPath(\".\");\n  PyObject *module = PyImport_Import(PyString_FromString(\"mycl\"));\n  PyModule_AddObject(main, \"mycl\", module);\n\n  PyObject *instance = PyRun_String(\"mycl.MyCl()\", Py_eval_input, dict, dict);\n\n  // Get C++ interface poiner rather than Python object:\n  myif *inst = python2interface(instance);\n  std::cout &lt;&lt; inst-&gt;myfunc(input) &lt;&lt; std::endl;\n\n  Py_Finalize();\n  return 0;\n}\n</code>\n</pre>\n", "senID": 24}, {"text": ["Finally we have to compile main.cc with -DSWIG_TYPE_TABLE=myif and this gives:"], "childNum": 1, "tag": "p", "senID": 25, "childList": [{"text": "-DSWIG_TYPE_TABLE=myif", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n./main\n11\n</pre>\n", "senID": 26}], [{"text": ["Quoting http://wiki.python.org/moin/boost.python/Inheritance"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://wiki.python.org/moin/boost.python/Inheritance", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/boost.python/Inheritance"}]}, {"text": ["\"Boost.Python also allows us to represent C++ inheritance relationships so that wrapped derived classes may be passed where values, pointers, or references to a base class are expected as arguments."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There are examples of virtual functions so that solves the first part (the one with class MyCl(myif))"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For specific examples doing this, http://wiki.python.org/moin/boost.python/OverridableVirtualFunctions"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://wiki.python.org/moin/boost.python/OverridableVirtualFunctions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/boost.python/OverridableVirtualFunctions"}]}, {"text": ["For the line myif c = MyCl(); you need to expose your python (module) to C++.", "There are examples here http://wiki.python.org/moin/boost.python/EmbeddingPython"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://wiki.python.org/moin/boost.python/EmbeddingPython", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/boost.python/EmbeddingPython"}]}], [{"text": ["Minimal example; note that it is complicated by the fact that Base is not pure virtual.", "There we go:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Base", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["And the result is:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n Base.foo Base.foo\nPyDerived.foo PyDerived.foo\n</code>\n</pre>\n", "senID": 2}, {"text": ["where you can see how fooBase() (the non-virtual c++ function)  calls virtual foo(), which resolves to the override regardless whether in c++ or python.", "You could derive a class from Base in c++ and it would work just the same."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "fooBase()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["EDIT (extracting c++ object):"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "EDIT (extracting c++ object):", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n PyObject* obj; // given\npy::object pyObj(obj); // wrap as boost::python object (cheap)\npy::extract&lt;Base&gt; ex(pyObj); \nif(ex.check()){ // types are compatible\n  Base&amp; b=ex(); // get the wrapped object\n  // ...\n} else {\n  // error\n}\n\n// shorter, thrwos when conversion not possible\nBase &amp;b=py::extract&lt;Base&gt;(py::object(obj))();\n</code>\n</pre>\n", "senID": 5}, {"text": ["Construct py::object from PyObject* and use py::extract to query whether the python object matches what you are trying to extract: PyObject* obj; py::extract&lt;Base&gt; extractor(py::object(obj)); if(!extractor.check()) /* error */; Base&amp; b=extractor(); "], "childNum": 4, "tag": "p", "senID": 6, "childList": [{"text": "py::object", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "PyObject*", "childNum": 0, "tag": "code", "childList": []}, {"text": "py::extract", "childNum": 0, "tag": "code", "childList": []}, {"text": "PyObject* obj; py::extract&lt;Base&gt; extractor(py::object(obj)); if(!extractor.check()) /* error */; Base&amp; b=extractor();", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Take a look at Boost Python, that is the most versatile and powerful tool to bridge between C++ and Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.boost.org/doc/libs/1_48_0/libs/python/doc/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.boost.org/doc/libs/1_48_0/libs/python/doc/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.boost.org/doc/libs/1_48_0/libs/python/doc/"}]}], [{"text": ["There's no real way to interface C++ code directly with Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["SWIG does handle this, but it builds its own wrapper."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["One alternative I prefer over SWIG is ctypes, but to use this you need to create a C wrapper."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For the example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n // myif.h\nclass myif {\n   public:\n     virtual float myfunc(float a);\n};\n</code>\n</pre>\n", "senID": 4}, {"text": ["Build a C wrapper like so:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n extern \"C\" __declspec(dllexport) float myif_myfunc(myif* m, float a) {\n    return m-&gt;myfunc(a);\n}\n</code>\n</pre>\n", "senID": 6}, {"text": ["Since you are building using C++, the extern \"C\" allows for C linkage so you can call it easily from your dll, and __declspec(dllexport) allows the function to be called from the dll. "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["In Python:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n from ctypes import *\nfrom os.path import dirname\n\ndlldir = dirname(__file__)                      # this strips it to the directory only\ndlldir.replace( '\\\\', '\\\\\\\\' )                  # Replaces \\ with \\\\ in dlldir\nlib = cdll.LoadLibrary(dlldir+'\\\\myif.dll')     # Loads from the full path to your module.\n\n# Just an alias for the void pointer for your class\nc_myif = c_void_p\n\n# This tells Python how to interpret the return type and arguments\nlib.myif_myfunc.argtypes = [ c_myif, c_float ]\nlib.myif_myfunc.restype  = c_float\n\nclass MyCl(myif):\n    def __init__:\n        # Assume you wrapped a constructor for myif in C\n        self.obj = lib.myif_newmyif(None)\n\n    def myfunc(a):\n        return lib.myif_myfunc(self.obj, a)\n</code>\n</pre>\n", "senID": 9}, {"text": ["While SWIG does all this for you, there's little room for you to modify things as you please without getting frustrated at all the changes you have to redo when you regenerate the SWIG wrapper."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["One issue with ctypes is that it doesn't handle STL structures, since it's made for C. SWIG does handle this for you, but you may be able to wrap it yourself in the C. It's up to you."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Here's the Python doc for ctypes:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["http://docs.python.org/library/ctypes.html"], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "http://docs.python.org/library/ctypes.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/ctypes.html"}]}, {"text": ["Also, the built dll should be in the same folder as your Python interface (why wouldn't it be?", ")."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["I am curious though, why would you want to call Python from inside C++ instead of calling the C++ implementation directly?"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}], [{"text": ["Based upon the (very helpful) answer by Eudoxos I've taken his code and extended it such that there is now an embedded interpreter, with a built-in module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "the (very helpful) answer by Eudoxos", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/a/9078135/168175"}]}, {"text": ["This answer is the Boost.Python equivalent of my SWIG based answer."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "my SWIG based answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/a/9042139/168175"}]}, {"text": ["The headerfile myif.h:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class myif {\npublic:\n  virtual float myfunc(float a) const { return 0; }\n  virtual ~myif() {}\n};\n</code>\n</pre>\n", "senID": 3}, {"text": ["Is basically as in the question, but with a default implementation of myfunc and a virtual destructor."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "myfunc", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For the Python implementation, MyCl.py I have basically the same as the question:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import myif\n\nclass MyCl(myif.myif):\n  def myfunc(self,a): \n    return a*2.0\n</code>\n</pre>\n", "senID": 6}, {"text": ["This then leaves mymain.cc, most of which is based upon the answer from Eudoxos:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;boost/python.hpp&gt;\n#include &lt;iostream&gt;\n#include \"myif.h\"\n\nusing namespace boost::python;\n\n// This is basically Eudoxos's answer:\nstruct MyIfWrapper: myif, wrapper&lt;myif&gt;{\n  float myfunc(float a) const {\n    if(this-&gt;get_override(\"myfunc\")) \n      return this-&gt;get_override(\"myfunc\")(a);\n    else \n      return myif::myfunc(a);\n  }\n};\n\nBOOST_PYTHON_MODULE(myif){\n  class_&lt;MyIfWrapper,boost::noncopyable&gt;(\"myif\")\n    .def(\"myfunc\",&amp;myif::myfunc)\n  ;\n}\n// End answer by Eudoxos\n\nint main( int argc, char ** argv ) {\n  try {\n    // Tell python that \"myif\" is a built-in module\n    PyImport_AppendInittab(\"myif\", initmyif);\n    // Set up embedded Python interpreter:\n    Py_Initialize();\n\n    object main_module = import(\"__main__\");\n    object main_namespace = main_module.attr(\"__dict__\");\n\n    PySys_SetPath(\".\");\n    main_namespace[\"mycl\"] = import(\"mycl\");\n\n    // Create the Python object with an eval()\n    object obj = eval(\"mycl.MyCl()\", main_namespace);\n\n    // Find the base C++ type for the Python object (from Eudoxos)\n    const myif &amp;b=extract&lt;myif&gt;(obj)();\n    std::cout &lt;&lt; b.myfunc(5) &lt;&lt; std::endl;\n\n  } catch( error_already_set ) {\n    PyErr_Print();\n  }\n}\n</code>\n</pre>\n", "senID": 8}, {"text": ["The key part that I've added here, above and beyond the \"how do I embed Python using Boost.Python?", "\" and \"how do I extend Python using Boost.python?", "\" (which was answered by Eudoxos) is the answer to the question \"How do I do both at once in the same program?\".", "The solution to this lies with the PyImport_AppendInittab call, which takes the initialisation function that would normally be called when the module is loaded and registers it as a built-in module.", "Thus when mycl.py says import myif it ends up importing the built-in Boost.Python module."], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "PyImport_AppendInittab", "tag": "a", "pos": 3, "childList": [{"text": "PyImport_AppendInittab", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/c-api/import.html#PyImport_AppendInittab"}, {"text": "PyImport_AppendInittab", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "import myif", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}], [{"text": ["I'm pretty sure that this is not possible in an easy way."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First of all, if you want to execute Python code from within your C++ application, you will need to embed the python interpreter in your application.", "Otherwise there's no way to execute the Python code."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Then there's the question of how to communicate between Python and C++.", "I don't think it will be possible to just pop Python classes into your C++ class hierarchy, if only because Python is written in C."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["However, if you would be willing to create some wrapping code, I think it should be possible to create a wrapper class in your class hierarchy, that internally uses the embedded python interpreter to execute Python code implementing the actual functionality."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You might want to check out the relevant parts of the Python docs."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "relevant parts of the Python docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/extending/embedding.html#extending-embedded-python"}]}]]