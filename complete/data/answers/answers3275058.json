[[{"text": ["How about some analogies..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You have a sock drawer, but it is currently empty.", "Does it contain any black sock?", "No - you don't have any socks at all so you certainly don't have a black one.", "Clearly any([]) must return false - if it returned true this would be counter-intuitive."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "any([])", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["The case for all([]) is slightly more difficult.", "See the Wikipedia article on vacuous truth.", "Another analogy: If there are no people in a room then everyone in that room can speak French."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "all([])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "vacuous truth", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Vacuous_truth"}]}, {"text": ["Mathematically all([]) can be written:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "all([])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["There is considerable debate about whether vacuous statements should be considered true or not, but from a logical viewpoint it makes the most sense:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Also from the article:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Defining a \"vacuously true\" statement to return false in Python would violate the principle of least astonishment."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "principle of least astonishment", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Principle_of_least_astonishment"}]}], [{"text": ["One property of any is its recursive definition"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "any", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n any([x,y,z,...]) == (x or any([y,z,...]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["That means"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n x == any([x]) == (x or any([]))\n</code>\n</pre>\n", "senID": 3}, {"text": ["The equality is correct for any x if and only if any([]) is defined to be False.", "Similar for all."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "any([])", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "all", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I think of them as being implemented this way"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def all(seq):\n    for item in seq:\n        if not item:\n            return False\n    return True\n\ndef any(seq):\n    for item in seq:\n        if item:\n            return True\n    return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["not sure they are implemented that way though"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "are", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Perl 6 also takes the position that all() and any() on empty lists should serve as sane base-cases for their respective reduction operators, and therefore all() is true and any() is false."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "all()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "any()", "childNum": 0, "tag": "code", "childList": []}, {"text": "all()", "childNum": 0, "tag": "code", "childList": []}, {"text": "any()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["That is to say, all(a, b, c) is equivalent to [&amp;] a, b, c, which is equivalent to a &amp; b &amp; c (reduction on the \"junctive and\" operator, but you can ignore junctions and consider it a logical and for this post), and any(a, b, c) is equivalent to [|] a, b, c, which is equivalent to a | b | c (reduction on the \"junctive or\" operator -- again, you can pretend it's the same as logical or without missing anything)."], "childNum": 6, "tag": "p", "senID": 1, "childList": [{"text": "all(a, b, c)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[&amp;] a, b, c", "childNum": 0, "tag": "code", "childList": []}, {"text": "a &amp; b &amp; c", "childNum": 0, "tag": "code", "childList": []}, {"text": "any(a, b, c)", "childNum": 0, "tag": "code", "childList": []}, {"text": "[|] a, b, c", "childNum": 0, "tag": "code", "childList": []}, {"text": "a | b | c", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Any operator which can have reduction applied to it needs to have a defined behavior when reducing 0 terms, and usually this is done by having a natural identity element -- for instance, [+]() (reduction of addition across zero terms) is 0 because 0 is the additive identity; adding zero to any expression leaves it unchanged.", "[*]() is likewise 1 because 1 is the multiplicative identity.", "We've already said that all is equivalent to [&amp;] and any is equivalent to [|] -- well, truth is the and-identity, and falsity is the or-identity -- x and True is x, and x or False is x.", "This makes it inevitable that all() should be true and any() should be false."], "childNum": 12, "tag": "p", "senID": 2, "childList": [{"text": "[+]()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[*]()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "all", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "[&amp;]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "any", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "[|]", "childNum": 0, "tag": "code", "childList": []}, {"text": "and", "childNum": 0, "tag": "em", "childList": []}, {"text": "or", "childNum": 0, "tag": "em", "childList": []}, {"text": "x and True", "childNum": 0, "tag": "em", "childList": []}, {"text": "x or False", "childNum": 0, "tag": "em", "childList": []}, {"text": "all()", "childNum": 0, "tag": "code", "childList": []}, {"text": "any()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To put it in an entirely different (but practical) perspective, any is a latch that starts off false and becomes true whenever it sees something true; all is a latch that starts off true and becomes false whenever it sees something false.", "Giving them no arguments means giving them no chance to change state, so you're simply asking them what their \"default\" state is.", ":)"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "any", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "all", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["For general interest, here's the blog post in which GvR proposes any/all with a sample implementation like gnibbler's and references quanifiers in ABC.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "blog post", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.artima.com/weblogs/viewpost.jsp?thread=98196"}]}], [{"text": ["any and all have the same meaning in python as everywhere else:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "any", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "all", "childNum": 0, "tag": "code", "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": ["any"], "childNum": 0, "tag": "code", "senID": 1, "childList": []}, {"text": ["all"], "childNum": 0, "tag": "code", "senID": 2, "childList": []}]}]]