[[{"text": ["Ok, after i understood what you want, it is as simple as using the second argument of zipfile.write, where you can use whatever you want:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "zipfile.write", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import zipfile\nmyZipFile = zipfile.ZipFile(\"zip.zip\", \"w\" )\nmyZipFile.write(\"test.py\", \"dir\\\\test.py\", zipfile.ZIP_DEFLATED )\n</code>\n</pre>\n", "senID": 1}, {"text": ["creates a zipfile where test.py would be extracted to a directory called dir "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "test.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dir", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["EDIT:\nI once had to create an empty directory in a zip file: it is possible.", "after the code above just delete the file test.py from the zipfile, the file is gone, but the empty directory stays."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["A zip file has no directory structure, it just has a bunch of pathnames and their contents.", "These pathnames should be relative to an imaginary root folder (the ZIP file itself).", "\"../\" prefixes have no defined meaning in a zip file."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Consider you have a file, a and you want to store it in a \"folder\" inside a zip file.", "All you have to do is prefix the filename with a folder name when storing the file in the zipfile:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n zipi= zipfile.ZipInfo()\nzipi.filename= \"folder/a\" # this is what you want\nzipi.date_time= time.localtime(os.path.getmtime(\"a\"))[:6]\nzipi.compress_type= zipfile.ZIP_DEFLATED\nfiledata= open(\"a\", \"rb\").read()\n\nzipfile1.writestr(zipi, filedata) # zipfile1 is a zipfile.ZipFile instance\n</code>\n</pre>\n", "senID": 2}, {"text": ["I don't know of any ZIP implementations allowing the inclusion of an empty folder in a ZIP file.", "I can think of a workaround (storing a dummy filename in the zip \"folder\" which should be ignored on extraction), but not portable across implementations."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "empty", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "dummy", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["You can also use shutil"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import shutil\n\nshutil.make_archive(\"desired_zipfile_name_no\", \"zip\", \"name_of_the_folder_you_want_to_zip\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will put the whole folder in the zip."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n import zipfile\nimport os\n\n\nclass ZipUtilities:\n\n    def toZip(self, file, filename):\n    \tzip_file = zipfile.ZipFile(filename, 'w')\n    \tif os.path.isfile(file):\n            \t\tzip_file.write(file)\n        \telse:\n            \t\tself.addFolderToZip(zip_file, file)\n    \tzip_file.close()\n\n    def addFolderToZip(self, zip_file, folder): \n    \tfor file in os.listdir(folder):\n    \t\tfull_path = os.path.join(folder, file)\n    \t\tif os.path.isfile(full_path):\n    \t\t\tprint 'File added: ' + str(full_path)\n    \t\t\tzip_file.write(full_path)\n    \t\telif os.path.isdir(full_path):\n    \t\t\tprint 'Entering folder: ' + str(full_path)\n    \t\t\tself.addFolderToZip(zip_file, full_path)\n\ndef main():\n    utilities = ZipUtilities()\n    filename = 'TEMP.zip'\n    directory = 'TEMP'\n    utilities.toZip(directory, filename)\n\nmain()\n</code>\n</pre>\n", "senID": 0}, {"text": ["I'm running:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["python tozip.py"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This is the log:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["havok@fireshield:~$ python tozip.py"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["File added: TEMP/NARF (7\u00aa copia)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Entering folder: TEMP/TEMP2"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["File added: TEMP/TEMP2/NERF (otra copia)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["File added: TEMP/TEMP2/NERF (copia)"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["File added: TEMP/TEMP2/NARF"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["File added: TEMP/TEMP2/NARF (copia)"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["File added: TEMP/TEMP2/NARF (otra copia)"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Entering folder: TEMP/TEMP2/TEMP3"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["File added: TEMP/TEMP2/TEMP3/DOCUMENTO DEL FINAL"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["File added: TEMP/TEMP2/TEMP3/DOCUMENTO DEL FINAL (copia)"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["File added: TEMP/TEMP2/NERF"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["File added: TEMP/NARF (copia) (otra copia)"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["File added: TEMP/NARF (copia) (copia)"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["File added: TEMP/NARF (6\u00aa copia)"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["File added: TEMP/NERF (copia) (otra copia)"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["File added: TEMP/NERF (4\u00aa copia)"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"text": ["File added: TEMP/NERF (otra copia)"], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"text": ["File added: TEMP/NERF (3\u00aa copia)"], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"text": ["File added: TEMP/NERF (6\u00aa copia)"], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"text": ["File added: TEMP/NERF (copia)"], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"text": ["File added: TEMP/NERF (5\u00aa copia)"], "childNum": 0, "tag": "p", "senID": 25, "childList": []}, {"text": ["File added: TEMP/NARF (8\u00aa copia)"], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"text": ["File added: TEMP/NARF (3\u00aa copia)"], "childNum": 0, "tag": "p", "senID": 27, "childList": []}, {"text": ["File added: TEMP/NARF (5\u00aa copia)"], "childNum": 0, "tag": "p", "senID": 28, "childList": []}, {"text": ["File added: TEMP/NERF (copia) (3\u00aa copia)"], "childNum": 0, "tag": "p", "senID": 29, "childList": []}, {"text": ["File added: TEMP/NARF"], "childNum": 0, "tag": "p", "senID": 30, "childList": []}, {"text": ["File added: TEMP/NERF (copia) (copia)"], "childNum": 0, "tag": "p", "senID": 31, "childList": []}, {"text": ["File added: TEMP/NERF (8\u00aa copia)"], "childNum": 0, "tag": "p", "senID": 32, "childList": []}, {"text": ["File added: TEMP/NERF (7\u00aa copia)"], "childNum": 0, "tag": "p", "senID": 33, "childList": []}, {"text": ["File added: TEMP/NARF (copia)"], "childNum": 0, "tag": "p", "senID": 34, "childList": []}, {"text": ["File added: TEMP/NARF (otra copia)"], "childNum": 0, "tag": "p", "senID": 35, "childList": []}, {"text": ["File added: TEMP/NARF (4\u00aa copia)"], "childNum": 0, "tag": "p", "senID": 36, "childList": []}, {"text": ["File added: TEMP/NERF"], "childNum": 0, "tag": "p", "senID": 37, "childList": []}, {"text": ["File added: TEMP/NARF (copia) (3\u00aa copia)"], "childNum": 0, "tag": "p", "senID": 38, "childList": []}, {"text": ["As you can see, it work, the archive is ok too.", "This is a recursive function that can zip an entire folder.", "The only problem is that it doesn't create a empty folder."], "childNum": 0, "tag": "p", "senID": 39, "childList": []}, {"text": ["Cheers."], "childNum": 0, "tag": "p", "senID": 40, "childList": []}], [{"text": ["after adding some imports your code runs fine for me, how do you call the script, maybe you could tell us the folder structure of the '..\\packed\\bin' directory. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I called your code with the following arguments:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n planName='test.zip'\nfiles=['z.py',]\nfolders=['c:\\\\temp']\n(success,filename)=createZipFile(planName,files,folders)\n</code>\n</pre>\n", "senID": 2}, {"text": [], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Below is some code for zipping an entire directory into a zipfile."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This seems to work OK creating zip files on both windows and linux.", "The output\nfiles seem to extract properly on windows (built-in Compressed Folders feature,\nWinZip, and 7-Zip) and linux.", "However, empty directories in a zip file appear\nto be a thorny issue.", "The solution below seems to work but the output of\n\"zipinfo\" on linux is concerning.", "Also the directory permissions are not set\ncorrectly for empty directories in the zip archive.", "This appears to require\nsome more in depth research."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I got some info from this velocity reviews thread and this python mailing list thread."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "this velocity reviews thread", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.velocityreviews.com/forums/t318840-add-empty-directory-using-zipfile.html"}, {"href": "http://mail.python.org/pipermail/python-list/2006-January/535240.html", "text": "this python mailing list thread", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Note that this function is designed to put files in the zip archive with\neither no parent directory or just one parent directory, so it will trim any\nleading directories in the filesystem paths and not include them inside the\nzip archive paths.", "This is generally the case when you want to just take a\ndirectory and make it into a zip file that can be extracted in different\nlocations. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Keyword arguments:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["dirPath -- string path to the directory to archive.", "This is the only\nrequired argument.", "It can be absolute or relative, but only one or zero\nleading directories will be included in the zip archive."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["zipFilePath -- string path to the output zip file.", "This can be an absolute\nor relative path.", "If the zip file already exists, it will be updated.", "If\nnot, it will be created.", "If you want to replace it from scratch, delete it\nprior to calling this function.", "(default is computed as dirPath + \".zip\")"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["includeDirInZip -- boolean indicating whether the top level directory should\nbe included in the archive or omitted.", "(default True)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["(Note that StackOverflow seems to be failing to pretty print my python with\ntriple quoted strings, so I just converted my doc strings to the post text here)"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\nimport os\nimport zipfile\n\ndef zipdir(dirPath=None, zipFilePath=None, includeDirInZip=True):\n\n    if not zipFilePath:\n        zipFilePath = dirPath + \".zip\"\n    if not os.path.isdir(dirPath):\n        raise OSError(\"dirPath argument must point to a directory. \"\n            \"'%s' does not.\" % dirPath)\n    parentDir, dirToZip = os.path.split(dirPath)\n    #Little nested function to prepare the proper archive path\n    def trimPath(path):\n        archivePath = path.replace(parentDir, \"\", 1)\n        if parentDir:\n            archivePath = archivePath.replace(os.path.sep, \"\", 1)\n        if not includeDirInZip:\n            archivePath = archivePath.replace(dirToZip + os.path.sep, \"\", 1)\n        return os.path.normcase(archivePath)\n\n    outFile = zipfile.ZipFile(zipFilePath, \"w\",\n        compression=zipfile.ZIP_DEFLATED)\n    for (archiveDirPath, dirNames, fileNames) in os.walk(dirPath):\n        for fileName in fileNames:\n            filePath = os.path.join(archiveDirPath, fileName)\n            outFile.write(filePath, trimPath(filePath))\n        #Make sure we get empty directories as well\n        if not fileNames and not dirNames:\n            zipInfo = zipfile.ZipInfo(trimPath(archiveDirPath) + \"/\")\n            #some web sites suggest doing\n            #zipInfo.external_attr = 16\n            #or\n            #zipInfo.external_attr = 48\n            #Here to allow for inserting an empty directory.  Still TBD/TODO.\n            outFile.writestr(zipInfo, \"\")\n    outFile.close()\n</code>\n</pre>\n", "senID": 9}, {"text": ["Here's some sample usages.", "Note that if your dirPath argument has several leading directories, only the LAST one will be included by default.", "Pass includeDirInZip=False to omit all leading directories."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n zipdir(\"foo\") #Just give it a dir and get a .zip file\nzipdir(\"foo\", \"foo2.zip\") #Get a .zip file with a specific file name\nzipdir(\"foo\", \"foo3nodir.zip\", False) #Omit the top level directory\nzipdir(\"../test1/foo\", \"foo4nopardirs.zip\")\n</code>\n</pre>\n", "senID": 11}], [{"text": ["Heres the edited code I ran.", "Its based on the code above, taken from the mailing list.", "I added the imports and made a main routine.", "I also cut out the fiddling with the output filename to make the code shorter."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nimport os, zipfile, glob, sys\n\ndef addFolderToZip(myZipFile,folder):\n    folder = folder.encode('ascii') #convert path to ascii for ZipFile Method\n    for file in glob.glob(folder+\"/*\"):\n            if os.path.isfile(file):\n                print file\n                myZipFile.write(file, os.path.basename(file), zipfile.ZIP_DEFLATED)\n            elif os.path.isdir(file):\n                addFolderToZip(myZipFile,file)\n\ndef createZipFile(filename,files,folders):\n    myZipFile = zipfile.ZipFile( filename, \"w\" ) # Open the zip file for writing \n    for file in files:\n        file = file.encode('ascii') #convert path to ascii for ZipFile Method\n        if os.path.isfile(file):\n            (filepath, filename) = os.path.split(file)\n            myZipFile.write( file, filename, zipfile.ZIP_DEFLATED )\n\n    for folder in  folders:   \n        addFolderToZip(myZipFile,folder)  \n    myZipFile.close()\n    return (1,filename)\n\nif __name__==\"__main__\":\n    #put everything in sys.argv[1] in out.zip, skip files\n    print createZipFile(\"out.zip\", [], sys.argv[1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["At work, on my Windows box, this code ran fine but didnt create any \"folders\" in the zipfile.", "At least I recall it did.", "Now at home, on my Linux box, the zip file created seems to be bad:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ unzip -l out.zip \nArchive:  out.zip\n  End-of-central-directory signature not found.  Either this file is not\n  a zipfile, or it constitutes one disk of a multi-part archive.  In the\n  latter case the central directory and zipfile comment will be found on\n  the last disk(s) of this archive.\nunzip:  cannot find zipfile directory in one of out.zip or\n        out.zip.zip, and cannot find out.zip.ZIP, period.\n</code>\n</pre>\n", "senID": 3}, {"text": ["I dont know if I accidently broke the code, I think its the same.", "Crossplatform issues?", "Either way, its not related to my original question; getting folders in the zip file.", "Just wanted to post the code I actually ran, not the code I based my code on."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["here is my function i use to zip a folder:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\nimport os.path\nimport zipfile\n\ndef zip_dir(dirpath, zippath):\n    fzip = zipfile.ZipFile(zippath, 'w', zipfile.ZIP_DEFLATED)\n    basedir = os.path.dirname(dirpath) + '/' \n    for root, dirs, files in os.walk(dirpath):\n        if os.path.basename(root)[0] == '.':\n            continue #skip hidden directories        \n        dirname = root.replace(basedir, '')\n        for f in files:\n            if f[-1] == '~' or (f[0] == '.' and f != '.htaccess'):\n                #skip backup files and all hidden files except .htaccess\n                continue\n            fzip.write(root + '/' + f, dirname + '/' + f)\n    fzip.close()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Thank you wery much for this useful function!", "I found it very useful as I was also searching for help.", "However, maybe it would be useful to change it a little bit so that "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n basedir = os.path.dirname(dirpath) + '/'\n</code>\n</pre>\n", "senID": 1}, {"text": ["would be "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n basedir = os.path.dirname(dirpath + '/')\n</code>\n</pre>\n", "senID": 3}, {"text": ["Because found that if I want to zip folder 'Example' which is located at 'C:\\folder\\path\\notWanted\\to\\zip\\Example',"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I got in Windows:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n dirpath = 'C:\\folder\\path\\notWanted\\to\\zip\\Example'\nbasedir = 'C:\\folder\\path\\notWanted\\to\\zip\\Example/'\ndirname = 'C:\\folder\\path\\notWanted\\to\\zip\\Example\\Example\\Subfolder_etc'\n</code>\n</pre>\n", "senID": 6}, {"text": ["But I suppose your code should give"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n dirpath = 'C:\\folder\\path\\notWanted\\to\\zip\\Example'\nbasedir = 'C:\\folder\\path\\notWanted\\to\\zip\\Example\\'\ndirname = '\\Subfolder_etc'\n</code>\n</pre>\n", "senID": 8}], [{"text": ["When you wanna create an empty folder, you can do it like this: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n storage = api.Storage.open(\"empty_folder.zip\",\"w\")\n    res = storage.open_resource(\"hannu//\",\"w\")\n    storage.close()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Folder not showe in winextractor, but when you extract it it is showed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]