[[{"text": ["Everyone seems to want to tell you what you should be doing rather than just answering the question."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The problem is that you're running the module as '__main__' by passing the mod1.py as an argument to the interpreter."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["From PEP 328:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "PEP 328", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0328/"}]}, {"text": ["In Python 2.6, they're adding the ability to reference modules relative to the main module.", "PEP 366 describes the change."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "PEP 366", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://python.org/dev/peps/pep-0366/"}]}], [{"code": "<pre>\n<code>\n main.py\nsetup.py\napp/ -&gt;\n    __init__.py\n    package_a/ -&gt;\n       __init__.py\n       module_a.py\n    package_b/ -&gt;\n       __init__.py\n       module_b.py\n</code>\n</pre>\n", "senID": 0}, {"text": ["Alternatively 2 or 3 could use: from app.package_a import module_a"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "from app.package_a import module_a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["That will work as long as you have app in your PYTHONPATH.", "main.py could be anywhere then."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "app", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "main.py", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["So you write a setup.py to copy (install) the whole app package and subpackages to the target system's python folders, and main.py to target system's script folders."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "setup.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "main.py", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n def import_path(fullpath):\n    \"\"\" \n    Import a file with full path specification. Allows one to\n    import from anywhere, something __import__ does not do. \n    \"\"\"\n    path, filename = os.path.split(fullpath)\n    filename, ext = os.path.splitext(filename)\n    sys.path.append(path)\n    module = __import__(filename)\n    reload(module) # Might be out of date\n    del sys.path[-1]\n    return module\n</code>\n</pre>\n", "senID": 0}, {"text": ["I'm using this snippet to import modules from paths, hope that helps"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Take a look at http://docs.python.org/whatsnew/2.5.html#pep-328-absolute-and-relative-imports.", "You could do "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/whatsnew/2.5.html#pep-328-absolute-and-relative-imports", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/whatsnew/2.5.html#pep-328-absolute-and-relative-imports"}]}, {"code": "<pre>\n<code>\n from .mod1 import stuff\n</code>\n</pre>\n", "senID": 1}], [{"text": ["On a related note, Python 3 will change the default handling of imports to be absolute by default; relative imports will have to be explicitly specified."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python 3", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3100/"}]}], [{"text": ["Suppose you run at the toplevel, then in mod1 use:\nimport sub2.mod2 "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["instead of from ..sub2 import mod2"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["From Python doc,"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python doc", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/whatsnew/2.5.html#pep-328-absolute-and-relative-imports"}]}], [{"text": ["\"Guido views running scripts within a package as an anti-pattern\" (rejected\nPEP-3122)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PEP-3122", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3122/"}]}, {"text": ["I have spent so much time trying to find a solution, reading related posts here on Stack Overflow and saying to myself \"there must be a better way!\".", "Looks like there is not."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I am sorry, this is not an answer to the question.", "But I hope this comment will be helpful to someone."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I think that what you have to ask yourself is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Why i need to do this?", "tag": "none", "senID": 1}, {"text": "Is my package separation well done?", "tag": "none", "senID": 2}]}, {"text": ["I don't know the context why you want to do it this way.", "But for me a cleaner design would be to have the following packages structure:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n app/\n   __init__.py\n   sub1/\n      __init__.py\n      mod1.py\n      sub12/\n           __init__.py\n           mod2.py\n</code>\n</pre>\n", "senID": 4}, {"text": ["Then you only have to do:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from sub12 import mod2\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Why you even need this?", "Why you just do not import it as"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from app.sub2 import mod2\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Don't do relative imports.", "They'll only make your code more fragile.", "If you do an absolute import as Matej suggested, you'll be less vulnerable to changes in sys.path and changes in file locations."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]