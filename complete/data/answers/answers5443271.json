[[{"text": ["Not sure about pythonic, but this should work and is more terse:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n star_list = ['**', 'foo', '*', 'bar', 'bar', '**', '**', 'baz']\nstar_list = [i for i, next_i in zip(star_list, star_list[1:] + [None]) if (i, next_i) != ('**', '**')]      \nprint star_list == ['**', 'foo', '*', 'bar', 'bar', '**', 'baz']\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: The above copies the list twice; if you want to avoid that, consider Tom Zych's method.", "Or, you could do as follows:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import islice, izip, chain\n\nstar_list = ['**', 'foo', '*', 'bar', 'bar', '**', '**', 'baz']\nsl_shift = chain(islice(star_list, 1, None), [None])\nstar_list = [i for i, next_i in izip(star_list, sl_shift) if (i, next_i) != ('**', '**')]\nprint star_list == ['**', 'foo', '*', 'bar', 'bar', '**', 'baz']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This works.", "Not sure how Pythonic it is."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\np = ['**', 'foo', '*', 'bar', 'bar', '**', '**', 'baz']\n\nq = []\nfor key, iter in itertools.groupby(p):\n    q.extend([key] * (1 if key == '**' else len(list(iter))))\n\nprint(q)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n from itertools import groupby\n\np = ['**', 'foo', '*', 'bar', 'bar', '**', '**', 'baz']\nkeep = set(['foo',  'bar', 'baz'])\nresult = []\n\nfor k, g in groupby(p):\n    if k in keep:\n        result.extend(list(g))\n    else:\n        result.append(k)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["A solution without itertools.groupby() :   "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.groupby()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n p = ['**', 'foo', '*', 'bar', 'bar', '**', '**', '**', 'baz', '**', '**',\n     'foo', '*','*', 'bar', 'bar','bar', '**', '**','foo','bar',]\n\ndef treat(A):\n    prec = A[0]; yield prec\n    for x in A[1:]:\n        if (prec,x)!=('**','**'):  yield x\n        prec = x\n\nprint p\nprint\nprint list(treat(p))\n</code>\n</pre>\n", "senID": 1}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ['**', 'foo', '*', 'bar', 'bar', '**', '**', '**',  \n 'baz', '**', '**',\n 'foo', '*', '*', 'bar', 'bar','bar', '**', '**',\n 'foo', 'bar']\n\n\n['**', 'foo', '*', 'bar', 'bar', '**',\n 'baz', '**',\n 'foo', '*', '*', 'bar', 'bar', 'bar', '**',\n 'foo', 'bar']\n</code>\n</pre>\n", "senID": 3}, {"text": ["Another solution, inspired from dugres"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from itertools import groupby\n\np = ['**', 'foo', '*', 'bar', 'bar', '**', '**', '**', 'baz', '**', '**',\n     'foo', '*','*', 'bar', 'bar','bar', '**', '**','foo','bar',]\n\nres = []\nfor k, g in groupby(p):\n    res.extend(  ['**'] if k=='**' else list(g) )    \nprint res\n</code>\n</pre>\n", "senID": 5}, {"text": ["It's like Tom Zych's solution, but simpler"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["EDIT"], "childNum": 0, "tag": "h2", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n p = ['**','**', 'foo', '*', 'bar', 'bar', '**', '**', '**', 'baz', '**', '**',\n     'foo', '*','*', 'bar', 'bar','bar', '**', '**','foo','bar', '**', '**', '**']\n\n\nq= ['**',12,'**',45, 'foo',78, '*',751, 'bar',4789, 'bar',3, '**', 5,'**',7, '**',\n    73,'baz',4, '**',8, '**',20,'foo', 8,'*',36,'*', 36,'bar', 11,'bar',0,'bar',9,\n    '**', 78,'**',21,'foo',27,'bar',355, '**',33, '**',37, '**','end']\n\ndef treat(B,dedupl):\n    B = iter(B)\n    prec = B.next(); yield prec\n    for x in B:\n        if not(prec==x==dedupl):  yield x\n        prec = x\n\nprint 'gen = ( x for x in q[::2])'\ngen = ( x for x in q[::2])\nprint 'list(gen)==p is ',list(gen)==p\ngen = ( x for x in q[::2])\nprint 'list(treat(gen)==',list(treat(gen,'**'))\n\nch = '??h4i4???4t4y?45l????hmo4j5???'\nprint '\\nch==',ch\nprint \"''.join(treat(ch,'?'))==\",''.join(treat(ch,'?'))\n\nprint \"\\nlist(treat([],'%%'))==\",list(treat([],'%%'))\n</code>\n</pre>\n", "senID": 9}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n gen = ( x for x in q[::2])\nlist(gen)==p is  True\nlist(treat(gen)== ['**', 'foo', '*', 'bar', 'bar', '**', 'baz', '**', 'foo', '*', '*', 'bar', 'bar', 'bar', '**', 'foo', 'bar', '**']\n\nch== ??h4i4???4t4y?45l????hmo4j5???\n''.join(treat(ch,'?'))== ?h4i4?4t4y?45l?hmo4j5?\n\nlist(treat([],'%%'))== []\n</code>\n</pre>\n", "senID": 11}, {"text": [], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Remark: A generator function allows to adapt the output to the type of the input with a writing around the call of the generator, it dosn't require to change th internal code of the genrator function;"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["That's not the case with the Tom Zynch's solution , that can't be adapted so easely to the type of the input"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["EDIT 2"], "childNum": 0, "tag": "h2", "senID": 16, "childList": []}, {"text": ["I searched a one-line method, with a list comprehension or a generator expression."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["I found to ways of doing this, I think it isn't possible to do without groupby() "], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "groupby()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import groupby\nfrom operator import concat\n\np = ['**', '**','foo', '*', 'bar', 'bar', '**', '**', '**',\n     'bar','**','foo','sun','sun','sun']\nprint 'p==',p,'\\n'\n\ndedupl = (\"**\",'sun')\nprint 'dedupl==',repr(dedupl)\n\nprint [ x for k, g in groupby(p) for x in ((k,) if k in dedupl else g) ]\n\n# or\n\nprint reduce(concat,( [k] if k in dedupl else list(g) for k, g in groupby(p)),[])\n</code>\n</pre>\n", "senID": 19}, {"text": ["Based on the same principle, it is easy to convert the function of dugres into a generator function:"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"code": "<pre>\n<code>\n from itertools import groupby\n\ndef compress(iterable, to_compress):\n    for k, g in groupby(iterable):\n        if k in to_compress:\n            yield k\n        else:\n            for x in g: yield x\n</code>\n</pre>\n", "senID": 21}, {"text": ["However , this generator function has two disadvantages:"], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["it resorts to the function groupby(), which is not easy to understand by someone not used to Python"], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "groupby()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["its execution's time is longer than the ones of my generator function treat() and the generator function of John Machin, that don't use groupby().    "], "childNum": 2, "tag": "p", "senID": 24, "childList": [{"text": "treat()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "groupby()", "childNum": 0, "tag": "strong", "childList": []}]}]}, {"text": ["I slightly modified them to make them able to accept a sequence of items to be de-duplicated, and I measured the durations of execution:"], "childNum": 0, "tag": "p", "senID": 25, "childList": []}, {"code": "<pre>\n<code>\n from time import clock\nfrom itertools import groupby\n\ndef squeeze(iterable, victims, _dummy=object()):\n    if hasattr(iterable, '__iter__') and not hasattr(victims, '__iter__'):\n        victims = (victims,)\n    previous = _dummy\n    for item in iterable:\n        if item in victims and item==previous:\n            continue\n        previous = item\n        yield item\n\ndef treat(B,victims):\n    if hasattr(B, '__iter__') and not hasattr(victims, '__iter__'):\n        victims = (victims,)\n    B = iter(B)\n    prec = B.next(); yield prec\n    for x in B:\n        if x  not in victims or x!=prec:  yield x\n        prec = x\n\ndef compress(iterable, to_compress):\n    if hasattr(iterable, '__iter__') and not hasattr(to_compress, '__iter__'):\n        to_compress = (to_compress,)\n    for k, g in groupby(iterable):\n        if k in to_compress:\n            yield k\n        else:\n            for x in g: yield x\n\np = ['**', '**','su','foo', '*', 'bar', 'bar', '**', '**', '**',\n     'su','su','**','bin', '*','*','bar','bar','su','su','su']\n\nn = 10000\n\nte = clock()\nfor i in xrange(n):\n    a = list(compress(p,('**','sun')))\nprint clock()-te,'  generator function with groupby()'\n\nte = clock()\nfor i in xrange(n):\n    b = list(treat(p,('**','sun')))\nprint clock()-te,'  generator function eyquem'\n\n\nte = clock()\nfor i in xrange(n):\n    c = list(squeeze(p,('**','sun')))\nprint clock()-te,'  generator function John Machin'\n\nprint p\nprint 'a==b==c is ',a==b==c\nprint a\n</code>\n</pre>\n", "senID": 26}, {"text": ["The instruction"], "childNum": 0, "tag": "p", "senID": 27, "childList": []}, {"code": "<pre>\n<code>\n if hasattr(iterable, '__iter__') and not hasattr(to_compress, '__iter__'):\n    to_compress = (to_compress,)\n</code>\n</pre>\n", "senID": 28}, {"text": ["is necessary to avoid errors when the the iterable argument  is a sequence and the other argument only one string: this latter needs then to be modified into a container, provided that the iterable argument isn't  a string itself."], "childNum": 0, "tag": "p", "senID": 29, "childList": []}, {"text": ["It is based on the fact that sequences like tuples, lists, stes... have the method iter, but strings haven't.", "The following code shows the problems:"], "childNum": 1, "tag": "p", "senID": 30, "childList": [{"text": "iter", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def compress(iterable, to_compress):\n    if hasattr(iterable, '__iter__') and not hasattr( to_compress, '__iter__'):\n        to_compress = (to_compress,)\n    print 't_compress==',repr(to_compress)\n    for k, g in groupby(iterable):\n        if k in to_compress:\n            yield k\n        else:\n            for x in g: yield x\n\n\ndef compress_bof(iterable, to_compress):\n    if not hasattr(to_compress, '__iter__'): # to_compress is a string\n        to_compress = (to_compress,)\n    print 't_compress==',repr(to_compress)\n    for k, g in groupby(iterable):\n        if k in to_compress:\n            yield k\n        else:\n            for x in g: yield x\n\n\ndef compress_bug(iterable, to_compress_bug):\n    print 't_compress==',repr(to_compress_bug)\n    for k, g in groupby(iterable):\n        #print 'k==',k,k in to_compress_bug\n        if k in to_compress_bug:\n            yield k\n        else:\n            for x in g: yield x\n\n\nq = ';;;htr56;but78;;;;$$$$;ios4!'\nprint 'q==',q\ndedupl = \";$\"\nprint 'dedupl==',repr(dedupl)\nprint\n\nprint \"''.join(compress    (q,\"+repr(dedupl)+\")) :\\n\",''.join(compress    (q,dedupl))+\\\n      ' &lt;-CORRECT ONE'\nprint\nprint \"''.join(compress_bof(q,\"+repr(dedupl)+\")) :\\n\",''.join(compress_bof(q,dedupl))+\\\n      '  &lt;====== error ===='\nprint\nprint \"''.join(compress_bug(q,\"+repr(dedupl)+\")) :\\n\",''.join(compress_bug(q,dedupl))\n\nprint '\\n\\n\\n'\n\n\nq = [';$', ';$',';$','foo', ';', 'bar','bar',';',';',';','$','$','foo',';$12',';$12']\nprint 'q==',q\ndedupl = \";$12\"\nprint 'dedupl==',repr(dedupl)\nprint\nprint 'list(compress    (q,'+repr(dedupl)+')) :\\n',list(compress    (q,dedupl)),\\\n      ' &lt;-CORRECT ONE'\nprint\nprint 'list(compress_bof(q,'+repr(dedupl)+')) :\\n',list(compress_bof(q,dedupl))\nprint\nprint 'list(compress_bug(q,'+repr(dedupl)+')) :\\n',list(compress_bug(q,dedupl)),\\\n      '  &lt;====== error ===='\nprint\n</code>\n</pre>\n", "senID": 31}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 32, "childList": []}, {"code": "<pre>\n<code>\n q== ;;;htr56;but78;;;;$$$$;ios4!\ndedupl== ';$'\n\n''.join(compress    (q,';$')) :\nt_compress== ';$'\n;htr56;but78;$;ios4! &lt;-CORRECT ONE\n\n''.join(compress_bof(q,';$')) :\nt_compress== (';$',)\n;;;htr56;but78;;;;$$$$;ios4!  &lt;====== error ====\n\n''.join(compress_bug(q,';$')) :\nt_compress== ';$'\n;htr56;but78;$;ios4!\n\n\n\n\nq== [';$', ';$', ';$', 'foo', ';', 'bar', 'bar', ';', ';', ';', '$', '$', 'foo', ';$12', ';$12']\ndedupl== ';$12'\n\nlist(compress    (q,';$12')) :\nt_compress== (';$12',)\n[';$', ';$', ';$', 'foo', ';', 'bar', 'bar', ';', ';', ';', '$', '$', 'foo', ';$12']  &lt;-CORRECT ONE\n\nlist(compress_bof(q,';$12')) :\nt_compress== (';$12',)\n[';$', ';$', ';$', 'foo', ';', 'bar', 'bar', ';', ';', ';', '$', '$', 'foo', ';$12']\n\nlist(compress_bug(q,';$12')) :\nt_compress== ';$12'\n[';$', 'foo', ';', 'bar', 'bar', ';', '$', 'foo', ';$12']   &lt;====== error ====\n</code>\n</pre>\n", "senID": 33}, {"text": ["I obtained the following execution's time:"], "childNum": 0, "tag": "p", "senID": 34, "childList": []}, {"code": "<pre>\n<code>\n 0.390163274941   generator function with groupby()\n0.324547114228   generator function eyquem\n0.310176572721   generator function John Machin\n['**', '**', 'su', 'foo', '*', 'bar', 'bar', '**', '**', '**', 'su', 'su', '**', 'bin', '*', '*', 'bar', 'bar', 'su', 'su', 'su']\na==b==c is  True\n['**', 'su', 'foo', '*', 'bar', 'bar', '**', 'su', 'su', '**', 'bin', '*', '*', 'bar', 'bar', 'su', 'su', 'su']\n</code>\n</pre>\n", "senID": 35}, {"text": ["I prefer the solution of John Machin because there is no instruction B = iter(B) as in mine. "], "childNum": 0, "tag": "p", "senID": 36, "childList": []}, {"text": ["But the instruction previous = _dummy with _dummy = object() appears weird to me.", "So I finally think the better solution is the following code,  that works even with a string as iterable argument, and in which the first object previous being defined isn't a fake:"], "childNum": 2, "tag": "p", "senID": 37, "childList": [{"text": "previous = _dummy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "_dummy = object()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def squeeze(iterable, victims):\n    if hasattr(iterable, '__iter__') and not hasattr(victims, '__iter__'):\n        victims = (victims,)\n    for item in iterable:\n        previous = item\n        break\n    for item in iterable:\n        if item in victims and item==previous:\n            continue\n        previous = item\n        yield item\n</code>\n</pre>\n", "senID": 38}, {"text": [], "childNum": 0, "tag": "p", "senID": 39, "childList": []}, {"text": ["EDIT 3"], "childNum": 0, "tag": "h2", "senID": 40, "childList": []}, {"text": ["I had undesrtood that object() was used as a sentinel. "], "childNum": 1, "tag": "p", "senID": 41, "childList": [{"text": "object()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["But I was puzzled by the fact object is CALLED.", "Yesterday, I was thinking that object is something so peculiar that it is impossible that object  be in any iterable passed as an argument to squeeze().", "So, I was wondering why you called it, John Machin, and that sowed doubt in my mind concerning its nature; that's why I asked you a confirmation that object is the super meta-class."], "childNum": 4, "tag": "p", "senID": 42, "childList": [{"text": "object", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "object", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "object", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "object", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["But today, I think I understand why object is called in your code. "], "childNum": 1, "tag": "p", "senID": 43, "childList": [{"text": "object", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["In fact, it is quite possible that object be in an iterable, why not ?", "Super meta-class object is an object, so nothing prevents it to have been put in the iterable before a de-duplication is processed on the iterable, who knows ?", "Then using object itself as a sentinel is incorrect practice."], "childNum": 3, "tag": "p", "senID": 44, "childList": [{"text": "object", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "object", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "object", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 45, "childList": []}, {"text": ["So you didn't use object but an instance object() as a sentinel."], "childNum": 2, "tag": "p", "senID": 46, "childList": [{"text": "object", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "object()", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["But I wondered why to choose this mysterious thing that the return of a call to object is ?"], "childNum": 1, "tag": "p", "senID": 47, "childList": [{"text": "object", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["My reflections went on about this point and I remarked something that must be the reason of this call:"], "childNum": 0, "tag": "p", "senID": 48, "childList": []}, {"text": ["calling object creates an instance , since object is the most base class in Python, and each time an instance is created, it is a different object from any prior created instance, with a value always different from the value of any prior object's instance:"], "childNum": 3, "tag": "p", "senID": 49, "childList": [{"text": "object", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "object", "childNum": 0, "tag": "strong", "childList": []}, {"text": "object", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n a = object()\nb = object()\nc = object()\nd = object()\n\nprint id(a),'\\n',id(b),'\\n',id(c),'\\n',id(d)\n\nprint a==b,a==c,a==d\nprint b==c,b==d,c==d\n</code>\n</pre>\n", "senID": 50}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 51, "childList": []}, {"code": "<pre>\n<code>\n 10818752 \n10818760 \n10818768 \n10818776\nFalse False False\nFalse False False\n</code>\n</pre>\n", "senID": 52}, {"text": ["So it is sure that  _dummy=object()  is a unique object, having a unique id and a unique value.", "By the way , I wonder what is the value of an object's instance.", "Anyway the following code shows the problem with _dummy=object  and the absence of problem with _dummy=object() "], "childNum": 5, "tag": "p", "senID": 53, "childList": [{"text": "_dummy=object()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "id", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "object", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "_dummy=object", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "_dummy=object()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def imperfect_squeeze(iterable, victim, _dummy=object):\n    previous = _dummy\n    print 'id(previous)   ==',id(previous)\n    print 'id(iterable[0])==',id(iterable[0])\n    for item in iterable:\n        if item in victim and item==previous:  continue\n        previous = item; yield item\n\ndef squeeze(iterable, victim, _dummy=object()):\n    previous = _dummy\n    print 'id(previous)   ==',id(previous)\n    print 'id(iterable[0])==',id(iterable[0])\n    for item in iterable:\n        if item in victim and item==previous:  continue\n        previous = item; yield item\n\nwat = object\nli = [wat,'**','**','foo',wat,wat]\nprint 'imperfect_squeeze\\n''li before ==',li\nprint map(id,li)\nli = list(imperfect_squeeze(li,[wat,'**']))\nprint 'li after  ==',li\nprint\n\n\nwat = object()\nli = [wat,'**','**','foo',wat,wat]\nprint 'squeeze\\n''li before ==',li\nprint map(id,li)\nli = list(squeeze(li,[wat,'**']))\nprint 'li after  ==',li\nprint\n\n\nli = [object(),'**','**','foo',object(),object()]\nprint 'squeeze\\n''li before ==',li\nprint map(id,li)\nli = list(squeeze(li,[li[0],'**']))\nprint 'li after  ==',li\n</code>\n</pre>\n", "senID": 54}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 55, "childList": []}, {"code": "<pre>\n<code>\n imperfect_squeeze\nli before == [&lt;type 'object'&gt;, '**', '**', 'foo', &lt;type 'object'&gt;, &lt;type 'object'&gt;]\n[505317320, 18578968, 18578968, 13208848, 505317320, 505317320]\nid(previous)   == 505317320\nid(iterable[0])== 505317320\nli after  == ['**', 'foo', &lt;type 'object'&gt;]\n\nsqueeze\nli before == [&lt;object object at 0x00A514C8&gt;, '**', '**', 'foo', &lt;object object at 0x00A514C8&gt;, &lt;object object at 0x00A514C8&gt;]\n[10818760, 18578968, 18578968, 13208848, 10818760, 10818760]\nid(previous)   == 10818752\nid(iterable[0])== 10818760\nli after  == [&lt;object object at 0x00A514C8&gt;, '**', 'foo', &lt;object object at 0x00A514C8&gt;]\n\nsqueeze\nli before == [&lt;object object at 0x00A514D0&gt;, '**', '**', 'foo', &lt;object object at 0x00A514D8&gt;, &lt;object object at 0x00A514E0&gt;]\n[10818768, 18578968, 18578968, 13208848, 10818776, 10818784]\nid(previous)   == 10818752\nid(iterable[0])== 10818768\nli after  == [&lt;object object at 0x00A514D0&gt;, '**', 'foo', &lt;object object at 0x00A514D8&gt;, &lt;object object at 0x00A514E0&gt;]\n</code>\n</pre>\n", "senID": 56}, {"text": ["The problem is consisting in the absence of &lt;type 'object'&gt;   as first element of the list after treatment by imperfect_squeeze() . "], "childNum": 2, "tag": "p", "senID": 57, "childList": [{"text": "&lt;type 'object'&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "imperfect_squeeze()", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["However, we must note that the \"problem\" is possible only with a list whose FIRST element is object: that's a lot of reflections about such a tiny probability.... but a rigorous coder takes account of all. "], "childNum": 1, "tag": "p", "senID": 58, "childList": [{"text": "object", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If we resort to list, instead of object , the results are different:"], "childNum": 2, "tag": "p", "senID": 59, "childList": [{"text": "list", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "object", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n def imperfect_sqlize(iterable, victim, _dummy=list):\n    previous = _dummy\n    print 'id(previous)   ==',id(previous)\n    print 'id(iterable[0])==',id(iterable[0])\n    for item in iterable:\n        if item in victim and item==previous:  continue\n        previous = item; yield item\n\ndef sqlize(iterable, victim, _dummy=list()):\n    previous = _dummy\n    print 'id(previous)   ==',id(previous)\n    print 'id(iterable[0])==',id(iterable[0])\n    for item in iterable:\n        if item in victim and item==previous:  continue\n        previous = item; yield item\n\nwat = list\nli = [wat,'**','**','foo',wat,wat]\nprint 'imperfect_sqlize\\n''li before ==',li\nprint map(id,li)\nli = list(imperfect_sqlize(li,[wat,'**']))\nprint 'li after  ==',li\nprint\n\nwat = list()\nli = [wat,'**','**','foo',wat,wat]\nprint 'sqlize\\n''li before ==',li\nprint map(id,li)\nli = list(sqlize(li,[wat,'**']))\nprint 'li after  ==',li\nprint\n\nli = [list(),'**','**','foo',list(),list()]\nprint 'sqlize\\n''li before ==',li\nprint map(id,li)\nli = list(sqlize(li,[li[0],'**']))\nprint 'li after  ==',li\n</code>\n</pre>\n", "senID": 60}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 61, "childList": []}, {"code": "<pre>\n<code>\n imperfect_sqlize\nli before == [&lt;type 'list'&gt;, '**', '**', 'foo', &lt;type 'list'&gt;, &lt;type 'list'&gt;]\n[505343304, 18578968, 18578968, 13208848, 505343304, 505343304]\nid(previous)   == 505343304\nid(iterable[0])== 505343304\nli after  == ['**', 'foo', &lt;type 'list'&gt;]\n\nsqlize\nli before == [[], '**', '**', 'foo', [], []]\n[18734936, 18578968, 18578968, 13208848, 18734936, 18734936]\nid(previous)   == 18734656\nid(iterable[0])== 18734936\nli after  == ['**', 'foo', []]\n\nsqlize\nli before == [[], '**', '**', 'foo', [], []]\n[18734696, 18578968, 18578968, 13208848, 18735016, 18734816]\nid(previous)   == 18734656\nid(iterable[0])== 18734696\nli after  == ['**', 'foo', []]\n</code>\n</pre>\n", "senID": 62}, {"text": ["Is there any other object than object in Python that have this peculiarity ?"], "childNum": 1, "tag": "p", "senID": 63, "childList": [{"text": "object", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["John Machin, why did you choose an instance of object as a sentinel in your generator function ?", "Did you already know the above peculiarity ?"], "childNum": 1, "tag": "p", "senID": 64, "childList": [{"text": "object", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["A generalised \"pythonic\" solution that works with any iterable (no backing up, no copying, no indexing, no slicing, doesn't fail if iterable is empty) and any thing-to-squeeze (including None):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "any", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "including None", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; test = ['**', 'foo', '*', 'bar', 'bar', '**', '**', '**', 'baz', '**', '**',\n...      'foo', '*','*', 'bar', 'bar','bar', '**', '**','foo','bar',]\n&gt;&gt;&gt;\n&gt;&gt;&gt; def squeeze(iterable, victim, _dummy=object()):\n...     previous = _dummy\n...     for item in iterable:\n...         if item == victim == previous: continue\n...         previous = item\n...         yield item\n...\n&gt;&gt;&gt; print test\n['**', 'foo', '*', 'bar', 'bar', '**', '**', '**', 'baz', '**', '**', 'foo', '*'\n, '*', 'bar', 'bar', 'bar', '**', '**', 'foo', 'bar']\n&gt;&gt;&gt; print list(squeeze(test, \"**\"))\n['**', 'foo', '*', 'bar', 'bar', '**', 'baz', '**', 'foo', '*', '*', 'bar', 'bar\n', 'bar', '**', 'foo', 'bar']\n&gt;&gt;&gt; print list(squeeze([\"**\"], \"**\"))\n['**']\n&gt;&gt;&gt; print list(squeeze([\"**\", \"**\"], \"**\"))\n['**']\n&gt;&gt;&gt; print list(squeeze([], \"**\"))\n[]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Update for the edification of @eyquem who stated that victim could not be a sequence (or, presumably a set)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "victim", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Having a container of victims means that there are two possible semantics:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def squeeze2(iterable, victims, _dummy=object()):\n...     previous = _dummy\n...     for item in iterable:\n...         if item == previous in victims: continue\n...         previous = item\n...         yield item\n...\n&gt;&gt;&gt; def squeeze3(iterable, victims, _dummy=object()):\n...     previous = _dummy\n...     for item in iterable:\n...         if item in victims and previous in victims: continue\n...         previous = item\n...         yield item\n...\n&gt;&gt;&gt; guff = \"c...d..e.f,,,g,,h,i.,.,.,.j\"\n&gt;&gt;&gt; print \"\".join(squeeze2(guff, \".,\"))\nc.d.e.f,g,h,i.,.,.,.j\n&gt;&gt;&gt; print \"\".join(squeeze3(guff, \".,\"))\nc.d.e.f,g,h,i.j\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 4}], [{"text": ["This is in my opinion pythonic"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n result = [v for i, v in enumerate(L) if L[i:i+2] != [\"**\", \"**\"]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["the only \"trickery\" being used is that L[i:i+2] is a list of one element when i == len(L)-1."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "L[i:i+2]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "i == len(L)-1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Note that of course the very same expression can also be used as a generator"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]