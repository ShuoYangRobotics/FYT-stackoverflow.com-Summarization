[[{"text": ["As others mention, you can implement the test with a simple word.count('e').", "Unless you're doing this as a simple exercise, this is far better than trying to reinvent the wheel."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "word.count('e')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The problem with your code is that it counts the last character twice because you are testing index -1 at the end, which in Python returns the last character in the string.", "Fix it by changing while letters &gt;= 0 to while letters &gt; 0."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "-1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "while letters &gt;= 0", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "while letters &gt; 0", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["There are other ways you can tidy up your code (assuming this is an exercise in learning):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Python provides a nice way of iterating over a string using a ", "tag": "none", "senID": 3}, {"text": "Most languages provide a ", "tag": "none", "senID": 4}, {"text": "Use a parameter to define which character you're counting to make it more flexible. Define a default argument for using ", "tag": "none", "senID": 5}, {"text": "Choose a more appropriate name for the function. The name ", "tag": "none", "senID": 6}]}, {"text": ["Putting this all together we get:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def count_letter(word, char='e'):\n    count = 0\n    for c in word:\n        if c == char:\n            count += 1\n    return count\n</code>\n</pre>\n", "senID": 8}, {"text": ["Some tests:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; count_letter('tee')\n2\n&gt;&gt;&gt; count_letter('tee', 't')\n1\n&gt;&gt;&gt; count_letter('tee', 'f')\n0\n&gt;&gt;&gt; count_letter('wh' + 'e'*100)\n100\n</code>\n</pre>\n", "senID": 10}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; word = 'eeeooooohoooooeee'\n&gt;&gt;&gt; word.count('e')\n6\n</code>\n</pre>\n", "senID": 0}, {"text": ["Why not this?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Why not simply"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def has_no_e(word):\n    return sum(1 for letter in word if letter==\"e\")\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You don't have to use a while-loop.", "Strings can be used for-loops in Pyhton."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def has_no_e(word):\n    count = 0\n    for letter in word:\n        if letter == \"e\":\n            count += 1\n    print count\n</code>\n</pre>\n", "senID": 1}, {"text": ["or something simpler:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def has_no_e(word):\n    return sum(1 for letter in word if letter==\"e\")\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The problem is that the last value of 'letters' in your iteration is '0', and when this happens you look at:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n word[letters-1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["meaning, you look at word[-1], which in python means \"last letter of the word\".", "so you're actually counting correctly, and adding a \"bonus\" one if the last letter is 'e'.  "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}], [{"text": ["It will count it twice when ending with an e because you decrement letters one time too many (because you loop while letters &gt;= 0 and you should be looping while letters &gt; 0).", "When letters reaches zero you check word[letters-1] == word[-1] which corresponds to the last character in the word."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "letters", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "letters &gt;= 0", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "letters &gt; 0", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "letters", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "word[letters-1]", "childNum": 0, "tag": "code", "childList": []}, {"text": "word[-1]", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Many of these suggested solutions will work fine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Know that, in Python, list[-1] will return the last element of the list."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So, in your original code, when you were referencing word[letters-1] in a while loop constrained by letters >= 0, you would count the 'e' on the end of the word twice (once when letters was the length-1 and a second time when letters was 0)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For example, if my word was \"Pete\" your code trace would look like this (if you printed out word[letter] each loop."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["e (for word[3])\nt (for word[2])\ne (for word[1])\nP (for word[0])\ne (for word[-1])"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Hope this helps to clear things up and to reveal an interesting little quirk about Python."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["@marcog makes some excellent points;"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["in the meantime, you can do simple debugging by inserting print statements -"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def has_no_e(word):\n    letters = len(word)\n    count = 0\n    while letters &gt;= 0:\n        ch = word[letters-1]         # what is it looking at?\n        if ch == 'e':\n            count = count + 1\n            print('{0} &lt;-'.format(ch))\n        else:\n            print('{0}'.format(ch))\n        letters = letters - 1\n    print count\n</code>\n</pre>\n", "senID": 2}, {"text": ["then"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n has_no_e('tease')\n</code>\n</pre>\n", "senID": 4}, {"text": ["returns"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n e &lt;-\ns\na\ne &lt;-\nt\ne &lt;-\n3\n</code>\n</pre>\n", "senID": 6}, {"text": ["from which you can see that"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["If what you really want is 'has_no_e' then the following may be more appropriate than counting 'e's and then later checking for zero,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def has_no_e(word):\n  return 'e' not in word\n\n&gt;&gt;&gt; has_no_e('Adrian')\nTrue\n&gt;&gt;&gt; has_no_e('test')\nFalse\n&gt;&gt;&gt; has_no_e('NYSE')\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want to check there are no 'E's either,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def has_no_e(word):\n  return 'e' not in word.lower()\n\n&gt;&gt;&gt; has_no_e('NYSE')\nFalse\n</code>\n</pre>\n", "senID": 3}]]