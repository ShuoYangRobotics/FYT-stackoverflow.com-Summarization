[[{"text": ["I don't know a general purpose langugae that can do that, but it seems to me that you are looking for something like XPath."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "XPath", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/XPath"}]}], [{"text": ["There is TXL for pattern based tree rewriting."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "TXL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.txl.ca/"}]}, {"text": ["Tree rewriting with patterns is also done with parser toolkits such as ANTLR"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "ANTLR", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.antlr.org/wiki/display/~admin/2008/11/30/Example%2Btree%2Brewriting%2Bwith%2Bpatterns"}]}, {"text": ["Code generation with bottom up tree rewriting, google BURS or BURG."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["TSurgeon and Tregex from Stanford is capable of doing that.", "You can download the library from http://nlp.stanford.edu/software/tregex.shtml"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://nlp.stanford.edu/software/tregex.shtml", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://nlp.stanford.edu/software/tregex.shtml"}]}], [{"text": ["Navigating through a binary search tree requires state (in which node I am?", ") and comparisons (is that value less or greater than that?", "), things that cannot be done by a finite state automaton."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Sure, you can search for the node with a given value, but how then you could, for example, remove a node that isn't a leaf if you don't know its parent?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["And even if you know the parent via the information supplied by the node, how do you determine the minimum of the left subtree, remove it and place it in the node?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I think you're asking too much to FSA."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This article gives some tasty hints about recursive Perl regular expressions, but honestly it's rare to see a tree structure approached this way."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "This", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.perl.com/pub/a/2003/06/06/regexps.html"}]}, {"text": ["More typically, one would write a state machine style parser, that might use regexes to parse each particular node in the tree."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Expat is probably a good example to look at."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Expat", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://expat.sourceforge.net/"}]}], [{"text": ["Pattern Matching, provided by languages such as Scala, F#, Erlang and Haskell (I'm sure there's more) is designed to succinctly manipulate data structures like trees, esp when used with recursion. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["here is a very high level view of what pattren matching can do in Scala.", "The examples shown really don't do pattern matching justice. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.scala-lang.org/node/120"}]}, {"text": ["Wikipedia has a couple of references to pattern matching, too.", "Here and here."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikibooks.org/wiki/Haskell/Pattern%5Fmatching"}, {"href": "http://en.wikipedia.org/wiki/Pattern%5FMatching#Tree%5Fpatterns%5Ffor%5Fstrings", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I'm somewhat surprised that XSLT hasn't come up as an answer.", "Granted, I don't think it's a particularly elegant language, and most existent solutions tend to favour procedural approaches rather than pattern matching, and it's gotten a mighty bad rep from being blindly applied just because it's XML being applied to XML -- but otherwise it fits the bill.", "Pity its canonical representation is so verbose, though... "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "XSLT", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.w3schools.com/xsl/"}]}]]