[[{"text": ["You can think of it as if the function which yields simply \"pauses\" when it comes across the yield.", "The next time you call it, it will resume after the yield keeping the state that it was in when it left. "], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "yield", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "yield", "childNum": 0, "tag": "code", "childList": []}, {"text": "keeping the state that it was in when it left", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["..you cannot explain the meaning of the yield statement without mentioning generators; it would be like trying to explain what a stone is without mentioning rock.", "That is: the yield statement is the one responsible to transform a normal function into a generator."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["While you find it well documented here: http://docs.python.org/reference/simple_stmts.html#the-yield-statement"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/reference/simple_stmts.html#the-yield-statement", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/simple_stmts.html#the-yield-statement"}]}, {"text": ["..the brief explaination of it is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "When a function using the yield statement is called, it returns a \"generator iterator\", having a ", "tag": "none", "senID": 3}, {"text": "Each time the ", "tag": "none", "senID": 4}, {"text": "The next time ", "tag": "none", "senID": 5}]}, {"text": ["Some advantages in doing this are:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "less memory usage since memory is allocated just for the currently yielded value, not the whole list of returned values (as it would be by returning a list of values)", "tag": "none", "senID": 7}, {"text": "\"realtime\" results return, as they are produced can be passed to the caller without waiting for the generation end (i used that to return output from a running process)", "tag": "none", "senID": 8}]}], [{"text": ["No, there is only a single thread."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Each iteration of the for loop runs your countFrom function until it yields something, or returns.", "After the yield, the body of the for loop runs again and then, when a new iteration starts, the countFrom function picks up exactly where it left off and runs again until it yields (or returns)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "countFrom", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "countFrom", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This modified version of your example will helpfully make it clearer what path execution takes."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def countfrom(n):\n    while n &lt;= 12:\n        print \"before yield, n = \", n\n        yield n\n        n += 1\n        print \"after yield, n = \", n\n\nfor i in countfrom(10):\n    print \"enter for loop, i = \", i\n    print i\n    print \"end of for loop iteration, i = \", i\n</code>\n</pre>\n", "senID": 3}, {"text": ["Output"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Output", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n before yield, n =  10\nenter for loop, i =  10\n10\nend of for loop iteration, i =  10\nafter yield, n =  11\nbefore yield, n =  11\nenter for loop, i =  11\n11\nend of for loop iteration, i =  11\nafter yield, n =  12\nbefore yield, n =  12\nenter for loop, i =  12\n12\nend of for loop iteration, i =  12\nafter yield, n =  13\n</code>\n</pre>\n", "senID": 5}], [{"text": ["The function countfrom is not run in a parallel thread.", "What happens here is that whenever the for-construct asks for the next value, the function will execute until it hits a yield statement.", "When the next value after that is required, the function resumes execution from where it left off."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "countfrom", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "yield", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["And while you asked not to mention \"generators\", they are so intimately linked with yield that it doesn't really make sense to talk about the separately.", "What your countfrom function actually returns is a \"generator object\".", "It returns this object immediately after it is called, so the function body is not executed at all until something (e.g.", "a for-loop) requests values from the generator using its method .next()."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "countfrom", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": ".next()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["the yield statement stores the value that you yield, until that function is called again.", "so if you call that function (with an iterator) it will run the function another time and give you the value.", "the point being that it knows where it left off last time"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Python runs until it hits a yield and then stops and freezes execution.", "It's not continuing to run.", "It's hitting \"after\" on the next call to countfrom"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "countfrom", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["It's easy to say that without making reference to generators but the fact is yield and generator are inextricably linked.", "To really understand it you've got to view them as the same topic. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It's easy to show yourself that what I (and others) have said is true by working with the generator from your example in a more manual way. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["A function that yields instead of returning really returns a generator.", "You can then consume that generator by calling next.", "You are confused because your loop is taking care of all that in the background for you."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "next", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Here it is with the internals opened up:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def countfrom(n):\n    while n &lt;= 12:\n        print \"before yield, n = \", n\n        yield n\n        n += 1\n        print \"after yield, n = \", n\n\n\nyour_generator = countfrom(10)\nnext(your_generator)\nprint \"see the after yield hasn't shown up yet, it's stopped at the first yield\"\nnext(your_generator)\nprint \"now it woke back up and printed the after... and continued through the loop until it got to back to yield\"\nnext(your_generator)\nprint \"rinse and repeate\"\n</code>\n</pre>\n", "senID": 5}]]