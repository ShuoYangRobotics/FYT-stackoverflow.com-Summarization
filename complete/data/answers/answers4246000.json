[[{"text": ["Global is a very very bad way of doing this.", "You should be doing it this way."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fields = {'name':clean_name,'email':clean_email}\n\nfor key in fields:\n    fields[key]()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit2: Map your functions to values in a dictionary "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: Also using vars()[] is wrong too."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["It would be better to have dictionary of such functions than to look in globals().", "Usual approach is to write a class with such functions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Cleaner(object):\n    def clean_name(self):\n        pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["and then use getattr to get access to them:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n cleaner = Cleaner()\nfor f in fields:\n    getattr(cleaner, 'clean_%s' % f)()\n</code>\n</pre>\n", "senID": 3}, {"text": ["You could even move further and do something like that:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class Cleaner(object):\n    def __init__(self, fields):\n        self.fields = fields\n\n    def clean(self):\n        for f in self.fields:\n            getattr(self, 'clean_%s' % f)()\n</code>\n</pre>\n", "senID": 5}, {"text": ["Then just inherit it and declare your clean_&lt;name&gt; methods on an inherited class and use like that:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "clean_&lt;name&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n cleaner = Cleaner(['one', 'two'])\ncleaner.clean()\n</code>\n</pre>\n", "senID": 7}, {"text": ["Actually this can be extended even further to make it more clean (first step probably will be adding check with hasattr() if such method exists on your class), that's just a start."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "hasattr()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["And, finally, if don't want to use globals, vars and don't want make a separate module and/or class to encapsulate functions you want to call dynamically, you can call them as the attributes of the current module:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "globals, vars", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import sys\n...\ngetattr(sys.modules[__name__], \"clean_%s\" % fieldname)()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["globals() will give you a dict of the global namespace.", "From this you can get the function you want:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "globals()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n f = globals()[\"clean_%s\" % field]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then call it:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n f()\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n for field in fields:\n    vars()['clean_' + field]()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Another one way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["myscript.py"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def f1():\n    print 'f1'\n\ndef f2():\n    print 'f2'\n\ndef f3():\n    print 'f3'\n</code>\n</pre>\n", "senID": 2}, {"text": ["test.py"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import myscript\n\nfor i in range(1, 4):\n    getattr(myscript, 'f%d' % i)()\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I would use a dictionary which mapped field names to cleaning functions.", "If some fields don't have corresponding cleaning function, the for loop handling them can be kept simple by providing some sort of default function for those cases.", "Here's what I mean:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n fields = ['name', 'email', 'subject']\n\ndef clean_name():\n    pass\ndef clean_email():\n    pass\n\n# (one-time) field to cleaning-function map construction\ndef get_clean_func(field):\n    try:\n        return eval('clean_'+field)\n    except NameError:\n        return lambda: None  # do nothing\nclean = dict((field, get_clean_func(field)) for field in fields)\n\n# sample usage\nfor field in fields:\n    clean[field]()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The code above constructs the function dictionary dynamically by determining if a corresponding function named clean_&lt;field&gt; exists for each one named in the fields list.", "You likely would only have to execute it once since it would remain the same as long as the field list or available cleaning functions aren't changed."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "clean_&lt;field&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fields", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Here's another way: define the functions then define a dict with the names as keys:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; z=[clean_email, clean_name]\n&gt;&gt;&gt; z={\"email\": clean_email, \"name\":clean_name}\n&gt;&gt;&gt; z['email']()\n&gt;&gt;&gt; z['name']()\n</code>\n</pre>\n", "senID": 1}, {"text": ["then you loop over the names as keys."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["or how about this one?", "Construct a string and use 'eval':"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; field = \"email\"\n&gt;&gt;&gt; f=\"clean_\"+field+\"()\"\n&gt;&gt;&gt; eval(f)\n</code>\n</pre>\n", "senID": 4}, {"text": ["then just loop and construct the strings for eval."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Note that any method that requires constructing a string for evaluation is regarded as kludgy."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]