[[{"text": ["The subprocess.Popen.wait() is the only way to assure that they're dead.", "Indeed, POSIX OS's require that you wait on your children.", "Many *nix's will create a \"zombie\" process:  a dead child for which the parent didn't wait."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "subprocess.Popen.wait()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If the child is reasonably well-written, it terminates.", "Often, children read from PIPE's.", "Closing the input is a big hint to the child that it should close up shop and exit."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If the child has bugs and doesn't terminate, you may have to kill it.", "You should fix this bug.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If the child is a \"serve-forever\" loop, and is not designed to terminate, you should either kill it or provide some input or message which will force it to terminate.  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "hr", "senID": 4}, {"text": ["Edit."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["In standard OS's, you have os.kill( PID, 9 ).", "Kill -9 is harsh, BTW.", "If you can kill them with SIGABRT (6?", ") or SIGTERM (15) that's more polite."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "os.kill( PID, 9 )", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In Windows OS, you don't have an os.kill that works.", "Look at this ActiveState Recipe for terminating a process in Windows."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "os.kill", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ActiveState Recipe", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/347462/"}]}, {"text": ["We have child processes that are WSGI servers.", "To terminate them we do a GET on a special URL; this causes the child to clean up and exit."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["You can use atexit for this, and register any clean up tasks to be run when your program exits. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "atexit", "tag": "a", "pos": 0, "childList": [{"text": "atexit", "tag": "strong"}], "childNum": 1, "href": "http://docs.python.org/library/atexit.html"}, {"text": "atexit", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["atexit.register(func[, *args[, **kargs]])"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "atexit.register(func[, *args[, **kargs]])", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["In your cleanup process, you can also implement your own wait, and kill it when a your desired timeout occurs."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import atexit\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; \n&gt;&gt;&gt; \n&gt;&gt;&gt;\n&gt;&gt;&gt; def cleanup():\n...     timeout_sec = 5\n...     for p in all_processes: # list of your processes\n...         p_sec = 0\n...         for second in range(timeout_sec):\n...             if p.poll() == None:\n...                 time.sleep(1)\n...                 p_sec += 1\n...         if p_sec &gt;= timeout_sec:\n...             p.kill() # supported from python 2.6\n...     print 'cleaned up!'\n...\n&gt;&gt;&gt;\n&gt;&gt;&gt; atexit.register(cleanup)\n&gt;&gt;&gt;\n&gt;&gt;&gt; sys.exit()\ncleaned up!\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note -- Registered functions won't be run if this process (parent process) is killed."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Note", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Here's a way to kill a process in windows.", "Your Popen object has a pid attribute, so you can just call it by success = win_kill(p.pid) (Needs pywin32 installed):"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "success = win_kill(p.pid)", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"href": "http://sourceforge.net/projects/pywin32/", "text": "pywin32", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n def win_kill(pid):\n        '''kill a process by specified PID in windows'''\n        import win32api\n        import win32con\n\n        hProc = None\n        try:\n            hProc = win32api.OpenProcess(win32con.PROCESS_TERMINATE, 0, pid)\n            win32api.TerminateProcess(hProc, 0)\n        except Exception:\n            return False\n        finally:\n            if hProc != None:\n                hProc.Close()\n\n        return True\n</code>\n</pre>\n", "senID": 6}], [{"text": ["On *nix's, maybe using process groups can help you out - you can catch subprocesses spawned by your subprocesses as well."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if __name__ == \"__main__\":\n  os.setpgrp() # create new process group, become its leader\n  try:\n    # some code\n  finally:\n    os.killpg(0, signal.SIGKILL) # kill all processes in my group\n</code>\n</pre>\n", "senID": 1}, {"text": ["Another consideration is to escalate the signals: from SIGTERM (default signal for kill) to SIGKILL (a.k.a kill -9).", "Wait a short while between the signals to give the process a chance to exit cleanly before you kill -9 it."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "kill", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "kill -9", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "kill -9", "childNum": 0, "tag": "code", "childList": []}]}], [], [{"text": ["You could violate encapsulation and test that all Popen processes have terminated by doing"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "test", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n subprocess._cleanup()\nprint subprocess._active == []\n</code>\n</pre>\n", "senID": 1}, {"text": ["You cannot ensure that all subprocesses are dead without going out and killing every survivor.", "But if you have this problem, it is probably because you have a deeper design problem."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This is what I did for my posix app:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When your app exists call the kill() method of this class:\nhttp://www.pixelbeat.org/libs/subProcess.py"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.pixelbeat.org/libs/subProcess.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.pixelbeat.org/libs/subProcess.py"}]}, {"text": ["Example use here:\nhttp://code.google.com/p/fslint/source/browse/trunk/fslint-gui#608"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://code.google.com/p/fslint/source/browse/trunk/fslint-gui#608", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/fslint/source/browse/trunk/fslint-gui#608"}]}]]