[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; albums_today = ['album1', 'album2', 'album3']\n&gt;&gt;&gt; albums_yesterday = ['album2', 'album1', 'album3']\n&gt;&gt;&gt; D = dict((k,v) for v,k in enumerate(albums_yesterday))\n&gt;&gt;&gt; dict((k,D[k]-v) for v,k in enumerate(albums_today))\n{'album1': 1, 'album3': 0, 'album2': -1}\n</code>\n</pre>\n", "senID": 0}, {"text": ["In Python2.7 or Python3 it can be written even more simply"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; albums_today = ['album1', 'album2', 'album3']\n&gt;&gt;&gt; albums_yesterday = ['album2', 'album1', 'album3']\n&gt;&gt;&gt; D = {k:v for v,k in enumerate(albums_yesterday)}\n&gt;&gt;&gt; {k:D[k]-v for v,k in enumerate(albums_today)}\n{'album1': 1, 'album3': 0, 'album2': -1}\n</code>\n</pre>\n", "senID": 2}], [{"text": ["how about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def delta(a, b):\n    rank_a = dict((k, v) for v, k in enumerate(a))\n    rank_b = enumerate(b)\n    return dict((k, rank_a[k]-i) for i, k in rank_b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["which only creates a single dict to look things up into.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Well, as long as every entry in both lists are present exactly once each, then we know that once we look a key up in the rank_a collection, we don't need it anymore.", "We can delete it.", "Also, to save space, we don't have to populate that collection until the moment a particular key is needed."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class LookupOnce:\n    def __init__(self, seq):\n        self.cache = {}\n        self.seq = iter(seq)\n    def get(self, key):\n        if key in self.cache:\n            value = self.cache[key]\n            del self.cache[key]\n            return value\n        for v,k in self.seq:\n            if k == key:\n                return v\n            self.cache[k] = v\n        raise KeyError\n\n\ndef delta(a, b):\n    rank_a = LookupOnce(enumerate(a))\n    rank_b = enumerate(b)\n    result = {}\n    for i, k in rank_b:\n        result[k] = i - rank_a.get(k)\n    return result\n</code>\n</pre>\n", "senID": 4}], [{"text": ["you could also use the same algorithm as i wrote above and just use a single hashmap."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def findDelta1(today,yesterday):\n results = {}\n ypos = 0\n for i,title in enumerate(today):\n      if title in results:\n           results[title] = results[title] - i\n      else:\n           for ypos in xrange(ypos,len(yesterday)):\n                if yesterday[ypos] == title:\n                     results[title] = ypos - i\n                     ypos = ypos + 1\n                     break\n                else:\n                     results[yesterday[ypos]] = ypos\n return results\n</code>\n</pre>\n", "senID": 1}, {"text": ["still O(N), potentially faster and less RAM than my version above."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; def transform(albums):\n...     return dict((album, i) for i, album in enumerate(albums))\n... \n&gt;&gt;&gt; def show_diffs(album1, album2):\n...     album_dict1, album_dict2  = transform(album1), transform(album2)\n...     for k, v in sorted(album_dict1.iteritems()):\n...         print k, album_dict2[k] - v\n... \n&gt;&gt;&gt; albums_today = ['album1', 'album2', 'album3']\n&gt;&gt;&gt; albums_yesterday = ['album2', 'album1', 'album3']\n&gt;&gt;&gt; show_diffs(albums_today, albums_yesterday)\nalbum1 1\nalbum2 -1\nalbum3 0\n</code>\n</pre>\n", "senID": 0}], [{"text": ["well, depending on what the sizes of your lists are, there are a number of different approaches.", "without knowing how big your datasets are, i'd suggest that the simplest (perhaps unnecessarily optimized) method is something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n albums_yesterday_lookup = new HashMap();\ndifferences = new HashMap();\nforeach(albums_yesterday as position =&gt; album_title)\n    albums_yesterday_lookup.put(album_title,position);\n\nforeach(albums_today as position =&gt; album_title)\n    differences.put(album_title, albums_yesterday_lookup.get(album_title) - position);\n</code>\n</pre>\n", "senID": 1}, {"text": ["which runs as O(N)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["New and Improved and not O(n2): But still slower than two of the other answers."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "New and Improved and not O(n2)", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "2", "tag": "sup"}]}, {"text": "2", "childNum": 0, "tag": "sup", "childList": []}]}, {"text": ["The only advantage of this solution is memory savings.", "It avoids building a big dict and instead stores only what is necessary at the time.", "TokenMacGuy's second solution does this as well but this is slightly faster."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def get_deltas_aas(today, yesterday):\n    deltas = {}\n    for (new_rank, new_album), (old_rank, old_album) in \\\n            itertools.izip(enumerate(today), enumerate(yesterday)):\n        if old_album in deltas:\n            #Believe it or not, this is faster than deltas.pop(old_album) + old_rank\n            yield (old_album, deltas[old_album] + old_rank)\n            del deltas[old_album]    \n        else:\n            deltas[old_album] = old_rank\n\n        if new_album in deltas:\n            yield (new_album, deltas[new_album] - new_rank)\n            del deltas[new_album]\n        else:\n            deltas[new_album] = -new_rank\n</code>\n</pre>\n", "senID": 2}, {"text": ["Here's some timing results for most of the answers here (all of the ones in Python unless I missed something).", "dict ordering is in effect.", "If anybody wants me to change their code in any way, just ping me."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n get_deltas_token1: 1.08131885529 msecs\nget_deltas_gnibbler: 1.06443881989 msecs\nget_deltas_tyler: 1.61993408203 msecs\nget_deltas_token2: 1.52525019646 msecs\nget_deltas_hughdbrown: 3.27240777016 msecs\nget_deltas_aas: 1.39379096031 msecs\n</code>\n</pre>\n", "senID": 4}, {"text": ["The code I used to do the timing is here.", "I'm pleased with the timing framework I tossed together for it on top of timeit.", "Should be useful in the future after refactoring the code for running the tests."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://gist.github.com/711343"}]}], [{"code": "<pre>\n<code>\n D = dict((title, rank) for rank, title in enumerate(albums_yesterday))\nfor rank, title in enumerate(albums_today):\n    D[title] = D[title] - rank\n</code>\n</pre>\n", "senID": 0}]]