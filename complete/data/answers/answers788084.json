[[{"text": ["If your wordlist is very long, might it be more efficient to generate all possible 1-letter-differences from 'word', then check which ones are in the list?", "I don't know any Python but there should be a suitable data structure for the wordlist allowing for log-time lookups."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I suggest this because if your words are reasonable lengths (~10 letters), then you'll only be looking for 250 potential words, which is probably faster if your wordlist is larger than a few hundred words."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Your function distance is calculating the total distance, when you really only care about distance=1.", "The majority of cases you'll know it's >1 within a few characters, so you could return early and save a lot of time."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "distance", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Beyond that, there might be a better algorithm, but I can't think of it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit: Another idea."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "b", "pos": 0, "childList": []}]}, {"text": ["You can make 2 cases, depending on whether the first character matches.", "If it doesn't match, the rest of the word has to match exactly, and you can test for that in one shot.", "Otherwise, do it similarly to what you were doing.", "You could even do it recursively, but I don't think that would be faster."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def DifferentByOne(word1, word2):\n    if word1[0] != word2[0]:\n        return word1[1:] == word2[1:]\n    same = True\n    for i in range(1, len(word1)):\n        if word1[i] != word2[i]:\n            if same:\n                same = False\n            else:\n                return False\n    return not same\n</code>\n</pre>\n", "senID": 4}, {"text": ["Edit 2: I've deleted the check to see if the strings are the same length, since you say it's redundant.", "Running Ryan's tests on my own code and on the is_neighbors function provided by MizardX, I get the following:"], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "Edit 2:", "childNum": 0, "tag": "b", "pos": 0, "childList": []}, {"text": "Ryan's tests", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/788084/how-can-i-optimize-this-python-code/788168#788168"}, {"href": "http://stackoverflow.com/questions/788084/how-can-i-optimize-this-python-code/788113#788113", "text": "provided by MizardX", "childNum": 0, "tag": "a", "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "Original distance(): 3.7 seconds", "tag": "none", "senID": 6}, {"text": "My DifferentByOne(): 1.1 seconds", "tag": "none", "senID": 7}, {"text": "MizardX's is_neighbors(): 3.7 seconds", "tag": "none", "senID": 8}]}, {"text": ["Edit 3: (Probably getting into community wiki territory here, but...)"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Edit 3:", "childNum": 0, "tag": "b", "pos": 0, "childList": []}]}, {"text": ["Trying your final definition of is_neighbors() with izip instead of zip: 2.9 seconds."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Here's my latest version, which still times at 1.1 seconds:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def DifferentByOne(word1, word2):\n    if word1[0] != word2[0]:\n        return word1[1:] == word2[1:]\n    different = False\n    for i in range(1, len(word1)):\n        if word1[i] != word2[i]:\n            if different:\n                return False\n            different = True\n    return different\n</code>\n</pre>\n", "senID": 12}], [{"code": "<pre>\n<code>\n from itertools import izip\n\ndef is_neighbors(word1,word2):\n    different = False\n    for c1,c2 in izip(word1,word2):\n        if c1 != c2:\n            if different:\n                return False\n            different = True\n    return different\n</code>\n</pre>\n", "senID": 0}, {"text": ["Or maybe in-lining the izip code:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "izip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def is_neighbors(word1,word2):\n    different = False\n    next1 = iter(word1).next\n    next2 = iter(word2).next\n    try:\n        while 1:\n            if next1() != next2():\n                if different:\n                    return False\n                different = True\n    except StopIteration:\n        pass\n    return different\n</code>\n</pre>\n", "senID": 2}, {"text": ["And a rewritten getchildren:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "getchildren", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def iterchildren(word, wordlist):\n    return ( w for w in wordlist if is_neighbors(word, w) )\n</code>\n</pre>\n", "senID": 4}, {"tag": "ul", "num": 2, "lis": [{"text": ["izip(a,b)"], "childNum": 1, "tag": "a", "senID": 5, "childList": [{"text": "izip(a,b)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["zip(a,b)"], "childNum": 1, "tag": "a", "senID": 6, "childList": [{"text": "zip(a,b)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}], [{"text": ["People are mainly going about this by trying to write a quicker function, but there might be another way.."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Why is this?", "Perhaps a better way to optimise is to try and reduce the number of calls to distance, rather than shaving milliseconds of distance's execution time.", "It's impossible to tell without seeing the full script, but optimising a specific function is generally unnecessary."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "distance", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "distance's", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["If that is impossible, perhaps you could write it as a C module?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Well you can start by having your loop break if the difference is 2 or more."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also you can change"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for i in range(len(word1)):\n</code>\n</pre>\n", "senID": 2}, {"text": ["to "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for i in xrange(len(word1)):\n</code>\n</pre>\n", "senID": 4}, {"text": ["Because xrange generates sequences on demand instead of generating the whole range of numbers at once."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["You can also try comparing word lengths which would be quicker.", "Also note that your code doesn't work if word1 is greater than word2"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["There's not much else you can do algorithmically after that, which is to say you'll probably find more of a speedup by porting that section to C."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Edit 2"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Edit 2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Attempting to explain my analysis of Sumudu's algorithm compared to verifying differences char by char."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["When you have a word of length L, the number of \"differs-by-one\" words you will generate will be 25L.", "We know from implementations of sets on modern computers, that the  search speed is approximately log(n) base 2, where n is the number of elements to search for. "], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "log(n) base 2", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["Seeing that most of the 5 million words you test against is not in the set, most of the time, you will be traversing the entire set, which means that it really becomes log(25L) instead of only log(25L)/2.", "(and this is assuming best case scenario for sets that comparing string by string is equivalent to comparing char by char)"], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "not", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "log(25L)", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Now we take a look at the time complexity for determining a \"differs-by-one\".", "If we assume that you have to check the entire word, then the number of operations per word becomes L. We know that most words differ by 2 very quickly.", "And knowing that most prefixes take up a small portion of the word, we can logically assume that you will break most of the time by L/2, or half the word (and this is a conservative estimate)."], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "L", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "L/2", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["So now we plot the time complexities of the two searches, L/2 and log(25L), and keeping in mind that this is even considering string matching the same speed as char matching (highly in favor of sets).", "You have the equation log(25*L) > L/2, which can be simplified down to log(25) > L/2 - log(L).", "As you can see from the graph, it should be quicker to use the char matching algorithm until you reach very large numbers of L."], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "this is even considering string matching the same speed as char matching", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "very", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"src": "http://imgur.com/27AUC.png", "tag": "img", "senID": 14}, {"text": ["I was the first person in this question to suggest breaking on a difference of 2 or more.", "The thing is, that Mark's idea of string slicing (if word1[0] != word2[0]: return word1[1:] == word2[1:]) is simply putting what we are doing into C. How do you think word1[1:] == word2[1:] is calculated?", "The same way that we are doing."], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "word1[1:] == word2[1:]", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["As for producing the C code, I am a bit busy.", "I am sure you will be able to do it since you have written in C before.", "You could also try C#, which probably has similar performance characteristics."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["More Explanation"], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "More Explanation", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Here is a more indepth explanation to Davy8"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n def getchildren(word, wordlist):\n    oneoff = one_letter_off_strings(word)\n    return set(oneoff) &amp; set(wordlist)\n</code>\n</pre>\n", "senID": 19}, {"text": ["Your one_letter_off_strings function will create a set of 25L strings(where L is the number of letters). "], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"text": ["Creating a set from the wordlist will create a set of D strings (where D is the length of your dictionary).", "By creating an intersection from this, you MUST iterate over each oneoff and see if it exists in wordlist. "], "childNum": 3, "tag": "p", "senID": 21, "childList": [{"text": "MUST", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "oneoff", "childNum": 0, "tag": "strong", "childList": []}, {"text": "wordlist", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["The time complexity for this operation is detailed above.", "This operation is less efficient than comparing the word you want with each word in wordlist.", "Sumudu's method is an optimization in C rather than in algorithm."], "childNum": 2, "tag": "p", "senID": 22, "childList": [{"text": "word", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "wordlist", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["More Explanation 2"], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "More Explanation 2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["To create the intersection of 125 one-letter-off words with a dictionary of 4500, you need to make 125 * 4500 comparisons.", "This is not log(125,2).", "It is at best 125 * log(4500, 2) assuming that the dictionary is presorted.", "There is no magic shortcut to sets.", "You are also doing a string by string instead of char by char comparison here."], "childNum": 1, "tag": "p", "senID": 24, "childList": [{"text": "There is no magic shortcut to sets.", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}], [{"text": ["How often is the distance function called with the same arguments?", "A simple to implement optimization would be to use memoization. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "memoization", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/466320/"}]}, {"text": ["You could probably also create some sort of dictionary with frozensets of letters and lists of words that differ by one and look up values in that.", "This datastructure could either be stored and loaded through pickle or generated from scratch at startup."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Short circuiting the evaluation will only give you gains if the words you are using are very long, since the hamming distance algorithm you're using is basically O(n) where n is the word length. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I did some experiments with timeit for some alternative approaches that may be illustrative."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Your Solution"], "childNum": 0, "tag": "h2", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n d = \"\"\"\\\ndef distance(word1, word2):\n    difference = 0\n    for i in range(len(word1)):\n        if word1[i] != word2[i]:\n            difference += 1\n    return difference\n\"\"\"\nt1 = timeit.Timer('distance(\"hello\", \"belko\")', d)\nprint t1.timeit() # prints 6.502113536776391\n</code>\n</pre>\n", "senID": 5}, {"text": ["One Liner"], "childNum": 0, "tag": "h2", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n d = \"\"\"\\\nfrom itertools import izip\ndef hamdist(s1, s2):\n    return sum(ch1 != ch2 for ch1, ch2 in izip(s1,s2))\n\"\"\"\nt2 = timeit.Timer('hamdist(\"hello\", \"belko\")', d)\nprint t2.timeit() # prints 10.985101179\n</code>\n</pre>\n", "senID": 7}, {"text": ["Shortcut Evaluation"], "childNum": 0, "tag": "h2", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n d = \"\"\"\\\ndef distance_is_one(word1, word2):\n    diff = 0\n    for i in xrange(len(word1)):\n        if word1[i] != word2[i]:\n            diff += 1\n        if diff &gt; 1:\n            return False\n    return diff == 1\n\"\"\"\nt3 = timeit.Timer('hamdist(\"hello\", \"belko\")', d)\nprint t2.timeit() # prints 6.63337\n</code>\n</pre>\n", "senID": 9}], [{"text": ["For such a simple function that has such a large performance implication, I would probably make a C library and call it using ctypes.", "One of reddit's founders claims they made the website 2x as fast using this technique."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ctypes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/ctypes.html"}]}, {"text": ["You can also use psyco on this function, but beware that it can eat up a lot of memory."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "psyco", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://psyco.sourceforge.net/"}]}], [{"text": ["I don't know if it will significantly affect your speed, but you could start by turning the list comprehension into a generator expression.", "It's still iterable so it shouldn't be much different in usage:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def getchildren(word, wordlist):\n    return [ w for w in wordlist if distance(word, w) == 1 ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["to"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def getchildren(word, wordlist):\n    return ( w for w in wordlist if distance(word, w) == 1 )\n</code>\n</pre>\n", "senID": 3}, {"text": ["The main problem would be that a list comprehension would construct itself in memory and take up quite a bit of space, whereas the generator will create your list on the fly so there is no need to store the whole thing."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Also, following on unknown's answer, this may be a more \"pythonic\" way of writing distance():"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def distance(word1, word2):\n    difference = 0\n    for x,y in zip (word1, word2):\n        if x == y:\n            difference += 1\n    return difference\n</code>\n</pre>\n", "senID": 6}, {"text": ["But it's confusing what's intended when len (word1) != len (word2), in the case of zip it will only return as many characters as the shortest word.", "(Which could turn out to be an optimization...)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def distance(word1, word2):\n  return sum([not c1 == c2 for c1, c2 in zip(word1,word2)])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also, do you have a link to your game?", "I like being destroyed by word games"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["First thing to occur to me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from operator import ne\n\ndef distance(word1, word2):\n    return sum(map(ne, word1, word2))\n</code>\n</pre>\n", "senID": 1}, {"text": ["which has a decent chance of going faster than other functions people have posted, because it has no interpreted loops, just calls to Python primitives.", "And it's short enough that you could reasonably inline it into the caller."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For your higher-level problem, I'd look into the data structures developed for similarity search in metric spaces, e.g.", "this paper or this book, neither of which I've read (they came up in a search for a paper I have read but can't remember)."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "this paper", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.citeulike.org/user/vi%5Fz/article/3243208"}, {"href": "http://www.nmis.isti.cnr.it/amato/similarity-search-book/", "text": "this book", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["for this snippet:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for x,y in zip (word1, word2):\n    if x != y:\n        difference += 1\nreturn difference\n</code>\n</pre>\n", "senID": 1}, {"text": ["i'd use this one:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n return sum(1 for i in xrange(len(word1)) if word1[i] == word2[i])\n</code>\n</pre>\n", "senID": 3}, {"text": ["the same pattern would follow all around the provided code..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]