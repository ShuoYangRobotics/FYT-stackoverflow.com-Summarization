[[{"text": ["You can merge all your regexes into one using the \"|\" operator and let the regex library do the work of discerning between tokens.", "Some care should be taken to ensure the preference of tokens (for example to avoid matching a keyword as an identifier)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["It's possible that combining the token regexes will work, but you'd have to benchmark it.", "Something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n x = re.compile('(?P&lt;NUMBER&gt;[0-9]+)|(?P&lt;VAR&gt;[a-z]+)')\na = x.match('9999').groupdict() # =&gt; {'VAR': None, 'NUMBER': '9999'}\nif a:\n    token = [a for a in a.items() if a[1] != None][0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The filter is where you'll have to do some benchmarking..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Update: I tested this, and it seems as though if you combine all the tokens as stated and write a function like:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def find_token(lst):\n    for tok in lst:\n        if tok[1] != None: return tok\n    raise Exception\n</code>\n</pre>\n", "senID": 4}, {"text": ["You'll get roughly the same speed (maybe a teensy faster) for this.", "I believe the speedup must be in the number of calls to match, but the loop for token discrimination is still there, which of course kills it."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["re.match is anchored.", "You can give it a position argument:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re.match", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n pos = 0\nend = len(text)\nwhile pos &lt; end:\n    match = regexp.match(text, pos)\n    # do something with your match\n    pos = match.end()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Have a look for pygments which ships a shitload of lexers for syntax highlighting purposes with different implementations, most based on regular expressions."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This isn't exactly a direct answer to your question, but you might want to look at ANTLR.", "According to this document the python code generation target should be up to date."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "ANTLR", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.antlr.org"}, {"text": "this", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.antlr.org/wiki/display/ANTLR3/Code+Generation+Targets"}]}, {"text": ["As to your regexes, there are really two ways to go about speeding it up if you're sticking to regexes.", "The first would be to order your regexes in the order of the probability of finding them in a default text.", "You could figure adding a simple profiler to the code that collected token counts for each token type and running the lexer on a body of work.", "The other solution would be to bucket sort your regexes (since your key space, being a character, is relatively small) and then use a array or dictionary to perform the needed regexes after performing a single discrimination on the first character."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["However, I think that if you're going to go this route, you should really try something like ANTLR which will be easier to maintain, faster, and less likely to have bugs."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "ANTLR", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.antlr.org"}]}], [{"text": ["these are not so simple, but may be worth looking at..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["python module pyparsing  (pyparsing.wikispaces.com) allows specifying grammar - then using it to parse text.", "Douglas, thanks for the post about ANTLR I haven't heard of it.", "Also there's PLY - python2 and python3 compatible implementation of lex/yacc."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "pyparsing", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "ANTLR", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "PLY", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["I've written an ad-hoc regex-based parser myself first, but later realized that I might benefit from using some mature parsing tool and learning concepts of context independent grammar, etc."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The advantage of using grammar for parsing is that you can easily modify the rules and formalize quite complex syntax for whatever you are parsing."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I suggest using the re.Scanner class, it's not documented in the standard library, but it's well worth using.", "Here's an example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nscanner = re.Scanner([\n    (r\"-?[0-9]+\\.[0-9]+([eE]-?[0-9]+)?\", lambda scanner, token: float(token)),\n    (r\"-?[0-9]+\", lambda scanner, token: int(token)),\n    (r\" +\", lambda scanner, token: None),\n])\n\n&gt;&gt;&gt; scanner.scan(\"0 -1 4.5 7.8e3\")[0]\n[0, -1, 4.5, 7800.0]\n</code>\n</pre>\n", "senID": 1}]]