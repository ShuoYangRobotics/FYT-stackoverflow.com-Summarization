[[{"text": ["This is probably how I'd do it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def treat_missing_values(table):\n...     for line in table:\n...         prev = None\n...         for i, value in enumerate(line):\n...             if value is None:\n...                 line[i] = prev\n...             else:\n...                 prev = value\n...     return table\n... \n&gt;&gt;&gt; treat_missing_values([[1, 3, None, 5, None], [2, None, None, 3, 1], [4, None, 2, 1, None]])\n[[1, 3, 3, 5, 5], [2, 2, 2, 3, 1], [4, 4, 2, 1, 1]]\n&gt;&gt;&gt; treat_missing_values([[None, 3, None, 5, None], [2, None, None, 3, 1], [4, None, 2, 1, None]])\n[[None, 3, 3, 5, 5], [2, 2, 2, 3, 1], [4, 4, 2, 1, 1]]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["When you do an assignment in python, you are merely creating a reference on an object in memory.", "You can't use value to set the object in the list because you're effectively making value reference another object in memory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To do what you want, you need to set directly in the list at the right index."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As stated, your algorithm won't work if one of the inner lists has None as the first value."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["So you can do it like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n t = [[1, 3, None, 5, None], [2, None, None, 3, 1], [4, None, 2, 1, None]]\ndef treat_missing_values(table, default_value):\n    last_value = default_value\n    for line in table:\n        for index in xrange(len(line)):\n            if line[index] is None:\n                line[index] = last_value\n            else:\n                last_value = line[index]\n    return table\n\nprint treat_missing_values(t, 0)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["That thing about looking up the index from the value won't work if the list start with None or if there's a duplicate value.", "Try this: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def treat(v):\n   p = None\n   r = []\n   for n in v:\n     p = p if n == None else n\n     r.append(p)\n   return r\n\ndef treat_missing_values(table):\n   return [ treat(v) for v in table ]\n\nt = [[1, 3, None, 5, None], [2, None, None, 3, 1], [4, None, 2, 1, None]]\nprint treat_missing_values(t)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This better not be your homework, dude."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT A functional version for all you FP fans out there:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def treat(l):\n  def e(first, remainder):\n     return [ first ] + ([] if len(remainder) == 0 else e(first if remainder[0] == None else remainder[0], remainder[1:]))\n  return l if len(l) == 0 else e(l[0], l[1:])\n</code>\n</pre>\n", "senID": 4}], [{"text": ["That's because the index method returns the first occurence of the argument you pass to it.", "In the first line, for example, line.index(None) will always return 2, because that's the first occurence of None in that list."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "index", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Try this instead:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def treat_missing_values(table):\n        for line in table:\n            for i in range(len(line)):\n                if line[i] == None:\n                    if i != 0:\n                        line[i] = line[i - 1]\n                    else:\n                        #This line deals with your other problem: What if your FIRST value is None?\n                        line[i] = 0 #Some default value here\n        return table\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I'd use a global variable to keep track of the most recent valid value.", "And I'd use map() for the iteration."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "map()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n t = [[1, 3, None, 5, None], [2, None, None, 3, 1], [4, None, 2, 1, None]]\n\nprev = 0\ndef vIfNone(x):\n    global prev\n    if x:\n       prev = x\n    else:\n       x = prev\n    return x\n\nprint map( lambda line: map( vIfNone, line ), t )\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: Malvolio, here.", "Sorry to be writing in your answer, but there were too many mistakes to corrected in a comment."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["So:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def treat(n):\n    prev = [ None ]\n    def vIfNone(x):\n        if x is not None:\n           prev[0] = x\n        return prev[0]\n    return map( vIfNone, n )\n</code>\n</pre>\n", "senID": 4}, {"text": ["(Note the weird use of prev as a closed variable.", "It will be local to each invocation of treat, and global across all invocations of vIfNone from the same treat invocation, exactly what you need.", "For dark and probably disturbing Python reasons I don't understand, it has to be an array."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "closed variable", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "treat", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "treat", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["EDIT1"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "EDIT1", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # your algorithm won't work if the line start with None\nt = [[1, 3, None, 5, None], [2, None, None, 3, 1], [4, None, 2, 1, None]]\ndef treat_missing_values(table):\n    for line in table:\n        for index in range(len(line)):\n            if line[index] == None:\n                line[index] = line[index-1]\n    return table\n\nprint treat_missing_values(t)\n</code>\n</pre>\n", "senID": 1}]]