[[{"text": ["For calculations like sum, factorial etc, pythons built-in type checks will do fine.", "The calculations will end upp calling add, mul etc for the types, and if they break, they will throw the correct exception anyway.", "By enforcing your own checks, you may invalidate otherwise working input."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "add", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "mul", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}], [{"text": ["I assert what's absolutely essential."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "assert", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Important: What's absolutely essential.", "Some people over-test things."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "absolutely", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def factorial(num):\n    assert int(num)\n    assert num &gt; 0\n</code>\n</pre>\n", "senID": 2}, {"text": ["Isn't completely correct.", "long is also a legal possibility."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def factorial(num):\n    assert type(num) in ( int, long )\n    assert num &gt; 0\n</code>\n</pre>\n", "senID": 4}, {"text": ["Is better, but still not perfect.", "Many Python types (like rational numbers, or number-like objects) can also work in a good factorial function.", "It's hard to assert that an object has basic integer-like properties without being too specific and eliminating future unthought-of classes from consideration."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I never define unique exceptions for individual functions.", "I define a unique exception for a significant module or package.", "Usually, however, just an Error class or something similar.", "That way the application says except somelibrary.Error,e: which is about all you need to know.", "Fine-grained exceptions get fussy and silly."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "Error", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "except somelibrary.Error,e:", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["I've never done this, but I can see places where it might be necessary. "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n assert all( type(i) in (int,long) for i in someList )\n</code>\n</pre>\n", "senID": 8}, {"text": ["Generally, however, the ordinary Python built-in type checks work fine.", "They find almost all of the exceptional situations that matter almost all the time.", "When something isn't the right type, Python raises a TypeError that always points at the right line of code."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["BTW.", "I only add asserts at design time if I'm absolutely certain the function will be abused.", "I sometimes add assertions later when I have a unit test that fails in an obscure way."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["I'm trying to write docstring stating what type of parameter is expected and accepted, and I'm not checking it explicitly in my functions. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If someone wants to use my function with any other type its his responsibility to check if his type emulates one I accept well enough.", "Maybe your factorial can be used with some custom long-like type to obtain something you wouldn't think of?", "Or maybe your sum can be used to concatenate strings?", "Why should you disallow it by type checking?", "It's not C, anyway."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I basically try to convert the variable to what it should be and pass up or throw the appropriate exception if that fails."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def factorial(num):\n    \"\"\"Computes the factorial of num.\"\"\"\n    try:\n        num = int(num)\n    except ValueError, e:\n        print e\n    else:\n        ...\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It rather depends on what I'm writing, and how the output gets there.", "Python doesn't have the public/private protections of other OO-languages.", "Instead there are conventions.", "For example, external code should only call object methods that are not prefixed by an underscore."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Therefore, if I'm writing a module, I'd validate anything that is not generated from my own code, i.e.", "any calls to publicly-accessible methods/functions.", "Sometimes, if I know the validation is expensive, I make it togglable with a kwarg:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def publicly_accessible_function(arg1, validate=False):\n  if validate:\n    do_validation(arg1)\n   do_work\n</code>\n</pre>\n", "senID": 2}, {"text": ["Internal methods can do validation via the assert statement, which can be disabled altogether when the code goes out of development and into production."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "assert", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/simple_stmts.html#assert"}]}], [{"text": ["I almost never enforce any kind of a check, unless I think there's a possibility that someone might think they can pass some X which would produce completely crazy results."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The other time I check is when I accept several types for an argument, for example a function that takes a list, might accept an arbitrary object and just wrap it in a list (if it's not already a list).", "So in that case I check for the type -not to enforce anything- just because I want the function to be flexible in how it's used."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Only bother to check if you have a failing unit-test that forces you to."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also consider \"EAFP\"...", "It's the Python way!"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "EAFP", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/glossary.html#term-eafp"}]}], [{"text": ["A bit of perspective on how another language handles it might add some value.", "For Perl, I remember using this module - http://search.cpan.org/dist/Params-Validate/ which offloads a lot of parameter validation from the developer.", "I was searching for something similar in python and came across this: http://www.voidspace.org.uk/python/validate.html I haven't tried it out.", "But I guess aiming for a standard way of validating params across the entire codebase leads to upfront setting of parameter validation expectations across the entire team. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "http://search.cpan.org/dist/Params-Validate/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://search.cpan.org/dist/Params-Validate/"}, {"text": "http://www.voidspace.org.uk/python/validate.html", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.voidspace.org.uk/python/validate.html"}]}]]