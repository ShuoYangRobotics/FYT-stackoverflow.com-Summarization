[[{"text": ["Nope, that's pretty much how to do it.", "You can use exec if you want to as well."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "exec", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Note you can import a list of modules by doing this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; moduleNames = ['sys', 'os', 're', 'unittest'] \n&gt;&gt;&gt; moduleNames\n['sys', 'os', 're', 'unittest']\n&gt;&gt;&gt; modules = map(__import__, moduleNames)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Ripped straight from Dive Into Python."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Dive Into Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.diveintopython.net/functional_programming/dynamic_import.html"}]}], [{"text": ["As mentioned the imp module provides you loading functions."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["imp.load_source(path)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "imp.load_source(path)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["imp.load_compiled(path)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "imp.load_compiled(path)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I've used these before to perform something similar.", "In my case I defined a specific class with defined methods that were required.", "So, once I loaded the module I would check if the class was in the module, and then create an instance of that class."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["Something like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import imp\n\n\ndef load_from_file(filepath):\n    class_inst = None\n    expected_class = 'MyClass'\n\n    mod_name,file_ext = os.path.splitext(os.path.split(filepath)[-1])\n\n    if file_ext.lower() == '.py':\n        py_mod = imp.load_source(mod_name, filepath)\n\n    elif file_ext.lower() == '.pyc'\n        py_mod = imp.load_compiled(mod_name, filepath)\n\n    if expected_class in dir(py_mod):\n        class_inst = py_mod.MyClass() \n\n    return class_inst\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Use the imp module, or the more direct __import__() function."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "imp module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/imp.html#imp.load_module"}, {"href": "http://docs.python.org/library/functions.html#__import__", "text": "__import__()", "childNum": 1, "tag": "a", "childList": [{"text": "__import__()", "tag": "code"}]}, {"text": "__import__()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["It sounds like what you really want is a plugin architecture.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You should have a look at the  entry points functionality provided by the setuptools package.", "It offers a great way to discover plugins that are loaded for your application."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "entry points", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://peak.telecommunity.com/DevCenter/setuptools#extensible-applications-and-frameworks"}]}], [{"text": ["You can use exec:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "exec", "tag": "a", "pos": 0, "childList": [{"text": "exec", "tag": "code"}], "childNum": 1, "href": "http://www.python.org/doc/2.5.2/ref/exec.html"}, {"text": "exec", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n exec \"import myapp.commands.%s\" % command\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Check out this post on importing module code dynamically"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Dynamically executing or importing python code"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Dynamically executing or importing python code", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://edwardhuynh.blogspot.com/2009/08/dynamically-executing-or-importing.html"}]}], [{"text": ["If you want it in your locals:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; mod = 'sys'\n&gt;&gt;&gt; locals()['my_module'] = __import__(mod)\n&gt;&gt;&gt; my_module.version\n'2.6.6 (r266:84297, Aug 24 2010, 18:46:32) [MSC v.1500 32 bit (Intel)]'\n</code>\n</pre>\n", "senID": 1}, {"text": ["same would work with globals()"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "globals()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The following worked for me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys, glob\nsys.path.append('/home/marc/python/importtest/modus')\nfl = glob.glob('modus/*.py')\nmodulist = []\nadapters=[]\nfor i in range(len(fl)):\n    fl[i] = fl[i].split('/')[1]\n    fl[i] = fl[i][0:(len(fl[i])-3)]\n    modulist.append(getattr(__import__(fl[i]),fl[i]))\n    adapters.append(modulist[i]())\n</code>\n</pre>\n", "senID": 1}, {"text": ["It loads modules from the folder 'modus'.", "The modules have a single class with the same name as the module name.", "E.g.", "the file modus/modu1.py contains:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class modu1():\n    def __init__(self):\n        self.x=1\n        print self.x\n</code>\n</pre>\n", "senID": 3}, {"text": ["The result is a list of dynamically loaded classes \"adapters\"."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]