[[{"text": ["Use getattr:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "getattr", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#getattr"}]}, {"code": "<pre>\n<code>\n class Bot:\n    def fight(self):\n       print \"fighting is fun!\"\n\nclass Scheduler:       \n    def schedule_action(self,action):\n       bot = Bot()\n       getattr(bot,action)()\n\nscheduler = Scheduler()\nscheduler.schedule_action('fight')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that getattr also takes an optional argument that allows you to return a default value in case the requested action doesn't exist."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["In short,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n getattr(bot, action)()\n</code>\n</pre>\n", "senID": 1}, {"text": ["getattr will look up an attribute on the object by name -- attributes can be data or member methods The extra () at the end calls the method."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You could get the method in a separate step, like this, as well:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n method_to_call = getattr(bot, action)\nmethod_to_call()\n</code>\n</pre>\n", "senID": 4}, {"text": ["And you can pass arguments to the method in the usual way:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n getattr(bot, action)(argument1, argument2)\n</code>\n</pre>\n", "senID": 6}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n method_to_call = getattr(bot, action)\nmethod_to_call(argument1, argument2)\n</code>\n</pre>\n", "senID": 8}], [{"text": ["I'm not sure if it applies in your situation, but you may consider using a function pointer instead of manipulating the strings."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Bot:\n    def work(self): \n        print 'working'\n    def fight(self): \n        print 'fightin'\n\nclass Scheduler:\n    def schedule_action(self,action):\n       bot = Bot()\n       action(bot)\n\nscheduler = Scheduler()\nscheduler.schedule_action(Bot.fight)\nscheduler.schedule_action(Bot.work)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n fightin\nworking\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you can do this, it will give you an error about a misspelled function at compile-time when the code is interpreted instead of during run-time.", "This could shorten your debug cycle for stupid data-entry errors, especially if the actions are done over a span of time.", "Nothing sucks more than running something overnight and discovering that you had a syntax error in the morning."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "at compile-time", "childNum": 0, "tag": "strike", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n class Scheduler:\n    def schedule_action(self,action):\n       bot = Bot()\n       boundmethod = getattr(bot, action)\n       boundmethod()\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n def schedule_action(self,action):\n         bot = Bot()\n         bot.__getattribute__(action)()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You can also use a dictionary to map methods to actions.", "For instance:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ACTIONS = {\"fight\": Bot.fight,\n           \"walk\": Bot.walk,}\n\nclass Scheduler:\n    def schedule_action(self, action):\n        return ACTIONS[action](Bot())\n</code>\n</pre>\n", "senID": 1}]]