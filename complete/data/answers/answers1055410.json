[[{"text": ["Seems like an abuse of a dictionary structure.", "Why not create a simple class?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Entity(object):\n    def __init__(self, mass, volume):\n        self.mass = mass\n        self.volume = volume\n    def _density(self):\n        return self.mass / self.volume\n    density = property(_density)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You would be best off creating a class for this in this case and using a dynamic property.", "e.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Body(object):\n    def __init__(self):\n        self.mass=1.0\n        self.volume=0.5\n\n    @property\n    def density(self):\n        return self.mass/self.volume\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will give you mass, volume and density properties, where density is calculated based on the other two values.", "e.g."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n b=Body()\nb.mass=1\nb.volume=0.5\nprint b.density # should be 2\n\nb.mass=2.0\nprint b.density # should be 4\n</code>\n</pre>\n", "senID": 3}, {"text": ["However if you are wedded to using a dictionary you should probably extend it and override the __getitem__ and __setitem__ \"magic\" methods to and detect when mass has changed or else when density is being accessed and recalculate as needed."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "__getitem__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__setitem__", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["A class would do this better:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Thing:\n    def __init__(self, mass, volume):\n        self._mass = mass\n        self._volume = volume\n        self._update_density()\n\n    def _update_density(self):\n        self._density = self._mass / self._volume\n\n    def get_density(self):\n        return self._density\n\n    density = property(get_density)\n\n    # You're unlikely to need these, but to demonstrate the point:\n    def set_mass(self, mass):\n        self._mass = mass\n        self._update_density()\n\n    def set_volume(self, volume):\n        self._volume = volume\n        self._update_density()\n\nbrick = Thing(mass=2, volume=0.8)\nprint brick.density\n# Prints 2.5\n\nbrick.set_mass(4)\nprint brick.density\n# Prints 5.0\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm taking you at your word that you want the density updated when you set the other values - an easier way would be to simply calculate it on the fly when asked for it:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def get_density(self):\n        return self._mass / self._volume\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then you wouldn't need _update_density() at all."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "_update_density()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Short answer is you can't."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The assigned expression is evaluated strictly when it's encountered so any changes to the terms later on don't matter."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "strictly", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Evaluation%5Fstrategy#Strict%5Fevaluation"}]}, {"text": ["You could solve this with a custom dict class that overwrites the getitem and setitem methods and does something special (i.e.", "computes the value) for some of the keys (say density and a finite number of others)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "getitem", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "setitem", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n class MyDict(dict):\n    def __getitem__(self, key):\n            if key == \"density\":\n                    return self[\"mass\"] / self[\"volume\"]\n            return dict.__getitem__(self, key)\n\nd = MyDict()\nd[\"mass\"] = 2.0\nd[\"volume\"] = 4.0\nd[\"density\"]    # 0.5\n</code>\n</pre>\n", "senID": 3}, {"text": ["Have a look at this."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://diveintopython.org/object%5Foriented%5Fframework/special%5Fclass%5Fmethods.html"}]}, {"text": ["Cheers and good luck."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["The problem is that dictionaries aren't the right tool for your problem.", "Your question is like \"how can I hammer a nail in with a screwdriver\" ;-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Dictionaries are supposed to map keys to values and don't care about other values in the dictionary.", "What you want is a class"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class PhysicalObject:\n    def __init__(self, mass, volume):\n         self.mass = float(mass)\n         self.volume = float(volume)\n    def setMass(self, mass):\n         self.mass = float(mass)\n    def setVolume(self, volume):\n         self.volume = float(volume)\n    def getDensity(self):\n         return self.mass/float(self.volume)\n\n v = PhysicalObject(1.0, 2.0)\n print v.getDensity() # prints 0.5\n v.setMass(2.0)\n v.setVolume(1.0)\n print v.getDensity() # prints 2.0\n</code>\n</pre>\n", "senID": 2}, {"text": ["This example recalculates the density every time you want to get it, buy you can also calculate it in the setMass and setVolume functions."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This is so easy:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; mydict = {'mass':100, 'volume': 2, 'density': lambda: mydict['mass']/mydict['volume']}\n&gt;&gt;&gt; mydict['density']()\n50\n&gt;&gt;&gt; mydict['mass']=200\n&gt;&gt;&gt; mydict['density']()\n100\n&gt;&gt;&gt; mydict['volume'] = 4\n&gt;&gt;&gt; mydict['density']()\n50\n</code>\n</pre>\n", "senID": 1}, {"text": ["My lambda references mydict and later on retrieves the newest data hold in mydict, so sparing me the trouble of passing the mass and volume to the function each time I want to call it, like in your solution:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def density(mass,volume): return mass/volume\nmydict['density_calc'] = lambda x,y: density(x,y)\nmydict['density'] = mydict['density_calc'](mydict['mass'],mydict['volume'])\n</code>\n</pre>\n", "senID": 3}, {"text": ["However mydict['density'] is a function, not the value itself."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Here's a quick hack on how to subclass dict to meet your specs, but probably not to meet Python's specs for a dictionary:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class MyDict(dict):\n    def __getitem__(self, key):\n        if key == 'density':\n           return self['mass'] / self['volume']\n        else:\n            return dict.__getitem__(self,key)\n    def keys(self):\n        return ['density'] + dict.keys(self)\n\nx = MyDict()\nx['mass'] = 1.0\nx['volume'] = 0.5\n\nprint x\n\nprint x.keys()\n\nprint x['density']\n\nx['mass'] = 2.0\n\nprint x['density']\n</code>\n</pre>\n", "senID": 1}, {"text": ["which prints"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {'volume': 0.5, 'mass': 1.0}\n['density', 'volume', 'mass']\n2.0\n4.0\n</code>\n</pre>\n", "senID": 3}, {"text": ["But that doesn't account for dict.iterkeys(), among other things."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]