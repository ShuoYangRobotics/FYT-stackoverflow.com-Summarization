[[{"text": ["It's an old-ish idiom; inserting parentheses to show priority,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (port == \"443\" and \"https://\") or \"http://\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["x and y returns y if x is truish, x if x is falsish; a or b, vice versa, returns a if it's truish, otherwise b."], "childNum": 8, "tag": "p", "senID": 2, "childList": [{"text": "x and y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}, {"text": "a or b", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So if port == \"443\" is true, this returns the RHS of the and, i.e., \"https://\".", "Otherwise, the and is false, so the or gets into play and returns `\"http://\", its RHS."], "childNum": 6, "tag": "p", "senID": 3, "childList": [{"text": "port == \"443\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "and", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\"https://\"", "childNum": 0, "tag": "code", "childList": []}, {"text": "and", "childNum": 0, "tag": "code", "childList": []}, {"text": "or", "childNum": 0, "tag": "code", "childList": []}, {"text": "its", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["In modern Python, a better way to do translate this old-ish idiom is:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n \"https://\" if port == \"443\" else \"http://\"\n</code>\n</pre>\n", "senID": 5}], [{"text": ["and returns the right operand if the left is true.", "or returns the right operand if the left is false.", "Otherwise they both return the left operand.", "They are said to coalesce."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "and", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "or", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "coalesce", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}], [{"text": ["C and X or Y is the long-running early attempt by Python users to proxy for C ?", "X : Y"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "C and X or Y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "C ? X : Y", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["For the most part it works, except if X is False -- this has led to many bugs in Python code, so in the Python FAQ, you'll find the more correct solution being (C and [X] or [Y])[0] because a list with a single element, regardless of its evaluated Boolean value, is always True!", "For example: [None] is True but None isn't.", "The OP's example above works because the string representing X is not empty."], "childNum": 10, "tag": "p", "senID": 1, "childList": [{"text": "except", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "X", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://www.python.org/doc/faq/programming/#is-there-an-equivalent-of-c-s-ternary-operator", "text": "Python FAQ", "childNum": 0, "tag": "a", "childList": []}, {"text": "(C and [X] or [Y])[0]", "childNum": 0, "tag": "code", "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "childList": []}, {"text": "[None]", "childNum": 0, "tag": "code", "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}, {"text": "X", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["However, all this changed in Python 2.5, when the ternary or conditional operator was added to the language, allowing you to use the cleaner X if C else Y as stated in other posts here.", "If you see code using the older format, it's because the user has been a long time Python programmer who hasn't adopted the new syntax yet, they cut-n-paste other old code, or their employer is still using 2.4.x (or earlier releases), etc."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "X if C else Y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This is an ugly hack that is not recommended.", "It works because of the short-circuiting behaviour of and and or and that they return the one of their arguments rather than a boolean value.", "Using this technique gives a risk of introducing hard-to-find bugs, so don't use it in new code."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "and", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "or", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Here's an example of how the and/or idiom can give an unexpected result:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "and/or", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; foo = 'foobar'\n&gt;&gt;&gt; bar = 'foobar'\n&gt;&gt;&gt; x = 0\n&gt;&gt;&gt; y = 1\n&gt;&gt;&gt; (foo == bar) and x or y   # Will this return the value of x if (foo == bar)?\n1\n</code>\n</pre>\n", "senID": 2}, {"text": ["Prefer instead the newer notation:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n return \"https://\" if port == \"443\" else \"http://\"\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You may want to read up on the \"and / or trick\" of Python in this article The Peculiar Nature of And and Or in Python.", "It's a bit like the IIF() in VBA or VB, or ?", ": in C-style languages."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "The Peculiar Nature of And and Or in Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://diveintopython.org/power_of_introspection/and_or.html"}, {"text": "IIF()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "?:", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["This construction works because it 'unfolds' to the following code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["a and b -->"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if a:\n  return b\nelse:\n  return a\n</code>\n</pre>\n", "senID": 2}, {"text": ["a or b -->"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n if a:\n  return a\nelse:\n  return b\n</code>\n</pre>\n", "senID": 4}]]