[[{"text": ["What you might be looking for is the multiprocessing module.", "If subprocess is too heavy, then this may not suit your needs either. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "multiprocessing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/multiprocessing.html#module-multiprocessing.pool"}, {"text": "subprocess", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import time\nimport multiprocessing\n\ndef do_this_other_thing_that_may_take_too_long(duration):\n    time.sleep(duration)\n    return 'done after sleeping {0} seconds.'.format(duration)\n\npool = multiprocessing.Pool(1)\nprint 'starting....'\nres = pool.apply_async(do_this_other_thing_that_may_take_too_long, [8])\nfor timeout in range(1, 10):\n    try:\n        print '{0}: {1}'.format(duration, res.get(timeout))\n    except multiprocessing.TimeoutError:\n        print '{0}: timed out'.format(duration) \n\nprint 'end'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A completely general solution to this really, honestly does not exist.", "You have to use the right solution for a given domain."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "really, honestly", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": ["If you want timeouts for code you fully control, you have to write it to cooperate.", "Such code has to be able to break up into little chunks in some way, as in an event-driven system.", "You can also do this by threading if you can ensure nothing will hold a lock too long, but handling locks right is actually pretty hard."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you want timeouts because you're afraid code is out of control (for example, if you're afraid the user will ask your calculator to compute 9**(9**9)), you need to run it in another process.", "This is the only easy way to sufficiently isolate it.", "Running it in your event system or even a different thread will not be enough.", "It is also possible to break things up into little chunks similar to the other solution, but requires very careful handling and usually isn't worth it; in any event, that doesn't allow you to do the same exact thing as just running the Python code."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "9**(9**9)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}], [{"text": ["For \"normal\" Python code, that doesn't linger prolongued times in C extensions or I/O waits, you can achieve your goal by setting a trace function with sys.settrace() that aborts the running code when the timeout is reached."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sys.settrace()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Whether that is sufficient or not depends on how co-operating or malicious the code you run is.", "If it's well-behaved, a tracing function is sufficient."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["An other way is to use faulthandler:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "faulthandler", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/faulthandler/"}]}, {"code": "<pre>\n<code>\n import time\nimport faulthandler\n\n\nfaulthandler.enable()\n\n\ntry:\n    faulthandler.dump_tracebacks_later(3)\n    time.sleep(10)\nfinally:\n    faulthandler.cancel_dump_tracebacks_later()\n</code>\n</pre>\n", "senID": 1}, {"text": ["N.B: The faulthandler module is part of stdlib in python3.3."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "faulthandler", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/faulthandler.html"}]}], [{"text": ["If it's network related you could try:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import socket\nsocket.setdefaulttimeout(number)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you're running code that you expect to die after a set time, then you should write it properly so that there aren't any negative effects on shutdown, no matter if its a thread or a subprocess.", "A command pattern with undo would be useful here."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So, it really depends on what the thread is doing when you kill it.", "If its just crunching numbers who cares if you kill it.", "If its interacting with the filesystem and you kill it , then maybe you should really rethink your strategy. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["What is supported in Python when it comes to threads?", "Daemon threads and joins.", "Why does python let the main thread exit if you've joined a daemon while its still active?", "Because its understood that someone using daemon threads will (hopefully) write the code in a way that it wont matter when that thread dies.", "Giving a timeout to a join and then letting main die, and thus taking any daemon threads with it, is perfectly acceptable in this context."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]