[[{"text": ["After extensive googling, i realized what i am looking to do is a Boolean search."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Found the code that makes regex boolean aware : http://code.activestate.com/recipes/252526/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://code.activestate.com/recipes/252526/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/252526/"}]}, {"text": ["Issue looks solved for now."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Probably slow, but easy solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Make a query on the story plus each string to the search engine.", "If it returns anything, then it matches."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Otherwise you need to implement the search syntax yourself.", "If that includes things like \"title:\" and stuff this can be rather complex.", "If it's only the AND and OR from your example, then it's a recursive function that isn't too hairy."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Some time ago I looked for a python implementaion of lucene and I came accross of Woosh which is a pure python text-based research engine.", "Maybe it will statisfy your needs."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Woosh", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://whoosh.ca/"}]}, {"text": ["You can also try pyLucene, but i did'nt investigate this one."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "pyLucene", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://lucene.apache.org/pylucene/"}]}], [{"text": ["Here's a suggestion in pseudocode.", "I'm assuming you store a story identifier with the search terms in the index, so that you can retrieve it with the search results."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def search_strings_matching(story_id_to_match, search_strings):\n    result = set()\n    for s in search_strings:\n        result_story_ids = query_index(s) # query_index returns an id iterable\n        if story_id_to_match in result_story_ids:\n            result.add(s)\n    return result\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is probably less interesting to you now, since you've already solved your problem, but what you're describing sounds like Prospective Search, which is what you call it when you have the query first and you want to match it against documents as they come along."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Prospective Search", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Prospective%5Fsearch"}]}, {"text": ["Lucene's MemoryIndex is a class that was designed specifically for something like this, and in your case it might be efficient enough to run many queries against a single document."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "MemoryIndex", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://lucene.apache.org/java/2%5F4%5F0/api/org/apache/lucene/index/memory/MemoryIndex.html"}]}, {"text": ["This has nothing to do with Python, though.", "You'd probably be better off writing something like this in java."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you are writing Python on AppEngine, you can use the AppEngine Prospective Search Service to achieve exactly what you are trying to do here.", "See: http://code.google.com/appengine/docs/python/prospectivesearch/overview.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.google.com/appengine/docs/python/prospectivesearch/overview.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.google.com/appengine/docs/python/prospectivesearch/overview.html"}]}]]