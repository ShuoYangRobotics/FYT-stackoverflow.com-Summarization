[[{"text": ["You can write a wrapper that buffers some number of items from the generator, and provides a lookahead() function to peek at those buffered items:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Lookahead:\n    def __init__(self, iter):\n        self.iter = iter\n        self.buffer = []\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        if self.buffer:\n            return self.buffer.pop(0)\n        else:\n            return self.iter.next()\n\n    def lookahead(self, n):\n        \"\"\"Return an item n entries ahead in the iteration.\"\"\"\n        while n &gt;= len(self.buffer):\n            try:\n                self.buffer.append(self.iter.next())\n            except StopIteration:\n                return None\n        return self.buffer[n]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Pretty good answers there, but my favorite approach would be to use itertools.tee -- given an iterator, it returns two (or more if requested) that can be advanced independently.", "It buffers in memory just as much as needed (i.e., not much, if the iterators don't get very \"out of step\" from each other).", "E.g."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.tee", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\nimport collections\n\nclass IteratorWithLookahead(collections.Iterator):\n  def __init__(self, it):\n    self.it, self.nextit = itertools.tee(iter(it))\n    self._advance()\n  def _advance(self):\n    self.lookahead = next(self.nextit, None)\n  def __next__(self):\n    self._advance()\n    return next(self.it)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can wrap any iterator with this class, and then use the .lookahead attribute of the wrapper to know what the next item to be returned in the future will be.", "I like to leave all the real logic to itertools.tee and just provide this thin glue!-)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": ".lookahead", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["It's not pretty, but this may do what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def paired_iter(it):\n    token = it.next()\n    for lookahead in it:\n        yield (token, lookahead)\n        token = lookahead\n    yield (token, None)\n\ndef scan(s):\n    for c in s:\n        yield c\n\nfor this_token, next_token in paired_iter(scan(\"ABCDEF\")):\n    print \"this:%s next:%s\" % (this_token, next_token)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n this:A next:B\nthis:B next:C\nthis:C next:D\nthis:D next:E\nthis:E next:F\nthis:F next:None\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here is an example that allows a single item to be sent back to the generator"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def gen():\n    for i in range(100):\n        v=yield i           # when you call next(), v will be set to None\n        if v:\n            yield None      # this yields None to send() call\n            v=yield v       # so this yield is for the first next() after send()\n\ng=gen()\n\nx=g.next()\nprint 0,x\n\nx=g.next()\nprint 1,x\n\nx=g.next()\nprint 2,x # oops push it back\n\nx=g.send(x)\n\nx=g.next()\nprint 3,x # x should be 2 again\n\nx=g.next()\nprint 4,x\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Since you say you are tokenizing a string and not a general iterable, I suggest the simplest solution of just expanding your tokenizer to return a 3-tuple:\n(token_type, token_value, token_index), where token_index is the index of the token in the string.", "Then you can look forward, backward, or anywhere else in the string.", "Just don't go past the end.", "Simplest and most flexible solution I think."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "(token_type, token_value, token_index)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "token_index", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Also, you needn't use a list comprehension to create a list from a generator.", "Just call the list() constructor on it:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n token_list = list(scan(string))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Paul's is a good answer.", "A class based approach with arbitrary lookahead might look something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class lookahead(object):\n    def __init__(self, generator, lookahead_count=1):\n        self.gen = iter(generator)\n        self.look_count = lookahead_count\n\n    def __iter__(self):\n        self.lookahead = []\n        self.stopped = False\n        try:\n            for i in range(self.look_count):\n                self.lookahead.append(self.gen.next())\n        except StopIteration:\n            self.stopped = True\n        return self\n\n    def next(self):\n        if not self.stopped:\n            try:\n                self.lookahead.append(self.gen.next())\n            except StopIteration:\n                self.stopped = True\n        if self.lookahead != []:\n            return self.lookahead.pop(0)\n        else:\n            raise StopIteration\n\nx = lookahead(\"abcdef\", 3)\nfor i in x:\n    print i, x.lookahead\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How I would write it concisely, if I just needed 1 element's worth of lookahead:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n SEQUENCE_END = object()\n\ndef lookahead(iterable):\n    iter = iter(iterable)\n    current = next(iter)\n    for ahead in iter:\n        yield current,ahead\n        current = ahead\n    yield current,SEQUENCE_END\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for x,ahead in lookahead(range(3)):\n&gt;&gt;&gt;     print(x,ahead)\n0, 1\n1, 2\n2, &lt;object SEQUENCE_END&gt;\n</code>\n</pre>\n", "senID": 3}]]