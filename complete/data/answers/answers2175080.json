[[{"text": ["You can split on a range of characters using the re module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; r = re.compile('[ \\t\\n\\r:]+')\n&gt;&gt;&gt; r.split(\"abc:def  ghi\")\n['abc', 'def', 'ghi']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Python doesn't have an sscanf equivalent built-in, and most of the time it actually makes a whole lot more sense to parse the input by working with the string directly, using regexps, or using a parsing tool. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sscanf", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Probably mostly useful for translating C, people have implemented sscanf, such as in this module: http://hkn.eecs.berkeley.edu/~dyoo/python/scanf/"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "sscanf", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://hkn.eecs.berkeley.edu/~dyoo/python/scanf/", "text": "http://hkn.eecs.berkeley.edu/~dyoo/python/scanf/", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["In this particular case if you just want to split the data based on multiple split characters, re.split is really the right tool."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "re.split", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can parse with module re using named groups.", "It won't parse the substrings to their actual datatypes (e.g.", "int) but it's very convenient when parsing strings."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "re", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "named groups", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html#regular-expression-syntax"}, {"text": "int", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Given this sample line from /proc/net/tcp:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "/proc/net/tcp", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n line=\"   0: 00000000:0203 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 335 1 c1674320 300 0 0 0\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["An example mimicking your sscanf example with the variable could be:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import re\nhex_digit_pattern = r\"[\\dA-Fa-f]\"\npat = r\"\\d+: \" + \\\n      r\"(?P&lt;local_addr&gt;HEX+):(?P&lt;local_port&gt;HEX+) \" + \\\n      r\"(?P&lt;rem_addr&gt;HEX+):(?P&lt;rem_port&gt;HEX+) \" + \\\n      r\"HEX+ HEX+:HEX+ HEX+:HEX+ HEX+ +\\d+ +\\d+ \" + \\\n      r\"(?P&lt;inode&gt;\\d+)\"\npat = pat.replace(\"HEX\", hex_digit_pattern)\n\nvalues = re.search(pat, line).groupdict()\n\nimport pprint; pprint values\n# prints:\n# {'inode': '335',\n#  'local_addr': '00000000',\n#  'local_port': '0203',\n#  'rem_addr': '00000000',\n#  'rem_port': '0000'}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["you can turn the \":\" to space, and do the split.eg"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; f=open(\"/proc/net/dev\")\n&gt;&gt;&gt; for line in f:\n...     line=line.replace(\":\",\" \").split()\n...     print len(line)\n</code>\n</pre>\n", "senID": 1}, {"text": ["no regex needed (for this case)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Upvoted orip's answer.", "I think it is sound advice to use re module.", "The Kodos application is helpful when approaching a complex regexp task with Python. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://kodos.sourceforge.net/home.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://kodos.sourceforge.net/home.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://kodos.sourceforge.net/home.html"}]}], [{"text": ["If the separators are ':', you can split on ':', and then use x.strip() on the strings to get rid of any leading or trailing whitespace.", "int() will ignore the spaces."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["There is an ActiveState recipe which implements a basic scanf\nhttp://code.activestate.com/recipes/502213-simple-scanf-implementation/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.activestate.com/recipes/502213-simple-scanf-implementation/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/502213-simple-scanf-implementation/"}]}]]