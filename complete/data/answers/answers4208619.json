[[{"text": ["If another_func just wants a iterable you can pass itertools.chain(x,'a') to it."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "another_func", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools.chain(x,'a')", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["What about changing the other function to accept a list of params instead ?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def func(arg): # arg is tuple or list\n  another_func('a', *x)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["how about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = ['a']\nl.extend(x)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def f(*args):\n    print args\n\ndef a(*args):\n    k = list(args)\n    k.append('a')\n    f(*k)\n\na(1, 2, 3)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n (1, 2, 3, 'a')\n</code>\n</pre>\n", "senID": 2}], [{"text": ["My suggestion:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo(t):\n    bar(list(t) + [other])\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is not very efficient though, you'd be better off passing around mutable things if you're going to be, well, mutating them."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can use the type of the iterable passed to the first function to construct what you pass to the second:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import chain\n\ndef func(iterable):\n    it = iter(iterable)\n    another_func(type(iterable)(chain(it, ('a',))))\n\ndef another_func(arg):\n    print arg\n\nfunc((1,2))\n# (1, 2, 'a')\nfunc([1,2])\n# [1, 2, 'a']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think you have to clarify exactly which are the requirements of the two functions.", "Must arg be a sequence, or an iterable is enough?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "arg", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["If an iterable is enough you can use itertools.chain, but be aware that if function A(the first one called), also iterates over the iterable after calling B, then you might have problems since iterables cannot be rewinded.", "In this case you should opt for a sequence or use iterable.tee to make a copy of the iterable:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import itertools as it\n&gt;&gt;&gt; def A(iterable):\n...     iterable, backup = it.tee(iterable)\n...     res = B(it.chain(iterable, ('a',)))\n...     #do something with res\n...     for elem in backup:\n...             #do something with elem\n... \n&gt;&gt;&gt; def B(iterable):\n...     for elem in iterable:\n...             #do something with elem\n...\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Have your function accept any iterable.", "Then use itertools.chain to add whatever sequence you want to the iterable."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.chain", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import chain\n\ndef func(iterable):\n    another_func(chain(iterable, ('a',)))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'd say Santiago Lezica's answer of doing"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo(t):\n    bar(list(t) + [other])\n</code>\n</pre>\n", "senID": 1}, {"text": ["is the best because it is the simplest.", "(no need to import itertools stuff and use much less readable chain calls).", "But only use it if you expect t to be small.", "If t can be large you should use one of the other solutions. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]