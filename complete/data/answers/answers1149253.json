[[{"text": ["You're talking about giving a class value semantics, which is typically done by creating class instances in the normal way, but remembering each one, and if a matching instance would be created, give the already created instance instead.", "In python, this can be achieved by overloading a classes __new__ method.  "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "value semantics", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://docs.python.org/reference/datamodel.html", "text": "method", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Brief example, say we wanted to use pairs of integers to represent coordinates, and have the proper value semantics.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class point(object):\n    memo = {}\n    def __new__(cls, x, y):\n        if (x, y) in cls.memo:         # if it already exists, \n            return cls.memo[(x, y)]    # return the existing instance\n        else:                          # otherwise, \n            newPoint = object.__new__(cls) # create it, \n            newPoint.x = x             # initialize it, as you would in __init__\n            newPoint.y = y             \n            cls.memo[(x, y)] = newPoint # memoize it, \n            return newPoint            # and return it!\n</code>\n</pre>\n", "senID": 2}, {"tag": "hr", "senID": 3}], [{"text": ["Looks like #1 has been well answered already and I just want to explain a principle, related to #2, which appears to have been missed by all respondents: for most built-in types, calling the type without parameters (the \"default constructor\") returns an instance of that type which evaluates as false.", "That means an empty container for container types, a number which compares equal to zero for number types."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "which evaluates as false", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import decimal\n&gt;&gt;&gt; decimal.Decimal()\nDecimal(\"0\")\n&gt;&gt;&gt; set()\nset([])\n&gt;&gt;&gt; float()\n0.0\n&gt;&gt;&gt; tuple()\n()\n&gt;&gt;&gt; dict()\n{}\n&gt;&gt;&gt; list()\n[]\n&gt;&gt;&gt; str()\n''\n&gt;&gt;&gt; bool()\nFalse\n</code>\n</pre>\n", "senID": 1}, {"text": ["See?", "Pretty regular indeed!", "Moreover, for mutable types, like most containers, calling the type always returns a new instance; for immutable types, like numbers and strings, it doesn't matter (it's a possible internal optimization to return new reference to an existing immutable instance, but the implementation is not required to perform such optimization, and if it does it can and often will perform them quite selectively) since it's never correct to compare immutable type instances with is or equivalently by id()."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "is", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "id()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you design a type of which some instances can evaluate as false (by having __len__ or __nonzero__ special methods in the class), it's advisable to follow the same precept (have __init__ [or __new__ for immutables], if called without arguments [[beyond self for __init__ and 'cls' for __new__ of course]], prepare a [[new, if mutable]] \"empty\" or \"zero-like\" instance of the class)."], "childNum": 7, "tag": "p", "senID": 3, "childList": [{"text": "__len__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__nonzero__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["For the first question you could implement a singleton class design pattern http://en.wikipedia.org/wiki/Singleton_pattern you should from that restrict the number of instances."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://en.wikipedia.org/wiki/Singleton_pattern", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Singleton_pattern"}]}, {"text": ["For the second question, I think this kind of explains your issue http://docs.python.org/library/stdtypes.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/stdtypes.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html"}]}, {"text": ["Because integers are types, there are limitations to it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here is another resource...\nhttp://docs.python.org/library/functions.html#built-in-funcs"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://docs.python.org/library/functions.html#built-in-funcs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#built-in-funcs"}]}], [{"text": ["Singletons such as None: Create the class with the name you want to give the variable, and then rebind the variable to the (only) instance, or delete the class afterwards.", "This is handy when you want to emulate an interface such as getattr, where a parameter is optional but using None is different from not providing a value."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Singletons such as None:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "getattr", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class raise_error(object): pass\nraise_error = raise_error()\n\ndef example(d, key, default=raise_error):\n  \"\"\"Return d[key] if key in d, else return default or\n  raise KeyError if default isn't supplied.\"\"\"\n  try:\n    return d[key]\n  except KeyError:\n    if default is raise_error:\n      raise\n    return default\n</code>\n</pre>\n", "senID": 1}], [{"text": ["To answer the more generic question of how to create constrained instances, it depends on the constraint.", "Both you examples above are a sort of \"singletons\", although the second example is a variation where you can have many instances of one class, but you will have only one per input value."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["These can both done by overriding the class' __new__ method, so that the class creates the instances if it hasn't been created already, and both returns it, and stores it as an attribute on the class (as has been suggested above).", "However, a slightly less hackish way is to use metaclasses.", "These are classes that change the behaviour of classes, and singletons is a great example of when to use metaclasses.", "And the great thing about this is that you can reuse metaclasses.", "By creating a Singleton metaclass, you can then use this metaclass for all Singletons you have. "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "__new__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "and", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["A nice Python example in on Wikipedia: http://en.wikipedia.org/wiki/Singleton_pattern#Python"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://en.wikipedia.org/wiki/Singleton_pattern#Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Singleton_pattern#Python"}]}, {"text": ["Here is a variation that will create a different instance depending on parameters:\n(It's not perfect.", "If you pass in a parameter which is a dict, it will fail, for example.", "But it's a start):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # Notice how you subclass not from object, but from type. You are in other words\n# creating a new type of type.\nclass SingletonPerValue(type):\n    def __init__(cls, name, bases, dict):\n        super(SingletonPerValue, cls).__init__(name, bases, dict)\n        # Here we store the created instances later.\n        cls.instances = {}\n\n    def __call__(cls, *args, **kw):\n        # We make a tuple out of all parameters. This is so we can use it as a key\n        # This will fail if you send in unhasheable parameters.\n        params = args + tuple(kw.items())\n        # Check in cls.instances if this combination of parameter has been used:\n        if params not in cls.instances:\n            # No, this is a new combination of parameters. Create a new instance,\n            # and store it in the dictionary:\n            cls.instances[params] = super(SingletonPerValue, cls).__call__(*args, **kw)\n\n        return cls.instances[params]\n\n\nclass MyClass(object):\n    # Say that this class should use a specific metaclass:\n    __metaclass__ = SingletonPerValue\n\n    def __init__(self, value):\n        self.value = value\n\nprint 1, MyClass(1)\nprint 2, MyClass(2)\nprint 2, MyClass(2)\nprint 2, MyClass(2)\nprint 3, MyClass(3)\n</code>\n</pre>\n", "senID": 4}, {"text": ["But there are other constraints in Python than instantiation.", "Many of them can be done with metaclasses.", "Others have shortcuts, here is a class that only allows you to set the attributes 'items' and 'fruit', for example. "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class Constrained(object):\n    __slots__ = ['items', 'fruit']\n\ncon = Constrained()\ncon.items = 6\ncon.fruit = \"Banana\"\ncon.yummy = True\n</code>\n</pre>\n", "senID": 6}, {"text": ["If you want restrictions on attributes, but not quite these strong, you can override __getattr__, __setattr__ and __delattr__ to make many fantastic and horrid things happen.", ":-) There are also packages out there that let you set constraints on attributes, etc."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "__getattr__, __setattr__ and __delattr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I think some names for the concept you're thinking about are interning and immutable objects."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "interning", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/String%5Finterning"}, {"href": "http://en.wikipedia.org/wiki/Immutable%5Fobject", "text": "immutable objects", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["As for an answer to your specific questions, I think for #1, you could look up your constrained instance in a class method and return it. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For question #2, I think it's just a matter of how you specify your class.", "A non-specific instance of the int class would be pretty useless, so just spec it so it's impossible to create."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Note: this is not really an answer to your question, but more a comment I could not fit in the \"comment\" space."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Please note that a == b does NOT implies that a is b."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "a == b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "NOT", "childNum": 0, "tag": "strong", "childList": []}, {"text": "a is b", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It is true only for first handfuls of integers (like first hundred or so - I do not know exactly) and it is only an implementation detail of CPython, that actually changed with the switch to Python 3.0."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; n1 = 4000\n&gt;&gt;&gt; n2 = 4000\n&gt;&gt;&gt; n1 == n2\nTrue\n&gt;&gt;&gt; n1 is n2\nFalse\n</code>\n</pre>\n", "senID": 4}]]