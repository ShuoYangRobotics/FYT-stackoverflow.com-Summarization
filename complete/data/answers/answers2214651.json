[[{"text": ["I have done some profiling, and the results are completely counterintuitive.", "For simple array access operations, numpy and array.array are 10x slower than native Python arrays."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy and array.array are 10x slower than native Python arrays", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["Note that for array access, I am doing operations of the form:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a[i] += 1\n</code>\n</pre>\n", "senID": 2}, {"text": ["Profiles:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": ["[0] * 20000000"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["numpy.zeros(shape=(20000000,), dtype=numpy.int32)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["array.array('L', [0] * 20000000)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["array.array('L', (0 for i in range(20000000)))"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]}], [{"text": ["Just a reminder how Python's integers work: if you allocate a list by saying"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = [0] * K\n</code>\n</pre>\n", "senID": 1}, {"text": ["you need the memory for the list (sizeof(PyListObject) + K * sizeof(PyObject*)) and the memory for the single integer object 0.", "As long as the numbers in the list stay below the magic number V that Python uses for caching, you are fine because those are shared, i.e.", "any name that points to a number n &lt; V points to the exact same object.", "You can find this value by using the following snippet:"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "sizeof(PyListObject) + K * sizeof(PyObject*)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "V", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "n &lt; V", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; i = 0\n&gt;&gt;&gt; j = 0\n&gt;&gt;&gt; while i is j:\n...    i += 1\n...    j += 1\n&gt;&gt;&gt; i # on my system!\n257\n</code>\n</pre>\n", "senID": 3}, {"text": ["This means that as soon as the counts go above this number, the memory you need is sizeof(PyListObject) + K * sizeof(PyObject*) + d * sizeof(PyIntObject), where d &lt; K is the number of integers above V (== 256).", "On a 64 bit system, sizeof(PyIntObject) == 24 and sizeof(PyObject*) == 8, i.e.", "the worst case memory consumption is 3,200,000,000 bytes. "], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "sizeof(PyListObject) + K * sizeof(PyObject*) + d * sizeof(PyIntObject)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "d &lt; K", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "V (== 256)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sizeof(PyIntObject) == 24", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "sizeof(PyObject*) == 8", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["With numpy.ndarray or array.array, memory consumption is constant after initialization, but you pay for the wrapper objects that are created transparently, as Thomas Wouters said.", "Probably, you should think about converting the update code (which accesses and increases the positions in the array) to C code, either by using Cython or scipy.weave."], "childNum": 6, "tag": "p", "senID": 5, "childList": [{"text": "numpy.ndarray", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "array.array", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Thomas Wouters", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "#2214678"}, {"text": "Cython", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://cython.org/"}, {"href": "http://www.scipy.org/Weave", "text": "scipy.weave", "childNum": 1, "tag": "a", "childList": [{"text": "scipy.weave", "tag": "code"}]}, {"text": "scipy.weave", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n x = [0] * 100000000\n</code>\n</pre>\n", "senID": 1}, {"text": ["It takes just a few seconds to execute on my machine, and access is close to instant."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you are are not able to vectorize your calculuations, Python/Numpy will be slow.", "Numpy is fast because vectorized calculations occur at a lower level than Python.", "The core numpy functions are all written in C or Fortran.", "Hence sum(a) is not a python loop with many accesses, it's a single low level C call."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sum(a)", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Numpy's Performance Python demo page has a good example with different options.", "You can easily get 100x increase by using a lower level compiled language, Cython, or using vectorized functions if feasible.", "This blog post that shows a 43 fold increase using Cython for a numpy usecase."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Numpy's Performance Python demo page", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.scipy.org/PerformancePython"}, {"text": "This blog post", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.korokithakis.net/node/109"}]}], [{"text": ["It's unlikely you'll find anything faster than numpy's array.", "The implementation of the array itself is as efficient as it would be in, say, C (and basically the same as array.array, just with more usefulness."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "array", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "array.array", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you want to speed up your code, you'll have to do it by doing just that.", "Even though the array is implemented efficiently, accessing it from Python code has certain overhead; for example, indexing the array produces integer objects, which have to be created on the fly.", "numpy offers a number of operations implemented efficiently in C, but without seeing the actual code that isn't performing as well as you want it's hard to make any specific suggestions."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "numpy", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["For fast creation, use the array module."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Using the array module is ~5 times faster for creation, but about twice as slow for accessing elements compared to a normal list:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # Create array\npython -m timeit -s \"from array import array\" \"a = array('I', '\\x00'\n * 100000000)\"\n10 loops, best of 3: 204 msec per loop\n\n# Access array\npython -m timeit -s \"from array import array; a = array('I', '\\x00'\n* 100000000)\" \"a[4975563]\"\n10000000 loops, best of 3: 0.0902 usec per loop\n\n# Create list\npython -m timeit \"a = [0] * 100000000\"\n10 loops, best of 3: 949 msec per loop\n\n# Access list\npython -m timeit  -s \"a = [0] * 100000000\" \"a[4975563]\"\n10000000 loops, best of 3: 0.0417 usec per loop\n</code>\n</pre>\n", "senID": 2}], [{"text": ["In addition to the other excellent solutions, another way is to use a dict instead of an array (elements which exist are non-zero, otherwise they're zero).", "Lookup time is O(1)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You might also check if your application is resident in RAM, rather than swapping out.", "It's only 381 MB, but the system may not be giving you it all for whatever reason."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["However there are also some really fast sparse matrices (SciPy and ndsparse).", "They are done in low-level C, and might also be good."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "SciPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/SciPy"}, {"text": "ndsparse", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "https://launchpad.net/ndsparse"}]}], [{"text": ["NumPy is the appropriate tool for a large, fixed-size, homogeneous array.", "Accessing individual elements of anything in Python isn't going to be all that fast, though whole-array operations can often be conducted at speeds similar to C or Fortran.", "If you need to do operations on millions and millions of elements individually quickly, there is only so much you can get out of Python."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "NumPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/NumPy"}]}, {"text": ["What sort of algorithm are you implementing?", "How do you know that using sparse arrays is too slow if you haven't tried it?", "What do you mean by \"efficient\"?", "You want quick initialization?", "That is the bottleneck of your code?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I would simply create your own data type that doesn't initialize ANY values."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want to read an index position that has NOT been initialized, you return zeroes.", "Still, do not initialize any storage."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you want to read an index position that HAS been initialized, simply return the value."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you want to write to an index position that has NOT been initialized, initialize it, and store the input."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]