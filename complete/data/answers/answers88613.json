[[{"text": ["It just so happens that the tokens you want split are already Python tokens, so you can use the built-in tokenize module.", "It's almost a one-liner:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "tokenize", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from cStringIO import StringIO\nfrom tokenize import generate_tokens\nSTRING = 1\nlist(token[STRING] for token \n     in generate_tokens(StringIO('2+24*48/32').readline)\n     if token[STRING])\n['2', '+', '24', '*', '48', '/', '32']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Building on Cristian's solution, I would suggest matching for digits.", "That way, you won't have to specify every single operator you want to support (=, %, ^, whitespace, etc)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nsplitter = re.compile(r'[\\D]') # Match non-digits\nsplitter.split(\"2+24*48/32=10\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: (JFS)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The last expression returns just a list of strings with numbers without operators.", "Here's an improved variant:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; re.split(r'(\\D)', '2+24*48/32')\n['2', '+', '24', '*', '48', '/', '32']\n</code>\n</pre>\n", "senID": 4}], [{"text": ["This looks like a parsing problem, and thus I am compelled to present a solution based on parsing techniques."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["While it may seem that you want to 'split' this string, I think what you actually want to do is 'tokenize' it.", "Tokenization or lexxing is the compilation step before parsing.", "I have amended my original example in an edit to implement a proper recursive decent parser here.", "This is the easiest way to implement a parser by hand."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import re\n\npatterns = [\n    ('number', re.compile('\\d+')),\n    ('*', re.compile(r'\\*')),\n    ('/', re.compile(r'\\/')),\n    ('+', re.compile(r'\\+')),\n    ('-', re.compile(r'\\-')),\n]\nwhitespace = re.compile('\\W+')\n\ndef tokenize(string):\n    while string:\n\n        # strip off whitespace\n        m = whitespace.match(string)\n        if m:\n            string = string[m.end():]\n\n        for tokentype, pattern in patterns:\n            m = pattern.match(string)\n            if m:\n                yield tokentype, m.group(0)\n                string = string[m.end():]\n\ndef parseNumber(tokens):\n    tokentype, literal = tokens.pop(0)\n    assert tokentype == 'number'\n    return int(literal)\n\ndef parseMultiplication(tokens):\n    product = parseNumber(tokens)\n    while tokens and tokens[0][0] in ('*', '/'):\n        tokentype, literal = tokens.pop(0)\n        if tokentype == '*':\n            product *= parseNumber(tokens)\n        elif tokentype == '/':\n            product /= parseNumber(tokens)\n        else:\n            raise ValueError(\"Parse Error, unexpected %s %s\" % (tokentype, literal))\n\n    return product\n\ndef parseAddition(tokens):\n    total = parseMultiplication(tokens)\n    while tokens and tokens[0][0] in ('+', '-'):\n        tokentype, literal = tokens.pop(0)\n        if tokentype == '+':\n            total += parseMultiplication(tokens)\n        elif tokentype == '-':\n            total -= parseMultiplication(tokens)\n        else:\n            raise ValueError(\"Parse Error, unexpected %s %s\" % (tokentype, literal))\n\n    return total\n\ndef parse(tokens):\n    tokenlist = list(tokens)\n    returnvalue = parseAddition(tokenlist)\n    if tokenlist:\n        print 'Unconsumed data', tokenlist\n    return returnvalue\n\ndef main():\n    string = '2+24*48/32'\n    for tokentype, literal in tokenize(string):\n        print tokentype, literal\n\n    print parse(tokenize(string))\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Implementation of handling of brackets is left as an exercise for the reader.", "This example will correctly do multiplication before addition."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; re.findall(r'\\d+|\\D+', '2+24*48/32=10')\n\n['2', '+', '24', '*', '48', '/', '32', '=', '10']\n</code>\n</pre>\n", "senID": 0}, {"text": ["Matches consecutive digits or consecutive non-digits."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Each match is returned as a new element in the list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Depending on the usage, you may need to alter the regular expression.", "Such as if you need to match numbers with a decimal point."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; re.findall(r'[0-9\\.]+|[^0-9\\.]+', '2+24*48/32=10.1')\n\n['2', '+', '24', '*', '48', '/', '32', '=', '10.1']\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Another solution to this would be to avoid writing a calculator like that altogether.", "Writing an RPN parser is much simpler, and doesn't have any of the ambiguity inherent in writing math with infix notation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator, math\ncalc_operands = {\n    '+': (2, operator.add),\n    '-': (2, operator.sub),\n    '*': (2, operator.mul),\n    '/': (2, operator.truediv),\n    '//': (2, operator.div),\n    '%': (2, operator.mod),\n    '^': (2, operator.pow),\n    '**': (2, math.pow),\n    'abs': (1, operator.abs),\n    'ceil': (1, math.ceil),\n    'floor': (1, math.floor),\n    'round': (2, round),\n    'trunc': (1, int),\n    'log': (2, math.log),\n    'ln': (1, math.log),\n    'pi': (0, lambda: math.pi),\n    'e': (0, lambda: math.e),\n}\n\ndef calculate(inp):\n    stack = []\n    for tok in inp.split():\n        if tok in self.calc_operands:\n            n_pops, func = self.calc_operands[tok]\n            args = [stack.pop() for x in xrange(n_pops)]\n            args.reverse()\n            stack.append(func(*args))\n        elif '.' in tok:\n            stack.append(float(tok))\n        else:\n            stack.append(int(tok))\n    if not stack:\n        raise ValueError('no items on the stack.')\n    return stack.pop()\n    if stack:\n        raise ValueError('%d item(s) left on the stack.' % len(stack))\n\ncalculate('24 38 * 32 / 2 +')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is a parsing problem, so neither regex not split() are the \"good\" solution.", "Use a parser generator instead."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I would look closely at pyparsing.", "There have also been some decent articles about pyparsing in the Python Magazine."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "pyparsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}, {"text": "Python Magazine", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pymag.phparch.com/"}]}], [{"text": ["Regular expressions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; splitter = re.compile(r'([+*/])')\n&gt;&gt;&gt; splitter.split(\"2+24*48/32\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can expand the regular expression to include any other characters you want to split on."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [], [{"text": ["i'm sure Tim meant \"splitter = re.compile(r'([\\D])')\".", "if you copy exactly what he has down you only get the digits not the operators."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Why not just use SymPy?", "It should do what you're trying to achieve."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "SymPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/sympy/"}]}], [{"text": ["This doesn't answer the question exactly, but I believe it solves what you're trying to achieve.", "I would add it as a comment, but I don't have permission to do so yet."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I personally would take advantage of Python's maths functionality directly with exec:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; list(\"2+24*48/32\")\n\n['2', '+', '2', '4', '*', '4', '8', '/', '3', '2']\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; my_string = \"2+24*48/32\"\n&gt;&gt;&gt; my_list = re.findall(r\"-?\\d+|\\S\", my_string)\n&gt;&gt;&gt; print my_list\n\n['2', '+', '24', '*', '48', '/', '32']\n</code>\n</pre>\n", "senID": 0}, {"text": ["This will do the trick.", "I have encountered this kind of problem before."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]