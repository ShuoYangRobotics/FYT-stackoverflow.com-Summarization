[[{"text": ["I've seen several answers pointing to the \"walk in ordered sequence\" feature, which is indeed important, but none highlighting the other big feature, which is \"find first entry with a key >= this\".", "This has many uses even when there's no real need to \"walk\" from there."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example (this came up in a recent SO answer), say you want to generate pseudo-random values with given relative frequencies -- i.e, you're given, say, a dict d:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "d", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n {'wolf': 42, 'sheep': 15, 'dog': 23, 'goat': 15, 'cat': 5}\n</code>\n</pre>\n", "senID": 2}, {"text": ["and need a way to generate 'wolf' with a probability of 42 out of 100 (since 100 is the total of the relative frequencies given), 'sheep' 15 out of 100, and so on; and the number of distinct values can be quite large, as can the relative frequencies."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Then, store the given values (in whatever order) as the values in a tree map, with the corresponding keys being the \"total cumulative frequency\" up to that point.", "I.e."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def preprocess(d):\n    tot = 0\n    for v in d:\n        tot += d[v]\n        treemap.insert(key=tot, value=v)\n    return tot, treemap\n</code>\n</pre>\n", "senID": 5}, {"text": ["Now, generating a value can be pretty fast (O(log(len(d)))), as follows:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "O(log(len(d)))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def generate(tot, treemap, r=random):\n    n = r.randrange(tot)\n    return treemap.firstGTkey(n).value\n</code>\n</pre>\n", "senID": 7}, {"text": ["where firstGTKey is a method that returns the first entry (with .key and .value attributes, in this hypothetical example) with a key > the given argument.", "I've used this approach with large files stored as B-Trees, for example (using e.g.", "bsddb.bt_open and the set_location method)."], "childNum": 5, "tag": "p", "senID": 8, "childList": [{"text": "firstGTKey", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".key", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": ".value", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "bsddb.bt_open", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "set_location", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The reason for keeping the elements in sorted order is for faster retrieval.", "Say I wanted all of the values in the dictionary in a sorted range.", "This is much faster with a TreeDict then with the regular hashmap.", "It basically allows you to keep everything in the dictionary in sorted order.", "I know in the application I'm currently working on uses a class like this to basically query the data structure."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I often use Dict&lt;DateTime, someClassOrValue&gt; when working with industrial process data--\nValve open/close, machinery start/stop, etc."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Dict&lt;DateTime, someClassOrValue&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Having the keys sorted is especially useful when I need to compare time intervals between start/stop or open/close events in a decent amount of time."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["However, since I've been able to use linq in C# I've found that it's often easier to just work with IEnumerables and use the IQueryable extension methods to get the information I need."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Almost all \"GROUP BY\" reporting requires a sorted dictionary."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n summary = sortedDefaultDict()\nfor row in somePileOfData:\n    summary[row.group_by] += row.balance\nfor k in sorted(summary.keys()):\n    print k, summary[k]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is done so often in data warehousing applications, that it's difficult to express how central this is."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If the sorted function call does no work, it saves a ton of time in the long run."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "sorted", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["It's useful when you need to go through a Dictionary in order of the keys; which comes up on occasion.", "I've actually found its infinitely more common in certain programming contests then anything else (think ACM, etc)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The most useful feature of a TreeMap is when you want to quickly find the min or max key; using a sorted dictionary this is often a single method call; and algorithmically can be done in O(log(n)) time, as opposed to iterating over each key looking for a min/max if the collection is unsorted.", "Basically, a much friendlier interface."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["One of the more common times I run into it is when objects are identified by a specific name, and you want to print out the objects ordered according to the name; say a mapping from directory name to number of files in a directory."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["One other place I've used it is in an excel spreadsheet wrapper; mapping from row number to row object.", "This lets you quickly find the last row index, without looping through each row."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Also, it's useful when you can easily define a comparison relation on keys, but not necessarily a hashing function, as needed for HashMaps.", "The best (though weak) example I can think of is case insensitive string keys."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Have you seen that: http://code.activestate.com/recipes/576998/ ?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.activestate.com/recipes/576998/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/576998/"}]}, {"text": ["zuo"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["They can make various algorithms easier to implement."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]