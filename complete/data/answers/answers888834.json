[[{"text": ["You start by instantiating a HTTPServer.", "But you don't actually tell it to start serving in any of the supplied code.", "In your child process try calling server.serve_forever()."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "server.serve_forever()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["See this for reference "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "See this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://snippets.dzone.com/posts/show/654"}]}], [{"text": ["Just use daemontools or some other similar script instead of rolling your own daemonizing process.", "It is much better to keep this off your script."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "daemontools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cr.yp.to/daemontools.html"}]}, {"text": ["Also, your best option: Don't use BaseHTTPServer.", "It is really bad.", "There are many good HTTP servers for python, i.e.", "cherrypy or paste.", "Both includes ready-to-use daemonizing scripts."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "cherrypy", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://cherrypy.org"}, {"text": "paste", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://pythonpaste.org/"}]}], [{"text": ["After a bit of googling I finally stumbled upon:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://blog.doughellmann.com/2007/12/pymotw-basehttpserver.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://blog.doughellmann.com/2007/12/pymotw-basehttpserver.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://blog.doughellmann.com/2007/12/pymotw-basehttpserver.html"}]}, {"text": ["And after that I ended up with:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer\nfrom SocketServer import ThreadingMixIn\n\nclass ThreadedHTTPServer(ThreadingMixIn, HTTPServer):\n  \"\"\"Handle requests in a separate thread.\"\"\"\n\nserver = ThreadedHTTPServer((config['HTTPServer']['listen'],config['HTTPServer']['port']), HTTPHandler)\nserver.serve_forever()\n</code>\n</pre>\n", "senID": 3}, {"text": ["Which for the most part comes after I fork and ended up resolving my problem."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Here's how to do this with the python-daemon library:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "python-daemon", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/python-daemon"}]}, {"code": "<pre>\n<code>\n from BaseHTTPServer import (HTTPServer, BaseHTTPRequestHandler)\nimport contextlib\n\nimport daemon\n\nfrom my_app_config import config\n\n# Make the HTTP Server instance.\nserver = HTTPServer(\n    (config['HTTPServer']['listen'], config['HTTPServer']['port']),\n    BaseHTTPRequestHandler)\n\n# Make the context manager for becoming a daemon process.\ndaemon_context = daemon.DaemonContext()\ndaemon_context.files_preserve = [server.fileno()]\n\n# Become a daemon process.\nwith daemon_context:\n    server.serve_forever()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Since this has solicited answers since I originally posted, I thought that I'd share a little info."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The issue with the output has to do with the fact that the default handler for the logging module uses the StreamHandler.", "The best way to handle this is to create your own handlers.", "In the case where you want to use the default logging module, you can do something like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # Get the default logger\ndefault_logger = logging.getLogger('')\n\n# Add the handler\ndefault_logger.addHandler(myotherhandler)\n\n# Remove the default stream handler\nfor handler in default_logger.handlers:\n    if isinstance(handler, logging.StreamHandler):\n        default_logger.removeHandler(handler)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Also at this point I have moved to using the very nice Tornado project for my embedded http servers."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Tornado", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://tornadoweb.org"}]}], [{"text": ["A simple solution that worked for me was to override the BaseHTTPRequestHandler method log_message(), so we prevent any kind of writing in stdout and avoid problems when demonizing."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "BaseHTTPRequestHandler", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "log_message()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class CustomRequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):\n\n    def log_message(self, format, *args):\n            pass\n\n...\nrest of custom class code\n...\n</code>\n</pre>\n", "senID": 1}]]