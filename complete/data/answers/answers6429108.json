[[{"text": ["Instead of having 5 variables condition_*, use a list, conditions:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "condition_*", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "conditions", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n conditions=[1]*5 # initialize conditions as you wish\nfor line in input_file:\n    for i,condition in enumerate(conditions):\n        if condition:\n            conditions[i]=My_Function(A_tuple[i],B_tuple[i])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Stack Overflow: Replacements for switch statement in python?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Replacements for switch statement in python?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/60208/replacements-for-switch-statement-in-python"}]}], [{"text": ["What about something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n conditions = [condition_A, condition_B, condition_C, condition_D, condition_E]\ncondition_test = lambda c, i: My_Function(A_tuple[i], B_tuple[i]) if c else c\nfor line in input_file:\n    conditions = [condition_test(c, i) for i, c in enumerate(conditions)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["'line' is not referenced in teh loop, is that an error in simplifying it for posting?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["How about"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n condition=1 #or 2 or...\nfor line in input_file:\n   My_Function(A_tuple[condition],B_tuple[condition])\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Before refactoring your code on a purely syntactic level (which is covered in examples above), it might be useful to evaluate what you're doing with the code on a functional level"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Check out your condition_x variables.", "I think you might be using the same variable for two different things (both type-wise and logically) - usually a bad idea in a weakly typed language.", "It looks to me as if the user sets a condition to true or false, and then that condition is assigned the output - is the output boolean?", "is it related to the original value of that variable?", "Rethinking this might lead to more understandable code.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It is also difficult to evaluate how this can be refactored without seeing what goes in to condition_x - since these might have commonalities."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["One more sample(not solution) based on unutbu's:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n data = [1,2,3,'',4,5,6, '', 0]\nfor i in (i for i in xrange(len(data)) if data[i] not in ['',0]):\n    data[i] += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Sorry if duplicate"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here is a generic solution where you can have custom index and you can also access conditions by name if need be and it can be easily extended to add any new complexities"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Condition(object):\n    def __init__(self, active, index1, index2):\n        self.active = active\n        self.index1 = index1\n        self.index2 = index2\n\nconditions = {\n    'A': Condition(True,0,0),\n    'B': Condition(True,1,1),\n    'C': Condition(True,2,2),\n    'D': Condition(True,3,3),\n    'E': Condition(True,4,4),\n}\n\nfor line in input_file:\n    for condition in conditions.itervalues():\n        if condition.active:\n            condition.active = My_Function(A_tuple[condition.active.index1], B_tuple[condition.active.index2])\n</code>\n</pre>\n", "senID": 1}]]