[[{"text": ["This will do it a bit more neatly:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; data = [1,2,3,4,5,6]\n&gt;&gt;&gt; zip(data[0::2], data[1::2])\n[(1, 2), (3, 4), (5, 6)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["(but it's arguably less readable if you're not familiar with the \"stride\" feature of ranges)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Like your code, it discards the last value where you have an odd number of values."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The one often-quoted is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n zip(*[iter(l)] * 2)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I usually copy the grouper recipe from the itertools documentation into my code for this."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "grouper", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/itertools.html", "text": "itertools", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n def grouper(n, iterable, fillvalue=None):\n    \"grouper(3, 'ABCDEFG', 'x') --&gt; ABC DEF Gxx\"\n    args = [iter(iterable)] * n\n    return izip_longest(fillvalue=fillvalue, *args)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about using the step feature of range():"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "range()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n [(l[n],l[n+1]) for n in range(0,len(l),2)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["try this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def pairs(l, n):\n    return zip(*[l[i::n] for i in range(n)])\n</code>\n</pre>\n", "senID": 1}, {"text": ["So,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["pairs([1, 2, 3, 4], 2)\ngives"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "pairs([1, 2, 3, 4], 2)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n [(1, 2), (3, 4)]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The right thing is probably not to compute lists, but to write an iterator->iterator function.", "This is more generic -- it works on every iterable, and if you want to \"freeze\" it into a list, you can use the \"list()\" function."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def groupElements(iterable, n):\n    # For your case, you can hardcode n=2, but I wanted the general case here.\n    # Also, you do not specify what to do if the \n    # length of the list is not divisible by 2\n    # I chose here to drop such elements\n    source = iter(iterable)\n    while True:\n        l = []\n        for i in range(n):\n            l.append(source.next())\n        yield tuple(l)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm surprised the itertools module does not already have a function for that -- perhaps a future revision.", "Until then, feel free to use the version above :)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you don't want to lose elements if their number in list is not even try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; [(l[i],  l[i+1] if i+1 &lt; len(l) else None)  for i in range(0, len(l), 2)]\n[(1, 2), (3, 4), (5, None)]\n</code>\n</pre>\n", "senID": 1}]]