[[{"text": ["Your variable naming is a possible sign that your design could be improved.", "It might be better to use a list instead of three separate variables:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n levels = [{}, {}, {}]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n level1 = level2 = level3 = {}\n</code>\n</pre>\n", "senID": 0}, {"text": ["Doesn\u2019t create copies.", "It lets reference level{1-3} to the same object.", "You can use a list comprehension instead:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "same", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n level1, level2, level3 = [{} for dummy in range(3)]\n</code>\n</pre>\n", "senID": 2}, {"text": ["or more readable:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n level1, level2, level3 = {}, {}, {}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You could do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n level1, level2, level3 = {}, {}, {}\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n level1, level2, level3, = {}, {}, {}\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I personally never change code to squeeze more stuff on one line.", "Have three different assignments is the way I would do it, one per line."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, if there are documented performance improvements by making such a change, that's another thing.", "I just don't know of any performance improvements with these changes.", "Only obfuscation."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["People have already answered the intent of your question, but..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What do you mean by quicker?  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I think your real question should be \"what is the pythonic way to do this?", "\"  "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "should be", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["From the Python documentation:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Python documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#sequence-types-str-unicode-list-tuple-bytearray-buffer-xrange"}]}, {"text": ["a, b, c is implicitly (a, b, c).", "That's why you need to have a 3-tuple on the right side as suggested by other posters (nils, sdolan, gunner). "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Shown explicitly they are suggesting this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n (level1, level2, level3) = ({}, {}, {},)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Python is interpreted which allows the definitions of things to be made at runtime."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def prefixed_range(prefix, start, stop=None, step=1):\n    \" Like xrange() but results are prefixed numeric strings. \"\"\"\n    prefix = str(prefix)\n    if stop is None:\n        start, stop = 0, start\n    for i in xrange(start, stop, step):\n        yield prefix + str(i)\n\ndef define_vars(names, value=None, namespace=None):\n    namespace = globals() if not namespace else namespace\n    factory = (lambda: value) if not callable(value) else value\n    for name in names:\n        namespace[name] = factory()\n\ndefine_vars(prefixed_range('level', 1, 4), dict)\n\nprint 'level1: {}, level2: {}, level3: {}'.format(level1, level2, level3)\n# level1: {}, level2: {}, level3: {}\n</code>\n</pre>\n", "senID": 1}]]