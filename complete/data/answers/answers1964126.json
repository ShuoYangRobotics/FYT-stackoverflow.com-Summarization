[[{"text": ["Remember that you can subclass Python's built-in exception classes (and TypeError would surely be the right built-in exception class to raise here -- that's what Python raises if the number of arguments does not match the signature, in normal cases without *a or **k forms in the signature).", "I like having every package define its own class Error(Exception), and then specific exceptions as needed can multiply inherit as appropriate, e.g."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "TypeError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "*a", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "**k", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "class Error(Exception)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class WrongNumberOfArguments(thispackage.Error, TypeError):\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then, I'd raise WrongNumberOfArguments when I detect such a problem situation."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "raise WrongNumberOfArguments", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This way, any caller who's aware of this package can catch thispackage.Error, if they need to deal with any error specific to the package, while other callers (presumably up higher in the call chain) call still catch the more generic TypeError to deal with any errors such as \"wrong number of arguments used in a function call\"."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "thispackage.Error", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "TypeError", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Why not just do what python does?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; abs(1, 2, 3)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: abs() takes exactly one argument (3 given)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If (as you say in one of the comments) that this is a programmer error, then you can raise AssertionError:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def two(**kwargs):\n    assert len(kwargs) == 2, \"Please only provide two args\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["BTW, if you only have three named arguments, **kwargs seems like an odd way to do it.", "More natural might be:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def two(a=None, b=None, c=None):\n    pass\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I would make a specific one.", "You can catch it and deal with that specific exception since it is a special circumstance that you created :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I would use a ValueError, or a subclass thereof: \"Raised when a built-in operation or function receives an argument that has the right type but an inappropriate value, and the situation is not described by a more precise exception such as IndexError."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Passing 3 or 1 values when exactly 2 are required would technically be an inappropriate value if you consider all of the arguments a single tuple... At least in my opinion!", ":)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I recommend a custom exception.", "Like so:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class NeedExactlyTwo(ValueError):\n    pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you can raise NeedExactlyTwo in your code."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "raise NeedExactlyTwo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Be sure to document this in the docstring for your function."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]