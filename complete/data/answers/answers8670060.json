[[{"text": ["Let's just try this out, shall we:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def updateCache(name, new_data):\n    global cache\n    info = cache[name]\n    datarows = info['datarows']\n    datarows.append(new_data)\n\n\ncache = {'foo': {'datarows': []}, 'bar': {'datarows': []}}\n\nprint cache\nupdateCache('foo', 'bar')\nprint cache\n</code>\n</pre>\n", "senID": 1}, {"text": ["outputs:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {'foo': {'datarows': []}, 'bar': {'datarows': []}}\n{'foo': {'datarows': ['bar']}, 'bar': {'datarows': []}}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["They are redundant, since almost everything in python is a reference.", "(Unless you don't play with some magic functions like __new__)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__new__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["There are actually three options.", "See this link for a description on the different copy flavors.", "See this post for a nice explanation for each of these."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "this link", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/copy.html"}, {"text": "this post", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/a/3975388/1025391"}]}, {"text": ["For the determination of which option applies in this case, you need to investigate the properties of your object.", "In this case you have a mutable container object (dict).", "Which implies that you assign the object reference to the new name, as in (equivalent to c = d = {}):"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "properties of your object", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html"}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "c = d = {}", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["info has a value assigned to it.", "A quick experiment in a Python command line will confirm:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "info", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; cache = {'ProfSmiles':'LikesPython'}\n&gt;&gt;&gt; name = 'ProfSmiles'\n&gt;&gt;&gt; cache[name]\n'LikesPython'\n</code>\n</pre>\n", "senID": 1}, {"text": ["therefore in this case if we did info = cache[name], then type(info) would evaluate to &lt;type 'str'&gt;\nSo yes, the last two lines are redundant"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "info = cache[name]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "type(info)", "childNum": 0, "tag": "code", "childList": []}, {"text": "&lt;type 'str'&gt;", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}], [{"text": ["If cache[name] evaluates to an instance of a value-type (numeric, string, or tuple) it will be passed by value.", "If it is a reference-type (dict, list, most other types), it will be passed by reference and your last two lines will be redundant.", "Of course, if the object is of a reference type but immutable, you'll have to do something else, like make a copy of it and replace the copy in the cache."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "cache[name]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit: this is how I think about it, anyway.", "A possibly more technically correct explanation is that all types are passed by reference in Python, but some types like numerics, strings, and tuples are immutable (basically all hashable types), and therefore you can't make changes to the dereferenced object, and have to treat it as if it were pass-by-value."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Final edit: mutability is independent of hashability (though it would be odd to design a type that was immutable but unhashable), and it is mutability, not hashability, that matters in the OP's case.", "(Of course, name must be hashable to be a key in cache, but cache[name] could be anything."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "name", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "cache", "childNum": 0, "tag": "code", "childList": []}, {"text": "cache[name]", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["As this answer to a related question explains:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/a/986145/183066"}]}, {"text": ["Hence, what has to be taken into account is when some statement changes the state of an object or creates a new one."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["There are two things that you need to consider here"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This has interesting behavior when passing mutable and non mutable objects or a passed mutable reference is rebind-ed.", "Considering two sequence types list and tuples where the former is only mutable."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo(x):\n    print id(x)\n    x+=(2,)    \n&gt;&gt;&gt; x=(1,)\n&gt;&gt;&gt; foo(x)\n37261808\n&gt;&gt;&gt; x\n(1,)\n&gt;&gt;&gt; def bar(x):\n    print id(x)\n    x+=[2]    \n&gt;&gt;&gt; x=[1]\n&gt;&gt;&gt; bar(x)\n43710624\n&gt;&gt;&gt; x\n[1, 2]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["See how the baviour is so different for bar and foo with tuples and lists?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["So lets get back to your example.", "What you are passing is just a key to a global dictionary.", "You needn't worry whether name is passed by value or by reference.", "Because ultimately you are not changing name but a global dictionary cache which is not a part of the parameter. "], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "value", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "reference", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "name", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}]]