[[{"text": ["To retrieve the version from inside your package at runtime (what your question appears to actually be asking), you can use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n version = pkg_resources.require(\"MyProject\")[0].version\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want to go the other way 'round (which appears to be what other answer authors here appear to have thought you were asking), make a version.py in your package with a __version__ line, then read it from setup.py using execfile('mypackage/version.py'), so that it sets __version__ in the setup.py namespace."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "__version__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "execfile('mypackage/version.py')", "childNum": 0, "tag": "code", "childList": []}, {"text": "__version__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["By the way, DO NOT import your package from your setup.py as suggested in another answer here: it will seem to work for you (because you already have your package's dependencies installed), but it will wreak havoc upon new users of your package, as they will not be able to install your package without manually installing the dependencies first."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The best technique is to define __version__ in your product code, then import it into setup.py from there.", "This gives you a value you can read in your running module, and have only one place to define it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__version__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The values in setup.py are not installed, and setup.py doesn't stick around after installation."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["What I did (for example) in coverage.py:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # coverage/__init__.py\n__version__ = \"3.2\"\n\n\n# setup.py\nfrom coverage import __version__\n\nsetup(\n    name = 'coverage',\n    version = __version__,\n    ...\n    )\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This should also work, using regular expressions and depending on the metadata fields to have a format like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n __fieldname__ = 'value'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Use the following at the beginning of your setup.py:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import re\nmain_py = open('yourmodule.py').read()\nmetadata = dict(re.findall(\"__([a-z]+)__ = '([^']+)'\", main_py))\n</code>\n</pre>\n", "senID": 3}, {"text": ["After that, you can use the metadata in your script like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n print 'Author is:', metadata['author']\nprint 'Version is:', metadata['version']\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Create a file in your source tree, e.g.", "in yourbasedir/yourpackage/_version.py .", "Let that file contain only a single line of code, like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["__version__ = \"1.1.0-r4704\""], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__version__ = \"1.1.0-r4704\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Then in your setup.py, open that file and parse out the version number like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\nverstr = \"unknown\"\ntry:\n    verstrline = open('yourpackage/_version.py', \"rt\").read()\nexcept EnvironmentError:\n    pass # Okay, there is no version file.\nelse:\n    VSRE = r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\"\n    mo = re.search(VSRE, verstrline, re.M)\n    if mo:\n        verstr = mo.group(1)\n    else:\n        raise RuntimeError(\"unable to find version in yourpackage/_version.py\")\n</pre>\n", "senID": 3}, {"text": ["Finally, in yourbasedir/yourpackage/__init__.py import _version like this:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "yourbasedir/yourpackage/__init__.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n__version__ = \"unknown\"\ntry:\n    from _version import __version__\nexcept ImportError:\n    # We're running in a tree that doesn't have a _version.py, so we don't know what our version is.\n    pass\n</pre>\n", "senID": 5}, {"text": ["An example of code that does this is the \"pyutil\" package that I maintain.", "(See PyPI or google search -- stackoverflow is disallowing me from including a hyperlink to it in this answer."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["@pjeby is right that you shouldn't import your package from its own setup.py.", "That will work when you test it by creating a new Python interpreter and executing setup.py in it first thing: python setup.py, but there are cases when it won't work.", "That's because import youpackage doesn't mean to read the current working directory for a directory named \"yourpackage\", it means to look in the current sys.modules for a key \"yourpackage\" and then to do various things if it isn't there.", "So it always works when you do python setup.py because you have a fresh, empty sys.modules, but this doesn't work in general."], "childNum": 5, "tag": "p", "senID": 7, "childList": [{"text": "python setup.py", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "import youpackage", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "sys.modules", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "python setup.py", "childNum": 0, "tag": "code", "childList": []}, {"text": "sys.modules", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For example, what if py2exe is executing your setup.py as part of the process of packaging up an application?", "I've seen a case like this where py2exe would put the wrong version number on a package because the package was getting its version number from import myownthing in its setup.py, but a different version of that package had previously been imported during the py2exe run.", "Likewise, what if setuptools, easy_install, distribute, or distutils2 is trying to build your package as part of a process of installing a different package that depends on yours?", "Then whether your package is importable at the time that its setup.py is being evaluated, or whether there is already a version of your package that has been imported during this Python interpreter's life, or whether importing your package requires other packages to be installed first, or has side-effects, can change the results.", "I've had several struggles with trying to re-use Python packages which caused problems for tools like py2exe and setuptools because their setup.py imports the package itself in order to find its version number."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "import myownthing", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["By the way, this technique plays nicely with tools to automatically create the yourpackage/_version.py file for you, for example by reading your revision control history and writing out a version number based on the most recent tag in revision control history.", "Here is a tool that does that for darcs: http://tahoe-lafs.org/trac/darcsver/browser/trunk/README.rst and here is a code snippet which does the same thing for git: http://github.com/warner/python-ecdsa/blob/0ed702a9d4057ecf33eea969b8cf280eaccd89a1/setup.py#L34"], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "yourpackage/_version.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "http://tahoe-lafs.org/trac/darcsver/browser/trunk/README.rst", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://tahoe-lafs.org/trac/darcsver/browser/trunk/README.rst"}, {"href": "http://github.com/warner/python-ecdsa/blob/0ed702a9d4057ecf33eea969b8cf280eaccd89a1/setup.py#L34", "text": "http://github.com/warner/python-ecdsa/blob/0ed702a9d4057ecf33eea969b8cf280eaccd89a1/setup.py#L34", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Your question is a little vague, but I think what you are asking is how to specify it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You need to define __version__ like so:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__version__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n __version__ = '1.4.4'\n</code>\n</pre>\n", "senID": 2}, {"text": ["And then you can confirm that setup.py knows about the version you just specified:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n % ./setup.py --version\n1.4.4\n</code>\n</pre>\n", "senID": 4}], [{"text": ["To avoid importing a file (and thus executing its code) one could parse it and recover the version attribute from the syntax tree:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "version", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # assuming 'path' holds the path to the file\n\nimport ast\n\nwith open(path, 'rU') as file:\n    t = compile(file.read(), path, 'exec', ast.PyCF_ONLY_AST)\n    for node in (n for n in t.body if isinstance(n, ast.Assign)):\n        if len(node.targets) == 1:\n            name = node.targets[0]\n            if isinstance(name, ast.Name) and \\\n                    name.id in ('__version__', '__version_info__', 'VERSION'):\n                v = node.value\n                if isinstance(v, ast.Str):\n                    version = v.s\n                    break\n                if isinstance(v, ast.Tuple):\n                    r = []\n                    for e in v.elts:\n                        if isinstance(e, ast.Str):\n                            r.append(e.s)\n                        elif isinstance(e, ast.Num):\n                            r.append(str(e.n))\n                    version = '.'.join(r)\n                    break\n</code>\n</pre>\n", "senID": 1}, {"text": ["This code tries to find the __version__ or VERSION assignment at the top level of the module return is string value.", "The right side can be either a string or a tuple."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "__version__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "VERSION", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}]]