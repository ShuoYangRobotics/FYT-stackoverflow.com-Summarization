[[{"text": ["You can also use urllib2 as CheryPy does."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "CheryPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.google.com/codesearch/p?hl=en&sa=N&cd=9&ct=rc#OQvO9n2mc04/CherryPy-3.0.1/cherrypy/lib/httpauth.py&q=Authorization%20Digest%20http%20lang%3Apython"}]}, {"text": ["here is the snippet:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n input= \"\"\"\n Authorization: Digest qop=\"chap\",\n\t realm=\"testrealm@host.com\",\n\t username=\"Foobear\",\n\t response=\"6629fae49393a05397450978507c4ef1\",\n\t cnonce=\"5ccc069c403ebaf9f0171e9517f40e41\"\n\"\"\"\nimport urllib2\nfield, sep, value = input.partition(\"Authorization: Digest \")\nif value:\n\titems = urllib2.parse_http_list(value)\n\topts = urllib2.parse_keqv_list(items)\n\topts['protocol'] = 'Digest'\n\tprint opts\n</code>\n</pre>\n", "senID": 2}, {"text": ["it outputs:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n {'username': 'Foobear', 'protocol': 'Digest', 'qop': 'chap', 'cnonce': '5ccc069c403ebaf9f0171e9517f40e41', 'realm': 'testrealm@host.com', 'response': '6629fae49393a05397450978507c4ef1'}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["A little regex:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nreg=re.compile('(\\w+)[:=] ?\"?(\\w+)\"?')\n\n&gt;&gt;&gt;dict(reg.findall(headers))\n\n{'username': 'Foobear', 'realm': 'testrealm', 'qop': 'chap', 'cnonce': '5ccc069c403ebaf9f0171e9517f40e41', 'response': '6629fae49393a05397450978507c4ef1', 'Authorization': 'Digest'}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's my pyparsing attempt:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n text = \"\"\"Authorization: Digest qop=\"chap\",\n    realm=\"testrealm@host.com\",     \n    username=\"Foobear\",     \n    response=\"6629fae49393a05397450978507c4ef1\",     \n    cnonce=\"5ccc069c403ebaf9f0171e9517f40e41\" \"\"\"\n\nfrom pyparsing import *\n\nAUTH = Keyword(\"Authorization\")\nident = Word(alphas,alphanums)\nEQ = Suppress(\"=\")\nquotedString.setParseAction(removeQuotes)\n\nvalueDict = Dict(delimitedList(Group(ident + EQ + quotedString)))\nauthentry = AUTH + \":\" + ident(\"protocol\") + valueDict\n\nprint authentry.parseString(text).dump()\n</code>\n</pre>\n", "senID": 1}, {"text": ["which prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ['Authorization', ':', 'Digest', ['qop', 'chap'], ['realm', 'testrealm@host.com'],\n ['username', 'Foobear'], ['response', '6629fae49393a05397450978507c4ef1'], \n ['cnonce', '5ccc069c403ebaf9f0171e9517f40e41']]\n- cnonce: 5ccc069c403ebaf9f0171e9517f40e41\n- protocol: Digest\n- qop: chap\n- realm: testrealm@host.com\n- response: 6629fae49393a05397450978507c4ef1\n- username: Foobear\n</code>\n</pre>\n", "senID": 3}, {"text": ["I'm not familiar with the RFC, but I hope this gets you rolling."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If those components will always be there, then a regex will do the trick:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n test = '''Authorization: Digest qop=\"chap\", realm=\"testrealm@host.com\", username=\"Foobear\", response=\"6629fae49393a05397450978507c4ef1\", cnonce=\"5ccc069c403ebaf9f0171e9517f40e41\"'''\n\nimport re\n\nre_auth = re.compile(r\"\"\"\n    Authorization:\\s*(?P&lt;protocol&gt;[^ ]+)\\s+\n    qop=\"(?P&lt;qop&gt;[^\"]+)\",\\s+\n    realm=\"(?P&lt;realm&gt;[^\"]+)\",\\s+\n    username=\"(?P&lt;username&gt;[^\"]+)\",\\s+\n    response=\"(?P&lt;response&gt;[^\"]+)\",\\s+\n    cnonce=\"(?P&lt;cnonce&gt;[^\"]+)\"\n    \"\"\", re.VERBOSE)\n\nm = re_auth.match(test)\nprint m.groupdict()\n</code>\n</pre>\n", "senID": 1}, {"text": ["produces:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n { 'username': 'Foobear', \n  'protocol': 'Digest', \n  'qop': 'chap', \n  'cnonce': '5ccc069c403ebaf9f0171e9517f40e41', \n  'realm': 'testrealm@host.com', \n  'response': '6629fae49393a05397450978507c4ef1'\n}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I would recommend finding a correct library for parsing http headers unfortunately I can't reacall any.", ":("], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For a while check the snippet below (it should mostly work):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n input= \"\"\"\n Authorization: Digest qop=\"chap\",\n\t realm=\"testrealm@host.com\",\n\t username=\"Foob,ear\",\n\t response=\"6629fae49393a05397450978507c4ef1\",\n\t cnonce=\"5ccc069c403ebaf9f0171e9517f40e41\"\n\"\"\"\n\nfield, sep, value = input.partition(\":\")\nif field.endswith('Authorization'):\n   protocol, sep, opts_str = value.strip().partition(\" \")\n\n   opts = {}\n   for opt in opts_str.split(\",\\n\"):\n\t\tkey, value = opt.strip().split('=')\n\t\tkey = key.strip(\" \")\n\t\tvalue = value.strip(' \"')\n\t\topts[key] = value\n\n   opts['protocol'] = protocol\n\n   print opts\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The http digest Authorization header field is a bit of an odd beast.", "Its format is similar to that of rfc 2616's Cache-Control and Content-Type header fields, but just different enough to be incompatible.", "If you're still looking for a library that's a little smarter and more readable than the regex, you might try removing the Authorization: Digest part with str.split() and parsing the rest with parse_dict_header() from Werkzeug's http module.", "(Werkzeug can be installed on App Engine."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "rfc 2616", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://tools.ietf.org/html/rfc2616"}, {"text": "str.split()", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#str.split"}, {"text": "parse_dict_header()", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://werkzeug.pocoo.org/documentation/dev/http.html#werkzeug.parse_dict_header"}, {"text": "Werkzeug", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://werkzeug.pocoo.org/"}]}], [{"text": ["If your response comes in a single string that that never varies and has as many lines as there are expressions to match, you can split it into an array on the newlines called authentication_array and use regexps:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "never varies and has as many lines as there are expressions to match", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "authentication_array", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n pattern_array = ['qop', 'realm', 'username', 'response', 'cnonce']\ni = 0\nparsed_dict = {}\n\nfor line in authentication_array:\n    pattern = \"(\" + pattern_array[i] + \")\" + \"=(\\\".*\\\")\" # build a matching pattern\n    match = re.search(re.compile(pattern), line)         # make the match\n    if match:\n        parsed_dict[match.group(1)] = match.group(2)\n    i += 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Your original concept of using PyParsing would be the best approach.", "What you've implicitly asked for is something that requires a grammar... that is, a regular expression or simple parsing routine is always going to be brittle, and that sounds like it's something you're trying to avoid."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It appears that getting pyparsing on google app engine is easy: http://stackoverflow.com/questions/1341137/how-do-i-get-pyparsing-set-up-on-the-google-app-engine"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://stackoverflow.com/questions/1341137/how-do-i-get-pyparsing-set-up-on-the-google-app-engine", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1341137/how-do-i-get-pyparsing-set-up-on-the-google-app-engine"}]}, {"text": ["So I'd go with that, and then implement the full HTTP authentication/authorization header support from rfc2617."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Nadia's regex only matches alphanumeric characters for the value of a parameter.", "That means it fails to parse at least two fields.", "Namely, the uri and qop.", "According to RFC 2617, the uri field is a duplicate of the string in the request line (i.e.", "the first line of the HTTP request).", "And qop fails to parse correctly if the value is \"auth-int\" due to the non-alphanumeric '-'."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This modified regex allows the URI (or any other value) to contain anything but ' ' (space), '\"' (qoute), or ',' (comma).", "That's probably more permissive than it needs to be, but shouldn't cause any problems with correctly formed HTTP requests."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "correctly", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n reg re.compile('(\\w+)[:=] ?\"?([^\" ,]+)\"?')\n</code>\n</pre>\n", "senID": 2}, {"text": ["Bonus tip:  From there, it's fairly straight forward to convert the example code in RFC-2617 to python.", "Using python's md5 API, \"MD5Init()\" becomes \"m = md5.new()\", \"MD5Update()\" becomes \"m.update()\" and \"MD5Final()\" becomes \"m.digest()\"."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]