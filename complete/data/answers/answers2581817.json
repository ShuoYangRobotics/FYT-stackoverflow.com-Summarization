[[{"text": ["You're right - there is no nice API for this.", "You're also right on your second point - it's trivially easy to design a function that does this for you using threading."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import threading\nimport subprocess\n\ndef popenAndCall(onExit, popenArgs):\n    \"\"\"\n    Runs the given args in a subprocess.Popen, and then calls the function\n    onExit when the subprocess completes.\n    onExit is a callable object, and popenArgs is a list/tuple of args that \n    would give to subprocess.Popen.\n    \"\"\"\n    def runInThread(onExit, popenArgs):\n        proc = subprocess.Popen(*popenArgs)\n        proc.wait()\n        onExit()\n        return\n    thread = threading.Thread(target=runInThread, args=(onExit, popenArgs))\n    thread.start()\n    # returns immediately after the thread starts\n    return thread\n</code>\n</pre>\n", "senID": 1}, {"text": ["Even threading is pretty easy in Python, but note that if onExit() is computationally expensive, you'll want to put this in a separate process instead using multiprocessing (so that the GIL doesn't slow your program down).", "It's actually very simple - you can basically just replace all calls to threading.Thread with multiprocessing.Process since they follow (almost) the same API."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "threading.Thread", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "multiprocessing.Process", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I had same problem, and solved it using multiprocessing.Pool.", "There are two hacky tricks involved:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "multiprocessing.Pool", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["result is one function executed with callback on completion"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def sub(arg):\n    print arg             #prints [1,2,3,4,5]\n    return \"hello\"\n\ndef cb(arg):\n    print arg             # prints \"hello\"\n\npool = multiprocessing.Pool(1)\nrval = pool.map_async(sub,([[1,2,3,4,5]]),callback =cb)\n(do stuff) \npool.close()\n</code>\n</pre>\n", "senID": 2}, {"text": ["In my case, I wanted invocation to be non-blocking as well.", "Works beautifully"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["There is concurrent.futures module in Python 3.2 (available via pip install futures for older Python &lt; 3.2):"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "concurrent.futures", "tag": "a", "pos": 0, "childList": [{"text": "concurrent.futures", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/dev/library/concurrent.futures"}, {"text": "concurrent.futures", "childNum": 0, "tag": "code", "childList": []}, {"text": "pip install futures", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n pool = Pool(max_workers=1)\nf = pool.submit(subprocess.call, \"sleep 2; echo done\", shell=True)\nf.add_done_callback(callback)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The callback will be called in the same process that called f.add_done_callback()."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "f.add_done_callback()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import logging\nimport subprocess\n# to install run `pip install futures` on Python &lt;3.2\nfrom concurrent.futures import ThreadPoolExecutor as Pool\n\ninfo = logging.getLogger(__name__).info\n\ndef callback(future):\n    if future.exception() is not None:\n        info(\"got exception: %s\" % future.exception())\n    else:\n        info(\"process returned %d\" % future.result())\n\ndef main():\n    logging.basicConfig(\n        level=logging.INFO,\n        format=(\"%(relativeCreated)04d %(process)05d %(threadName)-10s \"\n                \"%(levelname)-5s %(msg)s\"))\n\n    # wait for the process completion asynchronously\n    info(\"begin waiting\")\n    pool = Pool(max_workers=1)\n    f = pool.submit(subprocess.call, \"sleep 2; echo done\", shell=True)\n    f.add_done_callback(callback)\n    pool.shutdown(wait=False) # no .submit() calls after that point\n    info(\"continue waiting asynchronously\")\n\nif __name__==\"__main__\":\n    main()\n</code>\n</pre>\n", "senID": 3}, {"code": "<pre>\n<code>\n $ python . &amp;&amp; python3 .\n0013 05382 MainThread INFO  begin waiting\n0021 05382 MainThread INFO  continue waiting asynchronously\ndone\n2025 05382 Thread-1   INFO  process returned 0\n0007 05402 MainThread INFO  begin waiting\n0014 05402 MainThread INFO  continue waiting asynchronously\ndone\n2018 05402 Thread-1   INFO  process returned 0\n</code>\n</pre>\n", "senID": 4}], [{"text": ["AFAIK there is no such API, at least not in subprocess module.", "You need to roll something on your own, possibly using threads."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "subprocess", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["multiprocessing?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "multiprocessing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/multiprocessing.html"}]}], [{"text": ["I was inspired by Daniel G. answer and implemented a very simple use case - in my work I often need to make repeated calls to the same (external) process with different arguments.", "I had hacked a way to determine when each specific call was done, but now I have a much cleaner way to issue callbacks. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I like this implementation because it is very simple, yet it allows me to issue asynchronous calls to multiple processors (notice I use multiprocessing instead of threading) and receive notification upon completion."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "multiprocessing", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "threading", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I tested the sample program and works great.", "Please edit at will and provide feedback."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import multiprocessing\nimport subprocess\n\nclass Process(object):\n    \"\"\"This class spawns a subprocess asynchronously and calls a\n    `callback` upon completion; it is not meant to be instantiated\n    directly (derived classes are called instead)\"\"\"\n    def __call__(self, *args):\n    # store the arguments for later retrieval\n    self.args = args\n    # define the target function to be called by\n    # `multiprocessing.Process`\n    def target():\n        cmd = [self.command] + [str(arg) for arg in self.args]\n        process = subprocess.Popen(cmd)\n        # the `multiprocessing.Process` process will wait until\n        # the call to the `subprocess.Popen` object is completed\n        process.wait()\n        # upon completion, call `callback`\n        return self.callback()\n    mp_process = multiprocessing.Process(target=target)\n    # this call issues the call to `target`, but returns immediately\n    mp_process.start()\n    return mp_process\n\nif __name__ == \"__main__\":\n\n    def squeal(who):\n    \"\"\"this serves as the callback function; its argument is the\n    instance of a subclass of Process making the call\"\"\"\n    print \"finished %s calling %s with arguments %s\" % (\n        who.__class__.__name__, who.command, who.args)\n\n    class Sleeper(Process):\n    \"\"\"Sample implementation of an asynchronous process - define\n    the command name (available in the system path) and a callback\n    function (previously defined)\"\"\"\n    command = \"./sleeper\"\n    callback = squeal\n\n    # create an instance to Sleeper - this is the Process object that\n    # can be called repeatedly in an asynchronous manner\n    sleeper_run = Sleeper()\n\n    # spawn three sleeper runs with different arguments\n    sleeper_run(5)\n    sleeper_run(2)\n    sleeper_run(1)\n\n    # the user should see the following message immediately (even\n    # though the Sleeper calls are not done yet)\n    print \"program continued\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["Sample output:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n program continued\nfinished Sleeper calling ./sleeper with arguments (1,)\nfinished Sleeper calling ./sleeper with arguments (2,)\nfinished Sleeper calling ./sleeper with arguments (5,)\n</code>\n</pre>\n", "senID": 5}, {"text": ["Below is the source code of sleeper.c - my sample \"time consuming\" external process"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "sleeper.c", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #include&lt;stdlib.h&gt;\n#include&lt;unistd.h&gt;\n\nint main(int argc, char *argv[]){\n  unsigned int t = atoi(argv[1]);\n  sleep(t);\n  return EXIT_SUCCESS;\n}\n</code>\n</pre>\n", "senID": 7}, {"text": ["compile as:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n gcc -o sleeper sleeper.c\n</code>\n</pre>\n", "senID": 9}]]