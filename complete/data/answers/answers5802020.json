[[{"text": ["In contrast to Ruby, you can't change the behaviour of built-in types in Python.", "All you can do is create a new type derived from a built-in type.", "Literals will still create the built-in type, though."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "derived", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Probably the best you can get is"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class T(tuple):\n    def __add__(self, other):\n        return T(x + y for x, y in zip(self, other))\n    def __rmul__(self, other):\n        return T(other * x for x in self)\na = T((1, 2))\nb = T((3, 4))\nc = a + b # c would be (4, 6)\nd = 3 * b # d would be (9, 12)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You cannot modify types defined in C, so you would need to create all new types for this.", "Or you could just use NumPy, which already has types that support this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can inherit a class from tuple and overload its __add__ method.", "Here's a very simplistic example:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "tuple", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__add__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n class mytuple(tuple):\n    def __add__(self, other):\n        assert len(self) == len(other)\n        return tuple([x + y for x, y in zip(self, other)])\n\nmt = mytuple((5, 6))\nprint mt + (2, 3)  # prints (7, 9)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I wouldn't recommend this approach though, because tuples weren't really designed for this purpose.", "If you want to perform numeric computations, just use numpy."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "numpy", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Using python complex numbers is definitely one way to do it, if not extremely pretty."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = 1 + 2j\nb = 3 + 4j\nc = a + b # c would be 4 + 6j\nd = 3 * b # d would be 9 + 12j\n</code>\n</pre>\n", "senID": 1}, {"text": ["That saves the definition of an extra class."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Also, expanding on previous answers, "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class T(tuple):\n    def __add__((x, y), (x1, y1)):\n        return T((x+x1, y+y1))\n    def __rmul__((x, y), other):\n        return T((other * x, other * y))\n</code>\n</pre>\n", "senID": 4}, {"text": ["would improve performance, at the cost of restraining the implementation to pairs."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Write your own class and implement __mul__, __add__ etc."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__mul__, __add__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can use numpy.array to get all you need."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy.array", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["There is the famous infix operator hack that would allow you to do soemthing like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "infix operator hack", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/384122-infix-operators/"}]}, {"code": "<pre>\n<code>\n x = Infix(lambda a,b:tuple([x+y for x, y in zip(a, b)]))\ny = Infix(lambda a,b:tuple([a*y for y in b]))\n\nc = a |x| b # c would be (4, 6)\nd = 3 |y| b # d would be (9, 12)\n</code>\n</pre>\n", "senID": 1}, {"text": ["That would hide the generator expressions and be applicable to tuples of all lengths, at the expense of \"weird\" pseudo-operators |x| and |y|."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "|x|", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "|y|", "childNum": 0, "tag": "code", "childList": []}]}]]