[[{"text": ["Lists in Python as stored by reference."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "reference", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["This means that when you do list2 = list1, you are not making a copy of the list - you are merely saying \"list2 refers to the same thing list1 does,\" namely, the list you originally created when you did list1 = []."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "list2 = list1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list2", "childNum": 0, "tag": "code", "childList": []}, {"text": "list1", "childNum": 0, "tag": "code", "childList": []}, {"text": "list1 = []", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Python specifies += to mean \"append in place\" for lists, because most of the time when you're using += on lists, that's what you want to do - you usually don't want to create new lists every single time you add an element."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "+=", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Thus, when you append to list2, which \"refers to the same object list1 does,\" and then read from list1, you see the appended item, as is expected since both of them point at the same list."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "list2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list1", "childNum": 0, "tag": "code", "childList": []}, {"text": "list1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["With +, however, a new list is always created because it doesn't make sense to modify either of the operands in place (since a+b doesn't imply the modification of a or b)."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a+b", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Therefore, when you do list2 = list2 + [1], you create a new list that has all of the contents of the original object pointed to by list2 and also 1, and then say that list2 now references that new list.", "Since it now references a different list than list1 does, when you go to read from list1 you still see the original list without the extra 1."], "childNum": 7, "tag": "p", "senID": 5, "childList": [{"text": "list2 = list2 + [1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "list2", "childNum": 0, "tag": "code", "childList": []}, {"text": "list1", "childNum": 0, "tag": "code", "childList": []}, {"text": "list1", "childNum": 0, "tag": "code", "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["From the Python 2.6.4 documentation, Section 6.2.1.", "(Augmented assignment statements)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["[Emphasis added]"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["See in the documentation regardingEmulating numeric types, which describes the methods that implement this behaviour.", "This also applies to lists:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "documentation regardingEmulating numeric types", "tag": "a", "pos": 0, "childList": [{"text": "Emulating numeric types", "tag": "em"}], "childNum": 1, "href": "http://docs.python.org/reference/datamodel.html#object.__iadd__"}, {"text": "Emulating numeric types", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}], [{"text": ["When you do list2 += [1] you are modifying the list in place.", "And that is why you don't change the reference the list points to, but you are changing the list directly.", "When you do a list2 = list2 + [1], you are creating a new list. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "list2 += [1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list2 = list2 + [1]", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l = []\n&gt;&gt;&gt; id(l)\n41523720L\n&gt;&gt;&gt; l += [3]\n&gt;&gt;&gt; id(l)\n41523720L     # same as l = []\n&gt;&gt;&gt; l = l+[3]\n&gt;&gt;&gt; id(l)\n41532232L\n</code>\n</pre>\n", "senID": 1}, {"text": ["That explains the difference. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Well, because that's how it works.", "When you write list2 = list2 + [1], you create new list and bind it to list2 name.", "When you use +=, operation happens \"in place\".", "So when list1 and list2 references the same object, which is case here, you modify it with += operator."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "list2 = list2 + [1]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "list2", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "childList": []}, {"text": "list1", "childNum": 0, "tag": "code", "childList": []}, {"text": "list2", "childNum": 0, "tag": "code", "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["That's how += is supposed to work.", "In general,"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "+=", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a += b\n</code>\n</pre>\n", "senID": 1}, {"text": ["means"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a = a + b\n</code>\n</pre>\n", "senID": 3}, {"text": ["But your particular scenario has a different problem.", "When you write"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n list2 = list1\n</code>\n</pre>\n", "senID": 5}, {"text": ["no copy is made; list2 is now a reference to the very same list.", "Any modifications to list2 will be visible in list1 and vice versa."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "list2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list2", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "list1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In your second code snippet, list2 + [1] constructs a new list which is subsequently assigned to list2.", "Since this copy is independent of list1, no change to list1 is visible."], "childNum": 5, "tag": "p", "senID": 7, "childList": [{"text": "list2 + [1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "new", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "list2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "list1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "list1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["(Nitpicker's corner: Using operator overloading, it is possible to construct a class that behaves differently for +=.", "Don't.", "Just...", "don't."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "is", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["In python, what you think of as variable names are more akin to pointers in most cases; \"=\" doesn't copy an object, it binds a new name to that object (\"copy by reference\" in other contexts).", "So list2 = list1 means that both of those names point to the same list, not just two copies of an identical list.", "Hence, \"+=\" modifies the single list which is pointed at by both names."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "list2 = list1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "same", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["You can copy the list element-by-element (list2 = [i for in list1]) or by using the copy module (list2 = copy.copy(list1))"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "list2 = [i for in list1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "copy", "childNum": 0, "tag": "code", "childList": []}, {"text": "list2 = copy.copy(list1)", "childNum": 0, "tag": "code", "childList": []}]}]]