[[{"text": ["I prefer the anonymous dict option."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I don't like the dict() option for the same reason I don't like:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "dict()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n i = int(\"1\")\n</code>\n</pre>\n", "senID": 2}, {"text": ["With the dict() option you're needlessly calling a function which is adding overhead you don't need:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "dict()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from timeit import Timer\n&gt;&gt;&gt; Timer(\"mydict = {'a' : 1, 'b' : 2, 'c' : 'three'}\").timeit()\n0.91826782454194589\n&gt;&gt;&gt; Timer(\"mydict = dict(a=1, b=2, c='three')\").timeit()\n1.9494664824719337\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I think in this specific case I'd probably prefer this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n foo.update(bar=42, baz='qux')\n</code>\n</pre>\n", "senID": 1}, {"text": ["In the more general case, I often prefer the literal syntax (what you call an anonymous dictionary, though it's just as anonymous to use {} as it is to use dict()).", "I think that speaks more clearly to the maintenance programmer (often me), partly because it stands out so nicely with syntax-highlighting text editors.", "It also ensures that when I have to add a key which is not representable as a Python name, like something with spaces, then I don't have to go and rewrite the whole line."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "{}", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["I prefer your \"anonymous dictionary\" method and I think this is purely a personal style thing.", "I just find the latter version more readable but it's also what I'm used to seeing. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The dict() method has the added overhead of a function call."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;import timeit,dis\n&gt;&gt;&gt; timeit.Timer(\"{'bar': 42, 'baz': 'qux'}\").repeat()\n[0.59602910425766709, 0.60173793037941437, 0.59139834811408321]\n&gt;&gt;&gt; timeit.Timer(\"dict(bar=42, baz='qux')\").repeat()\n[0.98166498814792646, 0.97745355904172015, 0.99231773870701545]\n\n&gt;&gt;&gt; dis.dis(compile(\"{'bar': 42, 'baz': 'qux'}\",\"\",\"exec\"))\n  1           0 BUILD_MAP                0\n              3 DUP_TOP\n              4 LOAD_CONST               0 (42)\n              7 ROT_TWO\n              8 LOAD_CONST               1 ('bar')\n             11 STORE_SUBSCR\n             12 DUP_TOP\n             13 LOAD_CONST               2 ('qux')\n             16 ROT_TWO\n             17 LOAD_CONST               3 ('baz')\n             20 STORE_SUBSCR\n             21 POP_TOP\n             22 LOAD_CONST               4 (None)\n             25 RETURN_VALUE\n\n&gt;&gt;&gt; dis.dis(compile(\"dict(bar=42, baz='qux')\",\"\",\"exec\"))\n  1           0 LOAD_NAME                0 (dict)\n              3 LOAD_CONST               0 ('bar')\n              6 LOAD_CONST               1 (42)\n              9 LOAD_CONST               2 ('baz')\n             12 LOAD_CONST               3 ('qux')\n             15 CALL_FUNCTION          512\n             18 POP_TOP\n             19 LOAD_CONST               4 (None)\n             22 RETURN_VALUE\n</code>\n</pre>\n", "senID": 1}], [{"text": ["My answer will largely talk about the design of APIs to use dicts vs. keyword args.", "But it's also applicable the individual use of {...} vs. dict(...)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "{...}", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "dict(...)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The bottom line: be consistent.", "If most of your code will refer to 'bar' as a string - keep it a string in {...}; if you normally refer to it the identifier bar - use dict(bar=...)."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "'bar'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "{...}", "childNum": 0, "tag": "code", "childList": []}, {"text": "bar", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict(bar=...)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Constraints"], "childNum": 0, "tag": "h2", "senID": 2, "childList": []}, {"text": ["Before talking about style, note that the keyword bar=42 syntax works only for strings and only if they are valid identifiers.", "If you need arbitrary punctuation, spaces, unicode - or even non-string keys - the question is over => only the {'bar': 42} syntax will work."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "bar=42", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "{'bar': 42}", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This also means that when designing an API, you must allow full dicts, and not only keyword arguments - unless you are sure that only strings, and only valid identifiers are allowed.", "(Technically, update(**{'spaces &amp; punctuation': 42}) works.", "But it's ugly.", "And numbers/tuples/unicode won't work."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "update(**{'spaces &amp; punctuation': 42})", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Note that dict() and dict.update() combine both APIs: you can pass a single dict, you can pass keyword args, and you can even pass both (the later I think is undocumented).", "So if you want to be nice, allow both:"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "dict()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict.update()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def update(self, *args, **kwargs):\n    \"\"\"Callable as dict() - with either a mapping or keyword args:\n\n    .update(mapping)\n    .update(**kwargs)\n    \"\"\"\n    mapping = dict(*args, **kwargs)\n    # do something with `mapping`...\n</code>\n</pre>\n", "senID": 6}, {"text": ["This is especially recommended for a method named .update(), to follow the least-surprise rule."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": ".update()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Style"], "childNum": 0, "tag": "h2", "senID": 8, "childList": []}, {"text": ["I find it nice to distinguish internal from external strings.", "By internal I mean arbitrary identifiers denoting something only inside the program (variable names, object attributes) or possibly between several programs (DB columns, XML attribute names).", "They are normally only visible to developers.", "External strings are intended for human consumption."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "internal", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "external", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["[Some Python coders (me included) observe the convention of using 'single_quotes' for internal strings vs. \"Double quotes\" for external strings.", "This is definitely not universal, though."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "'single_quotes'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\"Double quotes\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Your question is about the proper uses of barewords (Perl term) - syntax sugars allowing to omit the quotes quotes altogether on internal strings.", "Some languages (notably LISP) allow them widely; the Pythonic opportunities to employ barewords are attribute access - foo.bar and keyword arguments - update(bar=...)."], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "barewords", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "foo.bar", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "update(bar=...)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The stylistic dilemma here is \"Are your strings internal enough to look like identifiers?"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "Are your strings internal enough to look like identifiers?", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If the keys are external strings, the answer is definitely NO:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n foo.update({\"The answer to the big question\": 42})\n\n# which you later might access as:\nfoo[\"The answer to the big question\"]\n</code>\n</pre>\n", "senID": 14}, {"text": ["If the keys refer to Python identifiers (e.g.", "object attributes), then I'd say YES:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n foo.update(dict(bar=42))\n# As others mentioned, in that case the cleaner API (if possible)\n# would be to receive them as **kwargs directly:\nfoo.update(bar=42)\n\n# which you later might access as:\nfoo.bar\n</code>\n</pre>\n", "senID": 16}, {"text": ["If the keys refer to identifiers outside your Python program, such as XML attr names, or DB column names, using barewords may be good or bad choice - but you it's best to choose one style and be consistent."], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "consistent", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Consistency is good because there is a psychological barrier between identifiers and strings.", "It exists because strings rarely cross it - only when using introspection to do meta-programming.", "And syntax highlighting only reinforces it.", "So if you read the code and see a green 'bar' in one place and a black foo.bar in a second place, you won't immediately make a connection."], "childNum": 2, "tag": "p", "senID": 18, "childList": [{"text": "'bar'", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "foo.bar", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Another important rule of thumb is: Barewords are good iff they are (mostly) fixed.", "E.g.", "if you refer to fixed DB columns mostly in your code, than using barewords to refer to them might be nice; but if half the time the column is a parameter, then it's better to use strings."], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "Barewords are good iff they are (mostly) fixed", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This is because parameter/constant is the most important difference people associate with the  identifiers/strings barrier.", "The difference between column (variable) and \"person\" (constant) is the most readable way to convey this difference.", "Making them both identifiers would blur the distinction, as well as backfiring syntactically - you'd need to use **{column: value} and getattr(obj, column) etc.", "a lot."], "childNum": 4, "tag": "p", "senID": 20, "childList": [{"text": "column", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\"person\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "**{column: value}", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "getattr(obj, column)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["I prefer the anonymous dictionary, too, just out of personal style."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If I have a lot of arguments, sometimes it is nice to omit the quotes on the keys:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n DoSomething(dict(\n   Name = 'Joe',\n   Age = 20,\n   Gender = 'Male',\n   ))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is a very subjective question, BTW.", ":)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I think the dict() function is really there for when you're creating a dict from something else, maybe something that easily produces the necessary keyword args.", "The anonymous method is best for 'dict literals' in the same way you'd use \"\" for strings, not str()."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dict()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Actually, if the receiving function will only receive a dictionary with not pre-dertermined keywords, I normally use the ** passing convention."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In this example, that would be:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Foo(object):\n   def update(self, **param_dict):\n       for key in param_dict:\n          ....\nfoo = Foo()\n....\nfoo.update(bar=42, baz='qux')\n</code>\n</pre>\n", "senID": 2}]]