[[{"text": ["If you want to interpolate data in a quite general and fast way, splines or polynomials are very useful.", "Scipy has the scipy.interpolate module, which is very useful.", "You can find many examples in the official pages."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "many examples", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/scipy/reference/tutorial/interpolate.html"}]}], [{"text": ["This is upsampling.", "See Help with resampling/upsampling for some example solutions."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Help with resampling/upsampling", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/5156690/help-with-resampling-upsampling"}]}, {"text": ["A fast way to do this is to use FFTs.", "This is what SciPy's native resample()function does.", "It assumes a periodic signal, though, so it's not exactly the same.", "Your function assumes the signal's samples are all 0 outside of the defined range, so the two methods will diverge away from the center point.", "If you pad the signal with lots of zeros first, it will produce a very close result.", "There are several more zeros past the edge of the plot not shown here:"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "resample()function", "tag": "a", "pos": 1, "childList": [{"text": "resample()", "tag": "code"}], "childNum": 1, "href": "http://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.resample.html"}, {"text": "resample()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "so it's not exactly the same", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://flic.kr/p/ax62fP"}]}, {"src": "http://i.stack.imgur.com/1CtHr.png", "tag": "img", "senID": 2}, {"text": ["Cubic interpolation won't be correct for resampling purposes.", "This example is an extreme case (near the sampling frequency), but as you can see, cubic interpolation isn't even close.", "For lower frequencies it should be pretty accurate."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Your question isn't entirely clear; you're trying to optimize the code you posted, right?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Re-writing sinc like this should speed it up considerably.", "This implementation avoids checking that the math module is imported on every call, doesn't do attribute access three times, and replaces exception handling with a conditional expression:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from math import sin, pi\ndef sinc(x):\n    return (sin(pi * x) / (pi * x)) if x != 0 else 1.0\n</code>\n</pre>\n", "senID": 2}, {"text": ["You could also try avoiding creating the matrix twice (and holding it twice in parallel in memory) by creating a numpy.array directly (not from a list of lists):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def resampleMatrix(Tso, Tsf, o, f):\n    retval = numpy.zeros((f, o))\n    for i in xrange(f):\n        for j in xrange(o):\n            retval[i][j] = sinc((Tsf*i - Tso*j)/Tso)\n    return retval\n</code>\n</pre>\n", "senID": 4}, {"text": ["(replace xrange with range on Python 3.0 and above)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Finally, you can create rows with numpy.arange as well as calling numpy.sinc on each row or even on the entire matrix:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def resampleMatrix(Tso, Tsf, o, f):\n    retval = numpy.zeros((f, o))\n    for i in xrange(f):\n        retval[i] = numpy.arange(Tsf*i / Tso, Tsf*i / Tso - o, -1.0)\n    return numpy.sinc(retval)\n</code>\n</pre>\n", "senID": 7}, {"text": ["This should be significantly faster than your original implementation.", "Try different combinations of these ideas and test their performance, see which works out the best!"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Here's a minimal example of 1d interpolation with scipy -- not as much fun as reinventing, but.", "The plot looks like sinc, which is no coincidence:\ntry google spline resample \"approximate sinc\".", "(Presumably less local / more taps &rArr; better approximation,\nbut I have no idea how local UnivariateSplines are."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "sinc", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n \"\"\" interpolate with scipy.interpolate.UnivariateSpline \"\"\"\nfrom __future__ import division\nimport numpy as np\nfrom scipy.interpolate import UnivariateSpline\nimport pylab as pl\n\nN = 10 \nH = 8\nx = np.arange(N+1)\nxup = np.arange( 0, N, 1/H )\ny = np.zeros(N+1);  y[N//2] = 100\n\ninterpolator = UnivariateSpline( x, y, k=3, s=0 )  # s=0 interpolates\nyup = interpolator( xup )\nnp.set_printoptions( 1, threshold=100, suppress=True )  # .1f\nprint \"yup:\", yup\n\npl.plot( x, y, \"green\",  xup, yup, \"blue\" )\npl.show()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Added feb 2010: see also basic-spline-interpolation-in-a-few-lines-of-numpy"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "basic-spline-interpolation-in-a-few-lines-of-numpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://advice.mechanicalkern.com/question/22/basic-spline-interpolation-in-a-few-lines-of-numpy"}]}], [{"text": ["I'm not quite sure what you're trying to do, but there are some speedups you can do to create the matrix.", "Braincore's suggestion to use numpy.sinc is a first step, but the second is to realize that numpy functions want to work on numpy arrays, where they can do loops at C speen, and can do it faster than on individual elements."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Braincore's suggestion", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1851384/resampling-interpolating-matrix/1851402#1851402"}, {"text": "numpy.sinc", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def resampleMatrix(Tso, Tsf, o, f):\n    retval = numpy.sinc((Tsi*numpy.arange(i)[:,numpy.newaxis]\n                         -Tso*numpy.arange(j)[numpy.newaxis,:])/Tso)\n    return retval\n</code>\n</pre>\n", "senID": 1}, {"text": ["The trick is that by indexing the aranges with the numpy.newaxis, numpy converts the array with shape i to one with shape i x 1, and the array with shape j, to shape 1 x j.", "At the subtraction step, numpy will \"broadcast\" the each input to act as a i x j shaped array and the do the subtraction.", "(\"Broadcast\" is numpy's term, reflecting the fact no additional copy is made to stretch the i x 1 to i x j."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Now the numpy.sinc can iterate over all the elements in compiled code, much quicker than any for-loop you could write."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["(There's an additional speed-up available if you do the division before the subtraction, especially since inthe latter the division cancels the multiplication."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The only drawback is that you now pay for an extra Nx10*N array to hold the difference.", "This might be a dealbreaker if N is large and memory is an issue."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Otherwise, you should be able to write this using numpy.convolve.", "From what little I just learned about sinc-interpolation, I'd say you want something like numpy.convolve(orig,numpy.sinc(numpy.arange(j)),mode=\"same\").", "But I'm probably wrong about the specifics."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "numpy.convolve", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "numpy.convolve(orig,numpy.sinc(numpy.arange(j)),mode=\"same\")", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["If your only interest is to 'generate a \"smooth\" plot' I would just go with a simple polynomial spline curve fit:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For any two adjacent data points the coefficients of a third degree polynomial function can be  computed from the coordinates of those data points and the two additional points to their left and right (disregarding boundary points.", ")  This will generate points on a nice smooth curve with a continuous first dirivitive.", "There's a straight forward formula for converting 4 coordinates to 4 polynomial coefficients but I don't want to deprive you of the fun of looking it up ;o). "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Small improvement.", "Use the built-in numpy.sinc(x) function which runs in compiled C code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Possible larger improvement: Can you do the interpolation on the fly (as the plotting occurs)?", "Or are you tied to a plotting library that only accepts a matrix?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I recommend that you check your algorithm, as it is a non-trivial problem.", "Specifically, I suggest you gain access to the article \"Function Plotting Using Conic Splines\" (IEEE Computer Graphics and Applications) by Hu and Pavlidis (1991).", "Their algorithm implementation allows for adaptive sampling of the function, such that the rendering time is smaller than with regularly spaced approaches."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The abstract follows:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]