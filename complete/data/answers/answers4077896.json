[[{"text": ["If you are guaranteed to have well-formed data consisting of nothing else but a singleton date in the DD-MM-YYYY format, then this works:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # FIRST METHOD\nmy $ndate = join(\"-\" =&gt; reverse split(m[/], $date));\n</code>\n</pre>\n", "senID": 1}, {"text": ["That works on a $date holding \"07/04/1776\" but fails on \"this 17/01/2010 and that 01/17/2010 there\".", "Instead, use:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "$date", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # SECOND METHOD\n($ndate = $date) =~ s{\n    \\b\n      ( \\d \\d   )\n    / ( \\d \\d   )\n    / ( \\d {4}  )\n    \\b\n}{$3-$2-$1}gx;\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you prefer a more \"grammatical\" regex, so that it\u2019s easier to maintain and update, you can instead use this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n # THIRD METHOD\n($ndate = $date) =~ s{\n    (?&amp;break)\n\n              (?&lt;DAY&gt;    (?&amp;day)    )\n    (?&amp;slash) (?&lt;MONTH&gt;  (?&amp;month)  )\n    (?&amp;slash) (?&lt;YEAR&gt;   (?&amp;year)   )\n\n    (?&amp;break)\n\n    (?(DEFINE)\n        (?&lt;break&gt; \\b     )\n        (?&lt;slash&gt; /      )\n        (?&lt;year&gt;  \\d {4} )\n        (?&lt;month&gt; \\d {2} )\n        (?&lt;day&gt;   \\d {2} )\n    )\n}{\n    join \"-\" =&gt; @+{qw&lt;YEAR MONTH DAY&gt;}\n}gxe;\n</code>\n</pre>\n", "senID": 5}, {"text": ["Finally, if you have Unicode data, you might want to be a bit more careful."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n # FOURTH METHOD\n($ndate = $date) =~ s{\n    (?&amp;break_before)\n              (?&lt;DAY&gt;    (?&amp;day)    )\n    (?&amp;slash) (?&lt;MONTH&gt;  (?&amp;month)  )\n    (?&amp;slash) (?&lt;YEAR&gt;   (?&amp;year)   )\n    (?&amp;break_after)\n\n    (?(DEFINE)\n        (?&lt;slash&gt;     /                  )\n        (?&lt;start&gt;     \\A                 )\n        (?&lt;finish&gt;    \\z                 )\n\n        # don't really want to use \\D or [^0-9] here:\n        (?&lt;break_before&gt;\n           (?&lt;= [\\pC\\pP\\pS\\p{Space}] )\n         | (?&lt;= \\A                )\n        )\n        (?&lt;break_after&gt;\n            (?= [\\pC\\pP\\pS\\p{Space}]\n              | \\z\n            )\n        )\n        (?&lt;digit&gt; \\d            )\n        (?&lt;year&gt;  (?&amp;digit) {4} )\n        (?&lt;month&gt; (?&amp;digit) {2} )\n        (?&lt;day&gt;   (?&amp;digit) {2} )\n    )\n}{\n    join \"-\" =&gt; @+{qw&lt;YEAR MONTH DAY&gt;}\n}gxe;\n</code>\n</pre>\n", "senID": 7}, {"text": ["You can see how each of these four approaches performs when confronted with sample input strings like these:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n my $sample  = q(17/01/2010);\nmy @strings =  (\n    $sample,  # trivial case\n\n    # multiple case\n    \"this $sample and that $sample there\",\n\n    # multiple case with non-ASCII BMP code points\n    # U+201C and U+201D are LEFT and RIGHT DOUBLE QUOTATION MARK\n    \"from \\x{201c}$sample\\x{201d} through\\xA0$sample\",\n\n    # multiple case with non-ASCII code points\n    #   from both the BMP and the SMP \n    # code point U+02013 is EN DASH, props \\pP \\p{Pd}\n    # code point U+10179 is GREEK YEAR SIGN, props \\pS \\p{So}\n    # code point U+110BD is KAITHI NUMBER SIGN, props \\pC \\p{Cf}\n    \"\\x{10179}$sample\\x{2013}\\x{110BD}$sample\",\n);\n</code>\n</pre>\n", "senID": 9}, {"text": ["Now letting $date be a foreach iterator through that array, we get this output:"], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "$date", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foreach", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n Original is:   17/01/2010\nFirst method:  2010-01-17\nSecond method: 2010-01-17\nThird method:  2010-01-17\nFourth method: 2010-01-17\n\nOriginal is:   this 17/01/2010 and that 17/01/2010 there\nFirst method:  2010 there-01-2010 and that 17-01-this 17\nSecond method: this 2010-01-17 and that 2010-01-17 there\nThird method:  this 2010-01-17 and that 2010-01-17 there\nFourth method: this 2010-01-17 and that 2010-01-17 there\n\nOriginal is:   from \u201c17/01/2010\u201d through\u00a017/01/2010\nFirst method:  2010-01-2010\u201d through\u00a017-01-from \u201c17\nSecond method: from \u201c2010-01-17\u201d through\u00a02010-01-17\nThird method:  from \u201c2010-01-17\u201d through\u00a02010-01-17\nFourth method: from \u201c2010-01-17\u201d through\u00a02010-01-17\n\nOriginal is:   \ud800\udd7917/01/2010\u2013\ud804\udcbd17/01/2010\nFirst method:  2010-01-2010\u2013\ud804\udcbd17-01-\ud800\udd7917\nSecond method: \ud800\udd792010-01-17\u2013\ud804\udcbd2010-01-17\nThird method:  \ud800\udd792010-01-17\u2013\ud804\udcbd2010-01-17\nFourth method: \ud800\udd792010-01-17\u2013\ud804\udcbd2010-01-17\n</code>\n</pre>\n", "senID": 11}, {"text": ["Now let\u2019s suppose that you actually do want to match non-ASCII digits.", "For example:"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "do", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n U+660  ARABIC-INDIC DIGIT ZERO\n   U+661  ARABIC-INDIC DIGIT ONE\n   U+662  ARABIC-INDIC DIGIT TWO\n   U+663  ARABIC-INDIC DIGIT THREE\n   U+664  ARABIC-INDIC DIGIT FOUR\n   U+665  ARABIC-INDIC DIGIT FIVE\n   U+666  ARABIC-INDIC DIGIT SIX\n   U+667  ARABIC-INDIC DIGIT SEVEN\n   U+668  ARABIC-INDIC DIGIT EIGHT\n   U+669  ARABIC-INDIC DIGIT NINE\n</code>\n</pre>\n", "senID": 13}, {"text": ["or even "], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n U+1D7F6  MATHEMATICAL MONOSPACE DIGIT ZERO\n U+1D7F7  MATHEMATICAL MONOSPACE DIGIT ONE\n U+1D7F8  MATHEMATICAL MONOSPACE DIGIT TWO\n U+1D7F9  MATHEMATICAL MONOSPACE DIGIT THREE\n U+1D7FA  MATHEMATICAL MONOSPACE DIGIT FOUR\n U+1D7FB  MATHEMATICAL MONOSPACE DIGIT FIVE\n U+1D7FC  MATHEMATICAL MONOSPACE DIGIT SIX\n U+1D7FD  MATHEMATICAL MONOSPACE DIGIT SEVEN\n U+1D7FE  MATHEMATICAL MONOSPACE DIGIT EIGHT\n U+1D7FF  MATHEMATICAL MONOSPACE DIGIT NINE\n</code>\n</pre>\n", "senID": 15}, {"text": ["So imagine you have a date in mathematical monospace digits, like this:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n $date = \"\\x{1D7F7}\\x{1D7FD}/\\x{1D7F7}\\x{1D7F6}/\\x{1D7F8}\\x{1D7F6}\\x{1D7F7}\\x{1D7F6}\";\n</code>\n</pre>\n", "senID": 17}, {"text": ["The Perl code will work just fine on that:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n Original is:   \ud835\udff7\ud835\udffd/\ud835\udff7\ud835\udff6/\ud835\udff8\ud835\udff6\ud835\udff7\ud835\udff6\nFirst method:  \ud835\udff8\ud835\udff6\ud835\udff7\ud835\udff6-\ud835\udff7\ud835\udff6-\ud835\udff7\ud835\udffd\nSecond method: \ud835\udff8\ud835\udff6\ud835\udff7\ud835\udff6-\ud835\udff7\ud835\udff6-\ud835\udff7\ud835\udffd\nThird method:  \ud835\udff8\ud835\udff6\ud835\udff7\ud835\udff6-\ud835\udff7\ud835\udff6-\ud835\udff7\ud835\udffd\nFourth method: \ud835\udff8\ud835\udff6\ud835\udff7\ud835\udff6-\ud835\udff7\ud835\udff6-\ud835\udff7\ud835\udffd\n</code>\n</pre>\n", "senID": 19}, {"text": ["I think you\u2019ll find that Python has a pretty brain\u2010damaged Unicode model whose lack of support for abstract characters and strings irrespective of content makes it ridiculously difficult to write things like this.  "], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"text": ["It\u2019s also tough to write legible regular expressions in Python where you decouple the declaration of the subexpressions from their execution, since (?(DEFINE)...", ") blocks are not supported there.", "Heck, Python doesn\u2019t even support Unicode properties.", "It\u2019s just not suitable for Unicode regex work because of this."], "childNum": 1, "tag": "p", "senID": 21, "childList": [{"text": "(?(DEFINE)...)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["But hey, if you think that\u2019s bad in Python compared to Perl (and it certainly is), just try any other language.", "I haven\u2019t found one that isn\u2019t still worse for this sort of work."], "childNum": 1, "tag": "p", "senID": 22, "childList": [{"text": "and it certainly is", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["As you see, you run into real problems when you ask for regex solutions from multiple languages.", "First of all, the solutions are difficult to compare because of the different regex flavors.", "But also because no other language can compare with Perl for power, expressivity, and maintainability in its regular expressions.", "This may become even more obvious once arbitrary Unicode enters the picture."], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"text": ["So if you just wanted Python, you should have asked for only that.", "Otherwise it\u2019s a terribly unfair contest that Python will nearly always lose; it\u2019s just too messy to get things like this correct in Python, let alone both correct and clean.", "That\u2019s asking more of it than it can produce."], "childNum": 2, "tag": "p", "senID": 24, "childList": [{"text": "both", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "and clean", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["In contrast, Perl\u2019s regexes excel at both those."], "childNum": 0, "tag": "p", "senID": 25, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; datetime.strptime('02/11/2010', '%d/%m/%Y').strftime('%Y-%m-%d')\n'2010-11-02'\n</code>\n</pre>\n", "senID": 0}, {"text": ["or more hackish way (that doesn't check for validity of values):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; '-'.join('02/11/2010'.split('/')[::-1])\n'2010-11-02'\n&gt;&gt;&gt; '-'.join(reversed('02/11/2010'.split('/')))\n'2010-11-02'\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Use Time::Piece (in core since 5.9.5), very similar to the Python solution accepted, as it provides the strptime and strftime functions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n use Time::Piece;\nmy $dt_str = Time::Piece-&gt;strptime('13/10/1979', '%d/%m/%Y')-&gt;strftime('%Y-%m-%d');\n</code>\n</pre>\n", "senID": 1}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ perl -MTime::Piece\nprint Time::Piece-&gt;strptime('13/10/1979', '%d/%m/%Y')-&gt;strftime('%Y-%m-%d');\n1979-10-13\n$\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Go with Perl: the datetime Python package is just broken.", "You could just do it with regexes to swap the date parts around, eg"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "datetime", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n echo \"17/01/2010\" | perl -pe 's{(\\d+)/(\\d+)/(\\d+)}{$3-$2-$1}g'\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you do need to parse these dates (eg to compute their day of week or other calendar-type operations), look into DateTimeX::Easy (you can install it with apt-get under Ubuntu):"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "DateTimeX::Easy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/~rokr/DateTimeX-Easy-0.089/lib/DateTimeX/Easy.pm"}, {"text": "apt-get", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n perl -MDateTimeX::Easy -e 'print DateTimeX::Easy-&gt;parse(\"17/01/2010\")-&gt;ymd(\"-\")'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Perl :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while (&lt;&gt;) {\n  s/(^|[^\\d])(\\d\\d)\\/(\\d\\d)\\/(\\d{4})($|[^\\d])/$4-$3-$2/g;\n  print $_;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you just have to run:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n perl MyScript.pl &lt; oldfile.txt &gt; newfile.txt\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Perl: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n my $date =~ s/(\\d+)\\/(\\d+)\\/(\\d+)/$3-$2-$1/;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In Perl you can do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n use strict;\nwhile(&lt;&gt;) {\n    chomp;\n    my($d,$m,$y) = split/\\//;\n    my $newDate = $y.'-'.$m.'-'.$d;\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["using python"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import string\nbefore = \"17/01/2010\"\narray = string.split(before,\"/\")\nafter = array[2] + '-' + array[1] + '-' + array[0]\nprint after\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In glorious perl-oneliner form:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n echo 17/01/2010 | perl -p -e \"chomp;  join('-', reverse split /\\//);\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["But seriously I would do it like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env perl\nwhile (&lt;&gt;) {\n    chomp;\n    print join('-', reverse split /\\//), \"\\n\";\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["Which will work on a pipe, converting and printing one date per line. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]