[[{"text": ["Beware that different people use different terminology; in particular there is often a rift between the object oriented community and the (rest of the) programming language theory community."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "object oriented community", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming"}, {"href": "http://en.wikipedia.org/wiki/Type_polymorphism", "text": "programming language theory community", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Generally speaking, polymorphism means that a method or function is able to cope with different types of input.", "For example the add method (or + operator) in the Integer class might perform integer addition, while the add method in the Float class performs floating-point addition, and the add method in the Bignum class performs the correct operations for an arbitrary-size number.", "Polymorphism is the ability to call the add method on an object without knowing what kind of a number it is."], "childNum": 8, "tag": "p", "senID": 1, "childList": [{"text": "add", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "+", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Integer", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "add", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "Float", "childNum": 0, "tag": "code", "childList": []}, {"text": "add", "childNum": 0, "tag": "code", "childList": []}, {"text": "Bignum", "childNum": 0, "tag": "code", "childList": []}, {"text": "add", "childNum": 0, "tag": "code", "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": ["One particular kind of polymorphism, usually called parametric polymorphism in the functional community and generic programming in the OOP community, is the ability to perform certain operations on an object without caring about its precise type.", "For example, to reverse a list, you don't need to care about the type of the elements of the list, you just need to know that it's a list.", "So you can write generic (in this sense) list reversal code: it'll work identically on lists of integers, strings, widgets, arbitrary objects, whatever.", "But you can't write code that adds the elements of a list in a generic way, because the way the elements are interpreted as numbers depends on what type they are."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Another kind of polymorphism, usually called ad-hoc polymorphism or (at least for some forms of it) generic programming in the functional community, and often subtyping polymorphism (though this somewhat restricts the concept) in the OOP community, it the ability to have a single method or function that behaves differently depending on the precise type of its arguments (or, for methods, the type of the object whose method is being invoked).", "The add example above is ad-hoc polymorphism.", "In dynamically typed languages this ability goes without saying; statically-typed languages tend to (but don't have to) have restrictions such as requiring that the argument be a subclass of some particular class (Addable)."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "add", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "have", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "Addable", "childNum": 0, "tag": "code", "childList": []}]}]}, {"text": ["Polymorphism is not about having to specify types when you define a function.", "That's more related to static vs. dynamic typing, though it's not an intrinsic part of the issue.", "Dynamically typed languages have no need for type declarations, while statically typed languages usually need some type declarations (going from quite a lot in Java to almost none in ML)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Hope from this example, you will understand what Polymorphism is.", "In this picture, all objects have a method Speak() but each has a different implementation.", "Polymorphism allows you to do this, you can declare an action for a class and its subclasses but for each subclass, you can write exactly what you want later."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Polymorphism", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Speak()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"src": "http://technofriends.files.wordpress.com/2008/02/polymorphism.gif", "tag": "img", "senID": 1}], [{"text": ["Polymorphism literally means \"many shapes\", and that's pretty good at explaining its purpose.", "The idea behind polymorphism is that one can use the same calls on different types and have them behave appropriately."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It is important to distinguish this from the typing system - strongly typed languages require that objects be related through an inheritance chain to be polymorphic, but with weakly typed languages, this is not necessary."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In Java (et al.", "), this is why interfaces are useful - they define the set of functions that can be called on objects without specifying the exact object - the objects that implement that interface are polymorphic with respect to that interface."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In Python, since things are dynamically typed, the interface is less formal, but the idea is the same - calling foo() will succeed on two objects that know how to properly implement foo(), but we don't care about what type they really are."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "really", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["The answers you've gotten are good, and explain what polymorphism is.", "I think it can also help to understand some of the reasons it is useful. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In some languages that lack polymorphism you find yourself in situations where you want to perform what is conceptually the same operation on different types of objects, in cases where that operation has to be implemented differently for each type.", "For instance, in a python-like syntax:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def dosomething(thing):\n   if type(thing)==suchandsuch:\n      #do some stuff\n   elif type(thing)==somesuch:\n      #do some other stuff\n   elif type(thing)==nonesuch:\n      #yet more stuff\n</code>\n</pre>\n", "senID": 2}, {"text": ["There are some problems with this.", "The biggest is that it causes very tight coupling and a lot of repetition.", "You are likely to have this same set of tests in a lot of places in your code.", "What happens if you add a new type that has to support this operation?", "You have to go find every place you have this sort of conditional and add a new branch.", "And of course you have to have access to all the source code involved to be able to make those changes.", "On top of that conditional logic like this is wordy, and hard to understand in real cases."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["It's nicer to be able to just write: "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n thing.dosomething()\n</code>\n</pre>\n", "senID": 5}, {"text": ["On top of being a lot shorter this leads to much looser coupling.", "This example/explanation is geared to traditional OO languages like Python.", "The details are a bit different in, say, functional languages.", "But a lot of the general utility of polymorphism remains the same."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["No, that is not polymorphism.", "Polymorphism is the concept that there can be many different implementations of an executable unit and the difference happen all behind the scene without the caller awareness."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, Bird and Plane are FlyingObject.", "So FlyingObject has a method call fly() and both Bird and Plane implement fly() method.", "Bird and Plan flies differently so the implementations are different.", "To the clients point of view, it does not matter how Bird or Plane fly, they can just call fly() method to a FlyingObject object does not matter if that object is Plan or Bird."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "fly()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "fly()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "fly()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["What you are describing is dynamic and static type checking which the type compatibility is done at run-time and compile-time respectively."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Hope this out.", "NawaMan"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Yes, that is an example of \"type-polymorphism\".", "However, when talking about object-oriented programming \"polymorphism\" typically relates to \"subtype polymorphism.", "\" The example you gave is often called \"typing\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Java, C, C++ and others, use static typing.", "In that, you have to specify the types are compile time."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Python, and Ruby use dynamic in that the typing is inferred during interpretation."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Subtype polymorphism or just \"polymorphism\" is the ability for a base class reference that is a derived type, to properly invoke the derived type's method."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["For example (in near pseudo code):"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class Base\n{\n  virtual void Draw() { //base draw}\n}\n\nclass Derived: public Base\n{\n  void Draw() { //derived draw}\n}\n\nBase* myBasePtr = new Derived();\n\nmyBasePtr-&gt;Draw(); //invokes Derived::Draw(), even though it's a base pointer.\n</code>\n</pre>\n", "senID": 5}, {"text": ["This is polymorphism."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["What you are talking about is auto-typing--or maybe type detection.", "It is something a Dynamic language tends to do--it allows the user to not know or care about the types at build time--the types are figured out at runtime and not restricted to a specific type."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Polymorphism is where you have two classes that inherit from a main class but each implement a method differently."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For instance, if you have Vehicle as a root class and Car and Bicycle as instances, then vehicle.calculateDistance() would operate based on gas available if the vehicle is an instance of Car, and would operate based on the endurance of the cyclist if it was a Bicycle type."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It's generally used like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n getTotalDistance(Vehicle[] vehicle) {\n    int dist=0\n    for each vehicle\n        dist+=vehicle.calculateDistance();\n</code>\n</pre>\n", "senID": 4}, {"text": ["Note that you are passing in the base type, but the instances will never be Vehicle itself, but always a child class of Vehicle--but you DO NOT cast it to the child type.", "Polymorphis means that vehicle morphs into whatever child is required."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Short answer: The ability to treat programmatic type instances of different types as the same for certain purposes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Long answer:\nFrom Ancient Greek poly (many) + morph (form) + -ism."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Polymorphism is a general technique enabling different types to be treated uniformly in some way.", "Examples in the programming world include:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["parametric polymorphism"], "childNum": 0, "tag": "code", "senID": 3, "childList": []}, {"text": ["subtyping\npolymorphism"], "childNum": 0, "tag": "code", "senID": 4, "childList": []}, {"text": ["ad-hoc\npolymorphism"], "childNum": 0, "tag": "code", "senID": 5, "childList": []}]}, {"text": ["The word polymorphism is also used to describe concepts in other, unrelated, domains such as genetics."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "s genetics", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ghr.nlm.nih.gov/glossary=polymorphism"}]}], [{"text": ["One Name Multiple Form- Polymerphism"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]