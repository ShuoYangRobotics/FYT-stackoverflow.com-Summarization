[[{"text": ["See Convert Bytes to Floating Point Numbers in Python "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Convert Bytes to Floating Point Numbers in Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/5415/"}]}, {"text": ["You probably want to use the struct module, e.g."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import struct\n\nresponse = (0, 0, 117, 143, 6)\nstruct.unpack(\"&gt;I\", ''.join([chr(x) for x in response[:-1]]))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Assuming an unsigned int.", "There may be a better way to do the conversion to unpack, a list comprehension with join was just the first thing that I came up with. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT: See also \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5's comment on this answer regarding endianness as well."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["EDIT #2: If you don't mind using the array module as well, here is an alternate method that obviates the need for a list comprehension.", "Thanks to @JimB for pointing out that unpack can operate on arrays as well."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "EDIT #2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "JimB", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/386753/how-do-i-convert-part-of-a-python-tuple-byte-array-into-an-integer#386998"}]}, {"code": "<pre>\n<code>\n import struct\nfrom array import array\n\nresponse = (0, 0, 117, 143, 6)\nbytes = array('B', response[:-1])\nstruct.unpack('&gt;I', bytes)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Would,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["meet your needs?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["aid"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could also make use of the array module"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import struct\nfrom array import array\nresponse = (0, 0, 117, 143, 6)\na = array('B', response[:4])\nstruct.unpack('&gt;I', a)\n\n(30095L,)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["OK, You don't specify the endinanness or whether the integer is signed or and it (perhaps)  is faster to with the struct module but:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n b = (8, 1, 0, 0)\nsum(b[i] &lt;&lt; (i * 8) for i in range(4))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about using the map function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = (0, 0, 117, 143, 6)\nb = []\nmap(b.append, a)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also, I don't know if this is you are looking for:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n response = (0, 0, 117, 143, 6)\nresponse[0:4]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This looks like a job for reduce!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What you basically need is to, bit-shift a byte at a time, and then add (addition) the next byte in the sequence. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a = (0, 0, 117, 143, 6)\nreduce(lambda x, y: (x&lt;&lt;8) + y, a)\n7704326\n</code>\n</pre>\n", "senID": 2}]]