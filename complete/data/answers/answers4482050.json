[[{"text": ["I would approach this problem by:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Creating a dict mapping day names to their sequential index", "tag": "none", "senID": 1}, {"text": "Converting my input day names to their sequential indices", "tag": "none", "senID": 2}, {"text": "Looking at the resulting input indices and asking if they are sequential", "tag": "none", "senID": 3}]}, {"text": ["Here's how you can do that, using calendar.day_name, range and some for comprehensions:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "calendar.day_name", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "range", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n day_indexes = {name:i for i, name in enumerate(calendar.day_name)}\ndef weekdays_consecutive(days):\n    indexes = [day_indexes[d] for d in days]\n    expected = range(indexes[0], indexes[-1] + 1)\n    return indexes == expected\n</code>\n</pre>\n", "senID": 5}, {"text": ["A few other options, depending on what you need:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["If you need Python &lt; 2.7, instead of the dict comprehension, you can use:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["If you don't want to allow Saturday and Sunday, just trim off the last two days:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["If you need to wrap around after Sunday, it's probably easiest to just check that each item is one more than the previous item, but working in modulo 7:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}]}, {"text": ["Update: For the extended problem, I would still stick with they day-to-index dict, but instead I would:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "Find all the indexes where a run of sequential days stops", "tag": "none", "senID": 11}, {"text": "Wrap the days around if necessary to get the longest possible sequence of days", "tag": "none", "senID": 12}, {"text": "Group the days into their sequential spans", "tag": "none", "senID": 13}]}, {"text": ["Here's code to do this:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n def weekdays_to_string(days):\n    # convert days to indexes\n    day_indexes = {name:i for i, name in enumerate(calendar.day_name)}\n    indexes = [day_indexes[d] for d in days]\n\n    # find the places where sequential days end\n    ends = [i + 1\n            for i in range(len(indexes))\n            if (indexes[(i + 1) % len(indexes)]) % 7 !=\n               (indexes[(i) % len(indexes)] + 1) % 7]\n\n    # wrap the days if necessary to get longest possible sequences\n    split = ends[-1]\n    if split != len(days):\n        days = days[split:] + days[:split]\n        ends = [len(days) - split + end for end in ends]\n\n    # group the days in sequential spans\n    spans = [days[begin:end] for begin, end in zip([0] + ends, ends)]\n\n    # format as requested, with \"to\", \"and\", commas, etc.\n    words = []\n    for span in spans:\n        if len(span) &lt; 3:\n            words.extend(span)\n        else:\n            words.append(\"%s to %s\" % (span[0], span[-1]))\n    if len(days) == 1:\n        return words[0]\n    elif len(days) == 2:\n        return \"%s and %s\" % tuple(words)\n    else:\n        return \", \".join(words)\n</code>\n</pre>\n", "senID": 15}, {"text": ["You might also try the following instead of that last if/elif/else block to get an \"and\" between the last two items and commas between everything else:"], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "if/elif/else", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if len(words) == 1:\n        return words[0]\n    else:\n        return \"%s and %s\" % (\", \".join(words[:-1]), words[-1])\n</code>\n</pre>\n", "senID": 17}, {"text": ["That's a little different from the spec, but prettier in my eyes."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}], [{"code": "<pre>\n<code>\n def weekdays_consecutive(inp):\n    days = { 'Monday': 0,\n             'Tuesday': 1,\n             'Wednesday': 2,\n             'Thursday': 3,\n             'Friday': 4 }\n\n    return [days[x] for x in inp] == range(days[inp[0]], days[inp[-1]] + 1)\n</code>\n</pre>\n", "senID": 0}, {"text": ["As you have already checked for other cases, I think this will be good enough."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Here's my complete solution, you can use it however you want; (the code is being put into the public domain, but I won't accept any liability if anything happens to you or your computer as a consequence of using it and there's no warranty yadda yadda ya)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n week_days = {\n    'monday':0,\n    'tuesday':1,\n    'wednesday':2,\n    'thursday':3,\n    'friday':4,\n    'saturday':5,\n    'sunday':6\n}\nweek_days_reverse = dict(zip(week_days.values(), week_days.keys()))\n\ndef days_str_to_int(days):\n    '''\n    Converts a list of days into a list of day numbers.\n    It is case ignorant.\n    ['Monday', 'tuesday'] -&gt; [0, 1]\n    '''\n    return map(lambda day: week_days[day.lower()], days)\n\ndef day_int_to_str(day):\n    '''\n    Converts a day number into a string.\n    0 -&gt; 'Monday' etc\n    '''\n    return week_days_reverse[day].capitalize()\n\ndef consecutive(days):\n    '''\n    Returns the number of consecutive days after the first given a sequence of \n    day numbers.\n    [0, 1, 2, 5] -&gt; 2\n    [6, 0, 1] -&gt; 2\n    '''\n    j = days[0]\n    n = 0\n    for i in days[1:]:\n        j = (j + 1) % 7\n        if j != i:\n            break\n        n += 1\n    return n\n\ndef days_to_ranges(days):\n    '''\n    Turns a sequence of day numbers into a list of ranges.\n    The days can be in any order\n    (n, m) means n to m\n    (n,) means just n\n    [0, 1, 2] -&gt; [(0, 2)]\n    [0, 1, 2, 4, 6] -&gt; [(0, 2), (4,), (6,)] \n    '''\n    days = sorted(set(days))\n    while days:\n        n = consecutive(days)\n        if n == 0:\n            yield (days[0],)\n        else:\n            assert n &lt; 7\n            yield days[0], days[n]\n        days = days[n+1:]\n\ndef wrap_ranges(ranges):\n    '''\n    Given a list of ranges in sequential order, this function will modify it in \n    place if the first and last range can be put together.\n    [(0, 3), (4,), (6,)] -&gt; [(6, 3), (4,)]\n    '''\n    if len(ranges) &gt; 1:\n        if ranges[0][0] == 0 and ranges[-1][-1] == 6:\n            ranges[0] = ranges[-1][0], ranges[0][-1]\n            del ranges[-1]\n\ndef range_to_str(r):\n    '''\n    Converts a single range into a string.\n    (0, 2) -&gt; \"Monday to Wednesday\"\n    '''\n    if len(r) == 1:\n        return day_int_to_str(r[0])\n    if r[1] == (r[0] + 1) % 7:\n        return day_int_to_str(r[0]) + ', ' + day_int_to_str(r[1])\n    return day_int_to_str(r[0]) + ' to ' + day_int_to_str(r[1])\n\ndef ranges_to_str(ranges):\n    '''\n    Converts a list of ranges into a string.\n    [(0, 2), (4, 5)] -&gt; \"Monday to Wednesday, Friday, Saturday\"\n    '''\n    if len(ranges) == 1 and ranges[0] == (0, 6):\n        return 'all week'\n    return ', '.join(map(range_to_str, ranges))\n\ndef week_days_to_string(days):\n    '''\n    Converts a list of days in string form to a stringed list of ranges.\n    ['saturday', 'monday', 'wednesday', 'friday', 'sunday'] -&gt; \n        'Friday to Monday, Wednesday'\n    '''\n    ranges = list(days_to_ranges(days_str_to_int(days)))\n    wrap_ranges(ranges)\n    return ranges_to_str(ranges)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Features:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Features:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "It supports more than one range,", "tag": "none", "senID": 3}, {"text": "You can enter in the days in any order,", "tag": "none", "senID": 4}, {"text": "It will wrap around,", "tag": "none", "senID": 5}]}, {"text": ["Add comments if you find any problems and I'll do my best to fix them."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["You would have to check the first date given, then have a list with all of the weekdays in it, check if the next given day is at the next index in the list, and repeat."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This can easily be done with a few loops, assuming the given days are in order."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This would either take some intricate case-by-case logic, or a hard-coded storage of all days sequentially.", "I'd prefer the latter."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def weekdays_consecutive(x):\n    allDays = { 'Monday':1, 'Tuesday':2, 'Wednesday':3, 'Thursday':4, 'Friday':5, 'Saturday' : 6, 'Sunday' : 7}\n    mostRecent = x[0]\n    for i in x[1:]:\n        if allDays[i] % 7 != allDays[mostRecent] % 7 + 1: return False\n        mostRecent = i\n    return True\n</code>\n</pre>\n", "senID": 1}, {"text": ["And this can sort the input : x.sort(lambda x, y: allDays[x] - allDays[y]).", "I don't know which function you'd prefer to use it in"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "x.sort(lambda x, y: allDays[x] - allDays[y])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;x = ['Tuesday', 'Thursday', 'Monday', 'Friday']\n&gt;&gt;&gt;x.sort(lambda x, y: allDays[x] - allDays[y]) \n&gt;&gt;&gt;x\n['Monday', 'Tuesday', 'Thursday', 'Friday']\n</code>\n</pre>\n", "senID": 3}, {"text": ["This relies on no non-days being present.", "I imagine you'd want to deal with this in the weekdays_to_string function rather than here in weekdays_consecutive. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["i also think you want to change the first case of your other function to 'and' instead of 'to' and add case for single-day inputs."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["EDIT: had a pretty dumb mistake i just fixed, should work now!"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I didn't test I must say."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def test(days):\n  days = list(days)\n  if len(days) == 1:\n    return days[0]\n  elif len(days) == 2:\n    return ' to '.join(days)\n  else:\n    return ''.join(days[:1] + [' to ' + days[-1]])\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import itertools\n\n#probably a better way to obtain this like with the datetime library\nWEEKDAYS = (('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'))\n\ndef weekdays_consecutive(days):\n    #assumes that days only contains valid weekdays\n\n    if len(days) == 0:\n        return True #or False?\n    iter = itertools.cycle(WEEKDAYS)\n    while iter.next() != days[0]: pass\n    for day in days[1:]:\n        if day != iter.next(): return False\n    return True\n\n#...\n\n&gt;&gt;&gt; weekdays_consecutive(('Friday', 'Monday'))\nTrue\n&gt;&gt;&gt; weekdays_consecutive(('Friday', 'Monday', 'Tuesday'))\nTrue\n&gt;&gt;&gt; weekdays_consecutive(('Friday', 'Monday', 'Tuesday', 'Thursday'))\nFalse\n</code>\n</pre>\n", "senID": 0}]]