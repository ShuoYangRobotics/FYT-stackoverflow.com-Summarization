[[{"text": ["The variable name used in the caller is not easily available to the called function.", "It's probably possible to do with an advanced use of inspect, but it might be better to rethink why you want the variable names."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "inspect", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["UPDATE: Now that I know what your real need is (\"I want to pass my variables to my template\"), the answer is simple: use locals(): it returns a dictionary mapping all your local variable names to their values."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "locals()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["UPDATE 2: How about this?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def only(d, *keys):\n    \"\"\"Return the subset of dict `d` whose keys are in `keys`.\"\"\"\n    return dict((k,v) for k,v in d.iteritems() if k in keys)\n\n...\n\na = 17\nb = 23\ntemplate_data = only(locals(), \"a\", \"b\")\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The function does not see the names (if any!-) of its actual arguments -- nor in fact any indication whatsoever that those actual arguments are the results of expressions that happen to be single variables rather than constants, function calls, or other expressions of any kind whatsoever."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So, what you require, as you have specified it, is simply not feasible."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["(1) Python is not PHP.", "(2) \"variable name lost when passed into a function\" is true. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Do Not Use Variables for this."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Do something simpler.", "Use the dict function."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "simpler", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dict( var1=1, var2='a', var3=1+3j )\n{'var1': 1, 'var3': (1+3j), 'var2': 'a'}\n</code>\n</pre>\n", "senID": 3}, {"text": ["That seems to do what you want.", "The variable \"names\" are in there exactly once.", "You don't really need to create other local, temporary variables."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "once", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import inspect\n&gt;&gt;&gt; def compact(*args):\n...     d = {}\n...     for a in args:\n...         d[a] = inspect.stack()[1][0].f_locals[a]\n...     return d\n...\n&gt;&gt;&gt; def test():\n...     x = 5\n...     print compact('x')\n...\n&gt;&gt;&gt; test()\n{'x': 5}\n</code>\n</pre>\n", "senID": 0}], [{"text": ["With the help of Getting method parameter names in python, here you go with decorator solution, so that you are able to apply it to any function:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Getting method parameter names in python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/218616/getting-method-parameter-names-in-python"}, {"text": "decorator", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def compactor(func):\n    import inspect\n    def compactor_impl(*args, **kwargs):\n        arg_names = inspect.getargspec(func)[0]\n        return dict(zip(arg_names, args))\n    return compactor_impl\n\n@compactor\ndef package(var1, var2, var3):\n    pass\n\n@compactor\ndef package2(var1, var2, var3, supervar):\n    pass\n\nassert package(1, 2, 3) == {'var1': 1, 'var2': 2, 'var3': 3,}\nassert package2(1, 2, 3, 'boh') == {'var1': 1, 'var2': 2, 'var3': 3, 'var3': 3, 'supervar': 'boh'}\n</code>\n</pre>\n", "senID": 1}, {"text": ["I assumed that the functions do nothing else but return the name-value pairs.", "You might want to add some checks (asserts) to ensure that len(args) == len(arg_names) and that kwargs is empty, because this will not be checked once the decorator is applied."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "name-value", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "len(args) == len(arg_names)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "kwargs", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["if you have a list called args and you want to put it into a dictionary called kwargs as in your example:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "args", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "kwargs", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n for k,v in enumerate(args):\n    kwargs[\"var%d\"%(k+1)] = v\n</code>\n</pre>\n", "senID": 1}, {"text": ["the keys are literally the index of the items in args, though; this can't be useful?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This is awkward and has limits, but for the rest it works"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def p(*args):\n  p = {}\n  for i in args:   \n     exec 'p[\"%s\"] = %s' % (i, i)\n  return p\n</code>\n</pre>\n", "senID": 1}]]