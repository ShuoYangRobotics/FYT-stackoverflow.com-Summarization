[[{"text": ["Generally, a recursive algorithm would do.", "Start with checking all subsets against start of a given word, if found \u2014 add (append) to found values and recurse with remaining part of the word and current found values.", "Or if it's an end of the string \u2014 print found values."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["something like that:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n all=[]\ndef frec(word, values=[]):\n    gobal all\n    if word == \"\":  # got result.\n        all+=[values]\n    for s in subsets:\n        if word.startswith(s):\n            frec(word[len(s):], values+[s])\n\nfrec(word)\n</code>\n</pre>\n", "senID": 2}, {"text": ["note that there are lots of possible solutions since subsets include many one-character strings.", "You might want to find some shortest of results.", "(13146 solutions... use \u201call.sort(cmp=lambda x, y: cmp(len(x), len(y)))\u201d to get shortest)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["For a level2 \u2014 you need another loop if no subset matches that adds more and more symbols to next value (and recurses into that) until match is found."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n all=[]\ndef frec(word, values=[]):\n    global all\n    if word == \"\":  # got result.\n        all+=[values]\n        return true\n    match = False\n    for s in subsets:\n        if word.startswith(s):\n            match = True\n            frec(word[len(s):], values+[s])       \n    if not match:                        \n        return frec(word[1:], values+[word[0]])\nfrec(word)\n</code>\n</pre>\n", "senID": 5}, {"text": ["This does not try to combine non-subset values into one string, though."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["i think you should do your own programming excercises...."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["For the Level 1 challenge you could do it recursively.", "Probably not the most efficient solution, but the easiest:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "recursively", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.google.com/webhp?q=recursion#q=recursion&btnG=Google+Search"}]}, {"code": "<pre>\n<code>\n word = \"iamtiredareyou\"\nsubsets = ['i', 'a', 'am', 'amt', 'm', 't', 'ti', 'tire', 'tired', 'i', 'ire', 'r', 're', 'red', 'redare', 'e', 'd', 'da', 'dar', 'dare', 'a', 'ar', 'are', 'r', 're', 'e', 'ey', 'y', 'yo', 'you', 'o', 'u']\n\ndef findsubset():\n    global word\n\n    for subset in subsets:\n        if word.startswith(subset):\n            setlist.append(subset)\n            word = word[len(subset):]\n\n            if word == \"\":\n                print setlist\n            else:\n                findsubset()\n\n            word = subset + word\n            setlist.pop()\n\n# Remove duplicate entries by making a set\nsubsets = set(subsets)\nsetlist = []\nfindsubset()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Your list of subsets has duplicates in it - e.g.", "'a' appears twice - so my code makes it a set to remove the duplicates before searching for results."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "'a'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://docs.python.org/library/stdtypes.html#set", "text": "set", "childNum": 1, "tag": "a", "childList": [{"text": "set", "tag": "code"}]}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Sorry about the lack of programming snippet, but I'd like to suggest dynamic programming.", "Attack level 1 and level 2 at the same time by giving each word a cost, and adding all the single characters not present as single character high cost words.", "The problem is then to find the way of splitting the sequence up into words that gives the least total cost."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Work from left to right along the sequence, at each point working out and saving the least cost solution up to and including the current point, and the length of the word that ends that solution.", "To work out the answer for the next point in the sequence, consider all of the known words that are suffixes of the sequence.", "For each such word, work out the best total cost by adding the cost of that word to the (already worked out) cost of the best solution ending just before that word starts.", "Note the smallest total cost and the length of the word that produces it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Once you have the best cost for the entire sequence, use the length of the last word in that sequence to work out what the last word is, and then step back that number of characters to inspect the answer worked out at that point and get the word just preceding the last word, and so on."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Isn't it just the same as finding the permutations, but with some conditions?", "Like you start the permutation algorithm (a recursive one) you check if the string you already have matches the first X characters of your to find word, if yes you continue the recursion until you find the whole word, otherwise you go back."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Level 2 is a bit silly if you ask me, because then you could actually write anything as the \"word to be found\", but basically it would be just like level1 with the exception that if you can't find a substring in your list you simply add it (letter by letter i.e.", "you have \"love\" and a list of ['l','e'] you match 'l' but you lack 'o' so you add it and check if any of your words in the list start with a 'v' and match your word to be found, they don't so you add 'v' to 'o' etc.", ")."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["And if you're bored you can implement a genetical algorithm, it's really fun but not really efficient."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here is a recursive, inefficient Java solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n private static void findSolutions(Set&lt;String&gt; fragments, String target, HashSet&lt;String&gt; solution, Collection&lt;Set&lt;String&gt;&gt; solutions) {\n    if (target.isEmpty()) {\n        solutions.add(solution);\n        return;\n    }\n\n    for (String frag : fragments) {\n        if (target.startsWith(frag)) {\n            HashSet&lt;String&gt; solution2 = new HashSet&lt;String&gt;(solution);\n            solution2.add(frag);\n            findSolutions(fragments, target.substring(frag.length()), solution2, solutions);\n        }\n    }       \n}\n\npublic static Collection&lt;Set&lt;String&gt;&gt; findSolutions(Set&lt;String&gt; fragments, String target) {\n    HashSet&lt;String&gt; solution = new HashSet&lt;String&gt;();\n    Collection&lt;Set&lt;String&gt;&gt; solutions = new ArrayList&lt;Set&lt;String&gt;&gt;();\n    findSolutions(fragments, target, solution, solutions);\n    return solutions;\n}\n</code>\n</pre>\n", "senID": 1}]]