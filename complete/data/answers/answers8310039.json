[[{"text": ["It's not that std::string performs poorly (as much as I dislike C++), it's that string handling is so heavily optimized for those other languages."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "std::string", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Your comparisons of string performance are misleading, and presumptuous if they are intended to represent more than just that."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I know for a fact that Python string objects are completely implemented in C, and indeed on Python 2.7, numerous optimizations exist due to the lack of separation between unicode strings and bytes.", "If you ran this test on Python 3.x you will find it considerably slower."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "Python string objects are completely implemented in C", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://hg.python.org/cpython/file/3ecddf168f1f/Objects/stringobject.c"}, {"text": "numerous", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://hg.python.org/cpython/file/3ecddf168f1f/Objects/stringobject.c#l1021"}, {"text": "optimizations", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://hg.python.org/cpython/file/3ecddf168f1f/Objects/bytearrayobject.c#l340"}]}, {"text": ["Javascript has numerous heavily optimized implementations.", "It's to be expected that string handling is excellent here."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Your Java result may be due to proper string handling, or some other poor case.", "I expect that a Java expert could step in and fix this test with a few changes."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["As for your C++ example, I'd expect performance to slightly exceed the Python version.", "It does the same operations, with less interpreter overhead.", "This is reflected in your results.", "Preceding the test with s.reserve(limit); would remove reallocation overhead."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "s.reserve(limit);", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["I'll repeat that you're only testing a single facet of the languages implementations.", "The results for this test do not reflect the overall language speed."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "implementations", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I've provided a C version to show how silly such pissing contests can be:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n #define _GNU_SOURCE\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\nvoid test()\n{\n    int limit = 102 * 1024;\n    char s[limit];\n    size_t size = 0;\n    while (size &lt; limit) {\n        s[size++] = 'X';\n        if (memmem(s, size, \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 26)) {\n            fprintf(stderr, \"zomg\\n\");\n            return;\n        }\n    }\n    printf(\"x's length = %zu\\n\", size);\n}\n\nint main()\n{\n    test();\n    return 0;\n}\n</code>\n</pre>\n", "senID": 8}, {"text": ["Timing:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n matt@stanley:~/Desktop$ time ./smash \nx's length = 104448\n\nreal    0m0.681s\nuser    0m0.680s\nsys     0m0.000s\n</code>\n</pre>\n", "senID": 10}], [{"text": ["So I went and played a bit with this on ideone.org. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here a slightly modified version of your original C++ program, but with the appending in the loop eliminated, so it only measures the call to std::string::find().", "Note that I had to cut the number of iterations to ~40%, otherwise ideone.org would kill the process."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "std::string::find()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Note that I had to cut the number of iterations to ~40%, otherwise ideone.org would kill the process.", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n #include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    const std::string::size_type limit = 42 * 1024;\n    unsigned int found = 0;\n\n    //std::string s;\n    std::string s(limit, 'X');\n    for (std::string::size_type i = 0; i &lt; limit; ++i) {\n        //s += 'X';\n        if (s.find(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 0) != std::string::npos)\n            ++found;\n    }\n\n    if(found &gt; 0)\n        std::cout &lt;&lt; \"Found \" &lt;&lt; found &lt;&lt; \" times!\\n\";\n    std::cout &lt;&lt; \"x's length = \" &lt;&lt; s.size() &lt;&lt; '\\n';\n\n    return 0;\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["My results at ideone.org are time: 3.37s.", "(Of course, this is highly questionably, but indulge me for a moment and wait for the other result.", ") "], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "ideone.org", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ideone.com/Suwea"}, {"text": "time: 3.37s", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Now we take this code and swap the commented lines, to test appending, rather than finding.", "Note that, this time, I had increased the number of iterations tenfold in trying to see any time result at all. "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Note that, this time, I had increased the number of iterations tenfold in trying to see any time result at all.", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n #include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main()\n{\n    const std::string::size_type limit = 1020 * 1024;\n    unsigned int found = 0;\n\n    std::string s;\n    //std::string s(limit, 'X');\n    for (std::string::size_type i = 0; i &lt; limit; ++i) {\n        s += 'X';\n        //if (s.find(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 0) != std::string::npos)\n        //    ++found;\n    }\n\n    if(found &gt; 0)\n        std::cout &lt;&lt; \"Found \" &lt;&lt; found &lt;&lt; \" times!\\n\";\n    std::cout &lt;&lt; \"x's length = \" &lt;&lt; s.size() &lt;&lt; '\\n';\n\n    return 0;\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["My results at ideone.org, despite the tenfold increase in iterations, are time: 0s. "], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "ideone.org", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ideone.com/OudWM"}, {"text": "time: 0s", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["My conclusion: This benchmark is, in C++, highly dominated by the searching operation, the appending of the character in the loop has no influence on the result at all.", "Was that really your intention? "], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "highly dominated by the searching operation", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "highly dominated by the searching operation", "tag": "em"}]}, {"text": "highly dominated by the searching operation", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}], [{"text": ["The idiomatic C++ solution would be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;algorithm&gt;\n\nint main()\n{\n    const int limit = 102 * 1024;\n    std::string s;\n    s.reserve(limit);\n\n    const std::string pattern(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n\n    for (int i = 0; i &lt; limit; ++i) {\n        s += 'X';\n        if (std::search(s.begin(), s.end(), pattern.begin(), pattern.end()) != s.end())\n            std::cout &lt;&lt; \"Omg Wtf found!\";\n    }\n    std::cout &lt;&lt; \"X's length = \" &lt;&lt; s.size();\n    return 0;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["I could speed this up considerably by putting the string on the stack, and using memmem -- but there seems to be no need.", "Running on my machine, this is over 10x the speed of the python solution already.."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["[On my laptop]"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["time ./test\nX's length = 104448\nreal    0m2.055s\nuser    0m2.049s\nsys 0m0.001s"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["That is the most obvious one: please try to do s.reserve(limit); before main loop. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "s.reserve(limit);", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Documentation is here."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cplusplus.com/reference/string/string/reserve/"}]}, {"text": ["I should mention that direct usage of standard classes in C++ in the same way you are used to do it in Java or Python will often give you sub-par performance if you are unaware of what is done behind the desk.", "There is no magical performance in language itself, it just gives you right tools."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["For C++, try to use std::string for \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" - in my implementation string::find(const charT* s, size_type pos = 0) const calculates length of string argument."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "std::string", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "string::find(const charT* s, size_type pos = 0) const", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["What you are missing here is the inherent complexity of the find search."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You are executing the search 102 * 1024 (104 448) times.", "A naive search algorithm will, each time, try to match the pattern starting from the first character, then the second, etc..."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "102 * 1024", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Therefore, you have a string that is going from length 1 to N, and at each step you search the pattern against this string, which is a linear operation in C++.", "That is N * (N+1) / 2 = 5 454 744 576 comparisons.", "I am not as surprised as you are that this would take some time..."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "N * (N+1) / 2 = 5 454 744 576", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Let us verify the hypothesis by using the overload of find that searches for a single A:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "find", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "A", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n Original: 6.94938e+06 ms\nChar    : 2.10709e+06 ms\n</code>\n</pre>\n", "senID": 4}, {"text": ["About 3 times faster, so we are within the same order of magnitude.", "Therefore the use of a full string is not really interesting."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Conclusion ?", "Maybe that find could be optimized a bit.", "But the problem is not worth it."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "find", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Note: and to those who tout Boyer Moore, I am afraid that the needle is too small, so it won't help much.", "May cut an order of magnitude (26 characters), but no more."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Note: and to those who tout Boyer Moore, I am afraid that the needle is too small, so it won't help much. May cut an order of magnitude (26 characters), but no more.", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}], [{"text": ["My first thought is that there isn't a problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["C++ gives second-best performance, nearly ten times faster than Java.", "Maybe all but Java are running close to the best performance achievable for that functionality, and you should be looking at how to fix the Java issue (hint - StringBuilder)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "StringBuilder", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In the C++ case, there are some things to try to improve performance a bit.", "In particular..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["s += 'X';"], "childNum": 0, "tag": "code", "senID": 3, "childList": []}, {"text": "Declare ", "tag": "none", "senID": 4}, {"text": "Try using ", "tag": "none", "senID": 5}]}, {"text": ["Overall, the result isn't too surprising though.", "JavaScript, with a good JIT compiler, may be able to optimise a little better than C++ static compilation is allowed to in this case."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["With enough work, you should always be able to optimise C++ better than JavaScript, but there will always be cases where that doesn't just naturally happen and where it may take a fair bit of knowledge and effort to achieve that."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I just tested the C++ example myself.", "If I remove the the call to std::sting::find, the program terminates in no time.", "Thus the allocations during string concatenation is no problem here."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "std::sting::find", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If I add a variable sdt::string abc = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" and replace the occurence of \"ABC...XYZ\" in the call of std::string::find, the program needs almost the same time to finish as the original example.", "This again shows that allocation as well as computing the string's length does not add much to the runtime."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "sdt::string abc = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "std::string::find", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Therefore, it seems that the string search algorithm used by libstdc++ is not as fast for your example as the search algorithms of javascript or python.", "Maybe you want to try C++ again with your own string search algorithm which fits your purpose better."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It seems that in nodejs better algorithm for search substrings.", "You can implement self and try it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Your test code is checking a pathological scenario of excessive string concatenation.", "(The string-search part of the test could have probably been omitted, I bet you it contributes almost nothing to the final results.", ") Excessive string concatenation is a pitfall that most languages warn very strongly against, and provide very well known alternatives for, (i.e.", "StringBuilder,) so what you are essentially testing here is how badly these languages fail under scenarios of perfectly expected failure.", "That's pointless."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["An example of a similarly pointless test would be to compare the performance of various languages when throwing and catching an exception in a tight loop.", "All languages warn that exception throwing and catching is abysmally slow.", "They do not specify how slow, they just warn you not to expect anything.", "Therefore, to go ahead and test precisely that, would be pointless."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So, it would make a lot more sense to repeat your test substituting the mindless string concatenation part (s += \"X\") with whatever construct is offered by each one of these languages precisely for avoiding string concatenation.", "(Such as class StringBuilder."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]