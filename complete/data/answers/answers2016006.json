[[{"text": ["Use sets instead:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n set1=set(line[:6] for line in open('file1.txt'))\nset2=set(line[:6] for line in open('file2.txt'))\nnot_found = set1 - set2\nif not_found:\n    print \"Some keys not found: \" + ', '.join(not_found)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n first_file=open(\"file1.txt\",\"r\")\n#save all items from first file into a set\nfirst_file_items=set(line.strip() for line in first_file)\nsecond_file=open(\"file2.txt\",\"r\")\nfor line in second_file:\n   if line[:6] in first_file_items:\n       #if this is item from the first file, remove it from the set\n       first_file_items.remove(line[:6])\n       #when nothing is left in the set, we found everything\n       if not first_file_items: break\n\nif first_file_items:\n   print \"Elements in first file but not in second\", first_file_items\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I don't think break; throws a StopIteration.    "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You generally don't want to use exceptions for flow control like that."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Go through each file once, adding each record to a hash with value equal to 1.", "Then make sure that the keys of the first hash are a subset of the keys of the second."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n hashes = []\nfor f in [\"file1.txt\",\"file2.txt\"]:\n    lines = open(f,\"r\").readlines()\n    hash = {}\n    for line in lines:\n        hash[line[:6] = 1\n    hashes.append(hash)\n\nset_keys1 = set(hashes[0].keys())\nset_keys2 = set(hashes[1].keys())\nassert(set_keys1.issubset(set_keys2))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think this might be closer to what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n unvalues = dict((line[:6], line[6:14]) for line in open(\"file1.txt\", \"r\"))\nnewfunds = [line for line in open(\"file2.txt\", \"r\")]\nfor i, line in enumerate(newfunds):\n    key = line.strip()\n    if key in unvalues:\n        v = unvalues[key]\n        print \"%s: Matching %s to %s for date %s\" % (i+1, line, key, v)\n    else:\n        print \"%s: No match for %s\" % (i+1, line)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You cannot (and need not) catch the StopIteration exception that occurs when the iterator is finished, because it gets caught by the for loop automatically.", "To do what you appear to be trying to do, you could use an else block after your for block, e.g.", "you could replace your inner loop with this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for line2 in iter(unvalues.readline, \"\"):\n    if line == line2[:6]:\n        print \"%s: Matching %s to %s for date %s\" % (i, line, line2[:6], line2[6:14])\n        break\nelse:\n    print \"%s: No match for %s\" % (i, line)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The else block is executed when the for loop finishes without the break statement getting hit."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["However, you may well find that one of the other approaches using sets is quicker."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n from collections import defaultdict\n\nunvalues = open(\"file1.txt\", \"r\").readlines()\nnewfunds = open(\"file2.txt\", \"r\").readlines()\n\nunvals = defaultdict(int)\n\nfor val in unvalues:\n    unvals[val] = 0\n\nfor line in newfunds:\n    line = line.strip()\n\n    if line[:6] in unvals.keys():\n        unvals[line[:6]] += 1\n\nfor k in unvals.keys():\n    if unvals[k] == 0:\n        print \"Match Not Found For %s\" % k\n</code>\n</pre>\n", "senID": 0}, {"text": ["might give you a good starting point for what you want to achieve, without being terribly messy.", "This gives you the performance advantage of only looping through each data set individually."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As a quick addendum, if you want line numbers, rather than building a counting variable outside the loop and incrementing it, try this instead:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for i, line in enumerate(newfunds):\n</code>\n</pre>\n", "senID": 3}, {"text": ["enumerate() basically zips a sequential integer iterator with your list to produce the desired result without unnecessary counting operations."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Another approach using sets"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n keys = set(line[:6] for line in open('file.txt'))\nmissing = set(value[:6] for value in open('file2.txt') if value[:6] not in keys)\nif missing:\n   print \"Keys Missing \" + ', '.join(missing)\n</code>\n</pre>\n", "senID": 1}]]