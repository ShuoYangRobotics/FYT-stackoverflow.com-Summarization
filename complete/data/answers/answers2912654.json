[[{"text": ["I would go for this, also you could override already defined properties."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class D:\n  def __init__(self, **kwargs):\n    self.__dict__.update(kwargs)\n</code>\n</pre>\n", "senID": 1}, {"text": ["But i personally would just go the long way.", "Think of those:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n - Explicit is better than implicit.\n- Flat is better than nested.\n(The Zen of Python)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I am not sure this is such a good idea, but it can be done:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import inspect\nclass NouveauRiches(object):\n    def __init__(self, car, mansion, jet, bling):\n        arguments = inspect.getargvalues(frame)[0]\n        values = inspect.getargvalues(frame)[3];\n        for name in arguments:\n            self.__dict__[name] = values[name]\n</code>\n</pre>\n", "senID": 1}, {"text": ["It does not read great either, though I suppose you could put this in a utility method that is reused."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could do this with a helper method, something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import inspect\n\ndef setargs(func):\n    f = inspect.currentframe(1)\n    argspec = inspect.getargspec(func)\n    for arg in argspec.args:\n        setattr(f.f_locals[\"self\"], arg, f.f_locals[arg])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Foo(object):\n\n    def __init__(self, bar, baz=4711):\n        setargs(self.__init__)\n\n        print self.bar # Now defined\n        print self.baz # Now defined\n</code>\n</pre>\n", "senID": 3}, {"text": ["This is not pretty, and it should probably only be used when prototyping.", "Please use explicit assignment if you plan to have others read it."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["It could probably be improved not to need to take the function as an argument, but that would require even more ugly hacks and trickery :)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Try something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d = dict(locals())\ndel d['self']\nself.__dict__.update(d)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course, it returns all local variables, not just function arguments."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could try something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class C(object):\n    def __init__(self, **kwargs):\n        for k in kwargs:\n            d = {k: kwargs[k]}\n            self.__dict__.update(d)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or using setattr you can do:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class D(object):\n    def __init__(self, **kwargs):\n        for k in kwargs:\n            setattr(self, k, kwargs[k])\n</code>\n</pre>\n", "senID": 3}, {"text": ["Both can then be called like:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n myclass = C(test=1, test2=2)\n</code>\n</pre>\n", "senID": 5}, {"text": ["So you have to use **kwargs, rather than *args."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I sometimes do this for classes that act \"bunch-like\", that is, they have a bunch of customizable attributes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class SuperClass(object):\n    def __init__(self, **kw):\n        for name, value in kw.iteritems():\n            if not hasattr(self, name):\n                raise TypeError('Unexpected argument: %s' % name)\n            setattr(self, name, value)\n\nclass SubClass(SuperClass):\n    instance_var = None # default value\n\nclass SubClass2(SubClass):\n    other_instance_var = True\n\n    @property\n    def something_dynamic(self):\n        return self._internal_var\n\n    @something_dynamic.setter # new Python 2.6 feature of properties\n    def something_dynamic(self, value):\n        assert value is None or isinstance(value, str)\n        self._internal_var = value\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you can call SubClass2(instance_var=[], other_instance_var=False) and it'll work without defining __init__ in either of them.", "You can use any property as well.", "Though this allows you to overwrite methods, which you probably wouldn't intend (as they return True for hasattr() just like an instance variable)."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "SubClass2(instance_var=[], other_instance_var=False)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "hasattr()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["If you add any property or other other descriptor it will work fine.", "You can use that to do type checking; unlike type checking in __init__ it'll be applied any time that value is updated.", "Note you can't use any positional arguments for these unless you override __init__, so sometimes what would be a natural positional argument won't work.", "formencode.declarative covers this and other issues, probably with a thoroughness I would not suggest you attempt (in retrospect I don't think it's worth it)."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "property", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "any", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "formencode.declarative", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://bitbucket.org/ianb/formencode/src/tip/formencode/declarative.py"}]}, {"text": ["Note that any recipe that uses self.__dict__ won't respect properties and descriptors, and if you use those together you'll just get weird and unexpected results.", "I only recommend using setattr() to set attributes, never self.__dict__."], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "self.__dict__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "only", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "setattr()", "childNum": 0, "tag": "code", "childList": []}, {"text": "never", "childNum": 0, "tag": "em", "childList": []}, {"text": "self.__dict__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Also this recipe doesn't give a very helpful signature, while some of the ones that do frame and function introspection do.", "With some work it is possible to dynamically generate a __doc__ that clarifies the arguments... but again I'm not sure the payoff is worth the addition of more moving parts."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "some work", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://bitbucket.org/ianb/formencode/src/tip/formencode/api.py#cl-283"}, {"text": "__doc__", "childNum": 0, "tag": "code", "childList": []}]}]]