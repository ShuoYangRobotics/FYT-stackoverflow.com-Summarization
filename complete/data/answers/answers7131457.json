[[{"text": ["You should not modify a list while iterating over it.", "This one should work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n listy = [2,2,1,3,4,2,1,2,3,4,5]\nfound = set()\nfor i in listy:\n    if not i in found:\n        print i, listy.count(i)\n        found.add(i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The result is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 2 4\n1 2\n3 2\n4 2\n5 1\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The reason for your problems is that you modify the list while you are iterating over it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you don't care about the order in which items appear in the output and don't care about the count, you can simply use use a set:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; listy = [2,2,1,3,4,2,1,2,3,4,5]\n&gt;&gt;&gt; print set(listy)\nset([1, 2, 3, 4, 5])\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you do care about the count, use the Counter class from the collections module in the Standard Library:"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "do", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "Counter", "childNum": 0, "tag": "code", "childList": []}, {"text": "collections", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import collections\n&gt;&gt;&gt; collections.Counter(listy)\nCounter({2: 4, 1: 2, 3: 2, 4: 2, 5: 1})\n&gt;&gt;&gt; c = collections.Counter(listy)\n&gt;&gt;&gt; for item in c.iteritems():\n...     print \"%i has a count of %i\" % item\n... \n1 has a count of 2\n2 has a count of 4\n3 has a count of 2\n4 has a count of 2\n5 has a count of 1\n</code>\n</pre>\n", "senID": 4}, {"text": ["If you do care about both the order and the count, you have to build a second list:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; checked = []\n&gt;&gt;&gt; counts = []\n&gt;&gt;&gt; for item in listy: \n&gt;&gt;&gt;     if item not in checked: \n&gt;&gt;&gt;         checked.append(item) \n&gt;&gt;&gt;         counts.append(listy.count(item))\n&gt;&gt;&gt; print zip(checked, counts)\n... [(2, 4), (1, 2), (3, 2), (4, 2), (5, 1)]\n</code>\n</pre>\n", "senID": 6}, {"text": ["This is the least efficient solution, of course."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["If you don't want to keep the counts for later, you don't need the counts list:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "counts", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n listy = [2,2,1,3,4,2,1,2,3,4,5]\nchecked = set()\nfor item in listy: \n    # \"continue early\" looks better when there is lots of code for\n    # handling the other case\n    if item in checked:     \n        continue\n\n    checked.add(item) \n    print item, listy.count(item)\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Don't modify a list while iterating over it, it will mess you up every time:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n listy = [2,2,1,3,4,2,1,2,3,4,5]\n#        *     *     * Get hit\nfor i in listy:\n    print i\n    if listy.count(i) &gt; 1:\n        print i, listy.count(i), 'item and occurences'\n        while i in listy: listy.remove(i)\n    else:\n        print i, listy.count(i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If what you want is to print each item only once, you can use the simple set method, or you could use the itertoolsunique_everseenrecipe:"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/itertools.html#recipes", "text": "itertoolsunique_everseenrecipe", "childNum": 2, "tag": "a", "childList": [{"text": "itertools", "tag": "code"}, {"text": "unique_everseen", "tag": "code"}]}, {"text": "itertools", "childNum": 0, "tag": "code", "childList": []}, {"text": "unique_everseen", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def unique_everseen(iterable, key=None):\n    \"List unique elements, preserving order. Remember all elements ever seen.\"\n    # unique_everseen('AAAABBBCCDAABBB') --&gt; A B C D\n    # unique_everseen('ABBCcAD', str.lower) --&gt; A B C D\n    seen = set()\n    seen_add = seen.add\n    if key is None:\n        for element in ifilterfalse(seen.__contains__, iterable):\n            seen_add(element)\n            yield element\n    else:\n        for element in iterable:\n            k = key(element)\n            if k not in seen:\n                seen_add(k)\n                yield element\n</code>\n</pre>\n", "senID": 3}, {"text": ["Which extends the basic set version to allow you to specify a special way to compare items."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you want to know which items are only in the list once:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n listy2 = filter(lambda i: listy.count(i) == 1, listy)\n</code>\n</pre>\n", "senID": 6}, {"text": ["listy2 now has all the single occurrences."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "listy2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you don't like the lambda, just do:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def getsingles(listy):\n    def singles(i):\n        return listy.count(i) == 1\n    return singles\n</code>\n</pre>\n", "senID": 9}, {"text": ["then:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n listy2 = filter(getsingles(listy), listy)\n</code>\n</pre>\n", "senID": 11}, {"text": ["This makes a special function that will tell you which items are in listy only once."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "listy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The reason of the behavior you get is here, in the note:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http&#58;//docs.python.org/reference/compound_stmts.html#index-811"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http&#58;//docs.python.org/reference/compound_stmts.html#index-811", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/compound_stmts.html#index-811"}]}, {"text": ["Update 1"], "childNum": 0, "tag": "h2", "senID": 2, "childList": []}, {"text": ["agf's solution isn't a good one for performance reason: the list is filtered according to the count of each element.", "The counting is done for each element, that is to say the counting process that consists to run through the entire list to count, is done as many times as there are elements in list: it's overconsuming time, imagine if your list is 1000 length"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["A better solution I think is to use an instance of Counter:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import random\nfrom collections import Counter\n\nli = [ random.randint(0,20) for i in xrange(30)]\n\nc = Counter(li)\n\nprint c\nprint type(c)\n\nres = [ k for k in c if c[k]==1]\nprint res\n</code>\n</pre>\n", "senID": 5}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n Counter({8: 5, 0: 3, 4: 3, 9: 3, 2: 2, 5: 2, 11: 2, 3: 1, 6: 1, 10: 1, 12: 1, 15: 1, 16: 1, 17: 1, 18: 1, 19: 1, 20: 1})\n&lt;class 'collections.Counter'&gt;\n[3, 6, 10, 12, 15, 16, 17, 18, 19, 20]\n</code>\n</pre>\n", "senID": 7}, {"text": ["Another solution would be to add the read elements in a set in order that the program avoids to make a count for an already seen element."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Update 2"], "childNum": 0, "tag": "h2", "senID": 9, "childList": []}, {"text": ["errrr.... my solution is stupid, you don't want to select the element appearing only one time in the list...."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Then the following code is the right one , I think:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n import random\nfrom collections import Counter\n\nlisty = [ random.randint(0,20) for i in xrange(30)]\nprint 'listy==',listy\nprint\n\nc = Counter(listy)\nprint c\nprint type(c)\nprint\n\nslimmed_listy = []\nfor el in listy:\n    if el in c:\n        slimmed_listy.append(el)\n        print 'element',el,'  count ==',c[el]\n        del c[el] \nprint\n\nprint 'slimmed_listy==',slimmed_listy\n</code>\n</pre>\n", "senID": 12}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n listy== [13, 10, 1, 1, 13, 11, 18, 15, 3, 15, 12, 11, 15, 18, 11, 10, 14, 10, 20, 3, 18, 9, 11, 2, 19, 15, 5, 14, 1, 1]\n\nCounter({1: 4, 11: 4, 15: 4, 10: 3, 18: 3, 3: 2, 13: 2, 14: 2, 2: 1, 5: 1, 9: 1, 12: 1, 19: 1, 20: 1})\n&lt;class 'collections.Counter'&gt;\n\nelement 13   count == 2\nelement 10   count == 3\nelement 1   count == 4\nelement 11   count == 4\nelement 18   count == 3\nelement 15   count == 4\nelement 3   count == 2\nelement 12   count == 1\nelement 14   count == 2\nelement 20   count == 1\nelement 9   count == 1\nelement 2   count == 1\nelement 19   count == 1\nelement 5   count == 1\n\nslimmed_listy== [13, 10, 1, 11, 18, 15, 3, 12, 14, 20, 9, 2, 19, 5]\n</code>\n</pre>\n", "senID": 14}, {"text": ["In case you wouldn't want the result in the order of listy, the code would be even simpler"], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "listy", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Update 3"], "childNum": 0, "tag": "h2", "senID": 16, "childList": []}, {"text": ["If you want only to print, then I propose:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n import random\nfrom collections import Counter\n\nlisty = [ random.randint(0,20) for i in xrange(30)]\nprint 'listy==',listy\nprint\n\n\ndef gener(li):\n    c = Counter(li)\n    for el in li:\n        if el in c:\n            yield el,c[el]\n            del c[el] \n\n\nprint '\\n'.join('element %4s   count %4s' % x for x in gener(listy))\n</code>\n</pre>\n", "senID": 18}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"code": "<pre>\n<code>\n listy== [16, 2, 4, 9, 15, 19, 1, 1, 3, 5, 12, 15, 12, 3, 17, 13, 8, 11, 4, 6, 15, 1, 0, 1, 3, 3, 6, 5, 0, 8]\n\nelement   16   count    1\nelement    2   count    1\nelement    4   count    2\nelement    9   count    1\nelement   15   count    3\nelement   19   count    1\nelement    1   count    4\nelement    3   count    4\nelement    5   count    2\nelement   12   count    2\nelement   17   count    1\nelement   13   count    1\nelement    8   count    2\nelement   11   count    1\nelement    6   count    2\nelement    0   count    2\n</code>\n</pre>\n", "senID": 20}], [{"text": ["Modifying a list while you iterate over it is a bad idea in every language I have encountered.", "My suggestion: don't do that.", "Here are some better ideas."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Use asetto find single occurrences"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Use asetto find single occurrences", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "set", "tag": "code"}]}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n source = [2,2,1,3,4,2,1,2,3,4,5]\nfor s in set(source):\n    print s\n</code>\n</pre>\n", "senID": 2}, {"text": ["And you get this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; source = [2,2,1,3,4,2,1,2,3,4,5]\n&gt;&gt;&gt; for s in set(source):\n...     print s\n... \n1\n2\n3\n4\n5\n</code>\n</pre>\n", "senID": 4}, {"text": ["If you want the counts, usedefaultdict"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "If you want the counts, usedefaultdict", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "defaultdict", "tag": "code"}]}, {"text": "defaultdict", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from collections import defaultdict\nd = defaultdict(int)\nsource = [2,2,1,3,4,2,1,2,3,4,5]\nfor s in source:\n    d[s] += 1\n\nfor k, v in d.iteritems():\n    print k, v\n</code>\n</pre>\n", "senID": 6}, {"text": ["You'll get this:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for k, v in d.iteritems():\n...     print k, v\n... \n1 2\n2 4\n3 2\n4 2\n5 1\n</code>\n</pre>\n", "senID": 8}, {"text": ["If you want your results sorted, usesortandoperator"], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "If you want your results sorted, usesortandoperator", "childNum": 2, "tag": "strong", "pos": 0, "childList": [{"text": "sort", "tag": "code"}, {"text": "operator", "tag": "code"}]}, {"text": "sort", "childNum": 0, "tag": "code", "childList": []}, {"text": "operator", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import operator\nfor k, v in sorted(d.iteritems(), key=operator.itemgetter(1)):\n    print k, v\n</code>\n</pre>\n", "senID": 10}, {"text": ["You'll get this:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import operator\n&gt;&gt;&gt; for k, v in sorted(d.iteritems(), key=operator.itemgetter(1)):\n...     print k, v\n... \n5 1\n1 2\n3 2\n4 2\n2 4\n</code>\n</pre>\n", "senID": 12}], [{"text": ["I am not sure if it is a good idea to iterate the list and remove elements at the same time.", "If you really just want to output all items and their number of occurrences, I would do it like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n listy = [2,2,1,3,4,2,1,2,3,4,5]\nlistx = []\nlistc = []\nfor i in listy:\n    if not i in listx:\n        listx += [i]\n        listc += [listy.count(i)]\nfor x, c in zip(listx, listc):\n    print x, c\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Like agf said, modifying a list while you iterate it will cause problems.", "You could solve your code by using while and pop:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "while", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "pop", "tag": "a", "pos": 1, "childList": [{"text": "pop", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/tutorial/datastructures.html#more-on-lists"}, {"text": "pop", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n single_occurrences = []\nwhile listy:\n    i = listy.pop(0)\n    count = listy.count(i)+1\n    if count &gt; 1:\n        print i, count\n        while i in listy: listy.remove(i)\n    else:\n        print i, count\n    single_occurrences.append(i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 2 4\n1 2\n3 2\n4 2\n5 1\n</code>\n</pre>\n", "senID": 3}], [{"text": ["One way to do that would be to create a result list and test whether the tested value is in it : "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n res=[]\nlisty = [2,2,1,3,4,2,1,2,3,4,5]\n\nfor i in listy:\n    if listy.count(i)&gt;1 and i not in res:\n        res.append(i)\n\nfor i in res:\n    print i, listy.count(i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Result :"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 2 4\n1 2\n3 2\n4 2\n</code>\n</pre>\n", "senID": 3}]]