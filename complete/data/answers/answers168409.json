[[{"text": ["I've done this in the past for a Python script to determine the last updated files in a directory: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import glob\nimport os\n\nsearch_dir = \"/mydir/\"\n# remove anything from the list that is not a file (directories, symlinks)\n# thanks to J.F. Sebastion for pointing out that the requirement was a list \n# of files (presumably not including directories)  \nfiles = filter(os.path.isfile, glob.glob(search_dir + \"*\"))\nfiles.sort(key=lambda x: os.path.getmtime(x))\n</code>\n</pre>\n", "senID": 1}, {"text": ["That should do what you're looking for based on file mtime."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: Note that you can also use os.listdir() in place of glob.glob() if desired - the reason I used glob in my original code was that I was wanting to use glob to only search for files with a particular set of file extensions, which glob() was better suited to.", "To use listdir here's what it would look like: "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import os\n\nsearch_dir = \"/mydir/\"\nos.chdir(search_dir)\nfiles = filter(os.path.isfile, os.listdir(search_dir))\nfiles = [os.path.join(search_dir, f) for f in files] # add path to each file\nfiles.sort(key=lambda x: os.path.getmtime(x))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Here's a more verbose version of @Greg Hewgill's answer.", "It is the most conforming to the question requirements.", "It makes a distinction between creation and modification dates (at least on Windows)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "@Greg Hewgill's answer", "tag": "a", "pos": 0, "childList": [{"text": "@Greg Hewgill", "tag": "code"}], "childNum": 1, "href": "http://stackoverflow.com/questions/168409/how-do-you-get-a-directory-listing-sorted-by-creation-date-in-python/168435#168435"}, {"text": "@Greg Hewgill", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nfrom stat import S_ISREG, ST_CTIME, ST_MODE\nimport os, sys, time\n\n# path to the directory (relative or absolute)\ndirpath = sys.argv[1] if len(sys.argv) == 2 else r'.'\n\n# get all entries in the directory w/ stats\nentries = (os.path.join(dirpath, fn) for fn in os.listdir(dirpath))\nentries = ((os.stat(path), path) for path in entries)\n\n# leave only regular files, insert creation date\nentries = ((stat[ST_CTIME], path)\n           for stat, path in entries if S_ISREG(stat[ST_MODE]))\n#NOTE: on Windows `ST_CTIME` is a creation date \n#  but on Unix it could be something else\n#NOTE: use `ST_MTIME` to sort by a modification date\n\nfor cdate, path in sorted(entries):\n    print time.ctime(cdate), os.path.basename(path)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ python stat_creation_date.py\nThu Feb 11 13:31:07 2009 stat_creation_date.py\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here's my version:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def getfiles(dirpath):\n    a = [s for s in os.listdir(dirpath)\n         if os.path.isfile(os.path.join(dirpath, s))]\n    a.sort(key=lambda s: os.path.getmtime(os.path.join(dirpath, s)))\n    return a\n</code>\n</pre>\n", "senID": 1}, {"text": ["First, we build a list of the file names.", "isfile() is used to skip directories; it can be omitted if directories should be included.", "Then, we sort the list in-place, using the modify date as the key."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's a one-liner:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\nimport time\nfrom pprint import pprint\n\npprint([(x[0], time.ctime(x[1].st_ctime)) for x in sorted([(fn, os.stat(fn)) for fn in os.listdir(\".\")], key = lambda x: x[1].st_ctime)])\n</code>\n</pre>\n", "senID": 1}, {"text": ["This calls os.listdir() to get a list of the filenames, then calls os.stat() for each one to get the creation time, then sorts against the creation time."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note that this method only calls os.stat() once for each file, which will be more efficient than calling it for each comparison in a sort."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n sorted(filter(os.path.isfile, os.listdir('.')), \n    key=lambda p: os.stat(p).st_mtime)\n</code>\n</pre>\n", "senID": 0}, {"text": ["You could use os.walk('.", "').next()[-1] instead of filtering with os.path.isfile, but that leaves dead symlinks in the list, and os.stat will fail on them."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "os.walk('.').next()[-1]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "os.path.isfile", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "os.stat", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["There is an os.paht.getmtime function that gives the number of seconds since the epoch\nand should be faster than os.stat."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n os.chdir(directory)\nsorted(filter(os.path.isfile, os.listdir('.')), key=os.path.getmtime)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["this is a basic step for learn:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os, stat, sys\nimport time\n\ndirpath = sys.argv[1] if len(sys.argv) == 2 else r'.'\n\nlistdir = os.listdir(dirpath)\n\nfor i in listdir:\n    os.chdir(dirpath)\n    data_001 = os.path.realpath(i)\n    listdir_stat1 = os.stat(data_001)\n    listdir_stat2 = ((os.stat(data_001), data_001))\n    print time.ctime(listdir_stat1.st_ctime), data_001\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Maybe you should use shell commands.", "In Unix/Linux, find piped with sort will probably be able to do what you want. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]