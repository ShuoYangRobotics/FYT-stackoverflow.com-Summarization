[[{"text": ["As far as I know, this isn't possible in 2.5.", "However, in 3.0, this was changed so that you can simply call super().__init__()."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "super().__init__()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["This is fixed in Python 3.  http://docs.python.org/py3k/library/functions.html#super"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/py3k/library/functions.html#super", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/py3k/library/functions.html#super"}]}, {"text": ["http://www.python.org/dev/peps/pep-3135/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.python.org/dev/peps/pep-3135/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3135/"}]}], [{"text": ["In Python 3.0, the super() can be called without arguments to do the same thing."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "super()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/py3k/library/functions.html#super"}]}], [{"text": ["I think if your class only inherits from one class it is safe to do just this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "one", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class B(A):\n    def __init__(self):\n        A.__init__(self)\n</code>\n</pre>\n", "senID": 1}, {"text": ["But I could be mistaken."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "But I could be mistaken.", "childNum": 0, "tag": "del", "pos": 0, "childList": []}]}], [{"text": ["There is some __class__ magic variable.", "The __class__ magic variable.", "Try:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__class__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__class__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class foo(OtherClass):\n    def __init__(self, *args, **kwargs):\n        super(self.__class__, self).__init__(*args, **kwargs)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["EDIT"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["As pointed out by Alex, this is wrong where there is more than a single level of inheritence."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Yes, \"new\" style classes have a __class__ attribute available which can be used, eg."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "__class__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class B(object):\n    def __init__(self):\n        print \"B.__init__():\"\n\nclass D(B):\n    def __init__(self):\n        print \"D.__init__():\"\n        super(self.__class__, self).__init__()\n\n&gt;&gt;&gt; d = D()\nD.__init__():\nB.__init__():\n\n&gt;&gt;&gt; dir(d)\n['__class__', '__delattr__', '__dict__', '__doc__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__str__', '__weakref__']\n&gt;&gt;&gt; d.__class__\n&lt;class '__main__.D'&gt;\n</code>\n</pre>\n", "senID": 3}]]