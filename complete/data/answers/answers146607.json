[[{"text": ["The first thing that may improve things is to move the re.compile outside the function.", "The compilation is cached, but there is a speed hit in checking this to see if its compiled."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Another possibility is to use a single regex as below:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n MatchedQuotes = re.compile(r\"(['\\\"])(.*)\\1\", re.LOCALE)\nitem = MatchedQuotes.sub(r'\\2', item, 1)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Finally, you can combine this into the regex in processVariables.", "Taking Torsten Marek's suggestion to use a function for re.sub, this improves and simplifies things dramatically."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Torsten Marek's", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/146607/im-using-python-regexes-in-a-criminally-inefficient-manner#146683"}]}, {"code": "<pre>\n<code>\n VariableDefinition = re.compile(r'&lt;%([\"\\']?)(.*?)\\1=([\"\\']?)(.*?)\\3%&gt;', re.LOCALE)\nVarRepl = re.compile(r'&lt;%([\"\\']?)(.*?)\\1%&gt;', re.LOCALE)\n\ndef processVariables(item):\n    vars = {}\n    def findVars(m):\n        vars[m.group(2).upper()] = m.group(4)\n        return \"\"\n\n    item = VariableDefinition.sub(findVars, item)\n    return VarRepl.sub(lambda m: vars[m.group(2).upper()], item)\n\nprint processVariables('&lt;%\"TITLE\"=\"This Is A Test Variable\"%&gt;The Web &lt;%\"TITLE\"%&gt;')\n</code>\n</pre>\n", "senID": 4}, {"text": ["Here are my timings for 100000 runs:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n Original       : 13.637\nGlobal regexes : 12.771\nSingle regex   :  9.095\nFinal version  :  1.846\n</code>\n</pre>\n", "senID": 6}, {"text": ["[Edit] Add missing non-greedy specifier"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["[Edit2] Added .upper() calls so case insensitive like original version"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["sub can take a callable as it's argument rather than a simple string.", "Using that, you can replace all variables with one function call:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sub", "tag": "a", "pos": 0, "childList": [{"text": "sub", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/lib/node46.html"}, {"text": "sub", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; var_matcher = re.compile(r'&lt;%(.*?)%&gt;', re.LOCALE)\n&gt;&gt;&gt; string = '&lt;%\"TITLE\"%&gt; &lt;%\"SHMITLE\"%&gt;'\n&gt;&gt;&gt; values = {'\"TITLE\"': \"I am a title.\", '\"SHMITLE\"': \"And I am a shmitle.\"}\n&gt;&gt;&gt; var_matcher.sub(lambda m: vars[m.group(1)], string)\n'I am a title. And I am a shmitle.\n</code>\n</pre>\n", "senID": 1}, {"text": ["Follow eduffy.myopenid.com's advice and keep the compiled regexes around. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "eduffy.myopenid.com", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "#146646"}]}, {"text": ["The same recipe can be applied to the first loop, only there you need to store the value of the variable first, and always return \"\" as replacement."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "\"\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Never create your own programming language.", "Ever.", "(I used to have an exception to this rule, but not any more."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There is always an existing language you can use which suits your needs better.", "If you elaborated on your use-case, people may help you select a suitable language."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Creating a templating language is all well and good, but shouldn't one of the goals of the templating language be easy readability and efficient parsing?", "The example you gave seems to be neither."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As Jamie Zawinsky famously said:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If regular expressions are a solution to a problem you have created, the best bet is not to write a better regular expression, but to redesign your approach to eliminate their use entirely.", "Regular expressions are complicated, expensive, hugely difficult to maintain, and (ideally) should only be used for working around a problem someone else created."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can match both kind of quotes in one go with r\"(\\\"|')(.*?", ")\\1\" - the \\1 refers to the first group, so it will only match matching quotes."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "r\"(\\\"|')(.*?)\\1\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\\1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You're calling re.compile quite a bit.", "A global variable for these wouldn't hurt here."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If a regexp only contains one .", "* wildcard and literals, then you can use find and rfind to locate the opening and closing delimiters."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If it contains only a series of .*?", "wildcards, and literals, then you can just use a series of find's to do the work."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If the code is time-critical, this switch away from regexp's altogether might give a little more speed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Also, it looks to me like this is an LL-parsable language.", "You could look for a library that can already parse such things for you.", "You could also use recursive calls to do a one-pass parse -- for example, you could implement your processVariables function to only consume up the first quote, and then call a quote-matching function to consume up to the next quote, etc."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "LL-parsable language", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/LL_parser"}]}], [{"text": ["Why not use Mako?", "Seriously.", "What feature do you require that Mako doesn't have?", "Perhaps you can adapt or extend something that already works."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Mako", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.makotemplates.org/"}]}], [{"text": ["Don't call search twice in a row (in the loop conditional, and the first statement in the loop).", "Call (and cache the result) once before the loop, and then in the final statement of the loop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Why not use XML and XSLT instead of creating your own template language?", "What you want to do is pretty easy in XSLT."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]