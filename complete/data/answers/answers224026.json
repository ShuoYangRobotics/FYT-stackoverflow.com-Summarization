[[{"text": ["Your DictObj example is actually quite common.", "Object-style dot-notation access can be a win if you are dealing with \u2018things that resemble objects\u2019, ie.", "they have fixed property names containing only characters valid in Python identifiers.", "Stuff like database rows or form submissions can be usefully stored in this kind of object, making code a little more readable without the excess of ['item access']."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The implementation is a bit limited - you don't get the nice constructor syntax of dict, len(), comparisons, 'in', iteration or nice reprs.", "You can of course implement those things yourself, but in the new-style-classes world you can get them for free by simply subclassing dict:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class AttrDict(dict):\n    __getattr__= dict.__getitem__\n    __setattr__= dict.__setitem__\n    __delattr__= dict.__delitem__\n</code>\n</pre>\n", "senID": 2}, {"text": ["To get the default-to-None behaviour, simply subclass Python 2.5's collections.defaultdict class instead of dict."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["With regards to the DictObj, would the following work for you?", "A blank class will allow you to arbitrarily add to or replace stuff in a container object."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "DictObj", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Container(object):\n    pass\n\n&gt;&gt;&gt; myContainer = Container()\n&gt;&gt;&gt; myContainer.spam = \"in a can\"\n&gt;&gt;&gt; myContainer.eggs = \"in a shell\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want to not throw an AttributeError when there is no attribute, what do you think about the following?", "Personally, I'd prefer to use a dict for clarity, or to use a try/except clause."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class QuietContainer(object):\n    def __getattr__(self, attribute):\n        try:\n            return object.__getattr__(self,attribute)\n        except AttributeError:\n            return None\n\n&gt;&gt;&gt; cont = QuietContainer()\n&gt;&gt;&gt; print cont.me\nNone\n</code>\n</pre>\n", "senID": 3}, {"text": ["Right?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["This is a simpler version of your DictObj class:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class DictObj(object):\n    def __getattr__(self, attr):\n        return self.__dict__.get(attr)\n\n&gt;&gt;&gt; d = DictObj()\n&gt;&gt;&gt; d.something = 'one'\n&gt;&gt;&gt; print d.something\none\n&gt;&gt;&gt; print d.somethingelse\nNone\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["As far as I know, Python classes use dictionaries to store their attributes anyway (that's hidden from the programmer), so it looks to me that what you've done there is effectively emulate a Python class... using a python class. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["It's not \"wrong\" to do this, and it can be nicer if your dictionaries have a strong possibility of turning into objects at some point, but be wary of the reasons for having bracket access in the first place:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also keep in mind you can always make your objects access like dictionaries if you decide to switch to objects later on."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For a case like this I would default to the \"readability counts\" mantra: presumably other Python programmers will be reading your code and they probably won't be expecting dictionary/object hybrids everywhere.", "If it's a good design decision for a particular situation, use it, but I wouldn't use it without necessity to do so."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The one major disadvantage of using something like your DictObj is you either have to limit allowable keys or you can't have methods on your DictObj such as .keys(), .values(), .items(), etc."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": ".keys()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".values()", "childNum": 0, "tag": "code", "childList": []}, {"text": ".items()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["It's not bad if it serves your purpose.", "\"Practicality beats purity\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I saw such approach elserwhere (eg.", "in Paver), so this can be considered common need (or desire)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Paver", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.blueskyonmars.com/projects/paver/"}, {"text": "common need", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["I like dot notation a lot better than dictionary fields personally.", "The reason being that it makes autocompletion work a lot better."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Can anyone get cPickle to work with this minimal Dotdict\n(in Python 2.5.1, macosx 10.4.11) ?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Dotdict( dict ):\n    def __getattr__(self, attr):\n        return self.get(attr, None)\n\nif __name__ == \"__main__\":\n    d = Dotdict( a=1 )\n    print d.a, d[\"a\"], d.get( \"no\", 42 ), d, d.keys(), \"%(a)s\" % d\n    # print \"%(no)s\" % d  # KeyError\n\n    import cPickle\n    ddump = cPickle.dumps( d, -1 )  \n        # =&gt; TypeError: 'NoneType' object is not callable\n    # assert ddump == cPickle.loads( ddump )\n</code>\n</pre>\n", "senID": 1}]]