[[{"text": ["An algorithm that seems to meet your requirements (and is perhaps similar to what John the Statistician is suggesting) is Semantic Hashing.", "The basic idea is that it trains a deep belief network (a type of neural network that some have called 'neural networks 2.0' and is a very active area of research right now) to create a hash of the list of descriptions of an object into binary number such that the Hamming distance between the numbers correspond to similar objects.", "Since this just requires bitwise operations it can be pretty fast, and since you can use it to create a nearest neighbor-style algorithm it naturally generalizes to a very large number of classes.", "This is very good state of the art stuff.", "Downside: it's not trivial to understand and implement, and requires some parameter tuning.", "The author provides some Matlab code here.", "A somewhat easier algorithm to implement and is closely related to this one is Locality Sensitive Hashing. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Semantic Hashing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cs.toronto.edu/~rsalakhu/papers/semantic_final.pdf"}, {"text": "here", "tag": "a", "pos": 5, "childList": [], "childNum": 0, "href": "http://www.cs.toronto.edu/~hinton/MatlabForSciencePaper.html"}]}, {"text": ["Now that you say that you have an expensive distance function you want to approximate quickly, I'm reminded of another very interesting algorithm that does this, Boostmap.", "This one uses boosting to create a fast metric which approximates an expensive to calculate metric.", "In a certain sense it's similar to the above idea but the algorithms used are different.", "The authors of this paper have several papers on related techniques, all pretty good quality (published in top conferences) that you might want to check out."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Boostmap", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cs-people.bu.edu/athitsos/publications/athitsos_cvpr2004.pdf"}]}], [{"text": ["You could use the vector space model (http://en.wikipedia.org/wiki/Vector_space_model).", "I think what you are trying to learn is how to weight terms in considering how close two object description vectors are to each other, say for example in terms of a simplified mutual information.", "This could be very efficient as you could hash from terms to vectors, which means you wouldn't have to compare objects without shared features.", "The naive model would then have an adjustable weight per term (this could either be per term per vector, per term overall, or both), as well as a threshold.", "The vector space model is a widely used technique (for example, in Apache Lucene, which you might be able to use for this problem), so you'll be able to find out a lot about it through further searches.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Let me give a very simple formulation of this in terms of your example.", "Given bob:  ['tall','old','funny'], I retrieve"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["frank: ['young','short,'funny']\nsteve: ['tall','old','grumpy']\njoe: ['tall','old']"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["as I am maintaining a hash from funny->{frank,...}, tall->{steve, joe,...}, and old->{steve, joe,...}"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I calculate something like the overall mutual information:  weight of shared tags/weight of bob's tags.", "If that weight is over the threshold, I include them in the list.  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["When training, if I make a mistake I modify the shared tags.", "If my error was including frank, I reduce the weight for funny, while if I make a mistake by not including Steve or Joe, I increase the weight for tall and old."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["You can make this as sophisticated as you'd like, for example by including weights for conjunctions of terms."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["SVM is pretty fast.", "LIBSVM for Python, in particular, provides a very decent implementation of Support Vector Machine for classification."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "LIBSVM", "tag": "a", "pos": 1, "childList": [{"text": "LIBSVM", "tag": "strong"}], "childNum": 1, "href": "http://www.csie.ntu.edu.tw/~cjlin/libsvm/"}, {"text": "LIBSVM", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["do you really need a machine learning algorithm for this?", "What is your metric for similarity?", "You've mentioned the dimensionality of the number of objects, what about the size of the trait set for each person?", "Are there a maximum number of trait types?", "I might try something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["1) Have a dictionary mapping trait to a list of names named map"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["for each person p"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["for each trait t in p"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["map[t].add(p);"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["2) then when I want to find the closest person, I'd take my dictionary and create a new temp one:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["dictionary mapping name to count called cnt"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["for each trait t in my person of interest"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["for each person p in map[t]"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["cnt[p]++;"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["then the entry with the highest count is closest"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["The benefit here is the map is only created once.", "if the traits per person is small, and the types of available traits are large, then the algorithm should be fast."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["This project departs from typical classification applications in two notable ways:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Rather than outputting the class which the new object is thought to belong to (or possibly outputting an array of these classes, each with probability / confidence level), the \"classifier\" provides a list of \"neighbors\" which are \"close enough\" to the new object.", "tag": "none", "senID": 1}, {"text": "With each new classification, an objective function, independent from the classifier, provides the list of the correct \"neighbors\"; in turn the corrected list (a ", "tag": "none", "senID": 2}]}, {"text": ["The idea behind the second point is probably that future objects submitted to the classifier and with similar to the current object should get better \"classified\" (be associated with a more correct set of previously seen objects) since the on-going training re-enforces connections to positive (correct) matches, while weakening the connection to objects which the classifier initially got wrong."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["These two characteristics introduce distinct problems.", "- The fact that the output is a list of objects rather than a \"prototype\" (or category identifier of sorts) make it difficult to scale as the number of objects seen so far grows toward the millions of instances as suggested in the question.", "- The fact that the training is done on the basis of a subset of the matches found by the classifier, may introduce over-fitting, whereby the classifier could become \"blind\" to features (dimensions) which it, accidentally, didn't weight as important/relevant, in the early parts of the training.", "(I may be assuming too much with regards to the objective function in charge of producing the list of \"correct\" objects)"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "subset", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Possibly, the scaling concern could be handled by having a two-step process, with a first classifier, based the K-Means algorithm or something similar, which would produce a subset of the overall object collection (of objects previously seen) as plausible matches for the current object (effectively filtering out say 70% or more of collection).", "These possible matches would then be evaluated on the basis of Vector Space Model (particularly relevant if the feature dimensions are based on factors rather than values) or some other models.", "The underlying assumption for this two-step process is that the object collection will effectively expose clusters (it may just be relatively evenly distributed along the various dimensions)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Another way to further limit the number of candidates to evaluate, as the size of the previously seen objects grows, is to remove near duplicates and to only compare with one of these (but to supply the full duplicate list in the result, assuming that if the new object is close to the \"representative\" of this near duplicate class, all members of the class would also match)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["The issue of over-fitting is trickier to handle.", "A possible approach would be to [sometimes] randomly add objects to the matching list which the classifier would not normally include.", "The extra objects could be added on the basis of their distance relative distance to the new object (i.e.", "making it a bit more probable that a relatively close object be added)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["What you describe is somewhat similar to the Locally Weighted Learning algorithm, which given a query instance, it trains a model locally around the neighboring instances weighted by their distances to the query one."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Locally Weighted Learning", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Weka (Java) has an implementation of this in weka.classifiers.lazy.LWL"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "weka.classifiers.lazy.LWL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.pentaho.com/display/DATAMINING/LWL"}]}]]