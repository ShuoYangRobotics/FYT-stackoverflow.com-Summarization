[[{"text": ["It sounds like you will want to research dictionaries and string formatting.", "In general, if you need help programming, just break down any problem you have into extremely small, discrete chunks, search those chunks independently, and then you should be able to formulate it all into  a larger answer.", "Stack Overflow is a great resource for this type of searching."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "dictionaries", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#dictionaries"}, {"text": "string formatting", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#string-formatting-operations"}]}, {"text": ["Also, if you have any general curiosities about Python, search or browse the official Python documentation.", "If you find yourself constantly not knowing where to begin, read the Python tutorial or find a book to go through.", "A week or two investment to get a good foundational knowledge of what you are doing will pay off over and over again as you complete work."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "official Python documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/index.html"}, {"text": "Python tutorial", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/index.html"}]}, {"code": "<pre>\n<code>\n verb_color_map = {\n    'likes': 'red',\n    'dislikes': 'blue',\n    'knows': 'black',\n}\n\nwith open('infile.txt') as infile: # assuming you've stored your data in 'infile.txt'\n    for line in infile:\n        # Python uses the name object, so I use object_\n        subject, verb, object_ = line.split()\n        print \"%s -&gt; %s %s;\" % (subject, object_, verb_color_map[verb])\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Simple enough; assuming the lists of verbs is fixed and small, this is easy to do with a dictionary and for loop:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n VERBS = {\n    \"likes\": \"red\"\n  , \"dislikes\": \"blue\"\n  , \"knows\": \"black\"\n  }\n\ndef replace_verb (line):\n    for verb, color in VERBS.items():\n        if verb in line:\n            return \"%s %s;\" % (\n                  line.replace (verb, \"-&gt;\")\n                , color\n                )\n    return line\n\ndef main ():\n    filename = \"my_file.txt\"\n    with open (filename, \"r\") as fp:\n        for line in fp:\n            print replace_verb (line)\n\n# Allow the module to be executed directly on the command line\nif __name__ == \"__main__\":\n    main ()\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n verbs = {\"dislikes\":\"blue\", \"knows\":\"black\", \"likes\":\"red\"}\nfor s in open(\"/tmp/infile\"):\n  s = s.strip()\n  for verb in verbs.keys():\n    if (s.count(verb) &gt; 0):\n      print s.replace(verb,\"-&gt;\")+\" \"+verbs[verb]+\";\"\n      break\n</code>\n</pre>\n", "senID": 0}, {"text": ["Edit: Rather use \"for s in open\""], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Are you sure this isn't a little homeworky :)  If so, it's okay to fess up.", "Without going into too much detail, think about the tasks you're trying to do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For each line:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Code using NetworkX (networkx.lanl.gov/)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n '''\nplot relationships in a social network\n'''\n\nimport networkx\n## make a fake file 'ex.txt' in this directory\n## then write fake relationships to it.\nexample_relationships = file('ex.txt','w') \nprint &gt;&gt; example_relationships, '''\\\nJane Doe likes Fred\nChris dislikes Joe\nNate knows Jill \\\n'''\nexample_relationships.close()\n\nrel_colors = {\n    'likes':  'blue',\n    'dislikes' : 'black',\n    'knows'   : 'green',\n}\n\ndef split_on_verb(sentence):\n    ''' we know the verb is the only lower cased word\n\n    &gt;&gt;&gt; split_on_verb(\"Jane Doe likes Fred\")\n    ('Jane Does','Fred','likes')\n\n    '''\n    words = sentence.strip().split()  # take off any outside whitespace, then split\n                                       # on whitespace\n    if not words:\n        return None  # if there aren't any words, just return nothing\n\n    verbs = [x for x in words if x.islower()]\n    verb = verbs[0]  # we want the '1st' one (python numbers from 0,1,2...)\n    verb_index = words.index(verb) # where is the verb?\n    subject = ' '.join(words[:verb_index])\n    obj =  ' '.join(words[(verb_index+1):])  # 'object' is already used in python\n    return (subject, obj, verb)\n\n\ndef graph_from_relationships(fh,color_dict):\n    '''\n    fh:  a filehandle, i.e., an opened file, from which we can read lines\n        and loop over\n    '''\n    G = networkx.DiGraph()\n\n    for line in fh:\n        if not line.strip():  continue # move on to the next line,\n                                         # if our line is empty-ish\n        (subj,obj,verb) = split_on_verb(line)\n        color = color_dict[verb]\n        # cf: python 'string templates', there are other solutions here\n        # this is the \n        print \"'%s' -&gt; '%s' [color='%s'];\" % (subj,obj,color)\n        G.add_edge(subj,obj,color)\n        # \n\n    return G\n\nG = graph_from_relationships(file('ex.txt'),rel_colors)\nprint G.edges()\n# from here you can use the various networkx plotting tools on G, as you're inclined.\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Python 2.5:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\nfrom collections import defaultdict\n\ncodes = defaultdict(lambda: (\"---\", \"Missing action!\"))\ncodes[\"likes\"] =    (\"--&gt;\", \"red\")\ncodes[\"dislikes\"] = (\"-/&gt;\", \"green\")\ncodes[\"loves\"] =    (\"==&gt;\", \"blue\")\n\nfor line in sys.stdin:\n    subject, verb, object_ = line.strip().split(\" \")\n    arrow, color = codes[verb]\n    print subject, arrow, object_, color, \";\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In addition to the question, Karasu also said (in a comment on one answer): \"In the actual input both subjects and objects vary unpredictably between one and two words."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Okay, here's how I would solve this."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n color_map = \\\n{\n    \"likes\" : \"red\",\n    \"dislikes\" : \"blue\",\n    \"knows\" : \"black\",\n}\n\ndef is_verb(word):\n    return word in color_map\n\ndef make_noun(lst):\n    if not lst:\n        return \"--NONE--\"\n    elif len(lst) == 1:\n        return lst[0]\n    else:\n        return \"_\".join(lst)\n\n\nfor line in open(\"filename\").readlines():\n    words = line.split()\n    # subject could be one or two words\n    if is_verb(words[1]):\n        # subject was one word\n        s = words[0]\n        v = words[1]\n        o = make_noun(words[2:])\n    else:\n        # subject was two words\n        assert is_verb(words[2])\n        s = make_noun(words[0:2])\n        v = words[2]\n        o = make_noun(words[3:])\n    color = color_map[v]\n    print \"%s -&gt; %s %s;\" % (s, o, color)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Some notes:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["0) We don't really need \"with\" for this problem, and writing it this way makes the program more portable to older versions of Python.", "This should work on Python 2.2 and newer, I think (I only tested on Python 2.6)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["1) You can change make_noun() to have whatever strategy you deem useful for handling multiple words.", "I showed just chaining them together with underscores, but you could have a dictionary with adjectives and throw those out, have a dictionary of nouns and choose those, or whatever."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["2) You could also use regular expressions for fuzzier matching.", "Instead of simply using a dictionary for color_map you could have a list of tuples, with a regular expression paired with the replacement color, and then when the regular expression matches, replace the color."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Here is an improved version of my previous answer.", "This one uses regular expression matching to make a fuzzy match on the verb.", "These all work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Steve loves Denise\nBears love honey\nMaria interested Anders\nMaria interests Anders\n</code>\n</pre>\n", "senID": 1}, {"text": ["The regular expression pattern \"loves?", "\" matches \"love\" plus an optional 's'.", "The pattern \"interest.", "*\" matches \"interest\" plus anything.", "Patterns with multiple alternatives separated by vertical bars match if any one of the alternatives matches."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nre_map = \\\n[\n    (\"likes?|loves?|interest.*\", \"red\"),\n    (\"dislikes?|hates?\", \"blue\"),\n    (\"knows?|tolerates?|ignores?\", \"black\"),\n]\n\n# compile the regular expressions one time, then use many times\npat_map = [(re.compile(s), color) for s, color in re_map]\n\n# We dont use is_verb() in this version, but here it is.\n# A word is a verb if any of the patterns match.\ndef is_verb(word):\n    return any(pat.match(word) for pat, color in pat_map)\n\n# Return color from matched verb, or None if no match.\n# This detects whether a word is a verb, and looks up the color, at the same time.\ndef color_from_verb(word):\n    for pat, color in pat_map:\n        if pat.match(word):\n            return color\n    return None\n\ndef make_noun(lst):\n    if not lst:\n        return \"--NONE--\"\n    elif len(lst) == 1:\n        return lst[0]\n    else:\n        return \"_\".join(lst)\n\n\nfor line in open(\"filename\"):\n    words = line.split()\n    # subject could be one or two words\n    color = color_from_verb(words[1])\n    if color:\n        # subject was one word\n        s = words[0]\n        o = make_noun(words[2:])\n    else:\n        # subject was two words\n        color = color_from_verb(words[1])\n        assert color\n        s = make_noun(words[0:2])\n        o = make_noun(words[3:])\n    print \"%s -&gt; %s %s;\" % (s, o, color)\n</code>\n</pre>\n", "senID": 3}, {"text": ["I hope it is clear how to take this answer and extend it.", "You can easily add more patterns to match more verbs.", "You could add logic to detect \"is\" and \"in\" and discard them, so that \"Anders is interested in Maria\" would match.", "And so on."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If you have any questions, I'd be happy to explain this further.", "Good luck."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]