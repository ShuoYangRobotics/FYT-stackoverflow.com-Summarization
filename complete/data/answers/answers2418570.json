[[{"text": ["The issue you're facing is that warnings.warn() calls warnings.showwarning(), which writes the result of warnings.formatwarning() to a file, defaulting to sys.stderr."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "warnings.warn()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "warnings.showwarning()", "childNum": 0, "tag": "code", "childList": []}, {"text": "warnings.formatwarning()", "childNum": 0, "tag": "code", "childList": []}, {"text": "sys.stderr", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["(See: http://docs.python.org/library/warnings.html#warnings.showwarning)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/warnings.html#warnings.showwarning", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/warnings.html#warnings.showwarning"}]}, {"text": ["If you're using Python 2.6, you can use the warnings.catch_warnings() context manager to easily modify how warnings are handled, including temporarily replacing the implementation of warnings.showwarning() to write to sys.stdout instead.", "That would be the Right Way to handle something like this."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "warnings.catch_warnings()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "warnings.showwarning()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sys.stdout", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["(See: http://docs.python.org/library/warnings.html#available-context-managers)"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://docs.python.org/library/warnings.html#available-context-managers", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/warnings.html#available-context-managers"}]}, {"text": ["If you want a quick and dirty hack, throw together a decorator that redirects sys.stderr to sys.stdout:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "sys.stderr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sys.stdout", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def stderr_to_stdout(func):\n    def wrapper(*args):\n        stderr_bak = sys.stderr\n        sys.stderr = sys.stdout\n        try:\n            return func(*args)\n        finally:\n            sys.stderr = stderr_bak\n    return wrapper\n</code>\n</pre>\n", "senID": 5}, {"text": ["Then you can call a decorated function in your doctest:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n from warnings import warn\nfrom utils import stderr_to_stdout\n\nclass Foo(object):\n    \"\"\"\n    Instantiating Foo always gives a warning:\n\n    &gt;&gt;&gt; @stderr_to_stdout\n    ... def make_me_a_foo():\n    ...     Foo()\n    ...\n    &gt;&gt;&gt; make_me_a_foo()\n    testdocs.py:18: UserWarning: \n      warn(\"Boo!\", UserWarning)\n    &gt;&gt;&gt;\n    \"\"\" \n    def __init__(self):\n        warn(\"Boo!\", UserWarning)\n</code>\n</pre>\n", "senID": 7}, {"text": ["Which passes:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n $ python -m doctest testdocs.py -v\nTrying:\n    @stderr_to_stdout\n    def make_me_a_foo():\n        Foo()\nExpecting nothing\nok\nTrying:\n    make_me_a_foo()\nExpecting:\n    testdocs.py:18: UserWarning: Boo!\n      warn(\"Boo!\", UserWarning)\nok\n[...]\n2 passed and 0 failed.\n</code>\n</pre>\n", "senID": 9}], [{"text": ["This isn't the most elegant way to do it, but it works for me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from warnings import warn\n\nclass Foo(object):\n    \"\"\"\n    Instantiating Foo always gives a warning:\n\n    &gt;&gt;&gt; import sys; sys.stderr = sys.stdout\n    &gt;&gt;&gt; foo = Foo() # doctest:+ELLIPSIS\n    /.../testdocs.py:14: UserWarning: Boo!\n      warn(\"Boo!\", UserWarning)\n    \"\"\"\n\n    def __init__(self):\n        warn(\"Boo!\", UserWarning)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()\n</code>\n</pre>\n", "senID": 1}, {"text": ["This presumably won't work on Windows, though, since the path reported in the UserWarning output must start with a slash the way I've written this test.", "You may be able to figure out some better incantation of the ELLIPSIS directive, but I could not."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The Testing Warnings sections of the Python documentation is dedicated to this topic.", "However, to summarize, you have two options:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Testing Warnings", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/warnings.html#testing-warnings"}]}, {"text": ["(A) Use the catch_warnings context manager"], "childNum": 1, "tag": "h2", "senID": 1, "childList": [{"text": "catch_warnings", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This is recommended course in the official documentation.", "However, the catch_warnings context manager only came into existence with Python 2.6."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "catch_warnings", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import warnings\n\ndef fxn():\n    warnings.warn(\"deprecated\", DeprecationWarning)\n\nwith warnings.catch_warnings(record=True) as w:\n    # Cause all warnings to always be triggered.\n    warnings.simplefilter(\"always\")\n    # Trigger a warning.\n    fxn()\n    # Verify some things\n    assert len(w) == 1\n    assert issubclass(w[-1].category, DeprecationWarning)\n    assert \"deprecated\" in str(w[-1].message)\n</code>\n</pre>\n", "senID": 3}, {"text": ["(B) Upgrade Warnings to Errors"], "childNum": 0, "tag": "h2", "senID": 4, "childList": []}, {"text": ["If the warning hasn't been seen before&mdash; and thus was registered in the warnings registry&mdash; then you can set warnings to raise exceptions and catch it."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import warnings\n\n\ndef fxn():\n    warnings.warn(\"deprecated\", DeprecationWarning)\n\n\nif __name__ == '__main__':\n    warnings.simplefilter(\"error\", DeprecationWarning)\n\n    try:\n        fxn()\n    except DeprecationWarning:\n        print \"Pass\"\n    else:\n        print \"Fail\"\n    finally:\n        warnings.simplefilter(\"default\", DeprecationWarning)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["docs suggest that you could pass-Wd when running doctest to always trigger warnings."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "pass-Wd", "tag": "a", "pos": 0, "childList": [{"text": "-Wd", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/warnings.html#the-warnings-filter"}, {"text": "-Wd", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Perhaps you could try mocking (patch print!", ") the troublesome bit.", "I admit this would add some clutter to the docstring but it might worth a go."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "mocking", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.voidspace.org.uk/python/mock/"}]}, {"text": ["If you wish to use that approach while retaining the current syntax, perhaps you could try implementing a custom wrapper for doctest that generates the missing code and then executes the fixed tests.", "If possible, that's probably best to be avoided though."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Alternatively you could just whip up a totally custom doctest runner but I suppose you would prefer to avoid this.", ":)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This is one example of why doctests are not appropriate for all tests.", "If you have inline examples in your docstrings and they need to be tested, that's one thing, but as you've discovered there are behaviors you want to test for that aren't best done with string matching.", "And cases where you don't need to have the docstring cluttered up with all the test mechanics."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]