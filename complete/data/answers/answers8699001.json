[[{"text": ["Using the decimal module, you can see the series also has a solution converging at 2000:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from decimal import Decimal, getcontext\ngetcontext().prec = 100\n\nu0=Decimal(3) / Decimal(2)\nu1=Decimal(5) / Decimal(3)\nu=[u0, u1]\nfor i in range(100):\n    un1 = 2003 - 6002/u[-1] + 4000/(u[-1]*u[-2])\n    u.append(un1)\n    print un1\n</code>\n</pre>\n", "senID": 1}, {"text": ["The recurrence relation has multiple fixed points (one at 2 and the other at 2000):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; u = [Decimal(2), Decimal(2)]\n&gt;&gt;&gt; 2003 - 6002/u[-1] + 4000/(u[-1]*u[-2])\nDecimal('2')\n\n&gt;&gt;&gt; u = [Decimal(2000), Decimal(2000)]\n&gt;&gt;&gt; 2003 - 6002/u[-1] + 4000/(u[-1]*u[-2])\nDecimal('2000.000')\n</code>\n</pre>\n", "senID": 3}, {"text": ["The solution at 2 is an unstable fixed-point.", "The attractive fixed-point is at 2000."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "attractive fixed-point", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Fixed_point_%28mathematics%29#Attractive_fixed_points"}]}, {"text": ["The convergence gets very close to two and when the round-off causes the value to slightly exceed two, that difference gets amplified again and again until hitting 2000."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Your (non-linear) recurrence sequence has three fixed points: 1, 2 and 2000.", "The values 1 and 2 are close to each other compared to 2000, which is usually an indication of unstable fixed points because they are \"almost\" double roots."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "2", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "2000", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You need to do some maths in order to diverge less early.", "Let v(n) be a side sequence:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "v(n)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n v(n) = (1+2^n)u(n)\n</code>\n</pre>\n", "senID": 2}, {"text": ["The following holds true:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n v(n+1) = (1+2^(n+1)) * (2003v(n)v(n-1) - 6002(1+2^n)v(n-1) + 4000(1+2^n)(1+2^n-1)) / (v(n)v(n-1))\n</code>\n</pre>\n", "senID": 4}, {"text": ["You can then simply compute v(n) and deduce u(n) from u(n) = v(n)/(1+2^n):"], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "v(n)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "u(n)", "childNum": 0, "tag": "code", "childList": []}, {"text": "u(n) = v(n)/(1+2^n)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nfrom mpmath import *\nmp.dps = 50\nv0 = mpf(3)\nv1 = mpf(5)\nv=[]\nv.append(v0)\nv.append(v1)\n\nu=[]\nu.append(v[0]/2)\nu.append(v[1]/3)\n\nfor i in range (2,25):\n    vn1 = (1+2**i) * (2003*v[i-1]*v[i-2] \\\n                     - 6002*(1+2**(i-1))*v[i-2] \\\n                     + 4000*(1+2**(i-1))*(1+2**(i-2))) \\\n                   / (v[i-1]*v[i-2])\n    v.append(vn1)\n    u.append(vn1/(1+2**i))\n\nprint u\n</code>\n</pre>\n", "senID": 6}, {"text": ["And the result:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n [mpf('1.5'),\nmpf('1.6666666666666666666666666666666666666666666666666676'),\nmpf('1.8000000000000000000000000000000000000000000000000005'),\nmpf('1.8888888888888888888888888888888888888888888888888892'),\nmpf('1.9411764705882352941176470588235294117647058823529413'),\nmpf('1.969696969696969696969696969696969696969696969696969'),\nmpf('1.9846153846153846153846153846153846153846153846153847'),\nmpf('1.992248062015503875968992248062015503875968992248062'),\nmpf('1.9961089494163424124513618677042801556420233463035019'),\nmpf('1.9980506822612085769980506822612085769980506822612089'),\nmpf('1.9990243902439024390243902439024390243902439024390251'),\nmpf('1.9995119570522205954123962908735968765251342118106393'),\nmpf('1.99975591896509641200878691725652916768367097876495'),\nmpf('1.9998779445868424264616135725619431221774685707311133'),\nmpf('1.9999389685688129386634116570033567287152883735123589'),\nmpf('1.9999694833531691537733833806341359211449845890933504'),\nmpf('1.9999847414437645909944001098616048949448403192089965'),\nmpf('1.9999923706636759668276456631037666033431751771913355'),\n...\n</code>\n</pre>\n", "senID": 8}, {"text": ["Note that this will still diverge eventually.", "In order to really converge, you need to compute v(n) with arbitrary precision.", "But this is now a lot easier since all the values are integers."], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "still diverge eventually", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "v(n)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "integers", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}], [{"text": ["You calculate your initial values to 53-bits of precision and then assign that rounded value to the high-precision mpf variable.", "You should use u0=mpf(3)/mpf(2) and u1=mpf(5)/mpf(3).", "You'll stay close to 2 for a few more interations, but you'll still end up converging at 2000.", "This is due to rounding error.", "One alternative is to compute with fractions.", "I used gmpy and the following code converges to 2."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "gmpy", "tag": "a", "pos": 5, "childList": [], "childNum": 0, "href": "http://code.google.com/p/gmpy/"}]}, {"code": "<pre>\n<code>\n from __future__ import print_function\nimport gmpy\n\nu = [gmpy.mpq(3,2), gmpy.mpq(5,3)]\nfor i in range(2,300):\n    temp = (2003 - 6002/u[-1] + 4000/(u[-1]*u[-2]))\n    u.append(temp)\n\nfor i in u: print(gmpy.mpf(i,300))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you compute with infinite precision then you get 2 otherwise you get 2000:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "2", "tag": "a", "pos": 0, "childList": [{"text": "2", "tag": "code"}], "childNum": 1, "href": "http://ideone.com/7D8zj"}, {"text": "2", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://ideone.com/mSzEM", "text": "2000", "childNum": 1, "tag": "a", "childList": [{"text": "2000", "tag": "code"}]}, {"text": "2000", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\nfrom fractions import Fraction\n\ndef series(u0=Fraction(3, 2), u1=Fraction(5, 3)):\n    yield u0\n    yield u1\n    while u0 != u1:\n        un = 2003 - 6002/u1 + 4000/(u1*u0)\n        yield un\n        u1, u0 = un, u1\n\nfor i, u in enumerate(itertools.islice(series(), 100)):\n    err = (2-u)/2 # relative error\n    print(\"%d\\t%.2g\" % (i, err))\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n<code>\n 0   0.25\n1   0.17\n2   0.1\n3   0.056\n4   0.029\n5   0.015\n6   0.0077\n7   0.0039\n8   0.0019\n9   0.00097\n10  0.00049\n11  0.00024\n12  0.00012\n13  6.1e-05\n14  3.1e-05\n15  1.5e-05\n16  7.6e-06\n17  3.8e-06\n18  1.9e-06\n19  9.5e-07\n20  4.8e-07\n21  2.4e-07\n22  1.2e-07\n23  6e-08\n24  3e-08\n25  1.5e-08\n26  7.5e-09\n27  3.7e-09\n28  1.9e-09\n29  9.3e-10\n30  4.7e-10\n31  2.3e-10\n32  1.2e-10\n33  5.8e-11\n34  2.9e-11\n35  1.5e-11\n36  7.3e-12\n37  3.6e-12\n38  1.8e-12\n39  9.1e-13\n40  4.5e-13\n41  2.3e-13\n42  1.1e-13\n43  5.7e-14\n44  2.8e-14\n45  1.4e-14\n46  7.1e-15\n47  3.6e-15\n48  1.8e-15\n49  8.9e-16\n50  4.4e-16\n51  2.2e-16\n52  1.1e-16\n53  5.6e-17\n54  2.8e-17\n55  1.4e-17\n56  6.9e-18\n57  3.5e-18\n58  1.7e-18\n59  8.7e-19\n60  4.3e-19\n61  2.2e-19\n62  1.1e-19\n63  5.4e-20\n64  2.7e-20\n65  1.4e-20\n66  6.8e-21\n67  3.4e-21\n68  1.7e-21\n69  8.5e-22\n70  4.2e-22\n71  2.1e-22\n72  1.1e-22\n73  5.3e-23\n74  2.6e-23\n75  1.3e-23\n76  6.6e-24\n77  3.3e-24\n78  1.7e-24\n79  8.3e-25\n80  4.1e-25\n81  2.1e-25\n82  1e-25\n83  5.2e-26\n84  2.6e-26\n85  1.3e-26\n86  6.5e-27\n87  3.2e-27\n88  1.6e-27\n89  8.1e-28\n90  4e-28\n91  2e-28\n92  1e-28\n93  5e-29\n94  2.5e-29\n95  1.3e-29\n96  6.3e-30\n97  3.2e-30\n98  1.6e-30\n99  7.9e-31\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Well, as casevh said, I just added the mpf function in first initials terms in my code :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["u0=mpf(3)/mpf(2)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["u1=mpf(5)/mpf(3)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["and the value converge for 16 steps to the correct value 2.0 before diverged again (see below)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["So, even with a good python library for arbitrary-precision floating-point arithmetic and some basics operations  the result can become totally false and it is not algorithmic, mathematical or recurrence problem as I read sometimes."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["So it is necessary to remain watchful and critic  !!!", "( I\u2019m very afraid about the mpmath.lerchphi(z, s, a) function ;-)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["The exact solution to your recurrence relation (with initial values u_0 = 3/2, u_1 = 5/3) is easily verified to be"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n u_n = (2^(n+1) + 1) / (2^n + 1).    (*)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The problem you're seeing is that although the solution is such that"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n lim_{n -&gt; oo} u_n = 2,\n</code>\n</pre>\n", "senID": 3}, {"text": ["this limit is a repelling fixed point of your recurrence relation.", "That is, any departure from the correct values of u_{n-1}, u{n-2}, for some n, will result in further values diverging from the correct limit.", "Consequently, unless your implementation of the recurrence relation correctly represents every u_n value exactly, it can be expected to exhibit eventual divergence from the correct limit, converging to the incorrect value of 2000 that just happens to be the only attracting fixed point of your recurrence relation.", "(*) In fact, u_n = (2^(n+1) + 1) / (2^n + 1) is the solution to any recurrence relation of the form "], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "repelling", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "any", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "exactly", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "", "childNum": 0, "tag": "hr", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n u_n = C + (7 - 3C)/u_{n-1} + (2C - 6)/(u_{n-1} u_{n-2})\n</code>\n</pre>\n", "senID": 5}, {"text": ["with the same initial values as given above, where C is an arbitrary constant.", "If I haven't made a mistake finding the roots of the characteristic polynomial, this will have the set of fixed points {1, 2, C - 3}\\{0}.", "The limit 2 can be either a repelling fixed point or an attracting fixed point, depending on the value of C.", "E.g., for C = 2003 the set of fixed points is {1, 2, 2000} with 2 being a repellor, whereas for C = 3 the fixed points are {1, 2} with 2 being an attractor."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]