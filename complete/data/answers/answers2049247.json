[[{"text": ["AFAIK no.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["And the reason is that for such an atomic operation to be possible, there has to be OS support in the form of a transactional file system.", "And none of the mainstream operating system offer a transactional file system."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["EDIT - I'm wrong for POSIX-compliant systems at least.", "The POSIX rename syscall performs an atomic replace if a file with the target name already exists ... as pointed out by @janneb.", "That should be sufficient to do the OP's operation atomically."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "rename", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["However, the fact remains that the Java File.renameTo() method is explicitly not guaranteed to be atomic, so it does not provide a cross-platform solution to the OP's problem."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "File.renameTo()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["At least on POSIX platforms, leave out step 3 (delete old file).", "In POSIX, rename within a filesystem is guaranteed to be atomic, and renaming on top of an existing file replaces it atomically."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["It's a classic producer/consumer problem.", "You should be able to solve this by using file renaming, which is atomic on POSIX systems."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Try Java FileLock API"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Java FileLock API", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://java.sun.com/javase/6/docs/api/java/nio/channels/FileLock.html"}]}], [{"text": ["You could try and use an extra file to act as a lock, but I'm not sure if that will work out ok. (It would force you to create lock-checking and retry logic at both sides, java and python)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Another solution might be to not create files at all, maybe you could make your java process listen on a port and serve data from there rather than from a file?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Have the python scripts request permission from the service.", "While the service is writing it would place a lock on the file.", "If the lock exists, the service would reject the python request."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In Linux, Solaris, Unix this is easy.", "Just use rename() from your program or mv.", "The files need to be on the same filesystem."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "rename", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "mv", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["On Windows, this is possible if you can control both programs.", "LockFileEx.", "For reads, open a shared lock on the lockfile.", "For writes, open an exclusive lock on the lockfile.", "Locking is weird in Windows, so I recommend using a separate lock file for this."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "LockFileEx", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "shared lock", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "exclusive lock", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "lock file", "childNum": 0, "tag": "em", "pos": 4, "childList": []}]}]]