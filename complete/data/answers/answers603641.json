[[{"text": ["You're breaking the definition of a generator, which should throw a StopIteration exception when iteration is complete (which is automatically handled by a return statement in a generator function)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def iterate(i):\n    for value in i:\n        yield value\n    return\n</code>\n</pre>\n", "senID": 2}, {"text": ["Best to let the calling code handle the case of an empty iterator:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n count = 0\nfor value in iterate(range([])):\n    print value\n    count += 1\nelse:\n    if count == 0:\n        print \"list was empty\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["Might be a cleaner way of doing the above, but that ought to work fine, and doesn't fall into any of the common 'treating an iterator like a list' traps below."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["There are a couple ways of doing this.", "You could always use the Iterator directly:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Iterator", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def iterate(i):\n    try:\n        i_iter = iter(i)\n        next = i_iter.next()\n    except StopIteration:\n        print 'i is empty'\n        return\n\n    while True:\n        yield next\n        next = i_iter.next()\n</code>\n</pre>\n", "senID": 1}, {"text": ["But if you know more about what to expect from the argument i, you can be more concise:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "i", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def iterate(i):\n    if i:  # or if len(i) == 0\n        for next in i:\n            yield next\n    else:\n        print 'i is empty'\n        raise StopIteration()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Summing up some of the earlier answers, it could be solved like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def iterate(i):\n    empty = True\n    for value in i:\n        yield value\n        empty = False\n\n    if empty:\n        print \"empty\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["so there really is no \"else\" clause involved."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As you note, for..else only detects a break.", "So it's only applicable when you look for something and then stop."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "for..else", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "break", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "stop", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["It's not applicable to your purpose not because it's a generator, but because you want to process all elements, without stopping (because you want to yield them all, but that's not the point)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "because you want to process all elements, without stopping", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["So generator or not, you really need a boolean, as in Ber's solution."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Maximum i can think of:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n >>> empty = True\n>>> for i in [1,2]:\n...     empty = False\n... if empty:\n...     print 'empty'\n...\n>>>\n>>>\n>>> empty = True\n>>> for i in []:\n...     empty = False\n... if empty:\n...    print 'empty'\n...\nempty\n>>>\n</code>\n</pre>\n", "senID": 1}], [{"text": ["What about simple if-else?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def iterate(i):\n    if len(i) == 0: print 'i is empty'\n    else:\n        for value in i:\n            yield value\n</code>\n</pre>\n", "senID": 1}]]