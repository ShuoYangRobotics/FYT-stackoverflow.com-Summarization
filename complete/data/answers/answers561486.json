[[{"text": ["This answer is similar in spirit to Douglas Leeder's, with the following changes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "It doesn't use actual Base64, so there's no padding characters", "tag": "none", "senID": 1}, {"text": ["Instead of converting the number first to a byte-string (base 256), it converts it directly to base 64, which has the advantage of letting you represent negative numbers using a sign character."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; num_encode(0)\n    'A'\n    &gt;&gt;&gt; num_encode(64)\n    'BA'\n    &gt;&gt;&gt; num_encode(-(64**5-1))\n    '$_____'\n</code>\n</pre>\n", "senID": 3}, {"text": ["A few side notes:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "You could (", "tag": "none", "senID": 5}, {"text": "If you're encoding a lot of negative numbers, you could increase the efficiency by using a sign bit or one's/two's complement instead of a sign character.", "tag": "none", "senID": 6}, {"text": "You should be able to easily adapt this code to different bases by changing the alphabet, either to restrict it to only alphanumeric characters or to add additional \"URL-safe\" characters.", "tag": "none", "senID": 7}, {"text": "I would recommend ", "tag": "none", "senID": 8}]}], [{"text": ["You probably do not want real base64 encoding for this - it will add padding etc, potentially even resulting in larger strings than hex would for small numbers.", "If there's no need to interoperate with anything else, just use your own encoding.", "Eg.", "here's a function that will encode to any base (note the digits are actually stored least-significant first to avoid extra reverse() calls:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def make_encoder(baseString):\n    size = len(baseString)\n    d = dict((ch, i) for (i, ch) in enumerate(baseString)) # Map from char -&gt; value\n    if len(d) != size:\n        raise Exception(\"Duplicate characters in encoding string\")\n\n    def encode(x):\n        if x==0: return baseString[0]  # Only needed if don't want '' for 0\n        l=[]\n        while x&gt;0:\n            l.append(baseString[x % size])\n            x //= size\n        return ''.join(l)\n\n    def decode(s):\n        return sum(d[ch] * size**i for (i,ch) in enumerate(s))\n\n    return encode, decode\n\n# Base 64 version:\nencode,decode = make_encoder(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")\n\nassert decode(encode(435346456456)) == 435346456456\n</code>\n</pre>\n", "senID": 1}, {"text": ["This has the advantage that you can use whatever base you want, just by adding appropriate\ncharacters to the encoder's base string."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note that the gains for larger bases are not going to be that big however.", "base 64 will only reduce the size to 2/3rds of base 16 (6 bits/char instead of 4).", "Each doubling only adds one more bit per character.", "Unless you've a real need to compact things, just using hex will probably be the simplest and fastest option."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You don't want base64 encoding, you want to represent a base 10 numeral in numeral base X."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want your base 10 numeral represented in the 26 letters available you could use:  http://en.wikipedia.org/wiki/Hexavigesimal.", "(You can extend that example for a much larger base by using all the legal url characters)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://en.wikipedia.org/wiki/Hexavigesimal", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Hexavigesimal"}]}, {"text": ["You should atleast be able to get base 38 (26 letters, 10 numbers, +, _)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The easy bit is converting the byte string to web-safe base64:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import base64\noutput = base64.urlsafe_b64encode(s)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The tricky bit is the first step - convert the integer to a byte string."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If your integers are small you're better off hex encoding them - see saua"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "saua", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/561486/how-do-you-base64-encode-an-integer-in-python/561534#561534"}]}, {"text": ["Otherwise (hacky recursive version):"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def convertIntToByteString(i):\n    if i == 0:\n        return \"\"\n    else:\n        return convertIntToByteString(i &gt;&gt; 8) + chr(i &amp; 255)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["To encode n:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n data = ''\nwhile n &gt; 0:\n    data = chr(n &amp; 255) + data\n    n = n &gt;&gt; 8\nencoded = base64.urlsafe_b64encode(data).rstrip('=')\n</code>\n</pre>\n", "senID": 1}, {"text": ["To decode s:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n data = base64.urlsafe_b64decode(s + '===')\ndecoded = 0\nwhile len(data) &gt; 0:\n    decoded = (decoded &lt;&lt; 8) | ord(data[0])\n    data = data[1:]\n</code>\n</pre>\n", "senID": 3}, {"text": ["In the same spirit as other for some \u201coptimal\u201d encoding, you can use 73 characters according to RFC 1738 (actually 74 if you count \u201c+\u201d as usable):"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "73", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_`\\\"!$'()*,-.\"\nencoded = ''\nwhile n &gt; 0:\n    n, r = divmod(n, len(alphabet))\n    encoded = alphabet[r] + encoded\n</code>\n</pre>\n", "senID": 5}, {"text": ["and the decoding:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n decoded = 0\nwhile len(s) &gt; 0:\n    decoded = decoded * len(alphabet) + alphabet.find(s[0])\n    s = s[1:]\n</code>\n</pre>\n", "senID": 7}], [{"text": ["a little hacky, but it works:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def b64num(num_to_encode):\n  h = hex(num_to_encode)[2:]     # hex(n) returns 0xhh, strip off the 0x\n  h = len(h) &amp; 1 and '0'+h or h  # if odd number of digits, prepend '0' which hex codec requires\n  return h.decode('hex').encode('base64')\n</code>\n</pre>\n", "senID": 1}, {"text": ["you could replace the call to .encode('base64') with something in the base64 module, such as  urlsafe_b64encode()"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I maintain a little library named zbase62: http://pypi.python.org/pypi/zbase62"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://pypi.python.org/pypi/zbase62", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/zbase62"}]}, {"text": ["With it you can convert from a Python 2 str object to a base-62 encoded string and vice versa:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n Python 2.7.1+ (r271:86832, Apr 11 2011, 18:13:53) \n[GCC 4.5.2] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; d = os.urandom(32)\n&gt;&gt;&gt; d\n'C$\\x8f\\xf9\\x92NV\\x97\\x13H\\xc7F\\x0c\\x0f\\x8d9}\\xf5.u\\xeeOr\\xc2V\\x92f\\x1b=:\\xc3\\xbc'\n&gt;&gt;&gt; from zbase62 import zbase62\n&gt;&gt;&gt; encoded = zbase62.b2a(d)\n&gt;&gt;&gt; encoded\n'Fv8kTvGhIrJvqQ2oTojUGlaVIxFE1b6BCLpH8JfYNRs'\n&gt;&gt;&gt; zbase62.a2b(encoded)\n'C$\\x8f\\xf9\\x92NV\\x97\\x13H\\xc7F\\x0c\\x0f\\x8d9}\\xf5.u\\xeeOr\\xc2V\\x92f\\x1b=:\\xc3\\xbc'\n</code>\n</pre>\n", "senID": 2}, {"text": ["However, you still need to convert from integer to str.", "This comes built-in to Python 3:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n Python 3.2 (r32:88445, Mar 25 2011, 19:56:22)\n[GCC 4.5.2] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; d = os.urandom(32)\n&gt;&gt;&gt; d\nb'\\xe4\\x0b\\x94|\\xb6o\\x08\\xe9oR\\x1f\\xaa\\xa8\\xe8qS3\\x86\\x82\\t\\x15\\xf2\"\\x1dL%?\\xda\\xcc3\\xe3\\xba'\n&gt;&gt;&gt; int.from_bytes(d, 'big')\n103147789615402524662804907510279354159900773934860106838120923694590497907642\n&gt;&gt;&gt; x= _ \n&gt;&gt;&gt; x.to_bytes(32, 'big')\nb'\\xe4\\x0b\\x94|\\xb6o\\x08\\xe9oR\\x1f\\xaa\\xa8\\xe8qS3\\x86\\x82\\t\\x15\\xf2\"\\x1dL%?\\xda\\xcc3\\xe3\\xba'\n</code>\n</pre>\n", "senID": 4}, {"text": ["To convert from int to bytes and vice versa in Python 2, there is not a convenient, standard way as far as I know.", "I guess maybe I should copy some implementation, such as this one: https://github.com/warner/foolscap/blob/46e3a041167950fa93e48f65dcf106a576ed110e/foolscap/banana.py#L41 into zbase62 for your convenience."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "https://github.com/warner/foolscap/blob/46e3a041167950fa93e48f65dcf106a576ed110e/foolscap/banana.py#L41", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "https://github.com/warner/foolscap/blob/46e3a041167950fa93e48f65dcf106a576ed110e/foolscap/banana.py#L41"}]}], [{"text": ["Base64 takes 4 bytes/characters to encode 3 bytes and can only encode multiples of 3 bytes (and adds padding otherwise)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So representing 4 bytes (your average int) in Base64 would take 8 bytes.", "Encoding the same 4 bytes in hex would also take 8 bytes.", "So you wouldn't gain anything for a single int."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I'd go the 'encode integer as binary string, then base64 encode that' method you suggest, and I'd do it using struct:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import struct, base64\n&gt;&gt;&gt; base64.b64encode(struct.pack('l', 47))\n'LwAAAA=='\n&gt;&gt;&gt; struct.unpack('l', base64.b64decode(_))\n(47,)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit again:\nTo strip out the extra 0s on numbers that are too small to need full 32-bit precision, try this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def pad(str, l=4):\n    while len(str) &lt; l:\n        str = '\\x00' + str\n    return str\n\n&gt;&gt;&gt; base64.b64encode(struct.pack('!l', 47).replace('\\x00', ''))\n'Lw=='\n&gt;&gt;&gt; struct.unpack('!l', pad(base64.b64decode('Lw==')))\n(47,)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If you are looking for a way to shorten the integer representation using base64, I think you need to look elsewhere.", "When you encode something with base64 it doesn't get shorter, in fact it gets longer. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "shorten", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["E.g.", "11234 encoded with base64 would yield MTEyMzQ="], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["When using base64 you have overlooked the fact that you are not converting just the digits (0-9) to a 64 character encoding.", "You are converting 3 bytes into 4 bytes so you are guaranteed your base64 encoded string would be 33.33% longer."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I needed a signed integer, so I ended up going with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import struct, base64\n\ndef b64encode_integer(i):\n   return base64.urlsafe_b64encode(struct.pack('i', i)).rstrip('=\\n')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; b64encode_integer(1)\n'AQAAAA'\n&gt;&gt;&gt; b64encode_integer(-1)\n'_____w'\n&gt;&gt;&gt; b64encode_integer(256)\n'AAEAAA'\n</code>\n</pre>\n", "senID": 3}]]