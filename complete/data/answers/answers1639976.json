[[{"text": ["here is main algorithm"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n iProduct = 1\nfor iFactor in xrange(1, i+1):\n    iProduct *= iFactor\n</code>\n</pre>\n", "senID": 1}, {"text": ["other code is for caching results."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Even without knowing Python, it must be clear to you that the two functions are far from identical.", "The C# version is calculating the factorial via recursion, whereas the Python one is doing it via iteration (although in a slightly weird way, with some odd memoization/caching going on - I guess in case you want to calculate multiple factorials in the lifetime of a program)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Anyway, since calculating a factorial is a very simple algorithm, it works out the same in both cases. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["IANAPG (Python Guru), but it looks to me like the function is creating a static array of 1000 entries, then filling them on an as-needed basis to prevent recalculation.", "In C++, it'd be something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n long factorial(int i){\n    //Cache array\n    static long factorials[1000];\n    if (!factorials[i]){ //If not cached, calculate &amp; store\n        int product = 1;\n        for (int idx = 1; idx &lt;= i + 1; ++idx){\n            product *= idx;\n        }\n        factorials[i] = product;\n    }\n    return factorials[i]; //Return cached value\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["it will return the same results, but the Python version will probably have better performance, because it memoizes the results"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["It just attaches an attribute called lstFactorial to factorial.", "This attribute is a list of 1000 values used to cache the results of previous calls."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "lstFactorial", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "factorial", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"senID": 0}, {"code": "<pre>\n<code>\n def factorial(i):\n    if not hasattr(factorial, 'lstFactorial'): #program checks whether caching list exists\n        factorial.lstFactorial = [None] * 1000 #if so, it creates a list of thousand None elements (it is more or less equivalent to C/C++'s NULL\n    if factorial.lstFactorial[i] is None: #prog checks if that factorial has been already calculated\n        iProduct = 1 #set result to 1\n        for iFactor in xrange(1, i+1): # C's for(iFactor = 1; iFactor &amp;lt;= i+1; iFactor++)\n            iProduct *= iFactor #we multiply result times current loop counter\n        factorial.lstFactorial[i] = iProduct #and put result in caching list\n    return factorial.lstFactorial[i] #after all, we return the result, calculated jest now or obtained from cache\n</code>\n</pre>\n", "senID": 1}, {"text": ["To be honest, it is not the best algorithm, since it uses cache only partially."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The simple, user-friendly factorial function (no caching) would be:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n def factorial(i):\n    if i == 0 or i == 1:\n        return 1\n    return i*factorial(i-1)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Of for lazy python programmers, most similiar to that C# example:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n f = lambda i: i and i*f(i-1) or 1\n</code>\n</pre>\n", "senID": 6}]]