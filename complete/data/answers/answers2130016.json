[[{"text": ["Changing the code to yield n chunks rather than chunks of n:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def chunks(l, n):\n    \"\"\" Yield n successive chunks from l.\n    \"\"\"\n    newn = int(len(l) / n)\n    for i in xrange(0, n-1):\n        yield l[i*newn:i*newn+newn]\n    yield l[n*newn-newn:]\n\nl = range(56)\nthree_chunks = chunks (l, 3)\nprint three_chunks.next()\nprint three_chunks.next()\nprint three_chunks.next()\n</code>\n</pre>\n", "senID": 1}, {"text": ["which gives:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n[18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]\n[36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55]\n</code>\n</pre>\n", "senID": 3}, {"text": ["This will assign the extra elements to the final group which is not perfect but well within your specification of \"roughly N equal parts\" :-) By that, I mean 56 elements would be better as (19,19,18) whereas this gives (18,18,20)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You can get the more balanced output with the following code:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\ndef chunks(l, n):\n    \"\"\" Yield n successive chunks from l.\n    \"\"\"\n    newn = int(1.0 * len(l) / n + 0.5)\n    for i in xrange(0, n-1):\n        yield l[i*newn:i*newn+newn]\n    yield l[n*newn-newn:]\n\nl = range(56)\nthree_chunks = chunks (l, 3)\nprint three_chunks.next()\nprint three_chunks.next()\nprint three_chunks.next()\n</code>\n</pre>\n", "senID": 6}, {"text": ["which outputs:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n[19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37]\n[38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55]\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Here is one that adds None to make the lists equal length"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import izip_longest\n&gt;&gt;&gt; def chunks(l, n):\n    \"\"\" Yield n successive chunks from l. Pads extra spaces with None\n    \"\"\"\n    return list(zip(*izip_longest(*[iter(l)]*n)))\n\n&gt;&gt;&gt; l=range(54)\n\n&gt;&gt;&gt; chunks(l,3)\n[(0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51), (1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52), (2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 41, 44, 47, 50, 53)]\n\n&gt;&gt;&gt; chunks(l,4)\n[(0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52), (1, 5, 9, 13, 17, 21, 25, 29, 33, 37, 41, 45, 49, 53), (2, 6, 10, 14, 18, 22, 26, 30, 34, 38, 42, 46, 50, None), (3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, None)]\n\n&gt;&gt;&gt; chunks(l,5)\n[(0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50), (1, 6, 11, 16, 21, 26, 31, 36, 41, 46, 51), (2, 7, 12, 17, 22, 27, 32, 37, 42, 47, 52), (3, 8, 13, 18, 23, 28, 33, 38, 43, 48, 53), (4, 9, 14, 19, 24, 29, 34, 39, 44, 49, None)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Have a look at numpy.split:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy.split", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/numpy/reference/generated/numpy.split.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = numpy.array([1,2,3,4])\n&gt;&gt;&gt; numpy.split(a, 2)\n[array([1, 2]), array([3, 4])]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Uses grouper():"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "grouper()", "tag": "a", "pos": 0, "childList": [{"text": "grouper()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#recipes"}, {"text": "grouper()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def chunks(seq, num):\n  return grouper(int(math.ceil(len(seq) / float(num))), seq)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's one that could work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def chunkIt(seq, num):\n  avg = len(seq) / float(num)\n  out = []\n  last = 0.0\n\n  while last &lt; len(seq):\n    out.append(seq[int(last):int(last + avg)])\n    last += avg\n\n  return out\n</code>\n</pre>\n", "senID": 1}, {"text": ["Testing:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; chunkIt(range(10), 3)\n[[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]\n&gt;&gt;&gt; chunkIt(range(11), 3)\n[[0, 1, 2], [3, 4, 5, 6], [7, 8, 9, 10]]\n&gt;&gt;&gt; chunkIt(range(12), 3)\n[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You can write it fairly simply as a list generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def split(a, n):\n    k, m = len(a) / n, len(a) % n\n    return (a[i * k + min(i, m):(i + 1) * k + min(i + 1, m)] for i in xrange(n))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(split(range(11), 3))\n[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10]]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["As long as you don't want anything silly like continuous chunks:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def chunkify(lst,n):\n...     return [ lst[i::n] for i in xrange(n) ]\n... \n&gt;&gt;&gt; chunkify( range(13), 3)\n[[0, 3, 6, 9, 12], [1, 4, 7, 10], [2, 5, 8, 11]]\n</code>\n</pre>\n", "senID": 1}]]