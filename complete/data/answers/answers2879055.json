[[{"text": ["Keeping things simple, this is O(N) complexity and should be sufficient if you don't have GBs of word data.", "Note that set() and dict() basically is a hashed index (free and builtin!", ")."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "set()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "dict()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n index = {}\nfor word, s_word in words:\n    index[s_word] = index.get(s_word, []) + [word]\n\nfor similar_words in index.values():\n    print ' '.join(similar_words)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Don't know what you are using it for, but it might be of interest to you that in python 2.7 a Counter class was introduced in the collections module."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Counter", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "Counter", "tag": "a"}]}, {"href": "http://docs.python.org/dev/library/collections.html#collections.Counter", "text": "Counter", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["If you really want to keep your algorithm and update a boolean list (which you don't because that algorithm would do inefficient double loops), you would do it like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n checked = [False] * len(words)\nfor i, (word, word_s) in enumerate(words):\n    if checked[i]:\n       continue\n    for j, (other, other_s) in enumerate(words[i:]):\n        if word_s == other_s:\n            print other,\n            checked[i+j] = True\n    print\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I generally like catchmeifyoutry's answer, but I would personally tighten it up a bit further as"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for word in set(words):\n    print word\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit:  My answer is a shorter but functionally equivalent form of catchmeifyoutry's original, pre-edited answer."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Edit:  My answer is a shorter but functionally equivalent form of catchmeifyoutry's original, pre-edited answer.", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "Edit", "tag": "strong"}]}, {"text": "Edit", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["I think the word you're looking for is Pythonic, here's a pythonic code sample for what you're tying to do, determine words that are equivalent, where equivalence is determined by having the same set of letters "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import collections\n\ndef print_equivalent_words(words):\n    eq_words = defaultdict(list)\n    for word in words:\n        eq_words[\"\".join(sorted(set(word)))].append(word)\n\n    for k,v in eq_words.items():\n        print(v)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is not the best algorithm to solve this problem (it's O(N^2) instead of O(N)), but here's a pythonic version of it.", "The method I've used is to replace your array of bits with a set that contains words you've already seen."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n checked = set()\nfor i, word in enumerate(words):\n    if word in checked:\n        continue\n    to_output = [word]\n    for word2 in words[i + 1:]:\n        if equivalentWords(word, word2):\n            to_output.append(word2)\n            checked.add(word2)\n    print ' '.join(to_output)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Make words a list of objects:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "words", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Word(object):\n  def __init__(self, word, s_word, checked=False):\n    self.word = word\n    self.s_word = s_word\n    self.checked = checked\n\n ....\n    for word1 in words:\n      if word1.s_word == word.s_word:\n        word1.checked = True\n        print word1.word\n    print\n</code>\n</pre>\n", "senID": 1}], [{"text": ["First lesson, it's \"Pythonic\" or \"Pythonically\"  :-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Based on the comment:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n // determines which words in a vector consist of the same letters\n// outputs the words with the same letters on the same line\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm not quite sure that the original code works, and even if it does, I can't say I like it much.", "First of all, based on the loop nesting, it looks like the complexity is O(N2).", "Second, I can't figure out what it's doing well enough to be sure it really does what's stated above (it uses a three-parameter overload of equivalentWords, which seems to be missing, which makes it hard to say though)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "2", "childNum": 0, "tag": "sup", "pos": 1, "childList": []}, {"text": "equivalentWords", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Some of the Python solutions are a lot shorter and simpler -- to the point that I feel reasonably certain they simply don't work.", "A couple seem to simply print out unique words, which (at least as I interpret it) is not the intent at all."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Here's a version in C++ that does what I interpret the requirements to be:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;string&gt;\n#include &lt;set&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nstd::string \nsort_word(std::string word) { \n    std::sort(word.begin(), word.end());\n    return word;\n}\n\nnamespace std { \n    std::ostream &amp;\n    operator&lt;&lt;(std::ostream &amp;os, \n               std::pair&lt;std::string, std::set&lt;std::string&gt; &gt;const &amp;words) \n    { \n        std::copy(words.second.begin(), words.second.end(), \n            std::ostream_iterator&lt;std::string&gt;(os, \"\\t\"));\n        return os;\n    }\n}\n\nvoid \nequivalentWords(std::vector&lt;std::string&gt; const &amp;words, std::ostream &amp;os) { \n    typedef std::map&lt;std::string, std::set&lt;std::string&gt; &gt; word_list_t;\n    word_list_t word_list;\n\n    for (int i=0; i&lt;words.size(); i++)\n        word_list[sort_word(words[i])].insert(words[i]);\n\n    std::copy(word_list.begin(), word_list.end(),\n              std::ostream_iterator&lt;word_list_t::value_type&gt;(os, \"\\n\"));\n}\n\nint \nmain() { \n    std::vector&lt;std::string&gt; input;\n\n    std::copy(std::istream_iterator&lt;std::string&gt;(std::cin),\n        std::istream_iterator&lt;std::string&gt;(),\n        std::back_inserter(input));\n    equivalentWords(input, std::cout);\n    return 0;\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["I think using that as a starting point for a Python version is more likely to produce a clean, working result."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "think", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["I wouldn't say this is pythonic, but I'm quite proud of it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\nfor _, to_output in itertools.groupby(sorted(words, key=sorted), sorted):\n    print ' '.join(to_output)\n</code>\n</pre>\n", "senID": 1}]]