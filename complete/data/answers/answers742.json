[[{"text": ["I've created and used my own generic view classes, defining __call__ so an instance of the class is callable.", "I really like it; while Django's generic views allow some customization through keyword arguments, OO generic views (if their behavior is split into a number of separate methods) can have much more fine-grained customization via subclassing, which lets me repeat myself a lot less.", "(I get tired of rewriting the same create/update view logic anytime I need to tweak something Django's generic views don't quite allow)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__call__", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "__call__", "tag": "code"}]}, {"text": "__call__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["I've posted some code at djangosnippets.org."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "djangosnippets.org", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.djangosnippets.org/snippets/1009/"}]}, {"text": ["The only real downside I see is the proliferation of internal method calls, which may impact performance somewhat.", "I don't think this is much of a concern; it's rare that Python code execution would be your performance bottleneck in a web app."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["UPDATE: Django's own generic views are now class-based."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "UPDATE", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://docs.djangoproject.com/en/dev/topics/class-based-views/", "text": "generic views", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["UPDATE: FWIW, I've changed my opinion on class-based views since this answer was written.", "After having used them extensively on a couple of projects, I feel they tend to lead to code that is satisfyingly DRY to write, but very hard to read and maintain later, because functionality is spread across so many different places, and subclasses are so dependent on every implementation detail of the superclasses and mixins.", "I now feel that TemplateResponse and view decorators is a better answer for decomposing view code."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "UPDATE", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "TemplateResponse", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "https://docs.djangoproject.com/en/dev/ref/template-response/"}]}], [{"text": ["If you're simply displaying data from models, why not use the Django Generic Views?", "They're designed to let you easy show data from a model without having to write your own view and stuff about mapping URL paramaters to views, fetching data, handling edge cases, rendering output, etc."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Django Generic Views", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.djangoproject.com/documentation/generic_views/"}]}], [{"text": ["I needed to use class based views, but I wanted to be able to use the full name of the class in my URLconf without always having to instantiate the view class before using it.", "What helped me was a surprisingly simple metaclass:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class CallableViewClass(type):\n    def __call__(cls, *args, **kwargs):\n        if args and isinstance(args[0], HttpRequest):\n            instance = super(CallableViewClass, cls).__call__()\n            return instance.__call__(*args, **kwargs)\n        else:\n            instance = super(CallableViewClass, cls).__call__(*args, **kwargs)\n            return instance\n\n\nclass View(object):\n    __metaclass__ = CallableViewClass\n\n    def __call__(self, request, *args, **kwargs):\n        if hasattr(self, request.method):\n            handler = getattr(self, request.method)\n            if hasattr(handler, '__call__'):\n                return handler(request, *args, **kwargs)\n        return HttpResponseBadRequest('Method Not Allowed', status=405)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I can now both instantiate view classes and use the instances as view functions, OR I can simply point my URLconf to my class and have the metaclass instantiate (and call) the view class for me.", "This works by checking the first argument to __call__ \u2013 if it's a HttpRequest, it must be an actual HTTP request because it would be nonsense to attept to instantiate a view class with an HttpRequest instance."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "__call__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "HttpRequest", "childNum": 0, "tag": "code", "childList": []}, {"text": "HttpRequest", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class MyView(View):\n    def __init__(self, arg=None):\n        self.arg = arg\n    def GET(request):\n        return HttpResponse(self.arg or 'no args provided')\n\n@login_required\nclass MyOtherView(View):\n    def POST(request):\n        pass\n\n# And all the following work as expected.\nurlpatterns = patterns(''\n    url(r'^myview1$', 'myapp.views.MyView', name='myview1'),\n    url(r'^myview2$', myapp.views.MyView, name='myview2'),\n    url(r'^myview3$', myapp.views.MyView('foobar'), name='myview3'),\n    url(r'^myotherview$', 'myapp.views.MyOtherView', name='otherview'),\n)\n</code>\n</pre>\n", "senID": 3}, {"text": ["(I posted a snippet for this at http://djangosnippets.org/snippets/2041/)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://djangosnippets.org/snippets/2041/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://djangosnippets.org/snippets/2041/"}]}], [{"text": ["Sounds to me like you're trying to combine things that shouldn't be combined.", "If you need to do different processing in your view depending on if it's a User or Group object you're trying to look at then you should use two different view functions."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["On the other hand there can be common idioms you'd want to extract out of your object_detail type views... perhaps you could use a decorator or just helper functions?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["-Dan"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Unless you want to do something a little complex, using the generic views are the way to go.", "They are far more powerful than their name implies, and if you are just displaying model data generic views will do the job."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can always create a class, override the __call__ function and then point the URL file to an instance of the class.", "You can take a look at the FormWizard class to see how this is done."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__call__", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "__call__", "tag": "code"}]}, {"text": "__call__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "FormWizard", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.djangoproject.com/browser/django/trunk/django/contrib/formtools/wizard.py"}]}], [{"text": ["If you want to share common functionality between pages I suggest you look at custom tags.", "They're quite easy to create, and are very powerful."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "easy to create", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.djangoproject.com/documentation/templates_python/#extending-the-template-system"}]}, {"text": ["Also, templates can extend from other templates.", "This allows you to have a base template to set up the layout of the page and to share this between other templates which fill in the blanks.", "You can nest templates to any depth; allowing you to specify the layout on separate groups of related pages in one place."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "templates can extend from other templates", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.djangoproject.com/documentation/templates/#extends"}]}], [{"text": ["Generic views will usually be the way to go, but ultimately you're free to handle URLs however you want.", "FormWizard does things in a class-based way, as do some apps for RESTful APIs."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Basically with a URL you are given a bunch of variables and place to provide a callable, what callable you provide is completely up to you - the standard way is to provide a function - but ultimately Django puts no restrictions on what you do."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I do agree that a few more examples of how to do this would be good, FormWizard is probably the place to start though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]