[[{"text": ["I know this question has already been answered, but for what it's worth, I've used the subprocess.py that ships with Python 2.6 in Python 2.3 and it's worked fine.", "If you read the comments at the top of the file it says:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "subprocess.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["There isn't really a great way to do it.", "subprocess is implemented in python (as opposed to C) so you could conceivably copy the module somewhere and use it (hoping of course that it doesn't use any 2.6 goodness)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "implemented in python", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Lib/subprocess.py?rev=69620&view=markup"}]}, {"text": ["On the other hand you could simply implement what subprocess claims to do and write a function that sends SIGTERM on *nix and calls TerminateProcess on Windows.", "The following implementation has been tested on linux and in a Win XP vm, you'll need the python Windows extensions:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "python Windows extensions", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://sourceforge.net/projects/pywin32/"}]}, {"code": "<pre>\n<code>\n import sys\n\ndef terminate(process):\n    \"\"\"\n    Kills a process, useful on 2.5 where subprocess.Popens don't have a \n    terminate method.\n\n\n    Used here because we're stuck on 2.5 and don't have Popen.terminate \n    goodness.\n    \"\"\"\n\n    def terminate_win(process):\n        import win32process\n        return win32process.TerminateProcess(process._handle, -1)\n\n    def terminate_nix(process):\n        import os\n        import signal\n        return os.kill(process.pid, signal.SIGTERM)\n\n    terminate_default = terminate_nix\n\n    handlers = {\n        \"win32\": terminate_win, \n        \"linux2\": terminate_nix\n    }\n\n    return handlers.get(sys.platform, terminate_default)(process)\n</code>\n</pre>\n", "senID": 2}, {"text": ["That way you only have to maintain the terminate code rather than the entire module."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "terminate", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["While this doesn't directly answer your question, it may be worth knowing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Imports from __future__ actually only change compiler options, so while it can turn with into a statement or make string literals produce unicodes instead of strs, it can't change the capabilities and features of modules in the Python standard library."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__future__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I followed Kamil Kisiel suggestion regarding using python 2.6 subprocess.py in python 2.5 and it worked perfectly.", "To make it easier, I created a distutils package that you can easy_install and/or include in buildout."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To use subprocess from python 2.6 in python 2.5 project:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n easy_install taras.python26\n</code>\n</pre>\n", "senID": 2}, {"text": ["in your code"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from taras.python26 import subprocess\n</code>\n</pre>\n", "senID": 4}, {"text": ["in buildout"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n [buildout]\nparts = subprocess26\n\n[subprocess26]\nrecipe = zc.recipe.egg\neggs = taras.python26\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Here are some ways to end processes on Windows, taken directly from\nhttp://code.activestate.com/recipes/347462/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.activestate.com/recipes/347462/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/347462/"}]}, {"code": "<pre>\n<code>\n # Create a process that won't end on its own\nimport subprocess\nprocess = subprocess.Popen(['python.exe', '-c', 'while 1: pass'])\n\n\n# Kill the process using pywin32\nimport win32api\nwin32api.TerminateProcess(int(process._handle), -1)\n\n\n# Kill the process using ctypes\nimport ctypes\nctypes.windll.kernel32.TerminateProcess(int(process._handle), -1)\n\n\n# Kill the proces using pywin32 and pid\nimport win32api\nPROCESS_TERMINATE = 1\nhandle = win32api.OpenProcess(PROCESS_TERMINATE, False, process.pid)\nwin32api.TerminateProcess(handle, -1)\nwin32api.CloseHandle(handle)\n\n\n# Kill the proces using ctypes and pid\nimport ctypes\nPROCESS_TERMINATE = 1\nhandle = ctypes.windll.kernel32.OpenProcess(PROCESS_TERMINATE, False, process.pid)\nctypes.windll.kernel32.TerminateProcess(handle, -1)\nctypes.windll.kernel32.CloseHandle(handle)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Well Python is open source, you are free to take that pthread function from 2.6 and move it into your own code or use it as a reference to implement your own."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For reasons that should be obvious there's no way to have a hybrid of Python that can import portions of newer versions."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]