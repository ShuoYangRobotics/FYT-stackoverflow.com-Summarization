[[{"text": ["The dominant paradigm here is EAFP: easier to ask forgiveness than permission.", "Go ahead and use the file interface, then handle the resulting exception, or let them propagate to the caller."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["It is generally not good practice to have checks like this in your code at all unless you have special requirements. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In Python the typing is dynamic, why do you feel need to check whether the object is file like, rather than just using it as if it was a file and handling the resulting error? "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Any check you can do is going to happen at runtime anyway so doing something like if not hasattr(fp, 'read') and raising some exception provides little more utility than just calling fp.read() and handling the resulting attribute error if the method does not exist."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "if not hasattr(fp, 'read')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fp.read()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You can try and call the method then catch the exception:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    fp.read()\nexcept AttributeError:\n    raise something\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you only want a read and a write method you could do this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if not (hasattr(fp, 'read') and hasattr(fp, 'write')):\n   raise something\n</code>\n</pre>\n", "senID": 3}, {"text": ["If I were you I would go with the try/except method."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["As others have said you should generally avoid such checks.", "One exception is when the object might legitimately be different types and you want different behaviour depending on the type.", "The EAFP method doesn't always work here as an object could look like more than one type of duck!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example an initialiser could take a file, string or instance of its own class.", "You might then have code like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    def __init__(self, f):\n        if isinstance(f, A):\n            # Just make a copy.\n        elif isinstance(f, file):\n            #\u00a0initialise from the file\n        else:\n            # treat f as a string\n</code>\n</pre>\n", "senID": 2}, {"text": ["Using EAFP here could cause all sorts of subtle problems as each initialisation path gets partially run before throwing an exception.", "Essentially this construction mimics function overloading and so isn't very Pythonic, but it can be useful if used with care."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["As a side note, you can't do the file check in the same way in Python 3.", "You'll need something like isinstance(f, io.IOBase) instead."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "isinstance(f, io.IOBase)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["It's often useful to raise an error by checking a condition, when that error normally wouldn't be raised until much later on.", "This is especially true for the boundary between 'user-land' and 'api' code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You wouldn't place a metal detector at a police station on the exit door, you would place it at the entrance!", "If not checking a condition means an error might occur that could have been caught 100 lines earlier, or in a super-class instead of being raised in the subclass then I say there is nothing wrong with checking."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Checking for proper types also makes sense when you are accepting more than one type.", "It's better to raise an exception that says \"I require a subclass of basestring, OR file\" than just raising an exception because some variable doesn't have a 'seek' method..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This doesn't mean you go crazy and do this everywhere, for the most part I agree with the concept of exceptions raising themselves, but if you can make your API drastically clear, or avoid unnecessary code execution because a simple condition has not been met do so!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Under most circumstances, the best way to handle this is not to.", "If a method takes a file-like object, and it turns out the object it's passed isn't, the exception that gets raised when the method tries to use the object is not any less informative than any exception you might have raised explicitly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There's at least one case where you might want to do this kind of check, though, and that's when the object's not being immediately used by what you've passed it to, e.g.", "if it's being set in a class's constructor.", "In that case, I would think that the principle of EAFP is trumped by the principle of \"fail fast.", "\"  I'd check the object to make sure it implemented the methods that my class needs (and that they're methods), e.g."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class C():\n    def __init__(self, file):\n        if type(getattr(file, 'read')) != type(self.__init__):\n            raise AttributeError\n        self.file = file\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I think the best way is to just put the read in a try block.", "IE"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    data = fp.read()\nexcept:\n    raise\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def isFile(f):\n    for i in dir(file):\n        try:\n            eval(\"help f.\"+i)\n        except AttributeError:\n            return False\n        except:\n            continue\n    return True\n</code>\n</pre>\n", "senID": 0}]]