[[{"text": ["There's no way to sort a sequence without knowing all the elements of the sequence, so any generator passed to sorted() is exhausted."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sorted()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The first thing sorted() does is to convert the data to a list.", "Basically the first line (after argument validation) of the implementation is"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sorted()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n newlist = PySequence_List(seq);\n</code>\n</pre>\n", "senID": 1}, {"text": ["See also the full source code version 2.7 and version 3.1.2."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "the full source code version 2.7", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/tags/r27/Python/bltinmodule.c?view=markup"}, {"href": "http://svn.python.org/view/python/tags/r312/Python/bltinmodule.c?view=markup", "text": "version 3.1.2", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Edit: As pointed out in the answer by aaronasterling, the variable newlist is, well, a new list.", "If the parameter is already a list, it is copied.", "So a generator expression really has the advantage of using less memory."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "answer by aaronasterling", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4154571/sorted-using-generator-expressions-rather-than-lists/4155652#4155652"}, {"text": "newlist", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "new", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}], [{"text": ["Python uses Timsort.", "Timsort needs to know the total number of elements up front, to compute the minrun parameter.", "Thus, as Sven reports, the first thing that sorted does when given a generator is to turn it into a list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That said, it would be possible to write an incremental version of Timsort, which consumed values from the generator more slowly - you'd just have to fix minrun before starting, and accept the pain of having some unbalanced merges at the end.", "Timsort works in two phases.", "The first phase involves a pass through the whole array, identifying runs and doing insertion sort to make runs where the data is unordered.", "Both run-finding and insertion sort are inherently incremental.", "The second phase involves a merge of the sorted runs; that would happen exactly as now."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I don't think there would be a lot of point in this, though.", "Perhaps it would make memory management easier, because rather than having to read from the generator into a constantly-growing array (as i baselessly assume the current implementation does), you could read each run into a small buffer, then only allocate a final-sized buffer once, at the end.", "However, this would involve having 2N slots of array in memory at once, whereas a growing array can be done with 1.5N if it doubles when it grows.", "So, probably not a good idea."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["There's a huge benefit.", "Because sorted doesn't affect the passed in sequence, it has to make a copy of it.", "If it's making a list from the generator expression, then only one list gets made.", "If a list comprehension is passed in, then first, that gets built and then sorted makes a copy of it to sort."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sorted", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This is reflected in the line"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n newlist = PySequence_List(seq);\n</code>\n</pre>\n", "senID": 2}, {"text": ["quoted in Sven Marnach's answer.", "Essentially, this will unconditionally make a copy of whatever sequence is passed to it."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Sven Marnach's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4154571/sorted-using-generator-expressions-rather-than-lists/4154734#4154734"}]}], [{"text": ["The easiest way to see which is faster is to use timeit and it tells me that it's faster to pass a list rather than a generator:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "timeit", "tag": "a", "pos": 0, "childList": [{"text": "timeit", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/timeit.html"}, {"text": "timeit", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import random\n&gt;&gt;&gt; randomlist = range(1000)\n&gt;&gt;&gt; random.shuffle(randomlist)\n&gt;&gt;&gt; import timeit\n&gt;&gt;&gt; timeit.timeit(\"sorted(x for x in randomlist)\",setup = \"from __main__ import randomlist\",number = 10000)\n4.944492386602178\n&gt;&gt;&gt; timeit.timeit(\"sorted([x for x in randomlist])\",setup = \"from __main__ import randomlist\",number = 10000)\n4.635165083830486\n</code>\n</pre>\n", "senID": 1}, {"text": ["And:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; timeit.timeit(\"sorted(x for x in xrange(1000,1,-1))\",number = 10000)\n1.411807087213674\n&gt;&gt;&gt; timeit.timeit(\"sorted([x for x in xrange(1000,1,-1)])\",number = 10000)\n1.0734657617099401\n</code>\n</pre>\n", "senID": 3}, {"text": ["I think this is because when sorted() converts the incoming value to a list it can do this more quickly for something that is already a list than for a generator.", "The source code seems to confirm this (but this is from reading the comments rather than fully understanding everything that is going on)."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "sorted()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "The source code seems to confirm this", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.google.com/codesearch/p?hl=en#-2BKs-LW4I0/trunk/python/src/Objects/listobject.c&q=_PyList_Extend&l=798"}]}], [{"text": ["what do you man faster than a list you mean faster than an explicit for ?", "for that i will say it depend , the list comprehensible is more like a syntactic sugar , but it very handy when it come to simple loop ."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["the main difference between List comprehensible and Generator expressions is that the Generator expressions avoid the overhead of generating the entire list at once.", "Instead, they return a generator object which can be iterated one by one, so the Generator expressions are more likely used to save memory usage."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["But you have to understand one thing in python it's very hard to tell if one way is faster (optimistic) than an other way just by looking at it, and if you want to do that you should use timeit for benchmarking (and benchmarking it's very complex than just running one timeit in a single machine)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "timeit", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/timeit.html"}]}, {"text": ["Read this for more info about some optimization ways."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/PythonSpeed/PerformanceTips"}]}]]