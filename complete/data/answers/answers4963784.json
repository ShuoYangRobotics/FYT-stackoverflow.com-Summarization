[[{"text": ["Your approach is a good one, but you should instead use the for x in y idiom instead of repeatedly calling next until you get a StopIteration.", "This works for both lists and generators:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "for x in y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "next", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "StopIteration", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def my_mean(values):\n    n = 0\n    Sum = 0.0\n\n    for value in values:\n        Sum += value\n        n += 1\n    return float(Sum)/n\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Just one simple change to your code would let you use both.", "Generators were meant to be used interchangeably to lists in a for-loop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def my_mean(values):\n    n = 0\n    Sum = 0.0\n    for v in values:\n        Sum += v\n        n += 1\n    return Sum / n\n</code>\n</pre>\n", "senID": 1}], [{"text": ["One way would be"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n numpy.fromiter(Y, int).mean()\n</code>\n</pre>\n", "senID": 1}, {"text": ["but this actually temporarily stores the numbers."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n def my_mean(values):\n    n = 0\n    sum = 0\n    for v in values:\n        sum += v\n        n += 1\n    return sum/n\n</code>\n</pre>\n", "senID": 0}, {"text": ["The above is very similar to your code, except by using for to iterate values you are good no matter if you get a list or an iterator.", "The python sum method is however very optimized, so unless the list is really, really long, you might be more happy temporarily storing the data."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "values", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sum", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["(Also notice that since you are using python3, you don't need float(sum)/n)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "float(sum)/n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The old-fashioned way to do it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def my_main(values):\n   sum, n = 0, 0\n   for x in values:\n      sum += x\n      n += 1\n   return float(sum)/n\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Try:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\ndef mean(i):\n    (i1, i2) = itertools.tee(i, 2)\n    return sum(i1) / sum(1 for _ in i2)\n\nprint mean([1,2,3,4,5])\n</code>\n</pre>\n", "senID": 1}, {"text": ["tee will duplicate your iterator for any iterable i (e.g.", "a generator, a list, etc.", "), allowing you to use one duplicate for summing and the other for counting."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "tee", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "i", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["(Note that 'tee' will still use intermediate storage)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n def my_mean(values):\n    total = 0\n    for n, v in enumerate(values, 1):\n        total += v\n    return total / n\n\nprint my_mean(X)\nprint my_mean(Y)\n</code>\n</pre>\n", "senID": 0}]]