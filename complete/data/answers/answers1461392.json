[[{"text": ["If you are going to be returning iterators sometimes, and single objects on others, I'd say return always an iterator, so you don't have to think about it. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Generaly, you would use that function in a context that expects an iterator, so if you'd have to check if it where a list to iterate or an object to do just one time the work, then its easier to just return an iterator and iterate always, even if its one time."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you need to do something different if you are returned one element, just use if len(var):."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "if len(var):", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Remember, consistency is a valuable good."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I lean towards returning a consistent object, not necesarily the same type, but if I return ever an iterable, I return always an iterable."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["In general, I would have to say that returning two different types is bad practice."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Imagine the next developer coming to read and maintain your code.", "At first he/she will read a method using your function and think \"Ah, read() returns a single item.", "\" "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Later they will see code treating read()'s result as a list.", "At best this will simply confuse them and force them to examine read()'s usage.", "At worst they might think there is a bug in the implementation using read() and attempt to fix it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Finally, once they understand read() returns two possible types they will have to ask themselves \"is there possibly a third return type I need to be ready for?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["This reminds me of the saying: \"Code as if the next guy to maintain your code is a homicidal maniac who knows where you live.", "\" "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Returning either a single object, or an iterable of objects, depending on arguments, is definitely hard to deal with.", "But the question in your title is much more general and the assertion that the standard library's function avoid (or \"mostly avoid\") returning different types based on the argument(s) is quite incorrect.", "There are many counter-examples."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Functions copy.copy and copy.deepcopy return the same type as their argument, so of course they're \"returning different types depending on\" the argument.", "\"Return same type as the input\" is actually VERY common --  you could class here, also, the \"fetch an object back from a container where it was put\", though normally that's done with a method rather than a function;-).", "But also, in the same vein, consider itertools.repeat (once you iterate on its returned iterator), or, say, filter...:"], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "copy.copy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "copy.deepcopy", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "itertools.repeat", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "filter", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; filter(lambda x: x&gt;'f', 'zaplepidop')\n'zplpiop'\n&gt;&gt;&gt; filter(lambda x: x&gt;'f', list('zaplepidop'))\n['z', 'p', 'l', 'p', 'i', 'o', 'p']\n</code>\n</pre>\n", "senID": 2}, {"text": ["filtering a string returns a string, filtering a list returns a list.  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["But wait, there's more!-)  Functions pickle.loads and its friends (e.g.", "in module marshal &amp;c) return objects of types entirely dependent on the value you're passing as an argument.", "So does built-in function eval (and similarly input, in Python 2.*).", "This is the second common pattern: construct or reconstruct an object as dictated by the value of the argument(s), of a wide (or even ubbounded) variety of possible types, and return it."], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "pickle.loads", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "marshal", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "entirely", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "eval", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "input", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["I know no good example of the specific anti-pattern you've observed (and I do believe it's an anti-pattern, mildly -- not for any high-falutin' reason, just because it's pesky and inconvenient to deal with;-).", "Note that these cases I have exemplified ARE handy and convenient -- that's the real design discriminant in most standard library issue!-)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["The only situation where I would do this is with a parameterized function or method, where one or more of the parameters the caller gives determines the type returned; for example, a \"factory\" function that returns one of a logically similar family of objects:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n newCharacter = characterFactory(\"human\", \"male\", \"warrior\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["In the general case, where the caller doesn't get to specify, I'd avoid the \"box of chocolates\" behavior.", ":)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It may not be a matter of \"pythonic\" but rather a matter of \"good design\".", "If you returnd different things AND nobody has to do typechecks on them, then it's probably okay.", "That's polymorphism for you.", "OTOH, if the caller has to \"pierce the veil\" then you have a design problem, known as a violation of the Liskov Substitution Principle.", "Pythonic or not, it is clearly not an OO design, which means it will be prone to bugs and programming inconveniences. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "AND", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["I would have read(integer) and read_list(iterable)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "integer", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "iterable", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["That way you could do read(10) and get back a single result and read_list([5, 5, 10, 5]) and get back a list of results.", "This is both more flexible and explicit."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["In python lists are objects :) So no type mismatch"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]