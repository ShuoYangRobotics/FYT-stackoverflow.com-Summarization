[[{"text": ["A K-means algorithm is already implemented in scipy.cluster.vq.", "If there is something about that implementation that you are trying to change, then I'd suggest start by studying the code there:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "scipy.cluster.vq", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/scipy/reference/cluster.vq.html"}]}, {"code": "<pre>\n<code>\n In [62]: import scipy.cluster.vq as scv\nIn [64]: scv.__file__\nOut[64]: '/usr/lib/python2.6/dist-packages/scipy/cluster/vq.pyc'\n</code>\n</pre>\n", "senID": 1}, {"text": ["PS.", "Because the algorithm you posted holds the data behind a dict (self.clusters) and attribute lookup (.points) you are forced to use slow Python looping just to get at your data.", "A major speed gain could be achieved by sticking with numpy arrays.", "See the scipy implementation of k-means clustering for ideas on a better data structure."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "self.clusters", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": ".points", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Why not avoid constructing the extra arrays?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def updateCentroid(self, label):\n  sumX=0; sumY=0\n  N = len( self.clusters[label].points)\n  for point in self.clusters[label].points:\n    sumX += point.x\n    sumY += point.y\n  self.clusters[label].centroid.x = sumX/N\n  self.clusters[label].centroid.y = sumY/N\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The costly part of your function is most certainly the iteration over the points.", "Avoid it altogether by making self.clusters[label].points a numpy array itself, and then compute the mean directly on it.", "For example if points contains X and Y coordinates concatenated in a 1D array:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "self.clusters[label].points", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n points = self.clusters[label].points\nx_mean = numpy.mean(points[0::2])\ny_mean = numpy.mean(points[1::2])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Without extra lists:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def updateCentroid(self, label):\n    self.clusters[label].centroid.x = numpy.fromiter(point.x for point in self.clusters[label].points, dtype = np.float).mean()\n    self.clusters[label].centroid.y = numpy.fromiter(point.y for point in self.clusters[label].points, dtype = np.float).mean()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Perhaps the added features of numpy's mean are adding a bit of overhead."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "mean", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def myMean(itr):\n...   c = t = 0\n...   for item in itr:\n...     c += 1\n...     t += item\n...   return t / c\n...\n&gt;&gt;&gt; import timeit\n&gt;&gt;&gt; a = range(20)\n&gt;&gt;&gt; t1 = timeit.Timer(\"myMean(a)\",\"from __main__ import myMean, a\")\n&gt;&gt;&gt; t1.timeit()\n6.8293311595916748\n&gt;&gt;&gt; t2 = timeit.Timer(\"average(a)\",\"from __main__ import a; from numpy import average\")\n&gt;&gt;&gt; t2.timeit()\n69.697283029556274\n&gt;&gt;&gt; t3 = timeit.Timer(\"average(array(a))\",\"from __main__ import a; from numpy import average, array\")\n&gt;&gt;&gt; t3.timeit()\n51.65147590637207\n&gt;&gt;&gt; t4 = timeit.Timer(\"fromiter(a,npfloat).mean()\",\"from __main__ import a; from numpy import average, fromiter,float as npfloat\")\n&gt;&gt;&gt; t4.timeit()\n18.513712167739868\n</code>\n</pre>\n", "senID": 1}, {"text": ["Looks like numpy's best performance came when using fromiter."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "fromiter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Ok, I figured out a moving average solution which is fast without changing the data structures:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def updateCentroid(self, label):\n    cluster = self.clusters[label]\n    n = len(cluster.points)\n    cluster.centroid.x = ((n-1)*cluster.centroid.x + cluster.points[n-1].x)/n\n    cluster.centroid.y = ((n-1)*cluster.centroid.y + cluster.points[n-1].y)/n\n</code>\n</pre>\n", "senID": 1}, {"text": ["This lowered computation time (for the whole k means algorithm) to 13% of original.", "=)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Thank you all for some great insight!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def updateCentroid(self, label):\n\n    self.clusters[label].centroid.x = numpy.array([point.x for point in self.clusters[label].points]).mean()\n    self.clusters[label].centroid.y = numpy.array([point.y for point in self.clusters[label].points]).mean()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["That's the problem with profilers that only tell you about functions.", "This is the method I use, and it pinpoints costly lines of code, including points where functions are called."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "This is the method I use", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/375913/what-can-i-use-to-profile-c-code-in-linux/378024#378024"}]}, {"text": ["That said, there's a general idea that data structure is free.", "As @Michael-Anderson asked, why not avoid making an array?", "That's the first thing I saw in your code, that you're building arrays by appending.", "You don't need to."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["One way to go is add an x_sum and y_sum to your \"clusters\" object and sum the coordinates as points are added.", "If things are moving around, you can also update the sum as points move.", "Then getting the centroid is just a matter of dividing the x_sum and y_sum by the number of points.", "If your points are numpy vectors that can be added, then you don't even need to sum the components, just maintain a sum of all the vectors and multiply be 1/len at the end."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]