[[{"text": ["append actually changes the list.", "Also, it takes an item, not a list.", "Hence, all you need is"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "append", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "changes", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "item", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n for i in range(n):\n   list1.append(i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(By the way, note that you can use range(n), in this case."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "range(n)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I assume your actual use is more complicated, but you may be able to use a list comprehension, which is more pythonic for this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n list1 = [i for i in range(n)]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Or, in this case, in Python 2.x range(n) in fact creates the list that you want already, although in Python 3.x, you need list(range(n))."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "range(n)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list(range(n))", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You don't need the assignment operator.", "append returns None."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["append returns None, so at the second iteration you are calling method append of NoneType.", "Just remove the assignment:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "append", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "append", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n for i in range(0, n):\n    list1.append([i])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Like Mikola said, append() returns a void, so every iteration you're setting list1 to a nonetype because append is returning a nonetype.", "On the next iteration, list1 is null so you're trying to call the append method of a null.", "Nulls don't have methods, hence your error."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "append()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Mikola has the right answer but a little more explanation.", "It will run the first time, but because append returns None, after the first iteration of the for loop, your assignment will cause list1 to equal None and therefore the error is thrown on the second iteration."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "list1", "childNum": 0, "tag": "code", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Note that you also can use insert in order to put number into the required position within list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n initList = [1,2,3,4,5]\ninitList.insert(2, 10) # insert(pos, val) =&gt; initList = [1,2,10,3,4,5]\n</code>\n</pre>\n", "senID": 1}, {"text": ["And also note that in python you can always get a list length using method len()"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I personally prefer the + operator than append:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "append", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n for i in range(0, n):\n\n    list1 += [[i]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["But this is creating a new list every time, so might not be the best if performance is critical."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]