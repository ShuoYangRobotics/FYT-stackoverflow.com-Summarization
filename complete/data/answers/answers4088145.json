[[{"text": ["This is the same:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if (x % 5 == 3 and y % 5 &gt; 1) or (y % 5 == 3 and x % 5 &gt; 1):\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Basically you're tiling a 5x5 binary pattern.", "Here's a clear expression of that:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n pattern = [[0, 0, 0, 0, 0],\n           [0, 0, 0, 0, 0],\n           [0, 0, 0, 1, 0],\n           [0, 0, 1, 1, 1],\n           [0, 0, 0, 1, 0]]\n\nfor y in range(MAP_HEIGHT):\n    for x in range(MAP_WIDTH):\n        if pattern[x%5][y%5]:\n           ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is a very simple and general approach which would allow the pattern to be easily modified."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["There are two trivial fixes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Cache the result of ", "tag": "none", "senID": 1}, {"text": "Use ", "tag": "none", "senID": 2}]}, {"text": ["Additionally, the test for &lt;= 4 (or &lt; 5) is actually redundant because every value of lx and ly will be &lt; 5."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "&lt;= 4", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "&lt; 5", "childNum": 0, "tag": "code", "childList": []}, {"text": "every", "childNum": 0, "tag": "em", "childList": []}, {"text": "lx", "childNum": 0, "tag": "code", "childList": []}, {"text": "ly", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n for y in range(MAP_HEIGHT):\n    for x in range(MAP_WIDTH):\n        lx = x % 5 # for local-x\n        ly = y % 5 # for local-y\n        if lx &gt; 1 and y &gt; 1 and \\\n           not (lx == 2 and ly == 2) and \\\n           not (lx == 4 and ly == 2) and \\\n           not (lx == 2 and ly == 4) and \\\n           not (lx == 4 and ly == 4):\n</code>\n</pre>\n", "senID": 4}, {"text": ["Or you may just keep a list of the actually allowed tuples:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n cross_fields = [(2, 3), (3, 2), (3, 3), (3, 4), (4, 3)]\n\nfor y in range(MAP_HEIGHT):\n    for x in range(MAP_WIDTH):\n        if (x % 5, y % 5) in cross_fields:\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Building on Konrad's answer, you can simplify it further:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for y in range(MAP_HEIGHT):\n    for x in range(MAP_WIDTH):\n        lx = x % 5 # for local-x\n        ly = y % 5 # for local-y\n        if (1 &lt; lx &lt; 5 and 1 &lt; y &lt; 5 and \n           (lx, ly) not in ((2, 2), (4, 2), (2, 4), (4, 2))):\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Konrad's second answer:-"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n cross_fields = [(2, 3), (3, 2), (3, 3), (3, 4), (4, 3)]\n\nfor y in range(MAP_HEIGHT):\n  for x in range(MAP_WIDTH):\n    if (x % 5, y % 5) in cross_fields:\n</code>\n</pre>\n", "senID": 1}, {"text": ["is probably the best one."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["However, I'll contribute:-"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for y in range(MAP_HEIGHT):\n  for x in range(MAP_WIDTH):\n    lx = x % 5\n    ly = y % 5\n    if (lx &gt; 1 and ly == 3) or (ly &gt; 1 and lx == 3):\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The general solution to optimizing a logic function like this is a Karnaugh map.", "Your truth table would be the literal plus shape you want with rows and columns being your modular tests."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Karnaugh map", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Karnaugh_map"}]}]]