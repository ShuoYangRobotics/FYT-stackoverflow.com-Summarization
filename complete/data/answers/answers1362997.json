[[{"text": ["Function call overheads are not big; you won't normally notice them.", "You only see them in this case because your actual code (x*x) is itself so completely trivial.", "In any real program that does real work, the amount of time spent in function-calling overhead will be negligably small."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(Not that I'd really recommend using foo, identity and square in the example, in any case; they're so trivial it's just as readable to have them inline and they don't really encapsulate or abstract anything."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Because programs are written for to be easy for you to read and maintain.", "You could replace constants with their literal values, but it'd make the program harder to work with, for a benefit that is so tiny you'll probably never even be able to measure it: the height of premature optimisation."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "you", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "could", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"href": "http://en.wikipedia.org/wiki/Optimization%5F%28computer%5Fscience%29#cite%5Fref-0", "text": "premature optimisation", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I don't know how good python compilers are, but the answer to this question for many languages is that the compiler will optimize calls to small procedures / functions / methods by inlining them.", "In fact, in some language implementations you generally get better performance by NOT trying to \"micro-optimize\" the code yourself."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["What you are talking about is the effect of inlining functions for gaining efficiency. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It is certainly true in your Python example, that encapsulation hurts performance.", "But there are some counter example to it:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Encapsulation is about one thing and one thing only: Readability.", "If you're really so worried about performance that you're willing to start stripping out encapsulated logic, you may as well just start coding in assembly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Encapsulation also assists in debugging and feature adding.", "Consider the following: lets say you have a simple game and need to add code that depletes the players health under some circumstances.", "Easy, yes?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def DamagePlayer(dmg):\n    player.health -= dmg;\n</code>\n</pre>\n", "senID": 2}, {"text": ["This IS very trivial code, so it's very tempting to simply scatter \"player.health -=\" everywhere.", "But what if later you want to add a powerup that halves damage done to the player while active?", "If the logic is still encapsulated, it's easy:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def DamagePlayer(dmg):\n    if player.hasCoolPowerUp:\n        player.health -= dmg / 2\n    else\n        player.health -= dmg\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now, consider if you had neglected to encapulate that bit of logic because of it's simplicity.", "Now you're looking at coding the same logic into 50 different places, at least one of which you are almost certain to forget, which leads to weird bugs like: \"When player has powerup all damage is halved except when hit by AlienSheep enemies...\""], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Do you want to have problems with Alien Sheep?", "I don't think so.", ":)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["In all seriousness, the point I'm trying to make is that encapsulation is a very good thing in the right circumstances.", "Of course, it's also easy to over-encapsulate, which can be just as problematic.", "Also, there are situations where the speed really truly does matter (though they are rare), and that extra few clock cycles is worth it.", "About the only way to find the right balance is practice.", "Don't shun encapsulation because it's slower, though.", "The benefits usually far outweigh the costs."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Figuring out what to make into a function and what to just include inline is something of an art.", "Many factors (performance, readability, maintainability) feed into the equation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I actually find your example kind of silly in many ways - a function that just returns it's argument?", "Unless it's an overload that's changing the rules, it's stupid.", "A function to square things?", "Again, why bother.", "Your function 'foo' should probably return a string, so that it can be used directly:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n ''.join(foo(x),\" -- bar !! \"])\n</code>\n</pre>\n", "senID": 2}, {"text": ["That's probably a more correct level of encapsulation in this example."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["As I say, it really depends on the circumstances.", "Unfortunately, this is the sort of thing that doesn't lend itself well to examples."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["IMO, this is related to Function Call Costs.", "Which are negligible usually, but not zero.", "Splitting the code in a lot of very small functions may hurt.", "Especially in interpreted languages where full optimization is not available."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Function Call Costs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/94794/what-is-the-cost-of-a-function-call"}]}, {"text": ["Inlining functions may improve performance but it may also deteriorate.", "See, for example, C++ FQA Lite for explanations (\u201cInlining can make code faster by eliminating function call overhead, or slower by generating too much code, causing instruction cache misses\u201d).", "This is not C++ specific.", "Better leave optimizations for compiler/interpreter unless they are really necessary."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "C++ FQA Lite", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://yosefk.com/c++fqa/inline.html#fqa-9.3"}, {"text": "really necessary", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"text": ["By the way, I don't see a huge difference between two versions:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ python bench.py \nfine-grained function decomposition: 5.46632194519\none-liner: 4.46827578545\n$ python --version\nPython 2.5.2\n</code>\n</pre>\n", "senID": 3}, {"text": ["I think this result is acceptable.", "See bench.py in the pastebin."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "pastebin", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pastebin.com/f7eb3be0"}]}], [{"text": ["There is a performance hit for using functions, since there is the overhead of jumping to a new address, pushing registers on the stack, and returning at the end.", "This overhead is very small, however, and even in peformance critial systems worrying about such overhead is most likely premature optimization."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Many languages avoid these issues in small frequenty called functions by using inlining, which is essentially  what you do above."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Python does not do inlining.", "The closest thing you can do is use macros to replace the function calls.   "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This sort of performance issue is better served by another language, if you need the sort of speed gained by inlining (mostly marginal, and sometimes detremental) then you need to consider not using python for whatever you are working on.  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["There is a good technical reason why what you suggested is impossible.", "In Python, functions, constants, and everything else are accessible at runtime and can be changed at any time if necessary; they could also be changed by outside modules.", "This is an explicit promise of Python and one would need some extremely important reasons to break it."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "accessible at runtime and can be changed at any time if necessary", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "extremely", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["For example, here's the common logging idiom:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # beginning of the file xxx.py\nlog = lambda *x: None \n\ndef something():\n    ...\n    log(...)\n    ...\n</code>\n</pre>\n", "senID": 2}, {"text": ["(here log does nothing), and then at some other module or at the interactive prompt:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "log", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import xxx\nxxx.log = print\nxxx.something()\n</code>\n</pre>\n", "senID": 4}, {"text": ["As you see, here log is modified by completely different module --- or by the user --- so that logging now works.", "That would be impossible if log was optimized away."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "log", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "log", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Similarly, if an exception was to happen in make_legal_foo_string (this is possible, e.g.", "if x.__str__() is broken and returns None) you'd be hit with a source quote from a wrong line and even perhaps from a wrong file in your scenario. "], "childNum": 4, "tag": "p", "senID": 6, "childList": [{"text": "an exception", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "make_legal_foo_string", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "x.__str__()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["There are some tools that in fact apply some optimizations to Python code, but I don't think of the kind you suggested."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]]