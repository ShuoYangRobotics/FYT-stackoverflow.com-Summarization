[[{"text": ["The gzip format specifies a field called ISIZE that:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "gzip format", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.gzip.org/zlib/rfc-gzip.html#header-trailer"}, {"text": "ISIZE", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In gzip.py, which I assume is what you're using for gzip support, there is a method called _read_eof defined as such:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "gzip.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pydoc.org/get.cgi/usr/local/lib/python2.5/gzip.py"}, {"text": "_read_eof", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def _read_eof(self):\n    # We've read to the end of the file, so we have to rewind in order\n    # to reread the 8 bytes containing the CRC and the file size.\n    # We check the that the computed CRC and size of the\n    # uncompressed data matches the stored values.  Note that the size\n    # stored is the true file size mod 2**32.\n    self.fileobj.seek(-8, 1)\n    crc32 = read32(self.fileobj)\n    isize = U32(read32(self.fileobj))   # may exceed 2GB\n    if U32(crc32) != U32(self.crc):\n        raise IOError, \"CRC check failed\"\n    elif isize != LOWU32(self.size):\n        raise IOError, \"Incorrect length of data produced\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["There you can see that the ISIZE field is being read, but only to to compare it to self.size for error detection.", "This then should mean that GzipFile.size stores the actual uncompressed size.", "However, I think it's not exposed publicly, so you might have to hack it in to expose it.", "Not so sure, sorry."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "ISIZE", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self.size", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "GzipFile.size", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "think", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["I just looked all of this up right now, and I haven't tried it so I could be wrong.", "I hope this is of some use to you.", "Sorry if I misunderstood your question."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The last 4 bytes of the .gz hold the original size of the file"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Unix way: use \"gunzip -l file.gz\" via subprocess.call / os.popen, capture and parse its output."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Looking at the source for the gzip module, I see that the underlying file object for GzipFile seems to be fileobj.", "So:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "gzip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "GzipFile", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "fileobj", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n mygzipfile = gzip.GzipFile()\n...\nmygzipfile.fileobj.tell()\n</code>\n</pre>\n", "senID": 1}, {"text": ["?  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Maybe it would be good to do some sanity checking before doing that, like checking that the attribute exists with hasattr."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "hasattr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Not exactly a public API, but..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["GzipFile.size stores the uncompressed size, but it's only incremented when you read the file, so you should prefer len(fd.read()) instead of the non-public GzipFile.size."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n f = gzip.open(filename)\n    # kludge - report uncompressed file position so progess bars\n    # don't go to 400%\n    f.tell = f.fileobj.tell\n</code>\n</pre>\n", "senID": 0}]]