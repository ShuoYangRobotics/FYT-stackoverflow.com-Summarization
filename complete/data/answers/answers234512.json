[[{"text": ["Here's a simplistic solution that works with your test input:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nre.findall('\\[[^\\]]*\\]|\\\"[^\\\"]*\\\"|\\S+',s)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will return any code that matches either "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "a open bracket followed by zero or more non-close-bracket characters followed by a close bracket, ", "tag": "none", "senID": 3}, {"text": "a double-quote followed by zero or more non-quote characters followed by a quote,", "tag": "none", "senID": 4}, {"text": "any group of non-whitespace characters", "tag": "none", "senID": 5}]}, {"text": ["This works with your example, but might fail for many real-world strings you may encounter.", "For example, you didn't say what you expect with unbalanced brackets or quotes,or how you want single quotes or escape characters to work.", "For simple cases, though, the above might be good enough."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["To complete Bryan post and match exactly the answer :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; txt = 'this is [bracket test] \"and quotes test \"'\n&gt;&gt;&gt; [x[1:-1] if x[0] in '[\"' else x for x in re.findall('\\[[^\\]]*\\]|\\\"[^\\\"]*\\\"|\\S+', txt)]\n['this', 'is', 'bracket test', 'and quotes test ']\n</code>\n</pre>\n", "senID": 1}, {"text": ["Don't misunderstand the whole syntax used : This is not several statments on a single line but a single functional statment (more bugproof)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's a simplistic parser (tested against your example input) that introduces the State design pattern."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In real world, you probably want to build a real parser using something like PLY."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "PLY", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/ply/"}]}, {"code": "<pre>\n<code>\n class SimpleParser(object):\n\n    def __init__(self):\n        self.mode = None\n        self.result = None\n\n    def parse(self, text):\n        self.initial_mode()\n        self.result = []\n        for word in text.split(' '):\n            self.mode.handle_word(word)\n        return self.result\n\n    def initial_mode(self):\n        self.mode = InitialMode(self)\n\n    def bracket_mode(self):\n        self.mode = BracketMode(self)\n\n    def quote_mode(self):\n        self.mode = QuoteMode(self)\n\n\nclass InitialMode(object):\n\n    def __init__(self, parser):\n        self.parser = parser\n\n    def handle_word(self, word):\n        if word.startswith('['):\n            self.parser.bracket_mode()\n            self.parser.mode.handle_word(word[1:])\n        elif word.startswith('\"'):\n            self.parser.quote_mode()\n            self.parser.mode.handle_word(word[1:])\n        else:\n            self.parser.result.append(word)\n\n\nclass BlockMode(object):\n\n    end_marker = None\n\n    def __init__(self, parser):\n        self.parser = parser\n        self.result = []\n\n    def handle_word(self, word):\n        if word.endswith(self.end_marker):\n            self.result.append(word[:-1])\n            self.parser.result.append(' '.join(self.result))\n            self.parser.initial_mode()\n        else:\n            self.result.append(word)\n\nclass BracketMode(BlockMode):\n    end_marker = ']'\n\nclass QuoteMode(BlockMode):\n    end_marker = '\"'\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Here's a more procedural approach:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\na = 'this is [bracket test] \"and quotes test \"'\n\nwords = a.split()\nwordlist = []\n\nwhile True:\n    try:\n        word = words.pop(0)\n    except IndexError:\n        break\n    if word[0] in '\"[':\n        buildlist = [word[1:]]\n        while True:\n            try:\n                word = words.pop(0)\n            except IndexError:\n                break\n            if word[-1] in '\"]':\n                buildlist.append(word[:-1])\n                break\n            buildlist.append(word)\n        wordlist.append(' '.join(buildlist))\n    else:\n        wordlist.append(word)\n\nprint wordlist\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Well, I've encountered this problem quite a few times, which led me to write my own system for parsing any kind of syntax."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The result of this can be found here; note that this may be overkill, and it will provide you with something that lets you parse statements with both brackets and parentheses, single and double quotes, as nested as you want.", "For example, you could parse something like this (example written in Common Lisp):"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://gist.github.com/19929"}]}, {"code": "<pre>\n<code>\n (defun hello_world (&amp;optional (text \"Hello, World!\"))\n    (format t text))\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can use nesting, brackets (square) and parentheses (round), single- and double-quoted strings, and it's very extensible."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The idea is basically a configurable implementation of a Finite State Machine which builds up an abstract syntax tree character-by-character.", "I recommend you look at the source code (see link above), so that you can get an idea of how to do it.", "It's capable via regular expressions, but try writing a system using REs and then trying to extend it (or even understand it) later."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Works for quotes only.     "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n rrr = []\nqqq = s.split('\\\"')\n[ rrr.extend( qqq[x].split(), [ qqq[x] ] )[ x%2]) for x in range( len( qqq ) )]\nprint rrr\n</code>\n</pre>\n", "senID": 1}]]