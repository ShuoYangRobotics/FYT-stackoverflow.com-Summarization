[[{"text": ["Semantically equivalent to your code but arguably neater:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Child(Parent):\n   Options = dict(Parent.Options,\n      option2='value2',\n      option3='value3')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Remember, \"life is better without braces\", and by calling dict explicitly you can often avoid braces (and extra quotes around keys that are constant identifier-like strings)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["See http://docs.python.org/library/stdtypes.html#dict for more details -- the key bit is \"If a key is specified both in the positional argument and as a keyword argument, the value associated with the keyword is retained\", i.e.", "keyword args override key-value associations in the positional arg, just like the update method lets you override them)."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "http://docs.python.org/library/stdtypes.html#dict", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#dict"}, {"text": "override", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "update", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["One way would be to use keyword arguments to dict to specify additional keys:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Parent.options = dict(\n    option1='value1',\n    option2='value2',\n)\n\nChild.options = dict(Parent.options,\n    option2='value2a',\n    option3='value3',\n)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want to get fancier, then using the descriptor protocol you can create a proxy object that will encapsulate the lookup.", "(just walk the owner.__mro__ from the owner attribute to the __get__(self, instance, owner) method).", "Or even fancier, crossing into the probably-not-a-good-idea territory, metaclasses/class decorators."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["After thinking more about it, and thanks to @SpliFF suggestion this is what I came up with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Parent(object):\n    class Options:\n        option1 = 'value1'\n        option2 = 'value2'\n\n\nclass Child(Parent):\n    class Options(Parent.Options):\n        option2 = 'value2'\n        option3 = 'value3'\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm still open to better solutions though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Why not just use class attributes?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Parent(object):\n    option1 = 'value1'\n    option2 = 'value2'\n\nclass Child(Parent):\n    option2 = 'value2'\n    option3 = 'value3'\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n class ParentOptions:\n  option1 = 'value1'\n  option2 = 'value2'\n\nclass ChildOptions(ParentOptions):\n  option2 = 'value2'\n  option3 = 'value3'\n\nclass Parent(object):\n  options = ParentOptions()\n\nclass Child(Parent):\n  options = ChildOptions()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Here is a way using a metaclass"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class OptionMeta(type):\n    @property\n    def options(self):\n        result = {}\n        for d in self.__mro__[::-1]:\n            result.update(getattr(d,'_options',{})) \n        return result\n\nclass Parent(object):\n    __metaclass__ = OptionMeta\n    _options = dict(\n        option1='value1',\n        option2='value2',\n        )\n\nclass Child(Parent):\n    _options = dict(\n        option2='value2a',\n        option3='value3',\n        )\n\nprint Parent.options\nprint Child.options\n</code>\n</pre>\n", "senID": 1}]]