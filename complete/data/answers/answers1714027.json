[[{"text": ["Is reuse considered elegance in this instance?", ":)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "reuse", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # pkg_resources is in setup_tools\ndef mycmp(a, b):\n    from pkg_resources import parse_version as V\n    return cmp(V(a),V(b))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["No need to iterate over the version tuples.", "The built in comparison operator on lists and tuples already works exactly like you want it.", "You'll just need to zero extend the version lists to the corresponding length.", "With python 2.6 you can use izip_longest to pad the sequences. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip_longest\ndef version_cmp(v1, v2):\n    parts1, parts2 = [map(int, v.split('.')) for v in [v1, v2]]\n    parts1, parts2 = zip(*izip_longest(parts1, parts2, fillvalue=0))\n    return cmp(parts1, parts2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["With lower versions, some map hackery is required."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def version_cmp(v1, v2):\n    parts1, parts2 = [map(int, v.split('.')) for v in [v1, v2]]\n    parts1, parts2 = zip(*map(lambda p1,p2: (p1 or 0, p2 or 0), parts1, parts2))\n    return cmp(parts1, parts2)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["How about using Python's distutils.version.StrictVersion?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "distutils.version.StrictVersion", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from distutils.version import StrictVersion\n&gt;&gt;&gt; StrictVersion('10.4.10') &gt; '10.4.9'\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["So for your cmp function:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "cmp", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; cmp = lambda x, y: StrictVersion(x).__cmp__(y)\n&gt;&gt;&gt; cmp(\"10.4.10\", \"10.4.11\")\n-1\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This is a little more compact than your suggestion.", "Rather than filling the shorter version with zeros, I'm removing trailing zeros from the version lists after splitting."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def normalize_version(v):\n    parts = [int(x) for x in v.split(\".\")]\n    while parts[-1] == 0:\n        parts.pop()\n    return parts\n\ndef mycmp(v1, v2):\n    return cmp(normalize_version(v1), normalize_version(v2))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Remove the uninteresting part of the string (trailing zeroes and dots), and then compare the lists of numbers."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef mycmp(version1, version2):\n    def normalize(v):\n        return [int(x) for x in re.sub(r'(\\.0+)*$','', v).split(\".\")]\n    return cmp(normalize(version1), normalize(version2))\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: same approach as P\u00e4r Wieslander, but a bit more compact."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Remove trailing .0 and .00 with regex, split and use cmp function which compares arrays correctly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def mycmp(v1,v2):\n c1=map(int,re.sub('(\\.0+)+\\Z','',v1).split('.'))\n c2=map(int,re.sub('(\\.0+)+\\Z','',v2).split('.'))\n return cmp(c1,c2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["and of course you can convert it to a one-liner if you don't mind the long lines"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n def compare_version(v1, v2):\n    return cmp(*tuple(zip(*map(lambda x, y: (x or 0, y or 0), \n           [int(x) for x in v1.split('.')], [int(y) for y in v2.split('.')]))))\n</code>\n</pre>\n", "senID": 0}, {"text": ["It's a one liner (split for legability).", "Not sure about readable..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The most difficult to read solution, but a one-liner nevertheless!", "and using iterators to be fast."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n next((c for c in imap(lambda x,y:cmp(int(x or 0),int(y or 0)),\n            v1.split('.'),v2.split('.')) if c), 0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["that is for Python2.6 and 3.+ btw, Python 2.5 and older need to catch the StopIteration."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["My preferred solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Padding the string with extra zeroes and just using the four first is easy to understand,\ndoesn't require any regex and the lambda is more or less readable.", "I use two lines for readability, for me elegance is short and simple. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def mycmp(version1,version2):\n  tup = lambda x: [int(y) for y in (x+'.0.0.0.0').split('.')][:4]\n  return cmp(tup(version1),tup(version2))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["This is my solution (written in C, sorry).", "I hope you'll find it useful"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n int compare_versions(const char *s1, const char *s2) {\n    while(*s1 &amp;&amp; *s2) {\n        if(isdigit(*s1) &amp;&amp; isdigit(*s2)) {\n            /* compare as two decimal integers */\n            int s1_i = strtol(s1, &amp;s1, 10);\n            int s2_i = strtol(s2, &amp;s2, 10);\n\n            if(s1_i != s2_i) return s1_i - s2_i;\n        } else {\n            /* compare as two strings */\n            while(*s1 &amp;&amp; !isdigit(*s1) &amp;&amp; *s2 == *s1) {\n                s1++;\n                s2++;\n            }\n\n            int s1_i = isdigit(*s1) ? 0 : *s1;\n            int s2_i = isdigit(*s2) ? 0 : *s2;\n\n            if(s1_i != s2_i) return s1_i - s2_i;\n        }\n    }\n\n    return 0;\n}\n</code>\n</pre>\n", "senID": 1}]]