[[{"text": ["sympy does close to what you want"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sympy", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "sympy", "tag": "a"}]}, {"href": "http://code.google.com/p/sympy/", "text": "sympy", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import sympy\n&gt;&gt;&gt; a,b,c = sympy.symbols('abc')\n&gt;&gt;&gt; 5*a+6*b + 2*a+9*b+9*c\n7*a + 9*c + 15*b\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could either use sympy:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import sympy\n&gt;&gt;&gt; from sympy import *\n&gt;&gt;&gt; a = Symbol('a')\n&gt;&gt;&gt; b = Symbol('b')\n&gt;&gt;&gt; c = Symbol('c')\n&gt;&gt;&gt; eval('5*a+6*b')\n5*a + 6*b\n&gt;&gt;&gt; eval('5*a+6*b') + eval('2*a+3*b+9*c')\n7*a + 9*b + 9*c\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or write a simple parser:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; input1 = '5a+6b'\n&gt;&gt;&gt; input2 = '2a+3b+9c'\n&gt;&gt;&gt; s = \"+\".join((input1, input2))\n&gt;&gt;&gt; s\n'5a+6b+2a+3b+9c'\n&gt;&gt;&gt; d = {}\n&gt;&gt;&gt; for i in s.split(\"+\"):\n...     d[i[-1]] = d.get(i[-1], 0) + int(i[:-1])\n... \n&gt;&gt;&gt; d\n{'a': 7, 'c': 9, 'b': 9}\n&gt;&gt;&gt; \"+\".join(\"\".join((str(j),i)) for i, j in d.items())\n'7a+9c+9b'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["For python2.7+"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import Counter\n&gt;&gt;&gt; input1 = '5a+6b'\n&gt;&gt;&gt; input2 = '2a+3b+9c'\n&gt;&gt;&gt; c=Counter()\n&gt;&gt;&gt; for inp in input1, input2:\n...     c+=Counter({x[-1]:int(x[:-1]) for x in inp.split('+')})\n... \n&gt;&gt;&gt; '+'.join(\"%s%s\"%(v,k) for k,v in sorted(c.items()))\n'7a+9b+9c'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It depends on what types of expressions you want to support.", "If there are to be parenthesis and other constructs, this turns into standard expression parsing - lexical analysis and syntactic analysis.", "You can just construct appropriate abstract syntax tree and provide suitable rules for evaluation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Not knowing what you've already got, I'll just post a description of how I would approach this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["1) The following could be used (assumption: single letters):"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "1)", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n d = {}\nfor e in input1.split(\"+\"):\n    d[e[:-1]] = e[-1]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["if you are willing to sacrifice a bit of speed for a massive control gain, I'd suggest regular expressions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from re import findall\n\ndef make_poly(s):\n    m = findall('([+-]?[0-9.]+)([a-z]+)', s)\n    return dict([(i[1], float(i[0])) for i in m])\n\ndef add_polys(*polys):\n    res = {}\n    for poly in polys:\n        for item in poly.iteritems():\n            if res.has_key(item[0]):\n                res[item[0]] += item[1]\n            else:\n                res[item[0]] = item[1]\n    return res\n\n&gt;&gt;&gt; p1 = make_poly('4x+7y+3.5z')\n&gt;&gt;&gt; p1\n{'y': 7.0, 'x': 4.0, 'z': 3.5}\n&gt;&gt;&gt; p2 = make_poly('-2x+1y+0.2z')\n&gt;&gt;&gt; p2\n{'y': 1.0, 'x': -2.0, 'z': 0.2}\n&gt;&gt;&gt; \n&gt;&gt;&gt; add_polys(p1, p2)\n{'y': 8.0, 'x': 2.0, 'z': 3.7}\n</code>\n</pre>\n", "senID": 1}, {"text": ["It still needs some tinkering for edge-cases and mal-formed user input but it works so far"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]