[[{"text": ["It sure does -- it just doesn't implicitly generate a new metaclass for every class: it uses the same metaclass as the parent class, or type by default.", "Python's design philosophy, aka \"The Zen of Python\", can be perused by doing import this at an interactive interpreter's prompt; the applicable point here is the second one, \"Explicit is better than implicit."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "import this", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In Python 2.X, you specify a custom metaclass with the following syntax:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class sic:\n  __metaclass__ = mymeta\n  ...\n</code>\n</pre>\n", "senID": 2}, {"text": ["In Python 3.X, more elegantly, you use named-argument syntax:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class sify(metaclass=mymeta):\n  ...\n</code>\n</pre>\n", "senID": 4}, {"text": ["Python's generators are first-class (typically standalone) functions, and Smalltalk doesn't have the concept of \"standalone\" functions -- it has methods inside classes.", "But it certainly does have iterators -- as classes, of course:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n iterator := aCollection iterator.\n[iterator hasNext] whileTrue: [iterator next doSomething].\n</code>\n</pre>\n", "senID": 6}, {"text": ["Since Smalltalk has first-class \"code blocks\" (Ruby took them from it), you accomplish iteration, just like other \"control structures\", by sending a code block to a suitable method, and if you wish you can do that directly with the collection (think select:):"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "select:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n aCollection select: [:item | item doSomething].\n</code>\n</pre>\n", "senID": 8}, {"text": ["So in Smalltalk (and Ruby) you send the code block to the iteration; Python does things the other way round, the iteration sends values out to the surrounding \"calling\" code.", "Looks very different, but not \"deeply\" different in the end."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["First-class code blocks mean that Smalltalk doesn't need nor have \"control structure\" statements and keywords such as if or while: they can be accomplished by sending code blocks as arguments of appropriate methods (e.g.", "ifTrue: method of booleans).", "(Ruby chooses to have the keywords/statements in addition to the first-class code blocks; I would say that Python [[explicitly]] and Smalltalk [[implicitly]] both try, like C, to \"offer a single way to perform an operation\", while Ruby's more in the Perl-ish school of \"there are many ways to do it\")."], "childNum": 4, "tag": "p", "senID": 10, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "while", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "ifTrue:", "childNum": 0, "tag": "code", "childList": []}, {"text": "in addition", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["No, absolutely incorrect -- Python intensely does dynamic method dispatch, to extremes.", "Consider for example:"], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "intensely", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "to extremes", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n for i in range(10):\n  myobject.bah()\n</code>\n</pre>\n", "senID": 12}, {"text": ["By Python semantics, this performs 10 lookups for method bah in myobject -- just in case the previous execution of the method had caused myobject to entirely restructure itself internally so that its current bah method is completely different from the previous one (might be a pretty insane thing for the programmer to rely on such furious dynamism, but Python supports it).", "This is the reason that makes:"], "childNum": 7, "tag": "p", "senID": 13, "childList": [{"text": "10 lookups", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "bah", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "myobject", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "myobject", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "current", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "bah", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "previous", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n themethod = myobject.bah\nfor i in range(10):\n  themethod()\n</code>\n</pre>\n", "senID": 14}, {"text": ["a common hand-optimization in Python code -- does one dynamic lookup before the loop instead of 10 inside the loop, one per leg (it's a case of \"constant hoisting\", since the compiler is forbidden from doing the \"constant folding\" itself by Python's extreme rules for dynamic lookups -- unless it can prove that it's guaranteed to be innocuous, and in practice such proof is too hard so Python implementations typically don't bother)."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["Python uses unified namespaces: methods are attributes of an object just like any other, except that they're callable.", "This is why extracting the method without calling it (known as a \"bound method\"), setting a reference to it in a variable (or stashing it into a list or other container, returning it from a function, whatever) is a plain and simple operation like in the above constant-hoisting example."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["Smalltalk and Ruby have separate namespaces for methods and other attributes (in Smalltalk, non-methods attributes are not visible outside the object's own methods), so \"extracting a method\" and \"calling the resulting object\" require more introspective ceremony (but the common case of dispatching may be thereby made marginally simpler in certain cases -- in particular, \"just mentioning\" an argument-less method implicitly calls it, while in Python, like in C, calling is explicitly performed by appending parentheses, while \"just mentioning\", well... \"just mentions\" it, making it available for any sort of explicit operation including calling;-)."], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "including", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Python certainly does have metaclasses."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Smalltalk has some unusual features:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Has a rather simple syntax and only about 6 (!) keywords. Everything else (including defining new classes) is accomplished by calling methods (sending messages in Smalltalk). This allows you to create some DSL within the language.", "tag": "none", "senID": 2}, {"text": "In Smalltalk, you don't store source files, but instead have one big memory image and you modify it on the fly. You can also modify most of the Smalltalk itself (and possibly break it ;)", "tag": "none", "senID": 3}]}], [{"text": ["I've been reading coders at work which is a really nice book full of interviews with top programmers.", "Anyhow, one of them is the inventor of smalltalk and he talks in length on his language and how it relates to python (he likes python quite a bit as well).", "The only problem he had with python was it's slow code... he really wanted to have the smalltalk jit compiler as a backend for python, but unfortunately due to the software belonging to the company he worked for, this was not possible."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "coders at work", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://rads.stackoverflow.com/amzn/click/1430219483"}]}, {"text": ["anyhow... maybe not a point by point comparison, but really a good read anyway this book."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["According to Wikipedia's page on dynamic method dispatch:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Wikipedia", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Dynamic%5Fdispatch"}]}, {"text": ["Emphasis added, and one paragraph snipped.", "So, at least that part seems to be similar between the two languages."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["True, but they can be implemented in most Smalltalk dialects from within the language.", "GNU Smalltalk comes with Generators as part of its stream library."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "stream library", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://smalltalk.gnu.org/faq/47"}]}], [{"text": ["With regard to the last post by reinier, I just read coders at work, the interview was with don ingalls, who was the implementer of smalltalk, rather than the inventor.", "The inventor is Alan Kay. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]