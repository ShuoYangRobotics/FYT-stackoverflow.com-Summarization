[[{"text": ["That's because json has no difference between string objects and unicode objects.", "They're all strings in javascript."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I think JSON is right to return unicode objects.", "In fact, I wouldn't accept anything less, since javascript strings are in factunicodeobjects (i.e.", "JSON (javascript) strings can store any kind of unicode character) so it makes sense to create unicode objects when translating strings from JSON.", "Plain strings just wouldn't fit since the library would have to guess the encoding you want."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "JSON is right to return unicode objects", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "are in factunicodeobjects", "childNum": 1, "tag": "strong", "pos": 1, "childList": [{"text": "unicode", "tag": "code"}]}, {"text": "unicode", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "any kind", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "unicode", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["It's better to use unicode string objects everywhere.", "So your best option is to update your libraries so they can deal with unicode objects."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "unicode", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["But if you really want bytestrings, just encode the results to the encoding of your choice:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; nl = json.loads(js)\n&gt;&gt;&gt; nl\n[u'a', u'b']\n&gt;&gt;&gt; nl = [s.encode('utf-8') for s in nl]\n&gt;&gt;&gt; nl\n['a', 'b']\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You can use the object_hook parameter for json.loads to pass in a converter.", "You don't have to do the conversion after the fact.", "The json module will always pass the object_hook dicts only, and it will recursively pass in nested dicts, so you don't have to recurse into nested dicts yourself.", "I don't think I would convert unicode strings to numbers like Wells shows.", "If it's a unicode string, it was quoted as a string in the JSON file, so it is supposed to be a string (or the file is bad)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "json.loads", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/json.html#json.loads"}, {"text": "json", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/json.html"}]}, {"text": ["Also, I'd try to avoid doing something like str(val) on an unicode object.", "You should use value.encode(encoding) with a valid encoding, depending on what your external lib expects."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So, for example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def _decode_list(data):\n    rv = []\n    for item in data:\n        if isinstance(item, unicode):\n            item = item.encode('utf-8')\n        elif isinstance(item, list):\n            item = _decode_list(item)\n        elif isinstance(item, dict):\n            item = _decode_dict(item)\n        rv.append(item)\n    return rv\n\ndef _decode_dict(data):\n    rv = {}\n    for key, value in data.iteritems():\n        if isinstance(key, unicode):\n           key = key.encode('utf-8')\n        if isinstance(value, unicode):\n           value = value.encode('utf-8')\n        elif isinstance(value, list):\n           value = _decode_list(value)\n        elif isinstance(value, dict):\n           value = _decode_dict(value)\n        rv[key] = value\n    return rv\n\nobj = json.loads(s, object_hook=_decode_dict)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I'm afraid there's no way to achieve this automatically within the simplejson library."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The scanner and decoder in simplejson are designed to produce unicode text.", "To do this, the library uses a function called c_scanstring (if it's available, for speed), or py_scanstring if the C version is not available.", "The scanstring function is called several times by nearly every routine that simplejson has for decoding a structure that might contain text.", "You'd have to either monkeypatch the scanstring value in simplejson.decoder, or subclass JSONDecoder and provide pretty much your own entire implementation of anything that might contain text."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "c_scanstring", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "py_scanstring", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "scanstring", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "scanstring", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "JSONDecoder", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The reason that simplejson outputs unicode, however, is that the json spec specifically mentions that \"A string is a collection of zero or more Unicode characters\"... support for unicode is assumed as part of the format itself.", "Simplejson's scanstring implementation goes so far as to scan and interpret unicode escapes (even error-checking for malformed multi-byte charset representations), so the only way it can reliably return the value to you is as unicode."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "json spec", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.json.org/"}, {"text": "scanstring", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If you have an aged library that needs an str, I recommend you either laboriously search the nested data structure after parsing (which I acknowledge is what you explicitly said you wanted to avoid... sorry), or perhaps wrap your libraries in some sort of facade where you can massage the input parameters at a more granular level.", "The second approach might be more manageable than the first if your data structures are indeed deeply nested."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This is late to the game, but I built this recursive caster.", "It works for my needs and I think it's relatively complete.", "It may help you."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def _parseJSON(self, obj):\n\tnewobj = {}\n\n\tfor key, value in obj.iteritems():\n\t\tkey = str(key)\n\n\t\tif isinstance(value, dict):\n\t\t\tnewobj[key] = self._parseJSON(value)\n\t\telif isinstance(value, list):\n\t\t\tif key not in newobj:\n\t\t\t\tnewobj[key] = []\n\t\t\t\tfor i in value:\n\t\t\t\t\tnewobj[key].append(self._parseJSON(i))\n\t\telif isinstance(value, unicode):\n\t\t\tval = str(value)\n\t\t\tif val.isdigit():\n\t\t\t\tval = int(val)\n\t\t\telse:\n\t\t\t\ttry:\n\t\t\t\t\tval = float(val)\n\t\t\t\texcept ValueError:\n\t\t\t\t\tval = str(val)\n\t\t\tnewobj[key] = val\n\n\treturn newobj\n</code>\n</pre>\n", "senID": 1}, {"text": ["Just pass it a JSON object like so:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n obj = json.loads(content, parse_float=float, parse_int=int)\nobj = _parseJSON(obj)\n</code>\n</pre>\n", "senID": 3}, {"text": ["I have it as a private member of a class, but you can repurpose the method as you see fit."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["So, I've run into the same problem.", "Guess what was the first Google result."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Because I need to pass all data to PyGTK, unicode strings aren't very useful to me either.", "So I have another recursive conversion method.", "It's actually also needed for typesafe JSON conversion - json.dump() would bail on any non-literals, like Python objects.", "Doesn't convert dict indexes though."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # removes any objects, turns unicode back into str\ndef filter_data(obj):\n        if type(obj) in (int, float, str, bool):\n                return obj\n        elif type(obj) == unicode:\n                return str(obj)\n        elif type(obj) in (list, tuple, set):\n                obj = list(obj)\n                for i,v in enumerate(obj):\n                        obj[i] = filter_data(v)\n        elif type(obj) == dict:\n                for i,v in obj.iteritems():\n                        obj[i] = filter_data(v)\n        else:\n                print \"invalid object in data, converting to string\"\n                obj = str(obj) \n        return obj\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The gotcha is that simplejson and json are two different modules, at least in the manner they deal with unicode.", "You have json in py 2.6+, and this gives you unicode values, whereas simplejson returns string objects.", "Just try easy_install-ing simplejson in your environment and see if that works.", "It did for me."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "simplejson", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "json", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "json", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "simplejson", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["I ran into this problem too, and having to deal with JSON, I came up with a small loop that converts the unicode keys to strings.", "(Simplejson on GAE does not return string keys)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["obj is the object decoded from json"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if NAME_CLASS_MAP.has_key(cls):\n                kwargs = {}\n                for i in obj.keys():\n                    kwargs[str(i)] = obj[i]\n                o = NAME_CLASS_MAP[cls](**kwargs)\n                o.save()\n</code>\n</pre>\n", "senID": 2}, {"text": ["kwargs is what I pass to the constructor of the GAE application (which does not like unicode keys in **kwargs)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Not as robust as the solution from Wells, but much smaller."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]