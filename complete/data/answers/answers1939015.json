[[{"text": ["You can create a standard iterator object, it just won't be as convenient as the generator; you need to store the iterator's state on the instace (so that it is pickled), and define a next() function to return the next object:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class TrainExampleIterator (object):\n    def __init__(self):\n        # set up internal state here\n        pass\n    def next(self):\n        # return next item here\n        pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["The iterator protocol is simple as that, defining the .next() method on an object is all you need to pass it to for loops etc."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": ".next()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In Python 3, the iterator protocol uses the __next__ method instead (somewhat more consistent)."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "__next__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The following code should do more-or-less what you want.", "The first class defines something that acts like a file but can be pickled.", "(When you unpickle it, it re-opens the file, and seeks to the location where it was when you pickled it).", "The second class is an iterator that generates word windows."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class PickleableFile(object):\n    def __init__(self, filename, mode='rb'):\n        self.filename = filename\n        self.mode = mode\n        self.file = open(filename, mode)\n    def __getstate__(self):\n        state = dict(filename=self.filename, mode=self.mode,\n                     closed=self.file.closed)\n        if not self.file.closed:\n            state['filepos'] = self.file.tell()\n        return state\n    def __setstate__(self, state):\n        self.filename = state['filename']\n        self.mode = state['mode']\n        self.file = open(self.filename, self.mode)\n        if state['closed']: self.file.close()\n        else: self.file.seek(state['filepos'])\n    def __getattr__(self, attr):\n        return getattr(self.file, attr)\n\nclass WordWindowReader:\n    def __init__(self, filenames, window_size):\n        self.filenames = filenames\n        self.window_size = window_size\n        self.filenum = 0\n        self.stream = None\n        self.filepos = 0\n        self.prevwords = []\n        self.current_line = []\n\n    def __iter__(self):\n        return self\n\n    def next(self):\n        # Read through files until we have a non-empty current line.\n        while not self.current_line:\n            if self.stream is None:\n                if self.filenum &gt;= len(self.filenames):\n                    raise StopIteration\n                else:\n                    self.stream = PickleableFile(self.filenames[self.filenum])\n                    self.stream.seek(self.filepos)\n                    self.prevwords = []\n            line = self.stream.readline()\n            self.filepos = self.stream.tell()\n            if line == '':\n                # End of file.\n                self.stream = None\n                self.filenum += 1\n                self.filepos = 0\n            else:\n                # Reverse line so we can pop off words.\n                self.current_line = line.split()[::-1]\n\n        # Get the first word of the current line, and add it to\n        # prevwords.  Truncate prevwords when necessary.\n        word = self.current_line.pop()\n        self.prevwords.append(word)\n        if len(self.prevwords) &gt; self.window_size:\n            self.prevwords = self.prevwords[-self.window_size:]\n\n        # If we have enough words, then return a word window;\n        # otherwise, go on to the next word.\n        if len(self.prevwords) == self.window_size:\n            return self.prevwords\n        else:\n            return self.next()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This may not be an option for you, but Stackless Python (http://stackless.com) does allow you to pickle things like functions and generators, under certain conditions.", "This will work:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "http://stackless.com", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackless.com"}, {"text": "does", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["In foo.py:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def foo():\n    with open('foo.txt') as fi:\n        buffer = fi.read()\n    del fi\n    for line in buffer.split('\\n'):\n        yield line\n</code>\n</pre>\n", "senID": 2}, {"text": ["In foo.txt:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n line1\nline2\nline3\nline4\nline5\n</code>\n</pre>\n", "senID": 4}, {"text": ["In the interpreter:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n Python 2.6 Stackless 3.1b3 060516 (python-2.6:66737:66749M, Oct  2 2008, 18:31:31) \nIPython 0.9.1 -- An enhanced Interactive Python.\n\nIn [1]: import foo\n\nIn [2]: g = foo.foo()\n\nIn [3]: g.next()\nOut[3]: 'line1'\n\nIn [4]: import pickle\n\nIn [5]: p = pickle.dumps(g)\n\nIn [6]: g2 = pickle.loads(p)\n\nIn [7]: g2.next()\nOut[7]: 'line2'\n</code>\n</pre>\n", "senID": 6}, {"text": ["Some things to note: you must buffer the contents of the file, and delete the file object.", "This means that the contents of the file will be duplicated in the pickle."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "must", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["You might also consider using NLTK's corpus readers:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["http://nltk.googlecode.com/svn/trunk/doc/api/nltk.corpus.reader-module.html"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["http://nltk.googlecode.com/svn/trunk/doc/howto/corpus.html"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}]}, {"text": ["-Edward"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I describe this method in more depth, with sample code, here."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://blog.metaoptimize.com/2009/12/22/why-cant-you-pickle-generators-in-python-workaround-pattern-for-saving-training-state/"}]}], [{"text": ["You can try create callable object:  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class TrainExampleGenerator:\n\n    def __call__(self):\n        for l in open(HYPERPARAMETERS[\"TRAIN_SENTENCES\"]):\n            prevwords = []\n            for w in string.split(l):\n                w = string.strip(w)\n                id = None\n                prevwords.append(wordmap.id(w))\n                if len(prevwords) &gt;= HYPERPARAMETERS[\"WINDOW_SIZE\"]:\n                    yield prevwords[-HYPERPARAMETERS[\"WINDOW_SIZE\"]:]\n\nget_train_example = TrainExampleGenerator()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now you can turn all state that needs to be saved into object fields and expose them to pickle.", "This is a basic idea and I hope this helps, but I haven't tried this myself yet."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["UPDATE:\nUnfortunately, I failed to deliver my idea.", "Provided example is not complete solution.", "You see, TrainExampleGenerator have no state.", "You must design this state and make it available for pickling.", "And __call__ method should use and modify that state so that to return generator which started from the position determined by object's state.", "Obviously, generator itself won't be pickle-able.", "But TrainExampleGenerator will be possible to pickle and you'll be able to recreate generator with it as if generator itself were pickled."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "TrainExampleGenerator", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__call__", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "TrainExampleGenerator", "childNum": 0, "tag": "code", "pos": 6, "childList": []}, {"text": "as if", "childNum": 0, "tag": "em", "childList": []}]}]]