[[{"text": ["the tokenize module defines a regexp called Name"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re, tokenize\nre.match(tokenize.Name,somestr)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n re.match(r'[a-z_]\\w*$', s, re.I)\n</code>\n</pre>\n", "senID": 0}, {"text": ["should do nicely.", "As far as I know there isn't any built-in method."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["In Python &lt; 3.0 this is quite easy, as you can't have unicode characters in identifiers.", "That should do the work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nimport keyword\n\ndef isidentifier(s):\n    if s in keyword.kwlist:\n        return False\n    return re.match(r'^[a-z_][a-z0-9_]*$', s, re.I) is not None\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Good answers so far.", "I'd write it like this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import keyword\nimport re\n\ndef isidentifier(candidate):\n    \"Is the candidate string an identifier in Python 2.x\"\n    is_not_keyword = candidate not in keyword.kwlist\n    pattern = re.compile(r'^[a-z_][a-z0-9_]*$', re.I)\n    matches_pattern = bool(pattern.match(candidate))\n    return is_not_keyword and matches_pattern\n</code>\n</pre>\n", "senID": 1}], [{"text": ["What I am using:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_valid_keyword_arg(k):\n    \"\"\"\n    Return True if the string k can be used as the name of a valid\n    Python keyword argument, otherwise return False.\n    \"\"\"\n    # Don't allow python reserved words as arg names\n    if k in keyword.kwlist:\n        return False\n    return re.match('^' + tokenize.Name + '$', k) is not None\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I've decided to take another crack at this, since there have been several good suggestions.", "I'll try to consolidate them.", "The following can be saved as a Python module and run directly from the command-line.", "If run, it tests the function, so is provably correct (at least to the extent that the documentation demonstrates the capability)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import keyword\nimport re\nimport tokenize\n\ndef isidentifier(candidate):\n    \"\"\"\n    Is the candidate string an identifier in Python 2.x\n    Return true if candidate is an identifier.\n    Return false if candidate is a string, but not an identifier.\n    Raises TypeError when candidate is not a string.\n\n    &gt;&gt;&gt; isidentifier('foo')\n    True\n\n    &gt;&gt;&gt; isidentifier('print')\n    False\n\n    &gt;&gt;&gt; isidentifier('Print')\n    True\n\n    &gt;&gt;&gt; isidentifier(u'Unicode_type_ok')\n    True\n\n    # unicode symbols are not allowed, though.\n    &gt;&gt;&gt; isidentifier(u'Unicode_content_\\u00a9')\n    False\n\n    &gt;&gt;&gt; isidentifier('not')\n    False\n\n    &gt;&gt;&gt; isidentifier('re')\n    True\n\n    &gt;&gt;&gt; isidentifier(object)\n    Traceback (most recent call last):\n    ...\n    TypeError: expected string or buffer\n    \"\"\"\n    # test if candidate is a keyword\n    is_not_keyword = candidate not in keyword.kwlist\n    # create a pattern based on tokenize.Name\n    pattern_text = '^{tokenize.Name}$'.format(**globals())\n    # compile the pattern\n    pattern = re.compile(pattern_text)\n    # test whether the pattern matches\n    matches_pattern = bool(pattern.match(candidate))\n    # return true only if the candidate is not a keyword and the pattern matches\n    return is_not_keyword and matches_pattern\n\ndef test():\n    import unittest\n    import doctest\n    suite = unittest.TestSuite()\n    suite.addTest(doctest.DocTestSuite())\n    runner = unittest.TextTestRunner()\n    runner.run(suite)\n\nif __name__ == '__main__':\n    test()\n</code>\n</pre>\n", "senID": 1}]]