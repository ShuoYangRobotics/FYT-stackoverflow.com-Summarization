[[{"text": ["UTF-8 is an unicode encoding which uses more than one byte for special characters.", "If you don't want the length of the encoded string, simple decode it and use len() on the unicode object (and not the str object!", ")."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "len()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "unicode", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Here are some examples:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; # creates a str literal (with utf-8 encoding, if this was\n&gt;&gt;&gt; # specified on the beginning of the file):\n&gt;&gt;&gt; len('\u00eb\u0301a\u00falt') \n9\n&gt;&gt;&gt; # creates a unicode literal (you should generally use this\n&gt;&gt;&gt; # version if you are dealing with special characters):\n&gt;&gt;&gt; len(u'\u00eb\u0301a\u00falt') \n6\n&gt;&gt;&gt; # the same str literal (written in an encoded notation):\n&gt;&gt;&gt; len('\\xc3\\xab\\xcc\\x81a\\xc3\\xbalt') \n9\n&gt;&gt;&gt; # you can convert any str to an unicode object by decoding() it:\n&gt;&gt;&gt; len('\\xc3\\xab\\xcc\\x81a\\xc3\\xbalt'.decode('utf-8')) \n6\n</code>\n</pre>\n", "senID": 2}, {"text": ["Of course, you can also access single characters in an unicode object like you would do in a str object (they are both inheriting from basestring and therefore have the same methods):"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "unicode", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "childList": []}, {"text": "basestring", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; test = u'\u00eb\u0301a\u00falt'\n&gt;&gt;&gt; print test[0]\n\u00eb\n</code>\n</pre>\n", "senID": 4}, {"text": ["If you develop localized applications, it's generally a good idea to use only unicode-objects internally, by decoding all inputs you get.", "After the work is done, you can encode the result again as 'UTF-8'.", "If you keep to this principle, you will never see your server crashing because of any internal UnicodeDecodeErrors you might get otherwise ;)"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "unicode", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "UnicodeDecodeError", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["PS: Please note, that the str and unicode datatype have changed significantly in Python 3.", "In Python 3 there are only unicode strings and plain byte strings which can't be mixed anymore.", "That should help to avoid common pitfalls with unicode handling..."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "unicode", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Regards,\nChristoph"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Yes.", "That's how code points are defined by Unicode.", "In general, you can ask Python to convert a letter and a separate \u2018combining\u2019 diacritical mark like U+0301 COMBINING ACUTE ACCENT using Unicode normalisation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; unicodedata.normalize('NFC', u'a\\u0301')\nu'\\xe1' # single character: \u00e1\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, there is no single character in Unicode for \u201ce with diaeresis and acute accent\u201d because no language in the world has ever used the letter \u2018\u00eb\u0301\u2019.", "(Pinyin transliteration has \u201cu with diaeresis and acute accent\u201d, but not \u2018e\u2019.", ") Consequently font support is poor; it renders really badly in many cases and is a messy blob on my web browser."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["To work out where the \u2018editable points\u2019 in a string of Unicode code points are is a tricky job that requires quite a bit of domain knowledge of languages.", "It's part of the issue of \u201ccomplex text layout\u201d, an area which also includes issues such as bidirectional text and contextual glpyh shaping and ligatures.", "To do complex text layout you'll need a library such as Uniscribe on Windows, or Pango generally (for which there is a Python interface)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If, on the other hand, you merely want to completely ignore all combining characters when doing a count, you can get rid of them easily enough:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def withoutcombining(s):\n    return ''.join(c for c in s if unicodedata.combining(c)==0)\n\n&gt;&gt;&gt; withoutcombining(u'\u00eb\u0301a\u00falt')\n'\\xeba\\xfalt' # \u00eba\u00falt\n&gt;&gt;&gt; len(_)\n5\n</code>\n</pre>\n", "senID": 5}], [{"text": ["The best you can do is to use unicodedata.normalize() to decompose the character and then filter out the accents."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "unicodedata.normalize()", "tag": "a", "pos": 0, "childList": [{"text": "unicodedata.normalize()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/unicodedata.html#unicodedata.normalize"}, {"text": "unicodedata.normalize()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Don't forget to use unicode and unicode literals in your code."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "unicode", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Rather than guessing, let's work out why you're getting those results.", "Where are you getting the string from?", "If you're loading it from a file, what does it look like in binary?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It sounds like it could be due to combining characters - you may be able to normalize to a form which uses a single character for the combined glyph, but I don't think that's always possible."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "may", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "always", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["which Python version are you using?", "Python 3.1 doesn't have this issue."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print(len(\"\u00eb\u0301a\u00falt\"))\n6\n</code>\n</pre>\n", "senID": 1}, {"text": ["Regards\nDjoudi"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You said: I have a string \u00eb\u0301a\u00falt that I want to get the length of a manipulate based on character positions and so on.", "The problem is that the first \u00eb\u0301 is being counted twice, or I guess \u00eb is in position 0 and \u00b4 is in position 1."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The first step in working on any Unicode problem is to know exactly what is in your data; don't guess.", "In this case your guess is correct; it won't always be."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["\"Exactly what is in your data\": use the repr() built-in function (for lots more things apart from unicode).", "A useful advantage of showing the repr() output in your question is that answerers then have exactly what you have.", "Note that your text displays in only FOUR positions instead of 5 with some browsers/fonts -- the 'e' and its diacritics and the 'a' are mangled together in one position."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You can use the unicodedata.name() function to tell you what each component is."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Here's an example:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n # coding: utf8\nimport unicodedata\nx = u\"\u00eb\u0301a\u00falt\"\nprint(repr(x))\nfor c in x:\n    try:\n        name = unicodedata.name(c)\n    except:\n        name = \"&lt;no name&gt;\"\n    print \"U+%04X\" % ord(c), repr(c), name\n</code>\n</pre>\n", "senID": 5}, {"text": ["Results:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n u'\\xeb\\u0301a\\xfalt'\nU+00EB u'\\xeb' LATIN SMALL LETTER E WITH DIAERESIS\nU+0301 u'\\u0301' COMBINING ACUTE ACCENT\nU+0061 u'a' LATIN SMALL LETTER A\nU+00FA u'\\xfa' LATIN SMALL LETTER U WITH ACUTE\nU+006C u'l' LATIN SMALL LETTER L\nU+0074 u't' LATIN SMALL LETTER T\n</code>\n</pre>\n", "senID": 7}, {"text": ["Now read @bobince's answer :-)"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}]]