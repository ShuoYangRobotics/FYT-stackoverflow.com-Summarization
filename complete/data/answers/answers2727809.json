[[{"text": ["In Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def report_missing_numbers(f):\n    for line in f:\n        numbers = [int(n) for n in line.split()]\n        all_numbers = set(range(numbers[0], numbers[-1]))\n        missing = all_numbers - set(numbers)\n        yield missing\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note: all_numbers is a bit of a lie, since the range excludes the final number, but since that number is guaranteed to be in the set, it doesn't affect the correctness of the algorithm."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Note:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "all_numbers", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Note: I removed the [-1] from my original answer, since int(n) doesn't care about the trailing '\\n'."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "Note:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "[-1]", "childNum": 0, "tag": "code", "childList": []}, {"text": "int(n)", "childNum": 0, "tag": "code", "childList": []}, {"text": "'\\n'", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Perl:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n use Modern::Perl;\n\nfor my $line (&lt;DATA&gt;) {\n    chomp $line;\n    my @numbers     = split /\\s+/, $line;\n    my ($min, $max) = (sort { $a &lt;=&gt; $b } @numbers)[0, -1];\n    my @missing     = grep { not $_ ~~ @numbers } $min .. $max;\n    say join \" \", @missing;\n}\n\n__DATA__\n673 673 673 676 676 680\n2667 2667 2668 2670 2671 2674\n</code>\n</pre>\n", "senID": 1}, {"text": ["/I3az/"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for line in open(\"inputfile.txt\"):\n    vals = set(map(int, line.split()))\n    minv, maxv = min(vals), max(vals)\n    missing = [str(v) for v in xrange(minv + 1, maxv) if v not in vals]\n    print \" \".join(missing)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Sample code Using Perl: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/perl\nuse strict;\nuse warnings;\n\nmy @missing;\n\nwhile(&lt;DATA&gt;) {\n    my @data = split (/[ ]/, $_);\n    my $i = shift @data;\n    foreach (@data) {\n        if ($_ != ++$i) {\n               push @missing, $i .. $_ - 1;\n               $i = $_;\n        }\n    }\n}\n\nprint join \" \", @missing;\n\n__DATA__\n673 673 673 676 676 680\n2667 2667 2668 2670 2671 2674\n</code>\n</pre>\n", "senID": 1}, {"text": ["OUTPUT"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "OUTPUT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 674 675 677 678 679 2669 2672 2673\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Ruby:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $stdin.each_line do |line|\n  numbers = line.scan(/\\d+/).map(&amp;:to_i)\n  missing = (numbers.min..numbers.max).to_a - numbers\n  puts missing.join \" \"\nend\n</code>\n</pre>\n", "senID": 1}, {"text": ["Golf version (79 characters):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n puts $stdin.map{|l|n=l.scan(/\\d+/).map(&amp;:to_i);((n.min..n.max).to_a-n).join\" \"}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Pure Bash:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while read -a line ; do\n  firstvalue=${line[0]}\n  lastvalue=${line[${#line[@]}-1]}\n  output=()\n  # prepare the output array\n  for (( item=firstvalue; item&lt;=lastvalue; item++ )); do\n    output[$item]=1\n  done\n  # unset array elements with an index from the input set\n  for item in ${line[@]}; do\n    unset  \"output[$item]\"\n  done\n  # echo the remaining indices\n  echo -e \"${!output[@]}\"\ndone &lt; \"$infile\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Modification of Marcelo's solution with safe release of file handle in the event of an exception:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n with open('myfile.txt') as f:\n    numbers = [int(n) for n in f.readline()[:-1].split(' ')]\nall_numbers = set(range(numbers[0], numbers[-1]))\nmissing = all_numbers - set(numbers)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This also avoids using the builtin name file."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "file", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Shell solution using Bash, sort, uniq &amp; jot (Mac OS X):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n numbers=\"673 673 673 676 676 680\"\nnumbers=\"2667 2667 2668 2670 2671 2674\"\nsorted=($(IFS=$'\\n' echo \"${numbers}\" | tr \" \" '\\n' | sort -u ))\nlow=${sorted[0]}\nhigh=${sorted[@]: -1}\n( printf \"%s\\n\" \"${sorted[@]}\"; jot $((${high} - ${low} + 1)) ${low} ${high} ) | sort | uniq -u\n</code>\n</pre>\n", "senID": 1}], [{"text": ["bash solution:\ncat file_of_numbers| xargs -n2 seq | sort -nu"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}], [{"text": ["Perl oneliner:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n perl -lane'($a,$b)=@F[0,-1];$,=\" \";@h{@F}=();print grep!exists$h{$_},$a..$b'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In Perl:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/perl\n\nuse 5.010;\n\nfor (1..1000) {\n    say \"I will not ask the internet to do my homework\";\n}\n</code>\n</pre>\n", "senID": 1}]]