[[{"text": ["Use a DOM library, not regular expressions, when dealing with manipulating HTML:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 8, "lis": [{"text": "lxml: a parser, document, and HTML serializer. Also can use BeautifulSoup and html5lib for parsing.", "tag": "none", "senID": 1}, {"text": "BeautifulSoup: a parser, document, and HTML serializer.", "tag": "none", "senID": 2}, {"text": "html5lib: a parser. It has a serializer.", "tag": "none", "senID": 3}, {"text": "ElementTree: a document object, and XML serializer ", "tag": "none", "senID": 4}, {"text": "cElementTree: a document object implemented as a C extension. ", "tag": "none", "senID": 5}, {"text": "HTMLParser: a parser. ", "tag": "none", "senID": 6}, {"text": "Genshi: includes a parser, document, and HTML serializer.", "tag": "none", "senID": 7}, {"text": "xml.dom.minidom: a document model built into the standard library, which html5lib can parse to. ", "tag": "none", "senID": 8}]}, {"text": ["Stolen from http://blog.ianbicking.org/2008/03/30/python-html-parser-performance/."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "http://blog.ianbicking.org/2008/03/30/python-html-parser-performance/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://blog.ianbicking.org/2008/03/30/python-html-parser-performance/"}]}, {"text": ["Out of these I would recommend lxml, html5lib, and BeautifulSoup."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["Beautiful Soup or HTMLParser is your answer."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Beautiful Soup", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/"}, {"href": "http://docs.python.org/library/htmllib.html", "text": "HTMLParser", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Note that arbitrary replacements can't be done unambiguously.", "Consider the following examples:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["HTML:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n A&lt;tag&gt;B&lt;/tag&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["Pattern -> replacement:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n AB -&gt; AXB\n</code>\n</pre>\n", "senID": 4}, {"text": ["Possible results:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n AX&lt;tag&gt;B&lt;/tag&gt;\nA&lt;tag&gt;XB&lt;/tag&gt;\n</code>\n</pre>\n", "senID": 6}, {"text": ["HTML:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n A&lt;tag&gt;A&lt;/tag&gt;A\n</code>\n</pre>\n", "senID": 8}, {"text": ["Pattern -> replacement:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n A+ -&gt; WXYZ\n</code>\n</pre>\n", "senID": 10}, {"text": ["Possible results:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n W&lt;tag /&gt;XYZ\nW&lt;tag&gt;X&lt;/tag&gt;YZ\nW&lt;tag&gt;XY&lt;/tag&gt;Z\nW&lt;tag&gt;XYZ&lt;/tag&gt;\nWX&lt;tag /&gt;YZ\nWX&lt;tag&gt;Y&lt;/tag&gt;Z\nWX&lt;tag&gt;YZ&lt;/tag&gt;\nWXY&lt;tag /&gt;Z\nWXY&lt;tag&gt;Z&lt;/tag&gt;\nWXYZ\n</code>\n</pre>\n", "senID": 12}, {"text": ["What kind of algorithms work for your case depends highly on the nature of possible search patterns and desired rules for handling ambiguity."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["Use html parser such as provided by lxml or BeautifulSoup.", "Another option is to use XSLT transformations (XSLT in Jython)."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "lxml", "tag": "a", "pos": 0, "childList": [{"text": "lxml", "tag": "code"}], "childNum": 1, "href": "http://codespeak.net/lxml/"}, {"text": "lxml", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "BeautifulSoup", "tag": "a", "pos": -1, "childList": [{"text": "BeautifulSoup", "tag": "code"}], "childNum": 1, "href": "http://www.crummy.com/software/BeautifulSoup/"}, {"text": "BeautifulSoup", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "XSLT in Jython", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://jython.xhaus.com/transforming-with-xslt-on-google-appengine-and-jython/"}]}], [{"text": ["I don't think that the DOM / HTML parser library recommendations posted so far address the specific problem in the given example: overflow should replaced with underflow only when preceded by stack in the rendered document, whether or not there are tags between them.", "Such a library is a necessary part the solution, though."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "overflow", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "underflow", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "stack", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Assuming that tags never appear in the middle of words, one solution would be to"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In 1. the HTML DOM,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n stack &lt;sometag&gt;overflow&lt;/sometag&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["becomes the DOM"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n #1;stack &lt;sometag&gt;#2;overflow&lt;/sometag&gt;\n</code>\n</pre>\n", "senID": 5}, {"text": ["and in 2. the plain text is produced:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n #1;stack #2;overflow\n</code>\n</pre>\n", "senID": 7}, {"text": ["The regex needed in 3. is #(\\d+);stack\\s+#(\\d+);overflow\\b and the replacement #\\1;stack %\\2;underflow.", "Note that only the second word is marked by changing # to % in the unique identifier, since the first word isn't altered."], "childNum": 4, "tag": "p", "senID": 8, "childList": [{"text": "#(\\d+);stack\\s+#(\\d+);overflow\\b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "#\\1;stack %\\2;underflow", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "#", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "%", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In 4., the word underflow with the unique identifier numbered 2 is extracted from the resulting plain text since it was marked by changing the # to a %."], "childNum": 4, "tag": "p", "senID": 9, "childList": [{"text": "underflow", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "2", "childNum": 0, "tag": "code", "childList": []}, {"text": "#", "childNum": 0, "tag": "code", "childList": []}, {"text": "%", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In 5., all #(\\d+); identifiers are removed from text nodes of the DOM while looking up their numbers among extracted words.", "The number 1 is not found, so #1;stack is replaced with simply stack.", "The number 2 is found with the changed word underflow, so #2;overflow is replaced by underflow."], "childNum": 8, "tag": "p", "senID": 10, "childList": [{"text": "#(\\d+);", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "#1;stack", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "stack", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "2", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "underflow", "childNum": 0, "tag": "code", "childList": []}, {"text": "#2;overflow", "childNum": 0, "tag": "code", "childList": []}, {"text": "underflow", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Finally in 6. the DOM is rendered back to the HTML document `stack underflow."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["Fun stuff to try.", "It sorta works.", "My friends like it when I attach this script to a textarea and let them \"translate\" things.", "I guess you could use it for anything really.", "Meh.", "Check the code over a few times if you're going to use it, it works but I'm new to all this.", "I think it's been 2 or three weeks since I started studying the php."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &lt;?php\n\n$html = ('&lt;div style=\"border: groove 2px;\"&gt;&lt;p&gt;Dear so and so, after reviewing your application I. . .&lt;/p&gt;&lt;p&gt;More of the same...&lt;/p&gt;&lt;p&gt;sincerely,&lt;/p&gt;&lt;p&gt;Important Dude&lt;/p&gt;&lt;/div&gt;');\n\n$oldWords = array('important', 'sincerely');\n\n$newWords = array('arrogant', 'ya sure');\n\n// function for oldWords\nfunction regex_oldWords_word_list(&$item1, $key)\n{\n\n    $item1 = \"/&gt;([^&lt;&gt;]+)?\\b$item1(tionally|istic|tion|ance|ence|less|ally|able|ness|ing|ity|ful|ant|est|ist|ic|al|ed|er|et|ly|y|s|d|'s|'d|'ve|'ll)?\\b([^&lt;&gt;]+)?/\";\n\n}\n\n// function for newWords\nfunction format_newWords_results(&$item1, $key)\n{\n\n    $item1 = \"&gt;$1&lt;span style=\\\"color: red;\\\"&gt;&lt;em&gt; $item1$2&lt;/em&gt;&lt;/span&gt;$3\";\n\n}\n\n// apply regex to oldWords\narray_walk($oldWords, 'regex_oldWords_word_list');\n\n// apply formatting to newWords\narray_walk($newWords, 'format_newWords_results');\n\n//HTML is not always as perfect as we want it\n$poo = array('/  /', '/&gt;([a-zA-Z\\']+)/', '/&rsquo;/', '/;([a-zA-Z\\']+)/', '/\"([a-zA-Z\\']+)/', '/([a-zA-Z\\']+)&lt;/', '/\\.\\.+/', '/\\. \\.+/');\n\n$unpoo = array(' ', '&gt; $1', '\\'', ';  $1', '\"  $1', '$1  &lt;', '. crap taco.', '. crap taco with cheese.');\n\n//and maybe things will go back to normal sort of\n$repoo = array('/&gt;  /', '/;  /', '/\"  /', '/  &lt;/');\n\n$muck = array('&gt; ', ';', '\"',' &lt;');\n\n//before\necho ($html);\n\n//I don't know what was happening on the free host but I had to keep stripping slashes\n//This is where the work is done anyway.\n$html = stripslashes(preg_replace($repoo , $muck , (ucwords(preg_replace($oldWords , $newWords , (preg_replace($poo , $unpoo , (stripslashes(strtolower(stripslashes($html)))))))))));\n\n//after\necho ('&lt;hr/&gt; ' . $html);\n\n//now if only there were a way to keep it out of the area between\n//&lt;style&gt;here&lt;/style&gt; and &lt;script&gt;here&lt;/script&gt; and tell it that english isn't math.\n\n?&gt;\n</code>\n</pre>\n", "senID": 1}]]