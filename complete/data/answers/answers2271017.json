[[{"code": "<pre>\n<code>\n all([5 &lt; x, x &lt; y])\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n (5 &lt; x) &amp; (x &lt; y)\n</code>\n</pre>\n", "senID": 0}, {"text": ["By using the bit-and operator, &amp;, you get no short-circuiting behavior (as you get with and, or, chaining, all/any).", "Short-circuiting is normally deemed desirable (fast &amp;c) but it's not hard to do without it if you really want;-)."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "&amp;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "and", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "or", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "all", "childNum": 0, "tag": "code", "childList": []}, {"text": "any", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n>>> x = 3\n>>> y > x > 5\nTraceback (most recent call last):\n  File \"\", line 1, in \nNameError: name 'y' is not defined\n</pre>\n", "senID": 0}], [{"text": ["The most natural way would probably be to evaluate the expressions on prior lines. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = foo()\nb = bar()\nif a and b:\n    ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["as solutions like all([5 &lt; x, x &lt; y]) hide that the side effects are important and solutions using bitwise and (&amp;) seem subtle and misusing\u2014both of these would require a comment in your code to make it obvious you are forcing evaluation and will cause people reading your code to think What was he thinking???.", "Putting important calculations on their own lines makes more sense than hiding them within subtle, at-first-glance ugly code."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "all([5 &lt; x, x &lt; y])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "&amp;", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "What was he thinking???", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["Though my solution doesn't prevent a NameError if b does not exist (i.e., you have a typo) and a is false, this is something you should be able to figure out by reading your code and using a bugfinder if you choose."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "NameError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If it's just the possibility of programmer-error you want to preclude, eagerly evaluating expressions won't do much.", "For instance, mistakenly doing x or y() instead of x() or y()  won't be detected.", "Perhaps you're actually looking for tools like pylint, pyflakes or pychecker."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "x or y()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "x() or y()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "pylint", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.logilab.org/857"}, {"href": "http://divmod.org/trac/wiki/DivmodPyflakes", "text": "pyflakes", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://pychecker.sourceforge.net/", "text": "pychecker", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["If you are receiving the statement from the user and want to execute it with your own semantics, you should parse it yourself with a tool such as pyparsing.", "It is messy and insecure to evaluate someone else's code in the middle of yours, mixing their results with yours and it is confusing to evaluate what looks to be Python code but with different semantics."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pyparsing", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]