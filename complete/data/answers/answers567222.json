[[{"text": ["There are some problems:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Why do you print out count when it didn't divide by x? It doesn't mean it's prime, it means only that this particular x doesn't divide it", "tag": "none", "senID": 1}, {"text": ["continue"], "childNum": 0, "tag": "code", "senID": 2, "childList": []}]}, {"text": ["Here's your code with a few fixes, it prints out only primes:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import math\n\ndef main():\n    count = 3\n\n    while True:\n        isprime = True\n\n        for x in range(2, int(math.sqrt(count) + 1)):\n            if count % x == 0: \n                isprime = False\n                break\n\n        if isprime:\n            print count\n\n        count += 1\n</code>\n</pre>\n", "senID": 4}, {"text": ["For much more efficient prime generation, see the Sieve of Erastothenes, as others have suggested.", "Here's a nice, optimized implementation with many comments:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def gen_primes():\n    \"\"\" Generate an infinite sequence of prime numbers.\n    \"\"\"\n    # Maps composites to primes witnessing their compositeness.\n    # This is memory efficient, as the sieve is not \"run forward\"\n    # indefinitely, but only as long as required by the current\n    # number being tested.\n    #\n    D = {}  \n\n    # The running integer that's checked for primeness\n    q = 2  \n\n    while True:\n        if q not in D:\n            # q is a new prime.\n            # Yield it and mark its first multiple that isn't\n            # already marked in previous iterations\n            # \n            yield q        \n            D[q * q] = [q]\n        else:\n            # q is composite. D[q] is the list of primes that\n            # divide it. Since we've reached q, we no longer\n            # need it in the map, but we'll mark the next \n            # multiples of its witnesses to prepare for larger\n            # numbers\n            # \n            for p in D[q]:\n                D.setdefault(p + q, []).append(p)\n            del D[q]\n\n        q += 1\n</code>\n</pre>\n", "senID": 6}, {"text": ["Note that it returns a generator."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"code": "<pre>\n<code>\n def is_prime(num):\n    \"\"\"Returns True if the number is prime\n    else False.\"\"\"\n    if num == 0 or num == 1:\n        return False\n    for x in range(2, num):\n        if num % x == 0:\n            return False\n    else:\n        return True\n\n&gt;&gt; filter(is_prime, range(1, 20))\n  [2, 3, 5, 7, 11, 13, 17, 19]\n</code>\n</pre>\n", "senID": 0}, {"text": ["We will get all the prime numbers upto 20 in a list.", "I could have used Sieve of Eratosthenes but you said\nyou want something very simple.", ";)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This seems homework-y, so I'll give a hint rather than a detailed explanation.", "Correct me if I've assumed wrong."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You're doing fine as far as bailing out when you see an even divisor. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["But you're printing 'count' as soon as you see even one number that doesn't divide into it.", "2, for instance, does not divide evenly into 9.", "But that doesn't make 9 a prime.", "You might want to keep going until you're sure no number in the range matches."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "one", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "no", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["(as others have replied, a Sieve is a much more efficient way to go... just trying to help you understand why this specific code isn't doing what you want)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["There is a much more efficient, and pretty easy to code, way to do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Sieve_of_Eratosthenes"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Sieve_of_Eratosthenes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"}]}], [{"text": ["Here's a simple (Python 2.6.2) solution... which is in-line with the OP's original request (now six-months old); and should be a perfectly acceptable solution in any \"programming 101\" course...", "Hence this post."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "simple", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import math\n\ndef isPrime(n):\n    for i in range(2, int(math.sqrt(n)+1)):\n        if n % i == 0: \n            return False;\n    return True;\n\nprint 2\nfor n in range(3, 50):\n    if isPrime(n):\n        print n\n</code>\n</pre>\n", "senID": 1}, {"text": ["This simple \"brute force\" method is \"fast enough\" for numbers upto about about 16,000 on modern PC's (took about 8 seconds on my 2GHz box)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Obviously, this could be done much more efficiently, by not recalculating the primeness of every even number, or every multiple of 3, 5, 7, etc for every single number... See the Sieve of Eratosthenes (see eliben's implementation above), or even the Sieve of Atkin if you're feeling particularly brave and/or crazy."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Sieve of Eratosthenes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Sieve%5Fof%5FEratosthenes"}, {"href": "http://en.wikipedia.org/wiki/Sieve%5Fof%5FAtkin", "text": "Sieve of Atkin", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Caveat Emptor: I'm a python noob.", "Please don't take anything I say as gospel."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"tag": "ul", "num": 3, "lis": [{"text": ["The continue statement looks wrong."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You want to start at 2 because 2 is the first prime number."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can write \"while True:\" to get an infinite loop."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]}], [{"text": ["You need to make sure that all possible divisors don't evenly divide the number you're checking.", "In this case you'll print the number you're checking any time just one of the  possible divisors doesn't evenly divide the number."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also you don't want to use a continue statement because a continue will just cause it to check the next possible divisor when you've already found out that the number is not a prime."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Here is a good one."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "good one", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/576543/"}]}], [{"text": ["Here is what I have:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_prime(num):\n    if num &lt; 2:         return False\n    elif num &lt; 4:       return True\n    elif not num % 2:   return False\n    elif num &lt; 9:       return True\n    elif not num % 3:   return False\n    else:\n        for n in range(5, int(math.sqrt(num) + 1), 6):\n            if not num % n:\n                return False\n            elif not num % (n + 2):\n                return False\n\n    return True\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's pretty fast for large numbers, as it only checks against already prime numbers for divisors of a number."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Now if you want to generate a list of primes, you can do:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # primes up to 'max'\ndef primes_max(max):\n    yield 2\n    for n in range(3, max, 2):\n        if is_prime(n):\n            yield n\n\n# the first 'count' primes\ndef primes_count(count):\n    counter = 0\n    num = 3\n\n    yield 2\n\n    while counter &lt; count:\n        if is_prime(num):\n            yield num\n            counter += 1\n        num += 2\n</code>\n</pre>\n", "senID": 4}, {"text": ["using generators here might be desired for efficiency."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["And just for reference, instead of saying:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n one = 1\nwhile one == 1:\n    # do stuff\n</code>\n</pre>\n", "senID": 7}, {"text": ["you can simply say:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n while 1:\n    #do stuff\n</code>\n</pre>\n", "senID": 9}], [{"text": ["You can create a list of primes using list comprehensions in a fairly elegant manner.", "Taken from here:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here:", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.secnetix.de/~olli/Python/list%5Fcomprehensions.hawk"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; noprimes = [j for i in range(2, 8) for j in range(i*2, 50, i)]\n&gt;&gt;&gt; primes = [x for x in range(2, 50) if x not in noprimes]\n&gt;&gt;&gt; print primes\n&gt;&gt;&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n print [x for x in range(2,100) if not [t for t in range(2,x) if not x%t]]\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n def check_prime(x):\n\n    if(x&lt;2): return 0\n\n    elif(x==2): return 1\n\n    t=range(x)\n\n    for i in t[2:]:\n\n        if(x%i==0): return 0\n\n    return 1\n</code>\n</pre>\n", "senID": 0}], [{"text": ["How about this if you want to compute the prime directly:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def oprime(n):\ncounter = 0\nb = 1\nif n == 1:\n    print 2\nwhile counter &lt; n-1:\n    b = b + 2\n    for a in range(2,b):\n        if b % a == 0:\n            break\n    else:\n        counter = counter + 1\n        if counter == n-1:\n            print b\n</code>\n</pre>\n", "senID": 1}], [{"text": ["your problem is definition of primes"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]