[[{"text": ["It's hard, because the function can call itself in obfuscated ways.", "E.g., does this count?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def funA():\n  print 'A'\n  foo = funA\n  foo()\n\nfunA()\n</code>\n</pre>\n", "senID": 1}, {"text": ["What about this?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def funA():\n  funB()\n\ndef funB():\n  funA()\n\nfunA()\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or even this?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def funA():\n  exec('Anuf'[::-1] + '()')\n\nfunA()\n</code>\n</pre>\n", "senID": 5}, {"text": ["I don't think you can do it with a regex.  "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Even considering your new edits, it will still be very difficult if not impossible.", "Consider this function for example.  "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def funA():\n  if 1 + 1 == 2:\n    return\n  funA()\n</code>\n</pre>\n", "senID": 8}, {"text": ["I suggest you follow the advice of Ignacio Vazquez-Abrams and look at ast."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "ast", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/ast.html"}]}], [{"text": ["Simply put, you won't be able to do this with regex.", "You'll need to at least parse function definitions, keep some kind of state as to what function you are currently parsing, and search for the a call of the current function name within the scope of the current function."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["This is not possible to achieve with regular expressions, as Python is not a regular language.", "A better approach would be to utilize the ast module and recursion."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "ast", "tag": "a", "pos": 1, "childList": [{"text": "ast", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/dev/library/ast.html"}, {"text": "ast", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I'll describe the pattern that I think you want:  a line that starts with def, followed by whitespace, followed by a name (which you capture in parentheses), followed by a (possibly empty) set of lines that start with white space, followed by a line that starts with white space and contains your function name followed by an open paren (so that you capture an actual call, and not just a reference)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Yes I do believe that it would be impossible for a regex to match the cases pointed out by wim where the self call is obfuscated.", "However, here is a regex that will do a semi decent job for straightforward self calls (in the form funcname(...)).", "This regex correctly matches all the test cases spelled out in the original question:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "funcname(...)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n reobj = re.compile(r\"\"\"\n    # Match (unreliably) Python function with self reference.\n    ^                        # Anchor to start of line.\n    ([ \\t]*)                 # $1: Indentation of DEF statement.\n    def[ \\t]+                # Function definition.\n    ([^\\s(]+)                # $2: Name of function to find.\n    .*\\r?\\n                  # Remainder of function def line.\n    (?:                      # Zero or more lines w/o funcname.\n      (?:                    # Function block lines alternatives.\n        \\1[ \\t]+             # Func block lines have extra indentation.\n        (?:(?!\\b\\2\\s*\\().)*  # Optional non-funcname stuff on line\n      | [ \\t]*\\#.*           # Allow comment lines to defy indent rules.\n      )?                     # Allow blank lines in function block.\n      \\r?\\n                  # End of line not containing funcname.\n    )*                       # Zero or more lines w/o funcname\n    \\1[ \\t]+                 # Now match the line having funcname.\n    (?:(?!\\b\\2\\s*\\().)*      # Optional non-funcname stuff on line\n    \\b\\2\\s*\\(                # Match the function self reference.\n    \"\"\", re.MULTILINE | re.VERBOSE)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It matches starting with the function definition line and captures the whitespace indentation before the 'def' in group $1 and the function name in group $2.", "It then matches lines within the function block that do not contain the function name which each have more leading whitespace than the function definition.", "It skips over empty lines and lines containing only comments.", "It declares a match once it finds a line in the function block which has the function name followed by a left parentheses, indicating a call to itself.", "Otherwise, it declares a non-match then continues looking for the next possible match."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "'def'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "$1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "$2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Note that this solution is unreliable and will result in false positives if the name of the function occurs inside a string or inside a comment following other code on a line.", "It also does not handle functions with multi-line raw strings.", "However, it will correctly catch quite a few!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["may be you could use gawk, below is my sample code, you may need to modify it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #! /usr/bin/gawk -f\n{\n    currentLine = $0\n    if (currentLine ~ /def/){\n        inFunction = \"true\"\n        nameIndex = index($2,\"(\")\n        functionName = substr($2,1,nameIndex - 1)\n        #print functionName\n        next\n    }\n    if (inFunction == \"true\" &amp;&amp; currentLine ~ functionName){\n       inFunction = false \n       print \"recursive function is: \" functionName\n    }\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["just run the program you will get what you want."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]