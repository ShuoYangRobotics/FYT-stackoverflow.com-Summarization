[[{"text": ["This is the nicest way I can think of:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\nsum(map(operator.mul, topo[:-1], topo[1:]))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can use map and reduce like this, but I'm not convinced it's more pythonic:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "reduce", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n reduce( lambda x, y: x + y, map( lambda x, y: x * y, topo[:-1], topo[1:]) )\n</code>\n</pre>\n", "senID": 1}, {"text": ["Probably simpler is this sum + generator expression:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n sum(topo[x] * topo[x+1] for x in xrange(len(topo)-1))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This works:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n mult = lambda (x, y): x * y\npairs = zip(list(topo), list(topo)[1:])\nresult = sum(map(mult, pairs))\n</code>\n</pre>\n", "senID": 1}, {"text": ["but is probably harder to understand."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Instead of map using a list comprehension should work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; topo = (14,10,6,7,23,6)\n&gt;&gt;&gt; sum((x*y for x,y in zip(topo[:-1],topo[1:])))\n541\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sum((topo[i]*topo[i+1] for i in range(len(topo)-1)))\n541\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I wouldn't call this pythonic, though it looks cooler, reduce doesn't fit in here:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "reduce", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def func(first, *rest):\n    return reduce(lambda (x,y),z:(x+y*z,z), rest, (0,first))[0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note the usage of (x,y),z is 2.x only."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "(x,y),z", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["With reduce and Python &lt; 3.x:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import tee, izip\n\n#recipe from http://docs.python.org/library/itertools.html#recipes\ndef pairwise(iterable):\n    \"s -&gt; (s0,s1), (s1,s2), (s2, s3), ...\"\n    a, b = tee(iterable)\n    next(b, None)\n    return izip(a, b)\n\nreduce(lambda s, (x, y):s + x * y, pairwise(topo), 0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["with map:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from operator import mul\nfrom itertools import tee\n\na, b = tee(topo)\nnext(b, None)\n\nsum(map(mul, a, b))\n</code>\n</pre>\n", "senID": 3}]]