[[{"text": ["I am not sure what you are trying to do.", "You can implement a do-while loop like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while True:\n  stuff()\n  if fail_condition:\n    break\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n stuff()\nwhile not fail_condition:\n  stuff()\n</code>\n</pre>\n", "senID": 3}, {"text": ["What are you doing trying to use a do while loop to print the stuff in the list?", "Why not just use:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n for i in l:\n  print i\nprint \"done\"\n</code>\n</pre>\n", "senID": 5}, {"text": ["Update:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["So do you have a list of lines?", "And you want to keep iterating through it?", "How about: "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n for s in l: \n  while True: \n    stuff() \n    # use a \"break\" instead of s = i.next()\n</code>\n</pre>\n", "senID": 8}, {"text": ["Does that seem like something close to what you would want?", "With your code example, it would be:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n for s in some_list:\n  while True :\n    if state is STATE_CODE :\n      if \"//\" in s :\n        tokens.add( TOKEN_COMMENT, s.split( \"//\" )[1] )\n        state = STATE_COMMENT\n      else :\n        tokens.add( TOKEN_CODE, s )\n    if state is STATE_COMMENT :\n      if \"//\" in s :\n        tokens.append( TOKEN_COMMENT, s.split( \"//\" )[1] )\n        break # get next s\n      else\n        state = STATE_CODE\n        # re-evaluate same line\n        # continues automatically\n</code>\n</pre>\n", "senID": 10}], [{"text": ["Here's a very simple way to emulate a do-while loop:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n condition = True\nwhile (condition):\n    # loop body here\n    condition = test_loop_condition()\n# end of loop\n</code>\n</pre>\n", "senID": 1}, {"text": ["The key features of a do-while loop are that the loop body always executes at least once, and that the condition is evaluated at the bottom of the loop body.", "The control structure show here accomplishes both of these with no need for exceptions or break statements.", "It does introduce one extra Boolean variable."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Exception will break the loop, so you might as well handle it outside the loop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n  while True:\n    if s:\n      print s\n    s = i.next()\nexcept StopIteration:   \n  pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["I guess that the problem with your code is that behaviour of break inside except is not defined.", "Generally break goes only one level up, so e.g.", "break inside try goes directly to finally (if it exists) an out of the try, but not out of the loop."], "childNum": 7, "tag": "p", "senID": 2, "childList": [{"text": "break", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "except", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "break", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "break", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "try", "childNum": 0, "tag": "code", "childList": []}, {"text": "finally", "childNum": 0, "tag": "code", "childList": []}, {"text": "try", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Related PEP: http://www.python.org/dev/peps/pep-3136 \nRelated question: http://stackoverflow.com/questions/653509/breaking-out-of-nested-loops"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "http://www.python.org/dev/peps/pep-3136", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3136"}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"href": "http://stackoverflow.com/questions/653509/breaking-out-of-nested-loops", "text": "http://stackoverflow.com/questions/653509/breaking-out-of-nested-loops", "childNum": 0, "tag": "a", "childList": []}]}], [{"code": "<pre>\n<code>\n while condition is True: \n  stuff()\nelse:\n  stuff()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["for a do - while loop containing try statements"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n loop = True\nwhile (loop):\n    generic_stuff()\n    try:\n        questionable_stuff()\n#       to break from successful completion\n#       loop = False  \n    except:\n        optional_stuff()\n#       to break from unsuccessful completion - \n#       the case referenced in the OP's question\n        loop = False\n   finally:\n        more_generic_stuff()\n</code>\n</pre>\n", "senID": 1}, {"text": ["alternatively, when there's no need for the 'finally' clause"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n while (True):\n    generic_stuff()\n    try:\n        questionable_stuff()\n#       to break from successful completion\n#       break  \n    except:\n        optional_stuff()\n#       to break from unsuccessful completion - \n#       the case referenced in the OP's question\n        break\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n do {\n  stuff()\n} while (condition())\n</code>\n</pre>\n", "senID": 0}, {"text": ["->"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n while True:\n  stuff()\n  if not condition():\n    break\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can do a function:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def do_while(stuff, condition):\n  while condition(stuff()):\n    pass\n</code>\n</pre>\n", "senID": 4}, {"text": ["But\n1) It's ugly.", "2) Condition should be a function with one parameter, supposed to be filled by stuff (it's the only reason not to use the classic while loop."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["Here is a crazier solution of a different pattern -- using coroutines.", "The code is still very similar, but with one important difference; there are no exit conditions at all!", "The coroutine (chain of coroutines really) just stops when you stop feeding it with data."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def coroutine(func):\n    \"\"\"Coroutine decorator\n\n    Coroutines must be started, advanced to their first \"yield\" point,\n    and this decorator does this automatically.\n    \"\"\"\n    def startcr(*ar, **kw):\n        cr = func(*ar, **kw)\n        cr.next()\n        return cr\n    return startcr\n\n@coroutine\ndef collector(storage):\n    \"\"\"Act as \"sink\" and collect all sent in @storage\"\"\"\n    while True:\n        storage.append((yield))\n\n@coroutine      \ndef state_machine(sink):\n    \"\"\" .send() new parts to be tokenized by the state machine,\n    tokens are passed on to @sink\n    \"\"\" \n    s = \"\"\n    state = STATE_CODE\n    while True: \n        if state is STATE_CODE :\n            if \"//\" in s :\n                sink.send((TOKEN_COMMENT, s.split( \"//\" )[1] ))\n                state = STATE_COMMENT\n            else :\n                sink.send(( TOKEN_CODE, s ))\n        if state is STATE_COMMENT :\n            if \"//\" in s :\n                sink.send(( TOKEN_COMMENT, s.split( \"//\" )[1] ))\n            else\n                state = STATE_CODE\n                # re-evaluate same line\n                continue\n        s = (yield)\n\ntokens = []\nsm = state_machine(collector(tokens))\nfor piece in i:\n    sm.send(piece)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The code above collects all tokens as tuples in tokens and I assume there is no difference between .append() and .add() in the original code."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "tokens", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".append()", "childNum": 0, "tag": "code", "childList": []}, {"text": ".add()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Why don't you just do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for s in l :\n    print s\nprint \"done\"\n</code>\n</pre>\n", "senID": 1}, {"text": [], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Agree with Martin's answer, I think you want to rethink your need to have such a do-while loop.", "It's not very \"pythonic\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But for what it's worth, I tried to run your provided example code and it did work for me.", "I don't think there's technically anything wrong with it, strange that it didn't work for you.", "This is with Python 2.5 (and I tested with Python 2.4 too) anyway."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "did", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["See if this helps :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Set a flag inside the exception handler and check it before working on the s."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n flagBreak = false;\nwhile True :\n\nif(flagBreak ) break;\n\n  if s :\n    print s\n  try :\n    s = i.next()\n  except StopIteration :\n    flagBreak = true;\nprint \"done\"\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Your code looks fine to me.", "I tried running it in ipython and the output is as expected. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["How did you run it?", "Perhaps you are running it in some debugger that catches the StopIteration before you have the chance to catch it?", "What version of Python are you using?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]