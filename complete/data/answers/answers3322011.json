[[{"text": ["You've basically developed a filesystem version of the binary semaphore (or mutex).", "It's a well-studied structure used for locking, so as long as you get the implementation details right, it should work.", "The trick is to get the \"test and set\" operation, or in your case \"check existence and move,\" to be truly atomic.", "For that I'd use something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n lock_acquired = False\nwhile not lock_acquired:\n    try:\n        move(fh, fhtemp)\n    except:\n        sleep(3)\n    else:\n        lock_acquired = True\n# do your writing\nmove(fhtemp, fh)\nlock_acquired = False\n</code>\n</pre>\n", "senID": 1}, {"text": ["The program as you had it would work most of the time, but as mentioned you could have issues if another process moved the file between the check for its existence and the call to move.", "I suppose you could work around that, but I'd personally recommend sticking with a well-tested mutex algorithm.", "(I've translated/ported the above code sample from Modern Operating Systems by Andrew Tanenbaum, but it's possible that I've introduced errors in the conversion - just fair warning)"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "move", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Modern Operating Systems", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["By the way, the man page for the open function on Linux offers this solution for file locking:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "open", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["To implement that in Python, you could do something like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n # each instance of the process should have a different filename here\nprocess_lockfile = '/path/to/hostname.pid.lock'\n# all processes should have the same filename here\nglobal_lockfile = '/path/to/lockfile'\n# create the file if necessary (only once, at the beginning of each process)\nwith open(process_lockfile, 'w') as f:\n    f.write('\\n') # or maybe write the hostname and pid\n\n# now, each time you have to lock the file:\nlock_acquired = False\nwhile not lock_acquired:\n    try:\n        link(process_lockfile, global_lockfile)\n    except:\n        lock_acquired = (stat(process_lockfile).st_nlinks == 2)\n    else:\n        lock_acquired = True\n# do your writing\nunlink(global_lockfile)\nlock_acquired = False\n</code>\n</pre>\n", "senID": 5}], [{"text": ["File move/rename is generally an atomic operation on most OSes, so it is probably a workable solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You will want to add an exception check on your move and open calls, though, in case some other process moved the file between your existence check and the move (or if the move failed to complete)."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "move", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "open", "childNum": 0, "tag": "code", "childList": []}, {"text": "move", "childNum": 0, "tag": "code", "childList": []}, {"text": "move", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit"], "childNum": 0, "tag": "h2", "senID": 2, "childList": []}, {"text": ["To summarize the proper flow that will work:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["A good option for [myID] is the PID of the process (possibly also include the host, if running on multiple systems)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "[myID]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If you don't track your move calls to see if they succeeded or not, you'll never know if you fall victim to a timing window.", "Remember that if anything can go wrong it will, at the worst possible time."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "move", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "at the worst possible time", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["Rather than using the contents of the file as a flag, maybe you could use the filename itself?", "For each task rename the file \"task_waiting_to_run\" to \"task_running\" to \"task_complete\".", "If the rename from \"task_waiting_to_run\" to \"task_running\" fails, that means another box got there first."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["EDIT: It's also common practice to identify the process that renamed the file.", "That way, should the process die before restoring it to its original name, it would be possible to trace the file's ownership and determine whether to intervene."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I've inserted (barely tested) os and socket calls to add this functionality.", "Use at your own risk."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "os", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "socket", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["If two processes are competing to rename the file, then having them check for its existence first will not prevent a race condition; it will only delay the time when it occurs."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The docs for shutil.move are (sadly) not explicit about throwing an IOError if the file does not exist, but that seems a reasonable expectation -- and I found it does happen in practice:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "shutil.move", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/shutil.html#shutil.move"}]}, {"code": "<pre>\n<code>\n import shutil\nimport os\nimport socket\n\noldname = \"foobar.txt\"\nnewname = (oldname + \".\" + socket.gethostbyaddr(socket.gethostname())[0]\n           + \".\" + str(os.getpid()))\ni_win = True\ntry:\n    shutil.move(oldname, newname)\nexcept IOError, e:\n    print \"File does not exist\"\n    i_win = False\nexcept Exception, e:\n    print e\n    i_win = False\n\nif i_win:\n    print \"I got it!\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["This means that only one process can think it has succeeded in renaming the file. "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Seems to me you are putting too much effort to accomplish something that can be simple if you change your data structure.", "Right now you have a single file that contains list of the tasks."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["How about making the task queue a directory instead, where each pending task is a file?", "Then the process is as easy as picking a task from directory \"Pending\", moving it to directory (say) \"Running\" and after it is done, move the task file to directory \"Completed\".", "Since file move is atomic operation, there will be no race condition (if move fails, means another worker just snatched it first, so pick up next task)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "moving", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Also, checking the progress is as easy as issuing ls on one of the directories :-)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "ls", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Relying on network filesystems for locking is a problem that has plagued systems for years (and still often doesn't work quite how you expect it)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Why not use something designed to be explicitly multiuser and transactional, like a database system?", "(I like Postgres personally...)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It's probably a bit overkill, but the workings are generally easy to understand for something like this.", "It also makes it easier to expand to add new functionality later."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]