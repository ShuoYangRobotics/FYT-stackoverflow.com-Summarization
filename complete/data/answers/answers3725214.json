[[{"text": ["Short answer: Ruby encourages method chaining, Python doesn't."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Ruby encourages method chaining, Python doesn't.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I guess the right question is: What is Ruby's tap useful for?"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "tap", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Now I don't know a lot about Ruby, but by googling I got the impression that tap is conceptually useful as method chaining."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "tap", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In Ruby, the style: SomeObject.doThis().doThat().andAnotherThing() is quite idiomatic.", "It underlies the concept of fluent interfaces, for example.", "Ruby's tap is a special case of this where instead of having SomeObject.doThis() you define doThis on the fly."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "SomeObject.doThis().doThat().andAnotherThing()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fluent interfaces", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://martinfowler.com/bliki/FluentInterface.html"}, {"text": "tap", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "SomeObject.doThis()", "childNum": 0, "tag": "code", "childList": []}, {"text": "doThis", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Why I am explaining all this?", "Because it tells us why tap doesn't have good support in Python.", "With due caveats, Python doesn't do call chaining."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "tap", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Python doesn't do call chaining", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["For example, Python list methods generally return None rather than returning the mutated list.", "Functions like map and filter are not list methods.", "On the other hand, many Ruby array methods do return the modified array."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "filter", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Other than certain cases like some ORMs, Python code doesn't use fluent interfaces."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["In the end it is the difference between idiomatic Ruby and idiomatic Python.", "If you are going from one language to the other you need to adjust."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["You can implement it in Python as follows:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def tap(x, f):\n    f(x)\n    return x\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; tap([], lambda x: x.append(1))\n[1]\n</code>\n</pre>\n", "senID": 3}, {"text": ["However it won't be so much use in Python 2.x as it is in Ruby because lambda functions in Python are quite restrictive.", "For example you can't inline a call to print because it is a keyword, so you can't use it for inline debugging code.", "You can do this in Python 3.x although it isn't as clean as the Ruby syntax."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; tap(2, lambda x: print(x)) + 3\n2\n5\n</code>\n</pre>\n", "senID": 5}], [{"text": ["If you want this bad enough, you can create a context manager"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Tap(object):\n    def __enter__(self, obj):\n        return obj\n\n    def __exit__(*args):\n        pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["which you can use like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def foo():\n    with Tap([]) as a:\n        a.append(1)\n        return a\n</code>\n</pre>\n", "senID": 3}, {"text": ["There's no getting around the return statement and with really doesn't do anything here.", "But you do have Tap right at the start which clues you into what the function is about I suppose.", "It is better than using lambdas because you aren't limited to expressions and can have pretty much whatever you want in the with statement."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "return", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "with", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "Tap", "childNum": 0, "tag": "code", "childList": []}, {"text": "with", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Overall, I would say that if you want tap that bad, then stick with ruby and if you need to program in python, use python to write python and not ruby.", "When I get around to learning ruby, I intend to write ruby ;)"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "tap", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Hardly any Ruby programmers use tap in this way.", "In fact, all top Ruby programmers i know say tap has no use except in debugging."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "tap", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tap", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Why not just do this in your code?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n [].push(1)\n</code>\n</pre>\n", "senID": 2}, {"text": ["and remember Array supports a fluent interface, so you can even do this:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Array", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n [].push(1).push(2)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I had an idea to achieve this using function decorators, but due to the distinction in python between expressions and statements, this ended up still requiring the return to be at the end."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The ruby syntax is rarely used in my experience, and is far less readable than the explicit python approach.", "If python had implicit returns or a way to wrap multiple statements up into a single expression then this would be doable - but it has neither of those things by design."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here's my - somewhat pointless - decorator approach, for reference:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Tapper(object):\n    def __init__(self, initial):\n        self.initial = initial\n    def __call__(self, func):\n        func(self.initial)\n        return self.initial\n\ndef tap(initial):\n    return Tapper(initial)\n\nif __name__ == \"__main__\":\n    def tapping_example():\n        @tap([])\n        def tapping(t):\n            t.append(1)\n            t.append(2)\n        return tapping\n\n    print repr(tapping_example())\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I partly agree with others in that it doesn't make much sense to implement this in Python.", "However, IMHO, Mark Byers's way is the way, but why lambdas(and all that comes with them)?", "can't you write a separate function to be called when needed?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Another way to do basically the same could be "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n map(afunction(), avariable)\n</code>\n</pre>\n", "senID": 2}, {"text": ["but this beautiful feature is not a built-in in Python 3, I hear. "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "beautiful", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}]]