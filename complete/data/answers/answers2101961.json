[[{"text": ["I don't really get the question.", "The State Design pattern is pretty clear.", "See the Design Patterns book."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "State", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "Design Patterns book", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://rads.stackoverflow.com/amzn/click/0201633612"}]}, {"code": "<pre>\n<code>\n class SuperState( object ):\n    def someStatefulMethod( self ):\n        raise NotImplementedError()\n    def transitionRule( self, input ):\n        raise NotImplementedError()\n\nclass SomeState( SuperState ):\n    def someStatefulMethod( self ):\n        actually do something()\n    def transitionRule( self, input ):\n        return NextState()\n</code>\n</pre>\n", "senID": 1}, {"text": ["That's pretty common boilerplate, used in Java, C++, Python (and I'm sure other languages, also)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If your state transition rules happen to be trivial, there are some optimizations to push the transition rule itself into the superclass."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Note that we need to have forward references, so we refer to classes by name, and use eval to translate a class name to an actual class.", "The alternative is to make the transition rules instance variables instead of class variables and then create the instances after all the classes are defined."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "eval", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class State( object ):\n    def transitionRule( self, input ):\n        return eval(self.map[input])()\n\nclass S1( State ): \n    map = { \"input\": \"S2\", \"other\": \"S3\" }\n    pass # Overrides to state-specific methods\n\nclass S2( State ):\n    map = { \"foo\": \"S1\", \"bar\": \"S2\" }\n\nclass S3( State ):\n    map = { \"quux\": \"S1\" }\n</code>\n</pre>\n", "senID": 5}, {"text": ["In some cases, your event isn't as simple as testing objects for equality, so a more general transition rule is to use a proper list of function-object pairs."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n class State( object ):\n    def transitionRule( self, input ):\n        next_states = [ s for f,s in self.map if f(input)  ]\n        assert len(next_states) &gt;= 1, \"faulty transition rule\"\n        return eval(next_states[0])()\n\nclass S1( State ):\n    map = [ (lambda x: x == \"input\", \"S2\"), (lambda x: x == \"other\", \"S3\" ) ]\n\nclass S2( State ):\n    map = [ (lambda x: \"bar\" &lt;= x &lt;= \"foo\", \"S3\"), (lambda x: True, \"S1\") ]\n</code>\n</pre>\n", "senID": 7}, {"text": ["Since the rules are evaluated sequentially, this allows a \"default\" rule."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["In the April, 2009 issue of Python Magazine, I wrote an article on embedding a State DSL within Python, using pyparsing and imputil.", "This code would allow you to write the module trafficLight.pystate:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # trafficLight.pystate\n\n# define state machine\nstatemachine TrafficLight:\n    Red -&gt; Green\n    Green -&gt; Yellow\n    Yellow -&gt; Red\n\n# define some class level constants\nRed.carsCanGo = False\nYellow.carsCanGo = True\nGreen.carsCanGo = True\n\nRed.delay = wait(20)\nYellow.delay = wait(3)\nGreen.delay = wait(15)\n</code>\n</pre>\n", "senID": 1}, {"text": ["and the DSL compiler would create all the necessary TrafficLight, Red, Yellow, and Green classes, and the proper state transition methods.", "Code could call these classes using something like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import statemachine\nimport trafficLight\n\ntl = trafficLight.Red()\nfor i in range(6):\n    print tl, \"GO\" if tl.carsCanGo else \"STOP\"\n    tl.delay()\n    tl = tl.next_state()\n</code>\n</pre>\n", "senID": 3}, {"text": ["(Unfortunately, imputil has been dropped in Python 3."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["There is this design pattern for using decorators to implement state machines.", "From the description on the page: "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this design pattern", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/PythonDecoratorLibrary#StateMachineImplementaion"}]}, {"text": ["There is example code on the page as well (it is quite long so I won't paste it here)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I think S. Lott's answer is a much better way to implement a state machine, but if you still want to continue with your approach, using (state,event) as the key for your dict is better.", "Modifying your code:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "(state,event)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n class HandlerFsm(object):\n\n  _fsm = {\n    (\"state_a\",\"event\"): \"next_state\",\n    #...\n  }\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think that the tool PySCXML needs a closer look too.", "This project uses the W3C definition: State Chart XML (SCXML): State Machine Notation for Control Abstraction"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "PySCXML", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/pyscxml/"}, {"text": "State Chart XML (SCXML)", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.w3.org/TR/scxml/"}]}, {"text": ["Currently, SCXML is a working draft; but chances are quite high that it is getting a W3C recommendation soon (It is the 9th draft)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Another interesting point to highlight is that there is an Apache Commons project aimed at creating and maintaining a Java SCXML engine capable of executing a state machine defined using a SCXML document, while abstracting out the environment interfaces... \nAnd for certain other tools supporting this technology will emerge in future when SCXML is leaving it's draft-status..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I wouldn't think to reach for a finite state machine for handling XML.", "The usual way to do this, I think, is to use a stack:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class TrackInfoHandler(object):\n    def __init__(self):\n        self._stack=[]\n\n    ## ================================== Event callbacks\n\n    def startElement(self, name, attrs):\n        cls = self.elementClasses[name]\n        self._stack.append(cls(**attrs))\n\n    def characters(self, ch):\n        self._stack[-1].addCharacters(ch)\n\n    def endElement(self, name):\n        e = self._stack.pop()\n        e.close()\n        if self._stack:\n            self._stack[-1].addElement(e)\n</code>\n</pre>\n", "senID": 1}, {"text": ["For each kind of element, you just need a class that supports the addCharacters, addElement, and close methods."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "addCharacters", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "addElement", "childNum": 0, "tag": "code", "childList": []}, {"text": "close", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["EDIT: To clarify, yes I do mean to argue that finite state machines are usually the wrong answer, that as a general-purpose programming technique they're rubbish and you should stay away."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["There are a few really well-understood, cleanly-delineated problems for which FSMs are a nice solution.", "lex, for example, is good stuff."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "lex", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["That said, FSMs typically don't cope well with change.", "Suppose someday you want to add a bit of state, perhaps a \"have we seen element X yet?", "\" flag.", "In the code above, you add a boolean attribute to the appropriate element class and you're done.", "In a finite state machine, you double the number of states and transitions."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Problems that require finite state at first very often evolve to require even more state, like maybe a number, at which point either your FSM scheme is toast, or worse, you evolve it into some kind of generalized state machine, and at that point you're really in trouble.", "The further you go, the more your rules start to act like code\u2014but code in a slow interpreted language you invented that nobody else knows, for which there's no debugger and no tools."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "number", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["It probably depends on how complex your state machine is.", "For simple state machines, a dict of dicts (of event-keys to state-keys for DFAs, or event-keys to lists/sets/tuples of state-keys for NFAs) will probably be the simplest thing to write and understand."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For more complex state machines, I've heard good things about SMC, which can compile declarative state machine descriptions to code in a wide variety of languages, including Python."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "SMC", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://smc.sourceforge.net/"}]}], [{"text": ["Check this and this."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ibm.com/developerworks/linux/library/l-python-state.html"}, {"href": "http://www.ibm.com/developerworks/library/l-pygen.html", "text": "this", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["The following code is a really simple solution.", "The only interesting part is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def next_state(self,cls):\n      self.__class__ = cls\n</code>\n</pre>\n", "senID": 1}, {"text": ["All the logic for each state is contained in a separate class.", "The 'state' is changed by replacing the '__class__' of the running instance."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "__class__", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#instance.__class__"}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nclass State(object):\n   call = 0 # shared state variable\n   def next_state(self,cls):\n      print '-&gt; %s' % (cls.__name__,),\n      self.__class__ = cls\n\n   def show_state(self,i):\n      print '%2d:%2d:%s' % (self.call,i,self.__class__.__name__),\n\nclass State1(State):\n   __call = 0  # state variable\n   def __call__(self,ok):\n      self.show_state(self.__call)\n      self.call += 1\n      self.__call += 1\n      # transition\n      if ok: self.next_state(State2)\n      print '' # force new line\n\nclass State2(State):\n   __call = 0\n   def __call__(self,ok):\n      self.show_state(self.__call)\n      self.call += 1\n      self.__call += 1\n      # transition\n      if ok: self.next_state(State3)\n      else: self.next_state(State1)\n      print '' # force new line\n\nclass State3(State):\n   __call = 0\n   def __call__(self,ok):\n      self.show_state(self.__call)\n      self.call += 1\n      self.__call += 1\n      # transition\n      if not ok: self.next_state(State2)\n      print '' # force new line\n\nif __name__ == '__main__':\n   sm = State1()\n   for v in [1,1,1,0,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0]:\n      sm(v)\n   print '---------'\n   print vars(sm\n</code>\n</pre>\n", "senID": 3}, {"text": ["Result:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n 0: 0:State1 -&gt; State2 \n 1: 0:State2 -&gt; State3 \n 2: 0:State3 \n 3: 1:State3 -&gt; State2 \n 4: 1:State2 -&gt; State1 \n 5: 1:State1 \n 6: 2:State1 -&gt; State2 \n 7: 2:State2 -&gt; State3 \n 8: 2:State3 -&gt; State2 \n 9: 3:State2 -&gt; State3 \n10: 3:State3 \n11: 4:State3 -&gt; State2 \n12: 4:State2 -&gt; State1 \n13: 3:State1 -&gt; State2 \n14: 5:State2 -&gt; State1 \n15: 4:State1 \n16: 5:State1 -&gt; State2 \n17: 6:State2 -&gt; State1 \n18: 6:State1 \n---------\n{'_State1__call': 7, 'call': 19, '_State3__call': 5, '_State2__call': 7}\n</code>\n</pre>\n", "senID": 5}]]