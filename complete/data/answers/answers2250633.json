[[{"text": ["I suspect there are more pythonic ways of doing it, but at least it gets the job done:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l=list('abcdefgh')\npat=list('de')\n\nprint pat in l # Returns False\nprint any(l[i:i+len(pat)]==pat for i in xrange(len(l)-len(pat)+1))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Don't know if this is very pythonic, but I would do it in this way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_sublist(a, b):\n    if a == []: return True\n    if b == []: return False\n    return b[:len(a)] == a or is_sublist(a, b[1:])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Shorter solution is offered in this discussion, but it suffers from the same problems as solutions with set - it doesn't consider order of elements."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "discussion", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-list/2001-August/691027.html"}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["UPDATE:\nInspired by MAK I introduced more concise and clear version of my code."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["UPDATE:\nThere are performance concerns about this method, due to list copying in slices.", "Also, as it is recursive, you can encounter recursion limit for long lists.", "To eliminate copying, you can use Numpy slices which creates views, not copies.", "If you encounter performance or recursion limit issues you should use solution without recursion. "], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "Numpy", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.scipy.org/"}, {"text": "creates views, not copies", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.scipy.org/NumPy_for_Matlab_Users"}]}], [{"text": ["I think this will be faster - It uses C implementation list.index to search for the first element, and goes from there on."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "list.index", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def find_sublist(sub, bigger):\n    if not bigger:\n        return -1\n    if not sub:\n        return 0\n    first, rest = sub[0], sub[1:]\n    pos = 0\n    try:\n        while True:\n            pos = bigger.index(first, pos) + 1\n            if not rest or bigger[pos:pos+len(rest)] == rest:\n                return pos\n    except ValueError:\n        return -1\n\ndata = list('abcdfghdesdkflksdkeeddefaksda')\nprint find_sublist(list('def'), data)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that this returns the position of the sublist in the list, not just True or False.", "If you want just a bool you could use this:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "True", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "bool", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def is_sublist(sub, bigger): \n    return find_sublist(sub, bigger) &gt;= 0\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I timed the accepted solution, my earlier solution and a new one with an index.", "The one with the index is clearly best."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["EDIT: I timed nosklo's solution, it's even much better than what I came up with.", ":)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def is_sublist_index(a, b):\n    if not a:\n        return True\n\n    index = 0\n    for elem in b:\n        if elem == a[index]:\n            index += 1\n            if index == len(a):\n                return True\n        elif elem == a[0]:\n            index = 1\n        else:\n            index = 0\n\n    return False\n\ndef is_sublist(a, b):\n    return str(a)[1:-1] in str(b)[1:-1]\n\ndef is_sublist_copylist(a, b):\n    if a == []: return True\n    if b == []: return False\n    return b[:len(a)] == a or is_sublist_copylist(a, b[1:])\n\nfrom timeit import Timer\nprint Timer('is_sublist([99999], range(100000))', setup='from __main__ import is_sublist').timeit(number=100)\nprint Timer('is_sublist_copylist([99999], range(100000))', setup='from __main__ import is_sublist_copylist').timeit(number=100)\nprint Timer('is_sublist_index([99999], range(100000))', setup='from __main__ import is_sublist_index').timeit(number=100)\nprint Timer('sublist_nosklo([99999], range(100000))', setup='from __main__ import sublist_nosklo').timeit(number=100)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Output in seconds:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["4.51677298546"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["4.5824368"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["1.87861895561"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["0.357429027557"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["So, if you aren't concerned about the order the subset appears, you can do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a=list('abcdefghij')\nb=list('de')\nset(b).issubset(set(a))\n\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit after you clarify: If you need to preserve order, and the list is indeed characters as in your question, you can use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ''.join(a).find(''.join(b)) &gt; 0\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Not sure how complex your application is, but for pattern matching in lists, pyparsing is very smart and easy to use."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pyparsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.google.ie/url?sa=t&source=web&ct=res&cd=1&ved=0CAkQFjAA&url=http%3A%2F%2Fpyparsing.wikispaces.com%2F&ei=2x91S5fqHo3X4ga5qc3HCg&usg=AFQjCNHYfzwvzIxYKcHuYSR5TCAIrvtEqw&sig2=u82fak0P7La1jRKSxprfiQ"}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt;''.join(b) in ''.join(a)\n\nTrue\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Use the lists' string representation and remove the square braces.", ":)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_sublist(a, b):\n    return str(a)[1:-1] in str(b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: Right, there are false positives ... e.g.", "is_sublist([1], [11]).", "Crappy answer.", ":)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "is_sublist([1], [11])", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]