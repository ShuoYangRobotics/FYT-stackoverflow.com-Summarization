[[{"text": ["You can use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n logging.basicConfig(level=your_level)\n</code>\n</pre>\n", "senID": 1}, {"text": ["where your_level is one of those:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "your_level", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 'debug': logging.DEBUG,\n      'info': logging.INFO,\n      'warning': logging.WARNING,\n      'error': logging.ERROR,\n      'critical': logging.CRITICAL\n</code>\n</pre>\n", "senID": 3}, {"text": ["So, if you set your_level to logging.CRITICAL, you will get only critical messages sent by: "], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "your_level", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "logging.CRITICAL", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n logging.critical('This is a critical error message')\n</code>\n</pre>\n", "senID": 5}, {"text": ["Setting your_level to logging.DEBUG will show all levels of logging."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "your_level", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "logging.DEBUG", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["For more details, please take a look at logging examples."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "logging examples.", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/logging.html?highlight=logging#simple-examples"}]}, {"text": ["In the same manner to change level for each Handler use Handler.setLevel() function."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Handler.setLevel()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/logging.html?highlight=logging#logging.Handler.setLevel"}]}, {"code": "<pre>\n<code>\n import logging\nimport logging.handlers\n\nLOG_FILENAME = '/tmp/logging_rotatingfile_example.out'\n\n# Set up a specific logger with our desired output level\nmy_logger = logging.getLogger('MyLogger')\nmy_logger.setLevel(logging.DEBUG)\n\n# Add the log message handler to the logger\nhandler = logging.handlers.RotatingFileHandler(\n          LOG_FILENAME, maxBytes=20, backupCount=5)\n\nhandler.setLevel(logging.CRITICAL)\n\nmy_logger.addHandler(handler)\n</code>\n</pre>\n", "senID": 9}], [{"text": ["I found a solution for this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n logger = logging.getLogger('my-logger')\nlogger.propagate = False\n# now if you use logger it will not log to console.\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will logging from being send to the upper logger that includes the console logging."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n logger = logging.getLogger()\nlogger.disabled = True\n... whatever you want ...\nlogger.disabled = False\n</code>\n</pre>\n", "senID": 1}], [{"text": ["(long dead question, but for future searchers)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Closer to the original poster's code/intent, this works for me under python 2.6"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\nimport logging\n\nlogger = logging.getLogger() # this gets the root logger\n\nlhStdout = logger.handlers[0]  # stdout is the only handler initially\n\n# ... here I add my own handlers \nf = open(\"/tmp/debug\",\"w\")          # example handler\nlh = logging.StreamHandler(f)\nlogger.addHandler(lh)\n\nlogger.removeHandler(lhStdout)\n\nlogger.debug(\"bla bla\")\n</code>\n</pre>\n", "senID": 2}, {"text": ["The gotcha I had to work out was to remove the stdout handler after adding a new one; the logger code appears to automatically re-add the stdout if no handlers are present."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "after", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["No need to divert stdout.", "Here is better way to do it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import logging\nclass MyLogHandler(logging.Handler):\n    def emit(self, record):\n        pass\n\nlogging.getLogger().addHandler(MyLogHandler())\n</code>\n</pre>\n", "senID": 1}, {"text": ["An even simpler way is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n logging.getLogger().setLevel(100)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I don't know the logging module very well, but I'm using it in the way that I usually want to disable only debug (or info) messages.", "You can use Handler.setLevel() to set the logging level to CRITICAL or higher."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Handler.setLevel()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Also, you could replace sys.stderr and sys.stdout by a file open for writing.", "See http://docs.python.org/library/sys.html#sys.stdout.", "But I wouldn't recommend that."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/sys.html#sys.stdout", "tag": "a", "pos": 1, "childList": [{"text": "stdout", "tag": "strong"}], "childNum": 1, "href": "http://docs.python.org/library/sys.html#sys.__stdout__"}, {"text": "stdout", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}], [{"text": ["There are some really nice answers here, but apparently the simplest is not taken too much in consideration (only from infinito)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n root_logger = logging.getLogger()\nroot_logger.disabled = True\n</code>\n</pre>\n", "senID": 1}, {"text": ["This disables the root logger, and thus all the other loggers.", "I haven't really tested but it should be also the fastest."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["From the logging code in python 2.7 I see this"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def handle(self, record):\n    \"\"\"\n    Call the handlers for the specified record.\n\n    This method is used for unpickled records received from a socket, as\n    well as those created locally. Logger-level filtering is applied.\n    \"\"\"\n    if (not self.disabled) and self.filter(record):\n        self.callHandlers(record)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Which means that when it's disabled no handler is called, and it should be more efficient that filtering to a very high value or setting a no-op handler for example."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]