[[{"text": ["You have two decent options:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The standard Python configuration files look like INI files with [sections] and key : value or key = value pairs.", "The advantages to this format are:"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "[sections]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "key : value", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "key = value", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "No third-party libraries necessary", "tag": "none", "senID": 2}, {"text": "Simple, familiar file format.", "tag": "none", "senID": 3}]}, {"text": ["YAML is different in that it is designed to be a human friendly data serialization format rather than specifically designed for configuration.", "It is very readable and gives you a couple different ways to represent the same data.", "For your problem, you could create a YAML file that looks like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n file .* does not exist : file not found\nuser .* not found : authorization error\n</code>\n</pre>\n", "senID": 5}, {"text": ["Or like this:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n { file .* does not exist: file not found,\n  user .* not found: authorization error }\n</code>\n</pre>\n", "senID": 7}, {"text": ["Using PyYAML couldn't be simpler:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n import yaml\n\nerrors = yaml.load(open('my.yaml'))\n</code>\n</pre>\n", "senID": 9}, {"text": ["At this point errors is a Python dictionary with the expected format.", "YAML is capable of representing more than dictionaries: if you prefer a list of pairs, use this format:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "errors", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n -\n  - file .* does not exist \n  - file not found\n-\n  - user .* not found\n  - authorization error\n</code>\n</pre>\n", "senID": 11}, {"text": ["Or"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n [ [file .* does not exist, file not found],\n  [user .* not found, authorization error]]\n</code>\n</pre>\n", "senID": 13}, {"text": ["Which will produce a list of lists when yaml.load is called."], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "yaml.load", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["One advantage of YAML is that you could use it to export your existing, hard-coded data out to a file to create the initial version, rather than cut/paste plus a bunch of find/replace to get the data into the right format."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["The YAML format will take a little more time to get familiar with, but using PyYAML is even simpler than using ConfigParser with the advantage is that you have more options regarding how your data is represented using YAML."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["Either one sounds like it will fit your current needs, ConfigParser will be easier to start with while YAML gives you more flexibilty in the future, if your needs expand."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["Best of luck!"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}], [{"text": ["I sometimes just write a python module (i.e.", "file) called config.py or something with following contents:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "config.py", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n config = {\n    'name': 'hello',\n    'see?': 'world'\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["this can then be 'read' like so:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from config import config\nconfig['name']\nconfig['see?']\n</code>\n</pre>\n", "senID": 3}, {"text": ["easy."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I've heard that ConfigObj is easier to work with than ConfigParser.", "It is used by a lot of big projects, IPython, Trac, Turbogears, etc...  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ConfigObj", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.voidspace.org.uk/python/configobj.html"}]}, {"text": ["From their introduction:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "introduction", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.voidspace.org.uk/python/configobj.html#introduction"}]}, {"text": ["ConfigObj is a simple but powerful config file reader and writer: an ini file round tripper.", "Its main feature is that it is very easy to use, with a straightforward programmer's interface and a simple syntax for config files.", "It has lots of other features though :"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 8, "lis": [{"text": "Nested sections (subsections), to any level", "tag": "none", "senID": 3}, {"text": "List values", "tag": "none", "senID": 4}, {"text": "Multiple line values", "tag": "none", "senID": 5}, {"text": "String interpolation (substitution)", "tag": "none", "senID": 6}, {"text": "Integrated with a powerful validation system\n", "tag": "none", "senID": 7}, {"text": "When writing out config files, ConfigObj preserves all comments and the order of members and sections", "tag": "none", "senID": 8}, {"text": "Many useful methods and options for working with configuration files (like the 'reload' method)", "tag": "none", "senID": 9}, {"text": "Full Unicode support", "tag": "none", "senID": 10}]}], [{"text": ["If you are the only one that has access to the configuration file, you can use a simple, low-level solution.", "Keep the \"dictionary\" in a text file as a list of tuples (regexp, message) exactly as if it was a python expression:\n[\n(\"file .", "* does not exist\", \"file not found\"),\n(\"user .", "* not authorized\", \"authorization error\")\n]\nIn your code, load it, then eval it, and compile the regexps in the result:\nf = open(\"messages.py\")\nmessages = eval(f.read()) # caution: you must besureof what's in that file\nf.close()\nmessages = [(re.compile(r), m) for (r,m) in messages]\nand you end up with a list of tuples (compiled_regexp, message)."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "[\n(\"file .* does not exist\", \"file not found\"),\n(\"user .* not authorized\", \"authorization error\")\n]", "childNum": 1, "tag": "pre", "pos": -1, "childList": [{"text": "[\n(\"file .* does not exist\", \"file not found\"),\n(\"user .* not authorized\", \"authorization error\")\n]", "tag": "code"}]}, {"text": "[\n(\"file .* does not exist\", \"file not found\"),\n(\"user .* not authorized\", \"authorization error\")\n]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "f = open(\"messages.py\")\nmessages = eval(f.read()) # caution: you must besureof what's in that file\nf.close()\nmessages = [(re.compile(r), m) for (r,m) in messages]", "childNum": 2, "tag": "pre", "pos": 3, "childList": [{"text": "f = open(\"messages.py\")\nmessages = eval(f.read()) # caution: you must besureof what's in that file\nf.close()\nmessages = [(re.compile(r), m) for (r,m) in messages]", "tag": "code"}, {"text": "sure", "tag": "em"}]}, {"text": "f = open(\"messages.py\")\nmessages = eval(f.read()) # caution: you must besureof what's in that file\nf.close()\nmessages = [(re.compile(r), m) for (r,m) in messages]", "childNum": 1, "tag": "code", "childList": [{"text": "sure", "tag": "em"}]}, {"text": "sure", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["I think you want the ConfigParser module in the standard library.", "It reads and writes INI style files.", "The examples and documentation in the standard documentation I've linked to are very comprehensive."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ConfigParser", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/configparser.html#module-ConfigParser"}]}], [{"text": ["I typically do as Daren suggested, just make your config file a Python script:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n patterns = {\n    'file .* does not exist': 'file not found',\n    'user .* not found': 'authorization error',\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you can use it as:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import config\n\nfor pattern in config.patterns:\n    if re.search(pattern, log_message):\n        print config.patterns[pattern]\n</code>\n</pre>\n", "senID": 3}, {"text": ["This is what Django does with their settings file, by the way."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]