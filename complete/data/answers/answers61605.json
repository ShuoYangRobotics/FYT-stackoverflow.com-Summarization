[[{"text": ["Absolutely (for the example you provided)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There is a builtin function divmod() that does exactly that."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "divmod()", "tag": "a", "pos": 0, "childList": [{"text": "divmod()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/lib/built-in-funcs.html"}, {"text": "divmod()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n q, r = divmod(x, y) # ((x - x%y)/y, x%y) Invariant: div*y + mod == x\n</code>\n</pre>\n", "senID": 2}, {"text": ["There are other examples: zip, enumerate, dict.items. "], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "enumerate", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict.items", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n for i, e in enumerate([1, 3, 3]):\n    print \"index=%d, element=%s\" % (i, e)\n\n# reverse keys and values in a dictionary\nd = dict((v, k) for k, v in adict.items()) # or \nd = dict(zip(adict.values(), adict.keys()))\n</code>\n</pre>\n", "senID": 4}, {"text": ["BTW, parentheses are not necessary most of the time.", "Citation from Python Library Refrence: "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Python Library Refrence", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/typesseq.html"}]}, {"text": ["Therefore they should return a single object.", "In your  case this object is a tuple.", "Consider tuple as an ad-hoc compound data structure.", "There are languages where almost every single function returns multiple values (list in Lisp)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Sometimes it is sufficient to return (x, y) instead of Point(x, y)."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "(x, y)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Point(x, y)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["With introduction of named tuples in Python 2.6 It is preferable in many cases to return named tuples instead of plain tuples."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import collections\n&gt;&gt;&gt; Point = collections.namedtuple('Point', 'x y')\n&gt;&gt;&gt; x, y = Point(0, 1)\n&gt;&gt;&gt; p = Point(x, y)\n&gt;&gt;&gt; x, y, p\n(0, 1, Point(x=0, y=1))\n&gt;&gt;&gt; p.x, p.y, p[0], p[1]\n(0, 1, 0, 1)\n&gt;&gt;&gt; for i in p:\n...   print(i)\n...\n0\n1\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Firstly, note that Python allows for the following (no need for the parenthesis):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n q, r = divide(22, 7)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Regarding your question, there's no hard and fast rule either way.", "For simple (and usually contrived) examples, it may seem that it's always possible for a given function to have a single purpose, resulting in a single value.", "However, when using Python for real-world applications, you quickly run into many cases where returning multiple values is necessary, and results in cleaner code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["So, I'd say do whatever makes sense, and don't try to conform to an artificial convention.", "Python supports multiple return values, so use it when appropriate."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The example you give is actually a python builtin function, called divmod.", "So someone, at some point in time, thought that it was pythonic enough to include in the core functionality."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "divmod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["To me, if it makes the code cleaner, it is pythonic.", "Compare these two code blocks:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n seconds = 1234\nminutes, seconds = divmod(seconds, 60)\nhours, minutes = divmod(minutes, 60)\n\nseconds = 1234\nminutes = seconds / 60\nseconds = seconds % 60\nhours = minutes / 60\nminutes = minutes % 60\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Yes, returning multiple values (i.e., a tuple) is definitely pythonic.", "As others have pointed out, there are plenty of examples in the Python standard library, as well as in well-respected Python projects.", "Two additional comments:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "code", "senID": 1}, {"code": "<pre>\n<code>\n // C++\nvoid test(int&amp; arg)\n{\n    arg = 1;\n}\n\nint foo = 0;\ntest(foo); // foo is now 1!\n\n# Python\ndef test(arg):\n    arg = 1\n\nfoo = 0\ntest(foo) # foo is still 0\n</code>\n</pre>\n", "senID": 2}, {"senID": 3}], [{"text": ["It's definitely pythonic.", "The fact that you can return multiple values from a function the boilerplate you would have in a language like C where you need to define a struct for every combination of types you return somewhere."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, if you reach the point where you are returning something crazy like 10 values from a single function, you should seriously consider bundling them in a class because at that point it gets unwieldy."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Returning a tuple is cool.", "Also note the new namedtuple\nwhich was added in python 2.6 which may make this more palatable for you:\nhttp://docs.python.org/dev/library/collections.html#collections.namedtuple"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/dev/library/collections.html#collections.namedtuple", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/collections.html#collections.namedtuple"}]}], [{"text": ["I'm fairly new to Python, but the tuple technique seems very pythonic to me.", "However, I've had another idea that may enhance readability.", "Using a dictionary allows access to the different values by name rather than position.", "For example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def divide(x, y):\n    return {'quotient': x/y, 'remainder':x%y }\n\nanswer = divide(22, 7)\nprint answer['quotient']\nprint answer['remainder']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["OT: RSRE's Algol68 has the curious \"/:=\" operator.", "eg."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n INT quotient:=355, remainder;\nremainder := (quotient /:= 113);\n</code>\n</pre>\n", "senID": 1}, {"text": ["Giving a quotient of 3, and a remainder of 16. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note: typically the value of \"(x/:=y)\" is discarded as quotient \"x\" is assigned by reference, but in RSRE's case the returned value is the remainder."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["c.f.", "Integer Arithmetic - Algol68"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Integer Arithmetic - Algol68", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://rosettacode.org/wiki/Basic%5Finteger%5Farithmetic#ALGOL%5F68"}]}], [{"text": ["It's fine to return multiple values using a tuple for simple functions such as divmod.", "If it makes the code readable, it's Pythonic."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "divmod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If the return value starts to become confusing, check whether the function is doing too much and split it if it is.", "If a big tuple is being used like an object, make it an object.", "Also, consider using named tuples, which will be part of the standard library in Python 2.6."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "named tuples", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/500261/"}]}]]