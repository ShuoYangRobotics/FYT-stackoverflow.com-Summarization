[[{"text": ["Use lookahead assertions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In : re.findall('val=(?!13$)(\\d{2,})', 'val=12') \nOut: ['12']\n\nIn : re.findall('val=(?!13$)(\\d{2,})', 'val=13') \nOut: []\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Why do you need a regular expression?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; string = 'val=13'\n&gt;&gt;&gt; array=string.split(\"=\")\n&gt;&gt;&gt; if array[0] == \"val\" and int(array[1]) &lt; 100 and int(array[1]) == 13\n...     print \"match\"\n...\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["And all these are assuming I understood what you wrote. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Don't use regular expressions for stuff like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n str = \"val=13\"\nnum = int(str.split(\"=\")[1])\n\n# a two-digit number ranges from 10 - 99\nif 10 &lt;= num &lt;= 99 and num != 13:\n    print(\"Success!\")\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you really want a regex that matches two digits numbers except 13, then this should work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; str = 'val=13'\n&gt;&gt;&gt; regex = 'val=(?!13$)(\\d{2,})'\n&gt;&gt;&gt; re.search(regex,str)\n&gt;&gt;&gt; str = 'val=26'\n&gt;&gt;&gt; re.search(regex,str)\n&lt;_sre.SRE_Match object at 0xb75c0bf0&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, as others pointed out, this may not be the best approach."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could use a 'negative look ahead assertion':"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n p = re.compile(\"val=(?!13)[0-9]{2}\")\nassert not p.match('val=13')\nassert p.match('val=23')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Edit: Changed to match numbers having one or more digits."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If you need to pluck out various forms of val=dd where dd must be a number having one or more digits, and that number cannot be 13 (or -13), and there may be whitespace surrounding the equals sign, and the number may have an optional leading +/- sign, then this script shows one way to do it:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "val=dd", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n import re\n# Regex: VERBOSE, commented version.\nreLong = r\"\"\"\n    # Match \"val=dd\" where dd has two or more digits (but is not 13).\n    \\bval\\s*=\\s*  # \"val=\" literal with optional ws.\n    (?!           # Begin negative lookahead assertion.\n      [+\\-]?      # Number may have optional sign.\n      13          # This is the number we don't match\n      \\b          # which ends on a word boundary.\n    )             # The number is not 13, +13 or -13.\n    (             # $1: Two digit number.\n      [+\\-]?      # Allow optional sign.\n      \\d+         # One or more digits.\n    )             # End $1: containing 2 digit number\n    \"\"\"\n# Regex: short, uncommented version.\nreShort = r\"\\bval\\s*=\\s*(?![+\\-]?13\\b)([+\\-]?\\d{2}\\b)\"\n\n# Compile a regex object we can use over and over.\nreObj = re.compile(reLong, re.IGNORECASE | re.VERBOSE)\n\n# Test data strings. Positive and negative. With/without whitespace.\ninput = [\n    # String with positive numbers. No whitespace.\n    \"val=1 val=13, val=133, val=12, otherval=1\",\n    # String with positive numbers. With whitespace.\n    \"val = 1 val = 13, val = 133, val = 12, otherval = 1\",\n    # String with negative numbers. No whitespace.\n    \"val=-1 val=-13, val=-133, val=-12, otherval=-1\",\n    # String with negative numbers. With whitespace.\n    \"val = -1 val = -13, val = -133, val = -12, otherval = -1\",\n    ]\n\n# Parse all test data strings and print matches.\nfor str in input:\n    matches = reObj.findall(str)\n    if matches:\n        print(matches)\n</code>\n</pre>\n", "senID": 2}, {"text": ["The regex is presented in both short and long verbose form with comments.", "Here is the output from the script:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["['1', '133', '12']\n['1', '133', '12']\n['-1', '-133', '-12']\n['-1', '-133', '-12'] "], "childNum": 7, "tag": "p", "senID": 4, "childList": [{"text": "['1', '133', '12']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "['1', '133', '12']", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "['-1', '-133', '-12']", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "['-1', '-133', '-12']", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Additional:\nTo match something that is NOT something that is more than one character long, we use negative lookahead.", "For example, if one wants to match words which are NOT \"BAD\", here is a commented regex which shows how:"], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "Additional:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "negative lookahead", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "\"BAD\"", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n reobj = re.compile(r\"\"\"\n    # Match a word that is not: 'BAD'\n    \\b         # Anchor to start of word.\n    (?!BAD\\b)  # Verify that this word is not 'BAD'\n    \\w+        # Ok. Safe to match non-BAD word.\n    \\b         # Anchor to end of word.\n    \"\"\", re.VERBOSE)\n</code>\n</pre>\n", "senID": 6}]]