[[{"text": ["zip is useful if you'd like to iterate over multiple iterables simultaneously, which is a reasonably common scenario in Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One real-world scenario where zip has come in handy for me is if you have an M by N array, and you want to look at columns instead of rows.", "For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; five_by_two = ((0, 1), (1, 2), (2, 3), (3, 4), (4, 5))\n&gt;&gt;&gt; two_by_five = tuple(zip(*five_by_two))\n&gt;&gt;&gt; two_by_five\n((0, 1, 2, 3, 4), (1, 2, 3, 4, 5))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["It allows you to process sequences in parallel instead of sequentially or nested.", "There's... so many uses for it that they currently escape me."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Here's a common use case for zip:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n x = [1,2,3,4,5]\ny = [6,7,8,9,0]\n\nfor x,y in zip(x,y):\n    print x+y\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It's handy in different places.", "My favorite, from http://norvig.com/python-iaq.html, is transposing a matrix:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://norvig.com/python-iaq.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://norvig.com/python-iaq.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = [ [1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15]]\n&gt;&gt;&gt; zip(*x)\n[(1, 6, 11), (2, 7, 12), (3, 8, 13), (4, 9, 14), (5, 10, 15)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Someone actually asked a question here fairly recently that I answered with the Zip extension method, so it's obviously important for some people.", ";)"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2352379/can-i-get-the-delta-of-two-ienumerables-in-linq/2352450#2352450"}, {"text": "Zip", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "some", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["Actually, it is a fairly important operation for mathematical algorithms - matrices, curve fitting, interpolation, pattern recognition, that sort of thing.", "Also very important in engineering applications like digital signal processing where much of what you do is combine multiple signals or apply linear transforms to them - both are based on the sample index, hence, zip it.", "Zipping two sequences is far, far faster than sorting and joining them based on some key, especially when you know in advance that the sequences have the same number of elements and are in the same order."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "mathematical", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I can't get into tight specifics here on account of my current employment, but speaking generally, this is also valuable for telemetry data - industrial, scientific, that sort of thing.", "Often you'll have time sequences of data coming from hundreds or thousands of points - parallel sources - and you need to aggregate, but horizontally, over devices, not over time.", "At the end, you want another time sequence, but with the sum or average or some other aggregate of all the individual points."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "horizontally", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["It may sound like a simple sort/group/join in SQL Server (for example) but it's actually really hard to do efficiently this way.", "For one thing, the timestamps may not match exactly, but you don't care about differences of a few milliseconds, so you end up having to generate a surrogate key/row number and group on that - and of course, the surrogate row number is nothing more than the time index which you already had.", "Zipping is simple, fast, and infinitely parallelizable."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "index", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "already had", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["I don't know if I'd call it foundational, but it it is important.", "I don't use the Reverse method very often either, but by the same token I'm glad I don't have to keep writing it myself on those rare occasions when I do find a need for it."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "foundational", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "important", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "Reverse", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["One of the reasons it might not seem that useful to you now is that .NET/C# 3.5 does not have tuples.", "C# 4 does have tuples, and when you're working with tuples, zipping really is a fundamental operation because ordering is strictly enforced."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "does have tuples", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.davidhayden.me/2009/12/tuple-in-c-4-c-4-examples.html"}, {"text": "is", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["A use case:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; fields = [\"id\", \"name\", \"location\"]\n&gt;&gt;&gt; values = [\"13\", \"bill\", \"redmond\"]\n&gt;&gt;&gt; dict(zip(fields, values))\n{'location': 'redmond', 'id': '13', 'name': 'bill'}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Try doing this without zip..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's a case where I used zip() to useful effect, in a Python class for comparing version numbers:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "zip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Version(object):\n\n    # ... snip ...\n\n    def get_tuple(self):\n        return (self.major, self.minor, self.revision)\n\n    def compare(self, other):\n        def comp(a, b):\n            if a == '*' or b == '*':\n                return 0\n            elif a == b:\n                return 0\n            elif a &lt; b:\n                return -1\n            else:\n                return 1\n        return tuple(comp(a, b) for a, b in zip(self.get_tuple(), Version(other).get_tuple()))\n\n    def is_compatible(self, other):\n        tup = self.compare(other)\n        return (tup[0] == 0 and tup[1] == 0)\n\n    def __eq__(self, other):\n        return all(x == 0 for x in self.compare(other))\n\n    def __ne__(self, other):\n        return any(x != 0 for x in self.compare(other))\n\n    def __lt__(self, other):\n        for x in self.compare(other):\n            if x &lt; 0:\n                return True\n            elif x &gt; 0:\n                return False\n        return False\n\n    def __gt__(self, other):\n        for x in self.compare(other):\n            if x &gt; 0:\n                return True\n            elif x &lt; 0:\n                return False\n        return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think zip(), coupled with all() and any(), makes the comparison operator implementations particularly clear and elegant.", "Sure, it could have been done without zip(), but then the same could be said about practically any language feature."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "zip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "all()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "any()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "zip()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]