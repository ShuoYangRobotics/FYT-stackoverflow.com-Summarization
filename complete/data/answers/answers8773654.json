[[{"text": ["Hmm, how about a generator?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def iterskip(iterator, test, n):\n    \"\"\"Iterate skipping values matching test, and n following values\"\"\"\n    iterator = iter(iterator)\n    while 1:\n        value = next(iterator)\n        if test(value):\n            for dummy in range(n):\n                next(iterator)\n        else:\n            yield value\n\ndef is_foo(value):\n    return value == 'foo'\n\nprint list(iterskip(values, is_foo, 2))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Just slice-delete."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; values = [1, 2, 3, 'foo', 'a', 'b', 6, 7, 'foo', 'x', 'y']\n&gt;&gt;&gt; values.index('foo')\n3\n&gt;&gt;&gt; del values[3:3 + 3]\n&gt;&gt;&gt; values.index('foo')\n5\n&gt;&gt;&gt; del values[5:5 + 3]\n&gt;&gt;&gt; values.index('foo')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: 'foo' is not in list\n&gt;&gt;&gt; values\n[1, 2, 3, 6, 7]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["And now, a coroutine solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def countdown(val, count):\n  curr = 0\n  while True:\n    now = (yield curr)\n    if curr &gt; 0:\n      curr -= 1\n    if now == val:\n      curr = count\n\nvalues = [1, 2, 3, 'foo', 'a', 'b', 6, 7, 'foo', 'x', 'y']\nc = countdown('foo', 3)\nc.next()\nprint [x for x in values if not c.send(x)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Write a simple function to work with del slices of the list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import copy\ndef del_sublists(list, value, length, copy_list = False):\n    if copy_list:\n        list = copy.deepcopy(list)\n    while value in list:\n        del list[list.index(value):list.index(value) + (length + 1)]\n    return list\n\na = [1, 2, 3, 'foo', 'a', 'b', 6, 7, 'foo', 'x', 'y']\nprint del_sublists(a, 'foo', 2)\nprint a\n</code>\n</pre>\n", "senID": 1}, {"text": ["output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [1, 2, 3, 6, 7]\n[1, 2, 3, 6, 7]\n</code>\n</pre>\n", "senID": 3}, {"text": ["and same but not changing the variable:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n a = [1, 2, 3, 'foo', 'a', 'b', 6, 7, 'foo', 'x', 'y']\nprint del_sublists(a, 'foo', 2, copy_list = True)\nprint a\n</code>\n</pre>\n", "senID": 5}, {"text": ["output:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n [1, 2, 3, 6, 7]\n[1, 2, 3, 'foo', 'a', 'b', 6, 7, 'foo', 'x', 'y']\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Depends on your definition of elegant, and whether you want to do what your question title says (remove from a list i.e.", "not making a new list)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The first function below safely mutates the existing list by iterating backwards and deleting the unwanted stuff.", "The second function iterates forwards using list.index until the marker is not found (IOW what Ignacio's answer suggested).", "The third function is a modified version of the first, assuming that the question is taken literally e.g.", "['foo', 'foo', 1, 2] is reduced to [], not [2]."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "list.index", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "['foo', 'foo', 1, 2]", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "[]", "childNum": 0, "tag": "code", "childList": []}, {"text": "[2]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def inplace_munge_1(alist, query, size):\n    for i in xrange(len(alist) - 1, -1, -1):\n        if alist[i] == query:\n            del alist[i:i+size]\n\ndef inplace_munge_2(alist, query, size):\n    start = 0\n    while True:\n        try:\n            i = alist.index(query, start)\n        except ValueError:\n            return\n        del alist[i:i+size]\n        start = i\n\ndef inplace_munge_3(alist, query, size):\n    marker = len(alist)\n    delpos = []\n    for i in xrange(len(alist) - 1, -1, -1):\n        if alist[i] == query:\n            for j in xrange(min(i + size, marker) - 1, i - 1, -1):\n                delpos.append(j)\n            marker = i\n    for j in delpos:\n        del alist[j]\n\nfuncs = [inplace_munge_1, inplace_munge_2, inplace_munge_3]\n\ntests = [\n    [],\n    [1],\n    ['foo'],\n    [1, 2, 3, 'foo', 'a', 'b', 6, 7, 'foo', 'x', 'y'],\n    ['foo', 'foo', 1, 2, 3],\n    ]\n\nfmt = \"%-15s: %r\"    \nfor test in tests:\n    print\n    print fmt % (\"Input\", test)\n    for func in funcs:\n        values = test[:]\n        func(values, 'foo', 3)\n        print fmt % (func.__name__, values)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n Input          : []\ninplace_munge_1: []\ninplace_munge_2: []\ninplace_munge_3: []\n\nInput          : [1]\ninplace_munge_1: [1]\ninplace_munge_2: [1]\ninplace_munge_3: [1]\n\nInput          : ['foo']\ninplace_munge_1: []\ninplace_munge_2: []\ninplace_munge_3: []\n\nInput          : [1, 2, 3, 'foo', 'a', 'b', 6, 7, 'foo', 'x', 'y']\ninplace_munge_1: [1, 2, 3, 6, 7]\ninplace_munge_2: [1, 2, 3, 6, 7]\ninplace_munge_3: [1, 2, 3, 6, 7]\n\nInput          : ['foo', 'foo', 1, 2, 3]\ninplace_munge_1: []\ninplace_munge_2: [2, 3]\ninplace_munge_3: [3]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["A good solution using a defined function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def special_remove(my_list, item, start=0):\n    try:\n        pos = my_list.index(item, start)\n        return special_remove(my_list[:pos] + my_list[pos+3:], item, pos)\n    except ValueError:\n        return my_list\n</code>\n</pre>\n", "senID": 1}, {"text": ["And using the function with your data:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; values = [1, 2, 3, 'foo', 'a', 'b', 6, 7, 'foo', 'x', 'y']\n&gt;&gt;&gt; special_remove(values, 'foo') [1, 2, 3, 6, 7]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Good thing about this code is that it won't fail even if you want to remove out-of-range elements, for example:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; values = [1, 'foo']\n&gt;&gt;&gt; special_remove(values, 'foo')\n[1]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Functional version:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's a bit messy, though."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def unfold(f, x):\n    while True:\n        try:\n            w, x = f(x)\n        except TypeError:\n            raise StopIteration\n        yield w\n\ndef test(info):\n    values, cur_values, n = info\n    length = len(values)\n\n    if n == length:\n        return None\n    elif n == length-1:\n        cur_values = cur_values + [values[n]]\n    elif values[n] == \"foo\" and n &lt; len(values)-2:\n        n += 3\n\n    return (cur_values, (values, cur_values + [values[n]], n+1))\n\nvalues = [1, 2, 3, 'a', 'b', 6, 7, 'foo', 'x', 'y', 2 , 6 , 7, \"foo\", 4 , 5, 6, 7]\nresults = list(unfold(test, (values, [], 0)))[-1]\nprint results\n</code>\n</pre>\n", "senID": 2}, {"text": ["Output: [1, 2, 3, 'a', 'b', 6, 7, 2, 6, 7, 6, 7]"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]