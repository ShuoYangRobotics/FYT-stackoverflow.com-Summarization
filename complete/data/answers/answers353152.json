[[{"text": ["The trick is in noticing which patterns emerge as you run the string through each iteration.", "Try evaluating iterate(D,n) for n between 1 and 10 and see if you can spot them.", "Also feed the string through a function that calculates the end position and the number of steps, and look for patterns there too."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "iterate(D,n)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You can then use this knowledge to simplify the algorithm to something that doesn't use these strings at all."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If you think about how many \"a\" and \"b\" characters there are in D(0), D(1), etc, you'll see that the string gets very long very quickly.", "Calculate how many characters there are in D(50), and then maybe think again about where you would store that much data.", "I make it 4.5*10^15 characters, which is 4500 TB at one byte per char."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Come to think of it, you don't have to calculate - the problem tells you there are 10^12 steps at least, which is a terabyte of data at one byte per character, or quarter of that if you use tricks to get down to 2 bits per character.", "I think this would cause problems with the one-minute time limit on any kind of storage medium I have access to :-)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Python strings are not going to be the answer to this one.", "Strings are stored as immutable arrays, so each one of those replacements creates an entirely new string in memory.", "Not to mention, the set of instructions after 10^12 steps will be at least 1TB in size if you store them as characters (and that's with some minor compressions)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Ideally, there should be a way to mathematically (hint, there is) generate the answer on the fly, so that you never need to store the sequence. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Just use the string as a guide to determine a method which creates your path. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Since you can't materialize the string, you must generate it.", "If you yield the individual characters instead of returning the whole string, you might get it to work."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def repl220( string ):\n    for c in string:\n        if c == 'a': yield \"aRbFR\"\n        elif c == 'b': yield \"LFaLb\"\n        else yield c\n</code>\n</pre>\n", "senID": 1}, {"text": ["Something like that will do replacement without creating a new string."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Now, of course, you need to call it recursively, and to the appropriate depth.", "So, each yield isn't just a yield, it's something a bit more complex."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Trying not to solve this for you, so I'll leave it at that."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You could treat D as a byte stream file."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Something like:-"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["warning totally untested"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Just as a word of warning be careful when using the replace() function.", "If your strings are very large (in my case ~ 5e6 chars) the replace function would return a subset of the string (around ~ 4e6 chars) without throwing any errors."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]