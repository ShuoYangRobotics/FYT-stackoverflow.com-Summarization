[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; single = ['key1', 'value1', 'key2', 'value2', 'key3', 'value3']\n&gt;&gt;&gt; dict(zip(single[::2], single[1::2]))\n{'key3': 'value3', 'key2': 'value2', 'key1': 'value1'}\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Similar to SilentGhost's solution, without building temporary lists:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import izip\n&gt;&gt;&gt; single = ['key1', 'value1', 'key2', 'value2', 'key3', 'value3']\n&gt;&gt;&gt; si = iter(single)\n&gt;&gt;&gt; dict(izip(si, si))\n{'key3': 'value3', 'key2': 'value2', 'key1': 'value1'}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is the simplest I guess.", "You will see more wizardry in solution here using list comprehension etc"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dictObj = {}\nfor x in range(0, len(single), 2):\n    dictObj[single[x]] = single[x+1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; single = ['key1', 'value1', 'key2', 'value2', 'key3', 'value3']\n&gt;&gt;&gt; dictObj = {}\n&gt;&gt;&gt; for x in range(0, len(single), 2):\n...     dictObj[single[x]] = single[x+1]\n... \n&gt;&gt;&gt; \n&gt;&gt;&gt; dictObj\n{'key3': 'value3', 'key2': 'value2', 'key1': 'value1'}\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n L = ['key1', 'value1', 'key2', 'value2', 'key3', 'value3']\nd = dict(L[n:n+2] for n in xrange(0, len(L), 2))\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; single = ['key', 'value', 'key2', 'value2', 'key3', 'value3']\n&gt;&gt;&gt; dict(zip(*[iter(single)]*2))\n{'key3': 'value3', 'key2': 'value2', 'key': 'value'}\n</code>\n</pre>\n", "senID": 0}, {"text": ["Probably not the most readable version though ;)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You haven't specified any criteria for \"best\".", "If you want understandability, simplicity, easily modified to check for duplicates and odd number of inputs, works with any iterable (in case you can't find out the length in advance), NO EXTRA MEMORY USED, ... try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def load_dict(iterable):\n    d = {}\n    pair = False\n    for item in iterable:\n        if pair:\n            # insert duplicate check here\n            d[key] = item\n        else:\n            key = item\n        pair = not pair\n    if pair:\n        grumble_about_odd_length(key)\n    return d\n</code>\n</pre>\n", "senID": 1}]]