[[{"text": ["ANTLR is pretty popular and even has an IDE to help you develop / test your grammars."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ANTLR", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.antlr.org/"}]}], [{"text": ["Pyparsing is a good Python add-on module for plain text.", "Easy to get something going quickly, but has enough supporting components to do some pretty elaborate parsing work.", "See http://pyparsing.wikispaces.com, and check out the Examples page.", "(Plus it is very liberally licensed, so there are no restrictions or runtime encumberances."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://pyparsing.wikispaces.com", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com"}]}], [{"text": ["Take a look at JavaCC. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "JavaCC", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://javacc.dev.java.net/"}]}, {"text": ["From the JavaCC FAQ:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "JavaCC FAQ", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.engr.mun.ca/~theo/JavaCC-FAQ/javacc-faq-moz.htm"}]}], [{"text": ["i think you are looking for something like apache lucene."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["check this : http://lucene.apache.org/java/docs/index.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://lucene.apache.org/java/docs/index.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://lucene.apache.org/java/docs/index.html"}]}], [{"text": ["It depends what you need to parse. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you need to solve particular problem domain than the best way is to create Domain-specific language and parse it in Groovy."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Groovy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://groovy.codehaus.org/Writing+Domain-Specific+Languages"}]}], [{"text": ["If the text has a known format, a grammar parser might be your best bet."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Gold Parser is open source and has both java and python support, among others.", "http://www.devincook.com/goldparser/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.devincook.com/goldparser/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.devincook.com/goldparser/"}]}], [{"text": ["Lepl - http://www.acooke.org/lepl - is a general-purpose, recursive descent parser for Python that I maintain."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.acooke.org/lepl", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.acooke.org/lepl"}]}, {"text": ["It's similar to pyparsing, in that both are parsers that you write directly in Python.", "Here's an example that parses and evaluates an arithmetic expression:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from operator import add, sub, mul, truediv\n\n&gt;&gt;&gt; # ast nodes\n... class Op(List):\n...     def __float__(self):\n...         return self._op(float(self[0]), float(self[1]))\n...\n&gt;&gt;&gt; class Add(Op): _op = add\n...\n&gt;&gt;&gt; class Sub(Op): _op = sub\n...\n&gt;&gt;&gt; class Mul(Op): _op = mul\n...\n&gt;&gt;&gt; class Div(Op): _op = truediv\n...\n\n&gt;&gt;&gt; # tokens\n&gt;&gt;&gt; value = Token(UnsignedFloat())\n&gt;&gt;&gt; symbol = Token('[^0-9a-zA-Z \\t\\r\\n]')\n\n&gt;&gt;&gt; number = Optional(symbol('-')) + value &gt;&gt; float\n&gt;&gt;&gt; group2, group3 = Delayed(), Delayed()\n\n&gt;&gt;&gt; # first layer, most tightly grouped, is parens and numbers\n... parens = ~symbol('(') &amp; group3 &amp; ~symbol(')')\n&gt;&gt;&gt; group1 = parens | number\n\n&gt;&gt;&gt; # second layer, next most tightly grouped, is multiplication\n... mul_ = group1 &amp; ~symbol('*') &amp; group2 &gt; Mul\n&gt;&gt;&gt; div_ = group1 &amp; ~symbol('/') &amp; group2 &gt; Div\n&gt;&gt;&gt; group2 += mul_ | div_ | group1\n\n&gt;&gt;&gt; # third layer, least tightly grouped, is addition\n... add_ = group2 &amp; ~symbol('+') &amp; group3 &gt; Add\n&gt;&gt;&gt; sub_ = group2 &amp; ~symbol('-') &amp; group3 &gt; Sub\n&gt;&gt;&gt; group3 += add_ | sub_ | group2\n\n... ast = group3.parse('1+2*(3-4)+5/6+7')[0]\n&gt;&gt;&gt; print(ast)\nAdd\n +- 1.0\n `- Add\n     +- Mul\n     |   +- 2.0\n     |   `- Sub\n     |       +- 3.0\n     |       `- 4.0\n     `- Add\n         +- Div\n         |   +- 5.0\n         |   `- 6.0\n         `- 7.0\n&gt;&gt;&gt; float(ast)\n6.833333333333333\n&gt;&gt;&gt; 1+2*(3-4)+5/6+7\n6.833333333333333\n</code>\n</pre>\n", "senID": 2}, {"text": ["The main advantages of Lepl over pyparsing are that it's slightly more powerful (it can compile itself to regular expressions in places for speed, handle left recursive grammars, uses trampolining to avoid running out of stack space).", "The main disadvantages are that it's younger than pyparsing, so doesn't have the same number of users or as large and supportive a community."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]