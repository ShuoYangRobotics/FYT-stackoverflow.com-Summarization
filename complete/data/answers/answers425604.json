[[{"text": ["I second the Knuth-Morris-Pratt algorithm.", "By the way, your problem (and the KMP solution) is exactly recipe 5.13 in Python Cookbook 2nd edition.", "You can find the related code at http://code.activestate.com/recipes/117214/"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Python Cookbook", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://rads.stackoverflow.com/amzn/click/0596007973"}, {"text": "http://code.activestate.com/recipes/117214/", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/117214/"}]}, {"text": ["It finds all the correct subsequences in a given sequence, and should be used as an iterator:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "all", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for s in KnuthMorrisPratt([4,'a',3,5,6], [5,6]): print s\n3\n&gt;&gt;&gt; for s in KnuthMorrisPratt([4,'a',3,5,6], [5,7]): print s\n(nothing)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Same thing as string matching sir...Knuth-Morris-Pratt string matching"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Knuth-Morris-Pratt string matching", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ics.uci.edu/~eppstein/161/960227.html"}]}], [{"text": ["Here's a brute-force approach O(n*m) (similar to @mcella's answer).", "It might be faster then the Knuth-Morris-Pratt algorithm implementation in pure Python O(n+m) (see @Gregg Lind answer) for small input sequences."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "O(n*m)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "@mcella's answer", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/425604/best-way-to-determine-if-a-sequence-is-in-another-sequence-in-python#425764"}, {"text": "O(n+m)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://stackoverflow.com/questions/425604/best-way-to-determine-if-a-sequence-is-in-another-sequence-in-python#425838", "text": "@Gregg Lind answer", "childNum": 0, "tag": "a", "childList": []}, {"text": "small", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\ndef index(subseq, seq):\n    \"\"\"Return an index of `subseq`uence in the `seq`uence.\n\n    Or `-1` if `subseq` is not a subsequence of the `seq`.\n\n    The time complexity of the algorithm is O(n*m), where\n\n        n, m = len(seq), len(subseq)\n\n    &gt;&gt;&gt; index([1,2], range(5))\n    1\n    &gt;&gt;&gt; index(range(1, 6), range(5))\n    -1\n    &gt;&gt;&gt; index(range(5), range(5))\n    0\n    &gt;&gt;&gt; index([1,2], [0, 1, 0, 1, 2])\n    3\n    \"\"\"\n    i, n, m = -1, len(seq), len(subseq)\n    try:\n        while True:\n            i = seq.index(subseq[0], i + 1, n - m + 1)\n            if subseq == seq[i:i + m]:\n               return i\n    except ValueError:\n        return -1\n\nif __name__ == '__main__':\n    import doctest; doctest.testmod()\n</code>\n</pre>\n", "senID": 1}, {"text": ["I wonder how large is the small in this case?"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "small", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; def seq_in_seq(subseq, seq):\n...     while subseq[0] in seq:\n...         index = seq.index(subseq[0])\n...         if subseq == seq[index:index + len(subseq)]:\n...             return index\n...         else:\n...             seq = seq[index + 1:]\n...     else:\n...         return -1\n... \n&gt;&gt;&gt; seq_in_seq([5,6], [4,'a',3,5,6])\n3\n&gt;&gt;&gt; seq_in_seq([5,7], [4,'a',3,5,6])\n-1\n</code>\n</pre>\n", "senID": 0}, {"text": ["Sorry I'm not an algorithm expert, it's just the fastest thing my mind can think about at the moment, at least I think it looks nice (to me) and I had fun coding it.", ";-)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Most probably it's the same thing your brute force approach is doing."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Brute force may be fine for small patterns."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For larger ones, look at the Aho-Corasick algorithm."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Aho-Corasick algorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Aho-Corasick_algorithm"}]}], [{"text": ["Here is another KMP implementation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def seq_in_seq(seq1,seq2):\n    '''\n    Return the index where seq1 appears in seq2, or -1 if \n    seq1 is not in seq2, using the Knuth-Morris-Pratt algorithm\n\n    based heavily on code by Neale Pickett &lt;neale@woozle.org&gt;\n    found at:  woozle.org/~neale/src/python/kmp.py\n\n    &gt;&gt;&gt; seq_in_seq(range(3),range(5))\n    0\n    &gt;&gt;&gt; seq_in_seq(range(3)[-1:],range(5))\n    2\n    &gt;&gt;&gt;seq_in_seq(range(6),range(5))\n    -1\n    '''\n    def compute_prefix_function(p):\n        m = len(p)\n        pi = [0] * m\n        k = 0\n        for q in xrange(1, m):\n            while k &gt; 0 and p[k] != p[q]:\n                k = pi[k - 1]\n            if p[k] == p[q]:\n                k = k + 1\n            pi[q] = k\n        return pi\n\n    t,p = list(tee(seq2)[0]), list(tee(seq1)[0])\n    m,n = len(p),len(t)\n    pi = compute_prefix_function(p)\n    q = 0\n    for i in range(n):\n        while q &gt; 0 and p[q] != t[i]:\n            q = pi[q - 1]\n        if p[q] == t[i]:\n            q = q + 1\n        if q == m:\n            return i - m + 1\n    return -1\n</code>\n</pre>\n", "senID": 1}]]