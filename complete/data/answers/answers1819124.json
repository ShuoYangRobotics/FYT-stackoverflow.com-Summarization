[[{"text": ["A similar question was asked a year ago and has numerous responses, including one regarding pixelizing the images, which I was going to suggest as at least a pre-qualification step (as it would exclude very non-similar images quite quickly)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "similar question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/189943/how-can-i-quantify-difference-between-two-images"}]}, {"text": ["There are also links there to still-earlier questions which have even more references and good answers."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here's an implementation using some of the ideas with Scipy, using your above three images (saved as im1.jpg, im2.jpg, im3.jpg, respectively).", "The final output shows im1 compared with itself, as a baseline, and then each image compared with the others."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import scipy as sp\n&gt;&gt;&gt; from scipy.misc import imread\n&gt;&gt;&gt; from scipy.signal.signaltools import correlate2d as c2d\n&gt;&gt;&gt;\n&gt;&gt;&gt; def get(i):\n...     # get JPG image as Scipy array, RGB (3 layer)\n...     data = imread('im%s.jpg' % i)\n...     # convert to grey-scale using W3C luminance calc\n...     data = sp.inner(data, [299, 587, 114]) / 1000.0\n...     # normalize per http://en.wikipedia.org/wiki/Cross-correlation\n...     return (data - data.mean()) / data.std()\n...\n&gt;&gt;&gt; im1 = get(1)\n&gt;&gt;&gt; im2 = get(2)\n&gt;&gt;&gt; im3 = get(3)\n&gt;&gt;&gt; im1.shape\n(105, 401)\n&gt;&gt;&gt; im2.shape\n(109, 373)\n&gt;&gt;&gt; im3.shape\n(121, 457)\n&gt;&gt;&gt; c11 = c2d(im1, im1, mode='same')  # baseline\n&gt;&gt;&gt; c12 = c2d(im1, im2, mode='same')\n&gt;&gt;&gt; c13 = c2d(im1, im3, mode='same')\n&gt;&gt;&gt; c23 = c2d(im2, im3, mode='same')\n&gt;&gt;&gt; c11.max(), c12.max(), c13.max(), c23.max()\n(42105.00000000259, 39898.103896795357, 16482.883608327804, 15873.465425120798)\n</code>\n</pre>\n", "senID": 3}, {"text": ["So note that im1 compared with itself gives a score of 42105, im2 compared with im1 is not far off that, but im3 compared with either of the others gives well under half that value.", "You'd have to experiment with other images to see how well this might perform and how you might improve it."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Run time is long... several minutes on my machine.", "I would try some pre-filtering to avoid wasting time comparing very dissimilar images, maybe with the \"compare jpg file size\" trick mentioned in responses to the other question, or with pixelization.", "The fact that you have images of different sizes complicates things, but you didn't give enough information about the extent of butchering one might expect, so it's hard to give a specific answer that takes that into account."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I have one done this with an image histogram comparison.", "My basic algorithm was this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "image histogram", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://colorschemedesigner.com/#3-32CvKhNF3nk"}]}, {"text": ["here is some code with numpy and pil"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "numpy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "pil", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n r = numpy.asarray(im.convert( \"RGB\", (1,0,0,0, 1,0,0,0, 1,0,0,0) ))\ng = numpy.asarray(im.convert( \"RGB\", (0,1,0,0, 0,1,0,0, 0,1,0,0) ))\nb = numpy.asarray(im.convert( \"RGB\", (0,0,1,0, 0,0,1,0, 0,0,1,0) ))\nhr, h_bins = numpy.histogram(r, bins=256, new=True, normed=True)\nhg, h_bins = numpy.histogram(g, bins=256, new=True, normed=True)\nhb, h_bins = numpy.histogram(b, bins=256, new=True, normed=True)\nhist = numpy.array([hr, hg, hb]).ravel()\n</code>\n</pre>\n", "senID": 2}, {"text": ["if you have two histograms, you can get the distance like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n diff = hist1 - hist2\ndistance = numpy.sqrt(numpy.dot(diff, diff))\n</code>\n</pre>\n", "senID": 4}, {"text": ["If the two images are identical, the distance is 0, the more they diverge, the greater the distance."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["It worked quite well for photos for me but failed on graphics like texts and logos."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["If your problem is about shifted pixels, maybe you should compare against a frequency transform."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The FFT should be OK (numpy has an implementation for 2D matrices), but I'm always hearing that Wavelets are better for this kind of tasks ^_^ "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "numpy has an implementation for 2D matrices", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/numpy/reference/generated/numpy.fft.fft2.html#numpy.fft.fft2"}]}, {"text": ["About the performance, if all the images are of the same size, if I remember well, the FFTW package created an specialised function for each FFT input size, so you can get a nice performance boost reusing the same code...", "I don't know if numpy is based on FFTW, but if it's not maybe you could try to investigate a little bit there."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here you have a prototype... you can play a little bit with it to see which threshold fits with your images."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import Image\nimport numpy\nimport sys\n\ndef main():\n    img1 = Image.open(sys.argv[1])\n    img2 = Image.open(sys.argv[2])\n\n    if img1.size != img2.size or img1.getbands() != img2.getbands():\n    \treturn -1\n\n    s = 0\n    for band_index, band in enumerate(img1.getbands()):\n    \tm1 = numpy.fft.fft2(numpy.array([p[band_index] for p in img1.getdata()]).reshape(*img1.size))\n    \tm2 = numpy.fft.fft2(numpy.array([p[band_index] for p in img2.getdata()]).reshape(*img2.size))\n    \ts += numpy.sum(numpy.abs(m1-m2))\n    print s\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n</code>\n</pre>\n", "senID": 4}, {"text": ["Another way to proceed might be blurring the images, then subtracting the pixel values from the two images.", "If the difference is non nil, then you can shift one of the images 1 px in each direction and compare again, if the difference is lower than in the previous step, you can repeat shifting in the direction of the gradient and subtracting until the difference is lower than a certain threshold or increases again.", "That should work if the radius of the blurring kernel is larger than the shift of the images."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Also, you can try with some of the tools that are commonly used in the photography workflow for blending multiple expositions or doing panoramas, like the Pano Tools."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Pano Tools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.panotools.org/Align%5Fimage%5Fstack"}]}], [{"text": ["You really need to specify the question better, but, looking at those 5 images, the organisms all seem to be oriented the same way.", "If this is always the case, you can try doing a normalized cross-correlation between the two images and taking the peak value as your degree of similarity.", "I don't know of a normalized cross-correlation function in Python, but there is a similar fftconvolve() function and you can do the circular cross-correlation yourself:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "normalized cross-correlation", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.mathworks.com/products/demos/image/cross%5Fcorrelation/imreg.html"}, {"text": "fftconvolve()", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.scipy.org/doc/api%5Fdocs/SciPy.signal.signaltools.html#fftconvolve"}]}, {"code": "<pre>\n<code>\n a = asarray(Image.open('c603225337.jpg').convert('L'))\nb = asarray(Image.open('9b78f22f42.jpg').convert('L'))\nf1 = rfftn(a)\nf2 = rfftn(b)\ng =  f1 * f2\nc = irfftn(g)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This won't work as written since the images are different sizes, and the output isn't weighted or normalized at all."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The location of the peak value of the output indicates the offset between the two images, and the magnitude of the peak indicates the similarity.", "There should be a way to weight/normalize it so that you can tell the difference between a good match and a poor match."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["This isn't as good of an answer as I want, since I haven't figured out how to normalize it yet, but I'll update it if I figure it out, and it will give you an idea to look into."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I have done some image processing course long ago, and remember that when matching I normally started with making the image grayscale, and then sharpening the edges of the image so you only see edges.", "You (the software) can then shift and subtract the images until the difference is minimal. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If that difference is larger than the treshold you set, the images are not equal and you can move on to the next.", "Images with a smaller treshold can then be analyzed next."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I do think that at best you can radically thin out possible matches, but will need to personally compare possible matches to determine they're really equal."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I can't really show code as it was a long time ago, and I used Khoros/Cantata for that course."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["First off, correlation is a very CPU intensive rather inaccurate measure for similarity.", "Why not just go for the sum of the squares if differences between individual pixels?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A simple solution, if the maximum shift is limited: generate all possible shifted images and find the one that is the best match.", "Make sure you calculate your match variable (i.e.", "correllation) only over the subset of pixels that can be matched in all shifted images.", "Also, your maximum shift should be significantly smaller than the size of your images."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you want to use some more advances image processing techniques I suggest you look at SIFT this is a very powerfull method that (theoretically anyway) can properly match items in images independent of translation, rotation and scale."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "SIFT", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Scale-invariant%5Ffeature%5Ftransform"}]}], [{"text": ["I guess you could do something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["estimate vertical / horizontal displacement of reference image vs the comparison image.", "a \nsimple SAD (sum of absolute difference) with motion vectors would do to. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["shift the comparison image accordingly "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": "compute the pearson correlation you were trying to do", "tag": "none", "senID": 3}]}, {"text": ["Shift measurement is not difficult. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 6, "lis": [{"text": "Take a region (say about 32x32) in comparison image. ", "tag": "none", "senID": 5}, {"text": "Shift it by x pixels in horizontal and y pixels in vertical direction. ", "tag": "none", "senID": 6}, {"text": "Compute the SAD (sum of absolute difference) w.r.t. original image", "tag": "none", "senID": 7}, {"text": "Do this for several values of x and y in a small range (-10, +10)", "tag": "none", "senID": 8}, {"text": "Find the place where the difference is minimum", "tag": "none", "senID": 9}, {"text": "Pick that value as the shift motion vector ", "tag": "none", "senID": 10}]}, {"text": ["Note:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["If the SAD is coming very high for all values of x and y then you can anyway assume that the images are highly dissimilar and shift measurement is not necessary."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}]]