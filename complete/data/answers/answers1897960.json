[[{"text": ["You can use dir to get a list the methods of any object.", "This is very useful in the interactive prompt:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dir", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dir(l1)\n['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__',\n'__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__',\n'__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__',\n'__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__',\n'__str__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']\n</code>\n</pre>\n", "senID": 1}, {"text": ["The interesting methods are usually those not starting with underscores.", "You can write your own version of dir that ignores names starting with underscores if you wish:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; mydir = lambda a:[x for x in dir(a) if not x.startswith('_')]\n&gt;&gt;&gt; mydir([])\n['append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You might want to look at the getmembers function in the inspect module"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "getmembers", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "inspect", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n In [1]: import inspect\n\nIn [2]: inspect?\nType:   \tmodule\nBase Class: &lt;type 'module'&gt;\nString Form:    &lt;module 'inspect' from '/usr/lib/python2.6/inspect.pyc'&gt;\nNamespace:  Interactive\nFile:   \t/usr/lib/python2.6/inspect.py\nDocstring:\n    Get useful information from live Python objects.\n\n    This module encapsulates the interface provided by the internal special\n    attributes (func_*, co_*, im_*, tb_*, etc.) in a friendlier fashion.\n    It also provides some help for examining source code and class layout.\n\n    Here are some of the useful functions provided by this module:\n\n        ismodule(), isclass(), ismethod(), isfunction(), isgeneratorfunction(),\n            isgenerator(), istraceback(), isframe(), iscode(), isbuiltin(),\n            isroutine() - check object types\n        getmembers() - get members of an object that satisfy a given condition\n\n        getfile(), getsourcefile(), getsource() - find an object's source code\n        getdoc(), getcomments() - get documentation on an object\n        getmodule() - determine the module that an object came from\n        getclasstree() - arrange classes so as to represent their hierarchy\n\n        getargspec(), getargvalues() - get info about function arguments\n        formatargspec(), formatargvalues() - format an argument spec\n        getouterframes(), getinnerframes() - get info about frames\n        currentframe() - get the current stack frame\n        stack(), trace() - get info about frames on the stack or in a traceback\n\nIn [3]: l1=[1,5,7]\n\nIn [4]: inspect.getmembers(l1)\nOut[4]: \n[('__add__', &lt;method-wrapper '__add__' of list object at 0xa38716c&gt;),\n ('__class__', &lt;type 'list'&gt;),\n ('__contains__', &lt;method-wrapper '__contains__' of list object at 0xa38716c&gt;),\n ('__delattr__', &lt;method-wrapper '__delattr__' of list object at 0xa38716c&gt;),\n ('__delitem__', &lt;method-wrapper '__delitem__' of list object at 0xa38716c&gt;),\n ('__delslice__', &lt;method-wrapper '__delslice__' of list object at 0xa38716c&gt;),\n ('__doc__',\n  \"list() -&gt; new list\\nlist(sequence) -&gt; new list initialized from sequence's items\"),\n ('__eq__', &lt;method-wrapper '__eq__' of list object at 0xa38716c&gt;),\n ('__format__', &lt;built-in method __format__ of list object at 0xa38716c&gt;),\n ('__ge__', &lt;method-wrapper '__ge__' of list object at 0xa38716c&gt;),\n ('__getattribute__',\n  &lt;method-wrapper '__getattribute__' of list object at 0xa38716c&gt;),\n ('__getitem__', &lt;built-in method __getitem__ of list object at 0xa38716c&gt;),\n ('__getslice__', &lt;method-wrapper '__getslice__' of list object at 0xa38716c&gt;),\n ('__gt__', &lt;method-wrapper '__gt__' of list object at 0xa38716c&gt;),\n ('__hash__', None),\n ('__iadd__', &lt;method-wrapper '__iadd__' of list object at 0xa38716c&gt;),\n ('__imul__', &lt;method-wrapper '__imul__' of list object at 0xa38716c&gt;),\n ('__init__', &lt;method-wrapper '__init__' of list object at 0xa38716c&gt;),\n ('__iter__', &lt;method-wrapper '__iter__' of list object at 0xa38716c&gt;),\n ('__le__', &lt;method-wrapper '__le__' of list object at 0xa38716c&gt;),\n ('__len__', &lt;method-wrapper '__len__' of list object at 0xa38716c&gt;),\n ('__lt__', &lt;method-wrapper '__lt__' of list object at 0xa38716c&gt;),\n ('__mul__', &lt;method-wrapper '__mul__' of list object at 0xa38716c&gt;),\n ('__ne__', &lt;method-wrapper '__ne__' of list object at 0xa38716c&gt;),\n ('__new__', &lt;built-in method __new__ of type object at 0x822be40&gt;),\n ('__reduce__', &lt;built-in method __reduce__ of list object at 0xa38716c&gt;),\n ('__reduce_ex__',\n  &lt;built-in method __reduce_ex__ of list object at 0xa38716c&gt;),\n ('__repr__', &lt;method-wrapper '__repr__' of list object at 0xa38716c&gt;),\n ('__reversed__', &lt;built-in method __reversed__ of list object at 0xa38716c&gt;),\n ('__rmul__', &lt;method-wrapper '__rmul__' of list object at 0xa38716c&gt;),\n ('__setattr__', &lt;method-wrapper '__setattr__' of list object at 0xa38716c&gt;),\n ('__setitem__', &lt;method-wrapper '__setitem__' of list object at 0xa38716c&gt;),\n ('__setslice__', &lt;method-wrapper '__setslice__' of list object at 0xa38716c&gt;),\n ('__sizeof__', &lt;built-in method __sizeof__ of list object at 0xa38716c&gt;),\n ('__str__', &lt;method-wrapper '__str__' of list object at 0xa38716c&gt;),\n ('__subclasshook__',\n  &lt;built-in method __subclasshook__ of type object at 0x822be40&gt;),\n ('append', &lt;built-in method append of list object at 0xa38716c&gt;),\n ('count', &lt;built-in method count of list object at 0xa38716c&gt;),\n ('extend', &lt;built-in method extend of list object at 0xa38716c&gt;),\n ('index', &lt;built-in method index of list object at 0xa38716c&gt;),\n ('insert', &lt;built-in method insert of list object at 0xa38716c&gt;),\n ('pop', &lt;built-in method pop of list object at 0xa38716c&gt;),\n ('remove', &lt;built-in method remove of list object at 0xa38716c&gt;),\n ('reverse', &lt;built-in method reverse of list object at 0xa38716c&gt;),\n ('sort', &lt;built-in method sort of list object at 0xa38716c&gt;)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Interactive Python has a help function you can use with anything:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "help", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; help(list)\nHelp on class list in module __builtin__:\n\nclass list(object)\n |  list() -&gt; new list\n |  list(sequence) -&gt; new list initialized from sequence\u00b4s items\n |\n |  Methods defined here:\n |\n |  __add__(...)\n |      x.__add__(y) &lt;==&gt; x+y\n |\n |  __contains__(...)\n |      x.__contains__(y) &lt;==&gt; y in x\n |\n |  __delitem__(...)\n |      x.__delitem__(y) &lt;==&gt; del x[y]\n |\n |  __delslice__(...)\n |      x.__delslice__(i, j) &lt;==&gt; del x[i:j]\n |\n |      Use of negative indices is not supported.\n |\n |  __eq__(...)\n |      x.__eq__(y) &lt;==&gt; x==y\n |\n |  __ge__(...)\n |      x.__ge__(y) &lt;==&gt; x&gt;=y\n |\n |  __getattribute__(...)\n |      x.__getattribute__('name') &lt;==&gt; x.name\n |\n |  __getitem__(...)\n |      x.__getitem__(y) &lt;==&gt; x[y]\n |\n |  __getslice__(...)\n |      x.__getslice__(i, j) &lt;==&gt; x[i:j]\n |\n |      Use of negative indices is not supported.\n |\n |  __gt__(...)\n |      x.__gt__(y) &lt;==&gt; x&gt;y\n |\n |  __iadd__(...)\n |      x.__iadd__(y) &lt;==&gt; x+=y\n |\n |  __imul__(...)\n |      x.__imul__(y) &lt;==&gt; x*=y\n |\n |  __init__(...)\n |      x.__init__(...) initializes x; see x.__class__.__doc__ for signature\n |\n |  __iter__(...)\n |      x.__iter__() &lt;==&gt; iter(x)\n |\n |  __le__(...)\n |      x.__le__(y) &lt;==&gt; x&lt;=y\n |\n |  __len__(...)\n |      x.__len__() &lt;==&gt; len(x)\n |\n |  __lt__(...)\n |      x.__lt__(y) &lt;==&gt; x&lt;y\n |\n |  __mul__(...)\n |      x.__mul__(n) &lt;==&gt; x*n\n |\n |  __ne__(...)\n |      x.__ne__(y) &lt;==&gt; x!=y\n |\n |  __repr__(...)\n |      x.__repr__() &lt;==&gt; repr(x)\n |\n |  __reversed__(...)\n |      L.__reversed__() -- return a reverse iterator over the list\n |\n |  __rmul__(...)\n |      x.__rmul__(n) &lt;==&gt; n*x\n |\n |  __setitem__(...)\n |      x.__setitem__(i, y) &lt;==&gt; x[i]=y\n |\n |  __setslice__(...)\n |      x.__setslice__(i, j, y) &lt;==&gt; x[i:j]=y\n |\n |      Use  of negative indices is not supported.\n |\n |  __sizeof__(...)\n |      L.__sizeof__() -- size of L in memory, in bytes\n |\n |  append(...)\n |      L.append(object) -- append object to end\n |\n |  count(...)\n |      L.count(value) -&gt; integer -- return number of occurrences of value\n |\n |  extend(...)\n |      L.extend(iterable) -- extend list by appending elements from the iterable\n |\n |  index(...)\n |      L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.\n |      Raises ValueError if the value is not present.\n |\n |  insert(...)\n |      L.insert(index, object) -- insert object before index\n |\n |  pop(...)\n |      L.pop([index]) -&gt; item -- remove and return item at index (default last).\n |      Raises IndexError if list is empty or index is out of range.\n |\n |  remove(...)\n |      L.remove(value) -- remove first occurrence of value.\n |      Raises ValueError if the value is not present.\n |\n |  reverse(...)\n |      L.reverse() -- reverse *IN PLACE*\n |\n |  sort(...)\n |      L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;\n |      cmp(x, y) -&gt; -1, 0, 1\n |\n |  ----------------------------------------------------------------------\n |  Data and other attributes defined here:\n |\n |  __hash__ = None\n |\n |  __new__ = &lt;built-in method __new__ of type object at 0x1E1CF100&gt;\n |      T.__new__(S, ...) -&gt; a new object with type S, a subtype of T\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you install IPython, then you can do this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "IPython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ipython.scipy.org/"}]}, {"code": "<pre>\n<code>\n % ipython\nPython 2.6.4 (r264:75706, Nov  2 2009, 14:38:03) \nType \"copyright\", \"credits\" or \"license\" for more information.\n\nIPython 0.10 -- An enhanced Interactive Python.\n?         -&gt; Introduction and overview of IPython's features.\n%quickref -&gt; Quick reference.\nhelp      -&gt; Python's own help system.\nobject?   -&gt; Details about 'object'. ?object also works, ?? prints more.\n\nIn [1]: l1=[1,5,7]\n\nIn [2]: l1.\nl1.__add__           l1.__getslice__      l1.__new__           l1.append\nl1.__class__         l1.__gt__            l1.__reduce__        l1.count\nl1.__contains__      l1.__hash__          l1.__reduce_ex__     l1.extend\nl1.__delattr__       l1.__iadd__          l1.__repr__          l1.index\nl1.__delitem__       l1.__imul__          l1.__reversed__      l1.insert\nl1.__delslice__      l1.__init__          l1.__rmul__          l1.pop\nl1.__doc__           l1.__iter__          l1.__setattr__       l1.remove\nl1.__eq__            l1.__le__            l1.__setitem__       l1.reverse\nl1.__format__        l1.__len__           l1.__setslice__      l1.sort\nl1.__ge__            l1.__lt__            l1.__sizeof__        \nl1.__getattribute__  l1.__mul__           l1.__str__           \nl1.__getitem__       l1.__ne__            l1.__subclasshook__  \n\nIn [2]: l1.\n</code>\n</pre>\n", "senID": 1}, {"text": ["On the last line, you type the object name, a period, and then press TAB.", "IPython then lists all the attributes of the object. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I find IPython an invaluable tool for exploring object attributes.", "It is far more convenient to use than the standard Python interactive prompt.", "Among other nifty things, putting a question mark after an object gives you its doc string:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n In [6]: d.update?\nType:   \tbuiltin_function_or_method\nBase Class: &lt;type 'builtin_function_or_method'&gt;\nString Form:    &lt;built-in method update of dict object at 0xa3c024c&gt;\nNamespace:  Interactive\nDocstring:\n    D.update(E, **F) -&gt; None.  Update D from dict/iterable E and F.\n    If E has a .keys() method, does:     for k in E: D[k] = E[k]\n    If E lacks .keys() method, does:     for (k, v) in E: D[k] = v\n    In either case, this is followed by: for k in F: D[k] = F[k]\n</code>\n</pre>\n", "senID": 4}, {"text": ["And, when available, two question marks gives you its source code:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n In [18]: np.sum??\nType:   \tfunction\nBase Class: &lt;type 'function'&gt;\nString Form:    &lt;function sum at 0x9c501ec&gt;\nNamespace:  Interactive\nFile:   \t/usr/lib/python2.6/dist-packages/numpy/core/fromnumeric.py\nDefinition: np.sum(a, axis=None, dtype=None, out=None)\nSource:\ndef sum(a, axis=None, dtype=None, out=None):\n...\n    if isinstance(a, _gentype):\n        res = _sum_(a)\n        if out is not None:\n            out[...] = res\n            return out\n        return res\n    try:\n        sum = a.sum\n    except AttributeError:\n        return _wrapit(a, 'sum', axis, dtype, out)\n    return sum(axis, dtype, out)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["As it happens, all the members of list instances are methods.", "If that weren't the case, you could use this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l1 = [1, 5 , 7]\nprint [name for name in dir(l1) if type(getattr(l1, name) == type(l1.append))]\n</code>\n</pre>\n", "senID": 1}, {"text": ["That will exclude members that aren't methods."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If the object (which often might be a module) has many methods or attributes using dir or the TAB completion of ipython can get to complex to keep track."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In such cases I use filter like in the following example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n filter(lambda s: 'sin' in s.lower(), dir(numpy))\n</code>\n</pre>\n", "senID": 2}, {"text": ["which results in"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n ['arcsin',\n 'arcsinh',\n 'csingle',\n 'isinf',\n 'isposinf',\n 'sin',\n 'sinc',\n 'single',\n 'singlecomplex',\n 'sinh']\n</code>\n</pre>\n", "senID": 4}, {"text": ["I find that very handy to explore unknown objects from which I expect that they must have a method (or attribute) which should have  as part of its name."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]