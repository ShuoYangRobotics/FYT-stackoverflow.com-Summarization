[[{"text": ["I would do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n c = (x &gt;&gt; 8) &amp; 0xff\nf = x &amp; 0xff\n</code>\n</pre>\n", "senID": 1}, {"text": ["It is \"safer\", see e.g."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; (10303 &gt;&gt; 8) &amp;0xff\n40\n&gt;&gt;&gt; (1030333333 &gt;&gt; 8) &amp;0xff\n163\n&gt;&gt;&gt; (1030333333 &gt;&gt; 8) \n4024739\n</code>\n</pre>\n", "senID": 3}, {"text": ["Since in python you can't \"controll\" if the number is or not a 16bit, you have to \"force\" it into a at-most 16bit value; not needed if you're sure to have a 16bit-value, but this way the func is more general and allows you to be really \"interested\" only in \"16 bit\", no matter what the \"container\" contains."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You should be consistent, if the intent of the operations is arithmetical, use modulo and division, if it's just for raw bit manipulation, use shift and mask."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In python, bit-fiddling doesn't have any particular advantage, so I would go with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n c, f= divmod(your_number, 256)\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: To make your intention even more obvious to the powers-of-two-challenged source viewer (if such a beast exists), you can replace the plain 256 with much more colourful alternatives, like 1&lt;&lt;8, 2**8, 0x100 or 0400.", "The constant folding done by the peephole optimizer since 2.5 ensures that any of them is exactly the same like using 256 (I'm obviously talking about the former two alternatives, which are expressions that evaluate to 256; the latter two are the constant 256)."], "childNum": 9, "tag": "p", "senID": 2, "childList": [{"text": "256", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "1&lt;&lt;8", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "2**8", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "0x100", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "0400", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "256", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "256", "childNum": 0, "tag": "code", "childList": []}, {"text": "are", "childNum": 0, "tag": "em", "childList": []}, {"text": "256", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n $ python\nPython 2.6.4 (r264:75706, Dec  7 2009, 18:45:15)\n[GCC 4.4.1] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import dis\n&gt;&gt;&gt; dis.dis(compile(\"c, f= divmod(your_number, 1&lt;&lt;8)\", \"\", \"exec\"))\n  1           0 LOAD_NAME                0 (divmod)\n              3 LOAD_NAME                1 (your_number)\n              6 LOAD_CONST               3 (256)\n              9 CALL_FUNCTION            2\n             12 UNPACK_SEQUENCE          2\n             15 STORE_NAME               2 (c)\n             18 STORE_NAME               3 (f)\n             21 LOAD_CONST               2 (None)\n             24 RETURN_VALUE\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You say you're using these numbers as output, which suggests that they're going to be converted into strings at some point down the line.", "With that in mind, I'd suggest you take a look at the structmodule, which is designed for precisely this sort of thing (packing numbers into strings of binary data).", "As a bonus, you get built-in error checking for the case where x is greater than 65535 (so that if something is horribly wonky in your program, you'll get an exception).", "For example,"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "structmodule", "tag": "a", "pos": 1, "childList": [{"text": "struct", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/struct.html"}, {"text": "struct", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n s = struct.pack('&gt;H', x)\n</code>\n</pre>\n", "senID": 1}, {"text": ["is the equivalent of"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if x &gt; 65535:\n    raise struct.error(...)\nc, f = convert(x)\ns = chr(c) + chr(f) # big-endian (network) byte ordering\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you need the other byte ordering, you can write"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n s = struct.pack('&lt;H', x)\n</code>\n</pre>\n", "senID": 5}, {"text": ["If you have a whole bunch of numbers to convert at once, struct.pack can do them in bunches:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "struct.pack", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n x = [10333, 10475, 3021, ...] # for example\ns = struct.pack('&gt;' + 'H' * len(x), *x)\n</code>\n</pre>\n", "senID": 7}], [{"text": ["If you use the two halves of the number in different places, I'd recommend having two separate functions, but if you're going to use them in the same place, one function will work just as well."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There are several correct ways to split the number, so eventually it all comes down to personal preference.", "Your code will work fine, just so long as you only pass in numbers that are at most 16 bits long.", "(which probably won't be much of a problem, but you should be aware of it)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I would use the bitwise &amp; rather than %.", "It probably makes little difference these days for short integers, but in the wider view, the &amp; operator is potentially more efficient."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There may be some issue about how % handles negative numbers, but I doubt that that's relevant here."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]