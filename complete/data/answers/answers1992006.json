[[{"text": ["ValueError seems logical:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In [1]: int('abc')\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\n\n&lt;ipython console&gt; in &lt;module&gt;()\n\nValueError: invalid literal for int() with base 10: 'abc'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["ValueError is a good match for the case you have.", "Just go with that and remember that you can specify a useful message as an argument, letting you distinguish this from other types of ValueError."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ValueError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I would not make the code more complicated by defining a subclass, however, unless I had a good reason to want to catch just that particular error but avoid catching any other ValueErrors.", "Many applications have dozens of \"special\" error conditions, but if they also defined per-case subclasses the code would quickly get unmaintainable and anyone trying to use the routines would be constantly surprised by the unexpected new exceptions."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I vote for creating a unique subclass, InvalidFormatException."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["ValueError, while true, is vague."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["InvalidFormatException is more specific and tied directly to your problem."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["A user could wind up with situations where they're doing something that could produce either error.", "They could be converting roman numerals and then doing some math.", "They might need to distinguish between the ValueError and the InvalidFormatException. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Well really it depends whether you want (or need) that particular exception to be catchable independently of other ValueErrors that may occur during invocation of your code.", "It also depends whether you are the sole consumer of your code or it's intended for other people to use; in the latter case it may be helpful to these people if you define some high-level library-specific exceptions that they can check for."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ValueError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Yes.", ";-) ValueError does sound like the most applicable of the built-in ones, and with a subclass of that you seem to be doing the best possible.", "It's also what f.i.", "'%q' % 1 would raise."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "ValueError", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "'%q' % 1", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["I also support ValueError for this case.", "My 2 cents."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]