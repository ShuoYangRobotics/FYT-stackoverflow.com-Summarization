[[{"text": ["You could use map instead of the for loop you've shown, but since you do not appear to use the result of item.my_func(), this is not recommended.", "map should be used if you want to apply a function without side-effects to all elements of a list.", "In all other situations, use an explicit for-loop."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "map", "tag": "a", "pos": 0, "childList": [{"text": "map", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.0/library/functions.html#map"}, {"text": "map", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "item.my_func()", "childNum": 0, "tag": "code", "childList": []}, {"text": "not recommended", "childNum": 0, "tag": "strong", "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Also, as of Python 3.0 map returns a generator, so in that case map will not behave the same (unless you explicitly evaluate all elements returned by the generator, e.g.", "by calling list on it)."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "list", "tag": "a", "pos": 1, "childList": [{"text": "list", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.0/library/functions.html#list"}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: kibibu asks in the comments for a clarification on why map's first argument should not be a function with side effects.", "I'll give answering that question a shot:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "kibibu", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/81804/kibibu"}, {"text": "map", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["map is meant to be passed a function f in the mathematical sense.", "Under such circumstances it does not matter in which order f is applied to the elements of the second argument (as long as they are returned in their original order, of course).", "More importantly, under those circumstances map(g, map(f, l)) is semantically equivalent to map(lambda x: g(f(x)), l), regardless of the order in whichfandgare applied to their respective inputs."], "childNum": 10, "tag": "p", "senID": 3, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "in the mathematical sense", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Function_%28mathematics%29"}, {"text": "f", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "returned", "childNum": 0, "tag": "em", "childList": []}, {"text": "map(g, map(f, l))", "childNum": 0, "tag": "code", "childList": []}, {"text": "map(lambda x: g(f(x)), l)", "childNum": 0, "tag": "code", "childList": []}, {"text": "regardless of the order in whichfandgare applied to their respective inputs", "childNum": 2, "tag": "em", "childList": [{"text": "f", "tag": "code"}, {"text": "g", "tag": "code"}]}, {"text": "f", "childNum": 0, "tag": "code", "childList": []}, {"text": "g", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["E.g., it doesn't matter whether map returns and iterator or a full list at once.", "However, if f and/or g cause side effects, then this equivalence is only guaranteed if the semantics of map(g, map(f, l)) are such that at any stage g is applied to the first n elements returned by map(f, l) before map(f, l) applies f to the (n + 1)&#8203;st element of l. (Meaning that map must perform the laziest possible iteration---which it does in Python 3, but not in Python 2!"], "childNum": 12, "tag": "p", "senID": 4, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "g", "childNum": 0, "tag": "code", "childList": []}, {"text": "map(g, map(f, l))", "childNum": 0, "tag": "code", "childList": []}, {"text": "g", "childNum": 0, "tag": "code", "childList": []}, {"text": "n", "childNum": 0, "tag": "em", "childList": []}, {"text": "map(f, l)", "childNum": 0, "tag": "code", "childList": []}, {"text": "map(f, l)", "childNum": 0, "tag": "code", "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "childList": []}, {"text": "(n + 1)", "childNum": 0, "tag": "em", "childList": []}, {"text": "l", "childNum": 0, "tag": "code", "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Going one step further: even if we assume the Python 3 implementation of map, the semantic equivalence may easily break down if the output of map(f, l) is e.g.", "passed through itertools.tee before being supplied to the outer map call. "], "childNum": 5, "tag": "p", "senID": 5, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "map(f, l)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "itertools.tee", "tag": "a", "pos": 1, "childList": [{"text": "itertools.tee", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/itertools.html#itertools.tee"}, {"text": "itertools.tee", "childNum": 0, "tag": "code", "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The above discussion may seem of a theoretic nature, but as programs become more complex, they become more difficult to reason about and therefore harder to debug.", "Ensuring that some things are invariant alleviates that problem somewhat, and may in fact prevent a whole class of bugs."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Lastly, map reminds many people of its truly functional counterpart in various (purely) functional languages.", "Passing it a \"function\" with side effects will confuse those people.", "Therefore, seeing as the alternative (i.e., using an explicit loop) is not harder to implement than a call to map, it is highly recommended that one restricts use of map to those cases in which the function to be applied does not cause side effects."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You can write this using map like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n map(cls.my_func, items)\n</code>\n</pre>\n", "senID": 1}, {"text": ["replacing cls with the class of the items you are iterating over."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["As mentioned by Stephan202, this is not recommended in this case."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "not recommended", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["As a rule, if you want to create a new list by applying some function to each item in the list, use map.", "This has the implied meaning that the function has no side effect, and thus you could (potentially) run the map in parallel."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If you don't want to create a new list, or if the function has side effects, use a for loop.", "This is the case in your example."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["There is a slight semantic difference, which is probably closed in python language spec.", "The map is explicitly parallelizable, while for only in special situations.", "Code can break out from for, but only escape with exception from map."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "map", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "for", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "break", "childNum": 0, "tag": "em", "childList": []}, {"text": "for", "childNum": 0, "tag": "em", "childList": []}, {"text": "map", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["In my opinion map shouldn't also guarantee order of function application while for must.", "AFAIK no python implementation is currently able to do this auto-parallelization."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "map", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "for", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}], [{"text": ["You can switch Your map to some cool threaded OR multiprocessing OR distributed computing framework if You need to.", "Disco is an example of distributed, resistant to failures erlang-and-python based framework.", "I configured it on 2 boxes of 8 cores and now my program runs 16 times faster, thanks to the Disco cluster, however I had to rewrite my program from list comprehensions and for loops to map/reduce."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Disco", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://discoproject.org/"}]}, {"text": ["It's the same deal to write a program using for loops and list comprehensions and map/reduce, but when You need it to run on a cluster, You can do it almost for free if You used map/reduce.", "If You didn't, well, You will have to rewrite."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Beware: as far as I know, python 2.x returns a list instead of an iterator from map.", "I've heard this can be bypassed by using iter.imap() (never used it though)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "iter.imap()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Use an explicit for-loop when you don't need a list of results back (eg.", "functions with side-effects)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Use a list comprehension when you do need a list of results back (eg.", "functions that return a value based directly on the input)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Use map() when you're trying to convince Lisp users that Python is worth using.", ";)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The main advantage of map is when you want to get the result of some calculation on every element in a list.", "For example, this snippet doubles every value in a list:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n map(lambda x: x * 2, [1,2,3,4])  #=&gt; [2, 4, 6, 8]\n</code>\n</pre>\n", "senID": 1}, {"text": ["It is important to note that map returns a new list with the results.", "It does not modify the original list in place."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["To do the same thing with for, you would have to create an empty list and add an extra line to the for body to add the result of each calculation to the new list.", "The map version is more concise and functional."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Map can sometimes be faster for built-in functions than manually coding a for loop.", "Try timing map(str, range(1000000)) vs. a similar for loop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n map(lambda item: item.my_func(), items)\n</code>\n</pre>\n", "senID": 0}]]