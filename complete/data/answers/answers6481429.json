[[{"text": ["Why would someone write recursive code for that?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [1,2,4,8].index(4)\n2\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I assume this is homework."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So you need to understand recursion.", "Here's an example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def countdown(n):\n    if n == 0:\n        print \"Hello World!\"\n    else:\n        print n\n        countdown(n-1)\n</code>\n</pre>\n", "senID": 2}, {"text": ["You need to start with a starting point, in your case it would probably be the 0th element."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You need an end point, which should be the length - 1 or when you find the element."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "length - 1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Simple if else should do here, with a modified version of countdown as above."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["That works"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def recursive_index(L, v):\n    return 0 if L[0] == v else 1 + recursive_index(L[1:], v)\n</code>\n</pre>\n", "senID": 1}, {"text": ["but is pretty stupid (and will only work if the value exists)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You can add if v not in L: return -1 to make it work for any case, but that is even worst."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "if v not in L: return -1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Do it really has to be recursive?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Yet another way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def rec(l,v, index=0):\n    try:\n        if l[index] == v:\n            return index\n    except IndexError:\n        return -1            \n\n    return rec(l,v,index+1)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n L = [1, 2, 3, 4, 5, 6, 7, 11, 13]\n\ndef index(L, v):\n    if len(L) == 0:\n            return -1000000\n    elif L[0] == v:\n        return 0\n    else:\n        return 1 + index(L[1:], v)\n\nprint index(L, 7)\nprint index(L, 13)\nprint index(L, 100)\n</code>\n</pre>\n", "senID": 0}, {"text": ["* Remote Interpreter Reinitialized  *"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "* Remote Interpreter Reinitialized  *", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["-999991"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Assuming 0 indexing, the following code will return the index of the element if it exists, or -1 if it is not contained in the list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def index(L, v):\n    if L == []:\n        return -1\n    elif L[0] == v:\n        return 0\n    rv = index(L[1:], v)\n    if rv &lt; 0:\n        return rv\n    return rv + 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here a tail recursive version of it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def indexof(elem, list_):\n    return indexof_tailrec(elem, list_, 0)\n\ndef indexof_tailrec(elem, list_, index):\n    if index &gt;= len(list_):\n        return None\n    if list_[index] == elem:\n        return index\n    return indexof_tailrec(elem, list_, index + 1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note, however, that Python does not have tail call optimization (at least not as far as I know)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]