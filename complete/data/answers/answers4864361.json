[[{"code": "<pre>\n<code>\n with open('dwn.txt') as f:\n    for i in xrange(6):\n        f.next()\n    for line in f:\n        process(line)\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n with open('test.txt', 'r') as fo:\n   for i in xrange(6):\n       fo.next()\n   for line in fo:\n       print \"%s\" % line.strip()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["In fact, to answer precisely at the question as it was written "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n How do I \"split\" this file starting at line 7 to EOF?\n</code>\n</pre>\n", "senID": 1}, {"text": ["you can do "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["in case the file is not big:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n with open('dwn.txt','rb+') as f:\n    for i in xrange(6):\n        print f.readline()\n    content = f.read()\n    f.seek(0,0)\n    f.write(content)\n    f.truncate()\n</code>\n</pre>\n", "senID": 5}, {"text": ["in case the file is very big"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n with open('dwn.txt','rb+') as ahead, open('dwn.txt','rb+') as back:\n    for i in xrange(6):\n        print ahead.readline()\n\n    x = 100000\n    chunk = ahead.read(x)\n    while chunk:\n        print repr(chunk)\n        back.write(chunk)\n        chunk = ahead.read(x)\n    back.truncate()\n</code>\n</pre>\n", "senID": 7}, {"text": ["The truncate() function is essential to put the EOF you asked for.", "Without executing truncate() , the tail of the file, corresponding to the offset of 6 lines, would remain."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "truncate()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "truncate()", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["The file must be opened in binary mode to prevent any problem to happen."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "must", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["When Python reads '\\r\\n' , it transforms them in '\\n' (that's the Universal Newline Support, enabled by default) , that is to say there are only '\\n' in the chains chunk even if there were '\\r\\n' in the file."], "childNum": 5, "tag": "p", "senID": 11, "childList": [{"text": "'\\r\\n'", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "'\\n'", "childNum": 0, "tag": "strong", "childList": []}, {"text": "'\\n'", "childNum": 0, "tag": "strong", "childList": []}, {"text": "chunk", "childNum": 0, "tag": "strong", "childList": []}, {"text": "'\\r\\n'", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["If the file is from Macintosh origin , it contains only CR = '\\r' newlines before the treatment but they will be changed to '\\n' or '\\r\\n' (according to the platform) during the rewriting on a non-Macintosh machine."], "childNum": 3, "tag": "p", "senID": 12, "childList": [{"text": "'\\r'", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "'\\n'", "childNum": 0, "tag": "strong", "childList": []}, {"text": "'\\r\\n'", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["If it is a file from Linux origin, it contains only LF = '\\n' newlines which, on a Windows OS, will be changed to '\\r\\n' (I don't know for a Linux file processed on a Macintosh ).", "The reason is that the OS Windows writes '\\r\\n' whatever it is ordered to write , '\\n' or '\\r' or '\\r\\n'.", "Consequently, there would be more characters rewritten than having been read, and then the offset between the file's pointers ahead and back would diminish and cause a messy rewriting."], "childNum": 8, "tag": "p", "senID": 13, "childList": [{"text": "'\\n'", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "'\\r\\n'", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "'\\r\\n'", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "'\\n'", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "'\\r'", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "'\\r\\n'", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "ahead", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "back", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["In HTML sources , there are also various newlines."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["That's why it's always preferable to open files in binary mode when they are so processed. "], "childNum": 0, "tag": "p", "senID": 15, "childList": []}], [{"text": ["Itertools answer!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import islice\n\nwith open('foo') as f:\n    for line in islice(f, 6, None):\n        print line\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Use the fact that readlines() returns an array"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "readlines()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "array", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n open('dwn.txt', 'rb').readlines()[6:]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Just do f.readline() six times.", "Ignore the returned value."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can read the entire file into an array/list and then just start at the index appropriate to the line you wish to start reading at."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f = open('dwn.txt', 'rb')\nfileAsList = f.readlines()\nfileAsList[0] #first line\nfileAsList[1] #second line\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n #!/usr/bin/python\n\nwith open('dnw.txt', 'r') as f:\n    lines_7_through_end = f.readlines()[6:]\n\nprint \"Lines 7+:\"\ni = 7;\nfor line in lines_7_through_end:\n    print \"    Line %s: %s\" % (i, line)\n    i+=1\n</code>\n</pre>\n", "senID": 0}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["To rebuild dwn.txt without the first six lines, do this after the above code:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "dwn.txt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n with open('dnw.txt', 'w') as f:\n    for line in lines_7_through_end:\n        f.write(line)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Solutions with readlines() are not satisfactory in my opinion because readlines() reads the entire file.", "The user will have to read again the lines (in file or in the produced list) to process what he wants, while it could have been done without having read the intersting lines already a first time.", "Moreover if the file is big, the memory is weighed by the file's content while a for line in file instruction would have been lighter."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "readlines()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "readlines()", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "for line in file", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Doing repetition of readline() can be done like that"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n nb = 6\nexec( nb * 'f.readline()\\n')\n</code>\n</pre>\n", "senID": 2}, {"text": ["It's short piece of code and nb is programmatically adjustable"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "nb", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}]]