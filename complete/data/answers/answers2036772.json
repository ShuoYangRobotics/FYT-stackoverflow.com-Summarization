[[{"text": ["One way to modify your code would be to use a local function as follows:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def countSubStringMatchRecursive(target,key):\n    def countit(target,key,count):\n        index=find(target,key)\n        if index&gt;=0:\n            target=target[index+len(key):]\n            count += countit(target,key,count) + 1\n        return count\n    return \"No. of instances of\", key, 'in', target, 'is', countit(target,key,0)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's something similar to Greg Hewgill's answer.", "However, instead we pass along the current count each time we call the function, and then return the count when there are no more matches to be made.", "While I suspect it makes no difference in Python, in languages that implement tail-call recursion, this allows each successive call to do_count to be optimised away on the call stack.", "This means that each call to do_count doesn't cause the call stack to grow."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "do_count", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "do_count", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n def count_sub_strings(target, key):\n    def do_count(target, key, count):\n        index = target.find(key)\n        if index &gt;= 0:\n            target = target[index + len(key):]\n            return do_count(target, key, count + 1)\n        else:\n            return count\n    return \"No. of instances of %s in %s is %s\" % (key, target, do_count(target, key, 0))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Your recursive function has O(n^2) performance because it copies the remaining contents of the string each time it finds a match.", "This is slower than the iterative solution O(n) and unnecessarily so."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can easily rewrite it to be faster, and at the same time simplify the code and extend its functionality by passing a start index for the search as an optional parameter to the function:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def countSubStringMatchRecursive(target, key, start_index = 0):\n    index = target.find(key, start_index)\n    if index &gt;= 0:\n        return countSubStringMatchRecursive(target, key, index + len(key)) + 1\n    return 0\n\ntarget_string = 'an apple and a banana'\nkey = 'an'\ncount = countSubStringMatchRecursive(target_string,  key)\nprint \"Number of instances of %r in %r is %d\" % (key, target_string, count)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n Number of instances of 'an' in 'an apple and a banana' is 4\n</code>\n</pre>\n", "senID": 4}, {"text": ["Update: If you really want to use the string module's find function, you can do this just by changing one line:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n index = find(target, key, start_index)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Just a side note: all solutions presented (from the original Q to all the As) are solving a problem that's different than the specifically stated one (I imagine that's a bug in the specific problem statement, but, worth fixing if so;-).", "Consider:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 'banana'.count('ana')\n1\n&gt;&gt;&gt; sum('banana'[x:x+3]=='ana' for x in range(len('banana')))\n2\n</code>\n</pre>\n", "senID": 1}, {"text": ["the first expression is counting the non-overlapping occurrences of 'ana' in 'banana'; the second one is counting all occurrences -- there are two occurrences in all, at indices 1 and 3 in 'banana', and they overlap.", "So given the problem statement, and I quote:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "non-overlapping", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "all", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["without any mention of \"non-overlapping\", it seems that overlapping occurrences should be counted.", "Of course, that's easy to fix, once noticed -- you just have to advance by 1 each time, instead of advancing by len(key) which leads you to skip overlapping occurrences."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "should", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "len(key)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["So, for example:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import string\n\ndef countit(target, key, startfrom=0):\n    where = string.find(target, key, startfrom)\n    if where &lt; 0: return 0\n    return 1 + countit(target, key, where+1)\n\nprint countit('banana', 'ana')\n</code>\n</pre>\n", "senID": 5}, {"text": ["prints 2, counting both (overlapping) occurrences."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Another way could be to have a third optional parameter on the countSubStringMatchRecursive function called count that is originally set to 0.", "That way you could keep track of the count.", "This would expose the count variable to the outside world which might not be desirable, but since it's no worse than your global variable I don't think it would be a problem in your case."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "countSubStringMatchRecursive", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["You would also have to change the code to make the last recursive call be the call that gives the return statement to the outside world.", "See this example (untested):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def countSubStringMatchRecursive(target, key, count = 0):\n    index = find(target, key)\n    targetstring = target\n    if index &gt;= 0:\n        count += 1\n        target = target[index+len(key):]\n        countSubStringMatchRecursive(target, key, count)\n    else:\n        return \"No. of instances of\", key, 'in', targetstring, 'is', count\n</code>\n</pre>\n", "senID": 2}, {"text": ["Edit: I realised that you would need a fourth parameter to be able to keep the original string traveling along the recursion.", "This is probably a less than optimal solution and I would recommend using Greg Hewgill's solution.", "It has a clean separation between the interactions with the outside and the \"business logic\", making the code more reusable!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["How about this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def count_it(target, key):\n    index = target.find(key)\n    if index &gt;= 0:\n        return 1 + count_it(target[index+len(key):], key)\n    else:\n        return 0\n\n\nprint count_it(\"aaa bbb aaa ccc aaa\", \"aaa\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 3\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Not untested ..."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Not", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def countSubStringMatchRecursive(target, key, count=0):\n    #### index = find(target, key) # HUH?\n    index = target.find(key)\n    if index &gt;= 0:\n        count += 1\n        target = target[index+len(key):]\n        count = countSubStringMatchRecursive(target, key, count)\n    return count\n\nfor test in ['', 'bar', 'foo', 'foofoo', 'foo foo foo fo']:\n   print countSubStringMatchRecursive(test, 'foo'), test.count(key), repr(test)\n</code>\n</pre>\n", "senID": 2}, {"text": ["output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n 0 0 ''\n0 0 'bar'\n1 1 'foo'\n2 2 'foofoo'\n3 3 'foo foo foo fo'\n</code>\n</pre>\n", "senID": 4}, {"text": ["I'm presuming that this is just amusement or homework ... recursive function must be slower than corresponding Python iterative solution, which will be naturally slower than using target.count(key) ... so I haven't bothered with fixing all the problems your version had ... but do read PEP-008 :-)"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "target.count(key)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Comments on string module"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Comments on string module", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You commented that you had omitted from string import find.", "What version of Python are you using?", "What is the last update date on the book or tutorial that you are using?"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "from string import find", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["From the start of the string module (it will be on your computer as &lt;your Python install directory&gt;/Lib/string.py; I'm quoting from the 2.6 version):"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "&lt;your Python install directory&gt;/Lib/string.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["\"\"\"A collection of string operations (most are no longer used)."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Warning: most of the code you see here isn't normally used nowadays.", "Beginning with Python 1.6, many of these functions are implemented as\nmethods on the standard string object.", "They used to be implemented by\na built-in module called strop, but strop is now obsolete itself."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["etc \n\"\"\""], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["and here is that file's code for the find function (stripped of comments):"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "find", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def find(s, *args):\n    return s.find(*args)\n</code>\n</pre>\n", "senID": 13}, {"text": ["so using string.find(target, key) instead of target.find(key) is a waste. "], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "string.find(target, key)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "target.find(key)", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n def countSubStringMatchRecursive(target,key):\nindex = string.find(target, key)\nif index == -1:\n    return 0\nelse:\n    return 1 + countSubStringMatchRecursive(target[index+len(key):],key)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I'm doing this course on OpenCourseware, it's great.", "Anyways, this is what I did.", "I took inspiration from adamse above."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def countSubStringMatchRecursive(target, key, counter = 0):\n    if find(target,key) == 0:\n        countSubStringMatchRecursive(target[1:], key, counter + 1)\n    elif find(target,key) &gt; 0:\n        countSubStringMatchRecursive(target[1:], key, counter)\n    elif find(target,key) == -1:\n        print counter\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Taking into account overlapping occurrences and maintaining the original definition from MIT this is the simpler and more compact code that I can get."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "MIT", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-00-introduction-to-computer-science-and-programming-fall-2008/assignments/pset3.pdf"}]}, {"text": ["code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from string import *\ndef countSubStringMatchRecursive(target, key):\n    index = find(target, key)\n    if index &gt; -1:\n        return countSubStringMatchRecursive(target[index + 1:], key) + 1\n    return 0\n\n\ndef test(target, key):\n    instances = countSubStringMatchRecursive(target, key)\n    if instances == 0:\n        print \"No instance of %r in %r\" % (key, target)\n    else:\n        print \"Number of instances of %r in %r: %d\" % (key, target, instances)\n\ntest(\"atgacatgcacaagtatgcat\",\"ggcc\")\ntest(\"atgacatgcacaagtatgcat\",\"atgc\")\ntest(\"banana\", \"ana\")\n</code>\n</pre>\n", "senID": 2}, {"text": ["output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["No instance of 'ggcc' in 'atgacatgcacaagtatgcat'"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Number of instances of 'atgc' in 'atgacatgcacaagtatgcat': 2"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Number of instances of 'ana' in 'banana': 2"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]