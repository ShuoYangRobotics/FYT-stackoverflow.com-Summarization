[[{"text": ["This would work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n random.choice([k for k in d for x in d[k]])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Do you always know the total number of values in the dictionary?", "If so, this might be easy to do with the following algorithm, which can be used whenever you want to make a probabilistic selection of some items from an ordered list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This algorithm has the advantage of not having to generate any new lists, which is important if your dictionary is large.", "Your program is only paying for the loop over K keys to calculate the total, a another loop over the keys which will on average end halfway through, and whatever it costs to generate a random number between 0 and 1.", "Generating such a random number is a very common application in programming, so most languages have a fast implementation of such a function.", "In Python the random number generator a C implementation of the Mersenne Twister algorithm, which should be very fast.", "Additionally, the documentation claims that this implementation is thread-safe. "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "random number generator", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/random.html"}, {"text": "Mersenne Twister algorithm", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Mersenne%5FTwister"}]}, {"text": ["Here's the code.", "I'm sure that you can clean it up if you'd like to use more Pythonic features:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n\nimport random\n\ndef select_weighted( d ):\n   # calculate total\n   total = 0\n   for key in d:\n      total = total + len(d[key])\n   accept_prob = float( 1.0 / total )\n\n   # pick a weighted value from d\n   n_seen = 0\n   for key in d:\n      current_key = key\n      for val in d[key]:\n         dice_roll = random.random()\n         accept_prob = float( 1.0 / ( total - n_seen ) )\n         n_seen = n_seen + 1\n         if dice_roll &lt;= accept_prob:\n            return current_key\n\ndict = {\n   'a': [1, 3, 2],\n   'b': [6],\n   'c': [0, 0]\n}\n\ncounts = {}\nfor key in dict:\n   counts[key] = 0\n\nfor s in range(1,100000):\n   k = select_weighted(dict)\n   counts[k] = counts[k] + 1\n\nprint counts\n</code>\n</pre>\n", "senID": 3}, {"text": ["After running this 100 times, I get select keys this number of times:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n {'a': 49801, 'c': 33548, 'b': 16650}\n</code>\n</pre>\n", "senID": 5}, {"text": ["Those are fairly close to your expected values of:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n {'a': 0.5, 'c': 0.33333333333333331, 'b': 0.16666666666666666}\n</code>\n</pre>\n", "senID": 7}, {"text": ["Edit: Miles pointed out a serious error in my original implementation, which has since been corrected.", "Sorry about that!"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Given that your dict fits in memory, the random.choice method should be reasonable.", "But assuming otherwise, the next technique is to use a list of increasing weights, and use bisect to find a randomly chosen weight."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import random, bisect\n&gt;&gt;&gt; items, total = [], 0\n&gt;&gt;&gt; for key, value in d.items():\n        total += len(value)\n        items.append((total, key))\n\n\n&gt;&gt;&gt; items[bisect.bisect_left(items, (random.randint(1, total),))][1]\n'a'\n&gt;&gt;&gt; items[bisect.bisect_left(items, (random.randint(1, total),))][1]\n'c'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Without constructing a new, possibly big list with repeated values:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def select_weighted(d):\n   offset = random.randint(0, sum(d.itervalues())-1)\n   for k, v in d.iteritems():\n      if offset &lt; v:\n         return k\n      offset -= v\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Make a list in which each key is repeated a number of times equal to the length of its value.", "In your example: ['a', 'a', 'a', 'b', 'c', 'c'].", "Then use random.choice()."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "['a', 'a', 'a', 'b', 'c', 'c']", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "random.choice()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Edit: or, less elegantly but more efficiently, try this: take the sum of the lengths of all values in the dictionary, S (you can cache and invalidate this value, or keep it up to date as you edit the dictionary, depending on the exact usage pattern you anticipate).", "Generate a random number from 0 to S, and do a linear search through the dictionary keys to find the range into which your random number falls."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "S", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I think that's the best you can do without changing or adding to your data representation."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here is some code that is based on a previous answer I gave for probability distribution in python but is using the length to set the weight.", "It uses an iterative markov chain so that it does not need to know what the total of all of the weights are.", "Currently it calculates the max length but if that is too slow just change "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "probability distribution in python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/526255/probability-distribution-in-python/526585#526585"}]}, {"code": "<pre>\n<code>\n self._maxw = 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["to  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n self._maxw = max lenght\n</code>\n</pre>\n", "senID": 3}, {"text": ["and remove"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n for k in self._odata:\n     if len(self._odata[k])&gt; self._maxw:\n          self._maxw=len(self._odata[k])\n</code>\n</pre>\n", "senID": 5}, {"text": ["Here is the code."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import random\n\n\nclass RandomDict:\n    \"\"\"\n    The weight is the length of each object in the dict.\n    \"\"\"\n\n    def __init__(self,odict,n=0):\n        self._odata = odict\n        self._keys = list(odict.keys())\n        self._maxw = 1  # to increase speed set me to max length\n        self._len=len(odict)\n        if n==0:\n            self._n=self._len\n        else:\n            self._n=n\n        # to increase speed set above max value and comment out next 3 lines\n        for k in self._odata:\n            if len(self._odata[k])&gt; self._maxw:\n                self._maxw=len(self._odata[k])\n\n\n    def __iter__(self):\n        return self.next()\n\n    def next(self):\n        while (self._len &gt; 0) and (self._n&gt;0):\n            self._n -= 1\n            for i in range(100):\n                k=random.choice(self._keys)\n                rx=random.uniform(0,self._maxw)\n                if rx &lt;= len(self._odata[k]): # test to see if that is the value we want\n                    break\n            # if you do not find one after 100 tries then just get a random one\n            yield k\n\n    def GetRdnKey(self):\n        for i in range(100):\n            k=random.choice(self._keys)\n            rx=random.uniform(0,self._maxw)\n\n            if rx &lt;= len(self._odata[k]): # test to see if that is the value we want\n                break\n        # if you do not find one after 100 tries then just get a random one\n        return k\n\n\n\n#test code\n\nd = {\n 'a': [1, 3, 2],\n 'b': [6],\n 'c': [0, 0]\n}\n\n\nrd=RandomDict(d)\n\ndc = {\n 'a': 0,\n 'b': 0,\n 'c': 0\n}\nfor i in range(100000):\n    k=rd.GetRdnKey()\n    dc[k]+=1\n\nprint(\"Key count=\",dc)\n\n\n\n#iterate over the objects\n\ndc = {\n 'a': 0,\n 'b': 0,\n 'c': 0\n}\n\nfor k in RandomDict(d,100000):\n    dc[k]+=1\n\nprint(\"Key count=\",dc)\n</code>\n</pre>\n", "senID": 7}, {"text": ["Test results"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n Key count= {'a': 50181, 'c': 33363, 'b': 16456}\nKey count= {'a': 50080, 'c': 33411, 'b': 16509}\n</code>\n</pre>\n", "senID": 9}], [{"text": ["I'd say this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n random.choice(\"\".join([k * len(d[k]) for k in d]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This makes it clear that each k in d gets as many chances as the length of its value.", "Of course, it is relying on dictionary keys of length 1 that are characters...."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Much later:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n table = \"\".join([key * len(value) for key, value in d.iteritems()])\nrandom.choice(table)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I modified some of the other answers to come up with this.", "It's a bit more configurable.", "It takes 2 arguments, a list and a lambda function to tell it how to generate a key."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def select_weighted(lst, weight):\n   \"\"\" Usage: select_weighted([0,1,10], weight=lambda x: x) \"\"\"\n   thesum = sum([weight(x) for x in lst])\n   if thesum == 0:\n      return random.choice(lst)\n   offset = random.randint(0, thesum - 1)\n\n   for k in lst:\n      v = weight(k)\n      if offset &lt; v:\n         return k\n      offset -= v\n</code>\n</pre>\n", "senID": 1}, {"text": ["Thanks to sth for the base code for this."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]