[[{"text": ["Don't parse HTML with regex."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Don't parse HTML with regex.", "tag": "a", "pos": 0, "childList": [{"text": "Don't parse HTML with regex.", "tag": "strong"}], "childNum": 1, "href": "http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454"}, {"text": "Don't parse HTML with regex.", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Regex is not the right tool to use for this problem.", "Look up BeautifulSoup or lxml."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "BeautifulSoup", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/"}, {"href": "http://codespeak.net/lxml/", "text": "lxml", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["You can join two alternatives with a vertical bar:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n start = '&lt;font color=\"red\"&gt;|&lt;span style=\"font-weight:bold;\"&gt;'\nend = '&lt;/font&gt;|&lt;/span&gt;'\n</code>\n</pre>\n", "senID": 1}, {"text": ["since you know that a font tag will always be closed by &lt;/font&gt;, a span tag always by &lt;/span&gt;."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "&lt;/font&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "&lt;/span&gt;", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["However, consider also using a solid HTML parser such as BeautifulSoup, rather than rolling your own regular expressions, to parse HTML, which is particularly unsuitable in general for getting parsed by regular expressions."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Although regular expressions are not your best choice for parsing HTML. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["For the sake of education, here is a possible answer to your question:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n start = '&lt;(?P&lt;tag&gt;font|tag) color=\"red\"&gt;'\nend = '&lt;/(?P=tag)&gt;'\nexpression = start + '(.*?)' + end\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n expression = '(&lt;font color=\"red\"&gt;(.*?)&lt;/font&gt;|&lt;span style=\"font-weight:bold;\"&gt;(.*?)&lt;/span&gt;)'\nmatch = re.compile(expression).search(web_source_code)\nneeded_info = match.group(2)\n</code>\n</pre>\n", "senID": 0}, {"text": ["This would get the job done but you shouldn't really be using regex to parse html"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Regex and HTML are not such a good match, HTML has too many potential variations that will trip up your regex.", "BeautifulSoup is the standard tool to employ here, but I find pyparsing can be just as effective, and sometimes even simpler to construct when trying to locate a particular tag relative to a particular previous tag."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is how to address your question using pyparsing:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n html = \"\"\" need to get info from a website that outputs it between &lt;font color=\"red\"&gt;needed-info-here&lt;/font&gt; OR &lt;span style=\"font-weight:bold;\"&gt;needed-info-here&lt;/span&gt;, randomly.\n&lt;font color=\"white\"&gt;but not this info&lt;/font&gt; and \n&lt;span style=\"font-weight:normal;\"&gt;dont want this either&lt;/span&gt;\n\"\"\"\n\nfrom pyparsing import *\n\nfont,fontEnd = makeHTMLTags(\"FONT\")\n# only match &lt;font&gt; tags with color=\"red\"\nfont.setParseAction(withAttribute(color=\"red\"))\n# only match &lt;span&gt; tags with given style\nspan,spanEnd = makeHTMLTags(\"SPAN\")\nspan.setParseAction(withAttribute(style=\"font-weight:bold;\"))\n\n# define full match patterns, define \"body\" results name for easy access\nfontpattern = font + SkipTo(fontEnd)(\"body\") + fontEnd\nspanpattern = span + SkipTo(spanEnd)(\"body\") + spanEnd\n\n# now create a single pattern, matching either of the other patterns\nsearchpattern = fontpattern | spanpattern\n\n# call searchString, and extract body element from each match\nfor text in searchpattern.searchString(html):\n    print text.body\n</code>\n</pre>\n", "senID": 2}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n needed-info-here\nneeded-info-here\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I haven't used Python, but if you make expressions equal to the following, it should work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n /(?P&lt;open&gt;&lt;(font|span)[^&gt;]*&gt;)(?P&lt;info&gt;[^&lt;]+)(?P&lt;close&gt;&lt;\\/(font|span)&gt;)/gi\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then just access your needed info with the name \"info\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["PS - I also agree about the \"not parsing HTML with regex\" rule, but if you know that it will appear in either font or span tags, then so be it..."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "know", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Also, why use the font tag?", "I haven't used a font tag since I learned CSS."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]