[[{"text": ["Use matplotlib's calls that won't block:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "matplotlib", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Using draw():"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "draw()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from matplotlib import plot, draw, show\nplot([1,2,3])\ndraw()\nprint 'continue computation'\n\n# at the end call show to ensure window won't close.\nshow()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Using interactive mode:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from matplotlib import plot, ion, show\nion() # enables interactive mode\nplot([1,2,3]) # result shows immediatelly (implicit draw())\n\nprint 'continue computation'\n\n# at the end call show to ensure window won't close.\nshow()\n</code>\n</pre>\n", "senID": 4}], [{"text": ["It is better to always check with the library you are using if it supports usage in a non-blocking way."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "non-blocking", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["But if you want a more generic solution, or if there is no other way, you can run anything that blocks in a separated process by using the multprocessing module included in python.", "Computation will continue:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "multprocessing", "tag": "a", "pos": 0, "childList": [{"text": "multprocessing", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/multiprocessing.html"}, {"text": "multprocessing", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n from multiprocessing import Process\nfrom matplotlib import plot, show\n\ndef plot_graph(*args):\n    for data in args:\n        plot(data)\n    show()\n\np = Process(target=plot_graph, args=([1, 2, 3],))\np.start()\n\nprint 'yay'\nprint 'computation continues...'\nprint 'that rocks.'\n\nprint 'Now lets wait for the graph be closed to continue...:'\np.join()\n</code>\n</pre>\n", "senID": 2}, {"text": ["That has the overhead of launching a new process, and is sometimes harder to debug on complex scenarios, so I'd prefer the other solution (using matplotlib's nonblocking API calls)"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "matplotlib", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/458209/is-there-a-way-to-detach-matplotlib-plots-so-that-the-computation-can-continue#458295", "text": "nonblocking API calls", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["You may want to read this document in matplotlib's documentation, titled:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "matplotlib", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Using matplotlib in a python shell"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Using matplotlib in a python shell", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://matplotlib.sourceforge.net/users/shell.html#using-matplotlib-in-a-python-shell"}]}], [{"text": ["In my case, I wanted to have several windows pop up as they are being computed.", "For reference, this is the way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from matplotlib.pyplot import draw, figure, show\nf1, f2 = figure(), figure()\naf1 = f1.add_subplot(111)\naf2 = f2.add_subplot(111)\naf1.plot([1,2,3])\naf2.plot([6,5,4])\ndraw() \nprint 'continuing computation'\nshow()\n</code>\n</pre>\n", "senID": 1}, {"text": ["PS.", "A quite useful guide to matplotlib's OO interface."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "guide to matplotlib's OO interface", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://matplotlib.sourceforge.net/leftwich_tut.txt"}]}], [{"text": ["Well, I had great trouble figuring out the non-blocking commands...", "But finally, I managed to rework the \"Cookbook/Matplotlib/Animations - Animating selected plot elements\" example, so it works with threads (and passes data between threads either via global variables, or through a multiprocessPipe) on Python 2.6.5 on Ubuntu 10.04. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Cookbook/Matplotlib/Animations - Animating selected plot elements", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.scipy.org/Cookbook/Matplotlib/Animations#head-3d51654b8306b1585664e7fe060a60fc76e5aa08"}, {"text": "and passes data between threads either via global variables, or through a multiprocessPipe", "childNum": 1, "tag": "em", "childList": [{"text": "Pipe", "tag": "code"}]}, {"text": "Pipe", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The script can be found here: Animating_selected_plot_elements-thread.py - otherwise pasted below (with fewer comments) for reference: "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Animating_selected_plot_elements-thread.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://sdaaubckp.svn.sourceforge.net/viewvc/sdaaubckp/single-scripts/Animating_selected_plot_elements-thread.py?revision=101&content-type=text%2Fplain"}, {"text": "with fewer comments", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n import sys\nimport gtk, gobject\nimport matplotlib\nmatplotlib.use('GTKAgg')\nimport pylab as p\nimport numpy as nx \nimport time\n\nimport threading \n\n\n\nax = p.subplot(111)\ncanvas = ax.figure.canvas\n\n# for profiling\ntstart = time.time()\n\n# create the initial line\nx = nx.arange(0,2*nx.pi,0.01)\nline, = ax.plot(x, nx.sin(x), animated=True)\n\n# save the clean slate background -- everything but the animated line\n# is drawn and saved in the pixel buffer background\nbackground = canvas.copy_from_bbox(ax.bbox)\n\n\n# just a plain global var to pass data (from main, to plot update thread)\nglobal mypass\n\n# http://docs.python.org/library/multiprocessing.html#pipes-and-queues\nfrom multiprocessing import Pipe\nglobal pipe1main, pipe1upd\npipe1main, pipe1upd = Pipe()\n\n\n# the kind of processing we might want to do in a main() function,\n# will now be done in a \"main thread\" - so it can run in\n# parallel with gobject.idle_add(update_line)\ndef threadMainTest():\n    global mypass\n    global runthread\n    global pipe1main\n\n    print \"tt\"\n\n    interncount = 1\n\n    while runthread: \n        mypass += 1\n        if mypass &gt; 100: # start \"speeding up\" animation, only after 100 counts have passed\n            interncount *= 1.03\n        pipe1main.send(interncount)\n        time.sleep(0.01)\n    return\n\n\n# main plot / GUI update\ndef update_line(*args):\n    global mypass\n    global t0\n    global runthread\n    global pipe1upd\n\n    if not runthread:\n        return False \n\n    if pipe1upd.poll(): # check first if there is anything to receive\n        myinterncount = pipe1upd.recv()\n\n    update_line.cnt = mypass\n\n    # restore the clean slate background\n    canvas.restore_region(background)\n    # update the data\n    line.set_ydata(nx.sin(x+(update_line.cnt+myinterncount)/10.0))\n    # just draw the animated artist\n    ax.draw_artist(line)\n    # just redraw the axes rectangle\n    canvas.blit(ax.bbox)\n\n    if update_line.cnt&gt;=500:\n        # print the timing info and quit\n        print 'FPS:' , update_line.cnt/(time.time()-tstart)\n\n        runthread=0\n        t0.join(1)   \n        print \"exiting\"\n        sys.exit(0)\n\n    return True\n\n\n\nglobal runthread\n\nupdate_line.cnt = 0\nmypass = 0\n\nrunthread=1\n\ngobject.idle_add(update_line)\n\nglobal t0\nt0 = threading.Thread(target=threadMainTest)\nt0.start() \n\n# start the graphics update thread\np.show()\n\nprint \"out\" # will never print - show() blocks indefinitely!\n</code>\n</pre>\n", "senID": 2}, {"text": ["Hope this helps someone,\nCheers!"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}], [{"text": ["On my system show() does not block, although I wanted the script to wait for the user to interact with the graph (and collect data using 'pick_event' callbacks) before continuing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In order to block execution until the plot window is closed, I used the following:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n fig = plt.figure()\nax = fig.add_subplot(1,1,1)\nax.plot(x,y)\n\n# set processing to continue when window closed\ndef onclose(event):\n    fig.canvas.stop_event_loop()\nfig.canvas.mpl_connect('close_event', onclose)\n\nfig.show() # this call does not block on my system\nfig.canvas.start_event_loop_default() # block here until window closed\n\n# continue with further processing, perhaps using result from callbacks\n</code>\n</pre>\n", "senID": 2}, {"text": ["Note, however, that canvas.start_event_loop_default() produced the following warning:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n C:\\Python26\\lib\\site-packages\\matplotlib\\backend_bases.py:2051: DeprecationWarning: Using default event loop until function specific to this GUI is implemented\n  warnings.warn(str,DeprecationWarning)\n</code>\n</pre>\n", "senID": 4}, {"text": ["although the script still ran."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]