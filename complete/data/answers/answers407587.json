[[{"text": ["Python 2.6 or 3.0:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def bitsoncount(x):\n    return bin(x).count('1')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = 123\n&gt;&gt;&gt; bin(x)\n'0b1111011'\n&gt;&gt;&gt; bitsoncount(x) \n6\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Matt Howells's answer in Python:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Matt Howells's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/109023/best-algorithm-to-count-the-number-of-set-bits-in-a-32-bit-integer#109025"}]}, {"code": "<pre>\n<code>\n def bitsoncount(i):\n    assert 0 &lt;= i &lt; 0x100000000\n    i = i - ((i &gt;&gt; 1) &amp; 0x55555555)\n    i = (i &amp; 0x33333333) + ((i &gt;&gt; 2) &amp; 0x33333333)\n    return (((i + (i &gt;&gt; 4) &amp; 0xF0F0F0F) * 0x1010101) &amp; 0xffffffff) &gt;&gt; 24\n</code>\n</pre>\n", "senID": 6}], [{"text": ["The direct translation of your C algorithm is as follows:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def bitsoncount(x):\n    b = 0\n    while x &gt; 0:\n        x &amp;= x - 1\n        b += 1\n    return b\n</code>\n</pre>\n", "senID": 1}], [{"text": ["what you're looking for is called the Hamming Weight."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Hamming Weight", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Hamming_weight"}]}, {"text": ["in python 2.6/3.0 it can be found rather easily with:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n bits = sum( b == '1' for b in bin(x)[2:] )\n</code>\n</pre>\n", "senID": 2}], [{"text": ["What version of Python are you using?", "First off, Python uses white space not semicolon's, so to start it should look something like this..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def bitsoncount(x): \n      b=0\n      while(x &gt; 0):\n          x &amp;= x - 1   \n          b+=1\n      return b\n</code>\n</pre>\n", "senID": 1}, {"text": ["What is the code supposed to do?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Maybe this is what you mean?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def bits_on_count(x):\n    b = 0\n    while x != 0:\n        if x &amp; 1: # Last bit is a 1\n            b += 1\n        x &gt;&gt;= 1 # Shift the bits of x right\n    return b\n</code>\n</pre>\n", "senID": 1}, {"text": ["There's also a way to do it simply in Python 3.0:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def bits_on_count(x):\n  return sum(c=='1' for c in bin(x))\n</code>\n</pre>\n", "senID": 3}, {"text": ["This uses the fact that bin(x) gives a binary representation of x."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Try this module:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\nif sys.maxint &lt; 2**32:\n    msb2= 2**30\nelse:\n    msb2= 2**62\nBITS=[-msb2*2] # not converted into long\nwhile msb2:\n    BITS.append(msb2)\n    msb2 &gt;&gt;= 1\n\ndef bitcount(n):\n    return sum(1 for b in BITS if b&amp;n)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This should work for machine integers (depending on your OS and the Python version).", "It won't work for any long."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "long", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["How do you like this one:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def bitsoncount(x):\n    b   = 0\n    bit = 1\n    while bit &lt;= x:\n        b += int(x &amp; bit &gt; 0)\n        bit = bit &lt;&lt; 1\n\n    return b\n</code>\n</pre>\n", "senID": 1}, {"text": ["Basically, you use a test bit that starts right and gets shifted all the way through up to the bit length of your in parameter.", "For each position the bit &amp; x yields a single bit which is on, or none.", "Check > 0 and turn the resulting True|False into 1|0 with int(), and add this to the accumulator.", "Seems to work nicely for longs :-) ."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]