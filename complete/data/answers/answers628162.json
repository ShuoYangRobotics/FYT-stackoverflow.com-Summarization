[[{"code": "<pre>\n<code>\n def Factorial(arg):\n    try:\n        it = iter(arg)\n    except TypeError:\n        pass\n    else:\n        return [Factorial(x) for x in it]\n    return math.factorial(arg)\n</code>\n</pre>\n", "senID": 0}, {"text": ["If it's iterable, apply recursivly.", "Otherwise, proceed normally."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Alternatively, you could move the last return into the except block."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "return", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "except", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you are sure the body of Factorial will never raise TypeError, it could be simplified to:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Factorial", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "TypeError", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def Factorial(arg):\n    try:\n        return [Factorial(x) for x in arg]\n    except TypeError:\n        return math.factorial(arg)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["List comprehension:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "List comprehension", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions"}]}, {"code": "<pre>\n<code>\n [fac(n) for n in nums]\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Sorry, I misunderstood, you want a method that handles both sequences and single values?", "I can't imagine why you wouldn't do this with two methods."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def factorial(n):\n    # implement factorial here\n    return answer\n\ndef factorial_list(nums):\n    return [factorial(n) for n in nums]\n</code>\n</pre>\n", "senID": 4}, {"text": ["The alternative would be to do some sort of type-checking, which is better avoided unless you have some terribly compelling reason to do so."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["EDIT 2:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "EDIT 2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["MizardX's answer is better, vote for that one.", "Cheers."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["This is done sometimes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def factorial( *args ):\n    def fact( n ):\n        if n == 0: return 1\n        return n*fact(n-1)\n    return [ fact(a) for a in args ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["It gives an almost magical function that works with simple values as well as sequences."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; factorial(5)\n[120]\n&gt;&gt;&gt; factorial( 5, 6, 7 )\n[120, 720, 5040]\n&gt;&gt;&gt; factorial( *[5, 6, 7] )\n[120, 720, 5040]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If you're asking if Python can do method overloading: no.", "Hence, doing multi-methods like that is a rather un-Pythonic way of defining a method.", "Also, naming convention usually upper-cases class names, and lower-cases functions/methods."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want to go ahead anyway, simplest way would be to just make a branch:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def Factorial(arg):\n  if getattr(arg, '__iter__', False): # checks if arg is iterable\n    return [Factorial(x) for x in arg]\n  else:\n    # ...\n</code>\n</pre>\n", "senID": 2}, {"text": ["Or, if you're feeling fancy, you could make a decorator that does this to any function:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def autoMap(f):\n    def mapped(arg):\n        if getattr(arg, '__iter__', False):\n            return [mapped(x) for x in arg]\n        else:\n            return f(arg)\n    return mapped\n\n@autoMap\ndef fact(x):\n    if x == 1 or x == 0:\n        return 1\n    else:\n        return fact(x-1) + fact(x-2)\n\n&gt;&gt;&gt; fact(3)\n3\n&gt;&gt;&gt; fact(4)\n5\n&gt;&gt;&gt; fact(5)\n8\n&gt;&gt;&gt; fact(6)\n13\n&gt;&gt;&gt; fact([3,4,5,6])\n[3, 5, 8, 13]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Although a more Pythonic way is to use variable argument lengths:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def autoMap2(f):\n    def mapped(*arg):\n        if len(arg) != 1:\n            return [f(x) for x in arg]\n        else:\n            return f(arg[0])\n    return mapped\n\n@autoMap2\ndef fact(n):\n# ...\n\n&gt;&gt;&gt; fact(3,4,5,6)\n[3, 5, 8, 13]\n</code>\n</pre>\n", "senID": 6}, {"text": ["Putting the two together into a deep mapping decorator:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def autoDeepMap(f):\n    def mapped(*args):\n        if len(args) != 1:\n            return [mapped(x) for x in args]\n        elif getattr(args[0], '__iter__', False):\n            return [mapped(x) for x in args[0]]\n        else:\n            return f(args[0])\n    return mapped\n\n@autoDeepMap\ndef fact(n):\n# ...\n\n&gt;&gt;&gt; fact(0)\n1\n&gt;&gt;&gt; fact(0,1,2,3,4,5,6)\n[1, 1, 2, 3, 5, 8, 13]\n&gt;&gt;&gt; fact([0,1,2,3,4,5,6])\n[1, 1, 2, 3, 5, 8, 13]\n&gt;&gt;&gt; fact([0,1,2],[3,4,5,6])\n[[1, 1, 2], [3, 5, 8, 13]]\n&gt;&gt;&gt; fact([0,1,2],[3,(4,5),6])\n[[1, 1, 2], [3, [5, 8], 13]]\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Or if you don't like the list comprehension syntax, and wish to skip having a new method:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def factorial(num):\n    if num == 0:\n        return 1\n    elif num &gt; 0:\n        return num * factorial(num - 1)\n    else:\n        raise Exception(\"Negative num has no factorial.\")\n\nnums = [1, 2, 3, 4, 5]\n# [1, 2, 3, 4, 5]\n\nmap(factorial, nums)\n# [1, 2, 6, 24, 120, 720]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You might want to take a look at NumPy/SciPy's vectorize."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "vectorize", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.html"}]}, {"text": ["In the numpy world, given your single-int-arg Factorial function,\nyou'd do things like"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n vFactorial=np.vectorize(Factorial)\n  vFactorial([1,2,3,4,5])\n  vFactorial(6)\n</code>\n</pre>\n", "senID": 2}, {"text": ["although note that the last case returns a single-element numpy array rather than a raw int."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]