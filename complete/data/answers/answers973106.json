[[{"text": ["It's not idiomatic to run Clojure scripts over and over from the command line.", "The REPL is a better command line.", "Clojure being a Lisp, it's common to fire up Clojure and leave the same instance running forever, and interact with it rather than restart it.", "You can change functions in the running instance one at a time, run them and poke them as needed.", "Escaping the tedious and slow traditional edit/compile/debug cycle is a great feature of Lisps.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can easily write functions to do things like run unit tests, and just call those functions from the REPL whenever you want to run them and ignore them otherwise.", "It's common in Clojure to use clojure.contrib.test-is, add your test functions to your namespace, then use clojure.contrib.test-is/run-tests to run them all."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "clojure.contrib.test-is", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "clojure.contrib.test-is/run-tests", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Another good reason not to run Clojure from the commandline is that the startup time of the JVM can be prohibitive."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you really want to run a Clojure script from the command line, there are a bunch of ways you can do it.", "See the Clojure mailing list for some discussion."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "the Clojure mailing list", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://groups.google.com/group/clojure/browse%5Fthread/thread/ca60d98fb4f7e71e/ddc68367d4fa1bc7"}]}, {"text": ["One way is to test for the presence of command line arguments.", "Given this foo.clj in the current directory:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "foo.clj", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n (ns foo)\n\n(defn hello [x] (println \"Hello,\" x))\n\n(if *command-line-args*\n  (hello \"command line\")\n  (hello \"REPL\"))\n</code>\n</pre>\n", "senID": 5}, {"text": ["You'll get different behavior depending how you start Clojure."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n $ java -cp ~/path/to/clojure.jar:. clojure.main foo.clj --\nHello, command line\n$ java -cp ~/path/to/clojure.jar:. clojure.main\nClojure 1.1.0-alpha-SNAPSHOT\nuser=&gt; (use 'foo)\nHello, REPL\nnil\nuser=&gt;\n</code>\n</pre>\n", "senID": 7}, {"text": ["See src/clj/clojure/main.clj in the Clojure source if you want to see how this is working."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "src/clj/clojure/main.clj", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Another way is to compile your code into .class files and invoke them from the Java command line.", "Given a source file foo.clj:"], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": ".class", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo.clj", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n (ns foo\n  (:gen-class))\n\n(defn hello [x] (println \"Hello,\" x))\n\n(defn -main [] (hello \"command line\"))\n</code>\n</pre>\n", "senID": 10}, {"text": ["Make a directory to store the compiled .class files; this defaults to ./classes.", "You must make this folder yourself, Clojure won't create it.", "Also make sure you set $CLASSPATH to include ./classes and the directory with your source code; I'll assume foo.clj is in the current directory.", "So from the command line:"], "childNum": 5, "tag": "p", "senID": 11, "childList": [{"text": ".class", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "./classes", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "$CLASSPATH", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "./classes", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "foo.clj", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n $ mkdir classes\n$ java -cp ~/path/to/clojure.jar:./classes:. clojure.main\nClojure 1.1.0-alpha-SNAPSHOT\nuser=&gt; (compile 'foo)\nfoo\n</code>\n</pre>\n", "senID": 12}, {"text": ["In the classes directory you will now have a bunch of .class files.", "To invoke your code from the command line (running the -main function by default):"], "childNum": 3, "tag": "p", "senID": 13, "childList": [{"text": "classes", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".class", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "-main", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n $ java -cp ~/path/to/clojure.jar:./classes foo\nHello, command line.\n</code>\n</pre>\n", "senID": 14}, {"text": ["There's a lot of information about compiling Clojure code on clojure.org."], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "clojure.org", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://clojure.org/compilation"}]}], [{"text": ["I'm very new to Clojure but I think this discussion on the Clojure groups may be a solution and/or workaround, specifically the post by Stuart Sierra on April 17th at 10:40 PM. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this discussion", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://groups.google.com/group/clojure/browse_thread/thread/d3c2c328787c328f/8c8c526fee2d6deb?lnk=gst&q=clojure+python+__name__#8c8c526fee2d6deb"}]}], [{"text": ["In Common Lisp you can use conditional reading with features."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "features", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.lispworks.com/documentation/HyperSpec/Body/24%5Fab.htm"}]}, {"code": "<pre>\n<code>\n #+testing (run-test 'is-answer-equal-42)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Above will only be read and thus execute during load if the list of features bound to cl:*features* will contain the symbol :testing ."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "cl:*features*", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.lispworks.com/documentation/HyperSpec/Body/v%5Ffeatur.htm#STfeaturesST"}]}, {"text": ["For example"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n (let ((*features* (cons :testing *features*)))\n   (load \"/foo/bar/my-answerlib.lisp\"))\n</code>\n</pre>\n", "senID": 4}, {"text": ["will temporarily add :testing to the list of features."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["You can define your own features and control which expressions the Common Lisp system reads and which it skips."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Additionally you can also do:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n #-testing (print '|we are in production mode|)\n</code>\n</pre>\n", "senID": 8}], [{"text": ["There's also a list of different possibilities at http://rosettacode.org/wiki/Scripted_Main#Clojure.", "(If you find a new one - please add it.", ";-))"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://rosettacode.org/wiki/Scripted_Main#Clojure", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://rosettacode.org/wiki/Scripted_Main#Clojure"}]}], [{"text": ["You might want to have a look at the test-is library from clojure-contrib.", "It's not the same idiom, but it should support a pretty similar workflow."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "test-is", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/clojure-contrib/source/browse/trunk/src/clojure/contrib/test%5Fis.clj"}]}], [{"text": ["Common Lisp and Clojure (as well as other lisps) provide interactive environment with REPL, and you do not need tricks like \u00abif __name__ == '__main__'\u00bb.", "There are REPL-like environments for python: the python from command-line, ipython, python mode for Emacs, etc."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "if __name__ == '__main__'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You should just create the library, add a testsuite to it (there are many testing frameworks for Common Lisp; I prefer the 5am framework, there is a survey of frameworks available here).", "And then you load the library, and in the REPL you can do anything with the library: run tests, call functions, experiment, etc."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "5am", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://common-lisp.net/project/bese/FiveAM.html"}, {"text": "here", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://aperiodic.net/phil/archives/Geekery/notes-on-lisp-testing-frameworks.html"}]}, {"text": ["When you find a failing test, you make a fix to it, recompile the changed code, and continue experimenting, running tests without restarting the whole application.", "This saves a lot of time, because the running application might have accumulated a lot of state (it might have created gui windows, connected to databases, reached some critical moment that is not easily reproduceable), and you don't have to restart it after every change."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here's an example for Common Lisp (from my cl-sqlite library):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The code:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n (def-suite sqlite-suite)\n\n(defun run-all-tests ()\n  (run! 'sqlite-suite));'\n\n(in-suite sqlite-suite)\n\n(test test-connect\n  (with-open-database (db \":memory:\")))\n\n(test test-disconnect-with-statements\n  (finishes\n    (with-open-database (db \":memory:\")\n      (prepare-statement db \"create table users (id integer primary key, user_name text not null, age integer null)\"))))\n...\n</code>\n</pre>\n", "senID": 5}, {"text": ["and the interactive session:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n CL-USER&gt; (sqlite-tests:run-all-tests)\n.......\n Did 7 checks.\n    Pass: 7 (100%)\n    Skip: 0 ( 0%)\n    Fail: 0 ( 0%)\n\nNIL\nCL-USER&gt; (defvar *db* (sqlite:connect \":memory:\"))\n*DB*\nCL-USER&gt; (sqlite:execute-non-query *db* \"create table t1 (field text not null)\")\n; No value\nCL-USER&gt; (sqlite:execute-non-query *db* \"insert into t1 (field) values (?)\" \"hello\")\n; No value\nCL-USER&gt; (sqlite:execute-to-list *db* \"select * from t1\")\n((\"hello\"))\nCL-USER&gt;\n</code>\n</pre>\n", "senID": 7}, {"text": ["Now suppose that I found bug in sqlite:execute-to-list.", "I go to the code of this function, fix the bug and recompile this function.", "Then I call the fixed function and ensure that it works.", "The in-memory database is not gone, it has the same state as it had before recompile."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["If you are talking about having an \"entry point\" you can certainly do that:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (ns foo)\n\n(defn foo [n]\n  (inc n))\n\n(defn main []\n  (println \"working\")\n  (println \"Foo has ran:\" (foo 1)))\n\n(main)\n</code>\n</pre>\n", "senID": 1}, {"text": ["what will happen now is that any time this code is (load-file \"foo.clj\")'d or (use 'foo) or (require 'foo), then (main) will be called, that's usually not done."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Much more common is that a file of code can be loaded at the REPL and then the main function would be called by the user."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]