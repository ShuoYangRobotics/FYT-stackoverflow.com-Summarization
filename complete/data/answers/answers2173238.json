[[{"text": ["I suggest a much simpler approach:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def removecommon(name1, name2):\n  common = set(name1).intersection(name2)\n  res1 = ''.join(n for n in name1 if n not in common)\n  res2 = ''.join(n for n in name2 if n not in common)\n  return res1, res2\n\nn1, n2 = removecommon('naveen', 'darshana')\nprint n1, n2\n</code>\n</pre>\n", "senID": 1}, {"text": ["emits vee drsh as desired."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "vee drsh", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit: as the OP now specified (in a comment -- pls remember to edit your question too, oh OP!", ") that he actually wants to remove only the first occurrence in each word of each common letter, the needed algorithm is of course completely different.", "A simple approach (feasible if the length of the words is not too high):"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "question", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "first", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def removefirstcommon(name1, name2):\n  common = set(name1).intersection(name2)\n  n1 = list(name1)\n  for c in common: n1.remove(c)\n  n2 = list(name2)\n  for c in common: n2.remove(c)\n  return ''.join(n1), ''.join(n2)\n</code>\n</pre>\n", "senID": 4}, {"text": ["A more elaborate approach (while slower for normal-length words) would be faster for extremely long words (since the following is O(N) while the former's O(N squared)):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def removefirstcommonlongwords(name1, name2):\n  common = set(name1).intersection(name2)\n  def mustrem(c, copycom):\n    res = c not in copycom\n    copycom.discard(c)\n    return res\n  cop = set(common)\n  n1 = [c for c in name1 if mustrem(c, cop)]\n  n2 = [c for c in name2 if mustrem(c, common)]\n  return ''.join(n1), ''.join(n2)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["A more pythonic approach would be to use sets and list comprehensions."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "pythonic", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n name1 = \"naveen\"; name2 = \"darshana\"\n\nname1_set=set(name1)\nname2_set=set(name2)\n\nclean1=[x for x in  name1 if x not in name2_set]\nclean2=[x for x in name2 if x not in name1_set]\n\nclean1.extend(['0']*(len(name1)-len(clean1)))\nclean2.extend(['1']*(len(name2)-len(clean2)))\n\nprint clean1,clean2\n</code>\n</pre>\n", "senID": 1}, {"text": ["set gives us O(1) lookups, thus making the whole process faster by making it O(N) instead of O(N^2)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["EDIT: In light of your later comment that the number of occurrences matter, this is the updated version that takes that into account."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n name1 = \"naveen\"; name2 = \"darshana\"\n\ncount1={}\ncount2={}\n\n\nfor x in name1:\n    count1[x]=count1.get(x,0)+1\n\nfor x in name2:\n    count2[x]=count2.get(x,0)+1\n\ndef remove_dups(name,count,null):\n    clean=[]\n    for x in name:\n        if count.get(x,0):\n            count[x]-=1\n        else:\n            clean.append(x)\n    clean.extend([null]*(len(name)-len(clean)))\n    return clean\n\nclean1=remove_dups(name1,count2,'0')\nclean2=remove_dups(name2,count1,'1')\n\nprint clean1,clean2\n</code>\n</pre>\n", "senID": 4}, {"text": ["It uses dicts to keep counts of occurrences.", "Whenever a character is removed, the corresponding count for the other name is decremented.", "Complexity is still O(N)."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["It prints ['v', 'e', 'e', 'n', '0', '0']  and ['d', 'r', 's', 'h', 'a', 'a', '1', '1'].", "Is that what you wanted?"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "['v', 'e', 'e', 'n', '0', '0']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "['d', 'r', 's', 'h', 'a', 'a', '1', '1']", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["It's working here for me.", "That is, if I add print statements thus:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n name1 = \"abdjek\"\nname2 = \"doarhsnk\"\n\nn1l = list(name1)\nn2l = list(name2)\n\nprint \"Lists before loop:\"\nprint n1l\nprint n2l\n\nfor i in range(len(n1l)):\n    for j in range(len(n2l)):\n        if n1l[i] == n2l[j]:\n           n1l.pop(i)\n           n2l.pop(j)\n           n1l.append('0')\n           n2l.append('1')\n\nprint \"Lists after loop:\"\nprint n1l\nprint n2l\n</code>\n</pre>\n", "senID": 1}, {"text": ["the characters 'a', 'd', and 'k' are all removed:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt; python test.py \nLists before loop:\n['a', 'b', 'd', 'j', 'e', 'k']\n['d', 'o', 'a', 'r', 'h', 's', 'n', 'k']\nLists after loop:\n['b', 'j', 'e', '0', '0', '0']\n['o', 'r', 'h', 's', 'n', '1', '1', '1']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Your code might not be working as you expect it to, as it is removing paired letters.", "For instance, you see an a, you then remove both a's from your words... "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Your code most probably fails because you pop common letters from anywhere in the list, but append the replacements (\"0\" and \"1\") to the end of the list.", "They should be at position i and j, respectively."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "end", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "i", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "j", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["So the loop should probably look like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for i in range(len(n1l)):\n   for j in range(len(n2l)):\n         if n1l[i] == n2l[j] and n1l[i] not in (\"0\", \"1\"):\n               print \"common letter \", n1l[i]\n               # Replace i-th and j-th element\n               n1l[i] = \"0\"\n               n2l[j] = \"1\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["Anyway, there more \"pythonic\" ways, which are already shown in the other answers."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT: Tested and working also with name1 = \"naveen\" / name2 = \"darshana\"."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "name1 = \"naveen\"", "childNum": 0, "tag": "code", "childList": []}, {"text": "name2 = \"darshana\"", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Here's some quite (IMHO quite elegant) code that runs in O(n).", "If word 1 has N occurrences of the letter x, it removes the first N x's from word 2 (and vice versa) -- I think this is what you want, but I could be wrong."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\ndef build(s, chars_s, chars_t):\n    \"\"\"Return characters of s, with duplicate characters from t removed.\"\"\"\n    for i, char in enumerate(s):\n        indexes_s, indexes_t = chars_s[char], chars_t[char]\n        if len(indexes_s) &gt; len(indexes_t) and i &gt;= indexes_s[len(indexes_t)]:\n            yield char\n\ndef rm_dup(a, b):\n    \"\"\"Pairwise remove duplicate letters in a and b.\"\"\"\n    chars_a, chars_b = defaultdict(list), defaultdict(list)\n    for i, char in enumerate(a): chars_a[char].append(i)\n    for i, char in enumerate(b): chars_b[char].append(i)\n    return (''.join(build(a, chars_a, chars_b)),\n            ''.join(build(b, chars_b, chars_a)))\n\nprint rm_dup('naveen', 'darshana')\n</code>\n</pre>\n", "senID": 1}]]