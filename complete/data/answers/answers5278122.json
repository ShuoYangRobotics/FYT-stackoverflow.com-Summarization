[[{"text": ["Not the most efficient, but straight forward and concise:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if len(x) &gt; len(set(x)):\n   pass # do something\n</code>\n</pre>\n", "senID": 1}, {"text": ["Probably won't make much of a difference for short lists. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["An early-exit solution could be"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def unique_values(g):\n    s = set()\n    for x in g:\n        if x in s: return False\n        s.add(x)\n    return True\n</code>\n</pre>\n", "senID": 1}, {"text": ["however for small cases or if early-exiting is not the common case then I would expect len(x) != len(set(x)) being the fastest method."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "len(x) != len(set(x))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["How about adding all the entries to a set and checking its length?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n len(set(x)) == len(x)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Alternative to a set, you can use a dict."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n len({}.fromkeys(x)) == len(x)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is a two-liner that will also do early exit:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def allUnique(x):\n...     seen = set()\n...     return not any(i in seen or seen.add(i) for i in x)\n...\n&gt;&gt;&gt; allUnique(\"ABCDEF\")\nTrue\n&gt;&gt;&gt; allUnique(\"ABACDEF\")\nFalse\n</code>\n</pre>\n", "senID": 1}, {"text": ["If the elements of x aren't hashable, then you'll have to resort to using a list for seen:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "seen", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def allUnique(x):\n...     seen = list()\n...     print not any(i in seen or seen.append(i) for i in x)\n...\n&gt;&gt;&gt; allUnique([list(\"ABC\"), list(\"DEF\")])\nTrue\n&gt;&gt;&gt; allUnique([list(\"ABC\"), list(\"DEF\"), list(\"ABC\")])\nFalse\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You can use Yan's syntax (len(x) > len(set(x))), but instead of set(x), define a function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f5(seq, idfun=None): \n    # order preserving\n    if idfun is None:\n        def idfun(x): return x\n    seen = {}\n    result = []\n    for item in seq:\n        marker = idfun(item)\n        # in old Python versions:\n        # if seen.has_key(marker)\n        # but in new ones:\n        if marker in seen: continue\n        seen[marker] = 1\n        result.append(item)\n    return result\n</code>\n</pre>\n", "senID": 1}, {"text": ["and do len(x) > len(f5(x)).", "This will be fast and is also order preserving."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Code there is taken from: http://www.peterbe.com/plog/uniqifiers-benchmark"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://www.peterbe.com/plog/uniqifiers-benchmark", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.peterbe.com/plog/uniqifiers-benchmark"}]}]]