[[{"text": ["at the very least use a list comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [x for x in a + b if (a + b).count(x) == 1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["otherwise use the set class:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "set", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#set-types-set-frozenset"}]}, {"code": "<pre>\n<code>\n list(set(a).symmetric_difference(set(b)))\n</code>\n</pre>\n", "senID": 3}, {"text": ["there is also a more compact form:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n list(set(a) ^ set(b))\n</code>\n</pre>\n", "senID": 5}], [{"text": ["If the order is not important and you can ignore repetitions within a and b, I would simply use sets:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; set(b) - set(a)\nset([4, 5])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Sets are iterable, so most of the times you do not need to explicitly convert them back to list.", "If you have to, this does it:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(set(b) - set(a))\n[4, 5]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Items in b that aren't in a, if you need to preserve order or duplicates in b:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [1, 2, 3]\n&gt;&gt;&gt; b = [1, 2, 3, 4, 4, 5]\n&gt;&gt;&gt; a_set = set(a)\n&gt;&gt;&gt; [x for x in b if x not in a_set]\n[4, 4, 5]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Items in b that aren't in a, not preserving order, and not preserving duplicates in b:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(set(b) - set(a))\n[4, 5]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I'd say go for the set variant, where"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n set(b) ^ set(a)   (set.symmetric_difference())\n</code>\n</pre>\n", "senID": 1}, {"text": ["only applies if you can be certain that a is always a subset of b, but in that case has the advantage of being commutative, ie.", "you don't have to worry about calculating set(b) ^ set(a) or set(a) ^ set(b); or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n set(b) - set(a)    (set.difference())\n</code>\n</pre>\n", "senID": 3}, {"text": ["which matches your description more closely, allows a to have extra elements not in b which will not be in the result set, but you have to mind the order (set(a) - set(b) will give you a different result)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Here are some different possibilities with the sets"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n>>> a = [1, 2, 3, 4, 5, 1, 2]\n>>> b = [1, 2, 5, 6]\n>>> print list(set(a)^set(b))\n[3, 4, 6]\n>>> print list(set(a)-set(b))\n[3, 4]\n>>> print list(set(b)-set(a))\n[6]\n>>> print list(set(a)-set(b))+list(set(b)-set(a))\n[3, 4, 6]\n>>>\n</pre>\n", "senID": 1}], [{"text": ["Another solution using only lists:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = [1, 2, 3]\nb = [1, 2, 3, 4, 5]\nc = [n for n in a + b if n not in a or n not in b]\n</code>\n</pre>\n", "senID": 1}]]