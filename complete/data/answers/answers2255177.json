[[{"text": ["\"language agnostic\" and worrying about performance are pretty much incompatible concepts. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Most modern processors have a CLZ instruction, \"count leading zeros\".", "In GCC you can get to it with __builtin_clz(x) (which also produces reasonable, if not the fastest, code for targets that lack clz).", "Note that this CLZ is undefined for zero, so you'll need an extra branch to catch that case if it matters in your application."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In CELT ( http://celt-codec.org ) the branchless CLZ we use for compliers lacking a CLZ was written by Timothy B. Terriberry:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://celt-codec.org", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://celt-codec.org"}]}, {"code": "<pre>\n<code>\n int ilog(uint32 _v){\n  int ret;\n  int m;\n  ret=!!_v;\n  m=!!(_v&0xFFFF0000)&lt;&lt;4;\n  _v&gt;&gt;=m;\n  ret|=m;\n  m=!!(_v&0xFF00)&lt;&lt;3;\n  _v&gt;&gt;=m;\n  ret|=m;\n  m=!!(_v&0xF0)&lt;&lt;2;\n  _v&gt;&gt;=m;\n  ret|=m;\n  m=!!(_v&0xC)&lt;&lt;1;\n  _v&gt;&gt;=m;\n  ret|=m;\n  ret+=!!(_v&0x2);\n  return ret;\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["(The comments indicate that this was found to be faster than a branching version and a lookup table based version)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["But if performance is that critical you probably shouldn't be implementing this part of your code in python."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["There is a page with a lot of these types of tricks and hacks.", "It's written for C, but many of them should work in Python too (though the performance will obviously be different).", "The bit you want is here and onwards."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://graphics.stanford.edu/~seander/bithacks.html#IntegerLogObvious"}]}, {"text": ["You could try this for example:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog"}]}, {"code": "<pre>\n<code>\n register unsigned int r = 0; // result of log2(v) will go here\nfor (i = 4; i &gt;= 0; i--) // unroll for speed...\n{\n  if (v &amp; b[i])\n  {\n    v &gt;&gt;= S[i];\n    r |= S[i];\n  } \n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["That looks like it could be converted to Python quite easily."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You can do it in O(lg s) time for arbitrary length integers using a binsearch. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\ndef floorlg(n):\n    if n &lt; 1:\n        return -1\n    low=0\n    high=sys.getsizeof(n)*8 # not the best upper-bound guesstimate, but...\n    while True:\n        mid = (low+high)//2\n        i = n &gt;&gt; mid\n        if i == 1:\n            return mid\n        if i == 0:\n            high = mid-1\n        else:\n            low = mid+1\n</code>\n</pre>\n", "senID": 1}, {"text": ["For fixed size integers, a lookup table should be the fastest solution, and probably best overall."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As far as python is concerned:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "The ", "tag": "none", "senID": 1}, {"text": "The ", "tag": "none", "senID": 2}, {"text": "Both previous methods have well-defined (but extensible) upper limits. The ", "tag": "none", "senID": 3}]}, {"text": ["func(2**5)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "func(2**5)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n hashlookup:          0.13s     100%\nlookup:              0.15s     109%\nstringcount:         0.29s     220%\nunrolled_bitwise:    0.36s     272%\nlog_e:               0.60s     450%\nbitcounter:          0.64s     479%\nlog_2:               0.69s     515%\nilog:                0.81s     609%\nbitwise:             1.10s     821%\nolgn:                1.42s    1065%\n</code>\n</pre>\n", "senID": 5}, {"text": ["func(2**31)"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "func(2**31)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n hashlookup:          0.11s     100%\nunrolled_bitwise:    0.26s     229%\nlog_e:               0.30s     268%\nstringcount:         0.30s     270%\nlog_2:               0.34s     301%\nilog:                0.41s     363%\nbitwise:             0.87s     778%\nolgn:                1.02s     912%\nbitcounter:          1.42s    1264%\n</code>\n</pre>\n", "senID": 7}, {"text": ["func(2**128)"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "func(2**128)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n hashlookup:     0.01s     100%\nstringcount:    0.03s     264%\nlog_e:          0.04s     315%\nlog_2:          0.04s     383%\nolgn:           0.18s    1585%\nbitcounter:     1.41s   12393%\n</code>\n</pre>\n", "senID": 9}, {"text": ["func(2**1024)"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "func(2**1024)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n log_e:          0.00s     100%\nlog_2:          0.01s     118%\nstringcount:    0.02s     354%\nolgn:           0.03s     707%\nbitcounter:     1.73s   37695%\n</code>\n</pre>\n", "senID": 11}, {"code": "<pre>\n<code>\n import math, sys\n\ndef stringcount(v):\n    \"\"\"mac\"\"\"    \n    return len(bin(v)) - 3\n\ndef log_2(v):\n    \"\"\"mac\"\"\"    \n    return int(round(math.log(v, 2), 0)) # 2**101 generates 100.999999999\n\ndef log_e(v):\n    \"\"\"bp on mac\"\"\"    \n    return int(round(math.log(v)/0.69314718055994529, 0))  # 0.69 == log(2)\n\ndef bitcounter(v):\n    \"\"\"John Y on mac\"\"\"\n    r = 0\n    while v &gt; 1 :\n        v &gt;&gt;= 1\n        r += 1\n    return r\n\ndef olgn(n) :\n    \"\"\"outis\"\"\"\n    if n &lt; 1:\n        return -1\n    low = 0\n    high = sys.getsizeof(n)*8 # not the best upper-bound guesstimate, but...\n    while True:\n        mid = (low+high)//2\n        i = n &gt;&gt; mid\n        if i == 1:\n            return mid\n        if i == 0:\n            high = mid-1\n        else:\n            low = mid+1\n\ndef hashlookup(v):\n    \"\"\"mac on brone -- limit: v &lt; 2**131\"\"\"\n#    def prepareTable(max_log2=130) :\n#        hash_table = {}\n#        for p in range(1, max_log2) :\n#            hash_table[2**p] = p\n#        return hash_table\n\n    global hash_table\n    return hash_table[v] \n\ndef lookup(v):\n    \"\"\"brone -- limit: v &lt; 2**11\"\"\"\n#    def prepareTable(max_log2=10) :\n#        log2s_table=[0]*((1&lt;&lt;max_log2)+1)\n#        for i in range(max_log2+1):\n#            log2s_table[1&lt;&lt;i]=i\n#        return tuple(log2s_table)\n\n    global log2s_table\n    return log2s_table[v]\n\ndef bitwise(v):\n    \"\"\"Mark Byers -- limit: v &lt; 2**32\"\"\"\n    b = (0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000)\n    S = (1, 2, 4, 8, 16)\n    r = 0\n    for i in range(4, -1, -1) :\n        if (v &amp; b[i]) :\n            v &gt;&gt;= S[i];\n            r |= S[i];\n    return r\n\ndef unrolled_bitwise(v):\n    \"\"\"x4u on Mark Byers -- limit:   v &lt; 2**33\"\"\"\n    r = 0;\n    if v &gt; 0xffff : \n        v &gt;&gt;= 16\n        r = 16;\n    if v &gt; 0x00ff :\n        v &gt;&gt;=  8\n        r += 8;\n    if v &gt; 0x000f :\n        v &gt;&gt;=  4\n        r += 4;\n    if v &gt; 0x0003 : \n        v &gt;&gt;=  2\n        r += 2;\n    return r + (v &gt;&gt; 1)\n\ndef ilog(v):\n    \"\"\"Gregory Maxwell - (Original code: B. Terriberry) -- limit: v &lt; 2**32\"\"\"\n    ret = 1\n    m = (not not v &amp; 0xFFFF0000) &lt;&lt; 4;\n    v &gt;&gt;= m;\n    ret |= m;\n    m = (not not v &amp; 0xFF00) &lt;&lt; 3;\n    v &gt;&gt;= m;\n    ret |= m;\n    m = (not not v &amp; 0xF0) &lt;&lt; 2;\n    v &gt;&gt;= m;\n    ret |= m;\n    m = (not not v &amp; 0xC) &lt;&lt; 1;\n    v &gt;&gt;= m;\n    ret |= m;\n    ret += (not not v &amp; 0x2);\n    return ret - 1;\n\n\n# following table is equal to \"return hashlookup.prepareTable()\" \nhash_table = {...} # numbers have been cut out to avoid cluttering the post\n\n# following table is equal to \"return lookup.prepareTable()\" - cached for speed\nlog2s_table = (...) # numbers have been cut out to avoid cluttering the post\n</code>\n</pre>\n", "senID": 12}], [{"text": ["Convert your power of 2 to hexadecimal (e.g., using '%x' formatting) and count the number of digits, then adjust for the first digit."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's a function that computes the bitlength of a Python integer;  it'll return one more than the number you actually want (e.g., 2**100 has a bitlength of 101)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def nbits(n, correction = {\n        '0': 4, '1': 3, '2': 2, '3': 2,\n        '4': 1, '5': 1, '6': 1, '7': 1,\n        '8': 0, '9': 0, 'a': 0, 'b': 0,\n        'c': 0, 'd': 0, 'e': 0, 'f': 0}):\n    \"\"\"Number of bits in binary representation of the positive integer n,\n    or 0 if n == 0.\n    \"\"\"\n    if n &lt; 0:\n        raise ValueError(\"The argument to nbits should be nonnegative.\")\n    hex_n = \"%x\" % n\n    return 4*len(hex_n) - correction[hex_n[0]]\n</code>\n</pre>\n", "senID": 2}, {"text": ["In Python 3.1 (and 2.7, when it appears), there's a bit_length method on integers that does the same thing."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["It seems like the range is known.", "Let's assume it goes up to 1&lt;&lt;20, just to make it more interesting:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n max_log2=20\n</code>\n</pre>\n", "senID": 1}, {"text": ["So make a list that (in effect) maps an integer to its base 2 logarithm.", "The following will do the trick:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n log2s_table=[0]*((1&lt;&lt;max_log2)+1)\nfor i in range(max_log2+1):\n    log2s_table[1&lt;&lt;i]=i\n</code>\n</pre>\n", "senID": 3}, {"text": ["(This doesn't do anything useful for numbers that aren't powers of two; the problem statement suggests they don't need to be handled.", "Would be easy enough to fix that though."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The function to get the logarithm is very simple, and could easily be inlined:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def table(v):\n    return log2s_table[v]\n</code>\n</pre>\n", "senID": 6}, {"text": ["I can't guarantee that the test code I wrote is exactly the same as the one being used to get the example timings, but this is rather quicker than the stringcount code:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "stringcount", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n stringcount: 0.43 s.\ntable: 0.16 s.\n</code>\n</pre>\n", "senID": 8}, {"text": ["Since all the values in the table are less than 256, I wondered whether using a string instead of a list would be quicker, or maybe an array.array of bytes, but no dice:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "array.array", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n string: 0.25 s.\narr: 0.21 s.\n</code>\n</pre>\n", "senID": 10}, {"text": ["Using a dict to do the lookup is another possibility, taking advantage of the way only powers of two are being checked:"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n log2s_map=dict([(1&lt;&lt;x,x) for x in range(max_log2+1)])\n\ndef map(v):\n    return log2s_map[v]\n</code>\n</pre>\n", "senID": 12}, {"text": ["The results for this weren't as good, though:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n map: 0.20 s.\n</code>\n</pre>\n", "senID": 14}, {"text": ["And just for fun one could also use the hex method on float objects to get a string that includes (as its last part) the base 2 exponent of the number.", "This is a bit slow to extract in general, but if the exponent is only ever going to be one digit it could be done straightforwardly enough:"], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "hex", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def floathex(v):\n    return ord(float(v).hex()[-1])-48\n</code>\n</pre>\n", "senID": 16}, {"text": ["This is purely for entertainment value though as it was uncompetetive -- though, amazingly, still quicker than the bitwise approach."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["So it looks like using a list is the way to go."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["(This approach won't scale indefinitely, due to limited memory, but to make up for that the execution speed won't depend on max_log2, or the input values, in any way that you'll notice when running python code.", "Regarding the memory consumption, if I remember my python internals correctly, the table will take up about (1&lt;&lt;max_log2)*4 bytes, because the contents are all small integers that the interpreter will intern automatically.", "SO, when max_log2 is 20, that's about 4MB."], "childNum": 3, "tag": "p", "senID": 19, "childList": [{"text": "max_log2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(1&lt;&lt;max_log2)*4", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "max_log2", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["This is actually a comment to the performance test posted by mac.", "I post this as an answer to have proper code formatting and indenting"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "This is actually a comment to the performance test posted by mac. I post this as an answer to have proper code formatting and indenting", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["mac, could you try a unrolled implementation of the bitseach suggested by Mark Byers?", "Maybe it's just the array access that slows it down.", "In theory this approach should be faster than the others."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It would look something like this, although I'm not sure whether the formatting is right for python but I guess you can see what it is supposed to do."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def bitwise(v):\n    r = 0;\n    if( v &gt; 0xffff ) : v &gt;&gt;= 16; r = 16;\n    if( v &gt; 0x00ff ) : v &gt;&gt;=  8; r += 8;\n    if( v &gt; 0x000f ) : v &gt;&gt;=  4; r += 4;\n    if( v &gt; 0x0003 ) : v &gt;&gt;=  2; r += 2;\n    return r + ( v &gt;&gt; 1 );\n</code>\n</pre>\n", "senID": 3}, {"text": ["If python shares java's lack of unsingned integers it would need to be something like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def bitwise(v):\n    r = 0;\n    if( v &amp; 0xffff0000 ) : v &gt;&gt;&gt;= 16; r = 16;\n    if( v &gt; 0x00ff ) : v &gt;&gt;=  8; r += 8;\n    if( v &gt; 0x000f ) : v &gt;&gt;=  4; r += 4;\n    if( v &gt; 0x0003 ) : v &gt;&gt;=  2; r += 2;\n    return r + ( v &gt;&gt; 1 );\n</code>\n</pre>\n", "senID": 5}]]