[[{"text": ["You could create two range objects and zip them:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n r = xrange(2000, 2005)\nh = zip(xrange(1, len(r) + 1), r)\nprint h\n</code>\n</pre>\n", "senID": 1}, {"text": ["Result:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n[(1, 2000), (2, 2001), (3, 2002), (4, 2003), (5, 2004)]\n</pre>\n", "senID": 3}, {"text": ["If you want to create a generator instead of a list then you can use izip instead."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "izip", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.izip"}]}], [{"text": ["Easy, just define your own function that does what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def enum(seq, start=0):\n    for i, x in enumerate(seq):\n        yield i+start, x\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Simplest way to do in Python 2.5 exactly what you ask about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools as it\n\n... it.izip(it.count(1), xrange(2000, 2005)) ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want a list, as you appear to, use zip in lieu of it.izip."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "it.izip", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["(BTW, as a general rule, the best way to make a list out of a generator or any other iterable X is not [x for x in X], but rather list(X))."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "[x for x in X]", "childNum": 0, "tag": "code", "childList": []}, {"text": "list(X)", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n from itertools import count, izip\n\ndef enumerate(L, n=0):\n    return izip( count(n), L)\n\n# if 2.5 has no count\ndef count(n=0):\n    while True:\n        yield n\n        n+=1\n</code>\n</pre>\n", "senID": 0}, {"text": ["Now h = list(enumerate(xrange(2000, 2005), 1)) works."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "h = list(enumerate(xrange(2000, 2005), 1))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["enumerate is trivial, and so is re-implementing it to accept a start:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def enumerate(iterable, start = 0):\n    n = start\n    for i in iterable:\n        yield n, i\n        n += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that this doesn't break code using enumerate without start argument.", "Alternatively, this oneliner may be more elegant and possibly faster, but breaks other uses of enumerate:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Alternatively, this oneliner may be more elegant and possibly faster, but breaks other uses of enumerate:", "childNum": 0, "tag": "s", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n enumerate = ((index+1, item) for index, item)\n</code>\n</pre>\n", "senID": 3}, {"senID": 4}, {"text": ["The latter was pure nonsense.", "@Duncan got the wrapper right."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; list(enumerate(range(1999, 2005)))[1:]\n[(1, 2000), (2, 2001), (3, 2002), (4, 2003), (5, 2004)]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["h = [(i + 1, x) for i, x in enumerate(xrange(2000, 2005))]"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "h = [(i + 1, x) for i, x in enumerate(xrange(2000, 2005))]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; h = enumerate(range(2000, 2005))\n&gt;&gt;&gt; [(tup[0]+1, tup[1]) for tup in h]\n[(1, 2000), (2, 2001), (3, 2002), (4, 2003), (5, 2004)]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Since this is somewhat verbose, I'd recommend writing your own function to generalize it:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def enumerate_at(xs, start):\n    return ((tup[0]+start, tup[1]) for tup in enumerate(xs))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Ok, I feel a bit stupid here... what's the reason not to just do it with something like \n[(a+1,b) for (a,b) in enumerate(r)] ?", "If you won't function, no problem either:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "[(a+1,b) for (a,b) in enumerate(r)]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; r = range(2000, 2005)\n&gt;&gt;&gt; [(a+1,b) for (a,b) in enumerate(r)]\n[(1, 2000), (2, 2001), (3, 2002), (4, 2003), (5, 2004)]\n\n&gt;&gt;&gt; enumerate1 = lambda r:((a+1,b) for (a,b) in enumerate(r)) \n\n&gt;&gt;&gt; list(enumerate1(range(2000,2005)))   # note - generator just like original enumerate()\n[(1, 2000), (2, 2001), (3, 2002), (4, 2003), (5, 2004)]\n</code>\n</pre>\n", "senID": 1}]]