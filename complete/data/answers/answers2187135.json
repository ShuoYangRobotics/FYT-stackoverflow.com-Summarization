[[{"text": ["No problems with creating the range, as long as you don't want 10**13 elements, e.g. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n range(10**14,10**15,10**14)\n</code>\n</pre>\n", "senID": 1}, {"text": ["gives"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [100000000000000, 200000000000000, 300000000000000, 400000000000000, 500000000000000, 600000000000000, 700000000000000, 800000000000000, 900000000000000]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You could try this.", "Same semantics as range:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\ndef lrange(num1, num2 = None, step = 1):\n    op = operator.__lt__\n\n    if num2 is None:\n        num1, num2 = 0, num1\n    if num2 &lt; num1:\n        if step &gt; 0:\n            num1 = num2\n        op = operator.__gt__\n    elif step &lt; 0:\n        num1 = num2\n\n    while op(num1, num2):\n        yield num1\n        num1 += step\n\n&gt;&gt;&gt; list(lrange(138264128374162347812634134, 138264128374162347812634140))\n[138264128374162347812634134L, 138264128374162347812634135L, 138264128374162347812634136L, 138264128374162347812634137L, 138264128374162347812634138L, 138264128374162347812634139L]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Another solution would be using itertools.islice, as suggested inxrange's documentation"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "itertools.islice", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "xrange", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/functions.html#xrange", "text": "documentation", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["On 64-bit Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; xrange(9999999999999)\nxrange(9999999999999)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I would not use range() for a 13-digit number.", "My poor machine would not be able to hold the resultant list."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "range()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I don't think it will work.", "Functions like len expect the result to fit into a 4 byte integer, due to restrictions in the cPython implementation."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "len", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In Python 3.0:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; range(9999999999999)\nrange(0, 9999999999999)\n</code>\n</pre>\n", "senID": 2}, {"text": ["It looks like it works, but..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; len(range(9999999999999))\nTraceback (most recent call last):\n  File \"&lt;pyshell#2&gt;\", line 1, in &lt;module&gt;\n    len(range(9999999999999))\nOverflowError: Python int too large to convert to C ssize_t\n</code>\n</pre>\n", "senID": 4}, {"text": ["See here for a related question."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2128989/python-len-and-size-of-ints"}]}], [{"text": ["if you need enumerating integer try using itertools:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html"}]}, {"code": "<pre>\n<code>\n itertools.count(1000000000000)\n</code>\n</pre>\n", "senID": 1}, {"text": ["it should not allocate memory for a list of 1000000000000 elements"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "1000000000000", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["range(x) returns a list.Python lists cant contain that many elements.", "You should use xrange() to iterate through those digits if you need to do trillions of cycles."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["range() and xrange() work in recent enough versions of Python; however, in 2.5 or less you'll need to work around the int to long conversion."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def irange(start, stop=None, step=1):\n    if stop is None:\n        stop = long(start)\n        num = 1L\n    else:\n        stop = long(stop)\n        num = long(start)\n    step = long(step)\n    while num &lt; stop:\n        yield num\n        num += step\n</code>\n</pre>\n", "senID": 1}, {"text": ["This isn't a complete solution (it doesn't handle negative steps), but it should get you going."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The difference between range() and xrange() is that the first returns the entire list, while the second returns a generator that generates each number as it is needed.", "The second one should work for any number, no matter how large."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In Python 3.0, xrange() has disappeared and range() behaves like xrange() did previously."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]