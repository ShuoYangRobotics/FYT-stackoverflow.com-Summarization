[[{"text": ["Ruby has syntactically lightweight support for literal anonymous procedures (called blocks in Ruby).", "Therefore, it doesn't need a new language feature for this."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "blocks", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["(In general, it is a bad sign, if you need to add language features.", "You should be able to implement everything in a library, otherwise it is a sign of bad language design."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So, what you normally do, is to write a method which takes a block of code, allocates the resource, executes the block of code in the context of that resource and then closes the resource."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Something like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def with(klass, *args)\n  yield r = klass.open(*args)\nensure\n  r.close\nend\n</code>\n</pre>\n", "senID": 4}, {"text": ["You could use it like this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n with File, 'temp.txt', 'w' do |f|\n  f.write 'hi'\n  raise 'spitespite'\nend\n</code>\n</pre>\n", "senID": 6}, {"text": ["However, this is a very procedural way to do this.", "Ruby is an object-oriented language, which means that the responsibility of properly executing a block of code in the context of a File should belong to the File class:"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "File", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "File", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n File.open 'temp.txt', 'w' do |f|\n  f.write 'hi'\n  raise 'spitespite'\nend\n</code>\n</pre>\n", "senID": 8}, {"text": ["This could be implemented something like this:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n def File.open(*args)\n  f = new(*args)\n  return f unless block_given?\n  yield f\nensure\n  f.close if block_given?\nend\n</code>\n</pre>\n", "senID": 10}, {"text": ["This is a general pattern that is implemented by lots of classes in the Ruby core library, standard libraries and third-party libraries."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["A more close correspondence to the generic Python context manager protocol would be:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n def with(ctx)\n  yield ctx.setup\nensure\n  ctx.teardown\nend\n\nclass File\n  def setup; self end\n  alias_method :teardown, :close\nend\n\nwith File.open('temp.txt', 'w') do |f|\n  f.write 'hi'\n  raise 'spitespite'\nend\n</code>\n</pre>\n", "senID": 13}, {"text": ["Note that this is virtually indistinguishable from the Python example, but it didn't require the addition of new syntax to the language."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}], [{"text": ["The equivalent in Ruby would be to pass a block to the File.open method."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n File.open(...) do |file|\n  #do stuff with file\nend  #file is closed\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is the idiom that Ruby uses and one that you should get comfortable with."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could use Block Arguments to do this in Ruby:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Object  \n    def with(obj)  \n        obj.__enter__  \n        yield  \n        obj.__exit__  \n    end  \nend\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now, you could add __enter__ and __exit__ methods to another class and use it like this:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "__enter__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__exit__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n with GetSomeObject(\"somefile.text\") do |foo|  \n    do_something_with(foo)\nend\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You could always use a try..catch..finally block, where the finally section contains code to clean up."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "try..catch..finally", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "finally", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: sorry, misspoke: you'd want begin..rescue..ensure."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "begin..rescue..ensure", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I believe you are looking for ensure."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ensure", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ruby.activeventure.com/usersguide/rg/ensure.html"}]}], [{"text": ["I'll just add some more explanations for others; credit should go to them."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Indeed, in Ruby, clean-up code is as others said, in ensure clause; but wrapping things in blocks is ubiquitous in Ruby, and this is how it is done most efficiently and most in spirit of Ruby.", "When translating, don't translate directly word-for-word, you will get some very strange sentences.", "Similarly, don't expect everything from Python to have one-to-one correspondence to Ruby."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "ensure", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["From the link you posted:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class controlled_execution:\n    def __enter__(self):\n        set things up\n        return thing\n    def __exit__(self, type, value, traceback):\n        tear things down\n\nwith controlled_execution() as thing:\n     some code\n</code>\n</pre>\n", "senID": 3}, {"text": ["Ruby way, something like this (man, I'm probably doing this all wrong :D ):"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def controlled_executor\n  begin\n    do_setup\n    yield\n  ensure\n    do_cleanup\n  end\nend\n\ncontrolled_executor do ...\n  some_code\nend\n</code>\n</pre>\n", "senID": 5}, {"text": ["Obviously, you can add arguments to both controlled executor (to be called in a usual fashion), and to yield (in which case you need to add arguments to the block as well).", "Thus, to implement what you quoted above,"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "controlled executor", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class File\n  def my_open(file, mode=\"r\")\n    handle = open(file, mode)\n    begin\n      yield handle\n    ensure\n      handle.close\n    end\n  end\nend\n\nFile.my_open(\"temp.txt\", \"w\") do |f|\n  f.write(\"hi\")\n  raise Exception.new(\"spitesprite\")\nend\n</code>\n</pre>\n", "senID": 7}]]