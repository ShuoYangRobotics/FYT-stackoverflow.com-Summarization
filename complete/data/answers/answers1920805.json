[[{"text": ["This has nothing to do with the language.", "It is a question of the hardware (if the machine only has 1 CPU, it is simply physically impossible to execute two instructions at the same time), the Operating System (again, if the OS doesn't support true multithreading, there is nothing you can do) and the language implementation / execution engine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Unless the language specification explicitly forbids or enforces true multithreading, this has absolutely nothing whatsoever to do with the language."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["All the languages that you mention, plus all the languages that have been mentioned in the answers so far, have multiple implementations, some of which support true multithreading, some don't, and some are built on top of other execution engines which might or might not support true multithreading."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "All", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "other", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Take Ruby, for example.", "Here are just some of its implementations and their threading models:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "some", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"tag": "ul", "num": 6, "lis": [{"text": "MRI: green threads, no true multithreading", "tag": "none", "senID": 4}, {"text": "YARV: OS threads, no true multithreading", "tag": "none", "senID": 5}, {"text": "Rubinius: OS threads, true multithreading", "tag": "none", "senID": 6}, {"text": "MacRuby: OS threads, true multithreading", "tag": "none", "senID": 7}, {"text": "JRuby, XRuby: JVM threads, depends on the JVM (if the JVM supports true multithreading, then JRuby/XRuby does, too, if the JVM doesn't, then there's nothing ", "tag": "none", "senID": 8}, {"text": "IronRuby, Ruby.NET: just like JRuby, XRuby, but on the CLI instead of on the JVM", "tag": "none", "senID": 9}]}, {"text": ["See also my answer to another similar question about Ruby.", "(Note that that answer is more than a year old, and some of it is no longer accurate.", "Rubinius, for example, uses truly concurrent native threads now, instead of truly concurrent green threads.", "Also, since then, several new Ruby implementations have emerged, such as BlueRuby, tinyrb, Ruby Go Lightly, Red Sun and SmallRuby."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "my answer to another similar question about Ruby", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://StackOverflow.Com/questions/56087/57802/#57802"}, {"text": "new", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"text": ["Similar for Python:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "CPython: native threads, no true multithreading", "tag": "none", "senID": 12}, {"text": "PyPy: native threads, depends on the execution engine (PyPy can run natively, or on top of a JVM, or on top of a CLI, or on top of ", "tag": "none", "senID": 13}, {"text": "Unladen Swallow: native threads, currently no true multithreading, but fix is planned", "tag": "none", "senID": 14}, {"text": "Jython: JVM threads, see JRuby", "tag": "none", "senID": 15}, {"text": "IronPython: CLI threads, see IronRuby", "tag": "none", "senID": 16}]}, {"text": ["For Haskell, at least the Glorious Glasgow Haskell Compiler supports true multithreading with native threads.", "I don't know about UHC, LHC, JHC, YHC, HUGS or all the others."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["For Erlang, both BEAM and HiPE support true multithreading with green threads."], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "both", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Again: this depends on the Virtual Machine, the Operating System and the hardware.", "Also, some of the implementations mentioned above, don't even have Virtual Machines."], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "have", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["The GHC compiler will run your program on multiple OS threads (and thus multiple cores) if you compile with the -threaded option and then pass +RTS -N&lt;x&gt; -RTS at runtime, where &lt;x&gt; = the number of OS threads you want."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "-threaded", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "+RTS -N&lt;x&gt; -RTS", "childNum": 0, "tag": "code", "childList": []}, {"text": "&lt;x&gt;", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The Haskell implementation, GHC, supports multiple mechanisms for parallel execution on shared memory multicore.", "These mechanisms are described in \"Runtime Support for Multicore Haskell\"."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Runtime Support for Multicore Haskell", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.haskell.org/~simonmar/bib/multicore-ghc-09_abstract.html"}]}, {"text": ["Concretely, the Haskell runtime divides work be N OS threads, distributed over the available compute cores.", "These N OS threads in turn run M lightweight Haskell threads (sometimes millions of them).", "In turn, each Haskell thread can take work for a spark queue (there may be billions of sparks).", "Like so:\n"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "img", "pos": 0, "childList": []}]}, {"text": ["The runtime schedules work to be executed on separate cores, migrates work, and load balances.", "The garbage collector is also a parallel one, using each core to collect part of the heap."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Unlike Python or Ruby, there's no global interpreter lock, so for that, and other reasons, GHC is particularly good on mulitcore in comparison, e.g.", "Haskell v Python on the multicore shootout"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Haskell v Python on the multicore shootout", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=python&box=1"}]}], [{"text": ["The current version of Ruby 1.9(YARV- C based version) has native threads but has the problem of GIL.", "As I know Python also has the problem of GIL. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However both Jython and JRuby(mature Java implementations of both Ruby and Python) provide native multithreading, no green threads and no GIL. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Don't know about Haskell."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Haskell is thread-capable, in addition you get pure functional language - no side effects "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "pure", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Purely%5Ffunctional"}, {"href": "http://en.wikipedia.org/wiki/Side%5Feffect%5F%28computer%5Fscience%29", "text": "side effects", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["For real concurrency, you probably want to try Erlang."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I second the choice of Erlang.", "Erlang can support distributed highly concurrent programming out of the box.", "Does not matter whether you callit \"multi-threading\" or \"multi-processing\".", "Two important elements to consider are the level of concurrency and the fact that Erlang processes do not share state. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "do not share", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}, {"text": ["No shared state among processes is a good thing."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Haskell is suitable for anything.", "python has processing module, which (I think - not sure) helps to avoid GIL problems.", "(so it suitable for anything too). "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "processing", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["But my opinion - best way you can do is to select highest level possible language with static type system for big and huge things.", "Today this languages are: ocaml, haskell, erlang."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you want to develop small thing - python is good.", "But when things become bigger - all python benefits are eaten by miriads of tests."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I didn't use ruby.", "I still thinking that ruby is a toy language.", "(Or at least there's no reason to teach ruby when you know python - better to read SICP book)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]