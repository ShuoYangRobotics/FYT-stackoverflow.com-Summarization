[[{"text": ["\"Do child processes spawned via multiprocessing share objects created earlier in the program?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["No.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Processes have independent memory space."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Solution 1"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Solution 1", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["To make best use of a large structure with lots of workers, do this."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Each process reads, does work and writes."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["This is remarkably efficient since all processes are running concurrently.", "The writes and reads pass directly through shared buffers between the processes."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"tag": "hr", "senID": 7}, {"text": ["Solution 2"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Solution 2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["In some cases, you have a more complex structure -- often a \"fan-out\" structure.", "In this case you have a parent with multiple children."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["The child parts are pleasant to write because each child simply reads sys.sydin.  "], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "sys.sydin", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The parent has a little bit of fancy footwork in spawning all the children and retaining the pipes properly, but it's not too bad."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Fan-in is the opposite structure.", "A number of independently running processes need to interleave their inputs into a common process.", "The collector is not as easy to write, since it has to read from many sources.  "], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Reading from many named pipes is often done using the select module to see which pipes have pending input."], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "select", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "hr", "senID": 14}, {"text": ["Solution 3"], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "Solution 3", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Shared lookup is the definition of a database.  "], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["Solution 3A -- load a database.", "Let the workers process the data in the database."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["Solution 3B -- create a very simple server using werkzeug (or similar) to provide WSGI applications that respond to HTTP GET so the workers can query the server."], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "werkzeug", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://werkzeug.pocoo.org/"}]}, {"tag": "hr", "senID": 19}, {"text": ["Solution 4"], "childNum": 1, "tag": "p", "senID": 20, "childList": [{"text": "Solution 4", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Shared filesystem object.", "Unix OS offers shared memory objects.", "These are just files that are mapped to memory so that swapping I/O is done instead of more convention buffered reads."], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"text": ["You can do this from a Python context in several ways"], "childNum": 0, "tag": "p", "senID": 22, "childList": []}], [{"text": ["It depends.", "For global read-only variables it can be often considered so (apart from the memory consumed) else it should not. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["multiprocessing's documentation says:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "multiprocessing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/multiprocessing.html#multiprocessing-programming"}]}, {"text": ["Better to inherit than pickle/unpickle"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Better to inherit than pickle/unpickle", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Explicitly pass resources to child processes"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Explicitly pass resources to child processes", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Global variables"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Global variables", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["On Windows (single CPU):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nimport os, sys, time\nfrom multiprocessing import Pool\n\nx = 23000 # replace `23` due to small integers share representation\nz = []    # integers are immutable, let's try mutable object\n\ndef printx(y):\n    global x\n    if y == 3:\n       x = -x\n    z.append(y)\n    print os.getpid(), x, id(x), z, id(z) \n    print y\n    if len(sys.argv) == 2 and sys.argv[1] == \"sleep\":\n       time.sleep(.1) # should make more apparant the effect\n\nif __name__ == '__main__':\n    pool = Pool(processes=4)\n    pool.map(printx, (1,2,3,4))\n</code>\n</pre>\n", "senID": 6}, {"text": ["With sleep:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "sleep", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ python26 test_share.py sleep\n2504 23000 11639492 [1] 10774408\n1\n2564 23000 11639492 [2] 10774408\n2\n2504 -23000 11639384 [1, 3] 10774408\n3\n4084 23000 11639492 [4] 10774408\n4\n</code>\n</pre>\n", "senID": 8}, {"text": ["Without sleep:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "sleep", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ python26 test_share.py\n1148 23000 11639492 [1] 10774408\n1\n1148 23000 11639492 [1, 2] 10774408\n2\n1148 -23000 11639324 [1, 2, 3] 10774408\n3\n1148 -23000 11639324 [1, 2, 3, 4] 10774408\n4\n</code>\n</pre>\n", "senID": 10}], [{"text": ["If you're running under Unix, they may share the same object, due to how fork works (i.e., the child processes have separate memory but it's copy-on-write, so it may be shared as long as nobody modifies it).", "I tried the following:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "how fork works", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://unixfaq.blogspot.com/2008/08/whats-difference-between-fork-and-vfork.html"}]}, {"code": "<pre>\n<code>\n import multiprocessing\n\nx = 23\n\ndef printx(y):\n    print x, id(x)\n    print y\n\nif __name__ == '__main__':\n    pool = multiprocessing.Pool(processes=4)\n    pool.map(printx, (1,2,3,4))\n</code>\n</pre>\n", "senID": 1}, {"text": ["and got the following output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n$ ./mtest.py\n23 22995656\n1\n23 22995656\n2\n23 22995656\n3\n23 22995656\n4\n</pre>\n", "senID": 3}, {"text": ["Of course this doesn't prove that a copy hasn't been made, but you should be able to verify that in your situation by looking at the output of ps to see how much real memory each subprocess is using."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "prove", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "ps", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["S.Lott is correct.", "Python's multiprocessing shortcuts effectively give you a separate, duplicated chunk of memory."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "S.Lott", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/659865/python-multiprocessing-sharing-a-large-read-only-object-between-processes/659888#659888"}]}, {"text": ["On most *nix systems, using a lower-level call to os.fork() will, in fact, give you copy-on-write memory, which might be what you're thinking.", "AFAIK, in theory, in the most simplistic of programs possible, you could read from that data without having it duplicated."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "os.fork()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["However, things aren't quite that simple in the Python interpreter.", "Object data and meta-data are stored in the same memory segment, so even if the object is never changes,  something like a reference counter for that object being incremented will cause a memory write, and therefore a copy.", "Almost any Python program that is doing more than \"print 'hello'\" will cause reference count increments, so you will likely never realize the benefit of copy-on-write."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Even if someone did manage to hack a shared-memory solution in Python, trying to coordinate garbage collection across processes would probably be pretty painful."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Not directly related to multiprocessing per se, but from your example, it would seem you could just use the shelve module or something like that.", "Does the \"big_lookup_object\" really have to be completely in memory?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "shelve", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/shelve.html"}]}], [{"text": ["Different processes have different address space.", "Like running different instances of the interpreter.", "That's what IPC (interprocess communication) is for."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can use either queues or pipes for this purpose.", "You can also use rpc over tcp if you want to distribute the processes over a network later."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://docs.python.org/dev/library/multiprocessing.html#exchanging-objects-between-processes"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://docs.python.org/dev/library/multiprocessing.html#exchanging-objects-between-processes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/multiprocessing.html#exchanging-objects-between-processes"}]}]]