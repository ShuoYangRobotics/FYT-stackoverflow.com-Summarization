[[{"text": ["This isn't directly answering your question, but I think a better approach to solving this problem would be to not add/remove the member method domagic on your wiz object:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "not", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "domagic", "childNum": 0, "tag": "code", "childList": []}, {"text": "wiz", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["What I would do instead is within the domagic method, add a condition that checks for the relevant state of the wiz object, and then only perform the rest of the domagic method for a valid state, otherwise outputting an error message of your choosing."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "domagic", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "wiz", "childNum": 0, "tag": "code", "childList": []}, {"text": "domagic", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def domagic():\n    if (state != desired_state):\n    \tprint \"You cannot do any magic now!\"\n    \treturn\n    print \"Doing some magic\"\n    [some more commands]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["If an object is in a state where calling a given method on that object doesn't make sense, having it disappear from the object's interface seems like the wrong way to handle the problem.", "More explicit error handling gives you the ability to explain the problem more precisely to your callers, throwing NotEnoughMana instead of presenting them with a method-not-found error."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you're worried about having a bunch of function prefixes that look like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if self.StateNotValid():\n    raise NotEnoughMana()\n</code>\n</pre>\n", "senID": 2}, {"text": ["...then you could use a decorator on each function.", "It's shorter, and gives you an easy way to grep for all special-state-requiring functions."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You can't delete a class method from an instance of that class because the instance doesn't have that method.", "The protocol is:  if o is an instance of class Foo, and I call o.bar(), first o is examined to see if it has a method named bar.", "If it doesn't, then Foo is examined.", "The methods aren't bound to the instance unless they override its class."], "childNum": 7, "tag": "p", "senID": 0, "childList": [{"text": "have", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "o", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Foo", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "o.bar()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "o", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "bar", "childNum": 0, "tag": "code", "childList": []}, {"text": "Foo", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I don't see any good that can come from the road that you're going down here, either."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You can use a hack like that:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class A(object):\n...     def test(self):\n...         print 'test'\n... \n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; def noattr(name):\n...     raise AttributeError('no attribute %s' % name)\n... \n&gt;&gt;&gt; a.test = lambda *a, **k: noattr('test')\n&gt;&gt;&gt; a.test()\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n\n/Users/piranha/&lt;ipython console&gt; in &lt;module&gt;()\n\n/Users/piranha/&lt;ipython console&gt; in &lt;lambda&gt;(*a, **k)\n\n/Users/piranha/&lt;ipython console&gt; in noattr(name)\n\nAttributeError: no attribute test\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course, this gives you wrong traceback, but exception is the same.", ";-)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Another (IMHO - better) way is to override __getattr__ and then put dispatch logic there, then you can use it like that:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "__getattr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class A(object):\n...     def __getattr__(self, name):\n...         def inner(*args, **kwargs):\n...             print args, kwargs\n...         return inner\n... \n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.test\n    &lt;function inner at 0x1006c36e0&gt;\n&gt;&gt;&gt; a.test('q')\n('q',) {}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["There seem to be some pretty good ideas to address the explicit question of how to hide/remove a method from a python object, so I'd like to address a higher level question.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Specifically, the problem statement from the original question:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This situation is a classic example of the problem solved via the State Design Pattern:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "State Design Pattern", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/State%5Fpattern"}]}, {"text": ["I would consider using this pattern if your Wizard has the following properties:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Wizard", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Looks like the way to dir() works by default is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dir(obj) == sorted(obj.__dict__.keys() + dir(obj.__class__))\n</code>\n</pre>\n", "senID": 1}, {"text": ["(well, removing duplicates anyway)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["So an approach would be:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Wizard(object):\n    def __init__(self):\n        self.mana = 0\n\n    def __dir__(self):\n        natdir = set(self.__dict__.keys() + dir(self.__class__))\n        if self.mana &lt;= 0:\n            natdir.remove(\"domagic\")\n        return list(natdir)\n\n    def addmana(self):\n        self.mana += 1\n\n    def domagic(self):\n        if self.mana &lt;= 0:\n            raise NotEnoughMana()\n        print \"Abracadabra!\"\n        self.mana -= 1\n</code>\n</pre>\n", "senID": 4}, {"text": ["With the behaviour in Py2.6 being:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; wiz = Wizard()\n\n&gt;&gt;&gt; [x for x in dir(wiz) if not x.startswith(\"_\")]\n['addmana', 'mana']\n\n&gt;&gt;&gt; wiz.addmana()\n\n&gt;&gt;&gt; [x for x in dir(wiz) if not x.startswith(\"_\")]\n['addmana', 'domagic', 'mana']\n\n&gt;&gt;&gt; wiz.domagic()\nAbracadabra!\n\n&gt;&gt;&gt; [x for x in dir(wiz) if not x.startswith(\"_\")]\n['addmana', 'mana']\n\n&gt;&gt;&gt; wiz.domagic()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 13, in domagic\n__main__.NotEnoughMana\n</code>\n</pre>\n", "senID": 6}]]