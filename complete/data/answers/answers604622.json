[[{"text": ["A class may be a better fit here (and is usually a better fit for anything involving \"state\"):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Stateful(object):\n\n    def __init__(self):\n        self.state_var = 0\n\n    def __call__(self):\n        self.state_var = self.state_var + 1\n        print self.state_var\n\nfoo = Stateful()\nfoo()\nfoo()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The closest parallel is probably to attach values to the function itself."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo():\n    foo.bar = foo.bar + 1\n\nfoo.bar = 0\n\nfoo()\nfoo()\nfoo()\n\nprint foo.bar # prints 3\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Python has generators which do something similar:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://stackoverflow.com/questions/231767/can-somebody-explain-me-the-python-yield-statement"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://stackoverflow.com/questions/231767/can-somebody-explain-me-the-python-yield-statement", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/231767/can-somebody-explain-me-the-python-yield-statement"}]}], [{"text": ["Not sure if this is what you're looking for, but python has generator functions that don't return a value per se, but a generator object that generates a new value everytime"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def gen():\n   x = 10\n   while True:\n      yield x\n      x += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = gen()\n&gt;&gt;&gt; a.next()\n10\n&gt;&gt;&gt; a.next()\n11\n&gt;&gt;&gt; a.next()\n12\n&gt;&gt;&gt; a.next()\n13\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["look here for more explanation on yield:\nhttp://stackoverflow.com/questions/231767/can-somebody-explain-me-the-python-yield-statement"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "yield", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/231767/can-somebody-explain-me-the-python-yield-statement"}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"href": "http://stackoverflow.com/questions/231767/can-somebody-explain-me-the-python-yield-statement", "text": "http://stackoverflow.com/questions/231767/can-somebody-explain-me-the-python-yield-statement", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Here's one way to implement a closure in python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def outer():\n    a = [4]\n    def inner():\n        print a[0]\n        a[0] = a[0] + 1\n    return inner\n\nfn = outer()\nfn() # =&gt; 4\nfn() # =&gt; 5\nfn() # =&gt; 6\n</code>\n</pre>\n", "senID": 1}, {"text": ["I borrowed this example verbatim from a python mailing list post."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "python mailing list post", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-list/2004-July/270951.html"}]}], [{"text": ["Yes, though you have to declare your global variable first before it is encountered in foo:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n x = 0\n\ndef foo():\n    global x\n    x += 1\n    print x\n\nfoo()\nfoo()\nfoo()\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: In response to the comment, it's true that python has no static variables scoped within a function.", "Note that x in this example is only exposed as global to the rest of the module.", "For example, say the code above is in test.py.", "Now suppose you write the following module:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "test.py", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n from test import foo\nx = 100\nfoo()\nfoo()\n</code>\n</pre>\n", "senID": 3}, {"text": ["The output will be only 1 and 2, not 101 and 102."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "2", "childNum": 0, "tag": "code", "childList": []}, {"text": "101", "childNum": 0, "tag": "code", "childList": []}, {"text": "102", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You could also use something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def static_num2():\n    k = 0\n    while True:\n        k += 1\n        yield k\n\nstatic = static_num2().next\n\nfor i in range(0,10) :\n    print static()\n</code>\n</pre>\n", "senID": 1}, {"text": ["to avoid a global var.", "Lifted from this link about the same question."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "this link", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.daniweb.com/forums/thread33025.html"}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo():\n    x = 1\n    while True:\n        yield x\n        x += 1\n\n\n&gt;&gt;&gt; z = iter(foo())\n&gt;&gt;&gt; next(z)\n1\n&gt;&gt;&gt; next(z)\n2\n&gt;&gt;&gt; next(z)\n3\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Not that I'm recommending this, but just for fun:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo(var=[1]):\n    print var[0]\n    var[0] += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["This works because of the way mutable default arguments work in Python."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "way mutable default arguments", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/default-values.htm"}]}], [{"text": ["The preferable way is to use class or generator (yield)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "class", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/604622/does-python-have-something-like-perl-5-10s-state-variables/604645#604645"}, {"href": "http://stackoverflow.com/questions/604622/does-python-have-something-like-perl-5-10s-state-variables/604658#604658", "text": "generator", "childNum": 0, "tag": "a", "childList": []}, {"text": "yield", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For the sake of completeness here's a variant w/ closure in Python 3.x:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def make_foo():\n...     x = 1\n...     def foo():\n...         nonlocal x\n...         print(x)\n...         x += 1\n...     return foo\n...\n&gt;&gt;&gt; foo = make_foo()\n&gt;&gt;&gt; foo()\n1\n&gt;&gt;&gt; foo()\n2\n&gt;&gt;&gt; foo()\n3\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Here's another dirty cheap way to do it, it's a variation on Tryiptich's answer, but using decorators"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def static_var( name, value ):\n    def dec( function ):\n        setattr( function, name, value )\n        return function\n    return dec\n\n\n@static_var( 'counter', 0 )\ndef counting_function():\n    counting_function.counter = counting_function.counter + 1\n    print counting_function.counter\n\n\n\n\"\"\"\n&gt;&gt;&gt; counting_function()\n1\n&gt;&gt;&gt; counting_function()\n2\n&gt;&gt;&gt; counting_function()\n3\n&gt;&gt;&gt; counting_function()\n4\n&gt;&gt;&gt; counting_function()\n5\n&gt;&gt;&gt; \n\"\"\"\n</code>\n</pre>\n", "senID": 1}]]