[[{"text": ["I take it from your code snippet that lot is grouped w.r.t.", "category-1.", "Following should work then:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "lot", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "category-1", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import groupby, islice\nfrom operator import itemgetter\n\nans = []\nfor x, g1 in groupby(lot, itemgetter(0)):\n    for y, g2 in islice(groupby(g1, itemgetter(2)), 0, 3):\n        ans.extend(list(g2))\n\nprint ans\n# [('a', 'x1', 10), ('a', 'x2', 9), ('a', 'x3', 9), ('a', 'x4', 8), ('a', 'x5', 8),\n#  ('b', 'x1', 10), ('b', 'x2', 9), ('b', 'x3', 8)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you already have the input data sorted that way then is very probably that your solution is a little better than the heapq based one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Your algorithm complexity is O(n) while the heapq based one is conceptually O(n * log(3)) and it will probably need more passes over the data to arrange it properly. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Some additional details ...", "I timed both mhyfritz's excellent solution that uses itertools and  and my code (brute-force). "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "mhyfritz's excellent solution", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/6669632/n-largest-elements-in-an-sequence-need-to-retain-duplicates/6670141#6670141"}, {"text": "itertools", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Here are the timeit results for n = 10 and for a list with 1 million elements."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "timeit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "n = 10", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n # Here's how I built the sample list of 1 million entries.\nlot = []\nfor i in range(1001):\n    for j in reversed(range(333)):\n        for k in range(3):\n            lot.append((i, 'x', j))\n\n# timeit Results for n = 10\nbrute_force = 6.55s\nitertools = 2.07s\n# clearly the itertools solution provided by mhyfritz is much faster.\n</code>\n</pre>\n", "senID": 2}, {"text": ["In case anyone is curious, here is a trace of how his code works."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n + Outer loop - x, g1\n| a [('a', 'x1', 10), ('a', 'x2', 9), ('a', 'x3', 9), ('a', 'x4', 8), ('a', 'x5', 8), ('a', 'x6', 7)]\n+-- Inner loop - y, g2\n  |- 10 [('a', 'x1', 10)]\n  |- 9 [('a', 'x2', 9), ('a', 'x3', 9)]\n  |- 8 [('a', 'x4', 8), ('a', 'x5', 8)]\n+ Outer loop - x, g1\n| b [('b', 'x1', 10), ('b', 'x2', 9), ('b', 'x3', 8), ('b', 'x4', 7), ('b', 'x5', 6), ('b', 'x6', 5)]\n+-- Inner loop - y, g2\n  |- 10 [('b', 'x1', 10)]\n  |- 9 [('b', 'x2', 9)]\n  |- 8 [('b', 'x3', 8)]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["This is the idea, make a dict with the value you want to sort by as the key and a list of the tuples that have that value as the values."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Then sort the items of the dict by the keys, get the items from the top, extract their values and join them."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Quick, ugly code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sum(\n        map(lambda x: x[1],\n            sorted(dict([(x[2], filter(lambda y: y[2] == x[2], lot))\n                for x in lot]).items(),\n                reverse=True)[:3]),\n    [])\n\n7: [('a', 'x1', 10),\n ('b', 'x1', 10),\n ('a', 'x2', 9),\n ('a', 'x3', 9),\n ('b', 'x2', 9),\n ('a', 'x4', 8),\n ('a', 'x5', 8),\n ('b', 'x3', 8)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Just to give you some ideas, hope it helps.", "If you need some clarification ask in the comments"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["How's about this?", "It doesn't exactly return your desired result, since it reverse-sorts on y."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "exactly", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n # split lot by first element of values\nlots = defaultdict(list)\nfor x, y, z in lot:\n    lots[x].append((y, z))\n\nans = []\nfor x, l in lots.iteritems():\n    # find top-3 unique values\n    top = nlargest(3, set(z for (y, z) in l))\n    ans += [(x, y, z) for (z, y) in sorted([(z, y) for (y, z) in l\n                                                   if z in top],\n                                           reverse=True)]\n\nprint ans\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n from collections import *\n\ncategories = defaultdict(lambda: defaultdict(lambda: set()))\nfor t in myTuples:\n    cat1,cat2,val = t\n    categories[cat1][val].add(t)\n\ndef onlyTopThreeKeys(d):\n    keys = sorted(d.keys())[-3:]\n    return {k:d[k] for k in keys}\n\nprint( {cat1:onlyTopThreeKeys(sets) for cat1,sets in categories.items()} )\n</code>\n</pre>\n", "senID": 0}, {"text": ["Result:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n {'a': {8: {('a', 'x5', 8), ('a', 'x4', 8)},\n       9: {('a', 'x3', 9), ('a', 'x2', 9)},\n       10: {('a', 'x1', 10)}},\n 'b': {8: {('b', 'x3', 8)}, \n       9: {('b', 'x2', 9)}, \n       10: {('b', 'x1', 10)}}}\n</code>\n</pre>\n", "senID": 2}, {"text": ["flat list: I did the method above because it gives you more information.", "To just get a flat list, use closures to emit results with onlyTopThreeKeys:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "flat list", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "onlyTopThreeKeys", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from collections import *\n\ndef topTiedThreeInEachCategory(tuples):\n    categories = defaultdict(lambda: defaultdict(lambda: set()))\n    for t in myTuples:\n        cat1,cat2,val = t\n        categories[cat1][val].add(t)\n\n    reap = set()\n\n    def sowTopThreeKeys(d):\n        keys = sorted(d.keys())[-3:]\n        for k in keys:\n            for x in d[k]:\n                reap.add(x)\n    for sets in categories.values():\n        sowTopThreeKeys(sets)\n\n    return reap\n</code>\n</pre>\n", "senID": 4}, {"text": ["Result:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; topTiedThreeInEachCategory(myTuples)\n{('b', 'x2', 9), ('a', 'x1', 10), ('b', 'x3', 8), ('a', 'x2', 9), ('a', 'x4', 8), ('a', 'x3', 9), ('a', 'x5', 8), ('b', 'x1', 10)}\n</code>\n</pre>\n", "senID": 6}, {"text": ["You can also use itertools.groupby if your input is guaranteed to be sorted as in your sample input, but this will cause your code to break if the sorting ever changes."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "itertools.groupby", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]