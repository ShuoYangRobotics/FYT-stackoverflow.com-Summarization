[[{"text": ["Not only is a function more readable, it is also reusable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The inline expression may call c.find('@') twice, which is inefficient."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "c.find('@')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["As Useless has mentioned in the comments, there are already built in functions to do this; you really don't need to define your own function in this case:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n agent,_,address = c.partition('@')\n</code>\n</pre>\n", "senID": 3}, {"text": ["By the way, a callback is a function that is passed in as an argument and called later.", "You don't have a callback since it is not being called later.", "I think it should just be called a function."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Most Pythonic?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Don't reinvent the wheel, use str.partition()"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "str.partition()", "tag": "a", "pos": 0, "childList": [{"text": "str.partition()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#str.partition"}, {"text": "str.partition()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def slice_from_at(inp):\n    if '@' in inp:\n        return inp.partition('@')[2]\n    return inp\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you're more concerned about speed than readability, try str.rsplit():"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "str.rsplit()", "tag": "a", "pos": 0, "childList": [{"text": "str.rsplit()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#str.rsplit"}, {"text": "str.rsplit()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def slice_from_at(inp):\n    return inp.rsplit('@', 1)[-1]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Neither of your examples includes a \"callback\".", "Nor should they. "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["A well-named function that does one thing and does that one thing well is about as Pythonic as it gets.", "If it's backed-up with unit tests, so much the better."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["How about this instead?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n c.split('@')[0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The stylistic reason that [existing, but you could have wrote them yourself] functions like .partition() or .rsplit() are cleaner than c[:slice_from_at(c)] that the API of slice_from_at() is low-level: it returns an index into the string that it was given, but that index only makes sense to cut the string, so why not return the desired fragment(s) of the string directly?"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": ".partition()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".rsplit()", "childNum": 0, "tag": "code", "childList": []}, {"text": "c[:slice_from_at(c)]", "childNum": 0, "tag": "code", "childList": []}, {"text": "slice_from_at()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Generally, indexes into sequences are considered unpythonic when a higher-level alternative exists, as evidenced by the growing amount of built-in helpers that reduce exposure to indexes.", "Particular examples that come to mind:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["zip()"], "childNum": 0, "tag": "code", "senID": 2, "childList": []}, {"text": ["substring in string"], "childNum": 0, "tag": "code", "senID": 3, "childList": []}]}], [{"text": ["I tend to prefer string methods when they do the job easily, but for completeness, regular expressions should be mentioned:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n re.sub('^.*@', '', c)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I code like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if '@' in c:\n    c = c[:c.find('@')]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I don't move 2 lines of code in to separate function in most of cases."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]