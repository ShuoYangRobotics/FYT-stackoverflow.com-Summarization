[[{"text": ["You don't have to compute exactly where does the segments intersect, but only understand whether they intersect at all.", "This will simplify the solution."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "where", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "whether", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["The idea is to treat one segment as the \"anchor\" and separate the second segment into 2 points.", "Now, you will have to find the relative position of each point to the \"anchored\" segment (OnLeft, OnRight or Collinear).", "After doing so for both points, check that one of the points is OnLeft and the other is OnRight (or perhaps include Collinear position, if you wish to include improper intersections as well)."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "improper", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Implementing such method will be much easier than actually implementing a method that finds the intersection point (given the many corner cases which you will have to handle as well)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Update"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The following functions should illustrate the idea (source: Computational Geometry in C).", "Remark: This sample assumes the usage of integers.", "If you're using some floating-point representation instead (which could obviously complicate things), then you should determine some epsilon value to indicate \"equality\" (mostly for the IsCollinear evaluation)."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "Computational Geometry in C", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://rads.stackoverflow.com/amzn/click/0521649765"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "Remark:", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "IsCollinear", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n // points \"a\" and \"b\" forms the anchored segment.\n// point \"c\" is the evaluated point\nbool IsOnLeft(Point a, Point b, Point c)\n{\n     return Area2(a, b, c) &gt; 0;\n}\n\nbool IsOnRight(Point a, Point b, Point c)\n{\n     return Area2(a, b, c) &lt; 0;\n}\n\nbool IsCollinear(Point a, Point b, Point c)\n{\n     return Area2(a, b, c) == 0;\n}\n\n// calculates the triangle's size (formed by the \"anchor\" segment and additional point)\nint Area2(Point a, Point b, Point c)\n{\n     return (b.X - a.X) * (c.Y - a.Y) -\n            (c.X - a.X) * (b.Y - a.Y);\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["Of course, when using these function, one must remember to check that each segment lays \"between\" the other segment (since these are finite segments, and not infinite lines).  "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Also, using these function you can understand whether you've got a proper or improper intersection."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "proper", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "improper", "childNum": 0, "tag": "em", "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": ["Proper"], "childNum": 0, "tag": "strong", "senID": 8, "childList": []}, {"text": ["Improper"], "childNum": 0, "tag": "strong", "senID": 9, "childList": []}]}], [{"text": ["Suppose the two segments have endpoints A,B and C,D.", "The numerically robust way to determine intersection is to check the sign of the four determinants:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n | Ax-Cx  Bx-Cx |    | Ax-Dx  Bx-Dx |\n| Ay-Cy  By-Cy |    | Ay-Dy  By-Dy |\n\n| Cx-Ax  Dx-Ax |    | Cx-Bx  Dx-Bx |\n| Cy-Ay  Dy-Ay |    | Cy-By  Dy-By |\n</code>\n</pre>\n", "senID": 1}, {"text": ["For intersection, each determinant on the left must have the opposite sign of the one to the right, but there need not be any relationship between the two lines.", "You are basically checking each point of a segment against the other segment to make sure they lie on opposite sides of the line defined by the other segment."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["See here: http://www.cs.cmu.edu/~quake/robust.html"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://www.cs.cmu.edu/~quake/robust.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cs.cmu.edu/~quake/robust.html"}]}], [{"text": ["The formula for a line is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f(x) = A*x + b = y\n</code>\n</pre>\n", "senID": 1}, {"text": ["For a segment, it is exactly the same, except that x is included into an interval I."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you have two segments, defined as follow:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n Segment1 = {(X1, Y1), (X2, Y2)}\nSegment2 = {(X3, Y3), (X4, Y4)}\n</code>\n</pre>\n", "senID": 4}, {"text": ["The abcisse Xa of the potential point of intersection (Xa,Ya) must be contained in both interval I1 and I2, defined as follow :"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n I1 = [MIN(X1,X2), MAX(X1,X2)]\nI2 = [MIN(X3,X4), MAX(X3,X4)]\n</code>\n</pre>\n", "senID": 6}, {"text": ["And we could say that Xa is included into :"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n Ia = [MAX( MIN(X1,X2), MIN(X3,X4) ), MIN( MAX(X1,X2), MAX(X3,X4)] )]\n</code>\n</pre>\n", "senID": 8}, {"text": ["Now, you need to check that this interval Ia exists :"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n if (MAX(X1,X2) &lt; MIN(X3,X4))\n    return false; // There is no mutual abcisses\n</code>\n</pre>\n", "senID": 10}, {"text": ["So, you got two line formula, and a mutual interval.", "Your line formulas are:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n f1(x) = A1*x + b1 = y\nf2(x) = A2*x + b2 = y\n</code>\n</pre>\n", "senID": 12}, {"text": ["As we got two points by segment, we are able to determine A1, A2, b1 and b2:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n A1 = (Y1-Y2)/(X1-X2) // Pay attention to not dividing by zero\nA2 = (Y3-Y4)/(X3-X4) // Pay attention to not dividing by zero\nb1 = Y1-A1*X1 = Y2-A1*X2\nb2 = Y3-A2*X3 = Y4-A2*X4\n</code>\n</pre>\n", "senID": 14}, {"text": ["If the segments are parallel, then A1 == A2 :"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n if (A1 == A2)\n    return false; // Parallel segments\n</code>\n</pre>\n", "senID": 16}, {"text": ["A point (Xa,Ya) standing on both line must verify both formulas f1 and f2:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n Ya = A1 * Xa + b1\nYa = A2 * Xa + b2\nA1 * Xa + b1 = A2 * Xa + b2\nXa = (b2 - b1) / (A1 - A2) // Once again, pay attention to not dividing by zero\n</code>\n</pre>\n", "senID": 18}, {"text": ["The last thing to do is check that Xa is included into Ia:"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"code": "<pre>\n<code>\n if ( (Xa &lt; MAX( MIN(X1,X2), MIN(X3,X4) )) ||\n  (Xa &gt; MIN( MAX(X1,X2), MAX(X3,X4) )) )\n    return false; // intersection is out of bound\nelse\n    return true;\n</code>\n</pre>\n", "senID": 20}, {"text": ["In addition to this, you may check at startup that two of the four provided points are not equals to avoid all that testing."], "childNum": 0, "tag": "p", "senID": 21, "childList": []}], [{"text": ["I found this post from Bryce Boe that works really great, and is quick. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.bryceboe.com/2006/10/23/line-segment-intersection-algorithm/"}]}], [{"text": ["You have two line segments.", "Define one segment by endpoints A &amp; B and the second segment by endpoints C &amp; D. There is a nice trick to show that they must intersect, WITHIN the bounds of the segments.", "(Note that the lines themselves may intersect beyond the bounds of the segments, so you must be careful.", "Good code will also watch for parallel lines."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The trick is to test that points A and B must line on opposite sides of line CD, AND that points C and D must lie on opposite sides of line AB."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Since this is homework, I won't give you an explicit solution.", "But a simple test to see which side of a line a point falls on, is to use a dot product.", "Thus, for a given line CD, compute the normal vector to that line (I'll call it N_C.", ") Now, simply test the signs of these two results:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n dot(A-C,N_C)\n</code>\n</pre>\n", "senID": 3}, {"text": ["and"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n dot(B-C,N_C)\n</code>\n</pre>\n", "senID": 5}, {"text": ["If those results have opposite signs, then A and B are opposite sides of line CD.", "Now do the same test for the other line, AB.", "It has normal vector N_A.", "Compare the signs of"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n dot(C-A,N_A)\n</code>\n</pre>\n", "senID": 7}, {"text": ["and"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n dot(D-A,N_A)\n</code>\n</pre>\n", "senID": 9}, {"text": ["I'll leave it to you to figure out how to compute a normal vector.", "(In 2-d, that is trivial, but will your code worry about whether A and B are distinct points?", "Likewise, are C and D distinct?"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["You still need to worry about line segments that lie along the same infinite line, or if one point actually falls on the other line segment itself.", "Good code will cater to every possible problem."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["if your data define line you just have to prove that they are not parallel.", "To do this you can compute  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n alpha = float(y2 - y1) / (x2 - x1).\n</code>\n</pre>\n", "senID": 1}, {"text": ["If this coefficient is equal for both Line1 and Line2, it means the line are parallel.", "If not, it means they will intersect. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If they are parallel you then have to prove that they are not the same.", "For that, you compute   "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n beta = y1 - alpha*x1\n</code>\n</pre>\n", "senID": 4}, {"text": ["If beta is the same for Line1 and Line2,it means you line intersect as they are equal"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["If they are segment, you still have to compute alpha and beta as described above for each Line.", "Then you have to check that (beta1 - beta2) / (alpha1 - alpha2) is greater than Min(x1_line1, x2_line1) and less than Max(x1_line1, x2_line1)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Calculate the intersection point of the lines laying on your segments (it means basically to solve a linear equation system), then check whether is it between the starting and ending points of your segments."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["This is what I've got for AS3, don't know much about python but the concept is there"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n public function getIntersectingPointF($A:Point, $B:Point, $C:Point, $D:Point):Number {\n        var A:Point = $A.clone();\n        var B:Point = $B.clone();\n        var C:Point = $C.clone();\n        var D:Point = $D.clone();\n        var f_ab:Number = (D.x - C.x) * (A.y - C.y) - (D.y - C.y) * (A.x - C.x);\n\n        // are lines parallel\n        if (f_ab == 0) { return Infinity };\n\n        var f_cd:Number = (B.x - A.x) * (A.y - C.y) - (B.y - A.y) * (A.x - C.x);\n        var f_d:Number = (D.y - C.y) * (B.x - A.x) - (D.x - C.x) * (B.y - A.y);\n        var f1:Number = f_ab/f_d\n        var f2:Number = f_cd / f_d\n        if (f1 == Infinity || f1 &lt;= 0 || f1 &gt;= 1) { return Infinity };\n        if (f2 == Infinity || f2 &lt;= 0 || f2 &gt;= 1) { return Infinity };\n        return f1;\n    }\n\n    public function getIntersectingPoint($A:Point, $B:Point, $C:Point, $D:Point):Point\n    {\n        var f:Number = getIntersectingPointF($A, $B, $C, $D);\n        if (f == Infinity || f &lt;= 0 || f &gt;= 1) { return null };\n\n        var retPoint:Point = Point.interpolate($A, $B, 1 - f);\n        return retPoint.clone();\n    }\n</code>\n</pre>\n", "senID": 1}], [{"text": ["for segments AB and CD, find the slope of CD\nslope=(Dy-Cy)/(Dx-Cx)\nextend CD over A and B, and take the distance to CD going straight up\ndist1=slope*(Cx-Ax)+Ay-Cy\ndist2=slope*(Dx-Ax)+Ay-Dy\ncheck if they are on opposite sides\nreturn dist1*dist2&lt;0"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]