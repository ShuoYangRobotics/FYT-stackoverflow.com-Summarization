[[{"text": ["(Well, since this is tagged with Python):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["We use Python's optparse module for this purpose.", "It has a much friendlier API than lots of ifs."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "optparse", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/optparse.html"}]}], [{"text": ["Create a hash table which stores function pointers (in C# that'd be delegates) for handling each of the parameters, keyed using the parameter text.", "Then you just go through the command line in a loop and make calls to delegates based on what comes out of hash table lookups."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["A useful options library for C#: NDesk.Options"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "NDesk.Options", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ndesk.org/Options"}]}], [{"text": ["The getopt function is very common for C programming.", "It can parse parameters for you.", "Here is a question (and answer) where to get it for C#: http://stackoverflow.com/questions/172443/getopt-library-for-c ."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://stackoverflow.com/questions/172443/getopt-library-for-c", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/172443/getopt-library-for-c"}]}, {"text": ["Especially lappies implementation looks like rather modern C# with attributes and such."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "lappies", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/172443/getopt-library-for-c#172533"}]}], [{"text": ["I'd be a little uncomfortable using a command line like that.", "First thing I'd say is \"what does the first '1' mean, and why is it different to the second '1'?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Any time I write a command line utility that accepts an argument, I consider how easy it would be for a user to learn all the options.", "In this case, it looks like a bit of a hard task, IMHO."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Maybe refactoring how the user passes the arguments would be a good idea.", "There's a reason why a lot of software takes key/value type parameters (e.g.", "myclient.exe -server=myServerName -config=debug) It takes a lot of load off the user, and also simplifies the argument parsing once it hits your code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Just for fun, you can create a wrapper around the whole thing and work with strong names in your code.", "More work?", "Yes.", "But more fun and once you add a new command to the wrapper you can forget about it ;)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n public class Form1 \n{ \n\nprivate void main() \n{ \n    MyCommandHandler CommandLineHandler = new MyCommandHandler(); \n    CommandLineHandler.SetInput = \"-t alpha 1 -prod 1 2 -sleep 200\"; \n\n    //now we can use strong name to work with the variables: \n    //CommandLineHandler.prod.ProdID \n    //CommandLineHandler.prod.ProdInstanceID \n    //CommandLineHandler.Alpha.AlhaValue() \n    //CommandLineHandler.Sleep.Miliseconds() \n    if (CommandLineHandler.Alpha.AlhaValue &gt; 255) { \n        throw new Exception(\"Apha value out of bounds!\"); \n    } \n\n} \n} \n\npublic class MyCommandHandler \n{ \nprivate string[] values; \npublic string SetInput { \n    set { values = Strings.Split(value, \"-\"); } \n} \n\n//Handle Prod command \npublic struct prodstructure \n{ \n    public string ProdID; \n    public string ProdInstanceID; \n} \npublic prodstructure prod { \n    get { \n        prodstructure ret = new prodstructure(); \n        ret.ProdID = GetArgsForCommand(\"prod\", 0); \n        ret.ProdInstanceID = GetArgsForCommand(\"prod\", 1); \n        return ret; \n    } \n} \n\n//Handle Apha command \npublic struct Aphastructure \n{ \n    public int AlhaValue; \n} \npublic Aphastructure Alpha { \n    get { \n        Aphastructure ret = new Aphastructure(); \n        ret.AlhaValue = Convert.ToInt32(GetArgsForCommand(\"alpha\", 0)); \n        return ret; \n    } \n} \n\n\n//Handle Sleep command \npublic struct SleepStructure \n{ \n    public int Miliseconds; \n} \npublic SleepStructure Sleep { \n    get { \n        SleepStructure ret = new SleepStructure(); \n        ret.Miliseconds = Convert.ToInt32(GetArgsForCommand(\"sleep\", 0)); \n        return ret; \n    } \n} \n\n\nprivate string GetArgsForCommand(string key, int item) \n{ \n    foreach (string c in values) { \n        foreach (string cc in Strings.Split(c.Trim, \" \")) { \n            if (cc.ToLower == key.ToLower) { \n                try { \n                    return Strings.Split(c.Trim, \" \")(item + 1); \n                } \n                catch (Exception ex) { \n                    return \"\"; \n                } \n            } \n        } \n    } \n    return \"\"; \n} \n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The answer in Java, as is so often the case, is that someone has beaten you to it and released an excellent open source library to do this.", "Have a look at Apache CLI."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Apache CLI", "tag": "a", "pos": 1, "childList": [{"text": "Apache CLI", "tag": "strong"}], "childNum": 1, "href": "http://commons.apache.org/cli/"}, {"text": "Apache CLI", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["I dont think this is too cludging.. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n private void Main() \n{ \nstring c = \"-t alpha 1 -prod 1 2 -sleep 200\"; \n\nforeach (string incommand in Strings.Split(c, \"-\")) { \n    HandleCommand(Strings.Split(incommand.Trim, \" \")); \n} \n} \n\n\npublic void HandleCommand(string[] c) \n{ \nswitch (c(0).ToLower) { \n    case \"t\": \n        Interaction.MsgBox(\"Command:\" + c(0) + \" params: \" + c.Length - 1); \n        break; \n    case \"prod\": \n        Interaction.MsgBox(\"Command:\" + c(0) + \" params: \" + c.Length - 1); \n        break; \n    case \"sleep\": \n        Interaction.MsgBox(\"Command:\" + c(0) + \" params: \" + c.Length - 1); \n        break; \n} \n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course, instead of doing exactly same thing in those switch-statements, call appropriate functions or code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Commonly, you can replace large if/else or switch/case constructs with a Dictionary.", "Where the if-criteria is the key and the code to execute is the value."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, you could nave a Dictionary&lt;string, ICommand&gt; (or Dictionary&lt;string, Type&gt;), which you fill before you parse your command line."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Dictionary&lt;string, ICommand&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Dictionary&lt;string, Type&gt;", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["When you iterate over the passed in command line options, you simply look them up in the dictionary and \"invoke\" on the value which is the matching command (object) to execute (or alternatively use Activate.CreateInstance(/*dictionary-value*/) if you stored the type instead of a specific object instance)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Activate.CreateInstance(/*dictionary-value*/)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In C# 3.0 you could also something like Dictionary&lt;string, System.Linq.Expressions.Expression&lt;T&gt;&gt;, although this gets you pretty close to the actual if-statement - which is something you might want to have or not.", "YMMV."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Dictionary&lt;string, System.Linq.Expressions.Expression&lt;T&gt;&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Some libraries provide you with the mere parsing of the command line arguments (like traditionally getopt() et al did) or can provide the whole package, including the invokation of actions upon the presence of specific command line arguments."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]