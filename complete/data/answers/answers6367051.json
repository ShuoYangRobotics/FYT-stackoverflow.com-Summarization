[[{"text": ["A typical solution to this problem is to define a new class that wraps an existing instance of a file, which automatically counts the numbers.", "Something like this (just off the top of my head, I haven't tested this):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "file", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class FileLineWrapper(object):\n    def __init__(self, f):\n        self.f = f\n        self.line = 0\n    def close(self):\n        return self.f.close()\n    def readline(self):\n        self.line += 1\n        return self.f.readline()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Use it like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n f = FileLineWrapper(open(\"myfile.txt\", \"r\"))\nf.readline()\nprint(f.line)\n</code>\n</pre>\n", "senID": 3}, {"text": ["It looks like the standard module fileinput does much the same thing (and some other things as well); you could use that instead if you like."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "fileinput", "tag": "a", "pos": 0, "childList": [{"text": "fileinput", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/fileinput.html"}, {"text": "fileinput", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I'm not certain this has exactly what you need, but you might find the fileinput module useful."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "fileinput", "tag": "a", "pos": 0, "childList": [{"text": "fileinput", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/fileinput.html"}, {"text": "fileinput", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I don't think so, not in the way you desire (as in a standard built-in feature of Python file handles returned by open)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "open", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you're not amenable to tracking the line number manually as you read the lines or the use of a wrapper class (excellent suggestions by GregH and senderle, by the way), then I think you'll have to simply use the fp.tell() figure and go back to the start of the file, reading until you get there."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "fp.tell()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["That's not too bad an option since I'm assuming error conditions will be less likely than everything working swimmingly.", "If everything works okay, there's no impact."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "too", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["If there's an error, then you have the extra effort of rescanning the file.", "If the file is big, that may impact your perceived performance - you should take that into account if it's a problem."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "big,", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["You could use a decorator on readline function to count number of lines."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "decorator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0318/"}]}], [{"text": ["One way might be to iterate over the line and keep an explicit count of the number of lines already seen:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; f=open('text.txt','r')\n&gt;&gt;&gt; from itertools import izip\n&gt;&gt;&gt; from itertools import count\n&gt;&gt;&gt; f=open('test.java','r')\n&gt;&gt;&gt; for line_no,line in izip(count(),f):\n...     print line_no,line\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The following code creates a function Which_Line_for_Position(pos) that gives the number of the line for the position pos, that is to say the number of line in which lies the character situated  at  position pos in the file."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "Which_Line_for_Position(pos)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "number of the line", "childNum": 0, "tag": "strong", "childList": []}, {"text": "pos", "childNum": 0, "tag": "strong", "childList": []}, {"text": "number of line", "childNum": 0, "tag": "em", "childList": []}, {"text": "pos", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["This function can be used with any position as argument, independantly from the value of the file's  pointer's current position and from the historic of the movements of this pointer before the function is called."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So, with this function, one isn't limited to determine the number of the current line only during an uninterrupted iteration on the lines, as it is the case with Greg Hewgill's solution."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n with open(filepath,'rb') as f:\n    GIVE_NO_FOR_END = {}\n    end = 0\n    for i,line in enumerate(f):\n        end += len(line)\n        GIVE_NO_FOR_END[end] = i\n    if line[-1]=='\\n':\n        GIVE_NO_FOR_END[end+1] = i+1\n    end_positions = GIVE_NO_FOR_END.keys()\n    end_positions.sort()\n\ndef Which_Line_for_Position(pos,\n                            dic = GIVE_NO_FOR_END,\n                            keys = end_positions,\n                            kmax = end_positions[-1]):\n    return dic[(k for k in keys if pos &lt; k).next()] if pos&lt;kmax else None\n</code>\n</pre>\n", "senID": 3}, {"text": [], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The same solution can be written with the help of the module fileinput:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "fileinput", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import fileinput\n\nGIVE_NO_FOR_END = {}\nend = 0\nfor line in fileinput.input(filepath,'rb'):\n    end += len(line)\n    GIVE_NO_FOR_END[end] = fileinput.filelineno()\nif line[-1]=='\\n':\n    GIVE_NO_FOR_END[end+1] = fileinput.filelineno()+1\nfileinput.close()\n\nend_positions = GIVE_NO_FOR_END.keys()\nend_positions.sort()\n\ndef Which_Line_for_Position(pos,\n                            dic = GIVE_NO_FOR_END,\n                            keys = end_positions,\n                            kmax = end_positions[-1]):\n    return dic[(k for k in keys if pos &lt; k).next()] if pos&lt;kmax else None\n</code>\n</pre>\n", "senID": 6}, {"text": ["But this solution has some inconveniences: "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "it needs to import the module ", "tag": "none", "senID": 8}, {"text": "it deletes all the content of the file !! There must be something wrong in my code but I don't know ", "tag": "none", "senID": 9}, {"text": "it seems that the file is first entirely read before any iteration can be launched. If so, for a file very big, the size of the file may exceed the capacity of the RAM. I am not sure of this point: I tried to test with a file of 1,5 GB but it's rather long and I dropped this point for the moment. If this point is right, it constitutes an argument to use the other solution with ", "tag": "none", "senID": 10}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["exemple:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n text = '''Harold Acton (1904\u20131994)\nGilbert Adair (born 1944)\nHelen Adam (1909\u20131993)\nArthur Henry Adams (1872\u20131936)\nRobert Adamson (1852\u20131902)\nFleur Adcock (born 1934)\nJoseph Addison (1672\u20131719)\nMark Akenside (1721\u20131770)\nJames Alexander Allan (1889\u20131956)\nLeslie Holdsworthy Allen (1879\u20131964)\nWilliam Allingham (1824/28-1889)\nKingsley Amis (1922\u20131995)\nEthel Anderson (1883\u20131958)\nBruce Andrews (born 1948)\nMaya Angelou (born 1928)\nRae Armantrout (born 1947)\nSimon Armitage (born 1963)\nMatthew Arnold (1822\u20131888)\nJohn Ashbery (born 1927)\nThomas Ashe (1836\u20131889)\nThea Astley (1925\u20132004)\nEdwin Atherstone (1788\u20131872)'''\n\n\n#with open('alao.txt','rb') as f:\n\nf = text.splitlines(True)\n# argument True in splitlines() makes the newlines kept\n\nGIVE_NO_FOR_END = {}\nend = 0\nfor i,line in enumerate(f):\n    end += len(line)\n    GIVE_NO_FOR_END[end] = i\nif line[-1]=='\\n':\n    GIVE_NO_FOR_END[end+1] = i+1\nend_positions = GIVE_NO_FOR_END.keys()\nend_positions.sort()\n\n\nprint '\\n'.join('line %-3s  ending at position %s' % (str(GIVE_NO_FOR_END[end]),str(end))\n                for end in end_positions)\n\ndef Which_Line_for_Position(pos,\n                            dic = GIVE_NO_FOR_END,\n                            keys = end_positions,\n                            kmax = end_positions[-1]):\n    return dic[(k for k in keys if pos &lt; k).next()] if pos&lt;kmax else None\n\nprint\nfor x in (2,450,320,104,105,599,600):\n    print 'pos=%-6s   line %s' % (x,Which_Line_for_Position(x))\n</code>\n</pre>\n", "senID": 13}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n line 0    ending at position 25\nline 1    ending at position 51\nline 2    ending at position 74\nline 3    ending at position 105\nline 4    ending at position 132\nline 5    ending at position 157\nline 6    ending at position 184\nline 7    ending at position 210\nline 8    ending at position 244\nline 9    ending at position 281\nline 10   ending at position 314\nline 11   ending at position 340\nline 12   ending at position 367\nline 13   ending at position 393\nline 14   ending at position 418\nline 15   ending at position 445\nline 16   ending at position 472\nline 17   ending at position 499\nline 18   ending at position 524\nline 19   ending at position 548\nline 20   ending at position 572\nline 21   ending at position 600\n\npos=2        line 0\npos=450      line 16\npos=320      line 11\npos=104      line 3\npos=105      line 4\npos=599      line 21\npos=600      line None\n</code>\n</pre>\n", "senID": 15}, {"text": [], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["Then, having function Which_Line_for_Position() , it is easy to obtain the number of a current line : just passing f.tell() as argument to the function"], "childNum": 2, "tag": "p", "senID": 17, "childList": [{"text": "Which_Line_for_Position()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "f.tell()", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["But WARNING: when using f.tell() and doing movements of the file's pointer in the file, it is absolutely necessary that the file is opened in binary mode: 'rb' or 'rb+' or 'ab' or ...."], "childNum": 5, "tag": "p", "senID": 18, "childList": [{"text": "WARNING", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "f.tell()", "childNum": 0, "tag": "strong", "childList": []}, {"text": "'rb'", "childNum": 0, "tag": "strong", "childList": []}, {"text": "'rb+'", "childNum": 0, "tag": "strong", "childList": []}, {"text": "'ab'", "childNum": 0, "tag": "strong", "childList": []}]}]]