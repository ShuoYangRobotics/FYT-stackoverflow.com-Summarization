[[{"text": ["I recommend the approaches detailed here.", "It starts by explaining how to execute strings of Python code, then from there details how to set up a Python environment to interact with your C program, call Python functions from your C code, manipulate Python objects from your C code, etc."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "approaches detailed here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.linuxjournal.com/article/8497"}]}, {"text": ["EDIT: If you really want to go the route of IPC, then you'll want to use the struct module.", "Most communication between a Python and C process revolves around passing structs back and forth, either over a socket or through shared memory."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "EDIT", "childNum": 0, "tag": "b", "pos": 0, "childList": []}, {"text": "the struct module", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/struct.html"}, {"text": "over a socket", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/socket.html"}, {"href": "http://docs.python.org/library/mmap.html", "text": "shared memory", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["I recommend creating a Command struct with fields and codes to represent commands and their arguments.", "I can't give much more specific advice without knowing more about what you want to accomplish, but in general I recommend the protlib library, since it's what I use to communicate between C and Python programs (disclaimer: I am the author of protlib)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Command", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "protlib", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://courtwright.org/protlib/"}]}], [{"text": ["See the relevant chapter in the manual: http://docs.python.org/extending/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/extending/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/extending/"}]}, {"text": ["Essentially you'll have to embed the python interpreter into your program."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Have you considered just wrapping your python application in a shell script and invoking it from with in your C application?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Not the most elegant solution, but it is very simple."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I haven't used an IPC approach for Python&lt;->C communication but it should work pretty well.", "I would have the C program do a standard fork-exec and use redirected stdin and stdout in the child process for the communication.", "A nice text-based communication will make it very easy to develop and test the Python program."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "stdin", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "stdout", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["If I had decided to go with IPC, I'd probably splurge with XML-RPC -- cross-platform, lets you easily put the Python server project on a different node later if you want, has many excellent implementations (see here for many, including C and Python ones, and here for the simple XML-RPC server that's part the Python standard library -- not as highly scalable as other approaches but probably fine and convenient for your use case)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "XML-RPC", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.xmlrpc.com/"}, {"href": "http://www.xmlrpc.com/directory/1568/implementations", "text": "here", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://docs.python.org/library/simplexmlrpcserver.html", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["It may not be a perfect IPC approach for all cases (or even a perfect RPC one, by all means!", "), but the convenience, flexibility, robustness, and broad range of implementations outweigh a lot of minor defects, in my opinion."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["apparently Python need to be able to compile to win32 dll, it will solve the problem"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In such a way that converting c# code to win32 dlls will make it usable by any development tool"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]