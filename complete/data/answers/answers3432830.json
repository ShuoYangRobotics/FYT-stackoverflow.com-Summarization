[[{"text": ["A list comprehension has no good (clean, portable) way to refer to the very list it's building.", "One good and elegant approach might be to do the job in a generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def running_sum(a):\n  tot = 0\n  for item in a:\n    tot += item\n    yield tot\n</code>\n</pre>\n", "senID": 1}, {"text": ["to get this as a list instead, of course, use list(running_sum(a))."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "list(running_sum(a))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I'm not sure about 'elegant', but I think the following is much simpler and more intuitive (at the cost of an extra variable):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = range(20)\n\nrunningTotal = []\n\ntotal = 0\nfor n in a:\n  total += n\n  runningTotal.append(total)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The functional way to do the same thing is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a = range(20)\nrunningTotal = reduce(lambda x, y: x+[x[-1]+y], a, [0])[1:]\n</code>\n</pre>\n", "senID": 3}, {"text": ["...but that's much less readable/maintainable, etc."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["@Omnifarous suggests this should be improved to:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n a = range(20)\nrunningTotal = reduce(lambda l, v: (l.append(l[-1] + v) or l), a, [0])\n</code>\n</pre>\n", "senID": 6}, {"text": ["...but I still find that less immediately comprehensible than my initial suggestion."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Remember the words of Kernighan: \"Debugging is twice as hard as writing the code in the first place.", "Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["If you can use numpy, it has a built-in function named cumsum that does this."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org/"}, {"text": "cumsum", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import numpy\ntot = numpy.cumsum(a)  # returns a numpy.ndarray\ntot = list(tot)        # if you prefer a list\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This can be implemented in 2 lines in Python."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "This can be implemented in 2 lines in Python.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Using a default parameter eliminates the need to maintain an aux variable outside, and then we just do a map to the list."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def accumulate(x, l=[0]): l[0] += x; return l[0];\nmap(accumulate, range(20))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I would use a coroutine for this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def runningTotal():\n    accum = 0\n    yield None\n    while True:\n        accum += yield accum\n\ntot = runningTotal()\nnext(tot)\nrunning_total = [tot.send(i) for i in xrange(N)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is inefficient as it does it every time from beginning but possible it is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = range(20)\nruntot=[sum(a[:i+1]) for i,item in enumerate(a)]\nfor line in zip(a,runtot):\n    print line\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You are looking for two things: fold (reduce) and a funny function that keeps a list of the results of another function, which I have called running.", "I made versions both with and without an initial parameter; either way these need to go to reduce with an initial []."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def last_or_default(list, default):\n    if len(list) &gt; 0:\n        return list[-1]\n    return default\n\ndef initial_or_apply(list, f, y):\n    if list == []:\n        return [y]\n    return list + [f(list[-1], y)]\n\ndef running_initial(f, initial):\n    return (lambda x, y: x + [f(last_or_default(x,initial), y)])\n\ndef running(f):\n    return (lambda x, y: initial_or_apply(x, f, y))\n\ntotaler = lambda x, y: x + y\nrunning_totaler = running(totaler)\nrunning_running_totaler = running_initial(running_totaler, [])\n\ndata = range(0,20)\nrunning_total = reduce(running_totaler, data, [])\nrunning_running_total = reduce(running_running_totaler, data, [])\n\nfor i in zip(data, running_total, running_running_total):\n    print \"{0:&gt;3}{1:&gt;4}{2:&gt;83}\".format(*i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["These will take a long time on really large lists due to the + operator.", "In a functional language, if done correctly, this list construction would be O(n)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here are the first few lines of output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n 0   0                      [0]\n1   1                   [0, 1]\n2   3                [0, 1, 3]\n3   6             [0, 1, 3, 6]\n4  10         [0, 1, 3, 6, 10]\n5  15     [0, 1, 3, 6, 10, 15]\n6  21 [0, 1, 3, 6, 10, 15, 21]\n</code>\n</pre>\n", "senID": 4}]]