[[{"text": ["Why not just use a dictionary?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n p = {'name': 'John Smith', 'age': 23}\n\nprint p\nprint p['name']\nprint p['age']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Have you considered using a named tuple?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "named tuple", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html#namedtuple-factory-function-for-tuples-with-named-fields"}]}, {"text": ["Using your dict notation"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; L=namedtuple('literal', 'name age')(**{'name': 'John Smith', 'age':23})\n</code>\n</pre>\n", "senID": 2}, {"text": ["or keyword arguments"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; L=namedtuple('literal', 'name age')(name='John Smith', age=23)\n&gt;&gt;&gt; L\nliteral(name='John Smith', age=23)\n&gt;&gt;&gt; L.name\n'John Smith'\n&gt;&gt;&gt; L.age\n23\n</code>\n</pre>\n", "senID": 4}, {"text": ["It is possible to wrap this behaviour into a function easily enough"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def literal(**kw):\n    return namedtuple('literal', kw)(**kw)\n</code>\n</pre>\n", "senID": 6}, {"text": ["the lambda equivalent would be"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n literal = lambda **kw:namedtuple('literal', kw)(**kw)\n</code>\n</pre>\n", "senID": 8}, {"text": ["but I think it's silly giving names to \"anonymous\" functions"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["From ActiveState:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ActiveState", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/52308-the-simple-but-handy-collector-of-a-bunch-of-named/"}]}, {"code": "<pre>\n<code>\n class Bunch:\n    def __init__(self, **kwds):\n        self.__dict__.update(kwds)\n\n# that's it!  Now, you can create a Bunch\n# whenever you want to group a few variables:\n\npoint = Bunch(datum=y, squared=y*y, coord=x)\n\n# and of course you can read/write the named\n# attributes you just created, add others, del\n# some of them, etc, etc:\nif point.squared &gt; threshold:\n    point.isok = 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I don't see anything wrong with creating \"anonymous\" classes/instances.", "It's often very convienient to create one with simple function call in one line of code.", "I personally use something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def make_class( *args, **attributes ):\n    \"\"\"With fixed inability of using 'name' and 'bases' attributes ;)\"\"\"\n    if len(args) == 2:\n        name, bases = args\n    elif len(args) == 1:\n        name, bases = args[0], (object, )\n    elif not args:\n        name, bases = \"AnonymousClass\", (object, )\n    return type( name, bases, attributes )\n\nobj = make_class( something = \"some value\" )()\nprint obj.something\n</code>\n</pre>\n", "senID": 1}, {"text": ["For creating dummy objects it works just fine.", "Namedtuple is ok, but is immutable, which can be inconvenient at times.", "And dictionary is... well, a dictionary, but there are situations when you have to pass something with __getattr__ defined, instead of __getitem__."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "__getattr__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__getitem__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I don't know whether it's pythonic or not, but it sometimes speeds things up and for me it's good enough reason to use it (sometimes)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["From the Python IAQ:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python IAQ", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://norvig.com/python-iaq.html"}]}], [{"text": ["A simple dictionary should be enough for most cases."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you are looking for a similar API to the one you indicated for the literal case, you can still use dictionaries and simply override the special __getattr__ function:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "__getattr__", "tag": "a", "pos": 0, "childList": [{"text": "__getattr__", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/release/2.6.5/reference/datamodel.html#object.__getattr__"}, {"text": "__getattr__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class CustomDict(dict):\n    def __getattr__(self, name):\n        return self[name]\n\np = CustomDict(user='James', location='Earth')\nprint p.user\nprint p.location\n</code>\n</pre>\n", "senID": 2}, {"text": ["Note: Keep in mind though that contrary to namedtuples, fields are not validated and you are in charge of making sure your arguments are sane.", "Arguments such as p['def'] = 'something' are tolerated inside a dictionary but you will not be able to access them via p.def."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "Note", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "p['def'] = 'something'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "p.def", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I think object literals make sense in JavaScript for two reasons:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Thus no, object literals aren\u2019t Pythonic, but they are JavaScripthonic."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]