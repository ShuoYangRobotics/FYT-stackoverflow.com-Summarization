[[{"text": ["To answer your general question, you can use bit manipulation techniques:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "bit manipulation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Bit_twiddling"}]}, {"code": "<pre>\n<code>\n pid, status = os.wait()\nexitstatus, signum = status &amp; 0xFF, (status &amp; 0xFF00) &gt;&gt; 8\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, there are also built-in funtions for interpreting exit status values:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "built-in funtions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/os-process.html#l2h-2780"}]}, {"code": "<pre>\n<code>\n pid, status = os.wait()\nexitstatus, signum = os.WEXITSTATUS( status ), os.WTERMSIG( status )\n</code>\n</pre>\n", "senID": 3}, {"text": ["See also:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 6, "lis": [{"text": "os.WCOREDUMP()", "tag": "none", "senID": 5}, {"text": "os.WIFCONTINUED()", "tag": "none", "senID": 6}, {"text": "os.WIFSTOPPED()", "tag": "none", "senID": 7}, {"text": "os.WIFSIGNALED()", "tag": "none", "senID": 8}, {"text": "os.WIFEXITED()", "tag": "none", "senID": 9}, {"text": "os.WSTOPSIG()", "tag": "none", "senID": 10}]}], [{"text": ["This will do what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n signum = status &amp; 0xff\nexitstatus = (status &amp; 0xff00) &gt;&gt; 8\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can unpack the status using bit-shifting and masking operators."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "bit-shifting", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/ref/shifting.html"}, {"href": "http://docs.python.org/ref/bitwise.html", "text": "masking", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n low = status &amp; 0x00FF\nhigh = (status &amp; 0xFF00) &gt;&gt; 8\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm not a Python programmer, so I hope got the syntax correct."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n exitstatus, signum= divmod(status, 256)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["The folks before me've nailed it, but if you really want it on one line, you can do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (signum, exitstatus) = (status &amp; 0xFF, (status &gt;&gt; 8) &amp; 0xFF)\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: Had it backwards."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can get break your int into a string of unsigned bytes with the struct module:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "struct", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/struct.html"}]}, {"code": "<pre>\n<code>\n import struct\ni = 3235830701  # 0xC0DEDBAD\ns = struct.pack(\"&gt;L\", i)  # \"&gt;\" = Big-endian, \"&lt;\" = Little-endian\nprint s         # '\\xc0\\xde\\xdb\\xad'\nprint s[0]      # '\\xc0'\nprint ord(s[0]) # 192 (which is 0xC0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you couple this with the array module you can do this more conveniently:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "array", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/array.html"}]}, {"code": "<pre>\n<code>\n import struct\ni = 3235830701  # 0xC0DEDBAD\ns = struct.pack(\"&gt;L\", i)  # \"&gt;\" = Big-endian, \"&lt;\" = Little-endian\n\nimport array\na = array.array(\"B\")  # B: Unsigned bytes\na.fromstring(s)\nprint a   # array('B', [192, 222, 219, 173])\n</code>\n</pre>\n", "senID": 3}]]