[[{"text": ["Did you mean:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n int(not(x))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Assuming that any non-zero integer value is true and 0 is false you'll always get integer 0 or 1 as a result."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n int(not x)\n</code>\n</pre>\n", "senID": 1}, {"text": ["to convert the boolean to 0 or 1."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you are looking for Bitwise Not, then ~ is what you are looking for.", "However, it works in the two's complement form."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "~", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This will raise a KeyError if x is not in (0,1)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def not_(x):\n    return {1:0,0:1}[x]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The tuple version would also accept -1 if you don't add a check for it, but is probably faster"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def not_(x):\n    return (1,0)[x]\n\n$ python -m timeit \"(1,0)[0]\"\n10000000 loops, best of 3: 0.0629 usec per loop\n$ python -m timeit \"(1,0)[1]\"\n10000000 loops, best of 3: 0.0646 usec per loop\n\n$ python -m timeit \"1^1\"\n10000000 loops, best of 3: 0.063 usec per loop\n$ python -m timeit \"1^0\"\n10000000 loops, best of 3: 0.0638 usec per loop\n\n$ python -m timeit \"int(not(0))\"\n1000000 loops, best of 3: 0.354 usec per loop\n$ python -m timeit \"int(not(1))\"\n1000000 loops, best of 3: 0.354 usec per loop\n\n$ python -m timeit \"{1:0,0:1}[0]\"\n1000000 loops, best of 3: 0.446 usec per loop\n$ python -m timeit \"{1:0,0:1}[1]\"\n1000000 loops, best of 3: 0.443 usec per loop\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You can use not but then convert result to integer."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "not", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n int(False)\n0\nint(True)\n1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think Your approach is very good for two reasons:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I assume that there cannot be such operator defined on the integers, because of the following problem: what to return if given value is not 0 or 1?", "Throw exception?", "Assume positive integers to mean 1?", "But negative integers?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Your approach defines concrete behaviour - accept only 0 or 1."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["So what you expect is to get 1 when input is 0, and 0 and when input is 1?", "Then XOR is your friend, you need to XOR your value with 1:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In [15]: negate = lambda x: x^1\n\nIn [16]: negate(0)\nOut[16]: 1\n\nIn [17]: negate(1)\nOut[17]: 0\n</code>\n</pre>\n", "senID": 1}]]