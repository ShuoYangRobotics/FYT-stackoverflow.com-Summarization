[[{"text": ["So here's my best shot at interpreting the data you're giving...:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import datetime\nimport struct\n\nclass Printable(object):\n  specials = ()\n  def __str__(self):\n    resultlines = []\n    for pair in self.__dict__.items():\n      if pair[0] in self.specials: continue\n      resultlines.append('%10s %s' % pair)\n    return '\\n'.join(resultlines)\n\nhead_fmt = '&gt;IH6sBH'\nhead_struct = struct.Struct(head_fmt)\nclass Header(Printable):\n  specials = ('bars',)\n  def __init__(self, symbol_count, symbol_length,\n               symbol, error_code, bar_count):\n    self.__dict__.update(locals())\n    self.bars = []\n    del self.self\n\nbar_fmt = '&gt;5fQ'\nbar_struct = struct.Struct(bar_fmt)\nclass Bar(Printable):\n  specials = ('header',)\n  def __init__(self, header, close, high, low,\n               open, volume, timestamp):\n    self.__dict__.update(locals())\n    self.header.bars.append(self)\n    del self.self\n    self.timestamp /= 1000.0\n    self.timestamp = datetime.date.fromtimestamp(self.timestamp)\n\ndef showdata(data):\n  terminator = '\\xff' * 2\n  assert data[-2:] == terminator\n  head_data = head_struct.unpack(data[:head_struct.size])\n  try:\n    assert head_data[4] * bar_struct.size + head_struct.size == \\\n           len(data) - len(terminator)\n  except AssertionError:\n    print 'data length is %d' % len(data)\n    print 'head struct size is %d' % head_struct.size\n    print 'bar struct size is %d' % bar_struct.size\n    print 'number of bars is %d' % head_data[4]\n    print 'head data:', head_data\n    print 'terminator:', terminator\n    print 'so, something is wrong, since',\n    print head_data[4] * bar_struct.size + head_struct.size, '!=',\n    print len(data) - len(terminator)\n    raise\n\n  head = Header(*head_data)\n  for i in range(head.bar_count):\n    bar_substr = data[head_struct.size + i * bar_struct.size:\n                      head_struct.size + (i+1) * bar_struct.size]\n    bar_data = bar_struct.unpack(bar_substr)\n    Bar(head, *bar_data)\n  assert len(head.bars) == head.bar_count\n  print head\n  for i, x in enumerate(head.bars):\n    print 'Bar #%s' % i\n    print x\n\ndatas = '''\n00 00 00 01 00 04 41 4D 54 44 00 00 00 00 02 41\n97 33 33 41 99 5C 29 41 90 3D 71 41 91 D7 0A 47\n0F C6 14 00 00 01 16 6A E0 68 80 41 93 B4 05 41\n97 1E B8 41 90 7A E1 41 96 8F 57 46 E6 2E 80 00\n00 01 16 7A 53 7C 80 FF FF\n'''\n\ndata = ''.join(chr(int(x, 16)) for x in datas.split())\nshowdata(data)\n</code>\n</pre>\n", "senID": 1}, {"text": ["this emits:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n symbol_count 1\n bar_count 2\n    symbol AMTD\nerror_code 0\nsymbol_length 4\nBar #0\n    volume 36806.078125\n timestamp 2007-11-22\n      high 19.1700000763\n       low 18.0300006866\n     close 18.8999996185\n      open 18.2299995422\nBar #1\n    volume 29463.25\n timestamp 2007-11-25\n      high 18.8899993896\n       low 18.0599994659\n     close 18.4629001617\n      open 18.8199901581\n</code>\n</pre>\n", "senID": 3}, {"text": ["...which seems to be pretty close to what you want, net of some output formatting details.", "Hope this helps!-)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You are unpacking big-endian data on a little-endian machine.", "Try this instead:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; struct.unpack('!IH', response.read(6))\n(1L, 4)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This tells unpack to consider the data in network-order (big-endian).", "Also, the values of counts and lengths can not be negative, so you should should use the unsigned variants in your format string."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Take a look at the struct.unpack in the struct module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "struct.unpack", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/struct.html?#struct.unpack"}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; data\n'\\x00\\x00\\x00\\x01\\x00\\x04AMTD\\x00\\x00\\x00\\x00\\x02A\\x9733A\\x99\\\\)A\\x90=qA\\x91\\xd7\\nG\\x0f\\xc6\\x14\\x00\\x00\\x01\\x16j\\xe0h\\x80A\\x93\\xb4\\x05A\\x97\\x1e\\xb8A\\x90z\\xe1A\\x96\\x8fWF\\xe6.\\x80\\x00\\x00\\x01\\x16zS|\\x80\\xff\\xff'\n&gt;&gt;&gt; from struct import unpack, calcsize\n&gt;&gt;&gt; scount, slength = unpack(\"!IH\", data[:6])\n&gt;&gt;&gt; assert scount == 1\n&gt;&gt;&gt; symbol, error_code = unpack(\"!%dsb\" % slength, data[6:6+slength+1])\n&gt;&gt;&gt; assert error_code == 0\n&gt;&gt;&gt; symbol\n'AMTD'\n&gt;&gt;&gt; bar_count = unpack(\"!I\", data[6+slength+1:6+slength+1+4])\n&gt;&gt;&gt; bar_count\n(2,)\n&gt;&gt;&gt; bar_format = \"!5fQ\"                                                         \n&gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; Bar = namedtuple(\"Bar\", \"Close High Low Open Volume Timestamp\")             \n&gt;&gt;&gt; b = Bar(*unpack(bar_format, data[6+slength+1+4:6+slength+1+4+calcsize(bar_format)]))\n&gt;&gt;&gt; b\nBar(Close=18.899999618530273, High=19.170000076293945, Low=18.030000686645508, Open=18.229999542236328, Volume=36806.078125, Timestamp=1195794000000L)\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; time.ctime(b.Timestamp//1000)\n'Fri Nov 23 08:00:00 2007'\n&gt;&gt;&gt; int(b.Volume*100 + 0.5)\n3680608\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Use pack/unpack functions from \"struct\" package.", "More info here http://docs.python.org/library/struct.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/struct.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/struct.html"}]}, {"text": ["Bye!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["As it was already mentioned, struct is the module you need to use."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "struct", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Please read its documentation to learn about byte ordering, etc."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In your example you need to do the following (as your data is big-endian and unsigned):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import struct\n&gt;&gt;&gt; x = '\\x00\\x00\\x00\\x01\\x00\\x04'\n&gt;&gt;&gt; struct.unpack('&gt;IH', x)\n(1, 4)\n</code>\n</pre>\n", "senID": 3}]]