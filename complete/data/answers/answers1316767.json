[[{"text": ["Unfortunately (depending on your version and release of Python) some types of objects use \"free lists\" which are a neat local optimization but may cause memory fragmentation, specifically by making more an more memory \"earmarked\" for only objects of a certain type and thereby unavailable to the \"general fund\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The only really reliable way to ensure that a large but temporary use of memory DOES return all resources to the system when it's done, is to have that use happen in a subprocess, which does the memory-hungry work then terminates.", "Under such conditions, the operating system WILL do its job, and gladly recycle all the resources the subprocess may have gobbled up.", "Fortunately, the multiprocessing module makes this kind of operation (which used to be rather a pain) not too bad in modern versions of Python."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "multiprocessing", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["In your use case, it seems that the best way for the subprocesses to accumulate some results and yet ensure those results are available to the main process is to use semi-temporary files (by semi-temporary I mean, NOT the kind of files that automatically go away when closed, just ordinary files that you explicitly delete when you're all done with them)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["According to http://docs.python.org/library/gc.html you can force the Garbage Collector to release unreferenced memory with gc.collect()"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/gc.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/gc.html"}, {"text": "gc.collect()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You can't explicitly free memory.", "What you need to do is to make sure you don't keep references to objects.", "They will then be garbage collected, freeing the memory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In your case, when you need large lists, you typically need to reorganize the code, typically using generators/iterators instead.", "That way you don't need to have the large lists in memory at all."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://www.prasannatech.net/2009/07/introduction-python-generators.html"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.prasannatech.net/2009/07/introduction-python-generators.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.prasannatech.net/2009/07/introduction-python-generators.html"}]}], [{"text": ["The del statement might be of use, but IIRC it isn't guaranteed to free the memory.", "The docs are here ... and a why it isn't released is here.  "], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "del", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "it isn't guaranteed to free the memory", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "docs are here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/simple%5Fstmts.html"}, {"href": "http://effbot.org/pyfaq/why-doesnt-python-release-the-memory-when-i-delete-a-large-object.htm", "text": "why it isn't released is here", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["I have heard people on Linux and Unix-type systems forking a python process to do some work, getting results and then killing it. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This article has notes on the Python garbage collector, but I think lack of memory control is the downside to managed memory"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "This article", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://evanjones.ca/python-memory.html"}, {"text": "lack of memory control is the downside to managed memory", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["Lists of numbers are much less memory-efficient than the format used by the standard array module or the third-party Numpy module.", "You would save memory by putting your vertices in a Numpy 3xN array and your triangles in an N-element array."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Python is garbage-collected, so if you reduce the size of your list, it will reclaim memory.", "You can also use the \"del\" statement to get rid of a variable completely:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n biglist = [blah,blah,blah]\n#...\ndel biglist\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you don't care about vertex reuse, you could have two output files--one for vertices and one for triangles.", "Then append the triangle file to the vertex file when you are done."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Others have posted some ways that you might be able to \"coax\" the Python interpreter into freeing the memory (or otherwise avoid having memory problems).", "Chances are you should try their ideas out first.", "However, I feel it important to give you a direct answer to your question.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There isn't really any way to directly tell Python to free memory.", "The fact of that matter is that if you want that low a level of control, you're going to have to write an extension in C or C++."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["That said, there are some tools to help with this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["cython"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}, {"text": ["swig"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}, {"text": ["boost python"], "childNum": 0, "tag": "a", "senID": 5, "childList": []}]}], [{"text": ["Gee - this is not really an answer - I am by no means a mathematician."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The only reason I write is that nobody else did ;-)  Well in fact they just did while I was writing."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I think millions of objects is probably not so good - maybe better to have just a few and then put the hard cash (the numbers) into lists."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I believe NumPy should be good at number crushing, but I am by no means a mathematician!"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "NumPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/NumPy"}]}]]