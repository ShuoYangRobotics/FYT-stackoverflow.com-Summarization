[[{"text": ["On POSIX systems you can use inet_pton and inet_ntop in combination to do canonicalization.", "You will still have to do your own CIDR parsing.", "Fortunately, I believe the only valid CIDR syntax for IPv6 is the /number_of_bits notation, so that's fairly easy."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "inet_pton", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "inet_ntop", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The other issue you will run into is the lack of support for interface specifications.", "For link-local addresses, you will see things like %eth0 on the end to specify what link they are local too.", "getaddrinfo will parse that but inet_pton won't."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "%eth0", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "getaddrinfo", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "inet_pton", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["One strategy you could go for is using getaddrinfo to parse and inet_ntop to canonicalize."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "getaddrinfo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "inet_ntop", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["getaddrinfo is available for Windows.", "inet_pton and inet_ntop aren't.", "Fortunately, it isn't too hard to write code to produce a canonical form IPv6 address.", "It will require two passes though because the rule for 0 compression is the biggest string of 0s that occurs first.", "Also IPv4 form (i.e.", "::127.0.0.1) is only used for ::IPv4 or ::ffff:IPv4."], "childNum": 6, "tag": "p", "senID": 3, "childList": [{"text": "getaddrinfo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "inet_pton", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "inet_ntop", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "::127.0.0.1", "childNum": 0, "tag": "code", "pos": 5, "childList": []}, {"text": "::IPv4", "childNum": 0, "tag": "code", "childList": []}, {"text": "::ffff:IPv4", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I have no Windows machine to test with, but from the documentation it appears that Python on Windows supports inet_pton and inet_ntop in its socket module."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "inet_pton", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "inet_ntop", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Writing your own routine for producing a canonical form might not be a bad idea, since even if your canonical form isn't the same as everybody else's, as long as it's valid other people can parse it.", "But I would under no circumstances write a routine of your own to parse IPv6 addresses."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "parse", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["My advice above is good for Python, C, and C++.", "I know little or nothing about how to solve this problem in Java or Javascript."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["EDIT: I have been examining getaddrinfo and its counterpart, getnameinfo.", "These are in almost all ways better than inet_pton and inet_ntop.", "They are thread safe, and you can pass them options (AI_NUMERICHOST in getaddrinfo's case, and NI_NUMERCHOST in getnameinfo's case) to keep them from doing any kind of DNS queries.", "Their interface is a little complex and reminds me of an ugly Windows interface in some respects, but it's fairly easy to figure out what options to pass to get what you want.", "I heartily recommend them both."], "childNum": 7, "tag": "p", "senID": 7, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "inet_pton", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "inet_ntop", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "AI_NUMERICHOST", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "getaddrinfo", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "NI_NUMERCHOST", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "getnameinfo", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["In Java, You could use "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n InetAddress.getByName(IP)\n</code>\n</pre>\n", "senID": 1}, {"text": ["and then check for exceptions thrown by this for validating IPv6 addresses"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You could also use Sun Propreitary API if thats oK to you.", "THis will not perform a DNS lookup.", "( They might change it/remove it without notice since its their propreitary API.This is a warning that will come when compiling a code using this )"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n boolean sun.net.util.IPAddressUtil.isIPv6LiteralAddress(String IP)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I wrote javascript-ipv6 for this very purpose.", "It currently powers v6decode.com."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "javascript-ipv6", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://github.com/beaugunderson/javascript-ipv6"}, {"text": "v6decode.com", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.v6decode.com/"}]}, {"text": ["Here's a short example of the API:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n var address = new v6.Address(\"::ffff:7b2d:4359/64\");\n\nif (address.isValid()) {\n   // Do something if the address is valid\n}\n\nconsole.log(address.correctForm());         // \"::ffff:7b2d:4359\"\nconsole.log(address.canonicalForm());       // \"0000:0000:0000:0000:0000:ffff:7b2d:4359\"\nconsole.log(address.v4Form());              // \"::ffff:123.45.67.89\"\nconsole.log(address.subnetMask);            // \"64\"\nconsole.log(address.possibleAddresses(96)); // \"4,294,967,296\"\n</code>\n</pre>\n", "senID": 2}], [{"text": ["From what I can gather, you should use getaddrinfo() on systems that have it, i.e.", "Linux and POSIX places.", "There should be no need to write your own low-level parser."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "getaddrinfo()", "childNum": 1, "tag": "code", "pos": 0, "childList": [{"text": "getaddrinfo()", "tag": "a"}]}, {"text": "getaddrinfo()", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://linux.die.net/man/3/getaddrinfo"}]}, {"text": ["Windows also provides getaddrinfo(), on XP and later."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "also provides", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://msdn.microsoft.com/en-us/library/ms738520%28VS.85%29.aspx"}, {"text": "getaddrinfo()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["For Python, the best solution might be IPy (http://pypi.python.org/pypi/IPy/0.51)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://pypi.python.org/pypi/IPy/0.51", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/IPy/0.51"}]}], [{"text": ["getaddrinfo already returns the shortest textual form, so if you have the longer form you can canonicalize by running through getaddrinfo again.", "Example Python,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys, socket;\nresult = socket.getaddrinfo('0:0::0:1', None);\nprint \"family:%i socktype:%i proto:%i canonname:%s sockaddr:%s\"%result[0];\n</code>\n</pre>\n", "senID": 1}, {"text": ["Outputs the following,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n family:10 socktype:1 proto:6 canonname: sockaddr:('::1', 0, 0, 0)\n</code>\n</pre>\n", "senID": 3}, {"text": ["IPv6 CIDR blocks don't appear to be well documented or defined so I wrote my own inet6_network implementation to handle that (C99)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "inet6_network implementation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/openpgm/source/browse/trunk/openpgm/pgm/inet_network.c"}]}], [{"text": ["I use a regular expression when os support may not be available - RE is available in most languages, including C/C++/Java/Python/Perl/bash/....", "The following python code builds the RE at startup, the resulting RE source is a humdinger - but once compiled by the re engine is as fast as native code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n PAT_IP4 = r'\\.'.join([r'(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])']*4)\nRE_IP4 = re.compile(PAT_IP4+'$')\nRE_IP6 = re.compile(                 '(?:%(hex4)s:){6}%(ls32)s$'\n               '|::(?:%(hex4)s:){5}%(ls32)s$'\n              '|(?:%(hex4)s)?::(?:%(hex4)s:){4}%(ls32)s$'\n'|(?:(?:%(hex4)s:){0,1}%(hex4)s)?::(?:%(hex4)s:){3}%(ls32)s$'\n'|(?:(?:%(hex4)s:){0,2}%(hex4)s)?::(?:%(hex4)s:){2}%(ls32)s$'\n'|(?:(?:%(hex4)s:){0,3}%(hex4)s)?::%(hex4)s:%(ls32)s$'\n'|(?:(?:%(hex4)s:){0,4}%(hex4)s)?::%(ls32)s$'\n'|(?:(?:%(hex4)s:){0,5}%(hex4)s)?::%(hex4)s$'\n'|(?:(?:%(hex4)s:){0,6}%(hex4)s)?::$'\n  % {\n'ls32': r'(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|%s)'%PAT_IP4,\n'hex4': r'[0-9a-f]{1,4}'\n}, re.IGNORECASE)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It's too bad Python 3.1 lost the ipaddr lib."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's still available as a third-party library: py-ipaddr available on PyPI."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "py-ipaddr", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/ipaddr-py/"}, {"href": "http://pypi.python.org/pypi/ipaddr", "text": "PyPI", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Compression"], "childNum": 0, "tag": "h2", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; ipaddr.IPv6Address('0:0::0:1').compressed\n'::1'\n</code>\n</pre>\n", "senID": 3}, {"text": ["IPv4 mapping"], "childNum": 0, "tag": "h2", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; ipaddr.IPv6Address('::ffff:123.45.67.89').ipv4_mapped\nIPv4Address('123.45.67.89')\n</code>\n</pre>\n", "senID": 5}, {"text": ["CIDR"], "childNum": 0, "tag": "h2", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; ipaddr.IPv6Network('::ffff:123.45.67.89/128')\nIPv6Network('::ffff:7b2d:4359/128')\n</code>\n</pre>\n", "senID": 7}]]