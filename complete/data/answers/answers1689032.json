[[{"code": "<pre>\n<code>\n def coins(num):\n    lst = [random.randrange(2) for i in range(num)]\n    lst = [(i, len(list(j))) for i, j in itertools.groupby(lst)]\n    tails = max(j for i, j in lst if i)\n    heads = max(j for i, j in lst if not i)\n    return {1: tails, 0: heads}\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n import collections, itertools, random\n\ndef makesequence(choices=2, length=200):\n  return [random.randrange(choices) for _ in itertools.repeat(None, length)]\n\ndef runlengths(sequence):\n  runlength_by_item = collections.defaultdict(set)\n  for key, group in itertools.groupby(sequence):\n    runlength_by_item[key].add(sum(1 for _ in group))\n  return dict((k, max(v)) for k, v in runlength_by_item.items())\n</code>\n</pre>\n", "senID": 0}, {"text": ["As you'll notice, this is much more \"decoupled\" -- runlengths is a completely general way to determine the maximal run-lengths of different hashable items in any iterable (highly reusable if you need such run-lengths in a variety of different contexts), just as makesequence is a completely general way to make a list of random numbers given list length and number of choices for each random number.", "Putting these two together may not offer an optimal point-solution to a given, highly specific problem, but it will come close, and building up your little library of reusable \"building blocks\" will have much higher longer-term returns than just solving each specific problem by entirely dedicated code."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "runlengths", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "makesequence", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["You can use itertools, which is a much more Pythonic way to do this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def toss(n):\n    rolls = [random.randrange(2) for i in xrange(n)]\n    maximums = [0, 0]\n    for which, grp in itertools.groupby(rolls):\n        maximums[which] = max(len(list(grp)), maximums[which])\n\n    print \"Longest sequence of heads %d, tails %d\" % tuple(maximums)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Another inefficient solution :-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random, re\ns = ''.join(str(random.randrange(2)) for c in range(10))\nprint s\nprint max(re.findall(r'0+', s))\nprint max(re.findall(r'1+', s))\n\n&gt;&gt;&gt; \n0011100100\n00\n111\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; def toss(count):\n        result = []\n        for i in range(count):\n            result.append(\"HT\"[random.randrange(0, 2)])\n        return ''.join(result)\n\n&gt;&gt;&gt; s = toss(200)\n&gt;&gt;&gt; h_max = max(len(x) for x in s.split(\"T\"))\n&gt;&gt;&gt; t_max = max(len(x) for x in s.split(\"H\"))\n&gt;&gt;&gt; print h_max, t_max\n4 6\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This isn't really pythonic so much as tortured, but here's a short version (with meaningless 1-character variable names, no less!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random\nx = ''.join([chr(random.randrange(2)) for i in range(200)])\nprint max([len(s) for s in x.split(chr(0)) + x.split(chr(1))])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It is probably an axiom that any code can be made more succinct.", "Yours looks perfectly pythonic, though."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Actually, on reflection perhaps there is no succinctness axiom like that.", "If succinct means \"marked by compact precise expression without wasted words,\" and if by \"words\" we mean words of code and not of memory, then a single word program cannot be made more succinct (unless, perhaps, it is the \"exit\" program)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "succinct", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.merriam-webster.com/dictionary/succinct"}]}, {"text": ["If pythonic means \"of extraordinary size and power\", then it seems antagonistic to succinctness unless we restrict our definition to power only.", "I'm not convinced your program resembles a prophetic oracle at all, although you might implement it as an ascii portrait of a particular prophetic oracle.", "It doesn't look like a snake, so there's room for improvement there too."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "pythonic", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.thefreedictionary.com/pythonic"}]}, {"code": "<pre>\n<code>\n import random\n\ndef toss(n):\n    '''\n     ___     ____________\n&lt;&lt;&lt;((__O\\   (__&lt;&gt;___&lt;&gt;__ \\   ____\n       \\ \\_(__&lt;&gt;___&lt;&gt;__)\\O\\_/O___&gt;-&lt;  hiss\n        \\O__&lt;&gt;___&lt;&gt;___&lt;&gt;)\\___/\n\n    '''\n    count = [0,0]\n    longest = [0,0]\n    for i in xrange(n):\n        coinface = random.randrange(2)\n        count[coinface] += 1\n        count[not coinface] = 0\n\n        if count[coinface] &gt; longest[coinface]:\n            longest[coinface] = count[coinface]\n        #print coinface, count, longest\n\n    print \"longest sequence heads %d, tails %d\" %tuple(longest)\n\nif __name__ == '__main__':\n    toss(200)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Nifty, huh?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n import random, itertools\n\ndef toss(n):\n    faces = (random.randrange(2) for i in range(n))\n    longest = [0, 0]\n    for face, seq in itertools.groupby(faces):\n        longest[face] = max(longest[face], len(list(seq)))\n    print \"longest sequence heads %d, tails %d\" % tuple(longest)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["String scanning algorithm"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["If you are looking for a fast algorithm, then you can use the algorithm I developed recently for an interview question that asked for the longest string of consecutive letters in a string.", "See blog entry here."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "See blog entry here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.iwebthereforeiam.com/iwebthereforeiam/2009/11/interview-question-part-ii-longest-sequence-in-string.html"}]}, {"code": "<pre>\n<code>\n def search_longest_substring(s):\n    \"\"\"\n    &gt;&gt;&gt; search_longest_substring('AABBBBCBBBBACCDDDDDDAAABBBBCBBBBACCDDDDDDDAAABBBBCBBBBACCDDDDDDA')\n    (7, 'D')\n    \"\"\"\n    def find_left(s, midc, mid, left):\n        for j in range(mid-1, left-1, -1):\n            if s[j] != midc:\n                return j + 1\n        return left\n    def find_right(s, midc, mid, right):\n        for k in range(mid+1, right):\n            if s[k] != midc:\n                return k\n        return right\n    i, longest = 0, (0, '')\n    while i &lt; len(s):\n        c = s[i]\n        j = find_left(s, c, i, i-longest[0])\n        k = find_right(s, c, i, len(s))\n        if k-j &gt; longest[0]:\n            longest = (k-j, c)\n        i = k + longest[0]\n    return longest\n\nif __name__ == '__main__':\n    import random\n    heads_or_tails = \"\".join([\"HT\"[random.randrange(0, 2)] for _ in range(20)])\n    print search_longest_substring(heads_or_tails)\n    print heads_or_tails\n</code>\n</pre>\n", "senID": 2}, {"text": ["This algorithm is O(n) in worst case (all coin flips are identical) or O(n/m) in average case (where m is the length of the longest match).", "Feel free to correct me on this."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The code is not especially pythonic (i.e.", "it does not use list comprehensions or itertools or other stuff).", "It's in python and it's a good algorithm."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Micro-optimizations"], "childNum": 0, "tag": "h2", "senID": 5, "childList": []}, {"text": ["For the micro-optimization crowd, here are changes that make this really scream in python 2.6 on a Windows Vista laptop:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def find_left(s, midc, mid, left):\n    j = mid - 1\n    while j &gt;= 0:\n        if s[j] != midc:\n            return j + 1\n        j -=  1\n    return left\ndef find_right(s, midc, mid, right):\n    k = mid+1\n    while k &lt; right:\n        if s[k] != midc:\n            return k\n        k += 1\n    return right\n</code>\n</pre>\n", "senID": 7}, {"text": ["Timing results for 1000 iterations with timeit:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "timeit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n range: 2.670\nxrange: 0.3268\nwhile-loop: 0.255\n</code>\n</pre>\n", "senID": 9}, {"text": ["Adding psyco import to the file:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "psyco", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n try:\n    import psyco\n    psyco.full()\nexcept ImportError:\n    pass\n</code>\n</pre>\n", "senID": 11}, {"text": ["0.011 on 1000 iterations with psyco and while-loop.", "So with judicious micros-optimizations and importing psyco, the code runs 250-ish times faster."], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "psyco", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "psyco", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]