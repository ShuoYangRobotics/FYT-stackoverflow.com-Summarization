[[{"text": ["You can use setattr (be careful though: not every string is a valid attribute name!", "):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "setattr", "tag": "a", "pos": 0, "childList": [{"text": "setattr", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/functions.html#setattr"}, {"text": "setattr", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class AllMyFields:\n...     def __init__(self, dictionary):\n...         for k, v in dictionary.items():\n...             setattr(self, k, v)\n... \n&gt;&gt;&gt; o = AllMyFields({'a': 1, 'b': 2})\n&gt;&gt;&gt; o.a\n1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: let me explain the difference between the above code and SilentGhost's answer.", "The above code snippet creates a class of which instance attributes are based on a given dictionary.", "SilentGhost's code creates a class whose class attributes are based on a given dictionary."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "SilentGhost's answer", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1639174/creating-class-instance-properties-from-a-dictionary-in-python/1639215#1639215"}, {"text": "instance attributes", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "class attributes", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Depending on your specific situation either of these solutions may be more suitable.", "Do you plain to create one or more class instances?", "If the answer is one, you may as well skip object creation entirely and only construct the type (and thus go with SilentGhost's answer)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; q = { 'Field1' : 3000, 'Field2' : 6000, 'RandomField' : 5000 }\n&gt;&gt;&gt; q = type('allMyFields', (object,), q)\n&gt;&gt;&gt; q.Field1\n3000\n</code>\n</pre>\n", "senID": 0}, {"text": ["docs for type explain well what's going here (see use as a constructor)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "type", "tag": "a", "pos": 0, "childList": [{"text": "type", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#type"}, {"text": "type", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["edit: in case you need instance variables, the following also works:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "edit", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = q()             # first instance\n&gt;&gt;&gt; a.Field1\n3000\n&gt;&gt;&gt; a.Field1 = 1\n&gt;&gt;&gt; a.Field1\n1\n&gt;&gt;&gt; q().Field1           # second instance\n3000\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Using named tuples (Python 2.6):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import namedtuple\n\n&gt;&gt;&gt; the_dict = {'Field1': 3, 'Field2': 'b', 'foo': 4.9}\n&gt;&gt;&gt; fields = ' '.join(the_dict.keys())\n&gt;&gt;&gt; AllMyFields = namedtuple('AllMyFields', fields)\n&gt;&gt;&gt; instance = AllMyFields(**the_dict)\n\n&gt;&gt;&gt; print instance.Field1, instance.Field2, instance.foo\n3 b 4.9\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can also use dict.update instead of manually looping over items (and if you're looping, iteritems is better)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "dict.update", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "items", "childNum": 0, "tag": "code", "childList": []}, {"text": "iteritems", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class allMyFields(object):\n    # note: you cannot (and don't have to) use self here\n    Field1 = None\n    Field2 = None\n\n    def __init__(self, dictionary):\n        self.__dict__.update(dictionary)\n\nq = { 'Field1' : 3000, 'Field2' : 6000, 'RandomField' : 5000 }\ninstance = allMyFields(q)\n\nprint instance.Field1      # =&gt; 3000\nprint instance.Field2      # =&gt; 6000\nprint instance.RandomField # =&gt; 5000\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Use setattr for the pretty way.", "The quick-n-dirty way is to update the instance internal dictionary:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class A(object):\n...    pass\n...\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.__dict__.update({\"foo\": 1, \"bar\": 2})\n&gt;&gt;&gt; a.foo\n1\n&gt;&gt;&gt; a.bar\n2\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could make a subclass of dict which allows attribute lookup for keys:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class AttributeDict(dict):\n    def __getattr__(self, name):\n        return self[name]\n\nq = AttributeDict({ 'Field1' : 3000, 'Field2' : 6000, 'RandomField' : 5000 })\nprint q.Field1              \nprint q.Field2              \nprint q.RandomField\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you try to look up an attribute that dict already has (say keys or get), you'll get that dict class attribute (a method).", "If the key you ask for doesn't exist on the dict class, then the __getattr__ method will get called and will do your key lookup.  "], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "keys", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "get", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "__getattr__", "childNum": 0, "tag": "code", "childList": []}]}]]