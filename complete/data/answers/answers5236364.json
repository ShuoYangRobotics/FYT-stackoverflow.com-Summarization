[[{"text": ["As Ken said, no, it can't, but with 2.6's multiprocessing module, it's pretty easy to parallelize computations."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "multiprocessing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/multiprocessing.html"}]}, {"code": "<pre>\n<code>\n import multiprocessing\n\ntry:\n    cpus = multiprocessing.cpu_count()\nexcept NotImplementedError:\n    cpus = 2   # arbitrary default\n\n\ndef square(n):\n    return n * n\n\npool = multiprocessing.Pool(processes=cpus)\nprint pool.map(square, xrange(1000))\n</code>\n</pre>\n", "senID": 1}, {"text": ["There are also examples in the documentation that shows how to do this using Managers, which should allow for distributed computations as well. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/multiprocessing.html#examples"}]}], [{"text": ["No, because list comprehension itself is a sort of a C-optimized macro.", "If you pull it out and parallelize it, then it's not a list comprehension, it's just a good old fashioned MapReduce."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "MapReduce", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/MapReduce"}]}, {"text": ["But you can easily parallelize your example.", "Here's a good tutorial on using MapReduce with Python's parallelization library:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://mikecvet.wordpress.com/2010/07/02/parallel-mapreduce-in-python/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://mikecvet.wordpress.com/2010/07/02/parallel-mapreduce-in-python/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mikecvet.wordpress.com/2010/07/02/parallel-mapreduce-in-python/"}]}], [{"text": ["Hmmm..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Using the futures.", "{Thread,Process}PoolExecutor.map(func, *iterables, timeout=None) and futures.as_completed(future_instances, timeout=None) functions from the new 3.2 concurrent.futures package couldn't help ?"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "futures.{Thread,Process}PoolExecutor.map(func, *iterables, timeout=None)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "futures.as_completed(future_instances, timeout=None)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://docs.python.org/py3k/library/concurrent.futures.html", "text": "concurrent.futures", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["It's also available as a 2.6+ backport."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "backport", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/futures/"}]}, {"text": ["Regards, Georges"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["(possibly off-topic)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "(possibly off-topic)", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["IMHO, effective automatic parallisation of list comprehension would be impossible without additional information (such as those provided using directives in OpenMP), or limiting it to expressions that involve only built-in types/methods."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "effective", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Unless there is a guarantee that the processing done on each list item has no side effects, there is a possibility that the results will be invalid (or at least different) if done out of order."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # Artificial example\ncounter = 0\n\ndef g(x): # func with side-effect\n    global counter\n    counter = counter + 1\n    return x + counter\n\nvals = [g(i) for i in range(100)] # diff result when not done in order\n</code>\n</pre>\n", "senID": 3}, {"text": ["There is also the issue of task distribution.", "How should the problem space be decomposed? "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If the processing of each element forms a task (~ task farm), then when there are many elements each involving trivial calculation, the overheads of managing the tasks will swamps out the performance gains of parallelisation. "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["One could also take the data decomposition approach where the problem space is divided equally among the available processes. "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["The fact that list comprehension also works with generators makes this slightly tricky, however this is probably not a show stopper if the overheads of pre-iterating it is acceptable.", "Of course, there is also a possibility of generators with side-effects which can change the outcome if subsequent items are prematurely iterated.", "Very unlikely, but possible."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["A bigger concern would be load imbalance across processes.", "There is no guarantee that each element would take the same amount of time to process, so statically partitioned data may result in one process doing most of the work while the idle your time away. "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Breaking the list down to smaller chunks and handing them as each child process is available is a good compromise, however, a good selection of chunk size would be application dependent hence not doable without more information from the user."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["As mentioned in several other answers, there are many approaches and parallel computing modules/frameworks to choose from depending on one requirements."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "parallel computing modules/frameworks", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/ParallelProcessing"}]}, {"text": ["Having used only MPI (in C) with no experience using Python for parallel processing, I am not in a position to vouch for any (although, upon a quick scan through,\nmultiprocessing, jug, pp and pyro stand out)."], "childNum": 4, "tag": "p", "senID": 11, "childList": [{"text": "multiprocessing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/multiprocessing.html"}, {"href": "http://luispedro.org/software/jug", "text": "jug", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://www.parallelpython.com/", "text": "pp", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://pyro.sourceforge.net/", "text": "pyro", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["If a requirement is to stick as close as possible to list comprehension, then jug seems to be the closest match.", "From the tutorial, distributing tasks across multiple instances can be as simple as:"], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "jug", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://luispedro.org/software/jug"}, {"text": "tutorial", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://packages.python.org/Jug/tutorial.html#example"}]}, {"code": "<pre>\n<code>\n from jug.task import Task\nfrom yourmodule import process_data\ntasks = [Task(process_data,infile) for infile in glob('*.dat')]\n</code>\n</pre>\n", "senID": 13}, {"text": ["While that does something similar to multiprocessing.Pool.map(), jug can use different backends for synchronising process and storing intermediate results (redis, filesystem, in-memory) which means the processes can span across nodes in a cluster."], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "multiprocessing.Pool.map()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "jug", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["There is a comprehensive list of parallel packages for Python here:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://wiki.python.org/moin/ParallelProcessing"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://wiki.python.org/moin/ParallelProcessing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/ParallelProcessing"}]}, {"text": ["I'm not sure if any handle the splitting of a list comprehension construct directly, but it should be trivial to formulate the same problem in a non-list comprehension way that can be easily forked to a number of different processors.", "I'm not familiar with cloud computing parallelization, but I've had some success with mpi4py on multi-core machines and over clusters.", "The biggest issue that you'll have to think about is whether the communication overhead is going to kill any gains you get from parallelizing the problem. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: The following might also be of interest:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["http://www.mblondel.org/journal/2009/11/27/easy-parallelization-with-data-decomposition/"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://www.mblondel.org/journal/2009/11/27/easy-parallelization-with-data-decomposition/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.mblondel.org/journal/2009/11/27/easy-parallelization-with-data-decomposition/"}]}], [{"text": ["Not within a list comprehension AFAIK."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You could certainly do it with a traditional for loop and the multiprocessing/threading modules."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["For shared-memory parallelism, I recommend joblib:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "joblib", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://packages.python.org/joblib/"}]}, {"code": "<pre>\n<code>\n from joblib import delayed, Parallel\n\ndef square(x): return x*x\nvalues = Parallel(n_jobs=NUM_CPUS)(delayed(square)(x) for x in range(1000))\n</code>\n</pre>\n", "senID": 1}]]