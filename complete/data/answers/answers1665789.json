[[{"text": ["For Test1, you could use .difference - for Test2, you'd need to use .difference() instead."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": ".difference", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".difference()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["As for why you might use it, a potential use would be to replace something that was previously directly stored as a property with a dynamic calculation instead."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For instance, if you used to store property obj.a, but then you expanded your implementation so that it knew instead properties obj.b and obj.c that could be used to calculate a, but could also be used to calculate different things.", "If you still wanted to provide backwards-compat with things that used the previous object form, you could implement obj.a as a property() that calculated a based on b and c and it'd behave to those older code fragments as it previously did, with no other code modification needed."], "childNum": 9, "tag": "p", "senID": 2, "childList": [{"text": "obj.a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "obj.b", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "obj.c", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "obj.a", "childNum": 0, "tag": "code", "childList": []}, {"text": "property()", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["People have given there opinion without analyzing it, it can be better solved by python itself, below is the code to check the difference"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import difflib\nfrom pprint import pprint\n\ns1 = \"\"\"\nclass Test(int):\n    difference=property(lambda self: self.__sub__)\n\"\"\"\n\ns2 = \"\"\"\nclass Test(int):\n    difference=lambda self: self.__sub__\n\"\"\"\n\nd = difflib.Differ()\n\nprint \"and the difference is...\"\nfor c in d.compare(s1, s2):\n    if c[0]  in '+-': print c[1:],\n</code>\n</pre>\n", "senID": 1}, {"text": ["and as expected it says"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n and the difference is...\n p  r  o  p  e  r  t  y  (  )\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Yes, in one case difference is a property.", "If you are asking what a property is, you can see it as a method that gets automatically called."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Yes, in one case difference is a property"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Edit: Ah, I see.", "You are asking why anybody would do exactly the code above.", "It's not, in fact a question about why to make a lambda or a property at all, it's not a question of the differences between the two examples, and not even why you want to make a property out of a lambda."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Your question is \"Why would anybody make a property of a lambda that just returns self.__sub__\"."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "self.__sub__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["And the answer is: One wouldn't."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Let's assume somebody wants to do this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; foo = MyInt(8)\n&gt;&gt;&gt; print foo.difference(7)\n1\n</code>\n</pre>\n", "senID": 4}, {"text": ["So he tries to accomplish it by this class:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class MyInt(int):\n    def difference(self, i):\n        return self - i\n</code>\n</pre>\n", "senID": 6}, {"text": ["But that's two lines, and since he is a Ruby programmer and believes that good code is code that has few lines of code, he changes it to:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n class MyInt(int):\n    difference = int.__sub__\n</code>\n</pre>\n", "senID": 8}, {"text": ["To save one line of code.", "But apparently, things are still too easy.", "He learned in Ruby that a problem is not properly solved unless you use anonymous code blocks, so he will try to use Pythons nearest equivalent, lambdas, for absolutely no reason:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n class MyInt(int):\n    difference=lambda self, i: self - i\n</code>\n</pre>\n", "senID": 10}, {"text": ["All these works.", "But things are still WAY to uncomplicated, so instead he decides to make things more complex, by not doing the calculation, but returning the sub method:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n class MyInt(int):\n    difference=lambda self: self.__sub__\n</code>\n</pre>\n", "senID": 12}, {"text": ["Ah, but that doesn't work, because he needs to call difference to get the sub-method:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; foo = MyInt(8)\n&gt;&gt;&gt; print foo.difference()(7)\n1\n</code>\n</pre>\n", "senID": 14}, {"text": ["So he makes it a property:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n class MyInt(int):\n    difference=property(lambda self: self.__sub__)\n</code>\n</pre>\n", "senID": 16}, {"text": ["There.", "Now he has found the maximum complexity to solve a non-problem."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["But normal people wouldn't do any of these, but do:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; foo = 8\n&gt;&gt;&gt; print foo - 7\n1\n</code>\n</pre>\n", "senID": 19}], [{"text": ["Purpose of property can be"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["1.", "To provide get/set hooks while accessing an attribute\ne.g.", "if you used to have class with attribute a, later on you want to do something else when it is set, you can convert that attribute to property without affecting the interface or how users use your class.", "So in the example below class A and B are exactly same for a user but internally in B you can do many things in get/setX"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class A(object):\n    def __init__(self):\n        self.x = 0\n\na = A()\na.x = 1\n\nclass B(object):\n    def __init__(self):\n        self.x = 0\n\n    def getX(self): return self._x\n    def setX(self, x): self._x = x \n    x = property(getX, setX)\n\nb = B()\nB.x = 1\n</code>\n</pre>\n", "senID": 2}, {"text": ["2.", "As implied in 1, property is a better alternative to get/set calls, so instead of getX, setX user uses less verbose self.x and self.x = 1, though personally I never make a property just for getting or setting a attribute, if need arises it can be done later on as shown in #1/"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["as far as difference in concerned, property provide you with get/set/del for an atribute, but in the example you have given a method(lambda or proper function) can only be used to do one of get/set or del, so you will need three such lambdas differenceSet, differenceGet, differenceDel"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]