[[{"code": "<pre>\n<code>\n li = ['a','b','c']\n\nd = reduce(lambda x, y: {y:x}, reversed(li+['']))\n\nprint(d)\nprint(d['a']['b']['c'])\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This will work."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python2\nfrom __future__ import print_function\n\nx = ['a','b','c']\n\ndef ltod(l):\n    rv = d = {}\n    while l:\n        i = l.pop(0)\n        d[i] = {}\n        d = d[i]\n    return rv\n\nd = ltod(x)\nprint(d)\nprint(d[\"a\"][\"b\"][\"c\"])\nd[\"a\"][\"b\"][\"c\"] = \"text\"\nprint(d[\"a\"][\"b\"][\"c\"])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Outputs:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {'a': {'b': {'c': {}}}}\n{}\ntext\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Find below sample that is not very beautiful but quite simple:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n path_to_data = \"user.name.first_name\"\nkeys = path_to_data.split('.')\nt = []\nfor key in keys[::-1]: # just to iterate in reversed order\n    if not t:\n        t.append({k:{}})\n    else:\n        t[-1] = ({k: t[-1]})\n#t[0] will contain your dictionary\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; x = ['a','b','c']\n&gt;&gt;&gt; y={}\n&gt;&gt;&gt; y[x[-1]]=\"\"\n&gt;&gt;&gt; x.pop(-1)\n'c'\n&gt;&gt;&gt; for i in x[::-1]:\n...     y={i:y}\n...\n&gt;&gt;&gt; y\n{'a': {'b': {'c': ''}}}\n&gt;&gt;&gt; y['a']['b']['c']\n''\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I guess you also want to include a value in the end.", "This works for that too:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def get_value(d, l):\n    if len(l) &gt; 1:\n        return get_value(d[l[0]], l[1:])\n    return d[l[0]]\n\ndef add_keys(d, l, c=None):\n    if len(l) &gt; 1:\n        d[l[0]] = _d = {}\n        d[l[0]] = d.get(l[0], {})\n        add_keys(d[l[0]], l[1:], c)\n    else:\n        d[l[0]] = c\n\ndef main():\n    d = {}\n    l1 = ['a', 'b', 'c', 'd']\n    c1 = 'letters'\n    l2 = [42, \"42\", (42,)]\n    c2 = 42\n    add_keys(d, l1, c1)\n    print d\n    add_keys(d, l2, c2)\n    print d\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n", "senID": 1}, {"text": ["It prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {'a': {'b': {'c': {'d': 'letters'}}}}\n{'a': {'b': {'c': {'d': 'letters'}}}, 42: {'42': {(42,): 42}}}\nletters\n42\n</code>\n</pre>\n", "senID": 3}, {"text": ["So it surely works.", "Recursion for the win."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["A general solution would be to use collections.defaultdict to create a nested dictionary.", "Then override __setitem__ for whatever behavior you'd like.", "This example will do the string parsing as well."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "collections.defaultdict", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html#defaultdict-objects"}]}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\nclass nesteddict(defaultdict):\n    def __init__(self):\n        defaultdict.__init__(self, nesteddict)\n    def __setitem__(self, key, value):\n        keys = key.split('.')\n        for key in keys[:-1]:\n            self = self[key]\n        defaultdict.__setitem__(self, keys[-1], value)\n\nnd = nesteddict()\nnd['a.b.c'] = 'lolcat'\nassert nd['a']['b']['c'] == 'lolcat'\n</code>\n</pre>\n", "senID": 1}]]