[[{"text": ["My attempt using the ast module:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ast", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/release/3.1.3/library/ast.html"}]}, {"code": "<pre>\n<code>\n import ast\n\n# which syntax elements are allowed at module level?\nwhitelist = [\n  # docstring\n  lambda x: isinstance(x, ast.Expr) \\\n             and isinstance(x.value, ast.Str),\n  # import\n  lambda x: isinstance(x, ast.Import),\n  # class\n  lambda x: isinstance(x, ast.ClassDef),\n  # function\n  lambda x: isinstance(x, ast.FunctionDef),\n]\n\ndef validate(source, required_functions):\n  tree = ast.parse(source)\n\n  functions = set()\n  required_functions = set(required_functions)\n\n  for item in tree.body:\n    if isinstance(item, ast.FunctionDef):\n      functions.add(item.name)\n      continue\n\n    if all(not checker(item) for checker in whitelist):\n      return False\n\n  # at least the required functions must be there\n  return len(required_functions - functions) == 0\n\n\nif __name__ == \"__main__\":\n  required_funcs = [ \"init\", \"execute\", \"cleanup\" ]\n  with open(\"/tmp/test.py\", \"rb\") as f:\n    print(\"yay!\" if validate(f.read(), required_funcs) else \"d'oh!\")\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'd first of all not require some functions, but a class that conforms to a specified interface, using either the abc module, or zope.interface.", "This forces the maker of the module to supply the functions you want."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "abc", "tag": "a", "pos": 0, "childList": [{"text": "abc", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/abc.html"}, {"text": "abc", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "zope.interface", "tag": "a", "pos": -1, "childList": [{"text": "zope.interface", "tag": "code"}], "childNum": 1, "href": "http://pypi.python.org/pypi/zope.interface/3.8.0"}, {"text": "zope.interface", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Secondly, I would not bother looking for module-level code.", "It's the module-makers problem if he does this.", "It's too much work with no actual benefit."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you are worried about security issues, you need to sandbox the code somehow anyway."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Not sure if you'll consider this elegant, but it is somewhat intelligent in the sense that it recognizes when def init are tokens and not just part of a tricky multi-line string:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "def init", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n '''\ndef init does not define init...\n'''\n</code>\n</pre>\n", "senID": 1}, {"text": ["It will not recognize when init is defined in tricky alternate ways such as"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "init", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n init = lambda ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n codestr='def  i'+'nit ...'\nexec(codestr)\n</code>\n</pre>\n", "senID": 5}, {"text": ["The only way to handle all such cases is to run the code (e.g.", "in a sandbox or by importing) and inspect the result. "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import tokenize\nimport token\nimport io\nimport collections\n\nuserscript = '''\\\ndef init():\n    blah\n\n\"\"\"\ndef execute():\n    more blah\n\"\"\"\n\nyadda\n'''\n\nclass Token(object):\n    def __init__(self, tok):\n        toknum, tokval, (srow, scol), (erow, ecol), line = tok\n        self.toknum = toknum\n        self.tokname = token.tok_name[toknum]\n        self.tokval = tokval\n        self.srow = srow\n        self.scol = scol\n        self.erow = erow\n        self.ecol = ecol\n        self.line = line    \n\nclass Validator(object):\n    def __init__(self, codestr):\n        self.codestr = codestr\n        self.toks = collections.deque(maxlen = 2)\n        self.names = set()\n    def validate(self):\n        tokens = tokenize.generate_tokens(io.StringIO(self.codestr).readline)\n        self.toks.append(Token(next(tokens)))\n        for tok in tokens:\n            self.toks.append(Token(tok))            \n            if (self.toks[0].tokname == 'NAME'     # First token is a name\n                and self.toks[0].scol == 0         # First token starts at col 0\n                and self.toks[0].tokval == 'def'   # First token is 'def'\n                and self.toks[1].tokname == 'NAME' # Next token is a name\n                ):\n                self.names.add(self.toks[1].tokval)\n        delta = set(['init', 'cleanup', 'execute']) - self.names\n        if delta:\n            raise ValueError('{n} not defined'.format(n = ' and '.join(delta)))\n\nv = Validator(userscript)\nv.validate()\n</code>\n</pre>\n", "senID": 7}, {"text": ["yields"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n ValueError: execute and cleanup not defined\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Here's a simpler (and more naive) alternative to the AST approach:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\nfrom imp import find_module, new_module, PY_SOURCE\n\n\nEXPECTED = (\"init\", \"execute\", \"cleanup\")\n\ndef import_script(name):\n    fileobj, path, description = find_module(name)\n\n    if description[2] != PY_SOURCE:\n        raise ImportError(\"no source file found\")\n\n    code = compile(fileobj.read(), path, \"exec\")\n\n    expected = list(EXPECTED)\n    for const in code.co_consts:\n        if isinstance(const, type(code)) and const.co_name in expected:\n            expected.remove(const.co_name)\n    if expected:\n        raise ImportError(\"missing expected function: {}\".format(expected))\n\n    module = new_module(name)\n    exec(code, module.__dict__)\n    sys.modules[name] = module\n    return module\n</code>\n</pre>\n", "senID": 1}, {"text": ["Keep in mind, this is a very direct way of doing it and circumvents extensions to Python's import machinery."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["One very simple solution could be to check the first characters of every line of code: The only permitted should be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": ["def init():"], "childNum": 0, "tag": "code", "senID": 1, "childList": []}, {"text": ["def execute():"], "childNum": 0, "tag": "code", "senID": 2, "childList": []}, {"text": ["def cleanup():"], "childNum": 0, "tag": "code", "senID": 3, "childList": []}, {"text": "lines starting with 4 spaces", "tag": "none", "senID": 4}, {"text": "[optionally]: lines starting with ", "tag": "none", "senID": 5}]}, {"text": ["This is very primitive but it fulfills your requirements..."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Update: After a second though about it I realized that it isn't so easy after all.", "Consider for example this piece of code:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def init():\n    v = \"\"\"abc\ndef\nghi\"\"\"\n    print(v)\n</code>\n</pre>\n", "senID": 8}, {"text": ["This means that you'd need a more complex code parsing algorithm... so forget about my solution..."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["A solution to 1 to 3, ( not the yadda part ) is to hand out \"generic_class.py\" with all the methods that you need.", "So, "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Generic(object):\n\n    def __init__(self):\n        return\n\n    def execute(self):\n        return\n\n    # etc\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can then check for the existence of \"generic\" in what you've imported.", "If it doesn't exist you can ignore it and if it does then you know exactly what's there.", "Anything extra will never be called unless it's called from within one of your pre-defined methods."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]