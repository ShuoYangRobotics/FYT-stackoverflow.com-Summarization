[[{"text": ["The elusive \"Tri-boolean\" value.", "I've seen this before somewhere."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n enum Bool \n{ \n    True, \n    False, \n    FileNotFound \n};\n</code>\n</pre>\n", "senID": 1}, {"text": ["What is Truth?", "- TheDailyWTF"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "What is Truth? - TheDailyWTF", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://thedailywtf.com/Articles/What_Is_Truth_0x3f_.aspx"}]}], [{"text": ["Depending on your language, you may be able to use an enum:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n enum DoohickyState\n{\n    Open,\n    Closed,\n    Running\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["actually you need only two, cause in your case:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n closed = ! open\n</code>\n</pre>\n", "senID": 1}, {"text": ["And this depends if only one of the three or evntually more than one can be valid at once, like open and running together?", "if its only one state allowed at once i would use Enumerations"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Enumerations", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Enumeration"}]}, {"text": ["As this issue is in Python which doesnt support Enums i suggest to take a look at: What&#39;s the best way to implement an &#39;enum&#39; in Python?", "All 1st Four answers are interesting but i prefere the 1st and 3rd ones, the one from Alexandru Nedelcu:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "What&#39;s the best way to implement an &#39;enum&#39; in Python?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/36932/whats-the-best-way-to-implement-an-enum-in-python"}]}, {"code": "<pre>\n<code>\n class State:\n    OPEN=1\n    CLOSED=2\n    RUNNING=3\n</code>\n</pre>\n", "senID": 4}, {"text": ["Or the answer of Mark Harrison like:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n OPEN, CLOSED, RUNNING = range(3)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["The simplest way to handle this in Python is to use string constants.", "We did exactly that when adding inspect.getgeneratorstate() to Python 3.2.", "The possible return values from that function are:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "inspect.getgeneratorstate()", "tag": "a", "pos": 1, "childList": [{"text": "inspect.getgeneratorstate()", "tag": "code"}], "childNum": 1, "href": "http://hg.python.org/cpython/file/default/Lib/inspect.py#l1159"}, {"text": "inspect.getgeneratorstate()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n GEN_CREATED = 'GEN_CREATED'\nGEN_RUNNING = 'GEN_RUNNING'\nGEN_SUSPENDED = 'GEN_SUSPENDED'\nGEN_CLOSED = 'GEN_CLOSED'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Creating a simple class as a namespace for the constants is another common option (but the attributes of that class should still be strings rather than integers)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In Python, there is minimal gain in using integers over strings for your constants.", "You lose a little in comparison speed (but not much, due to hash caching and other string comparison optimisations) and use slightly more memory (but not much, since references are the same size regardless of the type of the target), but vastly simplify debugging (since you don't need to translate integer codes to meaningful state names - you can just display the string values)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["+1 for suggestions you probably want an enum.", "Since python doesn't support them, I'd probably define a class to encapsulate it.", "That way you can enforce rules on update.", "As a minimum that'll give you the same behaviour as an enum.", "If appropriate you can also control legal state changes, e.g. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Widget:\n    def __init__(self, state=\"Closed\"):\n        self.state=state\n\n    def open(self):\n        if self.state == \"Closed\":\n            self.state = \"Open\"\n        elif self.state == \"Open\":\n            pass\n        else:\n            # do whatever if trying to open in \"Running\" state...\n\n    def close(self):\n        # etc.\n\nclass ThingContainingWidget:\n    def __init__(self):\n        self.widget=Widget()\n\n    def doSomethingThatAffectsWidget(self):\n        self.widget.close()\n        # etc.\n</code>\n</pre>\n", "senID": 1}, {"text": ["Depending on the problem, you may need/want to move the state change logic to the enclosing class (e.g.", "if state behaviour is dependent on other attributes of enclosing class too).", "But I'd probably leave the basic validation (ensuring value can only ever be Open/Closed/Running) in the Widget class."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Widget", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Haven't done any django in a while, but can't think of any reason why this wouldn't work."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["hth."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["This is a good place to make use of Python \"properties\" - which allow you to bind get and set methods to object attributes in a transparent way."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That way, your methods can control the behavior you want, and your code just have to set True or False for your states:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Machine(object):\n    def __init__(self):\n        self.open = False\n        self._running = False\n        self._closed = False\n\n    def get_running(self):\n     return self._running\n\n    def set_running(self, val):\n        if not self.open and val:\n            raise ValueError(\"Cannot run if it is closed\")\n        self._running = True\n\n    running = property(get_running, set_running)\n\n    def get_closed(self):\n        return self._closed\n\n    def set_closed(self, val):\n        if val:\n            self.open = False\n            self.running = False\n        self._closed = val\n\n    closed = property(get_closed, set_closed)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Pasting this on the python console allows for a quick test drive:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; m = Machine()\n&gt;&gt;&gt; m.open\nFalse\n&gt;&gt;&gt; m.running\nFalse\n&gt;&gt;&gt; m.running = True\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 12, in set_running\nValueError: Cannot run if it is closed\n&gt;&gt;&gt; m.open = True\n&gt;&gt;&gt; m.running = True\n&gt;&gt;&gt; m.closed\nFalse\n&gt;&gt;&gt; m.closed = True\n&gt;&gt;&gt; m.open, m.running\n(False, True)\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 4}]]