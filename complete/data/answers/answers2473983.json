[[{"text": ["To provide a rough code snippet for people who need to get this done in practice.", "Feel free to improve."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n u, s, v = np.linalg.svd(A)\nrank = np.sum(s &gt; 1e-10)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The answer is no\u2014there is currently no function dedicated to calculating the matrix rank of an array/matrix in scipy.", "Adding one has been discussed before, but if it's going to happen, I don't believe it has yet."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If numpy does not offer a rank facility, why don't you write your own?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["An efficient way to compute the rank is via the Singular Value Decomposition - the rank of the matrix is equal to the number of non-zero singular values."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def rank(A, eps=1e-12):\n    u, s, vh = numpy.linalg.svd(A)\n     return len([x for x in s if abs(x) &gt; eps])\n</code>\n</pre>\n", "senID": 2}, {"text": ["Notice that eps depends in your application - most would agree that 1e-12 corresponds to zero, but you may witness numerical instability even for eps=1e-9."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "eps", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Using your example, the answer is three.", "If you change the second row to [2, 6, 14] (linearly dependent with row one) the answer is two (the \"zero\" eigenvalue is 4.9960E-16)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "[2, 6, 14]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I don't know about Numpy in particular, but that's unlikely to be a built-in operation on a matrix; it involves fairly intensive numerical computations (and associated concerns about floating-point roundoff error and so forth) and threshold selections that may or may not be appropriate in a given context, and algorithm selection is important to computing it accurately and quickly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Things that are built into the basic classes tend to be things that can be performed in a unique and straightforward manner, such as matrix multiplications at the most complex."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The linear algebra functions are generally grouped innumpy.linalg.", "(They're also available from scipy.linalg, which has more functionality.", ") This allows polymorphism: the functions can accept any of the types that SciPy handles."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "linear algebra functions are generally grouped innumpy.linalg", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "numpy.linalg", "tag": "code"}]}, {"text": "numpy.linalg", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "scipy.linalg", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["So, yes, thenumpy.linalg.lstsqfunction does what you're asking.", "Why is that insufficient?"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "thenumpy.linalg.lstsqfunction", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "numpy.linalg.lstsq", "tag": "code"}]}, {"text": "numpy.linalg.lstsq", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Numpy provides numpy.linalg.matrix_rank():"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy.linalg.matrix_rank()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import numpy\n&gt;&gt;&gt; numpy.__version__\n'1.5.1'\n&gt;&gt;&gt; A = numpy.matrix([[1,3,7],[2,8,3],[7,8,1]])\n&gt;&gt;&gt; numpy.linalg.matrix_rank(A)\n3\n</code>\n</pre>\n", "senID": 1}]]