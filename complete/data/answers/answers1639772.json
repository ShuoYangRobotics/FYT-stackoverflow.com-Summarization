[[{"text": ["Not exactly efficient, but if you don't need it for very large lists:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dict(zip(t[::2], t[1::2]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or your version using a generator:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n dict(t[i:i+2] for i in xrange(0, len(t), 2))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Same idea as Luk\u00e1\u0161 Lalinsk\u00fd's answer, different idiom:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Luk\u00e1\u0161 Lalinsk\u00fd's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1639772/converting-a-single-ordered-list-in-python-to-a-dictionary-pythonically/1639789#1639789"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dict(zip(*([iter(t)] * 2)))\n{'a': 2, 'c': 4, 'b': 3}\n</code>\n</pre>\n", "senID": 1}, {"text": ["This uses the dict, zip and iter functions.", "It's advantage over Luk\u00e1\u0161' answer is that it works for any iterable.", "How it works:"], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "dict", "tag": "a", "pos": 0, "childList": [{"text": "dict", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/functions.html#dict"}, {"text": "dict", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "zip", "tag": "a", "pos": -1, "childList": [{"text": "zip", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/functions.html#zip"}, {"text": "zip", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "iter", "tag": "a", "pos": 1, "childList": [{"text": "iter", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/functions.html#iter"}, {"text": "iter", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Guys, guys, use itertools.", "Your low-RAM users will thank you when the lists get large."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import izip, islice\n&gt;&gt;&gt; t = ['a',2,'b',3,'c',4]\n&gt;&gt;&gt; s = dict(izip(islice(t, 0, None, 2), islice(t, 1, None, 2)))\n&gt;&gt;&gt; s\n{'a': 2, 'c': 4, 'b': 3}\n</code>\n</pre>\n", "senID": 1}, {"text": ["It might not look pretty, but it won't make unnecessary in-memory copies."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I'd use itertools, but, if you think that's complicated (as you've hinted in a comment), then maybe:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def twobytwo(t):\n  it = iter(t)\n  for x in it:\n    yield x, next(it)\n\nd = dict(twobytwo(t))\n</code>\n</pre>\n", "senID": 1}, {"text": ["or equivalently, and back to itertools again,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def twobytwo(t):\n  a, b = itertools.tee(iter(t))\n  next(b)\n  return itertools.izip(a, b)\n\nd = dict(twobytwo(t))\n</code>\n</pre>\n", "senID": 3}, {"text": ["or, if you insist on being inline, in a season-appropriate \"trick or treat\" mood:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n d = dict((x, next(it)) for it in (iter(t),) for x in it)\n</code>\n</pre>\n", "senID": 5}, {"text": ["me, I consider this a trick, but some might find it a treat.", "IOW, I find this kind of thing scary, but apparently in the US around this time of the years things are supposed to be;-)."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "supposed", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Basically, the problem boils down to \"how do I walk a list 2 items at a time\", because dict is quite happy to take a sequence of 2-tuples and make it into a dictionary.", "All the solutions I'm showing here ensure only O(1) extra space is taken (beyond the space, obviously O(N), that's needed for the input list and the output dict, of course)."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "O(1)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "O(N)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The suggested approach in the docs (everybody should be familiar with that page, the itertool recipes) is the function pairwise on that page, which is basically the second one I suggested here.", "I do think every site-packages directory should contain an iterutils.py file with those recipes (pity such a file's not already a part of python's stdlib!-)."], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html?highlight=itertools#recipes"}, {"text": "pairwise", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "iterutils.py", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"code": "<pre>\n<code>\n dict(zip(t[::2], t[1::2]))\n</code>\n</pre>\n", "senID": 0}, {"text": ["probably not the most efficient.", "works in python 3; you might need to import zip, in python 2.x"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Using the stream module:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "stream", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/stream/0.8"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from stream import chop\n&gt;&gt;&gt; t = ['a',2,'b',3,'c',4]\n&gt;&gt;&gt; s = t &gt;&gt; chop(2) &gt;&gt; dict\n&gt;&gt;&gt; s\n{'a': 2, 'c': 4, 'b': 3}\n</code>\n</pre>\n", "senID": 1}]]