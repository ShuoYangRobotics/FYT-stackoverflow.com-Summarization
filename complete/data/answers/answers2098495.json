[[{"text": ["The only way to \"have two while loops in parallel\" would be to place them on different threads, but then you need to tackle the synchronization and coordination problems between them since they're reaching into the same object."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I suggest you instead put a time check in the first (and single) loop and perform the increases that you now have in the second loop proportionately to that time-check; not quite satisfactory since the buttonbox call might take an indefinite amount of time to return, but way simpler to arrange, esp.", "for a beginner, than proper threading coordination."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "buttonbox", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "way", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Once you do have the basic logic in place and working, then you can consider threads again (with a periodic timer for what you'd like in the 2nd loop in one thread, the blocking buttonbox call in the main thread [[I think in easygui it has to be]], both feeding events into a Queue.Queue [[intrinsically thread-safe]] with another thread getting them and operating accordingly, i.e.", "most of what you now have in the 1st loop).", "But that's quite an advanced architectural problem, which is why I recommend you don't try to deal w/it right now!-)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "then", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["You should use State Machines for this (see the Apress pygame book - downloads here: http://apress.com/book/downloadfile/3765 ), see chapter 7."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://apress.com/book/downloadfile/3765", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://apress.com/book/downloadfile/3765"}]}, {"text": ["A simplified state machine:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def do_play(pet, time_passed):\n    pet.happiness += time_pass*4.0\n\ndef do_feed(pet, time_passed):\n    pet.hunger -= time_passed*4.0\n\ndef do_sleep(pet, time_passed):\n    pet.tiredness += time_passed*4.0\n    if pet.tiredness &lt;= 0:\n        return 'Waiting'\n\ndef do_waiting(pet, time_passed):\n    pass\n\ndef do_howl(pet, time_passed):\n    print 'Hoooowl'\n\ndef do_beg(pet, time_passed):\n    print \"I'm bored!\"\n\ndef do_dead(pet, time_passed):\n    print '...'\n\nSTATE_TO_FUNC = dict(Waiting=do_waiting,\n                     Sleeping=do_sleep,\n                     Feeding=do_feed,\n                     Playing=do_play,\n                     Howling=do_howl,\n                     Begging=do_beg,\n                     Dead=do_dead\n                     )\n\nclass Pet:\n    def __init__(self):\n        self.state = 'Waiting'\n        self.hunger = 1.0\n        self.tiredness = 1.0\n        self.happiness = 1.0\n\n    def process(self, time_passed):\n        self.hunger +=1*time_passed\n        self.tiredness +=1*time_passed\n        self.happiness -= 1*time_passed\n\n        func = STATE_TO_FUNC[self.state]\n        new_state = func(self, time_passed)\n        if new_state is not None:\n            self.set_state(new_state)\n\n        if self.hunger &gt;10:\n            self.set_state('Dead')\n        elif self.hunger &gt; 5 and not (self.state == 'Feeding'):\n            self.set_state('Howling')\n        elif self.tiredness &gt; 5:\n            self.set_state('Sleeping')\n        elif self.happiness &lt; 0 and not (self.state == 'Playing'):\n            self.set_state('Begging')\n\n    def set_state(self,state):\n        if not self.state == 'Dead':\n            self.state = state\n\nfrom msvcrt import getch\nimport time\npet = Pet()\nwhile True:\n    time0 = time.time()\n    cmd = getch() # what command?\n    pet.process(time.time()-time0)\n    if cmd == 'a':\n        pet.set_state('Feeding')\n    if cmd == 's':\n        pet.set_state('Sleeping')\n    if cmd == 'd':\n        pet.set_state('Playing')\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Essentially to have processing to happen in parallel you have several solutions"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["1- Separate processes (ie: programs) running independently that speak to one another through a specific protocol (eg: Sockets)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["2- Or you can have the one process spawn off multiple threads"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["3- Build an event queue internally and process them one by one"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["That is the general picture."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["As for the specific answer to your question, you said \"the stuff in the first loop to b[e] constantly happening\".", "The reality is you never want this to happen all the time, because all that will do is use up 100% of the CPU and nothing else will ever get done"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The simplest solution is probably number 3."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["The way I would implement it is in my main loop have a thread that goes through an event queue and sets a timer for each event.", "Once all the timers have been sent the main loop then goes to sleep."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["When a timer times out, an other function will then run the corresponding function for the event that triggered that timer."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["In your case, you have two events.", "One for displaying the selection menu (first loop) and the second for changing myPotatoHead.", "The timer associated with the first one, I would set to 0.5sec, making it larger reduces CPU usage but slows down responsivness, increasing it usses up more CPU, for the second event I would set a 20 second timer."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Ofcourse when the timer expires, you would not do while 1 but you will just go through your while loop body once (ie get rid of while)."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "while 1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "while", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["i think they cannot be coupled in to one while loop.", "maybe you need to check the threading or multiprocessing library."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "threading", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "multiprocessing", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["put one of them into a function, the threading.Thread class supports a target attribute:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import threading\nthreading.Thread(target=yourFunc).start()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Will start yourFunc() running in the background."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["There is also a package called SimPy that you could also look at.", "The threading and multiprocessing libraries may also help."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "SimPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://simpy.sourceforge.net/"}, {"text": "threading", "childNum": 0, "tag": "b", "pos": 1, "childList": []}, {"text": "multiprocessing", "childNum": 0, "tag": "b", "childList": []}]}], [{"text": ["Have a look at Threading.Timer. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Threading.Timer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/threading.html#timer-objects"}]}, {"text": ["There is a code recipe here to schedule a function to run every 5 seconds."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "code recipe here to schedule a function to run every 5 seconds", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/496800/"}]}, {"code": "<pre>\n<code>\n import thread\nimport threading\n\nclass Operation(threading._Timer):\n    def __init__(self, *args, **kwargs):\n        threading._Timer.__init__(self, *args, **kwargs)\n        self.setDaemon(True)\n\n    def run(self):\n        while True:\n            self.finished.clear()\n            self.finished.wait(self.interval)\n            if not self.finished.isSet():\n                self.function(*self.args, **self.kwargs)\n            else:\n                return\n            self.finished.set()\n\nclass Manager(object):\n\n    ops = []\n\n    def add_operation(self, operation, interval, args=[], kwargs={}):\n        op = Operation(interval, operation, args, kwargs)\n        self.ops.append(op)\n        thread.start_new_thread(op.run, ())\n\n    def stop(self):\n        for op in self.ops:\n            op.cancel()\n        self._event.set()\n\nif __name__ == '__main__':\n    # Print \"Hello World!\" every 5 seconds\n\n    import time\n\n    def hello():\n        print \"Hello World!\"\n\n    timer = Manager()\n    timer.add_operation(hello, 5)\n\n    while True:\n        time.sleep(.1)\n</code>\n</pre>\n", "senID": 2}]]