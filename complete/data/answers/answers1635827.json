[[{"text": ["You could try to encapsulate this in a struct:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "struct", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n typedef struct s_generator {\n    int current;\n    int (*func)(int);\n} generator;\n\nint next(generator* gen) {\n    int result = gen-&gt;current;\n    gen-&gt;current = (gen-&gt;func)(gen-&gt;current);\n    return result;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you define you multiples with:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n int next_multiple(int current) { return 2 + current; }\ngenerator multiples_of_2 = {0, next_multiple};\n</code>\n</pre>\n", "senID": 3}, {"text": ["You get the next multiple by calling"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n next(&amp;multiples_of_2);\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I found a good article recently on coroutines in C, which describes one method of doing this.", "It's certainly not for the faint of heart."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "coroutines in C", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html"}]}], [{"text": ["The basic approach is to not do it.", "In Python (and C#) the 'yield' method stores local state between calls, whereas in C/C++ and most other languages the local state stored on the stack is not preserved between calls and this is a fundemental implementation difference.", "So in C you'd have to store the state between calls in some variable explicitly - either a global variable or a function parameter to your sequence generator.", "So either:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n int multiples_of_2() {\n   static int i = 0;\n   i += 2;\n   return i;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n int multiples_of_2(int i) {\n   i += 2;\n   return i;\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["depending upon if there's one global sequence or many."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I've quickly considered longjmp and GCC computed gotos and other non-standard things, and I can't say I'd recommend any of them for this!", "In C, do it the C way."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Check out setjmp/longjmp"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "setjmp/longjmp", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Setjmp/longjmp"}]}, {"text": ["(Lua coroutines were implemented that way)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Lua coroutines", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.lua.org/manual/5.1/manual.html#2.11"}]}], [{"text": ["You can pass the argument as a pointer to allow the function to modify it without using the return value:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n void multiples_of_2(int *i)\n{\n    *i += 2;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["And call it:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n int i = 0;\nmultiples_of_2(&amp;i);\n</code>\n</pre>\n", "senID": 3}], [{"text": ["As Will mentioned, languages like python do the job of storing the state of the stack between successive calls of the generator.", "Since C does not have this mechanism, you'll have to do it yourself.", "The \"generic\" way of doing this is not for the faint-hearted, as Greg pointed out.", "The traditional C way of doing this would be for you to define and maintain the state yourself and pass it in and out of your method.", "So:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n struct multiples_of_two_state {\n       int i;\n       /* all the state you need should go in here */\n};\n\nvoid multiples_of_two_init(struct multiples_of_two_state *s) {\n    s-&gt;i = 0;\n}\n\nint multiples_of_two_next(struct multiples_of_two_state *s) {\n    s-&gt;i += 2;\n    return s-&gt;i;\n}\n\n/* Usage */\nstruct multiples_of_two_state s;\nint result;\nmultiples_of_two_init(&amp;s);\nfor (int i=0; i&lt;INFINITY; i++) {\n    result = multiples_of_two_next(&amp;s);\n    printf(\"next is %d\", result);\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The key is keeping the state of the function between calls.", "You have a number of options:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Greg cites an interesting article, above, that presents a way of using static state with syntax similar to the yield statement.", "I liked it academically but probably wouldn't use it because of the reentrancy issue, and because I'm still surprised that the infamous Duffy's Device even compiles ;-). "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In practice, large C programs do want to compute things lazily, e.g.", "a database server may want to satisfy a SELECT ... LIMIT 10 query by wrapping the plain SELECT query inside something that will yield each row until 10 have been returned, rather than computing the whole result and then discarding most of them.", "The most C-like technique for this is explicitly create an object for the state, and to call a function with it for each call.", "For your example, you might see something like:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "SELECT ... LIMIT 10", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "SELECT", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n /* Definitions in a library somewhere. */\ntypedef int M2_STATE;\nM2_STATE m2_new() { return 0; }\nint m2_empty(M2_STATE s) { return s &lt; INT_MAX; }\nint m2_next(M2_STATE s) { int orig_s = s; s = s + 2; return orig_s; }\n\n/* Caller. */\nM2_STATE s;\ns = m2_new();\nwhile (!m2_empty(s))\n{\n    int num = m2_next(s);\n    printf(\"%d\\n\", num);\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["This seems cumbersome for the multiples of two, but it becomes a useful pattern for more complicated generators.", "You can make the state more complicated without having to burden all the code that uses your generator with the details.", "Even better practice is to return an opaque pointer in the new function, and (unless GC is available) provide a function for cleaning up the generator."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "new", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["The big advantage of allocating the state for each new sequence of calls is things like recursive generators.", "For example, a generator that returns all files under a directory, by calling itself on each subdirectory."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n char *walk_next(WALK_STATE *s)\n{\n    if (s-&gt;subgenerator)\n    {\n        if (walk_is_empty(s-&gt;subgenerator))\n        {\n            walk_finish(s-&gt;subgenerator);\n            s-&gt;subgenerator = NULL;\n        }\n        else\n            return walk_next(s-&gt;subgenerator);\n    }\n\n    char *name = readdir(s-&gt;dir);\n    if (is_file(name))\n        return name;\n    else if (is_dir(name))\n    {\n        char subpath[MAX_PATH];\n        strcpy(subpath, s-&gt;path);\n        strcat(subpath, name);\n        s-&gt;subgenerator = walk_new(subpath);\n        return walk_next(s-&gt;subgenerator);\n    }\n    closedir(s-&gt;dir);\n    s-&gt;empty = 1;\n    return NULL;\n}\n</code>\n</pre>\n", "senID": 6}, {"text": ["(You'll have to excuse my misuse of readdir, et al.", "and my pretense that C has idiot-proof string support."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"code": "<pre>\n<code>\n int multiples_of_2() {\n    static int i = 0;\n    i += 2;\n    return i;\n}\n</code>\n</pre>\n", "senID": 0}, {"text": ["The static int i behaves like a global variable but is visible only within the contect of multiples_of_2()."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I have implemented my own lazy eval, with respects to solving the hamming's problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Heres my code for anyone whos interested:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Hamming problem in C.\n\ntypedef struct gen {\n  int tracker;\n  int (*next)(struct gen *g);\n} generator;\n\nint twos_gen(struct gen *g) {\n  g-&gt;tracker = g-&gt;tracker + 2;\n  return g-&gt;tracker;\n}\n\ngenerator* twos_stream() {\n  generator *g = malloc(sizeof(generator));\n  g-&gt;next = twos_gen;\n  g-&gt;tracker = 0;\n  return g;\n}\n\nint threes_gen(struct gen *g) {\n  g-&gt;tracker = g-&gt;tracker + 3;\n  return g-&gt;tracker;\n}\n\ngenerator* threes_stream() {\n  generator *g = malloc(sizeof(generator));\n  g-&gt;next = threes_gen;\n  g-&gt;tracker = 0;\n  return g;\n}\n\nint fives_gen(struct gen *g) {\n  g-&gt;tracker = g-&gt;tracker + 5;\n  return g-&gt;tracker;\n}\n\ngenerator* fives_stream() {\n  generator *g = malloc(sizeof(generator));\n  g-&gt;next = fives_gen;\n  g-&gt;tracker = 0;\n  return g;\n}\n\nint smallest(int a, int b, int c) {\n  if (a &lt; b) {\n    if (c &lt; a) return c;\n    return a;\n  }\n  else {\n    if (c &lt; b) return c;\n    return b;\n  }\n}\n\nint hamming_gen(struct gen *g) {\n  generator* twos = twos_stream();\n  generator* threes = threes_stream();\n  generator* fives = fives_stream();\n\n  int c2 = twos-&gt;next(twos);\n  int c3 = threes-&gt;next(threes);\n  int c5 = fives-&gt;next(fives);\n\n  while (c2 &lt;= g-&gt;tracker) c2 = twos-&gt;next(twos);\n  while (c3 &lt;= g-&gt;tracker) c3 = threes-&gt;next(threes);\n  while (c5 &lt;= g-&gt;tracker) c5 = fives-&gt;next(fives);\n\n  g-&gt;tracker = smallest(c2,c3,c5);\n  return g-&gt;tracker;\n}\n\ngenerator* hammings_stream() {\n  generator *g = malloc(sizeof(generator));\n  g-&gt;next = hamming_gen;\n  g-&gt;tracker = 0;\n  return g;\n}\n\nint main() {\n  generator* hammings = hammings_stream();\n  int i = 0;\n  while (i&lt;10) {\n    printf(\"Hamming No: %d\\n\",hammings-&gt;next(hammings));\n    i++;\n  }\n}\n</code>\n</pre>\n", "senID": 2}]]