[[{"text": ["If the dicts have identical sets of keys and you need all those prints for any value difference, there isn't much you can do; maybe something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n diffkeys = [k for k in dict1 if dict1[k] != dict2[k]]\nfor k in diffkeys:\n  print k, ':', dict1[k], '-&gt;', dict2[k]\n</code>\n</pre>\n", "senID": 1}, {"text": ["pretty much equivalent to what you have, but you might get nicer presentation for example by sorting diffkeys before you loop on it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Uhm, you are describing dict1 == dict2 ( check if boths dicts are equal )"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dict1 == dict2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["But what your code does is all( dict1[k]==dict2[k] for k in dict1 ) ( check if all entries in dict1 are equal to those in dict2 )"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "all( dict1[k]==dict2[k] for k in dict1 )", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can use sets for this too"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = {'x': 1, 'y': 2}\n&gt;&gt;&gt; b = {'y': 2, 'x': 1}\n&gt;&gt;&gt; set(a.iteritems())-set(b.iteritems())\nset([])\n&gt;&gt;&gt; a['y']=3\n&gt;&gt;&gt; set(a.iteritems())-set(b.iteritems())\nset([('y', 3)])\n&gt;&gt;&gt; set(b.iteritems())-set(a.iteritems())\nset([('y', 2)])\n&gt;&gt;&gt; set(b.iteritems())^set(a.iteritems())\nset([('y', 3), ('y', 2)])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you're just comparing for equality, you can just do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if not dict1 == dict2:\n    match = False\n</code>\n</pre>\n", "senID": 1}, {"text": ["Otherwise, the only major problem I see is that you're going to get a KeyError if there is a key in dict1 that is not in dict2, so you may want to do something like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for key in dict1:\n    if not key in dict2 or dict1[key] != dict2[key]:\n        match = False\n</code>\n</pre>\n", "senID": 3}, {"text": ["You could compress this into a comprehension to just get the list of keys that don't match too:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n mismatch_keys = [key for key in x if not key in y or x[key] != y[key]]\nmatch = not bool(mismatch_keys) #If the list is not empty, they don't match \nfor key in mismatch_keys:\n    print key\n    print '%s -&gt; %s' % (dict1[key],dict2[key])\n</code>\n</pre>\n", "senID": 5}, {"text": ["The only other optimization I can think of might be to use \"len(dict)\" to figure out which dict has fewer entries and loop through that one first to have the shortest loop possible."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; a = {'x': 1, 'y': 2}\n&gt;&gt;&gt; b = {'y': 2, 'x': 1}\n&gt;&gt;&gt; print a == b\nTrue\n&gt;&gt;&gt; c = {'z': 1}\n&gt;&gt;&gt; print a == c\nFalse\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If the true intent of the question is the comparison between dicts (rather than printing differences), the answer is"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dict1 == dict2\n</code>\n</pre>\n", "senID": 1}, {"text": ["This has been mentioned before, but I felt it was slightly drowning in other bits of information.", "It might appear superficial, but the value comparison of dicts has actually powerful semantics.", "It covers"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "number of keys (if they don't match, the dicts are not equal)", "tag": "none", "senID": 3}, {"text": "names of keys (if they don't match, they're not equal)", "tag": "none", "senID": 4}, {"text": "value of each key (they have to be '==', too)", "tag": "none", "senID": 5}]}, {"text": ["The last point again appears trivial, but is acutally interesting as it means that all of this applies recursively to nested dicts as well.", "E.g."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "applies recursively", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n m1 = {'f':True}\n m2 = {'f':True}\n m3 = {'a':1, 2:2, 3:m1}\n m4 = {'a':1, 2:2, 3:m2}\n m3 == m4  # True\n</code>\n</pre>\n", "senID": 7}, {"text": ["Similar semantics exist for the comparison of lists.", "All of this makes it a no-brainer to e.g.", "compare deep Json structures, alone with a simple \"==\"."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}]]