[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; a='00010100011011101101110100010111'\n&gt;&gt;&gt; [a[i:i+5] for i in range(0, len(a), 5)]\n['00010', '10001', '10111', '01101', '11010', '00101', '11']\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; [''.join(each) for each in zip(*[iter(s)]*5)]\n['00010', '10001', '10111', '01101', '11010', '00101']\n</code>\n</pre>\n", "senID": 0}, {"text": ["or:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; map(''.join, zip(*[iter(s)]*5))\n['00010', '10001', '10111', '01101', '11010', '00101']\n</code>\n</pre>\n", "senID": 2}, {"text": ["[EDIT]"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The question was raised by Greg Hewgill, what to do with the two trailing bits?", "Here are some possibilities:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import izip_longest\n&gt;&gt;&gt;\n&gt;&gt;&gt; map(''.join, izip_longest(*[iter(s)]*5, fillvalue=''))\n['00010', '10001', '10111', '01101', '11010', '00101', '11']\n&gt;&gt;&gt;\n&gt;&gt;&gt; map(''.join, izip_longest(*[iter(s)]*5, fillvalue=' '))\n['00010', '10001', '10111', '01101', '11010', '00101', '11   ']\n&gt;&gt;&gt;\n&gt;&gt;&gt; map(''.join, izip_longest(*[iter(s)]*5, fillvalue='0'))\n['00010', '10001', '10111', '01101', '11010', '00101', '11000']\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Per your comments, you actually want base 32 strings."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import base64\n&gt;&gt;&gt; base64.b32encode(\"good stuff\")\n'M5XW6ZBAON2HKZTG'\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; l = '00010100011011101101110100010111'\n&gt;&gt;&gt; def splitSize(s, size):\n...     return [''.join(x) for x in zip(*[list(s[t::size]) for t in range(size)])]\n...  \n&gt;&gt;&gt; splitSize(l, 5)\n['00010', '10001', '10111', '01101', '11010', '00101']\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Another way to group iterables, from the itertools examples:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html"}]}, {"code": "<pre>\n<code>\n def grouper(n, iterable, fillvalue=None):\n    \"grouper(3, 'ABCDEFG', 'x') --&gt; ABC DEF Gxx\"\n    args = [iter(iterable)] * n\n    return izip_longest(fillvalue=fillvalue, *args)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about using a regular expression?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; re.findall('.{1,5}', '00010100011011101101110100010111')\n['00010', '10001', '10111', '01101', '11010', '00101', '11']\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will break though if your input string contains newlines, that you want in the grouping."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]