[[{"text": ["You could use numpy.arange."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "numpy.arange", "tag": "a", "pos": 0, "childList": [{"text": "numpy.arange", "tag": "code"}], "childNum": 1, "href": "http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html#numpy-arange"}, {"text": "numpy.arange", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["EDIT: The docs prefer numpy.linspace.", "Thanks @Droogans for noticing =)"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "numpy.linspace", "tag": "a", "pos": 0, "childList": [{"text": "numpy.linspace", "tag": "code"}], "childNum": 1, "href": "http://docs.scipy.org/doc/numpy/reference/generated/numpy.linspace.html?highlight=linspace#numpy.linspace"}, {"text": "numpy.linspace", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Thanks @Droogans for noticing =)", "childNum": 0, "tag": "sub", "pos": 1, "childList": []}]}], [{"text": ["One explanation might be floating point rounding issues.", "For example, if you could call"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n range(0, 0.4, 0.1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["you might expect an output of"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [0, 0.1, 0.2, 0.3]\n</code>\n</pre>\n", "senID": 3}, {"text": ["but you in fact get something like"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n [0, 0.1, 0.2000000001, 0.3000000001]\n</code>\n</pre>\n", "senID": 5}, {"text": ["due to rounding issues.", "And since range is often used to generate indices of some sort, it's integers only."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Still, if you want a range generator for floats, you can just roll your own."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def xfrange(start, stop, step):\n    while start &lt; stop:\n        yield start\n        start += step\n</code>\n</pre>\n", "senID": 8}], [{"text": ["When you add floating point numbers together, there's often a little bit of error.", "Would a range(0.0,2.2,1.1) return [0.0,1.1] or [0.0,1.1,2.199999999]?", "There's no way to be certain."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "range(0.0,2.2,1.1)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "[0.0,1.1]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "[0.0,1.1,2.199999999]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The code you posted is a perfect work-around if you really need this."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["In order to be able to use decimal numbers in a range expression a cool way for doing it is the following:\n[x * 0.1 for x in range(0, 10)]"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The problem with floating point is that you may not get the same number of items as you expected, due to inaccuracy.", "This can be a real problem if you are playing with polynomials where the exact number of items is quite important."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What you really want is an arithmetic progression; the following code will work quite happily for int, float and complex ... and strings, and lists ..."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "float", "childNum": 0, "tag": "code", "childList": []}, {"text": "complex", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def arithmetic_progression(start, step, length):\n    for i in xrange(length):\n        yield start + i * step\n</code>\n</pre>\n", "senID": 2}, {"text": ["Note that this code stands a better chance of your last value being within a bull's roar of the expected value than any alternative which maintains a running total."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 10000 * 0.0001, sum(0.0001 for i in xrange(10000))\n(1.0, 0.9999999999999062)\n&gt;&gt;&gt; 10000 * (1/3.), sum(1/3. for i in xrange(10000))\n(3333.333333333333, 3333.3333333337314)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Correction: here's a competetive running-total gadget:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "competetive running-total gadget", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Kahan_summation_algorithm"}]}, {"code": "<pre>\n<code>\n def kahan_range(start, stop, step):\n    assert step &gt; 0.0\n    total = start\n    compo = 0.0\n    while total &lt; stop:\n        yield total\n        y = step - compo\n        temp = total + y\n        compo = (temp - total) - y\n        total = temp\n\n&gt;&gt;&gt; list(kahan_range(0, 1, 0.0001))[-1]\n0.9999\n&gt;&gt;&gt; list(kahan_range(0, 3333.3334, 1/3.))[-1]\n3333.333333333333\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Probably because you can't have part of an iterable.", "Also, floats are imprecise."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "floats", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]