[[{"text": ["This is supported in Perl 6."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Perl 6", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://perlcabal.org/syn/S12.html#Mutating_methods"}]}], [{"text": ["IMHO, i don't like it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "IMHO", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["just imagine this,"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n items .= click(function(){...});\n</code>\n</pre>\n", "senID": 2}, {"text": ["it's not a syntax error anymore, but it doesn't make sense, does it?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I can say it does not make sense simply because if you expand my example, it would be like this,"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n items = items.click(function(){...});\n</code>\n</pre>\n", "senID": 5}, {"text": ["items.click(function(){...}); would just return the object items , and you will assign it to items?"], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "items.click(function(){...});", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "items", "childNum": 0, "tag": "code", "childList": []}, {"text": "items", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["in this example,"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n items .= filter(desc__endswith='Z');\n</code>\n</pre>\n", "senID": 8}, {"text": ["it would make sense, but not true to all objects, maybe that's the reason it was not implemented."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["as to  parent .= children();, what happens to parent later on the codes?"], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "parent .= children();", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "parent", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I'm talking jQuery way."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "I'm talking jQuery way.", "childNum": 0, "tag": "sub", "pos": 0, "childList": []}]}], [{"text": ["I can't answer those questions, and I'm not sure what I think of this because I havn't seen it before, but it does have an interesting applicatioon: all of the inplace operators become obsolete."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = 1\na .= __add__(1)\na .= __mul__(2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course, it's clearer to write a += 1, but if this syntax had come earlier in the design of the language, and the __add__ methods were less ugly (eg.", "just add), the language today might have eleven fewer operators today."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "a += 1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__add__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "add", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "eleven", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["(Of course, there would be other implications of that--in particular, the automatic fallback from __iadd__ to __add__ would be lost.", "Still, it's an interesting concept."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "__iadd__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__add__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Scala's collections support in-place operations, provided that the variable is a var."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "var", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n scala&gt; var L = List(\"b\", \"c\")\nL: List[java.lang.String] = List(b, c)\n\nscala&gt; L ::= \"a\"\n\nscala&gt; L\nres8: List[java.lang.String] = List(a, b, c)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(For those unfamiliar with Scala, :: is a method of List)"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "::", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "List", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This is a style of programming that many avoid, and in Scala you can avoid such in-place mutation by using immutable vals:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "val", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n scala&gt; val L = List(\"b\", \"c\")\nL: List[java.lang.String] = List(b, c)\n\nscala&gt; L ::= \"a\"\n&lt;console&gt;:7: error: reassignment to val\n       L ::= \"a\"\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I have thought about this often when doing Java or C# programming, where you find yourself repeating not just one but often the same two or more object references on both sides of the assignment -- e.g., you have a member of some object that is a string, and you want to call some methods on that string and assign it back to the member variable.", "Oddly enough, it hasn't bothered me nearly as much in Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The .= operator you propose is one idea I thought of at the time I was doing C#.", "Another option would be to allow a leading dot to as a shorthand for the object being assigned to, like this:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": ".=", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n foo.bar.str = .lower()  # same as foo.bar.str = foo.bar.str.lower()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Pascal, Modula-2, and Visual Basic have a with statement (different from Python's statement of the same name) that would allow you to write something like this if it existed in Python (I call it \"using\" here so it is not mistaken for valid Python):"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "with", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n using foo.bar:\n    str = str.lower()  # same as foo.bar.str = foo.bar.str.lower()\n</code>\n</pre>\n", "senID": 4}, {"text": ["This is very convenient when you are going to be doing a lot of manipulation of members of a single object since it allows a block.", "However, you still have a level of redundancy here, which could be eliminated if you combined the last two ideas like so:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n using foo.bar:\n    str = .lower()\n</code>\n</pre>\n", "senID": 6}, {"text": ["This seems to me like it would be a nice bit of syntactic sugar, and I find it very readable, but it does not seem like it is high on the priority list of most language designers.", "However, since Python does have Modula-2 influences, perhaps it's not out of the question that it would eventually be added."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Ruby has this feature in a way, but implements it differently.", "This is through 'destructive' methods, which alter the variable they are called on.", "For example, calling str.split just returns the object split, it doesn't alter it.", "But, if you call str.split!", "it changes it in place.", "Most builtin array and string methods have a destructive and non-destructive version. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]