[[{"text": ["So, for your new example, try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo(x)\n  (0..x).select { |i| bar(i) }\nend\n</code>\n</pre>\n", "senID": 1}, {"text": ["Basically, unless you're writing an iterator of your own, you don't need yield very often in Ruby.", "You'll probably do a lot better if you stop trying to write Python idioms using Ruby syntax."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["For the Python version I would use a generator expression like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (i for i in range(x) if bar(i))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or for this specific case of filtering values, even more simply"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n itertools.ifilter(bar,range(x))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The exact equivalent of your Python code (using Ruby Generators) would be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo(x)\n    Enumerator.new do |yielder|\n        (0..x).each { |v| yielder.yield(v) if bar(v) }\n    end\nend\n\nresult = Array(foo(100))\n</code>\n</pre>\n", "senID": 1}, {"text": ["In the above, the list is lazily generated (just as in the Python example); see:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def bar(v); v % 2 == 0; end\n\nf = foo(100)\nf.next #=&gt; 0\nf.next #=&gt; 2\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I know it's not exactly what you were looking for, but a more elegant way to express your example in ruby is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n result = Array.new(100) {|x| x*x}\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def squares(x)\n  (0..x).map { |i| i * i }\nend\n</code>\n</pre>\n", "senID": 0}, {"text": ["Anything involving a range of values is best handled with, well, a range, rather than times and array generation."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "times", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["For the Python list comprehension version posted by stbuton use xrange instead of range if you want a generator.", "range will create the entire list in memory."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "xrange", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#xrange"}]}], [{"text": ["yield means different things ruby and python.", "In ruby, you have to specify a callback block if I remember correctly, whereas generators in python can be passed around and yield to whoever holds them."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]