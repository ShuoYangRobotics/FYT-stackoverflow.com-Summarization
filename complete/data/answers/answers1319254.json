[[{"text": ["This will traverse at most once:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def point_to_index(point):\n    try: \n        return points.index(point)\n    except ValueError:\n        points.append(point)\n        return len(points)-1\n</code>\n</pre>\n", "senID": 1}, {"text": ["You may also want to try this version, which takes into account that matches are likely to be near the end of the list.", "Note that reversed() has almost no cost even on very large lists - it does not create a copy and does not traverse the list more than once."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "reversed()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def point_to_index(point):\n    for index, this_point in enumerate(reversed(points)):\n        if point == this_point:\n            return len(points) - (index+1)\n    else:\n        points.append(point)\n        return len(points)-1\n</code>\n</pre>\n", "senID": 3}, {"text": ["You might also consider keeping a parallel dict or set of points to check for membership, since both of those types can do membership tests in O(1).", "There would be, of course, a substantial memory cost."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Obviously, if the points were ordered somehow, you would have many other options for speeding this code up, notably using a binary search for membership tests."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["You want to use a set:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "set", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#set"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = set()\n&gt;&gt;&gt; x\nset([])\n&gt;&gt;&gt; x.add(1)\n&gt;&gt;&gt; x\nset([1])\n&gt;&gt;&gt; x.add(1)\n&gt;&gt;&gt; x\nset([1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["A set contains only one instance of any item you add, and it will be a lot more efficient than iterating a list manually."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This wikibooks page looks like a good primer if you haven't used sets in Python before."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "This wikibooks page", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikibooks.org/wiki/Python%5FProgramming/Sets"}]}], [{"text": ["If you're worried about memory usage, but want to optimize the common case, keep a dictionary with the last n points and their indexes.", "points_dict = dictionary, max_cache = size of the cache."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def point_to_index(point):\n    try:\n        return points_dict.get(point, points.index(point))\n    except:\n        if len(points) &gt;= max_cache:\n            del points_dict[points[len(points)-max_cache]]\n        points.append(point)\n        points_dict[points] = len(points)-1\n        return len(points)-1\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def point_to_index(point):\n    try:\n        return points.index(point)\n    except:\n        points.append(point)\n        return len(points)-1\n</code>\n</pre>\n", "senID": 0}, {"text": ["Update: Added in Nathan's exception code."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["As others said, consider using set or dict.", "You don't explain why you need the indices.", "If they are needed only to assign unique ids to the points (and I can't easily come up with another reason for using them), then dict will indeed work much better, e.g.,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n points = {}\ndef point_to_index(point):\n    if point in points:\n        return points[point]\n    else:\n       points[point] = len(points)\n       return len(points) - 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["What you really want is an ordered dict (key insertion determines the order):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Recipe: ", "tag": "none", "senID": 1}, {"text": "PEP: ", "tag": "none", "senID": 2}]}]]