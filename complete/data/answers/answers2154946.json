[[{"text": ["Here's a blog post sharing your pain.", "It includes an implementation of a linked list and a performance comparison."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "blog post", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.algorithm.co.il/blogs/index.php/programming/python/lru-cache-solution-a-case-for-linked-lists-in-python/"}]}, {"text": ["Perhaps blist would be better, though (from here)?"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "blist", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://pypi.python.org/pypi/blist/0.9.4", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Note that it's actually implemented as a B+ tree, allowing great performance for all those operations."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["There's a single-linked list here (recipe 17.14 in the Python Cookbook 1st ed) but it's hardly \"mature\" or rich -- it's just doing a FIFO queue so it's pretty minimal."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://books.google.com/books?id=yhfdQgq8JF4C&pg=PA533&lpg=PA533&dq=martelli+python+linked+list&source=bl&ots=-5pjCzgP0_&sig=y6iUN6XR2LRjJi-uTkijeRHhkxA&hl=en&ei=BqlhS9hXhoazA-O88bID&sa=X&oi=book_result&ct=result&resnum=6&ved=0CCUQ6AEwBQ#v=onepage&q=&f=false"}]}, {"text": ["This recipe is a very concise C implementation of (read-only) Lisp-like cons-boxes -- just car, cdr and cons; again, not a rich type, rather a minimal one (and to use it for mutable data, as opposed to pure functional approaches, you'd need to add setcar and setcdr at least).", "It may be a better starting point for you simply because cons-cells are so notoriously flexible and familiar."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "This recipe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/66509/"}]}, {"text": ["Some of the operations you require will be likely best done by existing Python primitives.", "For example, for sorting, it's hard to see how rolling your own sort can beat the performance of Python's sorted(linkedlist) (as long of course as you make the linkedlist type a Python iterable so it plays well with the rest of the language and library;-), considering the power of the timsort algorithm implemented in the Python runtime."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "sorted(linkedlist)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "linkedlist", "childNum": 0, "tag": "code", "childList": []}, {"text": "timsort", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["More generally I suggest you carefully timeit things every step along the way to consider how much the C-coded approach is really buying you (when compared to the trivial C-coded one exemplified by the recipe in the printed Cookbook whose URL I give at the start of this answer) -- that will crucially depend on the size and nature of your application's lists, so you're the one best placed to organize these benchmarks of course."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "timeit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Python lists are O(1) for operations at the end of the list.", "If you'll be doing all your inserting in a semi-sequential fashion--by analogy to C, only keeping a single pointer into the middle of the list as a \"cursor\" of sorts--you could save yourself a lot of effort by just using two Python lists.", "One list for what's before the cursor, one for what's after; moving the cursor involves pulling the next item from one list and appending it to the other.", "That gives you arbitrary O(1) inserting at the cursor location with far less effort and wheel reinventing than making an entire new data structure, letting you reuse a lot of the existing list functions."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "O(1) for operations at the end of the list", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/TimeComplexity"}]}, {"text": ["For the fully general case allowing multiple references into the list, though, you're probably stuck making a linked list of some sort."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit: You're not seriously thinking of actually doing a \"binary search\" on a linked list, are you?", "Binary search doesn't even make sense on an intrinsically sequential data structure..."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Anyway, if you're okay with linear-time searching and your insertions will always preserve the list order without re-sorting, then a simple linked list might be all you need.", "If you do as much searching as iterating you should consider something with fast indexing, and if resorting might be required something like a tree would be better."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["\" I will iterate over the list forwards (one by one), using a visitor on each entry, starting from the beginning or a position found by a binary search.", "When an entry matching a predicate is found it is removed from the list, and then, another binary search is performed on a subset of the list beginning from the removed entry's previous position\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It sounds like a linked list is absolutely the wrong data structure for this - doing a binary search will require random access to the list, which will mean repeatedly iterating through the elements.", "This is likely to be slower on a linked list than inserting and deleting items in a python list."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It sounds like the data structure you want is a skip list.", "Google throws up several implementations, but I cannot comment on their completeness or quality."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "skip list", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Skip_list"}]}, {"text": ["edit:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Another data structure that may be suitable is a threaded binary tree.", "this is like a regular binary tree but each leaf node points to next/previous subtree, so it can be iterated through as efficiently as a linked list.", "Implementing it in Python is left as an exercise for the reader (or Google)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "threaded binary tree", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Threaded_binary_tree"}]}], [{"text": ["It's puzzling that everyone demands justification to need a linked list.", "Linked lists are one of the most elementary data structures for a reason: they have properties that the other major data structures lack, and if you need those properties, you need a linked list or one of its close relatives.", "If you don't understand why linked lists are an important data structure that can't always be replaced with a deque or a binary tree, you should never have passed your \"intro to data structures\" class."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's a quick implementation, supporting the usual stuff: constant-time insertion at any point given a reference to the node, splitting the list into two lists, and inserting a list into the middle of another list (splice).", "Generic Python interfaces are supported: push, pop, pushleft, popleft, extend, ordinary iteration, iteration over a slice (getiter)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I just wrote this, so it's doctested but not production tested; there are probably still bugs."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def _ref(obj):\n    \"\"\"\n    weakref.ref has a bit of braindamage: you can't take a weakref to None.\n    This is a major hassle and a needless limitation; work around it.\n    \"\"\"\n    from weakref import ref\n    if obj is None:\n        class NullRef(object):\n            def __call__(self): return None\n        return NullRef()\n    else:\n        return ref(obj)\n\nclass _node(object):\n    def __init__(self, obj):\n        self.obj = obj\n        self._next = None\n        self._prev = _ref(None)\n    def __repr__(self):\n        return \"node(%s)\" % repr(self.obj)\n\n    def __call__(self):\n        return self.obj\n\n    @property\n    def next(self):\n        return self._next\n\n    @property\n    def prev(self):\n        return self._prev()\n\n# Implementation note: all \"_last\" and \"prev\" links are weakrefs, to prevent circular references.\n# This is important; if we don't do this, every list will be a big circular reference.  This would\n# affect collection of the actual objects in the list, not just our node objects.\n#\n# This means that _node objects can't exist on their own; they must be part of a list, or nodes\n# in the list will be collected.  We also have to pay attention to references when we move nodes\n# from one list to another.\nclass llist(object):\n    \"\"\"\n    Implements a doubly-linked list.\n    \"\"\"\n    def __init__(self, init=None):\n        self._first = None\n        self._last = _ref(None)\n        if init is not None:\n            self.extend(init)\n\n    def insert(self, item, node=None):\n        \"\"\"\n        Insert item before node.  If node is None, insert at the end of the list.\n        Return the node created for item.\n\n        &gt;&gt;&gt; l = llist()\n        &gt;&gt;&gt; a = l.insert(1)\n        &gt;&gt;&gt; b = l.insert(2)\n        &gt;&gt;&gt; d = l.insert(4)\n        &gt;&gt;&gt; l._check()\n        [1, 2, 4]\n        &gt;&gt;&gt; c = l.insert(3, d)\n        &gt;&gt;&gt; l._check()\n        [1, 2, 3, 4]\n        \"\"\"\n        item = _node(item)\n\n        if node is None:\n            if self._last() is not None:\n                self._last()._next = item\n                item._prev = _ref(self._last())\n            self._last = _ref(item)\n            if self._first is None:\n                self._first = item\n        else:\n            assert self._first is not None, \"insertion node must be None when the list is empty\"\n            if node._prev() is not None:\n                node._prev()._next = item\n            item._prev = node._prev\n            item._next = node\n            node._prev = _ref(item)\n            if node is self._first:\n                self._first = item\n        return item\n\n    def remove(self, node):\n        \"\"\"\n        &gt;&gt;&gt; l = llist()\n        &gt;&gt;&gt; a = l.append(1)\n        &gt;&gt;&gt; b = l.append(2)\n        &gt;&gt;&gt; c = l.append(3)\n        &gt;&gt;&gt; d = l.append(4)\n        &gt;&gt;&gt; e = l.append(5)\n        &gt;&gt;&gt; l.remove(c) # Check removing from the middle\n        3\n        &gt;&gt;&gt; l._check()\n        [1, 2, 4, 5]\n        &gt;&gt;&gt; l.remove(a) # Check removing from the start\n        1\n        &gt;&gt;&gt; l._check()\n        [2, 4, 5]\n        &gt;&gt;&gt; l.remove(e) # Check removing from the end\n        5\n        &gt;&gt;&gt; l._check()\n        [2, 4]\n        \"\"\"\n        if self._first is node:\n            self._first = node._next\n        if self._last() is node:\n            self._last = node._prev\n        if node._next is not None:\n            node._next._prev = node._prev\n        if node._prev() is not None:\n            node._prev()._next = node._next\n        node._next = None\n        node._prev = _ref(None)\n        return node.obj\n\n    def __nonzero__(self):\n        \"\"\"\n        A list is true if it has any elements.\n\n        &gt;&gt;&gt; l = llist()\n        &gt;&gt;&gt; bool(l)\n        False\n        &gt;&gt;&gt; l = llist([1])\n        &gt;&gt;&gt; bool(l)\n        True\n        \"\"\"\n        return self._first is not None\n\n\n    def __iter__(self):\n        \"\"\"\n        &gt;&gt;&gt; l = llist([1,2,3])\n        &gt;&gt;&gt; [i() for i in l]\n        [1, 2, 3]\n        \"\"\"\n        return self.getiter(self._first, self._last())\n\n    def _check(self):\n        if self._last() is None:\n            assert self._last() is None\n            return []\n        node = self._first\n        ret = []\n        while node is not None:\n            if node._next is None:\n                assert node == self._last()\n            if node._prev() is None:\n                assert node == self._first\n            if node._next is not None:\n                assert node._next._prev() == node\n            if node._prev() is not None:\n                assert node._prev()._next == node\n            ret.append(node.obj)\n            node = node._next\n        return ret\n\n    def getiter(self, first, last):\n        \"\"\"\n        Return an iterator over [first,last].\n\n        &gt;&gt;&gt; l = llist()\n        &gt;&gt;&gt; l.append(1)\n        node(1)\n        &gt;&gt;&gt; start = l.append(2)\n        &gt;&gt;&gt; l.extend([3,4,5,6])\n        &gt;&gt;&gt; end = l.append(7)\n        &gt;&gt;&gt; l.extend([8,9])\n        &gt;&gt;&gt; [i() for i in l.getiter(start, end)]\n        [2, 3, 4, 5, 6, 7]\n        \"\"\"\n        class listiter(object):\n            def __init__(self, first, last):\n                self.node = first\n                self.final_node = last\n\n            def __iter__(self): return self\n            def next(self):\n                ret = self.node\n                if ret is None:\n                    raise StopIteration\n                if ret is self.final_node:\n                    self.node = None\n                else:\n                    self.node = self.node._next\n                return ret\n        return listiter(first, last)\n\n    def append(self, item):\n        \"\"\"\n        Add an item to the end of the list.\n\n        &gt;&gt;&gt; l = llist()\n        &gt;&gt;&gt; l.append(1)\n        node(1)\n        &gt;&gt;&gt; l.append(2)\n        node(2)\n        &gt;&gt;&gt; l._check()\n        [1, 2]\n        \"\"\"\n        return self.insert(item, None)\n\n    def appendleft(self, item):\n        \"\"\"\n        Add an item to the beginning of the list.\n\n        &gt;&gt;&gt; l = llist()\n        &gt;&gt;&gt; l.appendleft(1)\n        node(1)\n        &gt;&gt;&gt; l.appendleft(2)\n        node(2)\n        &gt;&gt;&gt; l._check()\n        [2, 1]\n        \"\"\"\n        return self.insert(item, self._first)\n\n    def pop(self):\n        \"\"\"\n        Remove an item from the end of the list and return it.\n\n        &gt;&gt;&gt; l = llist([1,2,3])\n        &gt;&gt;&gt; l.pop()\n        3\n        &gt;&gt;&gt; l.pop()\n        2\n        &gt;&gt;&gt; l.pop()\n        1\n        &gt;&gt;&gt; l.pop()\n        Traceback (most recent call last):\n        ...\n        IndexError: pop from empty llist\n        \"\"\"\n        if self._last() is None:\n            raise IndexError, \"pop from empty llist\"\n        return self.remove(self._last())\n\n    def popleft(self):\n        \"\"\"\n        Remove an item from the beginning of the list and return it.\n\n        &gt;&gt;&gt; l = llist([1,2,3])\n        &gt;&gt;&gt; l.popleft()\n        1\n        &gt;&gt;&gt; l.popleft()\n        2\n        &gt;&gt;&gt; l.popleft()\n        3\n        &gt;&gt;&gt; l.popleft()\n        Traceback (most recent call last):\n        ...\n        IndexError: popleft from empty llist\n        \"\"\"\n        if self._first is None:\n            raise IndexError, \"popleft from empty llist\"\n        return self.remove(self._first)\n\n    def splice(self, source, node=None):\n        \"\"\"\n        Splice the contents of source into this list before node; if node is None, insert at\n        the end.  Empty source_list.  Return the first and last nodes that were moved.\n\n        # Test inserting at the beginning.\n        &gt;&gt;&gt; l = llist()\n        &gt;&gt;&gt; a = l.append(1)\n        &gt;&gt;&gt; b = l.append(2)\n        &gt;&gt;&gt; c = l.append(3)\n        &gt;&gt;&gt; l2 = llist([4,5,6])\n        &gt;&gt;&gt; l.splice(l2, a)\n        (node(4), node(6))\n        &gt;&gt;&gt; l._check()\n        [4, 5, 6, 1, 2, 3]\n        &gt;&gt;&gt; l2._check()\n        []\n\n        # Test inserting in the middle.\n        &gt;&gt;&gt; l = llist()\n        &gt;&gt;&gt; a = l.append(1)\n        &gt;&gt;&gt; b = l.append(2)\n        &gt;&gt;&gt; c = l.append(3)\n        &gt;&gt;&gt; l2 = llist([4,5,6])\n        &gt;&gt;&gt; l.splice(l2, b)\n        (node(4), node(6))\n        &gt;&gt;&gt; l._check()\n        [1, 4, 5, 6, 2, 3]\n        &gt;&gt;&gt; l2._check()\n        []\n\n        # Test inserting at the end.\n        &gt;&gt;&gt; l = llist()\n        &gt;&gt;&gt; a = l.append(1)\n        &gt;&gt;&gt; b = l.append(2)\n        &gt;&gt;&gt; c = l.append(3)\n        &gt;&gt;&gt; l2 = llist([4,5,6])\n        &gt;&gt;&gt; l.splice(l2, None)\n        (node(4), node(6))\n        &gt;&gt;&gt; l._check()\n        [1, 2, 3, 4, 5, 6]\n        &gt;&gt;&gt; l2._check()\n        []\n\n        # Test inserting a list with a single item.\n        &gt;&gt;&gt; l = llist()\n        &gt;&gt;&gt; a = l.append(1)\n        &gt;&gt;&gt; b = l.append(2)\n        &gt;&gt;&gt; c = l.append(3)\n        &gt;&gt;&gt; l2 = llist([4])\n        &gt;&gt;&gt; l.splice(l2, b)\n        (node(4), node(4))\n        &gt;&gt;&gt; l._check()\n        [1, 4, 2, 3]\n        &gt;&gt;&gt; l2._check()\n        []\n        \"\"\"\n        if source._first is None:\n            return\n        first = source._first\n        last = source._last()\n\n        if node is None:\n            if self._last() is not None:\n                self._last()._next = source._first\n            source._first._prev = self._last\n            self._last = source._last\n            if self._first is None:\n                self._first = source._first\n        else:\n            source._first._prev = node._prev\n            source._last()._next = node\n            if node._prev() is not None:\n                node._prev()._next = source._first\n            node._prev = source._last\n            if node is self._first:\n                self._first = source._first\n        source._first = None\n        source._last = _ref(None)\n        return first, last\n\n    def split(self, start, end=None):\n        \"\"\"\n        Remove all items between [node, end] and return them in a new list.  If end is None,\n        remove until the end of the list.\n\n        &gt;&gt;&gt; l = llist()\n        &gt;&gt;&gt; a = l.append(1)\n        &gt;&gt;&gt; b = l.append(2)\n        &gt;&gt;&gt; c = l.append(3)\n        &gt;&gt;&gt; d = l.append(4)\n        &gt;&gt;&gt; e = l.append(5)\n        &gt;&gt;&gt; l._check()\n        [1, 2, 3, 4, 5]\n        &gt;&gt;&gt; l2 = l.split(c, e)\n        &gt;&gt;&gt; l._check()\n        [1, 2]\n        &gt;&gt;&gt; l2._check()\n        [3, 4, 5]\n\n        &gt;&gt;&gt; l = llist()\n        &gt;&gt;&gt; a = l.append(1)\n        &gt;&gt;&gt; b = l.append(2)\n        &gt;&gt;&gt; c = l.append(3)\n        &gt;&gt;&gt; d = l.append(4)\n        &gt;&gt;&gt; e = l.append(5)\n        &gt;&gt;&gt; l2 = l.split(a, c)\n        &gt;&gt;&gt; l._check()\n        [4, 5]\n        &gt;&gt;&gt; l2._check()\n        [1, 2, 3]\n\n        &gt;&gt;&gt; l = llist()\n        &gt;&gt;&gt; a = l.append(1)\n        &gt;&gt;&gt; b = l.append(2)\n        &gt;&gt;&gt; c = l.append(3)\n        &gt;&gt;&gt; d = l.append(4)\n        &gt;&gt;&gt; e = l.append(5)\n        &gt;&gt;&gt; l2 = l.split(b, d)\n        &gt;&gt;&gt; l._check()\n        [1, 5]\n        &gt;&gt;&gt; l2._check()\n        [2, 3, 4]\n        \"\"\"\n        if end is None:\n            end = self._last()\n\n        ret = llist()\n\n        # First, move the region into the new list.  It's important to do this first, or\n        # once we remove the nodes from the old list, they'll be held only by weakrefs and\n        # nodes could end up being collected before we put it into the new one.\n        ret._first = start\n        ret._last = _ref(end)\n\n        # Hook our own nodes back together.\n        if start is self._first:\n            self._first = end._next\n        if end is self._last():\n            self._last = start._prev\n\n        if start._prev() is not None:\n            start._prev()._next = end._next\n        if end._next is not None:\n            end._next._prev = start._prev\n        start._prev = _ref(None)\n        end._next = None\n\n        return ret\n\n    def extend(self, items):\n        \"\"\"\n        &gt;&gt;&gt; l = llist()\n        &gt;&gt;&gt; l.extend([1,2,3,4,5])\n        &gt;&gt;&gt; l._check()\n        [1, 2, 3, 4, 5]\n        \"\"\"\n        for item in items:\n            self.append(item)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Python's deque class is 0(1) for insertion and deletion at the beginning and end of the list."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "deque", "tag": "a", "pos": 0, "childList": [{"text": "deque", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/collections.html#collections.deque"}, {"text": "deque", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Your requirements are still (after the edit) unclear.", "You say that you are doing a binary search on a linked list.", "Please pardon my ignorance, but I was under the impression that a binary search required direct access to list components via a calculated integer index.", "Perhaps your \"linked list\" is really a tree.", "Can you please explain? "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "linked", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}], [{"text": ["Here's an idea, that would require a little coding, but may give you hugely better performance.", "It may or may not be suitable for your use case."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can splice a new list into your list by replacing a single element.", "To insert the list [6, 7, 8] into  [1, 2, 3, 4, 5] at index 2, you would end up with"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["[1, 2, [3, 6, 7, 8], 4, 5]"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["By not changing the length of the large (here 5 element) list, you'll not have the speed problems you're currently having."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You can 'delete' an element from the list in the same way, by replacing it with an empty list."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["[1, 2, [], 4, 5]"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["To iterate over this mixed list is straightforward."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def IterateNestedList(xs):\n    for x in xs:\n        if isinstance(x, list):\n            for y in IterateNestedList(x): yield y\n        else: yield x\n</code>\n</pre>\n", "senID": 7}], [{"text": ["For large data\uff0c keep a sorted list is a trick.", "Don't insert but append new items at the end and then sort it.", "Don't delet item but replace with a special value, sort them to the end and then pop out.", "For finding, a sorted list also has very quick performance with bisection method.", "As for small data, iterate old list\uff0c filter and build a new one, like list comprehensions method, is always the fast way."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For me, what is large data?", "it should be over 1000000 items..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]