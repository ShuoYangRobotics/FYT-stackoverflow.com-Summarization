[[{"text": ["Take an XML parser, make it generate a DOM (Document Object Model) and then build a recursive algorithm that traverses all the nodes, calls \"text()\" in each node (that should give you the text in the current node and all children) and puts that as a key in the dictionary."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Use expat or another XML parser; it's more explicit than anything else, considering you're dealing with XML data anyway."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, note that XML element names can't start with a number as your example has them."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here's a parser that will do what you need, although you'll need to tweak it to combine duplicate elements into one dict key:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from xml.parsers.expat import ParserCreate\n\nopen_elements = {}\nresult_dict = {}\n\ndef start_element(name, attrs):\n    open_elements[name] = True\n\ndef end_element(name):\n    del open_elements[name]\n\ndef char_data(data):\n    for element in open_elements:\n        cur = result_dict.setdefault(element, '')\n        result_dict[element] = cur + data\n\nif __name__ == '__main__':\n    p = ParserCreate()\n\n    p.StartElementHandler = start_element\n    p.EndElementHandler = end_element\n    p.CharacterDataHandler = char_data\n\n    p.Parse(u'&lt;_133_3&gt;&lt;_135_3&gt;&lt;_116_2&gt;The other system worked for about 1 month&lt;/_116_2&gt; got some good images &lt;_137_3&gt;on it then it started doing the same thing as the first one&lt;/_137_3&gt; so then I quit using either camera now they are just sitting and collecting dust.&lt;/_135_3&gt;&lt;/_133_3&gt;', 1)\n\n    print result_dict\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n from cStringIO   import StringIO\nfrom collections import defaultdict\n####from xml.etree   import cElementTree as etree\nfrom lxml import etree\n\nxml = \"&lt;e133_3&gt;&lt;e135_3&gt;&lt;e116_2&gt;The other system worked for about 1 month&lt;/e116_2&gt; got some good images &lt;e137_3&gt;on it then it started doing the same thing as the first one&lt;/e137_3&gt; so then I quit using either camera now they are just sitting and collecting dust. &lt;/e135_3&gt;&lt;/e133_3&gt;\"\n\nd = defaultdict(list)\nfor event, elem in etree.iterparse(StringIO(xml)):\n    d[''.join(elem.itertext())].append(int(elem.tag[1:-2]))\n\nprint(dict(d.items()))\n</code>\n</pre>\n", "senID": 0}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n {'on it then it started doing the same thing as the first one': [137], \n'The other system worked for about 1 month': [116], \n'The other system worked for about 1 month got some good images on it then it started doing the same thing as the first one so then I quit using \\\neither camera now they are just sitting and collecting dust. ': [133, 135]}\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I think a grammar would be the best option here.", "I found a link with some information:\nhttp://www.onlamp.com/pub/a/python/2006/01/26/pyparsing.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.onlamp.com/pub/a/python/2006/01/26/pyparsing.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.onlamp.com/pub/a/python/2006/01/26/pyparsing.html"}]}], [{"text": ["Note that you can't actually solve this by a regular expression, since they don't have the expressive power to enforce proper nesting."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Take the following mini-language:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You could make a regular expression very easily to represent a super-language of this mini-language (where you don't enforce the equality of the number of starts parentheses and end parentheses).", "You could also make a regular expression very easilty to represent any finite sub-language (where you limit yourself to some max depth of nesting).", "But you can never represent this exact language in a regular expression."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["So you'd have to use a grammar, yes."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Here's an unreliable inefficient recursive regexp solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nre_tag = re.compile(r'&lt;(?P&lt;tag&gt;[^&gt;]+)&gt;(?P&lt;content&gt;.*?)&lt;/(?P=tag)&gt;', re.S)\n\ndef iterparse(text, tag=None):\n    if tag is not None: yield tag, text\n    for m in re_tag.finditer(text):\n        for tag, text in iterparse(m.group('content'), m.group('tag')):\n            yield tag, text\n\ndef strip_tags(content):\n    nested = lambda m: re_tag.sub(nested, m.group('content'))\n    return re_tag.sub(nested, content)\n\n\ntxt = \"&lt;133_3&gt;&lt;135_3&gt;&lt;116_2&gt;The other system worked for about 1 month&lt;/116_2&gt; got some good images &lt;137_3&gt;on it then it started doing the same thing as the first one&lt;/137_3&gt; so then I quit using either camera now they are just sitting and collecting dust. &lt;/135_3&gt;&lt;/133_3&gt;\"\nd = {}\nfor tag, text in iterparse(txt):\n    d.setdefault(strip_tags(text), []).append(int(tag[:-2]))\n\nprint(d)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {'on it then it started doing the same thing as the first one': [137], \n 'The other system worked for about 1 month': [116], \n 'The other system worked for about 1 month got some good images on it then it started doing the same thing as the first one so then I quit using \\\n either camera now they are just sitting and collecting dust. ': [133, 135]}\n</code>\n</pre>\n", "senID": 3}]]