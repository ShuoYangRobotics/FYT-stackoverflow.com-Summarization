[[{"text": ["It sounds like edit (or Levenshtein) distance is precisely the right tool for the job."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is one Python implementation that can be used on lists of integers: http://hetland.org/coding/python/levenshtein.py"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://hetland.org/coding/python/levenshtein.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://hetland.org/coding/python/levenshtein.py"}]}, {"text": ["Using that code, levenshtein([1,8,3,9,4,9,3,8,1,2,3], [1,8,1,3,9,4,9,3,8,1,2,3]) returns 1, which is the edit distance."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "levenshtein([1,8,3,9,4,9,3,8,1,2,3], [1,8,1,3,9,4,9,3,8,1,2,3])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Given the edit distance and the lengths of the two arrays, computing a \"percentage similarity\" metric should be pretty trivial."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You can use the difflib module  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "difflib", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/difflib.html"}]}, {"text": ["Which gives :"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s1=[1,8,3,9,4,9,3,8,1,2,3]\n &gt;&gt;&gt; s2=[1,8,1,3,9,4,9,3,8,1,2,3]\n &gt;&gt;&gt; sm=difflib.SequenceMatcher(None,s1,s2)\n &gt;&gt;&gt; sm.ratio()\n 0.9565217391304348\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Just use the same algorithm for calculating edit distance on strings if the values don't have any particular meaning."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Unless im missing the point."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import division\n\ndef similar(x,y):\n    si = 0\n    for a,b in zip(x, y):\n        if a == b:\n            si += 1\n    return (si/len(x)) * 100\n\n\nif __name__ in '__main__':\n    a = [1,8,3,9,4,9,3,8,1,2,3] \n    b = [1,8,1,3,9,4,9,3,8,1,2,3]\n    result = similar(a,b)\n    if result is not None:\n        print \"%s%s Similar!\" % (result,'%')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["One way to tackle this is to utilize histogram.", "As an example (demonstration with numpy):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "histogram", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Histogram"}, {"text": "numpy", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.numpy.org/"}]}, {"code": "<pre>\n<code>\n In []: a= array([1,8,3,9,4,9,3,8,1,2,3])\nIn []: b= array([1,8,1,3,9,4,9,3,8,1,2,3])\n\nIn []: a_c, _= histogram(a, arange(9)+ 1)\nIn []: a_c\nOut[]: array([2, 1, 3, 1, 0, 0, 0, 4])\n\nIn []: b_c, _= histogram(b, arange(9)+ 1)\nIn []: b_c\nOut[]: array([3, 1, 3, 1, 0, 0, 0, 4])\n\nIn []: (a_c- b_c).sum()\nOut[]: -1\n</code>\n</pre>\n", "senID": 1}, {"text": ["There exist now plethora of ways to harness a_c and b_c.  "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "a_c", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b_c", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Where the (seemingly) simplest similarity measure is:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n In []: 1- abs(-1/ 9.)\nOut[]: 0.8888888888888888\n</code>\n</pre>\n", "senID": 4}, {"text": ["Followed by:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n In []: norm(a_c)/ norm(b_c)\nOut[]: 0.92796072713833688\n</code>\n</pre>\n", "senID": 6}, {"text": ["and:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n In []: a_n= (a_c/ norm(a_c))[:, None]\nIn []: 1- norm(b_c- dot(dot(a_n, a_n.T), b_c))/ norm(b_c)\nOut[]: 0.84445724579043624\n</code>\n</pre>\n", "senID": 8}, {"text": ["Thus, you need to be much more specific to find out most suitable similarity measure suitable for your purposes."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["I've implemented something for a similar task a long time ago.", "Now, I have only a blog entry for that.", "It was simple: you had to compute the pdf of both sequences then it would find the common area covered by the graphical representation of pdf."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "a blog entry for that", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pgraycode.wordpress.com/2009/09/21/uniformity/"}]}, {"text": ["Sorry for the broken images on link, the external server that I've used back then is dead now."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Right now, for your problem the code translates to"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def overlap(pdf1, pdf2):\n    s = 0\n    for k in pdf1:\n        if pdf2.has_key(k):\n            s += min(pdf1[k], pdf2[k])\n    return s\n\ndef pdf(l):\n    d = {}\n    s = 0.0\n    for i in l:\n        s += i\n        if d.has_key(i):\n            d[i] += 1\n        else:\n            d[i] = 1\n    for k in d:\n        d[k] /= s\n    return d\n\ndef solve():\n    a = [1, 8, 3, 9, 4, 9, 3, 8, 1, 2, 3]\n    b = [1, 8, 1, 3, 9, 4, 9, 3, 8, 1, 2, 3]\n    pdf_a = pdf(a)\n    pdf_b = pdf(b)\n    print pdf_a\n    print pdf_b\n    print overlap(pdf_a, pdf_b)\n    print overlap(pdf_b, pdf_a)\n\nif __name__ == '__main__':\n    solve()\n</code>\n</pre>\n", "senID": 3}, {"text": ["Unfortunately, it gives an unexpected answer, only 0.212292609351"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "0.212292609351", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]