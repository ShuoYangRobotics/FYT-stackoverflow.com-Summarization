[[{"text": ["Python does not have a preprocessor, although you could run your python source through an external preprocessor to get the same effect - e.g.", "sed \"/logging.debug/d\" will strip out all the debug logging commands.", "This is not very elegant though - you will end up needing some sort of build system to run all your modules through the preprocessor and perhaps create a new directory tree of the processed .py files before running the main script."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sed \"/logging.debug/d\"", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Alternatively if you put all your debug statements in an if __debug__: block they will get optimised out when python is run with the -O (optimise) flag."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "if __debug__:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["As an aside, I checked the code with the dis module to ensure that it did get optimised away.", "I discovered that both"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if __debug__: doStuff()\n</code>\n</pre>\n", "senID": 3}, {"text": ["and"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n if 0: doStuff()\n</code>\n</pre>\n", "senID": 5}, {"text": ["are optimised, but "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n if False: doStuff()\n</code>\n</pre>\n", "senID": 7}, {"text": ["is not.", "This is because False is a regular Python object, and you can in fact do this:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; False = True\n&gt;&gt;&gt; if False: print \"Illogical, captain\"\nIllogical, captain\n</code>\n</pre>\n", "senID": 9}, {"text": ["Which seems to me a flaw in the language - hopefully it is fixed in Python 3."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This is fixed in Python 3:  Assigning to True or False now gives a SyntaxError.", "Since True and False are constants in Python 3, it means that if False: doStuff() is now optimised:"], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "now gives a SyntaxError", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/3.0/library/constants.html"}, {"text": "if False: doStuff()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def f():\n...     if False: print( \"illogical\")\n... \n&gt;&gt;&gt; dis.dis(f)\n  2           0 LOAD_CONST               0 (None) \n              3 RETURN_VALUE\n</code>\n</pre>\n", "senID": 13}], [{"text": ["Well, you can always implement your own simple preprocessor that does the trick.", "Or, even better, you can use an already existing one.", "Say http://code.google.com/p/preprocess/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.google.com/p/preprocess/", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://code.google.com/p/preprocess/"}]}], [{"text": ["Although I think the question is perfectly clear and valid (notwithstanding the many responses that suggest otherwise), the short answer is \"there's no support in Python for this\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The only potential solution other than the preprocessor suggestion would be to use some bytecode hacking.", "I won't even begin to imagine how this should work in terms of the high-level API, but at a low level you could imagine examining code objects for particular sequences of instructions and re-writing them to eliminate them.  "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "preprocessor suggestion", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2006190/python-equivalent-of-define-func-or-how-to-comment-out-a-function-call-in-p/2006874#2006874"}, {"text": "bytecode hacking", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.google.ca/search?hl=en&source=hp&q=python+bytecode+hack&btnG=Google+Search&meta=&aq=f&oq="}]}, {"text": ["For example, look at the following two functions:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def func():\n...    if debug:  # analogous to if __debug__:\n...       foo\n&gt;&gt;&gt; dis.dis(func)\n  2           0 LOAD_GLOBAL              0 (debug)\n              3 JUMP_IF_FALSE            8 (to 14)\n              6 POP_TOP\n\n  3           7 LOAD_GLOBAL              1 (foo)\n             10 POP_TOP\n             11 JUMP_FORWARD             1 (to 15)\n        &gt;&gt;   14 POP_TOP\n        &gt;&gt;   15 LOAD_CONST               0 (None)\n             18 RETURN_VALUE\n</code>\n</pre>\n", "senID": 3}, {"text": ["Here you could scan for the LOAD_GLOBAL of debug, and eliminate it and everything up to the JUMP_IF_FALSE target."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "LOAD_GLOBAL", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "debug", "childNum": 0, "tag": "code", "childList": []}, {"text": "JUMP_IF_FALSE", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This one is the more traditional C-style debug() function that gets nicely obliterated by a preprocessor:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def func2():\n...    debug('bar', baz)\n&gt;&gt;&gt; dis.dis(func2)\n  2           0 LOAD_GLOBAL              0 (debug)\n              3 LOAD_CONST               1 ('bar')\n              6 LOAD_GLOBAL              1 (baz)\n              9 CALL_FUNCTION            2\n             12 POP_TOP\n             13 LOAD_CONST               0 (None)\n             16 RETURN_VALUE\n</code>\n</pre>\n", "senID": 6}, {"text": ["Here you would look for LOAD_GLOBAL of debug and wipe everything up to the corresponding CALL_FUNCTION."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "LOAD_GLOBAL", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "debug", "childNum": 0, "tag": "code", "childList": []}, {"text": "CALL_FUNCTION", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Of course, both of those descriptions of what you would do are far simpler than what you'd really need for all but the most simplistic patterns of use, but I think it would be feasible.", "Would make a cute project, if nobody's already done it."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Use a module scoped variable?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["from config_module import debug_flag"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "from config_module import debug_flag", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["and use this \"variable\" to gate access to the logging function(s).", "You would build yourself a logging module that uses the debug_flag to gate the logging functionality."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "logging", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "debug_flag", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I think that completely aboiding the calling on a function is not posible, as Python works in a different way that C. The #define takes place in the pre-compiler, before the code is compiled.", "In Python, there's no such thing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want to completely remove the calling to debug in a work environment, I think the only way if to actually change the code before execution.", "With a script previous to execution you could comment/uncomment the debug lines. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Something like this: "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["File logging.py"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n #Main module\ndef log():\n    print 'logging'\n\ndef main():\n    log()\n    print 'Hello'\n    log()\n</code>\n</pre>\n", "senID": 4}, {"text": ["File call_log.py"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import re\n#To log or not to log, that's the question\nlog = True\n\n#Change the loging\nwith open('logging.py') as f:\n    new_data = []\n    for line in f:\n       if not log and re.match(r'\\s*log.*', line):\n         #Comment\n         line = '#' + line\n       if log and re.match(r'#\\s*log.*', line):\n         #Uncomment\n         line = line[1:]\n       new_data.append(line)\n\n#Save file with adequate log level\nwith open('logging.py', 'w') as f:\n   f.write(''.join(new_data))\n\n\n#Call the module\nimport logging\nlogging.main()\n</code>\n</pre>\n", "senID": 6}, {"text": ["Of course, it has its problems, specially if there are a lot of modules and are complex, but could be usable if you need to absolutely avoid the calling to a function."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Before you do this, have you profiled to verify that the logging is actually taking a substantial amount of time?", "You may find that you spend more time trying to remove the calls than you save."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Next, have you tried something like Psyco?", "If you've got things set up so logging is disabled, then Psyco may be able to optimise away most of the overhead of calling the logging function, noticing that it will always return without action."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Psyco", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://psyco.sourceforge.net/"}]}, {"text": ["If you still find logging taking an appreciable amount of time, you might then want to look at overriding the logging function inside critical loops, possibly by binding a local variable to either the logging function or a dummy function as appropriate (or by checking for None before calling it)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["define a function that does nothing, ie"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def nuzzing(*args, **kwargs): pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then just overload all the functions you want to get rid of with your function, ala"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n logging.debug = nuzzing\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I like the 'if _debug' solution except that putting it in front of every call is a bit distracting and ugly.", "I had this same problem and overcame it by writing a script which automatically parses your source files and replaces logging statements with pass statements (and commented out copies of the logging statements).", "It can also undo this conversion."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "debug", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I use it when I deploy new code to a production environment when there are lots of logging statements which I don't need in a production setting and they are affecting performance."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can find the script here: http://dound.com/2010/02/python-logging-performance/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://dound.com/2010/02/python-logging-performance/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://dound.com/2010/02/python-logging-performance/"}]}], [{"text": ["You can't skip function calls.", "You could redefine these as empty though, e.g.", "by creating another logging object that provides the same interface, but with empty functions."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "skip", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["But by far the cleanest approach is to ignore the low priority log messages (as you suggested):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n logging.root.setLevel(logging.CRITICAL)\n</code>\n</pre>\n", "senID": 2}]]