[[{"text": ["Scipy's clustering implementations work well, and they include a k-means implementation.", "There's a scipy kmeans example here."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Scipy's clustering", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/scipy/reference/cluster.html"}, {"text": "k-means", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/scipy/reference/cluster.vq.html"}, {"text": "example", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://hackmap.blogspot.com/2007/09/k-means-clustering-in-scipy.html"}]}, {"text": ["There's also scipy-cluster, which does agglomerative clustering; ths has the advantage that you don't need to decide on the number of clusters ahead of time."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "scipy-cluster", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/scipy-cluster/"}]}], [{"text": ["SciPy's kmeans2() has some numerical problems: others have reported error messages such as \"Matrix is not positive definite - Cholesky decomposition cannot be computed\" in version 0.6.0, and I just encountered the same in version 0.7.1."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "kmeans2()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/scipy/reference/cluster.vq.html"}, {"href": "http://mail.scipy.org/pipermail/scipy-user/2009-February/019777.html", "text": "reported", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["For now, I would recommend using PyCluster instead.", "Example usage:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "PyCluster", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bonsai.ims.u-tokyo.ac.jp/~mdehoon/software/cluster/software.htm#pycluster"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import numpy\n&gt;&gt;&gt; import Pycluster\n&gt;&gt;&gt; points = numpy.vstack([numpy.random.multivariate_normal(mean, \n                                                            0.03 * numpy.diag([1,1]),\n                                                            20) \n                           for mean in [(1, 1), (2, 4), (3, 2)]])\n&gt;&gt;&gt; labels, error, nfound = Pycluster.kcluster(points, 3)\n&gt;&gt;&gt; labels  # Cluster number for each point\narray([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,\n       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2,\n       2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2], dtype=int32)\n&gt;&gt;&gt; error   # The within-cluster sum of distances for the solution\n1.7721661785401261\n&gt;&gt;&gt; nfound  # Number of times this solution was found\n1\n</code>\n</pre>\n", "senID": 2}], [{"text": ["From wikipedia, you could use scipy,  K-means clustering an vector quantization"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "wikipedia", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/K-means%5Fclustering"}, {"href": "http://docs.scipy.org/doc/scipy/reference/cluster.vq.html", "text": "K-means clustering an vector quantization", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Or, you could use a Python wrapper for OpenCV, ctypes-opencv."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "ctypes-opencv", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/ctypes-opencv/"}]}, {"text": ["Or you could OpenCV's new Python interface, and their kmeans implementation."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "OpenCV's new Python interface", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://opencv.willowgarage.com/wiki/PythonInterface"}, {"href": "http://opencv.willowgarage.com/documentation/python/miscellaneous%5Ffunctions.html", "text": "kmeans", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["By the way, K-Means is a very simple algorithm to implement.", "It's an educational experience to implement it yourself."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can also use GDAL, which has many many functions to work with spatial data."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["For continuous data, k-means is very easy."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You need a list of your means, and for each data point, find the mean its closest to and average the new data point to it.", "your means will represent the recent salient clusters of points in the input data."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I do the averaging continuously, so there is no need to have the old data to obtain the new average.", "Given the old average k,the next data point x, and a constant n which is the number of past data points to keep the average of, the new average is"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "k", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n k*(1-(1/n)) + n*(1/n)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Here is the full code in Python"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import division\nfrom random import random\n\n# init means and data to random values\n# use real data in your code\nmeans = [random() for i in range(10)]\ndata = [random() for i in range(1000)]\n\nparam = 0.01 # bigger numbers make the means change faster\n# must be between 0 and 1\n\nfor x in data:\n    closest_k = 0;\n    smallest_error = 9999; # this should really be positive infinity\n    for k in enumerate(means):\n        error = abs(x-k[1])\n        if error &lt; smallest_error:\n            smallest_error = error\n            closest_k = k[0]\n        means[closest_k] = means[closest_k]*(1-param) + x*(param)\n</code>\n</pre>\n", "senID": 5}, {"text": ["you could just print the means when all the data has passed through, but its much more fun to watch it change in real time.", "I used this on frequency envelopes of 20ms bits of sound and after talking to it for a minute or two, it had consistent categories for the short 'a' vowel, the long 'o' vowel, and the 's' consonant.", "wierd!"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["(Years later) this kmeans.py under is-it-possible-to-specify-your-own-distance-function-using-scikits-learn-k-means is straightforward and reasonably fast; it uses any of the 20-odd metrics in scipy.spatial.distance."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "is-it-possible-to-specify-your-own-distance-function-using-scikits-learn-k-means", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/5529625/is-it-possible-to-specify-your-own-distance-function-using-scikits-learn-k-means"}]}], [{"text": ["you can try the scikits-learn implementation:\nhttp://scikit-learn.sourceforge.net/modules/generated/scikits.learn.cluster.KMeans.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://scikit-learn.sourceforge.net/modules/generated/scikits.learn.cluster.KMeans.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://scikit-learn.sourceforge.net/modules/generated/scikits.learn.cluster.KMeans.html"}]}]]