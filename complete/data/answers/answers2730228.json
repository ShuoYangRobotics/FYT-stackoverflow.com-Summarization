[[{"text": ["I might use"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def check(somelist, player):\n  return somelist.count(player) == 3\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: as @Andrew suggested in a comment (tx @Andrew!", "), you can do even better, e.g."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def check(somelist, player):\n  return somelist.count(player) == len(somelist)\n</code>\n</pre>\n", "senID": 3}, {"text": ["without hardcoding the 3 -- which also suggests another nice alternative:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def check(somelist, player):\n  return all(x==player for x in somelist)\n</code>\n</pre>\n", "senID": 5}, {"text": ["which very directly reads \"all items in the list equal player\".", "The general point is that by refactoring to a separate method you can then play with that method's implementation -- now of course here the code is very simple so the advantage is similarly modest, but it's an excellent point to keep in mind as you move to more complicated code."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "player", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["As you've noticed you only need a bool anyway, so this allows a much simpler approach -- just return the bool expression rather than doing an if on it.", "It's important to never use a built-in name like list for your own identifiers -- an \"attractive nuisance\" of the language...;-)."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["By which I mean, Python uses for its built-ins lots of nice, attractive names like list, bool, sum, and so on, so it's easy to find yourself accidentally using one of those names for a variable of your own, and nothing bad seems to happen... until the time you need to turn, say, a tuple into a list, use the obviously best solution, x = list(thetuple)... and end up spending our trying to understand and solve the errors that come because you've used list to mean anything else than the built-in type of that name."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "x = list(thetuple)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So, just get into the habit of not using those nice built-in names for purposes other than indicating the respective builtins, and you'll save yourself much future aggravation!-)"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "not", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Back to your code, you might consider the conciseness afforded by not unpacking board (a hard decision, since your code is quite readable... but may look a bit verbose):"], "childNum": 3, "tag": "p", "senID": 10, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "board", "childNum": 0, "tag": "code", "childList": []}, {"text": "is", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n for i in range(3):\n  if check([row[i] for row in board], player):\n    return player\nif check([row[i] for i, row in enumerate(board)], player):\n    return player\nif check([row[2-i] for i, row in enumerate(board)], player):\n    return player\n</code>\n</pre>\n", "senID": 11}, {"text": ["In the end I think I'd stick with your choice -- more readable and just marginally more verbose, if at all -- but it's nice to be aware of the alternatives, I think -- here, list comprehensions and enumerate to generate the lists to be checked as an alternative to \"manually coding out\" the three possibilities."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "enumerate", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Simply make a custom iterator over board."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "board", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def get_lines(board):\n  nums = range(3)\n  for i in nums: \n    yield (board[i][j] for j in nums) #cols\n  for j in nums: \n    yield (board[i][j] for i in nums) #rows\n  yield (board[i][i] for i in nums) #diag \\\n  yield (board[i][2-i] for i in nums) #diag /\n\ndef get_winner(board): #a bit too indented\n  for line in get_lines(board): #more expensive, so go through it only once\n    for player in 'x', 'o':\n      if line == player, player, player: #other way to check victory condition\n        return player\n  return None\n</code>\n</pre>\n", "senID": 1}, {"text": ["Obviously these really should be methods of a board class :)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "board", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You could use a better name instead of check that doesn't tell much.", "The rule of thumb is: if you can think of a good name for a peace of code then it might be beneficial to move it into separate function even if it is just one line of code.", "allsame might be one of alternatives here."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "check", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "allsame", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n def winner(board):\n    main_diag = [row[i] for i, row in enumerate(board)]\n    aux_diag = [row[len(board) - i - 1] for i, row in enumerate(board)]   \n    for triple in board + zip(*board) + [main_diag, aux_diag]: \n        if allsame(triple):         \n           return triple[0]\n\ndef allsame(lst):    \n    return all(x == lst[0] for x in lst)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Personally I think your best bet for readability is to bubble out functions to give you the rows(), columns(), and diags() of the board, as lists of lists.", "Then you can iterate through these and check uniformly.", "You can even then define allTriples(), which appends the output of rows(), columns(), and diags(), so that you can do your checking in a single concise loop.", "I'd probably also make the board an object, so that these functions could become object methods."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["And now for something completely different:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Represent the board by a list of nine elements.", "Each element can be -1 (X), 1 (O), or 0 (empty):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n WIN_LINES = (\n    (0, 1, 2),\n    (3, 4, 5),\n    (6, 7, 8),\n    (0, 3, 6),\n    (1, 4, 7),\n    (2, 5, 8),\n    (2, 4, 6),\n    (0, 4, 8),\n    )\n\ndef test_for_win(board):\n    for line in WIN_LINES:\n        total = sum(board[point] for point in line)\n        if abs(total) == 3:\n            return total // 3\n    return None\n</code>\n</pre>\n", "senID": 2}, {"text": ["Refinement:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n WIN_LINES = (\n    0, 1, 2,\n    3, 4, 5,\n    6, 7, 8,\n    0, 3, 6,\n    1, 4, 7,\n    2, 5, 8,\n    2, 4, 6,\n    0, 4, 8,\n    )\n\ndef test_for_win(board):\n    wpos = 0\n    for _unused in xrange(8):\n        total  = board[WIN_LINES[wpos]]; wpos += 1\n        total += board[WIN_LINES[wpos]]; wpos += 1\n        total += board[WIN_LINES[wpos]]; wpos += 1\n        if total ==  3: return  1\n        if total == -3: return -1\n    return None\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Just an idea"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def hasWon(board):\n  players = ['x', 'o']\n  for player in players:\n    top, mid, low = board\n    game = board + [[ top[i],mid[i],low[i]] for i in range(3)] + [top[0],mid[1],low[2]] +[top[2],mid[1],low[0]]\n    if 3 in [l.count(player) for l in game] :\n      return player\n  return None\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Your solution is fine - correct, readable and understandable. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Still, if you'd want to optimize for speed, I'd use a 1-dimensional array of digits, not strings, and try to look up each number as few times as possible.", "There will certainly be an extremely awkward-looking solution in which you check every field only once.", "I don't want to construct this now.", ":) Things like that might matter if you wanted to implement an AI playing against you while exploring the entire search tree of possible moves.", "An efficient win/loss check would be necessary there."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]