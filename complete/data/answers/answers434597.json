[[{"text": ["Use the subprocess module available on Python 2.4+, not os.system, so you don't have to deal with shell escaping."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import subprocess, os\nif os.name = 'mac':\n    subprocess.call(('open', filepath))\nelif os.name = 'nt':\n    subprocess.call(('start', filepath), shell=True)\nelif os.name = 'posix':\n    subprocess.call(('xdg-open', filepath))\n</code>\n</pre>\n", "senID": 1}, {"text": ["The double parentheses are because subprocess.call wants a sequence as its first argument, so we're using a tuple here.", "On Linux systems with Gnome there is also a \"gnome-open\" command that does the same thing."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["In Mac OS, you can use the \"open\" command.", "There is a Windows API call that does something similar, but I don't remember it offhand."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Okay, the \"start\" command will do it, so this should work."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Mac OS/X:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n os.system(\"open \"+filename);\n</code>\n</pre>\n", "senID": 3}, {"text": ["Windows:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n os.system(\"start \"+filename);\n</code>\n</pre>\n", "senID": 5}, {"text": ["Okay, clearly this silly-ass controversy continues, so let's just look at doing this with subprocess."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["open and start are command interpreter things for Mac OS/X and Windows repsectively.", "Now, let's say we use subprocess.", "Canonically, you'd use:"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "open", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "start", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n try:\n    retcode = subprocess.call(\"open \" + filename, shell=True)\n    if retcode &lt; 0:\n        print &gt;&gt;sys.stderr, \"Child was terminated by signal\", -retcode\n    else:\n        print &gt;&gt;sys.stderr, \"Child returned\", retcode\nexcept OSError, e:\n    print &gt;&gt;sys.stderr, \"Execution failed:\", e\n</code>\n</pre>\n", "senID": 8}, {"text": ["Now, what are the advantages of this?", "In theory, this is more secure -- but in fact we're needing to execute a command line one way or the other; in either environment, we need the environment and services to interpet, get paths, and so forth.", "In neither case are we executing arbitrary text, so it doesn't have an inherent \"but you can type 'filename ; rm -rf /'\" problem, and IF the file name can be corrupted, using subprocess.call gives us no protection."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "'filename ; rm -rf /'", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "subprocess.call", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It doesn't actually give us any more error detection, we're still depending on the retcode in either case.", "We don't need to wait for the child process, since we're by problem statement starting a separate process."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "retcode", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["\"But subprocess is preferred.", "\"  However, os.system() is not deprecated, and it's the simplest tool for this particular job."], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "subprocess", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "os.system()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Conclusion: using os.system() is the simplest, most straightforward way to do this, and is therefore a correct answer."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "os.system()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Just for completeness (it wasn't in the question), xdg-open will do the same on Linux."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "xdg-open", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://portland.freedesktop.org/xdg-utils-1.0/xdg-open.html"}]}], [{"code": "<pre>\n<code>\n import os\nimport subprocess\n\ndef click_on_file(filename):\n    try:\n        os.startfile(filename):\n    except AttributeError:\n        subprocess.call(['open', filename])\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I prefer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n os.startfile(path, 'open')\n</code>\n</pre>\n", "senID": 1}, {"text": ["(python docs) 'open' does not have to be added (it is the default).", "The docs specifically mention that this is like double-clicking on a file's icon in Windows Explorer."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "python docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/os.html#os.startfile"}]}, {"text": ["Edit: Windows only"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Start does not support long path names and white spaces.", "You have to convert it to 8.3 compatible paths."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import subprocess\nimport win32api\n\nfilename = \"C:\\\\Documents and Settings\\\\user\\\\Desktop\\file.avi\"\nfilename_short = win32api.GetShortPathName(filename)\n\nsubprocess.Popen('start ' + filename_short, shell=True )\n</code>\n</pre>\n", "senID": 1}, {"text": ["The file has to exist in order to work with the API call."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["on mac os you can call 'open'"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\nos.popen(\"open myfile.txt\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["this would open the file with TextEdit, or whatever app is set as default for this filetype"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you want to go the sybprocess.call() way, it should look like this on Windows:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sybprocess.call()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import subprocess\nsubprocess.call(('cmd', '/C', 'start', '', FILE_NAME))\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can't just use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n supbrocess.call(('start', FILE_NAME))\n</code>\n</pre>\n", "senID": 3}, {"text": ["because start is not an executable but a command of the cmd.exe program.", "This works:"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "start", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "is not an executable", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://frank.neatstep.com/node/84"}, {"text": "cmd.exe", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n subprocess.call(('cmd', '/C', 'start', FILE_NAME))\n</code>\n</pre>\n", "senID": 5}, {"text": ["but only if there are no spaces in the FILE_NAME."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["While subprocess.call method enquotes the parameters properly, the start command has a rather strange syntax, where:"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "subprocess.call", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "start", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n start notes.txt\n</code>\n</pre>\n", "senID": 8}, {"text": ["does something else than:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n start \"notes.txt\"\n</code>\n</pre>\n", "senID": 10}, {"text": ["The first quoted string should set the title of the window.", "To make it work with spaces, we have to do:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n start \"\" \"my notes.txt\"\n</code>\n</pre>\n", "senID": 12}, {"text": ["which is what the code on top does."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["I am pretty late to the lot, but here is a solution using the windows api.", "This always opens the associated application."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import ctypes\n\nshell32 = ctypes.windll.shell32\nfile = 'somedocument.doc'\n\nshell32.ShellExecuteA(0,\"open\",file,0,0,5)\n</code>\n</pre>\n", "senID": 1}, {"text": ["A lot of magic constants.", "The first zero is the hwnd of the current program.", "Can be zero.", "The other two zeros are optional parameters (parameters and directory).", "5 == SW_SHOW, it specifies how to execute the app.", "Read the \nShellExecute API docs for more info."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "ShellExecute API docs", "tag": "a", "pos": 5, "childList": [], "childNum": 0, "href": "http://msdn.microsoft.com/en-us/library/bb762153%28v=vs.85%29.aspx"}]}], [{"text": ["If you want to specify the app to open the file with on Mac OS X, use this:\nos.system(\"open -a [app name] [file name]\")"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "os.system(\"open -a [app name] [file name]\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]