[[{"text": ["it means any character zero or more times, followed by the literal dot and letters pdf (due to the greedy nature of the asterisk, it's basically guaranteed that the '.pdf' are going to be at the end of the subject string)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "'.pdf'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["There is glob module to do this the right way:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "glob", "tag": "a", "pos": 0, "childList": [{"text": "glob", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/glob.html"}, {"text": "glob", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; glob.glob(os.path.join(dirname, '*.pdf'))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Wrong question, you missed a crucial character of the expression.", ";-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In fact, .", "* will match any character (.", "in regex), as many times as possible (* in regex; relates to the previous string, so .", "in this case)."], "childNum": 6, "tag": "p", "senID": 1, "childList": [{"text": ".*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "any", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": ".", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "as many times as possible", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": ".", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["\\., on the other hand, will match exactly one dot (.).", "\\ escapes the following character (.", ") so it does no longer have its special meaning (e.g.", "in this case \u201cmatch any character\u201d) but rather it will be treated as-is."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "\\.", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\\", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": ".", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "any", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}], [{"text": ["The .", "means match any character but \"\\n\".", "The * means \"repeat the previous character 0 or more times\".", "The \\.", "matches an actual \".", "\"."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": ".", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "*", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "\\.", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["BTW, this is all in the docs."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "the docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html"}]}], [{"text": ["This searches for a string containing zero or more chars followed by \".pdf\"  The .", "* is a common idiom in regexps and it means match any char 0 or more times.", "The .", "is because in regexps, the .", "has a special meaning, and the \\ escapes that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The period (.", ")\nwill match any character except newlines"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "The period (.)", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["The following asterisk (*)\n   means unlimited number of repetitions\n   of the preceding period"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "The following asterisk (*)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["The backslash ()\nescapes the period in .pdf So it looks for a real\n   period, so ONLY the .pdf and not \"any\n   character\".pdf again'"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "The backslash ()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["So in the end it looks for\nAny piece of text that ends in .pdf"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["use os.walk() instead.", "And there's no need to use regex."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "os.walk()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/os.html"}]}, {"code": "<pre>\n<code>\n for r,d,f in os.walk(path):\n    for files in f:\n        if files[-4:].lower() == \".pdf\":\n             print \"found pdf: \",os.path.join(r,files)\n</code>\n</pre>\n", "senID": 1}]]