[[{"text": ["You can use psutil (http://code.google.com/p/psutil) which works on Windows and UNIX:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.google.com/p/psutil", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/psutil"}]}, {"code": "<pre>\nimport psutil\n\nPROCNAME = \"python.exe\"\n\nfor proc in psutil.process_iter():\n    if proc.name == PROCNAME:\n        print proc\n</pre>\n", "senID": 1}, {"text": ["The code above on my machines  prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\npsutil.Process (PID:2908; PPID:3944; NAME:'python.exe'; PATH:'C:\\Python26'; CMDL\nINE:['C:\\\\Python26\\\\python.exe', 'D:\\\\pyftpdlib\\\\svn\\\\psutil\\\\foo.py']; UID:-1;\nGID:-1;)\n</pre>\n", "senID": 3}], [{"text": ["There's no single cross-platform API, you'll have to check for OS.", "For posix based use /proc.", "For Windows use following code to get list of all pids with coresponding process names"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from win32com.client import GetObject\nWMI = GetObject('winmgmts:')\nprocesses = WMI.InstancesOf('Win32_Process')\nprocess_list = [(p.Properties_(\"ProcessID\").Value, p.Properties_(\"Name\").Value) for p in processes]\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can then easily filter out processes you need.", "For more info on available properties of Win32_Process check out Win32_Process Class"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Win32_Process Class", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://msdn.microsoft.com/en-us/library/aa394372%28VS.85%29.aspx"}]}], [{"text": ["I don't think you will be able to find a purely python-based, portable solution without using /proc or command line utilities, at least not in python itself.", "Parsing os.system is not ugly - someone has to deal with the multiple platforms, be it you or someone else.", "Implementing it for the OS you are interested in should be fairly easy, honestly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["First, Windows (in all it's incarnations) is a non-standard OS."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Linux (and most proprietary unixen) are POSIX-compliant standard operating systems."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The C libraries reflect this dichotomy.", "Python reflects the C libraries."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["There is no \"cross-platform\" way to do this.", "You have to hack up something with ctypes for a particular release of Windows (XP or Vista)"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "ctypes", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-ctypes.html"}]}], [{"text": ["There isn't, I'm afraid.", "Processes are uniquely identified by pid not by name.", "If you really must find a pid by name, then you will have use something like you have suggested, but it won't be portable and probably will not work in all cases."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you only have to find the pids for a certain application and you have control over this application, then I'd suggest changing this app to store its pid in files in some location where your script can find it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["For jython, if Java 5 is used, then you can get the Java process id as following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["from java.lang.management import *\npid = ManagementFactory.getRuntimeMXBean().getName()"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}]]