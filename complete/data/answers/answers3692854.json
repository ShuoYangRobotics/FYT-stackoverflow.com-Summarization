[[{"text": ["You seem to think that you are trying to avoid a \u201csimple\u201d race condition such as in"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ... = zmq_recv(fd);\ndo_something();\nzmq_send(fd, answer);\n/* Let's hope a new request does not arrive just now, please close it quickly! */\nzmq_close(fd);\n</code>\n</pre>\n", "senID": 1}, {"text": ["but I think the problem is that fair queuing (round-robin) makes things even more difficult: you might already even have several queued requests on your worker.", "The sender will not wait for your worker to be free before sending a new request if it is its turn to receive one, so at the time you call zmq_send other requests might be waiting already."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "zmq_send", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In fact, it looks like you might have selected the wrong data direction.", "Instead of having a requests pool send requests to your workers (even when you would prefer not to receive new ones), you might want to have your workers fetch a new request from a requests queue, take care of it, then send the answer."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Of course, it means using XREP/XREQ, but I think it is worth it."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "XREP", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "XREQ", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: I wrote some code implementing the other direction to explain what I mean."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "https://github.com/samueltardieu/zmq-broker", "text": "some code", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://www.rfc1149.net/blog/2010/12/08/responsible-workers-with-0mq/", "text": "the other direction", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I've been thinking about this as well.", "You may want to implement a CLOSE message which notifies the customer that the worker is going away.", "You could then have the worker drain for a period of time before shutting down.", "Not ideal, of course, but might be workable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I think the problem is that your messaging architecture is wrong.", "Your workers should use a REQ socket to send a request for work and that way there is only ever one job queued at the worker.", "Then to acknowledge completion of the work, you could either use another REQ request that doubles as ack for the previous job and request for a new one, or you could have a second control socket."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Some people do this using PUB/SUB for the control so that each worker publishes acks and the master subscribes to them."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You have to remember that with ZeroMQ there are 0 message queues.", "None at all!", "Just messages buffered in either the sender or receiver depending on settings like High Water Mark, and type of socket.", "If you really do need message queues then you need to write a broker app to handle that, or simply switch to AMQP where all communication is through a 3rd party broker."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["There is a conflict of interest between sending requests as rapidly as possible to workers, and getting reliability in case a worked crashes or dies.", "There is an entire section of the ZeroMQ Guide that explains different answers to this question of reliability.", "Read that, it'll help a lot."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["tl;dr workers can/will crash and clients need a resend functionality.", "The Guide provides reusable code for that, in many languages."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Wouldn't the simplest solution be to have the customer timeout when waiting for the reply and then retry if no reply is received?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Try sleeping before the call to close.", "This is fixed in 2.1 but not in 2.0 yet."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]