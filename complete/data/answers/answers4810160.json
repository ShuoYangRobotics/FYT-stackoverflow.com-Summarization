[[{"text": ["You could do something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = [1,2,3,4,5]\nb = iter(a)\n\ntry:\n    while True:\n        c = b.next()\n        if (condition):\n            c = b.next()\nexcept StopIteration:\n    pass\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If the item you're using over is an iterable object you can use item.next() to grab the next element.", "But you'll need to make sure to grab the StopIteration exception if needed."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "item.next()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "StopIteration", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; it = iter(range(5))\n&gt;&gt;&gt; for x in it:\n...     print x\n...     if x &gt; 3:\n...         print it.next()\n... \n0 1 2 3 4\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 4, in &lt;module&gt;\nStopIteration\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You want the continue statement."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "continue", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/controlflow.html"}]}, {"code": "<pre>\n<code>\n for x in list:\n  if(condition):\n      continue\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n skip = False\nfor x in list:\n    if skip:\n        skip = False\n        continue\n    # Do your main loop logic here\n    if (condition):\n        skip = True\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You can use a while loop instead of a for.", "In pseudocode:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "while", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n idx = 0\nwhile idx &lt; length(list)\n    x = list[idx]\n    ...\n    if (condition)\n        idx += 1\n    ...\n    idx += 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can always bypass the for loop and just use the iterator explicitly:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n iter = list.__iter__()\nwhile True:\n    x = iter.next()\n    ...\n    if (condition):\n        x = iter.next()\n    ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will throw a StopIteration exception when it reaches the end of the list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I suspect that your approach to parsing an if statement is not a good way to go about it.", "You will also find that you can't nest your IF statements nor put them all one one line.", "Here is how I would go about it. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["a) Convert your language into a BNF form.", "For example, for an if statment it might be "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n ifstmnt ::=  IF &amp;lt;condiftion&gt; THEN &amp;lt;trueblock&gt; [ ELSE &amp;lt;elseblock&gt; ]\n\nstatment ::= ifstmnt | assignstment | whilestmnt | forstmnt\n</code>\n</pre>\n", "senID": 2}, {"text": ["etc"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["b) Work out what you are waiting for at each point.", "After the IF, you read a condition until you see THEN. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["c) Write a getNextToken routine that reads characters from your source, until it has a complete token.", "A token is a recognisable unit - IF, THEN, A number, a symbol.", "Every time it is called it returns the token into a buffer.", "It is usefull to have a type and a value returned as well - it will save you converting numbers in many places.", "A table driven approach is very fast and flexible. "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["d) Then write lots of little routines to recognise each type of statement.", "One for IF, one for condition, one for block, one for statement, one for expression etc.", "These will call each other and return when they have recognised the statement.", "For example, the condition expression recogniser will read a boolean expression and eat all names, AND, OR etc, until it looks ahead and sees THEN.", "It can't handle THEN so it exists, and the IF recoogniser finds the token is THEN, it reads the next and calls the recogniser for a block (which might expect BEGIN, lots of statments and then END). "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["e) Each routine collects the data it needs - condition, trueblock, falseblock, and handles it as required.", "A very common treatment is to create a tree representation of the program in memory.", "Programmer defined  names are collected in a dictionary as they are defined, and checked as they are used. "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["f) A real compiler will then try to re-arange the tree to make things more efficent - but I suggest that is a future develoment"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["g) The final action is then to walk the tree, evaluating it in some way.", "If you are writng an interpreter you can calulate the values and store then as you go - store the values in the doctionary.", "If you are writting a true compiler you will need to generate a suitable output for the linker.", "That is a major task. "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Check out YACC and LEX.", "They are tools designed to do parts of the job, and will save you time.", "The terms to help your research are \"lexical analysis\" \"parser\" and similar. "], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["And good luck.", "Your project is non-trivial! "], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["See also http://nedbatchelder.com/text/python-parsers.html "], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "http://nedbatchelder.com/text/python-parsers.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://nedbatchelder.com/text/python-parsers.html"}]}]]