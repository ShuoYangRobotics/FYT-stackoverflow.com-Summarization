[[{"text": ["Reclassing instances like this is done in Mercurial (a distributed revision control system) when extensions (plugins) want to change the object that represent the local repository.", "The object is called repo and is initially a localrepo instance.", "It is passed to each extension in turn and, when needed, extensions will define a new class which is a subclass of repo.__class__ and change the class of repo to this new subclass!"], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "Mercurial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://selenic.com/mercurial/"}, {"text": "repo", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "localrepo", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "repo.__class__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "change", "childNum": 0, "tag": "em", "childList": []}, {"text": "repo", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It looks like this in code:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "like this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.selenic.com/hg/index.cgi/file/d19ab9a56bf4/hgext/bookmarks.py#l229"}]}, {"code": "<pre>\n<code>\n def reposetup(ui, repo):\n    # ...\n\n    class bookmark_repo(repo.__class__): \n        def rollback(self):\n            if os.path.exists(self.join('undo.bookmarks')):\n                util.rename(self.join('undo.bookmarks'), self.join('bookmarks'))\n            return super(bookmark_repo, self).rollback() \n\n        # ...\n\n    repo.__class__ = bookmark_repo\n</code>\n</pre>\n", "senID": 2}, {"text": ["The extension (I took the code from the bookmarks extension) defines a module level function called reposetup.", "Mercurial will call this when initializing the extension and pass a ui (user interface) and repo (repository) argument."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "reposetup", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ui", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "repo", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The function then defines a subclass of whatever class repo happens to be.", "It would not suffice to simply subclass localrepo since extensions need to be able to extend each other.", "So if the first extension changes repo.__class__ to foo_repo, the next extension should change repo.__class__ to a subclass of foo_repo and not just a subclass of localrepo.", "Finally the function changes the instance\u00f8's class, just like you did in your code."], "childNum": 8, "tag": "p", "senID": 4, "childList": [{"text": "repo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "localrepo", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "repo.__class__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "foo_repo", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "repo.__class__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "foo_repo", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "localrepo", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["I hope this code can show a legitimate use of this language feature.", "I think it's the only place where I've seen it used in the wild."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I'm not sure that the use of inheritance is best in this case (at least with regards to \"reclassing\").", "It seems like you're on the right track, but it sounds like composition or aggregation would be best for this.", "Here's an example of what I'm thinking of (in untested, pseudo-esque code):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from copy import copy\n\n# As long as none of these attributes are defined in the base class,\n# this should be safe\nclass SkilledProgrammer(Programmer):\n    def __init__(self, *skillsets):\n        super(SkilledProgrammer, self).__init__()\n        self.skillsets = set(skillsets)\n\ndef teach(programmer, other_programmer):\n    \"\"\"If other_programmer has skillsets, append this programmer's\n       skillsets.  Otherwise, create a new skillset that is a copy\n       of this programmer's\"\"\"\n    if hasattr(other_programmer, skillsets) and other_programmer.skillsets:\n        other_programmer.skillsets.union(programmer.skillsets)\n    else:\n        other_programmer.skillsets = copy(programmer.skillsets)\ndef has_skill(programmer, skill):\n    for skillset in programmer.skillsets:\n        if skill in skillset.skills\n            return True\n    return False\ndef has_skillset(programmer, skillset):\n    return skillset in programmer.skillsets\n\n\nclass SkillSet(object):\n    def __init__(self, *skills):\n        self.skills = set(skills)\n\nC = SkillSet(\"malloc\",\"free\",\"pointer arithmetic\",\"curly braces\")\nSQL = SkillSet(\"SELECT\", \"INSERT\", \"DELETE\", \"UPDATE\")\n\nBob = SkilledProgrammer(C)\nJill = Programmer()\n\nteach(Bob, Jill)          #teaches Jill C\nhas_skill(Jill, \"malloc\") #should return True\nhas_skillset(Jill, SQL)   #should return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["You may have to read more about sets and arbitrary argument lists if you aren't familiar with them to get this example."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "sets", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#set"}, {"href": "http://docs.python.org/tutorial/controlflow.html#arbitrary-argument-lists", "text": "arbitrary argument lists", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["This is fine.", "I've used this idiom plenty of times.", "One thing to keep in mind though is that this idea doesn't play well with old-style classes and various C extensions.", "Normally this wouldn't be an issue, but since you are using an external library you'll just have to make sure you're not dealing with any old-style classes or C extensions."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["\"The State Pattern allows an object to alter its behavior when its internal state changes.", "The object will appear to change it's class.", "\" - Head First Design Pattern.", "Something very similar write Gamma et.al.", "in their Design Patterns book.", "(I have it at my other place, so no quote).", "I think that's the whole point of this design pattern.", "But if I can change the class of an object at runtime, most of the time i don't need the pattern (there are cases when State Pattern does more than simulate a class change)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also, changing class at runtime doesn't always work:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    def __init__(self, val):\n        self.val = val\n    def get_val(self):\n        return self.val\n\nclass B(A):\n    def __init__(self, val1, val2):\n        A.__init__(self, val1)\n        self.val2 = val2\n    def get_val(self):\n        return self.val + self.val2\n\n\na = A(3)\nb = B(4, 6)\n\nprint a.get_val()\nprint b.get_val()\n\na.__class__ = B\n\nprint a.get_val() # oops!\n</code>\n</pre>\n", "senID": 2}, {"text": ["Apart from that, I consider changing class at runtime Pythonic and use it from time to time."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Heheh, fun example."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\"Reclassing\" is pretty weird, at first glance.", "What about the 'copy constructor' approach?", "You can do this with the Reflection-like hasattr, getattr and setattr.", "This code will copy everything from one object to another, unless it already exists.", "If you don't want to copy methods, you can exclude them; see the commented if."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "hasattr", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "getattr", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "setattr", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "if", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"code": "<pre>\n<code>\n class Foo(object):\n    def __init__(self):\n        self.cow = 2\n        self.moose = 6\n\nclass Bar(object):\n    def __init__(self):\n        self.cat = 2\n        self.cow = 11\n\n    def from_foo(foo):\n        bar = Bar()\n        attributes = dir(foo)\n        for attr in attributes:\n            if (hasattr(bar, attr)):\n                break\n            value = getattr(foo, attr)\n            # if hasattr(value, '__call__'):\n            #     break # skip callables (i.e. functions)\n            setattr(bar, attr, value)\n\n        return bar\n</code>\n</pre>\n", "senID": 2}, {"text": ["All this reflection isn't pretty, but sometimes you need an ugly reflection machine to make cool stuff happen.", ";)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This technique seems reasonably Pythonic to me.", "Composition would also be a good choice, but assigning to __class__ is perfectly valid (see here for a recipe that uses it in a slightly different way)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__class__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://code.activestate.com/recipes/68429/", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I will say this is perfectly fine, if it works for you."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]