[[{"text": ["Yes, but only with new-style classes.", "Use the super() function:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "new-style classes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/glossary.html#term-new-style-class"}, {"text": "super()", "tag": "a", "pos": 1, "childList": [{"text": "super()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#super"}, {"text": "super()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class Foo(Bar):\n    def baz(self, arg):\n        return super(Foo, self).baz(arg)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["ImmediateParentClass.frotz(self) will be just fine, whether the immediate parent class defined frotz itself or inherited it.", "super is only needed for proper support of multiple inheritance (and then it only works if every class uses it properly).", "In general, AnyClass.whatever is going to look up 'whatever' in AnyClass's ancestors if AnyClass doesn't define/override it, and this holds true for \"child class calling parent's method\" as for any other occurrence!"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "multiple", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["Python also has super as well: "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "super", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html"}]}, {"text": ["super(type[, object-or-type])"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "super(type[, object-or-type])", "childNum": 1, "tag": "code", "pos": 0, "childList": [{"text": "super", "tag": "strong"}]}, {"text": "super", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Example: "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    def foo(self):\n        print \"foo\"\n\nclass B(A):\n    def foo(self):\n        super(B, self).foo()\n\nmyB = B()\nmyB.foo()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This is a more abstract method:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n super(self.__class__,self).baz(arg)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There's a super() in Python too.", "It's a bit wonky, because of Python's old- and new-style classes, but is quite commonly used e.g.", "in constructors:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Foo(Bar):\n    def __init__(self):\n        super(Foo, self).__init__()\n        self.baz = 5\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would recommend using CLASS.__bases__\nsomething like this"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "CLASS.__bases__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class A:\n   def __init__(self):\n        print \"I am Class %s\"%self.__class__.__name__\n        for parentClass in self.__class__.__bases__:\n              print \"   I am inherited from:\",parentClass.__name__\n              #parentClass.foo(self) &lt;- call parents function with self as first param\nclass B(A):pass\nclass C(B):pass\na,b,c = A(),B(),C()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There is another way"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Foo(Bar):\n    def m(self):\n        Foo.m(self)\n        self.baz = 5\n</code>\n</pre>\n", "senID": 1}]]