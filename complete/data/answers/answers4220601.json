[[{"text": ["Perl has LWP.", "I suggest you use it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "LWP", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/perldoc/LWP"}]}], [{"text": ["Similar to @Santa's example, only in Ruby:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n require 'open-uri'\nprint open('http://www.example.com').read\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want to parse the content, Ruby's Nokogiri gem is awesome.", "It's built on top of libXML."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Nokogiri", "tag": "a", "pos": 0, "childList": [{"text": "Nokogiri", "tag": "code"}], "childNum": 1, "href": "http://nokogiri.org/"}, {"text": "Nokogiri", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Many other HTTP client gems are available, including HTTParty and Typhoeus.", "HTTParty makes it trivial to add REST capability to a class, along with the ability to parse JSON and XML.", "Typhoeus makes it easy to write multiple requests all at once for parallel gets/heads/whatevers."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "HTTParty", "tag": "a", "pos": 0, "childList": [{"text": "HTTParty", "tag": "code"}], "childNum": 1, "href": "https://github.com/jnunemaker/httparty"}, {"text": "HTTParty", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Typhoeus", "tag": "a", "pos": 2, "childList": [{"text": "Typhoeus", "tag": "code"}], "childNum": 1, "href": "https://github.com/pauldix/typhoeus"}, {"text": "Typhoeus", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Python has \"batteries included\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You don't need to work at the socket level (although you can).", "Python has several higher level web/http libraries built in its standard library."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["for example, in Python 2, you can use urllib2:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "urllib2", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/urllib2.html"}]}, {"code": "<pre>\n<code>\n import urllib2\n\nresponse = urllib2.urlopen('http://www.example.com/')\nhtml = response.read()\n</code>\n</pre>\n", "senID": 3}, {"text": ["also check out httplib, for slightly lower level access:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "httplib", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/httplib.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import httplib\n&gt;&gt;&gt; conn = httplib.HTTPConnection(\"www.python.org\")\n&gt;&gt;&gt; conn.request(\"GET\", \"/index.html\")\n&gt;&gt;&gt; r1 = conn.getresponse()\n&gt;&gt;&gt; print r1.status, r1.reason\n200 OK\n&gt;&gt;&gt; data1 = r1.read()\n&gt;&gt;&gt; conn.request(\"GET\", \"/parrot.spam\")\n&gt;&gt;&gt; r2 = conn.getresponse()\n&gt;&gt;&gt; print r2.status, r2.reason\n404 Not Found\n&gt;&gt;&gt; data2 = r2.read()\n&gt;&gt;&gt; conn.close()\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nimport urllib\n\nf = urllib.urlopen('http://www.example.com')\nprint f.read()\nf.close()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Plenty of examples seem trivial until you start needing to do anything heavy, like streaming gigabytes of data in both directions.", "My favorite is ruby's net/http, which is part of every ruby install."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "net/http", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Here's an example that streams the data, and leaves the connection open when you're finished for more requests."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n require 'net/http'\n\nhttp = Net::HTTP.new('my.server.org')\nhttp.start\n\nreq = Net::HTTP::Post.new('/path/to/huge/file')\nreq.basic_auth('user', 'pass')\nreq.content_length = File.size 'huge_input_file.txt'\nreq.body_stream = File.open('huge_input_file.txt', 'rb')\n\nhttp.request(req){|res|\n  File.open('huge_output_file.txt', 'wb'){|f|\n    res.read_body {|chunk| f.write chunk}\n  }\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["Perl doesn't have anything built-in.", "Net::HTTP and LWP::UserAgent are not part of perl core.", "A while back I needed a perl http client that functions like the above ruby example, without depending on anything from CPAN.", "It took under 200 lines, using only IO::Socket::INET and syswrite/sysread (which eliminates a lot of the lower-layer socket nonsense), and MIME::Base64 for authentication."], "childNum": 6, "tag": "p", "senID": 3, "childList": [{"text": "Net::HTTP", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "LWP::UserAgent", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "IO::Socket::INET", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "syswrite", "childNum": 0, "tag": "code", "childList": []}, {"text": "sysread", "childNum": 0, "tag": "code", "childList": []}, {"text": "MIME::Base64", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I take it that you don't actually want to write your own http client, but rather a script that fetches stuff using http?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Others mentioned HTTP::Lite and LWP::Simple .."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "HTTP::Lite", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/perldoc?HTTP%3a%3aLite"}, {"href": "http://search.cpan.org/perldoc?LWP%3a%3aSimple", "text": "LWP::Simple", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Here's an example using Mojo::Client, from the docs."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Mojo::Client", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/perldoc?Mojo%3a%3aClient"}]}, {"code": "<pre>\n<code>\n # Quick JSON request\nmy $trends = 'http://search.twitter.com/trends.json';\nprint $client-&gt;get($trends)-&gt;res-&gt;json-&gt;{trends}-&gt;[0]-&gt;{name};\n\n# Extract data from HTML and XML resources\nprint $client-&gt;get('mojolicious.org')-&gt;res-&gt;dom-&gt;at('title')-&gt;text;\n\n# Scrape the latest headlines from a news site\nmy $news = 'http://digg.com';\n$client-&gt;max_redirects(3);\n$client-&gt;get($news)-&gt;res-&gt;dom('h3 &gt; a.story-title')-&gt;each(sub {\n    print shift-&gt;text . \"\\n\";\n});\n</code>\n</pre>\n", "senID": 3}, {"text": ["Cool, but not the most mature module available.. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I can't see what possible benefit you would get from any answers to such a question, but I'll give in to the peer pressure.", "Since you don't seem to bothered which language to use..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want to manipulate it in interesting ways:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &lt;?php\n$d=new DOMDocument();\n$d-&gt;loadHTMLFile('http://www.example.com/');\n...\n</code>\n</pre>\n", "senID": 2}, {"text": ["But to just return a page:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &lt;?php\nprint file_get_contents('http://www.example.com/');\n</code>\n</pre>\n", "senID": 4}]]