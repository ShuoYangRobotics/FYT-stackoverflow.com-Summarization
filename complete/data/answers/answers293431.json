[[{"text": ["'self' is only a reference to the object.", "'del self' is deleting the 'self' reference from the local namespace of the kill function, instead of the actual object."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To see this for yourself, look at what happens when these two functions are executed:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class A():\n...     def kill_a(self):\n...         print self\n...         del self\n...     def kill_b(self):\n...         del self\n...         print self\n... \n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; b = A()\n&gt;&gt;&gt; a.kill_a()\n&lt;__main__.A instance at 0xb771250c&gt;\n&gt;&gt;&gt; b.kill_b()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 7, in kill_b\nUnboundLocalError: local variable 'self' referenced before assignment\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You don't need to use del to delete instances in the first place.", "Once the last reference to an object is gone, the object will be garbage collected.", "Maybe you should tell us more about the full problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In this specific context, your example doesn't make a lot of sense."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When a Being picks up an Item, the item retains an individual existence.", "It doesn't disappear because it's been picked up.", "It still exists, but it's (a) in the same location as the Being, and (b) no longer eligible to be picked up.", "While it's had a state change, it still exists."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There is a two-way association between Being and Item.", "The Being has the Item in a collection.", "The Item is associated with a Being."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["When an Item is picked up by a Being, two things have to happen."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["The Being how adds the Item in some set of items.", "Your bag attribute, for example, could be such a set.", "[A list is a poor choice -- does order matter in the bag?"], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "bag", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["The Item's location changes from where it used to be to the Being's location.", "There are probably two classes os Items - those with an independent sense of location (because they move around by themselves) and items that have to delegate location to the Being or Place where they're sitting."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]}, {"text": ["Under no circumstances does any Python object ever need to get deleted.", "If an item is \"destroyed\", then it's not in a Being's bag.", "It's not in a location.  "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n player.bag.remove(cat)\n</code>\n</pre>\n", "senID": 7}, {"text": ["Is all that's required to let the cat out of the bag.", "Since the cat is not used anywhere else, it will both exist as \"used\" memory and not exist because nothing in your program can access it.", "It will quietly vanish from memory when some quantum event occurs and memory references are garbage collected."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["On the other hand,"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n here.add( cat )\nplayer.bag.remove(cat)\n</code>\n</pre>\n", "senID": 10}, {"text": ["Will put the cat in the current location.", "The cat continues to exist, and will not be put out with the garbage."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["Indeed, Python does garbage collection through reference counting.", "As soon as the last reference to an object falls out of scope, it is deleted.", "In your example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = A()\na.kill()\n</code>\n</pre>\n", "senID": 1}, {"text": ["I don't believe there's any way for variable 'a' to implicitly set itself to None."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I'm curious as to why you would want to do such a thing.", "Chances are, you should just let garbage collection do its job.", "In python, garbage collection is pretty deterministic.", "So you don't really have to worry as much about just leaving objects laying around in memory like you would in other languages (not to say that refcounting doesn't have disadvantages)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Although one thing that you should consider is a wrapper around any objects or resources you may get rid of later."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class foo(object):\n    def __init__(self):\n        self.some_big_object = some_resource\n\n    def killBigObject(self):\n        del some_big_object\n</code>\n</pre>\n", "senID": 2}, {"text": ["In response to Null's addendum:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Null's addendum", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/293431/python-object-deleting-itself#293497"}]}, {"text": ["Unfortunately, I don't believe there's a way to do what you want to do the way you want to do it.", "Here's one way that you may wish to consider:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class manager(object):\n...     def __init__(self):\n...             self.lookup = {}\n...     def addItem(self, name, item):\n...             self.lookup[name] = item\n...             item.setLookup(self.lookup)\n&gt;&gt;&gt; class Item(object):\n...     def __init__(self, name):\n...             self.name = name\n...     def setLookup(self, lookup):\n...             self.lookup = lookup\n...     def deleteSelf(self):\n...             del self.lookup[self.name]\n&gt;&gt;&gt; man = manager()\n&gt;&gt;&gt; item = Item(\"foo\")\n&gt;&gt;&gt; man.addItem(\"foo\", item)\n&gt;&gt;&gt; man.lookup\n {'foo': &lt;__main__.Item object at 0x81b50&gt;}\n&gt;&gt;&gt; item.deleteSelf()\n&gt;&gt;&gt; man.lookup\n {}\n</code>\n</pre>\n", "senID": 5}, {"text": ["It's a little bit messy, but that should give you the idea.", "Essentially, I don't think that tying an item's existence in the game to whether or not it's allocated in memory is a good idea.", "This is because the conditions for the item to be garbage collected are probably going to be different than what the conditions are for the item in the game.", "This way, you don't have to worry so much about that."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I'm making a simple system of objects that can interact with each other for a game.", "One thing I want objects to do is to destroy themselves with a method."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Generic:\n    ''' Generic class all other classes inherit '''\n    def kill(self):\n        del self\n        #Need a way to remove the instance of the class\n\nclass Item(Generic):\n    def __init__(self,name):\n        self.name = name\n\nclass Being(Generic):\n    def __init__(self,name):\n        self.name = name\n        self.bag = []\n\n    def pick_up(self,target):\n        self.bag.append(target)\n        target.kill()\n\nplayer = Being('Hero')\nprint player\n\ncat = Item('Cat')\nprint cat\n\n\nprint'Players inventory',player.bag\n\nprint'Picking up the cat'\nplayer.pick_up(cat)\n\nprint'Players inventory',player.bag\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I am trying the same thing.", "I have a RPG battle system in which my Death(self) function has to kill the own object of the Fighter class.", "But it appeared it`s not possible.", "Maybe my class Game in which I collect all participants in the combat should delete units form the \"fictional\" map??"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def Death(self):\n    if self.stats[\"HP\"] &lt;= 0:\n        print(\"%s wounds were too much... Dead!\"%(self.player[\"Name\"]))\n        del self\n    else:\n        return True\n\ndef Damage(self, enemy):\n    todamage = self.stats[\"ATK\"] + randint(1,6)\n    todamage -= enemy.stats[\"DEF\"]\n    if todamage &gt;=0:\n        enemy.stats[\"HP\"] -= todamage\n        print(\"%s took %d damage from your attack!\"%(enemy.player[\"Name\"], todamage))\n        enemy.Death()\n        return True\n    else:\n        print(\"Ineffective...\")\n        return True\ndef Attack(self, enemy):\n    tohit = self.stats[\"DEX\"] + randint(1,6)\n    if tohit &gt; enemy.stats[\"EVA\"]:\n        print(\"You landed a successful attack on %s \"%(enemy.player[\"Name\"]))\n        self.Damage(enemy)\n        return True\n    else:\n        print(\"Miss!\")\n        return True\ndef Action(self, enemylist):\n    for i in range(0, len(enemylist)):\n        print(\"No.%d, %r\"%(i, enemylist[i]))\n    print(\"It`s your turn, %s. Take action!\"%(self.player[\"Name\"]))\n    choice = input(\"\\n(A)ttack\\n(D)efend\\n(S)kill\\n(I)tem\\n(H)elp\\n&gt;\")\n    if choice == 'a'or choice == 'A':\n        who = int(input(\"Who? \"))\n        self.Attack(enemylist[who])\n        return True\n    else:\n        return self.Action()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I can't tell you how this is possible with classes, but functions can delete themselves. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def kill_self(exit_msg = 'killed'):\n    global kill_self\n    del kill_self\n    return exit_msg\n</code>\n</pre>\n", "senID": 1}, {"text": ["And see the output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; kill_self\n&lt;function kill_self at 0x02A2C780&gt;\n&gt;&gt;&gt; kill_self()\n'killed'\n&gt;&gt;&gt; kill_self\nTraceback (most recent call last):\n  File \"&lt;pyshell#28&gt;\", line 1, in &lt;module&gt;\n    kill_self\nNameError: name 'kill_self' is not defined\n</code>\n</pre>\n", "senID": 3}, {"text": ["I don't think that deleting an individual instance of a class without knowing the name of it is possible. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["NOTE:\nIf you assign another name to the function, the other name will still reference the old one, but will cause errors once you attempt to run it:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "NOTE:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = kill_self\n&gt;&gt;&gt; kill_self()\n&gt;&gt;&gt; kill_self\nNameError: name 'kill_self' is not defined\n&gt;&gt;&gt; x\n&lt;function kill_self at 0x...&gt;\n&gt;&gt;&gt; x()\nNameError: global name 'kill_self' is not defined\n</code>\n</pre>\n", "senID": 6}]]