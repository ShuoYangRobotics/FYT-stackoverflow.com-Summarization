[[{"text": ["Well, you could do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; if all (k in foo for k in (\"foo\",\"bar\")):\n...     print \"They're there!\"\n...\nThey're there!\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n if set((\"foo\", \"bar\")) &lt;= set(myDict): ...\n</code>\n</pre>\n", "senID": 0}], [{"text": ["How about"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if all([key in foo for key in [\"foo\",\"bar\"]]):\n    #do stuff\n    pass\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using sets:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sets", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "sets", "tag": "a"}]}, {"href": "http://docs.python.org/library/stdtypes.html#set-types-set-frozenset", "text": "sets", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n if set((\"foo\", \"bar\")).issubset(foo):\n    #do stuff\n</code>\n</pre>\n", "senID": 1}, {"text": ["Alternatively:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if set((\"foo\", \"bar\")) &lt;= set(foo):\n    #do stuff\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Simple benchmarking rig for 3 of the alternatives.  "], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Put in your own values for D and Q"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n >>> from timeit import Timer\n>>> setup='''from random import randint as R;d=dict((str(R(0,1000000)),R(0,1000000)) for i in range(D));q=dict((str(R(0,1000000)),R(0,1000000)) for i in range(Q));print(\"looking for %s items in %s\"%(len(q),len(d)))'''\n\n>>> Timer('set(q) &lt;= set(d)','D=1000000;Q=100;'+setup).timeit(1)\nlooking for 100 items in 632499\n0.28672504425048828\n\n#This one only works for Python3\n>>> Timer('set(q) &lt;= d.keys()','D=1000000;Q=100;'+setup).timeit(1)\nlooking for 100 items in 632084\n2.5987625122070312e-05\n\n>>> Timer('all(k in d for k in q)','D=1000000;Q=100;'+setup).timeit(1)\nlooking for 100 items in 632219\n1.1920928955078125e-05\n</code>\n</pre>\n", "senID": 2}], [{"text": ["How about using lambda?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if reduce( (lambda x, y: x and foo.has_key(y) ), [ True, \"foo\", \"bar\"] ): # do stuff\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In case you want to: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "also get the values for the keys", "tag": "none", "senID": 1}, {"text": "check more than one dictonary", "tag": "none", "senID": 2}]}, {"text": ["then:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from operator import itemgetter\nfoo = {'foo':1,'zip':2,'zam':3,'bar':4}\nkeys = (\"foo\",\"bar\") \ngetter = itemgetter(*keys) # returns all values\ntry:\n    values = getter(foo)\nexcept KeyError:\n    # not both keys exist\n    pass\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Not to suggest that this isn't something that you haven't thought of, but I find that the simplest thing is usually the best:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if (\"foo\" in foo) and (\"bar\" in foo):\n    # do stuff\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; if 'foo' in foo and 'bar' in foo:\n...     print 'yes'\n... \nyes\n</code>\n</pre>\n", "senID": 0}, {"text": ["Jason, () aren't necessary in Python."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Alex Martelli's solution set(queries) &lt;= set(my_dict) is the shortest code but may not be the fastest.", "Assume Q = len(queries) and D = len(my_dict)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "set(queries) &lt;= set(my_dict)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This takes O(Q) + O(D) to make the two sets, and then (one hopes!", ") only O(min(Q,D)) to do the subset test -- assuming of course that Python set look-up is O(1) -- this is worst case (when the answer is True)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The generator solution of hughdbrown (et al?", ") all(k in my_dict for k in queries) is worst-case O(Q)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "all(k in my_dict for k in queries)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Complicating factors:\n(1) the loops in the set-based gadget are all done at C-speed whereas the any-based gadget is looping over bytecode.", "(2) The caller of the any-based gadget may be able to use any knowledge of probability of failure to order the query items accordingly whereas the set-based gadget allows no such control."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"text": ["As always, if speed is important, benchmarking under operational conditions is a good idea."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]