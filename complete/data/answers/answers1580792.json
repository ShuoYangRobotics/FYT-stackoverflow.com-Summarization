[[{"text": ["Create objects of types relevant to your program, and store the command line options relevant to each in them.", "Example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import WidgetFrobnosticator\nf = WidgetFrobnosticator()\nf.allow_oncave_widgets = option_allow_concave_widgets\nf.respect_weasel_pins = option_respect_weasel_pins\n\n# Now the methods of WidgetFrobnosticator have access to your command-line parameters,\n# in a way that's not dependent on the input format.\n\nimport PlatypusFactory\np = PlatypusFactory()\np.allow_parthenogenesis = option_allow_parthenogenesis\np.max_population = option_max_population\n\n# The platypus factory knows about its own options, but not those of the WidgetFrobnosticator\n# or vice versa.  This makes each class easier to read and implement.\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If \"a\" is a real object and not just a set of independent helper methods, you can create an \"p\" member variable in \"a\" and set it when you instantiate an \"a\" object.", "Then your main class will not need to pass \"p\" into meth1 and meth2 once \"a\" has been instantiated."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["[Caution: my answer isn't specific to python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I remember that Code Complete called this kind of parameter a \"tramp parameter\".", "Googling for \"tramp parameter\" doesn't return many results, however."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Code Complete", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Some alternatives to tramp parameters might include:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Put the data in a global variable", "tag": "none", "senID": 3}, {"text": "Put the data in a static variable of a class (similar to global data)", "tag": "none", "senID": 4}, {"text": "Put the data in an instance variable of a class", "tag": "none", "senID": 5}, {"text": "Pseudo-global variable: hidden behind a singleton, or some dependency injection mechanism", "tag": "none", "senID": 6}]}, {"text": ["Personally, I don't mind a tramp parameter as long as there's no more than one; i.e.", "your example is OK for me, but I wouldn't like ..."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import a\np1 = some_command_line_argument_value\np2 = another_command_line_argument_value\np3 = a_further_command_line_argument_value\na.meth1(p1, p2, p3)\n</code>\n</pre>\n", "senID": 8}, {"text": ["... instead I'd prefer ..."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n import a\np = several_command_line_argument_values\na.meth1(p)\n</code>\n</pre>\n", "senID": 10}, {"text": ["... because if meth2 decides that it wants more data than before, I'd prefer if it could extract this extra data from the original parameter which it's already being passed, so that I don't need to edit meth1."], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "meth2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "meth1", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Maybe you should organize your code more into classes and objects?", "As I was writing this, Jimmy showed a class-instance based answer, so here is a pure class-based answer.", "This would be most useful if you only ever wanted a single behavior; if there is any chance at all you might want different defaults some of the time, you should use ordinary object-oriented programming in Python, i.e.", "pass around class instances with the property p set in the instance, not the class."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Aclass(object):\n    p = None\n    @classmethod\n    def init_p(cls, value):\n        p = value\n    @classmethod\n    def meth1(cls):\n        # some code\n        res = cls.meth2()\n        # some more code w/ res\n    @classmethod\n    def meth2(cls):\n        # do something with p\n        pass\n\nfrom a import Aclass as ac\n\nac.init_p(some_command_line_argument_value)\n\nac.meth1()\nac.meth2()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["With objects, parameter lists should normally be very small, since most appropriate information is a property of the object itself.", "The standard way to handle this is to configure the object properties and then call the appropriate methods of that object.", "In this case set p as an attribute of a.", "Your meth2 should also complain if p is not set."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "p", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "meth2", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "p", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Your example is reminiscent of the code smell Message Chains.", "You may find the corresponding refactoring,  Hide Delegate, informative."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Message Chains", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://sourcemaking.com/refactoring/message-chains"}, {"text": "Hide Delegate", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://sourcemaking.com/refactoring/hide-delegate"}]}]]