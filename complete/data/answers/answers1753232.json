[[{"text": ["@behindthefall, the motivation to give function objects generic assignable attributes (they didn't use to have them) was that, absent such possibilities, real and popular frameworks were abusing what few assignable attributes existed (typically __doc__) to record information about each given function object.", "So there was clearly a \"pent-up demand\" for this functionality, so Guido decided to address it directly (adding an optional dict to each function object to record its attributes isn't a big deal -- most function objects don't need it, and it is optional, so the cost is just 4 bytes for a null pointer;-)."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "existed", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "__doc__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "dict", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "is", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Assigning such attributes in arbitrary places would be very bad practice, making the code harder to understand for no real benefit, but they're very useful when used in a controlled way -- for example, a decorator could usefully record all kinds of things about the function being decorated, and the context in which the decoration occurred, as attributes of the wrapper function, allowing trivially-easy introspection of such metadata to occur later at any time, as needed."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As other answers already pointed out, local variables (which are per-instance, not per-function object!", ") are a completely disjoint namespace from a function object's attributes held in its __dict__."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "__dict__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["In python, a namespace is just a dictionary object, mapping variable name as a string (in this case, 'guest') to a value (in this case, 'Harry').", "So as long as you have access to an object, and it's mutable, you can change anything about its namespace."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["On small projects, it's not a huge problem, and lets you hack things together faster, but incredibly confusing on larger projects, where your data could be modified from anywhere."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There are ways of making attributes of classes \"more private\", such as Name Mangling."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Name Mangling", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/expressions.html#atom-identifiers"}]}], [{"text": ["I think you might be conflating the concepts of local variables and function attributes.", "For more information on Python function attributes, see the SO question Python function attributes - uses and abuses."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "local variables", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "function attributes", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"href": "http://stackoverflow.com/questions/338101/python-function-attributes-uses-and-abuses", "text": "Python function attributes - uses and abuses", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["tom.guest is just a property on the tom function object, it has nothing to do with the scope or locals() inside that function, and nothing to do with that fact that tom is a function, it would work on any object."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I have used this in the past to make a self-contained function with \"enums\" that go along with it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Suppose I were implementing a seek() function.", "The built-in Python one (on file objects) takes an integer to tell it how to operate; yuck, give me an enum please."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "seek()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def seek(f, offset, whence=0):\n    return f.seek(offset, whence)\n\nseek.START = 0\nseek.RELATIVE = 1\nseek.END = 2\n\nf = open(filename)\n\nseek(f, 0, seek.START)  # seek to start of file\nseek(f, 0, seek.END)  # seek to end of file\n</code>\n</pre>\n", "senID": 2}, {"text": ["What do you think, too tricky and weird?", "I do like how it keeps the \"enum\" values bundled together with the function; if you import the function from a module, you get its \"enum\" values as well, automatically."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Python functions are lexically scoped so there is no way to add variables to the function outside of its defined scope."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, the function still will have access to all parent scopes, if you really wanted to design the system like that (generally considered bad practice though):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo():\n&gt;&gt;&gt;     def bar():\n&gt;&gt;&gt;         print x\n&gt;&gt;&gt;     x = 1\n&gt;&gt;&gt;     bar()\n1\n</code>\n</pre>\n", "senID": 2}, {"text": ["Mutating function variables is mostly a bad idea, since functions are assumed to be immutable.", "The most pythonic way of implementing this behavior is using classes and methods instead."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Python API documentation generation tools, such as pydoc and epydoc, use introspection to determine a function's name and docstring (available as the __name__ and __doc__ attributes).", "Well-behaved function decorators are expected to preserve these attributes, so such tools continue to work as expected (i.e.", "decorating a function should preserve the decorated function's documentation).", "You do this by copying these attributes from the decorated function to the decorator.", "Take a look at update_wrapper in the functools module:"], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "pydoc", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/pydoc"}, {"text": "epydoc", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://epydoc.sourceforge.net/"}, {"text": "__name__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__doc__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "update_wrapper", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "functools", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n WRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__doc__')\nWRAPPER_UPDATES = ('__dict__',)\n\ndef update_wrapper(wrapper,\n                   wrapped,\n                   assigned = WRAPPER_ASSIGNMENTS,\n                   updated = WRAPPER_UPDATES):\n    \"\"\"Update a wrapper function to look like the wrapped function\n\n       wrapper is the function to be updated\n       wrapped is the original function\n       ...\n    \"\"\"\n    for attr in assigned:\n        setattr(wrapper, attr, getattr(wrapped, attr))\n    for attr in updated:\n        getattr(wrapper, attr).update(getattr(wrapped, attr, {}))\n    ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["So, that's at least one example where modifying function attributes is useful and accepted."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It some situations, it can be useful to \"annotate\" a function by setting an attribute; Django uses this in a few places: "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Django", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.djangoproject.com"}]}, {"tag": "ul", "num": 2, "lis": [{"text": ["You can set alters_data to True\non model methods that change the\ndatabase, preventing them from being\ncalled in templates. "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "alters_data", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You can set\nallow_tags on model methods that\nwill be displayed in the admin, to\nsignify that the method returns HTML\ncontent, which shouldn't be\nautomatically escaped."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "allow_tags", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}, {"text": ["As always, use your judgement.", "If modifying attributes is accepted practice (for example, when writing a decorator), then by all means go ahead.", "If it's going to be part of a well documented API, it's probably fine too."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "well", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev/ref/templates/api/#rendering-a-context"}, {"href": "http://docs.djangoproject.com/en/dev/ref/contrib/admin/#django.contrib.admin.ModelAdmin.list%5Fdisplay", "text": "documented", "childNum": 0, "tag": "a", "childList": []}]}]]