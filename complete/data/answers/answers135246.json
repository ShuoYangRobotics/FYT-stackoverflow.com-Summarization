[[{"text": ["The 'struct' module should be able to do this, although alignment of structs in the middle of the data is always an issue.", "It's not very hard to get it right, however: find out (once) what boundary the structs-in-structs align to, then pad (manually, with the 'x' specifier) to that boundary.", "You can doublecheck your padding by comparing struct.calcsize() with your actual data.", "It's certainly easier than writing a C extension for it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In order to keep using Py_BuildValue() like that, you have two options.", "You can determine the size of time_t at compiletime (in terms of fundamental types, so 'an int' or 'a long' or 'an ssize_t') and then use the right format character to Py_BuildValue -- 'i' for an int, 'l' for a long, 'n' for an ssize_t.", "Or you can use PyInt_FromSsize_t() manually, in which case the compiler does the upcasting for you, and then use the 'O' format characters to pass the result to Py_BuildValue."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Explicitly specify that your data types (e.g.", "integers) are 32-bit.", "Otherwise if you have two integers next to each other when you read them they will be read as one 64-bit integer."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When you are dealing with cross-platform issues, the two main things to watch out for are:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Hopefully this helps."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["What's your code for reading the binary data?", "Make sure you're copying the data into properly-sized types like int32_t instead of just int."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "int32_t", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You need to make sure you're using architecture independant members for your struct.", "For instance an int may be 32 bits on one architecture and 64 bits on another.", "As others have suggested, use the int32_t style types instead.", "If your struct contains unaligned members, you may need to deal with padding added by the compiler too."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Another common problem with cross architecture data is endianness.", "i386 architectre is little-endian, but if you're reading on a completely different machine( eg.", "an Alpha or Sparc), you'll have to worry about this too."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The python struct module deals with both these situations, using the prefix passed as part of the format string."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "@ - Use native size, endianness and alignment. i= sizeof(int), l= sizeof(long)", "tag": "none", "senID": 3}, {"text": "= - Use native endianness, but standard sizes and alignment (i=32 bits, l=64 bits)", "tag": "none", "senID": 4}, {"text": "&lt; - Little-endian standard sizes/alignment", "tag": "none", "senID": 5}, {"text": "> - Big-endian standard sizes / alignment", "tag": "none", "senID": 6}]}, {"text": ["In general, if the data passes off your machine, you should nail down the endianness and the size / padding format to something specific.", "ie.", "use \"&lt;\" or \">\" as your format.", "If you want to handle this in your C extension, you may need to add some code to handle it."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Why aren't you using the struct package?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "struct", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-struct.html"}]}], [{"text": ["It would be a lot of code to post but as an example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n struct\n{\n\tWORD\tversion;\n\tBOOL\tupgrade;\n\ttime_t\ttime1;\n            time_t  time2;\n} apparms;\n\nFile *fp;\nfp = fopen(filePath, \"r+b\");\nfread(&amp;apparms, sizeof(apparms), 1, fp);\nreturn Py_BuildValue(\"{s:i,s:l,s:l}\",\n  \"sysVersion\",apparms.version,\n  \"powerFailTime\", apparms.time1,\n  \"normKitExpDate\", apparms.time2\n );\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now on a 32 bit system this works great, but on a 64 bit my time_t sizes are different (32bit vs 64 bit longs)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Damn, you people are fast.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Patrick, I originally started using the struct package but found it just way to slow for my needs.", "Plus I was looking for an excuse to write a Python Extension."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I know this is a stupid question but what types do I need to watch out for?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Thanks."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]