[[{"text": ["Probably something like this if it's the text part you want..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from xml.dom.minidom import parse\ndom = parse(\"C:\\\\eve.xml\")\nname = dom.getElementsByTagName('name')\n\nprint \" \".join(t.nodeValue for t in name[0].childNodes if t.nodeType == t.TEXT_NODE)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The text part of a node is considered a node in itself placed as a child-node of the one you asked for.", "Thus you will want to go through all its children and find all child nodes that are text nodes.", "A node can have several text nodes; eg."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &lt;name&gt;\n  blabla\n  &lt;somestuff&gt;asdf&lt;/somestuff&gt;\n  znylpx\n&lt;/name&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["You want both 'blabla' and 'znylpx'; hence the \" \".join().", "You might want to replace the space with a newline or so, or perhaps by nothing."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["It should just be"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n name[0].nodeValue\n</code>\n</pre>\n", "senID": 1}], [{"text": ["you can use something like this.It worked out for me"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n doc = parse('C:\\\\eve.xml')\nmy_node_list = doc.getElementsByTagName(\"name\")\nmy_n_node = my_node_list[0]\nmy_child = my_n_node.firstChild\nmy_text = my_child.data \nprint my_text\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I know this question is pretty old now, but I thought you might have an easier time with ElementTree"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from xml.etree import ElementTree as ET\nimport datetime\n\nf = ET.XML(data)\n\nfor element in f:\n    if element.tag == \"currentTime\":\n        # Handle time data was pulled\n        currentTime = datetime.datetime.strptime(element.text, \"%Y-%m-%d %H:%M:%S\")\n    if element.tag == \"cachedUntil\":\n        # Handle time until next allowed update\n        cachedUntil = datetime.datetime.strptime(element.text, \"%Y-%m-%d %H:%M:%S\")\n    if element.tag == \"result\":\n        # Process list of skills\n        pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["I know that's not super specific, but I just discovered it, and so far it's a lot easier to get my head around than the minidom (since so many nodes are essentially white space)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For instance, you have the tag name and the actual text together, just as you'd probably expect:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; element[0]\n&lt;Element currentTime at 40984d0&gt;\n&gt;&gt;&gt; element[0].tag\n'currentTime'\n&gt;&gt;&gt; element[0].text\n'2010-04-12 02:45:45'e\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I had a similar case, what worked for me was:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["name.firstChild.childNodes[0].data"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["XML is supposed to be simple and it really is and I don't know why python's minidom did it so complicated... but it's how it's made"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here is a slightly modified answer of Henrik's for multiple nodes (ie.", "when getElementsByTagName returns more than one instance)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n images = xml.getElementsByTagName(\"imageUrl\")\nfor i in images:\n    print \" \".join(t.nodeValue for t in i.childNodes if t.nodeType == t.TEXT_NODE)\n</code>\n</pre>\n", "senID": 1}]]