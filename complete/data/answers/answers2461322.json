[[{"text": ["I suggest you to adopt a search engine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["We've used Haystack search, a modular search application for django supporting many search engines (Solr, Xapian, Whoosh, etc...)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Haystack search", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://haystacksearch.org/"}]}, {"text": ["Advantages:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 7, "lis": [{"text": "Faster", "tag": "none", "senID": 3}, {"text": "perform search queries even without querying the database.", "tag": "none", "senID": 4}, {"text": "Highlight searched terms", "tag": "none", "senID": 5}, {"text": "\"More like this\" functionality", "tag": "none", "senID": 6}, {"text": "Spelling suggestions", "tag": "none", "senID": 7}, {"text": "Better ranking", "tag": "none", "senID": 8}, {"text": "etc...", "tag": "none", "senID": 9}]}, {"text": ["Disadvantages:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Search Indexes can grow in size pretty fast", "tag": "none", "senID": 11}, {"text": "One of the best search engines (Solr) run as a Java servlet (Xapian does not)", "tag": "none", "senID": 12}]}, {"text": ["We're pretty happy with this solution and it's pretty easy to implement."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["Answer to your general question: Definitely use a proper application for this."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "general", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["With your query, you always examine the whole content of the fields (title, text, tags).", "You gain no benefit from indexes, etc."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "always examine the whole content", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["With a proper full text search engine (or whatever you call it), text (words) is (are) indexed every time you insert new records.", "So queries will be a lot faster especially when your database grows."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "text (words) is (are) indexed", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["For full text search in Python, look at PyLucene.", "It allows for very complex queries.", "The main problem here is that you must find a way to tell your search engine which pages changed and update the index eventually."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PyLucene", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://lucene.apache.org/pylucene/"}]}, {"text": ["Alternatively, you can use Google Sitemaps to tell Google to index your site faster and then embed a custom query field in your site.", "The advantage here is that you just need to tell Google the changed pages and Google will do all the hard work (indexing, parsing the queries, etc).", "On top of that, most people are used to use Google to search plus it will keep your site current in the global Google searches, too."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Google Sitemaps", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Sitemaps"}]}], [{"text": ["Actually, the query you have posted does use OR rather than AND - you're using \\ to separate the Q objects.", "AND would be &amp;."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "does", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "\\", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Q", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "&amp;", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In general, I would highly recommend using a proper search engine.", "We have had good success with Haystack on top of Solr - Haystack manages all the Solr configuration, and exposes a nice API very similar to Django's own ORM."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["SOLR is very easy to setup and integrate with Django.", "Haystack makes it even simpler."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I think full text search on an application level is more a matter of what you have and how you expect it to scale.", "If you run a small site with low usage I think it might be more affordable to put some time into making an custom full text search rather than installing an application to perform the search for you.", "And application would create more dependency, maintenance and extra effort when storing data.", "By making your search yourself and you can build in nice custom features.", "Like for example, if your text exactly matches one title you can direct the user to that page instead of showing the results.", "Another would be to allow title: or author: prefixes to keywords. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is a method I've used for generating relevant search results from a web query."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import shlex\n\nclass WeightedGroup:\n    def __init__(self):  \n        # using a dictionary will make the results not paginate\n        # but it will be a lot faster when storing data          \n        self.data = {}\n\n    def list(self, max_len=0):\n        # returns a sorted list of the items with heaviest weight first\n        res = []\n        while len(self.data) != 0:\n            nominated_weight = 0                      \n            for item, weight in self.data.iteritems():\n                if weight &gt; nominated_weight:\n                    nominated = item\n                    nominated_weight = weight\n            self.data.pop(nominated)\n            res.append(nominated)\n            if len(res) == max_len:\n                return res\n        return res\n\n    def append(self, weight, item):\n        if item in self.data:\n            self.data[item] += weight\n        else:\n            self.data[item] = weight\n\n\ndef search(searchtext):\n    candidates = WeightedGroup()\n\n    for arg in shlex.split(searchtext): # shlex understand quotes\n\n        # Search TITLE\n        # order by date so we get most recent posts\n        query = Post.objects.filter_by(title__icontains=arg).order_by('-date')\n        arg_hits = query.count() # count is cheap\n\n        if arg_hits &gt; 1000:\n            continue # skip keywords which has too many hits\n\n        # Each of these are expensive as it would transfer data\n        #  from the db and build a python object, \n        for post in query[:50]: # so we limit it to 50 for example                \n            # more hits a keyword has the lesser it's relevant\n            candidates.append(100.0 / arg_hits, post.post_id)\n\n        # TODO add searchs for other areas\n        # Weight might also be adjusted with number of hits within the text\n        #  or perhaps you can find other metrics to value an post higher,\n        #  like number of views\n\n    # candidates can contain a lot of stuff now, show most relevant only\n    sorted_result = Post.objects.filter_by(post_id__in=candidates.list(20))\n</code>\n</pre>\n", "senID": 2}]]