[[{"text": ["defaultdict combined with the itertools.count().next method is a good way to assign identifiers to unique items.", "Here's an example of how to apply this in your case:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "defaultdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools.count().next", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import count\nfrom collections import defaultdict\n\ndef create_lookup_list(data, domains):\n    domain_keys = defaultdict(lambda:defaultdict(count().next))\n    out = []\n    for row in data:\n        out.append(tuple(domain_keys[dom][val] for val, dom in zip(row, domains)))\n    lookup_table = dict((k, sorted(d, key=d.get)) for k, d in domain_keys.items())\n    return out, lookup_table\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: note that count().next becomes count().__next__ or lambda: next(count()) in Python 3."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "count().next", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "count().__next__", "childNum": 0, "tag": "code", "childList": []}, {"text": "lambda: next(count())", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Mine's about the same length and complexity:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import collections\n\ndef create_lookup_list(messages, labels):\n\n    # Collect all the values\n    lookup = collections.defaultdict(set)\n    for msg in messages:\n        for l, v in zip(labels, msg):\n            lookup[l].add(v)\n\n    # Make the value sets lists\n    for k, v in lookup.items():\n        lookup[k] = list(v)\n\n    # Make the lookup_list\n    lookup_list = []\n    for msg in messages:\n        lookup_list.append([lookup[l].index(v) for l, v in zip(labels, msg)])\n\n    return lookup_list, lookup\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In Otto's answer (or anyone else's with string->id dicts), I'd replace (if obsessing over speed is your thing):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # create the lookup table\nlookup_dict = {}\nfor group in indices:\n    lookup_dict[group] = sorted(indices[group].keys(),\n            lambda e1, e2: indices[group][e1]-indices[group][e2])\n</code>\n</pre>\n", "senID": 1}, {"text": ["by"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # k2i must map keys to consecutive ints [0,len(k2i)-1)\ndef inverse_indices(k2i):\n    inv=[0]*len(k2i)\n    for k,i in k2i.iteritems():\n        inv[i]=k\n    return inv\n\nlookup_table = dict((g,inverse_indices(gi)) for g,gi in indices.iteritems())\n</code>\n</pre>\n", "senID": 3}, {"text": ["This is better because direct assignment to each item in the inverse array directly is faster than sorting."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Here is my own solution - I doubt it's the best"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def create_lookup_list(input_list, groups):\n    # use a dictionary for the indices so that the index lookup \n    # is fast (not necessarily a requirement)\n    indices = dict((group, {}) for group in groups) \n    output = []\n\n    # assign indices by iterating through the list\n    for row in input_list:\n        newrow = []\n        for group, element in zip(groups, row):\n            if element in indices[group]:\n                index = indices[group][element]\n            else:\n                index = indices[group][element] = len(indices[group])\n            newrow.append(index)\n        output.append(newrow)\n\n    # create the lookup table\n    lookup_dict = {}\n    for group in indices:\n        lookup_dict[group] = sorted(indices[group].keys(),\n                lambda e1, e2: indices[group][e1]-indices[group][e2])\n\n    return output, lookup_dict\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is a bit simpler, and more direct."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\ndef create_lookup_list( messages, schema ):\n    def mapped_rows( messages ):\n        for row in messages:\n            newRow= []\n            for col, value in zip(schema,row):\n                if value not in lookups[col]:\n                    lookups[col].append(value)\n                code= lookups[col].index(value)\n                newRow.append(code)\n            yield newRow\n    lookups = defaultdict(list)\n    return list( mapped_rows(messages) ), dict(lookups)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If the lookups were proper dictionaries, not lists, this could be simplified further.", "Make your \"lookup table\" have the following structure"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n { 'person': {'Ricky':0, 'Steve':1, 'Karl':2, 'Nora':3},\n  'medium': {'SMS':0, 'Email':1}\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["And it can be further reduced in complexity.  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You can turn this working copy of the lookups into it's inverse as follows:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; lookups = { 'person': {'Ricky':0, 'Steve':1, 'Karl':2, 'Nora':3},\n      'medium': {'SMS':0, 'Email':1}\n    }\n&gt;&gt;&gt; dict( ( d, dict( (v,k) for k,v in lookups[d].items() ) ) for d in lookups )\n{'person': {0: 'Ricky', 1: 'Steve', 2: 'Karl', 3: 'Nora'}, 'medium': {0: 'SMS', 1: 'Email'}}\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Here is my solution, it's not better - it's just different :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def create_lookup_list(data, keys):\n  encoded = []\n  table = dict([(key, []) for key in keys])\n\n  for record in data:\n      msg_int = []\n      for key, value in zip(keys, record):\n          if value not in table[key]:\n              table[key].append(value)\n          msg_int.append(table[key].index(value))  \n      encoded.append(tuple(msg_int))\n\n  return encoded, table\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is mine, the inner function lets me write the index-tuple as a generator."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def create_lookup_list( data, format):\n    table = {}\n    indices = []\n    def get_index( item, form ):\n        row = table.setdefault( form, [] )\n        try:\n            return row.index( item )\n        except ValueError:\n            n = len( row )\n            row.append( item )\n            return n\n    for row in data:\n        indices.append( tuple( get_index( item, form ) for item, form in zip( row, format ) ))\n\n    return table, indices\n</code>\n</pre>\n", "senID": 1}]]