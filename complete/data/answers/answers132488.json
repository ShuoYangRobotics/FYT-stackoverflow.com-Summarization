[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; from BeautifulSoup import BeautifulSoup, Comment\n&gt;&gt;&gt; html = '&lt;html&gt;&lt;!--[if IE]&gt; bloo blee&lt;![endif]--&gt;&lt;/html&gt;'\n&gt;&gt;&gt; soup = BeautifulSoup(html)\n&gt;&gt;&gt; comments = soup.findAll(text=lambda text:isinstance(text, Comment) \n               and text.find('if') != -1) #This is one line, of course\n&gt;&gt;&gt; [comment.extract() for comment in comments]\n[u'[if IE]&gt; bloo blee&lt;![endif]']\n&gt;&gt;&gt; print soup.prettify()\n&lt;html&gt;\n&lt;/html&gt;\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}, {"text": ["If your data gets BeautifulSoup confused, you can fix it before hand or customize the parser, among other solutions."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "fix", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/documentation.html#Sanitizing%20Bad%20Data%20with%20Regexps"}, {"href": "http://www.crummy.com/software/BeautifulSoup/documentation.html#Customizing%20the%20Parser", "text": "customize", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["EDIT: Per your comment, you just modify the lambda passed to findAll as you need (I modified it)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["@Benoit"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Benoit", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "#132503"}]}, {"text": ["Small Correction (with multiline turned on): "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n \"&lt;!--\\[if IE\\]&gt;.*?&lt;!\\[endif\\]--&gt;\"\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Here's what you'll need:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &lt;!(|--)\\[[^\\]]+\\]&gt;.+?&lt;!\\[endif\\](|--)&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["It will filter out all sorts of conditional comments including:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &lt;!--[if anything]&gt;\n    ...\n&lt;[endif]--&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["and"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &lt;![if ! IE 6]&gt;\n    ...\n&lt;![endif]&gt;\n</code>\n</pre>\n", "senID": 5}, {"tag": "hr", "senID": 6}, {"text": ["How about this:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n (&lt;!(|--)\\[[^\\]]+\\]&gt;.*?)(&lt;!--.+?--&gt;)(.*?&lt;!\\[endif\\](|--)&gt;)\n</code>\n</pre>\n", "senID": 8}, {"text": ["Do a replace on that regular expression leaving \\1\\4 (or $1$4) as the replacement.", "I know it has .?", "and .+?", "in it, see my comment on this post._"], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "I know it has .", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["As I see it, you only need to worry about downlevel-hidden comments (the ones that start with &lt;!--), and you don't need to match anything beyond the word if and the space following it.", "This should do what you want:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "downlevel-hidden", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "&lt;!--", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "if", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n \"&lt;!--\\[if\\s(?:[^&lt;]+|&lt;(?!!\\[endif\\]--&gt;))*&lt;!\\[endif\\]--&gt;\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["That mess in the middle is to satisfy your desire not to use .", "*?, but I don't really think it's worth the effort.", "The .*?", "approach should work fine if you compile the regex with the Re.S flag set or wrap it in (?s:...).", "For example:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": ".*?", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": ".*?", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "(?s:...)", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n \"(?s:&lt;!--\\[if\\s.*?&lt;!\\[endif\\]--&gt;)\"\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Don't use a regular expression for this.", "You will get confused about comments containing opening tags and what not, and do the wrong thing.", "HTML isn't regular, and trying to modify it with a single regular expression will fail."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Use a HTML parser for this.", "BeautifulSoup is a good, easy, flexible and sturdy one that is able to handle real-world (meaning hopelessly broken) HTML.", "With it you can just look up all comment nodes, examine their content (you can use a regular expression for that, if you wish) and remove them if they need to be removed."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "that", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["This works in Visual Studio 2005, where there is no line span option:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\\&lt;!--\\[if IE\\]\\&gt;{.|\\n}*\\&lt;!\\[endif\\]--\\&gt;"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "\\&lt;!--\\[if IE\\]\\&gt;{.|\\n}*\\&lt;!\\[endif\\]--\\&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I'd simply go with :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nhtml = \"\"\"fjlk&lt;wb&gt;dsqfjqdsmlkf fdsijfmldsqjfl fjdslmfkqsjf&lt;---- fdjslmjkqfs---&gt;&lt;!--[if lt IE 7.]&gt;\\\n&lt;script defer type=\"text/javascript\" src=\"pngfix_253168.js\"&gt;&lt;/script&gt;&lt;!--png fix for IE--&gt;\\\n&lt;![endif]--&gt;fjlk&lt;wb&gt;dsqfjqdsmlkf fdsijfmldsqjfl fjdslmfkqsjf&lt;---- fdjslmjkqfs---&gt;\"\"\"\n\n# here the black magic occurs (whithout '.')\nclean_html = ''.join(re.split(r'&lt;!--\\[[^\u00f8]+?endif]--&gt;', html))\n\nprint clean_html\n\n'fjlk&lt;wb&gt;dsqfjqdsmlkf fdsijfmldsqjfl fjdslmfkqsjf&lt;---- fdjslmjkqfs---&gt;fjlk&lt;wb&gt;dsqfjqdsmlkf fdsijfmldsqjfl fjdslmfkqsjf&lt;---- fdjslmjkqfs---&gt;'\n</code>\n</pre>\n", "senID": 1}, {"text": ["N.B : [^\u00f8] will match any char that is not '\u00f8'.", "This is really useful since it's lightning fast and this char can be found on any keyboard.", "But the trick is it's really hard to type (no one will type it by mistake) and nobody uses it : it's a generical money devise char."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you don't feel like using \u00f8, however, you can use chr(7) to generate the \"system bell\" char, wich is unprintable and can't be found in a web page ;-)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]