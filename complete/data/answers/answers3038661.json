[[{"text": ["python-graph"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "python-graph", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/python-graph/"}]}, {"text": ["added:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "added:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The comments made me curious as to how the performance of pygraph was for a problem on the order of the OP, so I made a toy program to find out.", "Here's the output for a slightly smaller version of the problem:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ python2.6 biggraph.py 4 6\nbiggraph generate 10000 nodes     00:00:00\nbiggraph generate 1000000 edges   00:00:00\nbiggraph add edges                00:00:05\nbiggraph Dijkstra                 00:01:32\nbiggraph shortest_path done       00:04:15\nstep: 1915 2\nstep: 0 1\nbiggraph walk done                00:04:15\npath: [9999, 1915, 0]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Not too bad for 10k nodes and 1M edges.", "It is important to note that the way Dijkstra's is computed by pygraph yields a dictionary of all spanning trees for each node relative to one target (which was arbitrarily node 0, and holds no privileged position in the graph).", "Therefore, the solution that took 3.75 minutes to compute actually yielded the answer to \"what is the shortest path from all nodes to the target?\".", "Indeed once shortest_path was done, walking the answer was mere dictionary lookups and took essentially no time.", "It is also worth noting that adding the pre-computed edges to the graph was rather expensive at ~1.5 minutes.", "These timings are consistent across multiple runs."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "shortest_path", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["I'd like to say that the process scales well, but I'm still waiting on biggraph 5 6 on an otherwise idled computer (Athlon 64, 4800 BogoMIPS per processor, all in core) which has been running for over a quarter hour.", "At least the memory use is stable at about 0.5GB.", "And the results are in:"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "biggraph 5 6", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "BogoMIPS", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/BogoMips"}]}, {"code": "<pre>\n<code>\n biggraph generate 100000 nodes    00:00:00\nbiggraph generate 1000000 edges   00:00:00\nbiggraph add edges                00:00:07\nbiggraph Dijkstra                 00:01:27\nbiggraph shortest_path done       00:23:44\nstep: 48437 4\nstep: 66200 3\nstep: 83824 2\nstep: 0 1\nbiggraph walk done                00:23:44\npath: [99999, 48437, 66200, 83824, 0]\n</code>\n</pre>\n", "senID": 6}, {"text": ["That's a long time, but it was also a heavy computation (and I really wish I'd pickled the result).", "Here's the code for the curious:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n\nimport pygraph.classes.graph\nimport pygraph.algorithms\nimport pygraph.algorithms.minmax\nimport time\nimport random\nimport sys\n\nif len(sys.argv) != 3:\n    print ('usage %s: node_exponent edge_exponent' % sys.argv[0])\n    sys.exit(1)\n\nnnodes = 10**int(sys.argv[1])\nnedges = 10**int(sys.argv[2])\n\nstart_time = time.clock()\ndef timestamp(s):\n    t = time.gmtime(time.clock() - start_time)\n    print 'biggraph', s.ljust(24), time.strftime('%H:%M:%S', t)\n\ntimestamp('generate %d nodes' % nnodes)\nbg = pygraph.classes.graph.graph()\nbg.add_nodes(xrange(nnodes))\n\ntimestamp('generate %d edges' % nedges)\nedges = set()\nwhile len(edges) &lt; nedges:\n    left, right = random.randrange(nnodes), random.randrange(nnodes)\n    if left == right:\n        continue\n    elif left &gt; right:\n        left, right = right, left\n    edges.add((left, right))\n\ntimestamp('add edges')\nfor edge in edges:\n    bg.add_edge(edge)\n\ntimestamp(\"Dijkstra\")\ntarget = 0\nspan, dist = pygraph.algorithms.minmax.shortest_path(bg, target)\ntimestamp('shortest_path done')\n\n# the paths from any node to target is in dict span, let's\n# pick any arbitrary node (the last one) and walk to the\n# target from there, the associated distance will decrease\n# monotonically\nlastnode = nnodes - 1\npath = []\nwhile lastnode != target:\n    nextnode = span[lastnode]\n    print 'step:', nextnode, dist[lastnode]\n    assert nextnode in bg.neighbors(lastnode)\n    path.append(lastnode)\n    lastnode = nextnode\npath.append(target)\ntimestamp('walk done')\nprint 'path:', path\n</code>\n</pre>\n", "senID": 8}], [{"text": ["For large graphs, try the Python interface of igraph.", "Its core is implemented in C, therefore it can cope with graphs with millions of vertices and edges relatively easily.", "It contains a BFS implementation (among other algorithms) and it also includes Dijkstra's algorithm and the Bellman-Ford algorithm for weighted graphs."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "igraph", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://igraph.sf.net"}]}, {"text": ["As for \"realtimeness\", I made some quick tests as well:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from igraph import *\nfrom random import randint\nimport time\n\ndef test_shortest_path(graph, tries=1000):\n    t1 = time.time()\n    for _ in xrange(tries):\n        v1 = randint(0, graph.vcount()-1)\n        v2 = randint(0, graph.vcount()-1)\n        sp = graph.get_shortest_paths(v1, v2)\n    t2 = time.time()\n    return (t2-t1)/tries\n\n&gt;&gt;&gt; print test_shortest_path(Graph.Barabasi(100000, 100))     \n0.010035698396\n&gt;&gt;&gt; print test_shortest_path(Graph.GRG(1000000, 0.002))\n0.413572219742\n</code>\n</pre>\n", "senID": 2}, {"text": ["According to the code snippet above, finding a shortest path between two given vertices in a small-world graph having 100K vertices and 10M edges (10M = 100K * 100) takes about 0.01003 seconds on average (averaged from 1000 tries).", "This was the first test case and it is a reasonable estimate if you are working with social network data or some other network where the diameter is known to be small compared to the size of the network.", "The second test is a geometric random graph where 1 million points are dropped randomly on a 2D plane and two points are connected if their distance is less than 0.002, resulting in a graph with about 1M vertices and 6.5M edges.", "In this case, the shortest path calculation takes longer (as the paths themselves are longer), but it is still pretty close to real-time: 0.41357 seconds on average."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Disclaimer: I am one of the authors ofigraph."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "Disclaimer: I am one of the authors ofigraph.", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "igraph", "tag": "a"}]}, {"href": "http://igraph.sf.net", "text": "igraph", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Dijkstra's algorithm"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Dijkstra's algorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm"}]}], [{"text": ["For a graph that large (and with your performance constraints), you probably want the Boost Graph Library since it's written in C++.", "It has the Python bindings you are looking for."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Boost Graph Library", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.google.com/url?sa=t&source=web&cd=1&ved=0CBIQFjAA&url=http%3A%2F%2Fwww.boost.org%2Fdoc%2Flibs%2Frelease%2Flibs%2Fgraph&ei=GVgWTOXjJsWBlAeUt4SZDA&usg=AFQjCNHFslcAYOlsIhhpogpi-ZN1DhiHfw&sig2=xL1ihbd4qgQ3g_0GiS1ATQ"}, {"text": "Python bindings", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://osl.iu.edu/~dgregor/bgl-python/"}]}], [{"text": ["Well, it depends on how much metadata you have attached to your nodes and edges.", "If relatively little, that size of graph would fit into memory, and I'd thus recommend the excellent NetworkX package (see especially http://networkx.lanl.gov/reference/generated/networkx.shortest_path.html), which is pure Python."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://networkx.lanl.gov/reference/generated/networkx.shortest_path.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://networkx.lanl.gov/reference/generated/networkx.shortest_path.html"}]}, {"text": ["For a more robust solution that can handle many millions of nodes, large metadata, with transactions, disk storage, etc., I've had great luck with neo4j (http://www.neo4j.org/).", "It is written in Java but has Python bindings or can be run as a REST server.", "Traversal with it is a little tricker but not bad."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["BFS in an undirected graph is only about 25 lines of code.", "You don't need a library.", "Check out the example code in the Wikipedia article."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Wikipedia article", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Breadth-first_search"}]}], [{"text": ["Depending on what kind of additional information you have, A* may be extremely efficient.", "In particular, if given a node you can compute an estimate of the cost from that node to the goal, A* is optimally efficient."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]