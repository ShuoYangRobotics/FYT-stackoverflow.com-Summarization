[[{"text": ["Exceptions are not conditionals."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The conditional version is clearer.", "That's natural: this is straightforward flow control, which is what conditionals are designed for, not exceptions."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The exception version is primarily used as an optimization when doing these lookups in a loop: for some algorithms it allows eliminating tests from inner loops.", "It doesn't have that benefit here.", "It has the small advantage that it avoids having to say \"blah\" twice, but if you're doing a lot of these you should probably have a helper move_key function anyway."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "\"blah\"", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "move_key", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In general, I'd strongly recommend sticking with the conditional version by default unless you have a specific reason not to.", "Conditionals are the obvious way to do this, which is usually a strong recommendation to prefer one solution over another."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "obvious", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["From what I understand, you want to update dict A with key,value pairs from dict B"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["updateis a better choice."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "updateis a better choice.", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "update", "tag": "code"}]}, {"text": "update", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n A.update(B)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; A = {'a':1, 'b': 2, 'c':3}\n&gt;&gt;&gt; B = {'d': 2, 'b':5, 'c': 4}\n&gt;&gt;&gt; A.update(B)\n&gt;&gt;&gt; A\n{'a': 1, 'c': 4, 'b': 5, 'd': 2}\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I think the general rule here is will A[\"blah\"] normally exist, if so try-except is good if not then use if \"blah\" in b:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "A[\"blah\"]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "if \"blah\" in b:", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I think \"try\" is cheap in time but \"except\" is more expensive."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["There is also a third way that avoids both exceptions and double-lookup, which can be important if the lookup is expensive:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n value = B.get(\"blah\", None)\nif value is not None: \n    A[\"blah\"] = value\n</code>\n</pre>\n", "senID": 1}, {"text": ["In case you expect the dictionary to contain None values, you can use some more esoteric constants like NotImplemented, Ellipsis or make a new one:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "NotImplemented", "childNum": 0, "tag": "code", "childList": []}, {"text": "Ellipsis", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n MyConst = object()\ndef update_key(A, B, key):\n    value = B.get(key, MyConst)\n    if value is not MyConst: \n        A[key] = value\n</code>\n</pre>\n", "senID": 3}, {"text": ["Anyway, using update() is the most readable option for me:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "update()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a.update((k, b[k]) for k in (\"foo\", \"bar\", \"blah\") if k in b)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Personally, I lean towards the second method (but using has_key):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "has_key", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if B.has_key(\"blah\"):\n  A[\"blah\"] = B[\"blah\"]\n</code>\n</pre>\n", "senID": 1}, {"text": ["That way, each assignment operation is only two lines (instead of 4 with try/except), and any exceptions that get thrown will be real errors or things you've missed (instead of just trying to access keys that aren't there)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["As it turns out (see the comments on your question), has_key is deprecated - so I guess it's better written as"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "has_key", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if \"blah\" in B:\n  A[\"blah\"] = B[\"blah\"]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The rule in other languages is to reserve exceptions for exceptional conditions, i.e.", "errors that don't occur in regular use.", "Don't know how that rule applies to Python, as StopIteration shouldn't exist by that rule."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I think the second example is what you should go for unless this code makes sense:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    A[\"foo\"] = B[\"foo\"]\n    A[\"bar\"] = B[\"bar\"]\n    A[\"baz\"] = B[\"baz\"]\nexcept KeyError:\n    pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["Keep in mind that code will abort as soon as there is a key that isn't in B.", "If this code makes sense, then you should use the exception method, otherwise use the test method.", "In my opinion, because it's shorter and clearly expresses the intent, it's a lot easier to read than the exception method."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "B", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Of course, the people telling you to use update are correct.", "If you are using a version of Python that supports dictionary comprehensions, I would strongly prefer this code:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "update", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n updateset = {'foo', 'bar', 'baz'}\nA.update({k: B[k] for k in updateset if k in B})\n</code>\n</pre>\n", "senID": 4}]]