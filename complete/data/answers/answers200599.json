[[{"text": ["I don't tackle the question which one is best.", "If you want to handle text-files, I'd consider ConfigParser -module.", "Another you could give a try would be simplejson or yaml.", "You could also consider a real db table."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "ConfigParser -module", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-ConfigParser.html"}, {"text": "simplejson", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://undefined.org/python/"}, {"text": "yaml", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.yaml.org/"}]}, {"text": ["For instance, you could have a table called userattrs, with three columns:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Int user_id", "tag": "none", "senID": 2}, {"text": "String attribute_name", "tag": "none", "senID": 3}, {"text": "String attribute_value", "tag": "none", "senID": 4}]}, {"text": ["If there's only few, you could store them into cookies for quick retrieval."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I would use the ConfigParser module, which produces some pretty readable and user-editable output for your example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ConfigParser", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-ConfigParser.html"}]}, {"code": "<pre>\n[bob]\ncolour_scheme: blue\nbritish: yes\n[joe]\ncolor_scheme: that's 'color', silly!\nbritish: no\n</pre>\n", "senID": 1}, {"text": ["The following code would produce the config file above, and then print it out:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import sys\nfrom ConfigParser import *\n\nc = ConfigParser()\n\nc.add_section(\"bob\")\nc.set(\"bob\", \"colour_scheme\", \"blue\")\nc.set(\"bob\", \"british\", str(True))\n\nc.add_section(\"joe\")\nc.set(\"joe\", \"color_scheme\", \"that's 'color', silly!\")\nc.set(\"joe\", \"british\", str(False))\n\nc.write(sys.stdout)  # this outputs the configuration to stdout\n                     # you could put a file-handle here instead\n\nfor section in c.sections(): # this is how you read the options back in\n    print section\n    for option in c.options(section):\n            print \"\\t\", option, \"=\", c.get(section, option)\n\nprint c.get(\"bob\", \"british\") # To access the \"british\" attribute for bob directly\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that ConfigParser only supports strings, so you'll have to convert as I have above for the Booleans.", "See effbot for a good run-down of the basics."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "effbot", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://effbot.org/librarybook/configparser.htm"}]}], [{"text": ["Using cPickle on the dictionary would be my choice.", "Dictionaries are a natural fit for these kind of data, so given your requirements I see no reason not to use them.", "That, unless you are thinking about reading them from non-python applications, in which case you'd have to use a language neutral text format.", "And even here you could get away with the pickle plus an export tool."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "cPickle", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-cPickle.html"}]}], [{"text": ["Here's the simplest way.", "Use simple variables and import the settings file."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "import", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Call the file userprefs.py"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # a user prefs file\ncolor = 0x010203\nfont = \"times new roman\"\nposition = ( 12, 13 )\nsize = ( 640, 480 )\n</code>\n</pre>\n", "senID": 2}, {"text": ["In your application, you need to be sure that you can import this file.", "You have many choices."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "many", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Example"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import sys\nimport os\nsys.path.insert(0,os.path.expanduser(\"~\"))\nimport userprefs \nprint userprefs.color\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I would use shelve or an sqlite database if I would have to store these setting on the file system.", "Although, since you are building a website you probably use some kind of database so why not just use that?"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "shelve", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-shelve.html"}, {"text": "sqlite", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-sqlite3.html"}]}], [{"text": ["For a database-driven website, of course, your best option is a db table.", "I'm assuming that you are not doing the database thing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you don't care about human-readable formats, then pickle is a simple and straightforward way to go.", "I've also heard good reports about simplejson."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "pickle", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "simplejson", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If human readability is important, two simple options present themselves:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Module: Just use a module.", "If all you need are a few globals and nothing fancy, then this is the way to go.", "If you really got desperate, you could define classes and class variables to emulate sections.", "The downside here: if the file will be hand-edited by a user, errors could be hard to catch and debug."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Module:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["INI format: I've been using ConfigObj for this, with quite a bit of success.", "ConfigObj is essentially a replacement for ConfigParser, with support for nested sections and much more.", "Optionally, you can define expected types or values for a file and validate it, providing a safety net (and important error feedback) for users/administrators."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "INI format:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "ConfigObj", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.voidspace.org.uk/python/configobj.html"}]}], [{"text": ["This sounds like a job for (quickly enter and exit a phonebooth) XML!  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(Or yaml or JSON or whatever your favorite data interchange language is)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If human readablity of configfiles matters an alternative might be the ConfigParser module which allows you to read and write .ini like files.", "But then you are restricted to one nesting level."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "the ConfigParser module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/lib/module-ConfigParser.html"}]}], [{"text": ["The built-in sqlite3 module would probably be far simpler than most alternatives, and gets you ready to update to a full RDBMS should you ever want or need to."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sqlite3", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-sqlite3.html"}]}], [{"text": ["If you have a database, I might suggest storing the settings in the database.", "However, it sounds like ordinary files might suit your environment better."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You probably don't want to store all the users settings in the same file, because you might run into trouble with concurrent access to that one file.", "If you stored each user's settings as a dictionary in their own pickled file, then they would be able to act independently."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "all", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Pickling is a reasonable way to store such data, but unfortunately the pickle data format is notoriously not-human-readable.", "You might be better off storing it as repr(dictionary) which will be a more readable format.", "To reload the user settings, use eval(open(\"file\").read()) or something like that."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "repr(dictionary)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "eval(open(\"file\").read())", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["Is there are particular reason you're not using the database for this?", "it seems the normal and natural thing to do - or store a pickle of the settings in the db keyed on user id or something."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You haven't described the usage patterns of the website, but just thinking of a general website - but I would think that keeping the settings in a database would cause much less disk I/O than using files."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["OTOH, for settings that might be used by client-side code, storing them as javascript in a static file that can be cached would be handy - at the expense of having multiple places you might have settings.", "(I'd probably store those settings in  the db, and rebuild the static files as necessary)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I agree with the reply about using Pickled Dictionary.", "Very simple and effective for storing simple data in a Dictionary structure."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you don't care about being able to edit the file yourself, and want a quick way to persist python objects, go with pickle.", "If you do want the file to be readable by a human, or readable by some other app, use ConfigParser.", "If you need anything more complex, go with some sort of database, be it relational (sqlite), or object-oriented (axiom, zodb)."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "pickle", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-pickle.html"}, {"text": "ConfigParser", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-ConfigParser.html"}, {"text": "sqlite", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/module-sqlite3.html"}, {"href": "http://www.divmod.org/trac/wiki/DivmodAxiom", "text": "axiom", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://wiki.zope.org/ZODB/FrontPage", "text": "zodb", "childNum": 0, "tag": "a", "childList": []}]}]]