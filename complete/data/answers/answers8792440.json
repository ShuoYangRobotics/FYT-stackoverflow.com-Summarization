[[{"code": "<pre>\n<code>\n z = (set((\"a\", \"b\", \"c\")) - set((x, y))).pop()\n</code>\n</pre>\n", "senID": 0}, {"text": ["I am assuming that one of the three cases in your code holds.", "If this is the case, the set set((\"a\", \"b\", \"c\")) - set((x, y)) will consist of a single element, which is returned by pop()."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "set((\"a\", \"b\", \"c\")) - set((x, y))", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "pop()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: As suggested by Raymond Hettinger in the comments, you could also use tuple unpacking to extract the single element from the set:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n z, = set((\"a\", \"b\", \"c\")) - set((x, y))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The strip method is another option that runs quickly for me:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "strip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n z = 'abc'.strip(x+y) if x!=y else None\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Sven's excellent code did just a little too much work and chould have used tuple unpacking instead of pop().", "Also, it could have added a guard if x != y to check for x and y being distinct.", "Here is what the improved answer looks like:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "pop()", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "if x != y", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "x", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "y", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n # create the set just once\nchoices = {'a', 'b', 'c'}\n\nx = 'a'\ny = 'b'\n\n# the main code can be used in a loop\nif x != y:\n    z, = choices - {x, y}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here are the comparative timings with a timing suite to show the relative performance:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import timeit, itertools\n\nsetup_template = '''\nx = %r\ny = %r\nchoices = {'a', 'b', 'c'}\n'''\n\nnew_version = '''\nif x != y:\n    z, = choices - {x, y}\n'''\n\noriginal_version = '''\nif x == 'a' and y == 'b' or x == 'b' and y == 'a':\n    z = 'c'\nelif x == 'b' and y == 'c' or x == 'c' and y == 'b':\n    z = 'a'\nelif x == 'a' and y == 'c' or x == 'c' and y == 'a':\n    z = 'b'\n'''\n\nfor x, y in itertools.product('abc', repeat=2):\n    print '\\nTesting with x=%r and y=%r' % (x, y)\n    setup = setup_template % (x, y)\n    for stmt, name in zip([original_version, new_version], ['if', 'set']):\n        print min(timeit.Timer(stmt, setup).repeat(7, 100000)),\n        print '\\t%s_version' % name\n</code>\n</pre>\n", "senID": 3}, {"text": ["Here are the results of the timings:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n Testing with x='a' and y='a'\n0.0410830974579     original_version\n0.00535297393799    new_version\n\nTesting with x='a' and y='b'\n0.0112571716309     original_version\n0.0524711608887     new_version\n\nTesting with x='a' and y='c'\n0.0383319854736     original_version\n0.048309803009      new_version\n\nTesting with x='b' and y='a'\n0.0175108909607     original_version\n0.0508949756622     new_version\n\nTesting with x='b' and y='b'\n0.0386209487915     original_version\n0.00529098510742    new_version\n\nTesting with x='b' and y='c'\n0.0259420871735     original_version\n0.0472128391266     new_version\n\nTesting with x='c' and y='a'\n0.0423510074615     original_version\n0.0481910705566     new_version\n\nTesting with x='c' and y='b'\n0.0295209884644     original_version\n0.0478219985962     new_version\n\nTesting with x='c' and y='c'\n0.0383579730988     original_version\n0.00530385971069    new_version\n</code>\n</pre>\n", "senID": 5}, {"text": ["These timings show that the original-version performance varies quite a bit depending on which if-statements are triggered by the various the input values."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "original-version", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n z = (set('abc') - set(x + y)).pop()\n</code>\n</pre>\n", "senID": 0}, {"text": ["Here are all of the scenarios to show that it works:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; (set('abc') - set('ab')).pop()   # x is a/b and y is b/a\n'c'\n&gt;&gt;&gt; (set('abc') - set('bc')).pop()   # x is b/c and y is c/b\n'a'\n&gt;&gt;&gt; (set('abc') - set('ac')).pop()   # x is a/c and y is c/a\n'b'\n</code>\n</pre>\n", "senID": 2}], [{"text": ["If the three items in question weren't \"a\", \"b\" and \"c\", but rather 1, 2 and 3, you could also use a binary XOR:"], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "\"a\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\"b\"", "childNum": 0, "tag": "code", "childList": []}, {"text": "\"c\"", "childNum": 0, "tag": "code", "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}, {"text": "2", "childNum": 0, "tag": "code", "childList": []}, {"text": "3", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n z = x ^ y\n</code>\n</pre>\n", "senID": 1}, {"text": ["More generally, if you want to set z to the remaining one of three numbers a, b and c given two numbers x and y from this set, you can use"], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "z", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n z = x ^ y ^ a ^ b ^ c\n</code>\n</pre>\n", "senID": 3}, {"text": ["Of course you can precompute a ^ b ^ c if the numbers are fixed."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "a ^ b ^ c", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This approach can also be used with the original letters:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n z = chr(ord(x) ^ ord(y) ^ 96)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; chr(ord(\"a\") ^ ord(\"c\") ^ 96)\n'b'\n</code>\n</pre>\n", "senID": 8}, {"text": ["Don't expect anyone reading this code to immediately figure out what it means :)"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["I think the solution by Sven Marnach and F.J is beautiful, but it's not faster in my little test.", "This is Raymond's optimized version using a pre-computed set:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre class=\"lang-sh prettyprint-override\">\n<code>\n $ python -m timeit -s \"choices = set('abc')\" \\\n                   -s \"x = 'c'\" \\\n                   -s \"y = 'a'\" \\\n                      \"z, = choices - set(x + y)\"\n1000000 loops, best of 3: 0.689 usec per loop\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is the original solution:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre class=\"lang-sh prettyprint-override\">\n<code>\n $ python -m timeit -s \"x = 'c'\" \\\n                   -s \"y = 'a'\" \\\n                      \"if x == 'a' and y == 'b' or x == 'b' and y == 'a':\" \\\n                      \"    z = 'c'\" \\\n                      \"elif x == 'b' and y == 'c' or x == 'c' and y == 'b':\" \\\n                      \"    z = 'a'\" \\\n                      \"elif x == 'a' and y == 'c' or x == 'c' and y == 'a':\" \\\n                      \"    z = 'b'\"\n10000000 loops, best of 3: 0.310 usec per loop\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that this is the worst possible input for the if-statements since all six comparisons will have to be tried out.", "Testing with all values for x and y gives:"], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "worst possible input", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "if", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre class=\"lang-sh prettyprint-override\">\n<code>\n x = 'a', y = 'b': 0.084 usec per loop\nx = 'a', y = 'c': 0.254 usec per loop\nx = 'b', y = 'a': 0.133 usec per loop\nx = 'b', y = 'c': 0.186 usec per loop\nx = 'c', y = 'a': 0.310 usec per loop\nx = 'c', y = 'b': 0.204 usec per loop\n</code>\n</pre>\n", "senID": 5}, {"text": ["The set-based variant shows the same performance for different inputs, but it is consistently between 2 and 8 times slower.", "The reason is that the if-based variant runs much simpler code: equality tests compared to hashing."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "2 and 8 times slower", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "if", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I think both types of solutions are valuable: it's important to know that creating \"complicated\" data structures like sets cost you something in performance \u2014 while they give you a lot in readability and development speed.", "The complex data types are also much better when the code change: it's easy to extend the set-based solution to four, five, ... variables whereas the if-statements quickly turn into a maintenance nightmare."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "development speed", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n z = 'a'*('a' not in x+y) or 'b'*('b' not in x+y) or 'c'\n</code>\n</pre>\n", "senID": 0}, {"text": ["or less hackish and using Conditional Assignment"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n z = 'a' if ('a' not in x+y) else 'b' if ('b' not in x+y) else 'c'\n</code>\n</pre>\n", "senID": 2}, {"text": ["but probably the dict solution is faster... you'd have to time it."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Try this option, using dictionaries:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n z = {'ab':'c', 'ba':'c', 'bc':'a', 'cb':'a', 'ac':'b', 'ca':'b'}[x+y]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course, if the x+y key is not present in the map, it'll produce a KeyError which you'll have to handle."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "x+y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "KeyError", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If the dictionary is precomputed a single time and stored for future use, the access will be much faster, since no new data structures will have to be created for each evaluation, only a string concatenation and a dictionary lookup are needed:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n lookup_table = {'ab':'c', 'ba':'c', 'bc':'a', 'cb':'a', 'ac':'b', 'ca':'b'}\nz = lookup_table[x+y]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I think it should looks like that:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n z = (set((\"a\", \"b\", \"c\")) - set((x, y))).pop() if x != y else None\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using list comprehension, assuming like others that one of the three cases in your code holds:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = ['a', 'b', 'c']\nz = [n for n in l if n not in [x,y]].pop()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or, like in the accepted answer, taking advantage of the tuple to unpack it,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n z, = [n for n in l if n not in [x,y]]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If x and y can only be one of a, b, or c, and must be distinct values, it's more efficient to check whether they are equal before making the other tests.", "That also allows the other tests to be simplified by using the in operator:"], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}, {"text": "in", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n if x != y:\n    if x in 'ab' and y in 'ab':\n        z = 'c'\n    elif x in 'bc' and y in 'bc':\n        z = 'a'\n    elif x in 'ac' and y in 'ac':\n        z = 'b'\n</code>\n</pre>\n", "senID": 1}, {"text": ["This satisfies the all the OP's conditions of being \"more concise, readable and efficient\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["See if this works"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if a not in xy\n    z= 'a'\nif b not in xy\n    z='b'\nif c not in xy\n    z='c'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The following gives more precise answer.", "z = a + b + c - x - y;"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This arithmetic takes ascii value in adding/subtracting and sets the missing value ( ascii ) to variable z."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]