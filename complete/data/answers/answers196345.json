[[{"text": ["I think you are not  asking the right question--"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A string in python has no property corresponding to 'ascii', utf-8, or any other encoding.", "The source of your string (whether you read it from a file, input from a keyboard, etc.", ") may have encoded a unicode string in ascii to produce your string, but that's where you need to go for an answer."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Perhaps the question you can ask is: \"Is this string the result of encoding a unicode string in ascii?", "\" -- This you can answer\n    by trying:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n try:\n    mystring.decode('ascii')\nexcept UnicodeDecodeError:\n    print \"it was not a ascii-encoded unicode string\"\nelse:\n    print \"It may have been an ascii-encoded unicode string\"\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n def is_ascii(s):\n    return all(ord(c) &lt; 128 for c in s)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Your question is incorrect; the error you see is not a result of how you built python, but of a confusion between byte strings and unicode strings."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Byte strings (e.g.", "\"foo\", or 'bar', in python syntax) are sequences of octets; numbers from 0-255.", "Unicode strings (e.g.", "u\"foo\" or u'bar') are sequences of unicode code points; numbers from 0-1112064.", "But you appear to be interested in the character \u00e9, which (in your terminal) is a multi-byte sequence that represents a single character."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Instead of ord(u'\u00e9'), try this:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "ord(u'\u00e9')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [ord(x) for x in u'\u00e9']\n</code>\n</pre>\n", "senID": 3}, {"text": ["That tells you which sequence of code points \"\u00e9\" represents.", "It may give you [233], or it may give you [101, 770]."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Instead of chr() to reverse this, there is unichr():"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "chr()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "unichr()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; unichr(233)\nu'\\xe9'\n</code>\n</pre>\n", "senID": 6}, {"text": ["This character may actually be represented either a single or multiple unicode \"code points\", which themselves represent either graphemes or characters.", "It's either \"e with an acute accent (i.e., code point 233)\", or \"e\" (code point 101), followed by \"an acute accent on the previous character\" (code point 770).", "So this exact same character may be presented as the Python data structure u'e\\u0301' or u'\\u00e9'."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "u'e\\u0301'", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "u'\\u00e9'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Most of the time you shouldn't have to care about this, but it can become an issue if you are iterating over a unicode string, as iteration works by code point, not by decomposable character.", "In other words, len(u'e\\u0301') == 2 and len(u'\\u00e9') == 1.", "If this matters to you, you can convert between composed and decomposed forms by using unicodedata.normalize."], "childNum": 4, "tag": "p", "senID": 8, "childList": [{"text": "len(u'e\\u0301') == 2", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "len(u'\\u00e9') == 1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "unicodedata.normalize", "tag": "a", "pos": 2, "childList": [{"text": "unicodedata.normalize", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/unicodedata.html#unicodedata.normalize"}, {"text": "unicodedata.normalize", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The Unicode Glossary can be a helpful guide to understanding some of these issues, by pointing how how each specific term refers to a different part of the representation of text, which is far more complicated than many programmers realize."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "The Unicode Glossary", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://unicode.org/glossary/"}]}], [{"text": ["How about doing this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import string\n\ndef isAscii(s):\n    for c in s:\n        if c not in string.ascii_letters:\n            return False\n    return True\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could use the regular expression library which accepts the Posix standard [[:ASCII:]] definition."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["A sting (str-type) in Python is a series of bytes.", "There is no way of telling just from looking at the string whether this series of bytes represent an ascii string, a string in a 8-bit charset like ISO-8859-1 or a string encoded with UTF-8 or UTF-16 or whatever."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "no way", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["However if you know the encoding used, then you can decode the str into a unicode string and then use a regular expression (or a loop) to check if it contains characters outside of the range you are concerned about."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "decode", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Ran into something like this recently - for future reference"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import chardet\n\nencoding = chardet.detect(string)\nif encoding['encoding'] == 'ascii':\n    print 'string is in ascii'\n</code>\n</pre>\n", "senID": 1}, {"text": ["which you could use with:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n string_ascii = string.decode(encoding['encoding']).encode('ascii')\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Use the 'type' function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; type('\u00e9')\n&lt;type 'str'&gt;\n&gt;&gt;&gt; type('\u00e9'.decode('utf-8'))\n&lt;type 'unicode'&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I use the following to determine if the string is ascii or unicode:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt; print 'test string'.__class__.__name__\nstr\n&gt;&gt;&gt; print u'test string'.__class__.__name__\nunicode\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then just use a conditional block to define the function:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def is_ascii(input):\n    if input.__class__.__name__ == \"str\":\n        return True\n    return False\n</code>\n</pre>\n", "senID": 3}]]