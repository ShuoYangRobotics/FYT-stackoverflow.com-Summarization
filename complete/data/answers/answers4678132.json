[[{"code": "<pre>\n<code>\n names = [('A', 'John', 'Paul', 'Smith'),\n('Matthew', 'M', 'Phil', 'Bond'),\n('A', 'Morris', 'O', 'Reil', 'M', 'Big')]\n\ndef getItem():\n    for name in names:\n        for (pos,item) in enumerate(name):\n            yield item\n\nitembase = getItem()\n\nfor i in enumerate(names):\n    element = itembase.next()\n    if len(element) == 1: firstName = element+\" \"+itembase.next()\n    else: firstName = element\n    element = itembase.next()\n    if len(element) == 1: mName = element+\" \"+itembase.next()\n    else: mName = element\n    element = itembase.next()\n    if len(element) == 1: lastName = element+\" \"+itembase.next()\n    else: lastName = element\n\n    print \"First Name: \"+firstName\n    print \"Middle Name: \"+mName\n    print \"Last Name: \"+lastName\n    print \"--\"\n</code>\n</pre>\n", "senID": 0}, {"text": ["This seems to work.", "Replace the len(element) == 1 condition (I didn't know you needed checking for only 3, so I've done one with any single letter) with conditions looking for three prefixes you have."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "len(element) == 1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n **Output**\nFirst Name: A John\nMiddle Name: Paul\nLast Name: Smith\n\nFirst Name: Matthew\nMiddle Name: M Phil\nLast Name: Bond\n\nFirst Name: A Morris\nMiddle Name: O Reil\nLast Name: M Big\n</code>\n</pre>\n", "senID": 2}], [{"text": ["How about this complete test script:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\n\ndef process(file):\n    for line in file:\n        arr = line.split()\n        if not arr:\n            continue\n        last = arr.pop()\n        n = len(arr)\n        if n == 4:\n            first, middle = ' '.join(arr[:2]), ' '.join(arr[2:])\n        elif n == 3:\n            if arr[0] in ('M', 'Shk', 'BS'):\n                first, middle = ' '.join(arr[:2]), arr[-1]\n            else:\n                first, middle = arr[0], ' '.join(arr[1:])\n        elif n == 2:\n            first, middle = arr\n        else:\n            continue\n        print 'First: %r' % first\n        print 'Middle: %r' % middle\n        print 'Last: %r' % last\n\nif __name__ == '__main__':\n    process(sys.stdin)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you run this on Linux, type in example lines and then press Ctrl+D to signify end-of-input.", "On Windows, use Ctrl+Z instead of Ctrl+D.", "You can also pipe in a file, of course."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The following input file:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n First Middle Last\nM First Middle Last\nFirst Shk Middle Last\nBS First M Middle Last\n</code>\n</pre>\n", "senID": 4}, {"text": ["gives this output:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n First: 'First'\nMiddle: 'Middle'\nLast: 'Last'\nFirst: 'M First'\nMiddle: 'Middle'\nLast: 'Last'\nFirst: 'First'\nMiddle: 'Shk Middle'\nLast: 'Last'\nFirst: 'BS First'\nMiddle: 'M Middle'\nLast: 'Last'\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Here you go, in an object-oriented way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Name(object):\n    def __init__(self, fullname):\n        self.full = fullname\n        s = self.full.split()\n\n        try:\n            self.first = \" \".join(s[:2]) if len(s[0]) == 1 else s[0]\n            s = s[len(self.first.split()):]\n\n            self.middle = \" \".join(s[:2]) if len(s[0]) == 1 else s[0]\n            s = s[len(self.middle.split()):]\n\n            self.last = \" \".join(s[:2]) if len(s[0]) == 1 else s[0]\n        finally:\n            pass\n\nnames = [\n    \"First Middle Last\",\n    \"P First Middle Last\",\n    \"First P Middle Last\",\n    \"P First p Middle Last\",\n]\n\nfor fullname in names:\n    name = Name(fullname)\n    print (name.first, name.middle, name.last)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If 'M', 'Shk' and 'BS' are not valid names/surnames, i.e.", "you don't care about their exact position, you could filter them out with a one-liner:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n first, middle, last = filter(lambda x: x not in ('M','Shk','BS'), yourNameHere.split())\n</code>\n</pre>\n", "senID": 1}, {"text": ["where, of course, yourNameHere is the string containing the name you want to parse."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "yourNameHere", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Warning: for this piece of code, I assume you always have a middle name, as you specified in the above examples.", "If not, you have to get the whole list and count elements to know whether you have a middle name or not."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT: if you do care about the prefix position:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n first, middle, last = map(\n    lambda x: x[1],\n    filter(\n        lambda (i,x): i not in (0, 2) or x not in ('M','Shk','BS'),\n        enumerate(yourNameHere.split())))\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n import csv\n\nclass CsvWriter(object):\n    \"\"\"\n    Wraps csv.writer in a partial file-API compatibility layer\n    \"\"\"\n    def __init__(self, fname, mode='w', *args, **kwargs):\n        super(CsvWriter, self).__init__()\n        self.f = open(fname, mode)\n        self.writer = csv.writer(self.f, *args, **kwargs)\n\n    def write(self, *args):\n        \"\"\"\n        Writes a row of data to the csv file\n\n        Can be called as\n          .write()         puts a blank row\n          .write(2)        puts a single cell\n          .write([1,2,3])  puts 3 cells\n          .write(1,2,3)    puts 3 cells\n        \"\"\"\n        if len(args)==1 and hasattr(args[0], ('__iter__')):\n            # single argument, and it's a sequence - let it be the row data\n            rowdata = args[0]\n        else:\n            rowdata = args\n\n        self.writer.writerow(rowdata)\n\n    def close(self):\n        self.writer = None\n        self.f.close()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        self.close()\n\nclass NameSplitter(object):\n    def __init__(self, pre=None):\n        super(NameSplitter, self).__init__()\n\n        # list of accepted prefixes\n        if pre is None:\n            self.pre = set(['m','shk','bs'])\n        else:\n            self.pre = set([s.lower() for s in pre])\n\n        # is-a-prefix word tester\n        self.isPre = lambda x,p=self.pre: x.lower() in p\n\n        jn = lambda *args: ' '.join(*args)\n\n        # signature-based dispatch table\n        self.match = {}\n        self.match[(3,())]    = lambda w,j=jn: (w[0],         w[1],         w[2])\n        self.match[(4,(0,))]  = lambda w,j=jn: (j(w[0],w[1]), w[2],         w[3])\n        self.match[(4,(1,))]  = lambda w,j=jn: (w[0],         j(w[1],w[2]), w[3])\n        self.match[(5,(0,2))] = lambda w,j=jn: (j(w[0],w[1]), j(w[2],w[3]), w[4])\n\n    def __call__(self, nameStr):\n        words = nameStr.split()\n\n        # build hashable signature\n        pres  = tuple(n for n,word in enumerate(words) if self.isPre(word))\n        sig   = (len(words), pres)\n\n        try:\n            do = self.match[sig]\n            return do(words)\n        except KeyError:\n            return None\n\ndef process(inf, outf, fn):\n    for line in inf:\n        res = fn(line)\n        if res is not None:\n            outf.write(res)\n\ndef main():\n    infname = \"input.txt\"\n    outfname = \"output.csv\"\n\n    with open(infname,'rU') as inf:\n        with CsvWriter(outfname) as outf:\n            process(inf, outf, NameSplitter())\n\nif __name__==\"__main__\":\n    main()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Complete script:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\n\ndef f(a,b):\n    if b in ('M','Shk','BS'):\n            return '%s %s' % (b,a)\n    else:\n            return '%s,%s' % (b,a)\n\nfor line in sys.stdin:\n    sys.stdout.write(reduce(f, reversed(line.split(' '))))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Input:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n First Middle Last\nM First Middle Last\nFirst Shk Middle Last\nBS First M Middle Last\n</code>\n</pre>\n", "senID": 3}, {"text": ["CSV output:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n First,Middle,Last\nM First,Middle,Last\nFirst,Shk Middle,Last\nBS First,M Middle,Last\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Here's another solution (obtained by making changes to source code given in question) :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import csv\ninPath = \"input.txt\"\noutPath = \"output.txt\"\n\nnewlist = []\n\nfile = open(inPath, 'rU')\nif file:\n    for line in file:\n        member = line.split()\n        newlist.append(member)\n    file.close()\nelse:\n    print \"Error Opening File.\"\n\nfile = open(outPath, 'wb')\nif file:\n    for fullName in newlist:\n        prefix = \"\"\n        for name in fullName:\n            if name == \"P\" or name == \"p\":\n                prefix = name + \" \"\n                continue\n            print prefix+name\n            prefix = \"\"\n        print\n    file.close()\nelse:\n    print \"Error Opening File.\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would use regular expression, that particulaly designed for such purpose.", "This solution would be easily to maintain and understand."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It is worth to being tried out.", "http://docs.python.org/library/re.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/re.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html"}]}, {"code": "<pre>\n<code>\n import re\nfrom operator import truth\n\n// patterns\n                     //First    Middle   Last\nfirst = re.compile (\"^([\\w]+) +([\\w]+) ([\\w]+)$\")\n                     //P  First    Middle    Last\nsecond = re.compile (\"^(M|Shk|BS) +([\\w]+) +([\\w]+) ([\\w]+)$\") \n                    //First     P    Middle   Last\nthird = re.compile (\"^([\\w]+) +(M|Shk|BS) +([\\w]+) ([\\w]+)$\")     \n                     //P    First    p   Middle    Last\nforth = re.compile (\"^(M|Shk|BS) +([\\w]+) +(M|Shk|BS) +([\\w]+) ([\\w]+)$\")     \n\nif truth (first.search (you_string)):\n     parsed = first.search (you_string)\n     print parsed.group(1), parsed.group(2), parsed.group(3)\nelif truth (second.search (you_string)):\n     parsed = first.search (you_string)\n     print parsed.group(1), parsed.group(2), parsed.group(3)\nelif truth (third.search (you_string)):\n     parsed = first.search (you_string)\n     print parsed.group(1), parsed.group(2), parsed.group(3)\nelif truth (forth.search (you_string)):\n     parsed = first.search (you_string)\n     print parsed.group(1), parsed.group(2), parsed.group(3)\nelse:\n     print \"not match at all\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["It would execute much faster due to precompiled patterns"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]