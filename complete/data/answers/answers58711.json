[[{"text": ["You could actually pull this off, but it would require using metaclasses, which are deep magic (there be dragons).", "If you want an intro to metaclasses, there's a series of articles from IBM which manage to introduce the ideas without melting your brain."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "deep", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "articles from IBM", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.ibm.com/developerworks/linux/library/l-pymeta.html"}]}, {"text": ["The source code from an ORM like SQLObject might help, too, since it uses this same kind of declarative syntax."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n ## All you need is this class:\n\nclass MainWindow(Window):\n    my_button = Button('Click Me')\n    my_paragraph = Text('This is the text you wish to place')\n    my_alert = AlertBox('What what what!!!')\n\n    @my_button.clicked\n    def my_button_clicked(self, button, event):\n        self.my_paragraph.text.append('And now you clicked on it, the button that is.')\n\n    @my_paragraph.text.changed\n    def my_paragraph_text_changed(self, text, event):\n        self.button.text = 'No more clicks!'\n\n    @my_button.text.changed\n    def my_button_text_changed(self, text, event):\n        self.my_alert.show()\n\n\n## The Style class is automatically gnerated by the framework\n## but you can override it by defining it in the class:\n##\n##      class MainWindow(Window):\n##          class Style:\n##              my_blah = {'style-info': 'value'}\n##\n## or like you see below:\n\nclass Style:\n    my_button = {\n        'background-color': '#ccc',\n        'font-size': '14px'}\n    my_paragraph = {\n        'background-color': '#fff',\n        'color': '#000',\n        'font-size': '14px',\n        'border': '1px solid black',\n        'border-radius': '3px'}\n\nMainWindow.Style = Style\n\n## The layout class is automatically generated\n## by the framework but you can override it by defining it\n## in the class, same as the Style class above, or by\n## defining it like this:\n\nclass MainLayout(Layout):\n    def __init__(self, style):\n        # It takes the custom or automatically generated style class upon instantiation\n        style.window.pack(HBox().pack(style.my_paragraph, style.my_button))\n\nMainWindow.Layout = MainLayout\n\nif __name__ == '__main__':\n    run(App(main=MainWindow))\n</code>\n</pre>\n", "senID": 0}, {"text": ["It would be relatively easy to do in python with a bit of that metaclass python magic know how.", "Which I have.", "And a knowledge of PyGTK.", "Which I also have.", "Gets ideas?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I was never satisfied with David Mertz's articles at IBM on metaclsses so I recently wrote my own metaclass article.", "Enjoy."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "metaclass article", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://askawizard.blogspot.com/2008/09/metaclasses-python-saga-part-4_30.html"}]}], [{"text": ["This is extremely contrived and not pythonic at all, but here's my attempt at a semi-literal translation using the new \"with\" statement."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n with Shoes():\n  t = Para(\"Not clicked!\")\n  with Button(\"The Label\"):\n    Alert(\"You clicked the button!\")\n    t.replace(\"Clicked!\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["The hardest part is dealing with the fact that python will not give us anonymous functions with more than one statement in them.", "To get around that, we could create a list of commands and run through those..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Anyway, here's the backend code I ran this with:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n context = None\n\nclass Nestable(object):\n  def __init__(self,caption=None):\n    self.caption = caption\n    self.things = []\n\n    global context\n    if context:\n      context.add(self)\n\n  def __enter__(self):\n    global context\n    self.parent = context\n    context = self\n\n  def __exit__(self, type, value, traceback):\n    global context\n    context = self.parent\n\n  def add(self,thing):\n    self.things.append(thing)\n    print \"Adding a %s to %s\" % (thing,self)\n\n  def __str__(self):\n    return \"%s(%s)\" % (self.__class__.__name__, self.caption)\n\n\nclass Shoes(Nestable):\n  pass\n\nclass Button(Nestable):\n  pass\n\nclass Alert(Nestable):\n  pass\n\nclass Para(Nestable):\n  def replace(self,caption):\n    Command(self,\"replace\",caption)\n\nclass Command(Nestable):\n  def __init__(self, target, command, caption):\n    self.command = command\n    self.target  = target\n    Nestable.__init__(self,caption)\n\n  def __str__(self):\n    return \"Command(%s text of %s with \\\"%s\\\")\" % (self.command, self.target, self.caption)\n\n  def execute(self):\n    self.target.caption = self.caption\n</code>\n</pre>\n", "senID": 4}], [{"text": ["With some Metaclass magic to keep the ordering I have the following working.", "I'm not sure how pythonic it is but it is good fun for creating simple things. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class w(Wndw):\n  title='Hello World'\n  class txt(Txt):  # either a new class\n    text='Insert name here'\n  lbl=Lbl(text='Hello') # or an instance\n  class greet(Bbt):\n    text='Greet'\n    def click(self): #on_click method\n      self.frame.lbl.text='Hello %s.'%self.frame.txt.text\n\napp=w()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The closest you can get to rubyish blocks is the with statement from pep343: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.python.org/dev/peps/pep-0343/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.python.org/dev/peps/pep-0343/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0343/"}]}], [{"text": ["If you use PyGTK with glade and this glade wrapper, then PyGTK actually becomes somewhat pythonic.", "A little at least."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "PyGTK", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.pygtk.org/"}, {"text": "glade", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://glade.gnome.org/"}, {"text": "this glade wrapper", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.pixelbeat.org/libs/libglade.py"}]}, {"text": ["Basically, you create the GUI layout in Glade.", "You also specify event callbacks in glade.", "Then you write a class for your window like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class MyWindow(GladeWrapper):\n    GladeWrapper.__init__(self, \"my_glade_file.xml\", \"mainWindow\")\n    self.GtkWindow.show()\n\n    def button_click_event (self, *args):\n        self.button1.set_label(\"CLICKED\")\n</code>\n</pre>\n", "senID": 2}, {"text": ["Here, I'm assuming that I have a GTK Button somewhere called button1 and that I specified *button_click_event* as the clicked callback.", "The glade wrapper takes a lot of effort out of event mapping."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "button1", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "clicked", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["If I were to design a Pythonic GUI library, I would support something similar, to aid rapid development.", "The only difference is that I would ensure that the widgets have a more pythonic interface too.", "The current PyGTK classes seem very C to me, except that I use foo.bar(...) instead of bar(foo, ...) though I'm not sure exactly what I'd do differently.", "Probably allow for a Django models style declarative means of specifying widgets and events in code and allowing you to access data though iterators (where it makes sense, eg widget lists perhaps), though I haven't really thought about it."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Maybe not as slick as the Ruby version, but how about something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from Boots import App, Para, Button, alert\n\ndef Shoeless(App):\n    t = Para(text = 'Not Clicked')\n    b = Button(label = 'The label')\n\n    def on_b_clicked(self):\n        alert('You clicked the button!')\n        self.t.text = 'Clicked!'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Like Justin said, to implement this you would need to use a custom metaclass on class App, and a bunch of properties on Para and Button.", "This actually wouldn't be too hard."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "Like Justin said", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/58711/how-would-you-design-a-very-pythonic-ui-framework#58917"}, {"text": "App", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Para", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Button", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The problem you run into next is: how do you keep track of the order that things appear in the class definition?", "In Python 2.x, there is no way to know if t should be above b or the other way around, since you receive the contents of the class definition as a python dict."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "order", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "t", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["However, in Python 3.0 metaclasses are being changed in a couple of (minor) ways.", "One of them is the __prepare__ method, which allows you to supply your own custom dictionary-like object to be used instead -- this means you'll be able to track the order in which items are defined, and position them accordingly in the window."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "metaclasses are being changed", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3115/"}, {"text": "__prepare__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["This could be an oversimplification, i don't think it would be a good idea to try to make a general purpose ui library this way.", "On the other hand you could use this approach (metaclasses and friends) to simplify the definition of certain classes of user interfaces for an existing ui library and depending of the application that could actually save you a significant amount of time and code lines."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The only attempt to do this that I know of is Hans Nowak's Wax (which is unfortunately dead)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Hans Nowak's Wax", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://zephyrfalcon.org/labs/dope_on_wax.html"}]}], [{"text": ["I have this same problem.", "I wan to to create a wrapper around any GUI toolkit for Python that is easy to use, and inspired by Shoes, but needs to be a OOP approach (against ruby blocks)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["More information in: http://wiki.alcidesfonseca.com/blog/python-universal-gui-revisited"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://wiki.alcidesfonseca.com/blog/python-universal-gui-revisited", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.alcidesfonseca.com/blog/python-universal-gui-revisited"}]}, {"text": ["Anyone's welcome to join the project."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you really want to code UI, you could try to get something similar to django's ORM; sth like this to get a simple help browser:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MyWindow(Window):\n    class VBox:\n        entry = Entry()\n        bigtext = TextView()\n\n        def on_entry_accepted(text):\n            bigtext.value = eval(text).__doc__\n</code>\n</pre>\n", "senID": 1}, {"text": ["The idea would be to interpret some containers (like windows) as simple classes, some containers (like tables, v/hboxes) recognized by object names, and simple widgets as objects."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I dont think one would have to name all containers inside a window, so some shortcuts (like old-style classes being recognized as widgets by names) would be desirable."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["About the order of elements: in MyWindow above you don't have to track this (window is conceptually a one-slot container).", "In other containers you can try to keep track of the order assuming that each widget constructor have access to some global widget list.", "This is how it is done in django (AFAIK)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Few hacks here, few tweaks there...", "There are still few things to think of, but I believe it is possible... and usable, as long as you don't build complicated UIs."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["However I am pretty happy with PyGTK+Glade.", "UI is just kind of data for me and it should be treated as data.", "There's just too much parameters to tweak (like spacing in different places) and it is better to manage that using a GUI tool.", "Therefore I build my UI in glade, save as xml and parse using gtk.glade.XML()."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Declarative is not necessarily more (or less) pythonic than functional IMHO.", "I think a layered approach would be the best (from buttom up):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Similar to Elixir + SQLAlchemy."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Elixir", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://elixir.ematia.de/trac/wiki"}, {"href": "http://www.sqlalchemy.org/", "text": "SQLAlchemy", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Personally, I would try to implement JQuery like API in a GUI framework."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "JQuery", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.jquery.com/Main_Page"}]}, {"code": "<pre>\n<code>\n class MyWindow(Window):\n    contents = (\n        para('Hello World!'),\n        button('Click Me', id='ok'),\n        para('Epilog'),\n    )\n\n    def __init__(self):\n        self['#ok'].click(self.message)\n        self['para'].hover(self.blend_in, self.blend_out)\n\n    def message(self):\n        print 'You clicked!'\n\n    def blend_in(self, object):\n        object.background = '#333333'\n\n    def blend_out(self, object):\n        object.background = 'WindowBackground'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's an approach that goes about GUI definitions a bit differently using class-based meta-programming rather than inheritance."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is largley Django/SQLAlchemy inspired in that it is heavily based on meta-programming and separates your GUI code from your \"code code\".", "I also think it should make heavy use of layout managers like Java does because when you're dropping code, no one wants to constantly tweak pixel alignment.", "I also think it would be cool if we could have CSS-like properties."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here is a rough brainstormed example that will show a column with a label on top, then a text box, then a button to click on the bottom which shows a message."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\nfrom happygui.controls import *\n\nMAIN_WINDOW = Window(width=\"500px\", height=\"350px\",\n    my_layout=ColumnLayout(padding=\"10px\",\n        my_label=Label(text=\"What's your name kiddo?\", bold=True, align=\"center\"),\n        my_edit=EditBox(placeholder=\"\"),\n        my_btn=Button(text=\"CLICK ME!\", on_click=Handler('module.file.btn_clicked')),\n    ),\n)\nMAIN_WINDOW.show()\n\ndef btn_clicked(sender): # could easily be in a handlers.py file\n    name = MAIN_WINDOW.my_layout.my_edit.text\n    # same thing: name = sender.parent.my_edit.text\n    # best practice, immune to structure change: MAIN_WINDOW.find('my_edit').text\n    MessageBox(\"Your name is '%s'\" % ()).show(modal=True)\n</pre>\n", "senID": 3}, {"text": ["One cool thing to notice is the way you can reference the input of my_edit by saying MAIN_WINDOW.my_layout.my_edit.text.", "In the declaration for the window, I think it's important to be able to arbitrarily name controls in the function kwargs."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "MAIN_WINDOW.my_layout.my_edit.text", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Here is the same app only using absolute positioning (the controls will appear in different places because we're not using a fancy layout manager):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\nfrom happygui.controls import *\n\nMAIN_WINDOW = Window(width=\"500px\", height=\"350px\",\n    my_label=Label(text=\"What's your name kiddo?\", bold=True, align=\"center\", x=\"10px\", y=\"10px\", width=\"300px\", height=\"100px\"),\n    my_edit=EditBox(placeholder=\"\", x=\"10px\", y=\"110px\", width=\"300px\", height=\"100px\"),\n    my_btn=Button(text=\"CLICK ME!\", on_click=Handler('module.file.btn_clicked'), x=\"10px\", y=\"210px\", width=\"300px\", height=\"100px\"),\n)\nMAIN_WINDOW.show()\n\ndef btn_clicked(sender): # could easily be in a handlers.py file\n    name = MAIN_WINDOW.my_edit.text\n    # same thing: name = sender.parent.my_edit.text\n    # best practice, immune to structure change: MAIN_WINDOW.find('my_edit').text\n    MessageBox(\"Your name is '%s'\" % ()).show(modal=True)\n</pre>\n", "senID": 6}, {"text": ["I'm not entirely sure yet if this is a super great approach, but I definitely think it's on the right path.", "I don't have time to explore this idea more, but if someone took this up as a project, I would love them."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]]