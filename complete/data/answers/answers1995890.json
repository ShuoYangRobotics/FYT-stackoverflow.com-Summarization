[[{"text": ["There is a nice Sieve of Eratosthenes generator implementation in test_generators.py:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Sieve of Eratosthenes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"}]}, {"code": "<pre>\n<code>\n def intsfrom(i):\n     while 1:\n         yield i\n         i += 1\n\ndef firstn(g, n):\n     return [g.next() for i in range(n)]\n\ndef exclude_multiples(n, ints):\n     for i in ints:\n         if i % n:\n             yield i    \n\ndef sieve(ints):\n     prime = ints.next()\n     yield prime\n     not_divisible_by_prime = exclude_multiples(prime, ints)\n     for p in sieve(not_divisible_by_prime):\n         yield p\n\nprimes = sieve(intsfrom(2))\n\n&gt;&gt;&gt; print firstn(primes, 20)\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]\n</code>\n</pre>\n", "senID": 1}, {"src": "http://upload.wikimedia.org/wikipedia/commons/8/8c/New_Animation_Sieve_of_Eratosthenes.gif", "tag": "img", "senID": 2}], [{"text": ["There is lots (!", ") to be improved with your Python code, but to answer your specific question: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When you have found a divisor (candidate % x == 0), you increment the candidate, but you don't do anything about x.", "This can lead to two problems:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "candidate % x == 0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["I don't think this is testing what you think it's testing.", "It looks like you're trying to say \"for each number between 2 and my candidate, check to see if the candidate is evenly divisible by that number\".", "However, when you find a prime (candidate%x == 0), you're only incrementing the candidate-- you still need to start your \"for x in ...\" loop over again, since the candidate has changed."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That's what I can see from the code as written; there are of course lots of other ways and other optimizations to use here."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["It's good to know that every prime number bigger than 3 can be written as:\n6k-1/+1. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When you are looking for the next candidate, you can always write something like this (code snippet is in C):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a=1;\n...\ncandidate=6*k+(a=(a==-1)?1:-1);\nif(a==1){\n           k++;\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["And a function I've used not so long ago to determine the nth prime number, where LIM is the nth number you are looking for (C code):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n int sol2(){\n        int res,cnt,i,k,a;\n        res=-1;\n        i=1;\n        cnt=3;\n        k=1;\n        a=1;\n        while (1){\n                if (util_isprime(cnt)){\n                        i++;\n                        if (i==LIM){\n                                res=cnt;\n                                break;\n                        }\n                }\n                /* 6k+/-1 starting from 6*1-1 */\n                cnt=6*k+(a=(a==-1)?1:-1);\n                if(a==1){\n                        k++;\n                }\n        }\n        return res;\n}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["in the statement:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for x in range(2,candidate)\n</code>\n</pre>\n", "senID": 1}, {"text": ["you can reduce the number of iterations by scanning up to sqrt(candidate) "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As for optimizations, if you're definite that you want to follow this implementation, you could avoid looking at numbers that:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Don't forget to add 5 and 11 as primes though!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Unless I'm very much mistaken, you are always adding the current candidate to the list of primes, regardless of whether a divisor has been found or not.", "Your code to append to the list of primes (putting aside the immutable tuple comment made earlier) is outside of the test for integer divisors, and therefore always run."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you want anything remotely efficient, do the Sieve of Eratosthenes - it's as simple as it's old."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Sieve of Eratosthenes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"}]}, {"code": "<pre>\n<code>\n MAX = 10000\ncandidates = [True] * MAX\ncandidates[0] = False\ncandidates[1] = False\n\nprimelist = []\nfor p,isprime in enumerate(candidates):\n    if isprime:\n        primelist.append(p)\n        for n in range(2*p,MAX,p):\n            candidates[n] = False\n\nprint primelist[1001]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["FYI...", "I solved it with the following code, though it can be optimised much much more, I just wanted to solve it in this manner first.", "Thanks everyone for your help."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from math import *\nprimes=[2,3]\ncount=2\ntestnumber=5\nwhile count&lt;1000:\n\n    flag=0\n    for x in range(2,testnumber):\n        if x&lt;=sqrt(testnumber):\n            if testnumber%x==0:\n                #print testnumber , \"is not a prime\"\n                flag=1\n\n            else : pass\n    if flag!=1:\n        #print testnumber , \"is a prime\"\n        primes=primes+[testnumber]\n        count=count+1\n    testnumber=testnumber+2\n\n\n#print primes\nprint \"1000th prime is \", primes[-1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I will now look at all the other algorithms mentioned by you all"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["c beginner "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["int main ()"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["{\nint a,s,c,v,f,p,z;"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["while(scanf(\"%d\",&amp;f) !=EOF){\np=0;\nfor(z=1;p\n\n}\n"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "}", "childNum": 1, "tag": "pre", "pos": 0, "childList": [{"text": "}", "tag": "code"}]}, {"text": "}", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["printf(\"%d\\n\",a);\n                            }"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["return 0;\n}"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]