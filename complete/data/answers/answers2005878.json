[[{"text": ["Metaclasses are indispensable if you want to have class objects (as opposed to instances of class objects) equipped with \"special customized behavior\", since an object's behavior depends on special methods on the type of the object, and a class object's type is, exactly a synonym for, the metaclass."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "instances", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "type", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["For example, if you want a class object X such that \"print X\" emits \"Time is now 8:46am\" (at 8:46 am, or, more generally, the current time) this must mean that type(x) (AKA X's metaclass) has a special custom __str__ method -- and similarly (with the various applicable special-methods) if you want to give meaning to expressions such as X + Y where X and Y are both class objects, or X[23] (where X, again, is a class object), and so forth."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "type(x)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__str__", "childNum": 0, "tag": "code", "childList": []}, {"text": "X + Y", "childNum": 0, "tag": "code", "childList": []}, {"text": "X[23]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Most other customization tasks are now (in Python 2.6 or better) easier to implement with a class decorator, which can alter a class object right after the end of the class statement.", "There are a few more cases where this is not feasible because the alterations must be made very early on if they are to have any effect (e.g., setting or altering __slots__)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "class", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__slots__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In Python 3, metaclasses gain one extra little bit of usefulness: a metaclass can now optionally specify the mapping object to be populated during the execution of the class statement's body (by default, it's a normal dict).", "This allows the order of name bindings in the class body to be preserved and used (while the normal dict loses order), which is sometimes nice when the class must have \"fields\" in a certain specific order (e.g.", "to map 1:1 onto a C struct, a row in a CSV file or DB table, and the like) -- in Python 2.", "* this had to be redundantly specified (typically with an extra class attribute that's a sequence and thus does preserve order), and this feature of Python 3 metaclasses allows the redundancy to be removed."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "class", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "order", "childNum": 0, "tag": "em", "pos": 3, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "struct", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Add extra flexibility to your programming: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But according to this Metaclass programming in Python you might not need them ( yet ) "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Metaclass programming in Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ibm.com/developerworks/linux/library/l-pymeta.html"}]}], [{"text": ["If you are looking for examples of using the metaclass mechanism, you can read the source code of django.forms."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "django.forms", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.djangoproject.com/browser/django/trunk/django/forms/forms.py"}]}, {"text": ["The declarative style of form definition is implemented through metaclass."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I use metaclasses with some frequency, and they're an extremely powerful tool to have in the toolbox.", "Sometimes your solution to a problem can be more elegant, less code, with them than without."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The thing I find myself using metaclasses for most often, is post-processing the class attributes during class creation.", "For example, setting a name attribute on objects where appropriate (like how the Django ORM might work):"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "name", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class AutonamingType(type):\n    def __init__(cls, name, bases, attrs):\n        for k,v in attrs.iteritems():\n            if getattr(v, '__autoname__', False):\n                v.name = k\n\nclass Autonamer(object):\n    __metaclass__ = AutonamingType\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you have this as a tool, and you're using a class which must know its name before it can do_something(): "], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "name", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "do_something()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class Foo(object):\n    __autoname__ = True\n    def __init__(self, name=None):\n        self.name = name\n    def do_something(self):\n        if self.name is None:\n            raise ValueError('name is None')\n        # now, do something\n</code>\n</pre>\n", "senID": 4}, {"text": ["It can make the difference in the rest of your code between this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class Bar(object):\n    myfoo1 = Foo('myfoo1')\n    myfoo2 = Foo('myfoo2')\n    myfoo3 = Foo('myfoo3')\n</code>\n</pre>\n", "senID": 6}, {"text": ["and this:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n class Baaz(Autonamer):\n    myfoo1 = Foo()\n    myfoo2 = Foo()\n    myfoo3 = Foo()\n</code>\n</pre>\n", "senID": 8}, {"text": ["Thus reducing duplication (and the chances that the variable name and the assigned name might get out-of-sync)."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["They are rarely needed, but come in useful in places where you want to add behavior to the basic behavior of an object -- compare Aspect Oriented Programming, or the instrumentation done in persistence frameworks like Hibernate. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, you may want a class which persists or logs each new object."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Probably there is nothing that can be done exclusively with metaclasses, but to some people (mine included) it's a interesting tool you can use.", "Just be careful not to abuse, as it can be tricky."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, I've used metaprogramming in a recent project.", "It was a OpenOffice calc sheet, which, using some pyUNO macros, generates some files with information.", "There was one sheet that presents to the user the information to fill, and the others can be used to describe the kind of elements and their properties.", "The user can then select the number of elements and the type of each, and generate the files.", "The macro will create a class via metaprogramming following the configuration on each sheet.", "Then, the user can instanciate each class and generate objects."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It could be done without metaprogramming, but to me seemed natural to use the metaprogramming capabilities to do it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Take a look at Django sources - for example metaclasses are used there to generate models."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://code.djangoproject.com/wiki/DynamicModels"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://code.djangoproject.com/wiki/DynamicModels", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.djangoproject.com/wiki/DynamicModels"}]}], [{"text": ["I think it isn't that there aren't other ways to do it, but some things are just nicer with metaclasses."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]