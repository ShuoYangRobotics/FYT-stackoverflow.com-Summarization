[[{"code": "<pre>\n<code>\n def location(x,y,dim_x,dim_y):\n    index = 1*(y==0) + 2*(y==dim_y-1) + 3*(x==0) + 6*(x==dim_x-1)\n    return [\"interior\",\"top\",\"bottom\",\"left\",\"top-left\",\n            \"bottom-left\",\"right\",\"top-right\",\"bottom-right\"][index]\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n # initially:\nmethod_list = [\n    bottom_left, bottom, bottom_right,\n    left, middle, right,\n    top_left, top, top_right,\n    ]\n\n# each time:\nkeyx = 0 if not x else (2 if x == self.dim_x - 1 else 1)\nkeyy = 0 if not y else (2 if y == self.dim_y - 1 else 1)\nkey = keyy * 3 + keyx\nmethod_list[key](self, x, y, other_args)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Untested ... but the general idea should shine through."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Update after the goal posts were drastically relocated by \"Something efficient would be good since this part of the logic is being called a couple million times...it's for simulated annealing\":"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Originally you didn't like the chain of tests, and said you were calling a function to handle each of the 8 cases.", "If you want fast (in Python): retain the chain of tests, and do the handling of each case inline instead of calling a function."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Can you use psyco?", "Also, consider using Cython."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If I understand correctly, you have a collection of coordinates (x,y) living in a grid, and you would like to know, given any coordinate, whether it is inside the grid or on an edge."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The approach I would take is to normalize the grid before making the comparison, so that its origin is (0,0) and its top right corner is (1,1), then I would only have to know the value of the coordinate to determine its location.", "Let me explain."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["0) Let _max represent the maximum value and _min, for instance, x_min is the minimum value of the coordinate x; let _new represent the normalized value."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 1) Given (x,y), compute: x_new = (x_max-x)/(x_max-x_min) and y_new=(y_max-y)/(y_max-y_min).\n\n2) [this is pseudo code]\nswitch y_new:\n  case y_new==0: pos_y='bottom'\n  case y_new==1: pos_y='top'\n  otherwise: pos_y='%2.2f \\% on y', 100*y_new\nswitch x_new:\n  case x_new==0: pos_x='left'\n  case x_new==1: pos_x='right'\n  otherwise: pos_x='%2.2f \\% on x', 100*x_new\n\nprint pos_y, pos_x\n\nIt would print stuff like \"bottom left\" or \"top right\" or \"32.58% on y 15.43% on x\"\n\nHope that helps.\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I guess if you really want to treat all these cases completely differently, your solution is okay, as it is very explicit.", "A compact solution might look more elegant, but will probably be harder to maintain.", "It really depends on what happens inside the if-blocks."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As soon as there is a common handling of, say, the corners, one might prefer to catch those cases with one clever if-statement."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Something like this might be more readable / maintainable.", "It will probably be a lot faster than your nested if statements since it only tests each condition once and dispatches through a dictionary which is nice and fast."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class LocationThing:\n\n    def __init__(self, x, y):\n        self.dim_x = x\n        self.dim_y = y\n\n    def interior(self):\n        print \"interior\"\n    def left(self):\n        print \"left\"\n    def right(self):\n        print \"right\"\n    def top(self):\n        print \"top\"\n    def bottom(self):\n        print \"bottom\"\n    def top_left(self):\n        print \"top_left\"\n    def top_right(self):\n        print \"top_right\"\n    def bottom_left(self):\n        print \"bottom_left\"\n    def bottom_right(self):\n        print \"bottom_right\"\n\n    location_map = {\n        # (left, right,   top, bottom)\n        ( False, False, False, False ) : interior,\n        (  True, False, False, False ) : left,\n        ( False,  True, False, False ) : right,\n        ( False, False,  True, False ) : top,\n        ( False, False, False,  True ) : bottom,\n        (  True, False,  True, False ) : top_left,\n        ( False,  True,  True, False ) : top_right,\n        (  True, False, False,  True ) : bottom_left,\n        ( False,  True, False,  True ) : bottom_right,\n        }\n\n\n    def location(self, x,y):\n        method = self.location_map[(x==0, x==self.dim_x-1, y==0, y==self.dim_y-1)]\n        return method(self)\n\nl = LocationThing(10,10)\nl.location(0,0)\nl.location(0,1)\nl.location(1,1)\nl.location(9,9)\nl.location(9,1)\nl.location(1,9)\nl.location(0,9)\nl.location(9,0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["When you run the above it prints"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n top_left\nleft\ninterior\nbottom_right\nright\nbottom\nbottom_left\ntop_right\n</code>\n</pre>\n", "senID": 3}], [{"text": ["For a fast inner-loop function, you can just bite the bullet and do the ugly: nested if else statements with repeated terms, so that each comparison is only done once, and it runs about twice as fast as an example cleaner answer (by mobrule):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "twice as fast", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import timeit\n\ndef f0(x, y, x_dim, y_dim):\n    if x!=0:\n        if x!=x_dim: # in the x interior\n            if y!=0:\n                if y!=y_dim: # y interior\n                    return \"interior\"\n                else: # y==y_dim edge 'top'\n                    return \"interior-top\"\n            else:\n                return \"interior-bottom\"\n        else: # x = x_dim, \"right\"\n            if y!=0:\n                if y!=y_dim: # \n                    return \"right-interior\"\n                else: # y==y_dim edge 'top'\n                    return \"right-top\"\n            else:\n                return \"right-bottom\"\n    else: # x=0 'left'\n        if y!=0:\n            if y!=y_dim: # y interior\n                return \"left-interior\"\n            else: # y==y_dim edge 'top'\n                return \"left-top\"\n        else:\n            return \"left-bottom\"\n\nr_list = [\"interior\",\"top\",\"bottom\",\"left\",\"top-left\",\n            \"bottom-left\",\"right\",\"top-right\",\"bottom-right\"]                 \ndef f1(x,y,dim_x,dim_y):\n    index = 1*(y==0) + 2*(y==dim_y-1) + 3*(x==0) + 6*(x==dim_x-1)\n    return r_list[index]\n\nfor x, y, x_dim, y_dim in [(4, 4, 5, 6), (0, 0, 5, 6)]:\n    t = timeit.Timer(\"f0(x, y, x_dim, y_dim)\", \"from __main__ import f0, f1, x, y, x_dim, y_dim, r_list\")\n    print \"f0\", t.timeit(number=1000000)\n    t = timeit.Timer(\"f1(x, y, x_dim, y_dim)\", \"from __main__ import f0, f1, x, y, x_dim, y_dim, r_list\")\n    print \"f1\", t.timeit(number=1000000)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which gives:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n f0 0.729887008667  # nested if-else for interior point (no \"else\"s)\nf1 1.4765329361\nf0 0.622623920441  # nested if-else for left-bottom (all \"else\"s)\nf1 1.49259114265\n</code>\n</pre>\n", "senID": 3}, {"text": ["So it's a bit better than twice as fast as mobrule's answer, which was the fastest looking code that I knew would work when I posted this.", "(Also, I moved mobrule's string list out of the function as that sped up the result by 50%.", ")  Speed over beauty?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If instead you want a concise and easy to read solution, I suggest:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def f1(x, y, x_dim, y_dim):\n    d_x = {0:\"left\", x_dim:\"right\"}\n    d_y = {0:\"bottom\", y_dim:\"top\"}\n    return d_x.get(x, \"interior\")+\"-\"+d_y.get(y, \"interior\")\n</code>\n</pre>\n", "senID": 6}, {"text": ["which is as fast as the others by my timing."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]]