[[{"text": ["I guess the problem is that while parsing your file an enormous syntax tree is made with a small overhead for each element that all add up.", "Once the bytecode is generated the syntax tree is no longer necessary and dumped, resulting in your 200MB data."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Have you tried storing the data in a seperate file in the following format and then dynamically load it in python?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n 1,2,3=1,2,3\n2,5,6=4,2,3,4,5,6\n</code>\n</pre>\n", "senID": 2}, {"text": ["The Python script should look something like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n file = open(\"filename\")\nd = {}\n\nfor line in file:\n    key, val = line.split(\"=\")\n    key = tuple(key.split(\",\"))\n    d[key] = tuple(val.split(\",\"))\n\nfile.close()\n</code>\n</pre>\n", "senID": 4}], [{"text": ["http://docs.python.org/library/shelve.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/shelve.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/shelve.html"}]}], [{"text": ["I'm guessing that your big compile spike happens when you do \"import module_containing_humungous_dict_statement\".", "Then it doesn't matter if you've got just one statement or 247257 separate assignment statements, the whole module will still get compiled at once.", "You could try using the separate-assignment-statement form, and then opening the file, reading one line at a time, and exec'ing it.", "Then you will only be compiling one line at a time.", "Will probably take a while."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I suspect creating the list to use as a key is what is expensive.", "Define a function that takes the three parts of the triple as input and returns a pipe delimited string.", "Use that as your key."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The way I read your question, you are generating Python source in your simulator, and the generated source has the contents of the giant dictionary hard-coded.", "If that is true, then you might as easily generate this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def giantdict():\n  d0 = {(1, 2): (3, 4), (3, 4): (5, 6), ...}  # first 1000 key/value pairs here\n  d1 = {(1, 2): (3, 4), (3, 4): (5, 6), ...}  # next 1000 key/value pairs\n  d2 = {(1, 2): (3, 4), (3, 4): (5, 6), ...}  # next 1000 key/value pairs\n  d3 = {(1, 2): (3, 4), (3, 4): (5, 6), ...}  # next 1000 key/value pairs\n  # ... until you're done\n  bigd = d0\n  bigd.update(d1)\n  del d1\n  bigd.update(d2)\n  del d2\n  # ... continue updating with all the dN dictionaries\n  return bigd\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm not sure that this will improve the compile time, but it would be something to try.", "If there is a penalty to putting everything in one data structure at compile time, splitting it up and assembling the pieces at run time may work around it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["While this kind of code (mine or yours) would draw my fury and ire if a human wrote it, I see no need for generated code to be \"nice\", as long as you know that no human will ever need to read it or maintain it."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "know", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Here's a class that uses a defaultdict for the automatic nesting of indexed values, with some special __getitem__ and __setitem__ methods to accept tuples as arguments:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__getitem__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__setitem__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\ndefdict3level = (lambda : defaultdict(lambda : \n                            defaultdict( lambda : \n                                defaultdict(tuple))))\n\nclass dict3level(object):\n    def __init__(self):\n        self.defdict = defdict3level()\n\n    def __getitem__(self, key):\n        if isinstance(key, tuple):\n            if len(key)==3:\n                return self.defdict[key[0]][key[1]][key[2]]\n            elif len(key)==2:\n                return self.defdict[key[0]][key[1]]\n            elif len(key)==1:\n                return self.defdict[key[0]]\n        else:\n            return self.defdict[key]\n\n    def __setitem__(self, key, value):\n        if isinstance(key, tuple) and len(key)==3:\n            self.defdict[key[0]][key[1]][key[2]] = value\n        else:\n            self.defdict[key] = value\n\n    def __getattr__(self, attr):\n        return getattr(self.defdict, attr)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now exec all your assignments like before:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n d = dict3level()\nd[1,2,3] = (1,2,3,4)\nd[1,2,7] = (3,4,5,6)\nd[2,5,6] = (4,2,3,4,5,6)\n</code>\n</pre>\n", "senID": 3}, {"text": ["You can still get a specific entry for a specific tuple:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n # get a specific entry\nprint d[1,2,3]\n</code>\n</pre>\n", "senID": 5}, {"text": ["But you can also navigate your dict by levels:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n # get all different 0'th index values\nprint d.keys()\n\n# get all sub values in d[1,2,*]\nprint d[1,2].keys()\nfor key in d[1,2]:\n    print \"d[1,2,%d] = %s\" % (key, d[1,2][key])\n\n# no such entry, return empty tuple\nprint d[1,2,0]\n</code>\n</pre>\n", "senID": 7}, {"text": ["Gives:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n print d[1,2,3] -&gt; (1, 2, 3, 4)\nprint d.keys() -&gt; [1, 2]\nprint d[1,2].keys() -&gt; [3, 7]\nfor key in d[1,2]:... -&gt; \n    d[1,2,3] = (1, 2, 3, 4)\n    d[1,2,7] = (3, 4, 5, 6)\nprint d[1,2,0] -&gt; ()\n</code>\n</pre>\n", "senID": 9}, {"text": ["(Don't know how this will affect your memory and/or pickling issues, but the resulting structure has a lot more capability to it."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}]]