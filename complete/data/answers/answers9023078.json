[[{"text": ["As you note, you can store the items to delete somewhere and defer the deletion of them until later.", "The problem then becomes when to purge them and how to make sure that the purge method eventually gets called.", "The answer to this is a context manager which is also a subclass of dict."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "when", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "how", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n class dd_dict(dict):    # the dd is for \"deferred delete\"\n    _defer   = False\n    _deletes = set()\n    def __delitem__(self, key):\n        self._deletes.add(key) if self._defer else dict.__delitem__(self, key)\n    def __enter__(self):\n        self._defer = True\n    def __exit__(self, type, value, tb):\n        self._defer = False\n        for key in self._deletes:\n            dict.__delitem__(self, key)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # make the dict and do whatever to it\nddd = dd_dict(a=1, b=2, c=3)\n\n# now iterate over it, deferring deletes\nwith ddd:\n    for k, v in ddd.iteritems():\n        if k is \"a\":\n            del ddd[k]\n\nprint ddd\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you're not in a with block, of course, deletes are immediate; as this is a dict subclass, it works just like a regular dict outside of a context manager."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "with", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You could also implement this as a wrapper class for a dictionary:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class deferring_delete(object):\n    def __init__(self, d):\n        self._dict = d\n    def __enter__(self):\n        self._deletes = set()\n        return self\n    def __exit__(self, type, value, tb):\n        for key in self._deletes:\n            del self._dict[key]\n        self._deletes = None\n    def __delitem__(self, key):\n        self._deletes.add(key)\n\nd = dict(a=1, b=2, c=3)\n\nwith deferring_delete(d) as dd:\n    for k, v in d.iteritems():\n        if k is \"a\":\n            del dd[k]    # delete through wrapper\n\nprint d\n</code>\n</pre>\n", "senID": 6}, {"text": ["It's even possible to make the wrapper class fully functional as a dictionary, if you want, though that's a fair bit more code."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Performance-wise, this is admittedly not such a win, but I like it from a programmer-friendliness standpoint."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["You can accomplish this by iterating over a static list of the key/value pairs of the dictionary, instead of iterating over a dictionary view."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Basically, iterating over list(dict_.items()) instead of dict_.items() will work:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "list(dict_.items())", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict_.items()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n for k, v in list(dict_.items()):\n  if condition(k, v):\n    del dict_[k]\n    continue\n  # do other things you need to do in this loop\n</code>\n</pre>\n", "senID": 2}, {"text": ["Here is an example (ideone):"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "ideone", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ideone.com/GZaOy"}]}, {"code": "<pre>\n<code>\n dict_ = {0: 'a', 1: 'b', 2: 'c', 3: 'd', 4: 'e', 5: 'f', 6: 'g'}\nfor k, v in list(dict_.items()):\n    if k % 2 == 0:\n        print(\"Deleting  \", (k, v))\n        del dict_[k]\n        continue\n    print(\"Processing\", (k, v))\n</code>\n</pre>\n", "senID": 4}, {"text": ["and the output:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n Deleting   (0, 'a')\nProcessing (1, 'b')\nDeleting   (2, 'c')\nProcessing (3, 'd')\nDeleting   (4, 'e')\nProcessing (5, 'f')\nDeleting   (6, 'g')\n</code>\n</pre>\n", "senID": 6}], [{"text": ["What you need to do is to not modify the list of keys you iterating over.", "You can do this in three ways:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Naive implementation for Python 2.x and 3.x:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\nfrom collections import deque\n\n\ndef _protect_from_delete(func):\n    def wrapper(self, *args, **kwargs):\n        try:\n            self._iterating += 1\n            for item in func(self, *args, **kwargs):\n                yield item\n        finally:\n            self._iterating -= 1\n            self._delete_pending()\n    return wrapper\n\nclass DeletableDict(dict):\n    def __init__(self, *args, **kwargs):\n        super(DeletableDict, self).__init__(*args, **kwargs)\n        self._keys_to_delete = deque()\n        self._iterating = 0\n\n    if sys.version_info[0] != 3:\n        iterkeys = _protect_from_delete(dict.iterkeys)\n        itervalues = _protect_from_delete(dict.itervalues)\n        iteritems = _protect_from_delete(dict.iteritems)\n    else:\n        keys = _protect_from_delete(dict.keys)\n        values = _protect_from_delete(dict.values)\n        items = _protect_from_delete(dict.items)  \n    __iter__ = _protect_from_delete(dict.__iter__)\n\n    def __delitem__(self, key):\n        if not self._iterating:\n            return super(DeletableDict, self).__delitem__(key)\n        self._keys_to_delete.append(key)\n\n    def _delete_pending(self):\n        for key in self._keys_to_delete:\n            super(DeletableDict, self).__delitem__(key)\n        self._keys_to_delete.clear()\n\nif __name__ == '__main__':\n    dct = DeletableDict((i, i*2) for i in range(15))\n    if sys.version_info[0] != 3:\n        for k, v in dct.iteritems():\n            if k &lt; 5:\n                del dct[k]\n        print(dct)\n        for k in dct.iterkeys():\n            if k &gt; 8:\n                del dct[k]\n        print(dct)\n        for k in dct:\n            if k &lt; 8:\n                del dct[k]\n        print(dct)\n    else:\n        for k, v in dct.items():\n            if k &lt; 5:\n                del dct[k]\n        print(dct)\n</code>\n</pre>\n", "senID": 1}, {"text": ["When iterating over keys, items or values it sets flag self._iterating.", "In __delitem__ it checks for ability to delete item, and stores keys in temporary queue.", "At the end of iterations it deletes all pending keys."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "self._iterating", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__delitem__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["It's very naive implementation, and I wouldn't recommend to use it in production code."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Added support for Python 3 and improvements from @jsbueno comments."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "@jsbueno", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/108205/jsbueno"}]}, {"text": ["Python 3 run on Ideone.com"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Python 3 run on Ideone.com", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ideone.com/mEIPm"}]}], [{"text": ["Python 3.2 has such dict in the stdlib:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python3\nfrom collections import OrderedDict as odict\n\nd = odict(zip(range(3), \"abc\"))\nprint(d)\nfor k in d:\n    if k == 2:\n       del d[k]\nprint(d)\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n<code>\n OrderedDict([(0, 'a'), (1, 'b'), (2, 'c')])\nOrderedDict([(0, 'a'), (1, 'b')])\n</code>\n</pre>\n", "senID": 2}, {"text": ["Iteration is performed over a linked list, see __iter__()method implementation.", "The deletion is safe (in Python 3.2) even though items are weak references."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "__iter__()method implementation", "tag": "a", "pos": 0, "childList": [{"text": "__iter__()", "tag": "code"}], "childNum": 1, "href": "http://hg.python.org/cpython/file/3.2/Lib/collections.py#l82"}, {"text": "__iter__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "The deletion is safe (in Python 3.2)", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://hg.python.org/cpython/file/3.2/Lib/collections.py#l71"}]}], [], [{"text": ["This could work as a compromise between the two examples - two lines longer than the second one, but shorter and slightly faster than the first.", "Python 2:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dict_ = {k : random.randint(0, 40000) for k in range(0,200000)}\n\ndict_remove = [k for k,v in dict_.iteritems() if v &lt; 3000]\nfor k in dict_remove:\n    del dict_[k]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Split into a function and it's down to one line each call (whether this is more readable or not is your call):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def dict_remove(dict_, keys):\n    for k in keys:\n        del dict_[k]\n\ndict_remove(dict_, [k for k,v in dict_.iteritems() if v &lt; 3000])\n</code>\n</pre>\n", "senID": 3}, {"text": ["Regardless of where the code is stored, you'll have to store the keys needing deletion somewhere.", "The only way around that is using generator expressions, which will explode the moment you delete a key for the first time."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]