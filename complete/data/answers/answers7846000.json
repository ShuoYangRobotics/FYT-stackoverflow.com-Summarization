[[{"text": ["If all you wanted were the longest line in the file (like the question title says), then this one is shockingly simple in modern Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; max(open('test.txt'), key=len)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["To fetch the label of the longest line, build a mapping of labels to line-lengths"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In your sample dataset, it looks like labels startwith \"_line \" and the corresponding line immediately follows:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n label2linelength = {}\nfor line in open('test.txt'):\n    if line.startswith('_line '):\n        label = line\n    else:\n        label2linelength[label] = len(line)\n    lastline = line\nprint max(label2linelength.items(), key=lambda kv: kv[1])\n</code>\n</pre>\n", "senID": 2}], [{"text": ["That is easy to achieve:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n data = open('test.txt').readlines()\nmax_line_pos = data.index(max(data, key=len))\nprev_line = data[max_line_pos-1]\nprint prev_line\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'd do something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n label = None\nmaxlen = 0\nmaxstr = ''\nmaxlabel = None\nwith open('f.txt') as f:\n  for line in f:\n    line = line.rstrip()\n    if line.startswith('_line'):\n      label = line\n    elif len(line) &gt; maxlen:\n      maxlen = len(line)\n      maxstr = line\n      maxlabel = label\nprint maxlabel, maxstr\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's a little bit more generic than the problem statement in that it allows multiple lines of text per label."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I'd elaborate on Raymond's answer; if grouper() were available in the standard lib this answer would be quite close to a oneliner again; unluckily it isn't, grouper is only defined in itertools examples."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools examples.", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html"}]}, {"text": ["I think you'd prefer this version since it's functional.", "I didn't test its performance, but at least I'm not opening the file and seeking twice nor I'm keeping the whole contents in memory."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip_longest\ndef grouper(n, iterable, fillvalue=None):\n    \"grouper(3, 'ABCDEFG', 'x') --&gt; ABC DEF Gxx\"\n    args = [iter(iterable)] * n\n    return izip_longest(fillvalue=fillvalue, *args)\n\nmax( grouper(2, open(\"test.txt\")), key=lambda x:len(x[1]))[0]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Another concise variant:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import imap, izip\nfrom operator import itemgetter\nwith open(\"a.py\") as f:\n    res = max(izip(f, imap(len, f)), key=itemgetter(1))[0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This treats every other line as a label."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's my one.", "It works where a few of the other answers here would fail, e.g.", "an input file like "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n _line 1\nabc\n_line 2\ndefg\n_line 3\nhij\n</code>\n</pre>\n", "senID": 1}, {"text": ["But it does rely on the format of the file being just how you said it was.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n with open('test.txt') as f:\n  spam = f.readlines()\n\nlabels = spam[0::2]\nlines = spam[1::2]\n\nd = dict(zip(labels, lines))\n\nlongest_lines_label = max(d, key=lambda x: len(d[x]))\n\nprint \"Longest line is....\"\nprint longest_lines_label, d[longest_lines_label]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If you are sure the data is correct and don't need any error handling this should do the job:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n lines = open('test.txt', 'r').readlines()\nprint max([(len(lines[i+1]), lines[i])\n           for i in xrange(0, len(lines), 2)])[1].strip()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's an awk program that will do it:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "awk", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n BEGIN { best=\"\"; best_length=0; current=\"\"; }\n/^_/ { current=$0; }\n/^[^_]/ { if(length($0) &gt; best_length) { best=current; best_length=length($0); }}\nEND { print \"Longest line: \"best\" with length: \"best_length }\n</code>\n</pre>\n", "senID": 1}, {"text": ["(I like it better than the following python version, which more closely answers your question....)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "python", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n best = \"\"\nbest_length = 0\ncurrent = \"\"\nfor line in f:  #( assumes f = open(...) from your code )\n  if line[:5] == '_line':\n    current = line.strip()\n    continue\n  else:\n    if len(line) &gt; best_length:\n      best = current\n      best_length = len(line.strip())\nprint \"Longest line is: %s with length: %d\" % (best,best_length)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This is fairly short, and works even if you have multiple lines of text after each label"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n content = list(open(\"test.txt\"))\nlongest = content.index(max(content, key=len))\nlabel = [ x for x in content[0:longest] if x.startswith(\"_line\") ][-1]\nprint label.replace(\"_line \",\"\")\n</code>\n</pre>\n", "senID": 1}], [{"text": ["And here's yet another way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re, mmap\n\nwith open(\"test.txt\", \"rb\") as f:\n    mm = mmap.mmap(f.fileno(), 0, mmap.MAP_PRIVATE, mmap.PROT_READ)\n    print max(re.finditer(r'_line (\\d+)\\n(.*)', mm),\n              key=lambda m: len(m.group(2))).group(1)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's your code, fixed:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f = open('test.txt', 'r')\nprint f\n\nread = None\ntop_read_line_length = 0\ntopreadline = None\ncurrentlength = 0\nlabel_line = True\nfor line in f:  \n    if label_line:\n        label_line = False\n        print \"label line\", line\n        #means we are on a read line\n        currentread = line\n    else:\n        label_line = True\n        #We are on a sequence line for currentread.\n        currentlength = len(line)\n        print 'cl', currentlength\n    print top_read_line_length\n\n    if top_read_line_length &lt; currentlength:\n        print 'trl', topreadline\n        topreadline = currentread #now topreadline label is the \"_line\" string\n        top_read_line_length = currentlength\n        print 'trl', topreadline\n\n        #go to next line\n\nprint \"Done\"\nprint \"Longest line is....\"\nprint topreadline\n</code>\n</pre>\n", "senID": 1}, {"text": ["I added a label_line boolean to switch back and forth between lable-lines and data-lines, but the important pieces were:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "label_line", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "put enough info on your print lines to see what's going on; and", "tag": "none", "senID": 3}, {"text": "be consistent with your variable names", "tag": "none", "senID": 4}]}, {"text": ["The problem was in the last if suite -- you were checking top_read_line_length but were setting topreadlinelength (no underscores)."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "top_read_line_length", "childNum": 0, "tag": "code", "childList": []}, {"text": "topreadlinelength", "childNum": 0, "tag": "code", "childList": []}]}]]