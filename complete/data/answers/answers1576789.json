[[{"text": ["Quick answer: Match a string consisting of a single character, where that character is alphanumeric (letters, numbers) an underscore (_) or an asterisk (*)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Quick answer:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "_", "childNum": 0, "tag": "code", "childList": []}, {"text": "*", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Details:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Details:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "The \"", "tag": "none", "senID": 2}, {"text": "The \"", "tag": "none", "senID": 3}, {"text": "The ", "tag": "none", "senID": 4}]}, {"text": ["It is also worth mentioning that normal quoting and escaping rules for strings make it very difficult to enter regular expressions (all the backslashes would need to be escaped with additional backslashes), so in Python there is a special notation which has its own special quoting rules that allow for all of the backslashes to be interpreted properly, and that is what the \"r\" at the beginning is for."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "r", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Note: Normally an asterisk (*) means \"0 or more of the previous thing\" but in the example above, it does not have that meaning, since the asterisk is inside of the character class, so it loses its \"special-ness\"."], "childNum": 4, "tag": "p", "senID": 6, "childList": [{"text": "Note:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "*", "childNum": 0, "tag": "code", "childList": []}, {"text": "not", "childNum": 0, "tag": "em", "childList": []}, {"text": "inside", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["For more information on regular expressions in Python, the two official references are the re module, the Regular Expression HOWTO."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "re module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html"}, {"href": "http://docs.python.org/dev/howto/regex.html", "text": "HOWTO", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["As exhuma said, \\w is any word-class character (alphanumeric as Jonathan clarifies)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However because it is in square brackets it will match:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So the whole regular expression matches:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "the beginning of a\nline (^)", "tag": "none", "senID": 3}, {"text": "followed by either a\nsingle alphanumeric character or an\nasterisk", "tag": "none", "senID": 4}, {"text": "followed by the end of a\nline ($)", "tag": "none", "senID": 5}]}, {"text": ["so the following would match:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n blah\nz  &lt;- matches this line\nblah\n</code>\n</pre>\n", "senID": 7}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n blah\n* &lt;- matches this line\nblah\n</code>\n</pre>\n", "senID": 9}], [{"text": ["From the beginning of this line, \"Any number of word characters (letter, number, underscore)\" until the end of the line."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\"Any number of word characters (letter, number, underscore)\"", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://rubular.com"}]}, {"text": ["I am unsure as to why it's in square brackets, as circle brackets (e.g.", "\"(\" and \")\") are correct if you want the matched text returned."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["\\w refers to 0 or more alphanumeric characters and the underscore.", "the * in your case is also inside the character class, so [\\w*] would match all of [a-zA-Z0-9_*] (the * is interpreted literally)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["See http://www.regular-expressions.info/reference.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.regular-expressions.info/reference.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.regular-expressions.info/reference.html"}]}, {"text": ["To quote:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit corrected in response to comment"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["\\w is equivalent to [a-zA-Z0-9_] I don't understand the * after it or the [] around it, because \\w already is a class and * in class definitions makes no sense. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["As said above \\w means any word.", "so you could use this in the context of below"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n view.aspx?url=[\\w]\n</code>\n</pre>\n", "senID": 1}, {"text": ["which means you can have any word as the value of the \"url=\" parameter"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]