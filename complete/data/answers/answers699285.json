[[{"text": ["You can use string formatting:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "string formatting", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#string-formatting"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; number = 123456789\n&gt;&gt;&gt; hex = \"%X\" % number\n&gt;&gt;&gt; hex\n'75BCD15'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm not sure exactly what you want, but have you looked at the struct module?"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "struct", "tag": "a", "pos": 0, "childList": [{"text": "struct", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/struct.html"}, {"text": "struct", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Given"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; hex(123456789)\n'0x75bcd15'\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can do:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; struct.pack('i', 123456789)\n'\\x15\\xcd[\\x07'\n</code>\n</pre>\n", "senID": 4}, {"text": ["Note that '\\x5b' == '['."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "'\\x5b' == '['", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Also, you can reverse the endianness:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; struct.pack('&gt;i', 123456789)\n'\\x07[\\xcd\\x15'\n</code>\n</pre>\n", "senID": 7}, {"text": ["Edit: I'm not sure what you mean by \"bigger than a long\", since AFAIK longs in python are unbounded (except by memory).", "However, you can deal with bigger integers by just dividing and concatenating.", "e.g.", "given:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; n = 123456789012345678901234567890\n</code>\n</pre>\n", "senID": 9}, {"text": ["the target is:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; hex(n)\n'0x18ee90ff6c373e0ee4e3f0ad2L'\n</code>\n</pre>\n", "senID": 11}, {"text": ["So:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = ''\n&gt;&gt;&gt; while n &gt;= 2**32:\n...  n, r = divmod(n, 2**32)\n...  s = struct.pack('&gt;l', r) + s\n... \n&gt;&gt;&gt; s = struct.pack('&gt;l', n) + s\n</code>\n</pre>\n", "senID": 13}, {"text": ["See that s matches the result of hex(n) above:"], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "hex(n)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s\n'\\x00\\x00\\x00\\x01\\x8e\\xe9\\x0f\\xf6\\xc3s\\xe0\\xeeN?\\n\\xd2'\n</code>\n</pre>\n", "senID": 15}], [{"text": ["Because it doesn't make sense.", "How do you fit 'AAB' in a space that takes either 2 or 4 digits?", "Each byte is two hex characters.", "When you have an odd number of hex characters, the desired result is ambiguous.", "Do you want it to be the equivalent of 0AAB or AAB0?", "If you know which one you want it to be equivalent to, just add that character to the right place before decoding."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["i.e.", "(('0' + foo) if len(foo) % 2 else foo).decode('hex') where foo is a string of the form returned by %x."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "(('0' + foo) if len(foo) % 2 else foo).decode('hex')", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "%x.", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["As Paolo mentioned, string formatting is the way to go.", "Note that you can choose between lower and upper case letters:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; hex = lambda n: '%X' % n\n&gt;&gt;&gt; hex(42)\n'2A'\n&gt;&gt;&gt; hex = lambda n: '%x' % n\n&gt;&gt;&gt; hex(42)\n'2a'\n&gt;&gt;&gt; def escaped(n):\n...     s = hex(n)\n...     if len(s) &amp; 1:\n...          s = '0' + s\n...     return ''.join(chr(int(s[i:i + 2], 16)) for i in range(0, len(s), 2))\n...\n&gt;&gt;&gt; escaped(123)\n'{'\n&gt;&gt;&gt; escaped(1234)\n'\\x04\\xd2'\n&gt;&gt;&gt; escaped(12348767655764764654764445473245874398787989879879873)\n'!\\x01^\\xa4\\xdf\\xdd(l\\x9c\\x00\\\\\\xfa*\\xf3\\xb4\\xc4\\x94\\x98\\xa9\\x03x\\xc1'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that escaped adds a leading zero in case of an odd number of hex digits.", "This solution works for strings of any length."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "escaped", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["If you know how long your output strings should be, string formatting will work.", "For example, to get four-character strings, you need a formatted length of eight:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; \"{0:08x}\".format(123456789).decode(\"hex\")\n'\\x07[\\xcd\\x15'\n&gt;&gt;&gt; \"{0:08x}\".format(1234567890).decode(\"hex\")\n'I\\x96\\x02\\xd2'\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will prepend zeroes if your number doesn't \"fill up\" the string.", "For example, with six-character strings:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; \"{0:012x}\".format(123456789).decode(\"hex\")\n'\\x00\\x00\\x07[\\xcd\\x15'\n&gt;&gt;&gt; \"{0:012x}\".format(1234567890).decode(\"hex\")\n'\\x00\\x00I\\x96\\x02\\xd2'\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["To \"detect\" the length of target strings, you can use the math.log function:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "math.log", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def int2str(n):\n        l = int(math.ceil(math.log(n, 256) / 2) * 4)\n        return (\"{0:0{1}x}\").format(n, l).decode(\"hex\")\n\n&gt;&gt;&gt; int2str(123456789)\n'\\x07[\\xcd\\x15'\n&gt;&gt;&gt; int2str(1234567890)\n'I\\x96\\x02\\xd2'\n</code>\n</pre>\n", "senID": 6}], [{"text": ["one of the surest way, for arbitary numbers, is to use the 'array' module like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from array import array\nbinArr = array('B')\n\nwhile(data):\n    d = data &amp; 0xFF\n    binArr.append(d)\n    data &gt;&gt;= 8\n\nhexStr = binArr.tostring()\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n '{0:b}'.format( number )\n</code>\n</pre>\n", "senID": 0}, {"text": ["refer to http://docs.python.org/library/string.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/string.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/string.html"}]}]]