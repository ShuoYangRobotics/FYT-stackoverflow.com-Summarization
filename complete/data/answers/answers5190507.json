[[{"text": ["First, learn to specify the files of interest.", "In one directory or more than one directory?", "The Unix find utility will do that. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "find", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["At the Bash prompt:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n $ cd [the root directory where your files are]\n$ find . -name \"*.txt\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["You did not say, but assumably the files are describable with \"star dot something\" then find will find the files."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Next, pipe the files names to what you want to do to them:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n $ find . -name \"*.txt\" -print0 | xargs -0 egrep 'stuff'\n</code>\n</pre>\n", "senID": 5}, {"text": ["That will run egrep on each file with the search pattern of stuff "], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "egrep", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "stuff", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Google find plus xargs for literally thousands of examples.", "Once you are comfortable finding the files -- rephrase your question so that it is a bit more obvious what you want to do to them.", "Then I can help you with Perl to do it. "], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "find", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "xargs", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["You might this to be faster, more Pythonic, and easier to understand:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n with open(\"words.txt\") as words:\n    wlist=[(ln,word.strip()) for ln,word in enumerate(words,1)]\n\nwith open(\"files.txt\") as files:\n    flist=[(ln,file.strip()) for ln,file in enumerate(files,1)]\n\nfor filenum, filename in flist:\n    with open(filename) as fdata:\n        for fln,line in enumerate(fdata,1):\n            for wln, word in wlist:\n                if word in line:\n                    print \"%d =&gt; %d\" % (wln, fln)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is a two-parter with awk:\n1. scan each file in files.txt, and map the word number to the name of the file\n2. map the filename to the line number in files.txt"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n awk '\n  NR == FNR {word[$1] = NR; next}\n  {for (i=1; i&lt;=NF; i++) {if ($i in word) {print word[$i] \" =&gt; \" FILENAME; break}}}\n' words.txt $(&lt;files.txt) | \nsort -u |\nawk '\n  NR == FNR {filenum[$1] = NR; next}\n  {$3 = filenum[$3]; print}\n' files.txt -\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's something that will do what you want, but the only thing is that it will not print out the matched word, instead just prints out the line matched, the file name, and the line number.", "However, if you use --color=auto on grep, it will highlight the matched words using whatever you have set in ${GREP_COLOR}, the default is red."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "not", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "--color=auto", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "${GREP_COLOR}", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n cat files.txt | xargs grep -nf words.txt --color=auto\n</code>\n</pre>\n", "senID": 1}, {"text": ["This command will dump all contents of files.txt, line by line, and it will pipe the file names to grep, which will search the file for every word that matches in words.txt.", "Similar to files.txt, words.txt should be all the search terms you want delimited by new-lines."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "files.txt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "words.txt", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "files.txt", "childNum": 0, "tag": "code", "childList": []}, {"text": "words.txt", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If your grep was built with the perl regular expression engine, then, you can use Perl regular expressions if you pass the -P option to grep like so:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "-P", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n grep -Pnf words.txt --color=auto\n</code>\n</pre>\n", "senID": 4}, {"text": ["Hope this helps."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Update: At first, I wasn't really sure what @Zeophlite was asking but after he posted his example, I see what he wanted.", "Here's a python implementation of what he wants to do:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n from contextlib import nested\n\n\ndef search_file(line_num, filename):\n    with nested(open(filename), open('words.txt')) as managers:\n        open_filename, word_file = managers\n        for line in open_filename:\n            for wordfile_line_number, word in enumerate(word_file, 1):\n                if word.strip() in line:\n                    print \"%s =&gt; %s\" % (line_num, wordfile_line_number)\n\n\nwith open('files.txt') as filenames_file:\n    for filenames_line_number, fname in enumerate(filenames_file, 1):\n        search_file(filenames_line_number, fname.strip())\n</code>\n</pre>\n", "senID": 7}], [{"text": ["The following script in python does it.", "This is my first attempt at python, so I'd appreciate any comments"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n flist = open('files.txt')\n\nfilenum = 0\nfor filename in flist:\n    filenum = filenum + 1\n    filenamey = filename.strip()\n    filedata = open(filenamey)\n    for fline in filedata:\n        wordnum = 0\n        wlist = open('words.txt')\n        for word in wlist:\n            wordnum = wordnum + 1\n            sword = word.strip()\n            if sword in fline:\n                s = repr(filenum) + ' =&gt; ' + repr(wordnum)\n                print s\n</code>\n</pre>\n", "senID": 1}], [{"text": ["To answer your demand"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Your code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n flist = open('files.txt') \n\nfilenum = 0 \nfor filename in flist: \n    filenum = filenum + 1 \n    filenamey = filename.strip() \n    filedata = open(filenamey) \n    for fline in filedata: \n        wordnum = 0 \n        wlist = open('words.txt') \n        for word in wlist: \n            wordnum = wordnum + 1 \n            sword = word.strip() \n            if sword in fline: \n                s = repr(filenum) + ' =&gt; ' + repr(wordnum) \n                print s\n</code>\n</pre>\n", "senID": 3}, {"text": ["You open 'files.txt' but don't close it.", "with open('files.txt') as flist: is preferable because it is textually cleaner and it manages to close alone."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "'files.txt'", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "with open('files.txt') as flist:", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Instead of filenum = filenum + 1 , use enumerate()\nFrom now, you must never forget enumerate() because it is an extremely useful function.", "It works very very fast, too."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "filenum = filenum + 1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "enumerate()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "enumerate()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["fline isn't a good name for an iterator of lines, IMO; Isn't line a good one ?"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "fline", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "line", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["The instruction wlist = open('words.txt') isn't in a good place: it is executed not only each for each file opened, but even each time a line is analysed.", "Moreover, the treatment of the names listed in wlist is performed each time the wlist is iterated, that is to say at each line.", "You must put this treatment out of all the iterations."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "wlist = open('words.txt')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "wlist", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "wlist", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["wordnum is nothing else than the index of word in wlist.", "You can use again enumerate() or simply loop with index i and use wlist[i] instead of word"], "childNum": 7, "tag": "p", "senID": 8, "childList": [{"text": "wordnum", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "word", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "wlist", "childNum": 0, "tag": "strong", "childList": []}, {"text": "enumerate()", "childNum": 0, "tag": "code", "childList": []}, {"text": "i", "childNum": 0, "tag": "strong", "childList": []}, {"text": "wlist[i]", "childNum": 0, "tag": "code", "childList": []}, {"text": "word", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Each time a sword of wlist is in the line, you do "], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "sword", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "wlist", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n print repr(filenum) + ' =&gt; ' + repr(wordnum)\n</code>\n</pre>\n", "senID": 10}, {"text": ["It would be better to do print repr(filenum) + ' =&gt; ' + repr(all_wordnum) in which all_wordnum would be the list of all the sword found in one line"], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "print repr(filenum) + ' =&gt; ' + repr(all_wordnum)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "all_wordnum", "childNum": 0, "tag": "code", "childList": []}, {"text": "sword", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["You keep your list of words in a file.", "You'd better serialise the list of this words.", "See the modules pickle and pickle"], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "pickle", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "pickle", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["There is also something to improve in the recording of result.", "Because executing the instruction "], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n print repr(filenum) + ' =&gt; ' + repr(wordnum)\n</code>\n</pre>\n", "senID": 14}, {"text": ["each time is not a good practice.", "It's the same if you want to record in a file: you can't repeatedly order write() Better is to list all the result in a list, and print or record when process is over, making \"\\n\".join(list) or something like that"], "childNum": 2, "tag": "p", "senID": 15, "childList": [{"text": "write()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\"\\n\".join(list)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Doing it in pure shell, I'm close:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ grep -n $(tr '\\n' '|' &lt; words.txt | sed 's/|$//') $(cat files.txt)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Tried to figure out how to remove the $(cat files.txt), but couldn't)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "$(cat files.txt)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This prints out the words in each file, and prints out the lines where they occur, but it doesn't print out the line in words.txt where that word was located."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "words.txt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["There's probably some really ugly (if you didn't think this was ugly enough) stuff I could do, but your real answer is to use a higher level language.", "The awk solution is shellish since most people now consider awk as just part of the Unix environment.", "However, if you're using awk, you might as well use perl, python, or ruby. "], "childNum": 7, "tag": "p", "senID": 4, "childList": [{"text": "awk", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "shellish", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "awk", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "awk", "childNum": 0, "tag": "code", "childList": []}, {"text": "perl", "childNum": 0, "tag": "code", "childList": []}, {"text": "python", "childNum": 0, "tag": "code", "childList": []}, {"text": "ruby", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The only advantage awk has is that it is automatically included in a Linux/Unix distro even if the user who created the distro didn't include any of the development packages.", "It's rare, but it happens."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "awk", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["A pure sh answer, assuming that words or filenames do not contain any shell metacharacters such as blanks:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sh", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n nw=0; while read w; do nw=`expr $nw + 1`; nf=0; { while read f; do nf=`expr $nf + 1`; fgrep -n $w $f | sed 's/:.*//' | while read n; do echo $nw =\\&gt; $nf; done; done &lt; /tmp/files.txt;}; done &lt; /tmp/words.txt\n</code>\n</pre>\n", "senID": 1}, {"text": ["But I prefer Perl for this kind of thing.", "And the Perl script won't be quite as short or readable as carrrot-top's Python code, unless you use IO::All."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "IO::All", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.perl.com/pub/2004/03/12/ioall.html"}]}]]