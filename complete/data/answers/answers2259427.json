[[{"text": ["To access another Python module, you import it.", "execfile has been mentioned by a couple people, but it is messy and dangerous.", "execfile clutters your namespace, possibly even messing up the code you are running.", "When you want to access another Python source file, use the import statement."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "import it", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "execfile", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "execfile", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "import", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Even better would be not to use a Python file for configuration at all, but rather to use the builtin module ConfigParser or a serialization format like JSON.", "This way your configuration files don't allow execution of arbitrary (possibly malicious) code, doesn't require people to know Python to configure your program, and can easily be altered programatically."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "ConfigParser", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["In Python 2.", "*, execfile works (I recommend passing a specific dictionary and accessing the variables from there -- as the note in the docs says, execfile can't affect the calling function's locals() dictionary)."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "2.*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "execfile", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html?highlight=execfile#execfile"}, {"text": "execfile", "childNum": 0, "tag": "code", "childList": []}, {"text": "locals()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In Python 3.", "*, execfile has been removed, so do, instead:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "3.*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n with open('thefile.py') as f:\n  exec(f.read(), somedict)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You just need to be able to dynamically specify the imports and then dynamically get at the variables."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Let's say your config file is bar.py and looks like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n x = 3\ny = 4\ndef f(x): return (x&lt;4)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then your code should look like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import sys\n\n# somehow modnames should be a list of strings that are the names of config files\n#\n# you can do this more dynamically depending on what you're doing                                                                                                     \nmodnames = ['bar']\n\nfor modname in modnames:\n  exec('import %s' % modname)\n\nfor modname in modnames:\n  mod = sys.modules[modname]\n  for k in mod.__dict__:\n    if k[:2] != '__':\n      print modname, k, mod.__dict__[k]\n</code>\n</pre>\n", "senID": 4}, {"text": ["I get this output:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n bar f &lt;function f at 0x7f2354eb4cf8&gt;\nbar x 3\nbar y 4\n</code>\n</pre>\n", "senID": 6}, {"text": ["Then you at least have all the variables and functions.", "I didn't quite get what you wanted from the predicate functions, but maybe you can get that on your own now."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["As written in the python official documentation, if you just want to import a module by name, you can look it up in the sys.modules dictionary after using __import__."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "python official documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#__import__"}, {"text": "sys.modules", "childNum": 0, "tag": "code", "childList": []}, {"text": "__import__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Supposing your configuration is in myproject.mymodule, you would do like that :"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "myproject.mymodule", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n module_name = 'myproject.mymodule'\n\nimport sys\n__import__(module_name)\nmymodule = sys.modules[module_name]\n\n# Then you can just access your variables and functions\nprint mymodule.var1\nprint mymodule.var2\n# etc...\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can also use the return value of __import__ statement but you will have to understand fully how python works with namespaces and scopes."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "__import__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/reference/executionmodel.html", "text": "how python works with namespaces and scopes", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["If you want to have a configuration file that will only be edited by the user when the program isn't running, just import it as a normal python file"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["ie."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["main.py:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import config\nprint config.var1\n</code>\n</pre>\n", "senID": 3}, {"text": ["config.py:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n var=\"var12\"\nvar2 = 100.5\n</code>\n</pre>\n", "senID": 5}], [{"text": ["If the imported module is on the regular search path, you can use __import__."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__import__", "tag": "a", "pos": 0, "childList": [{"text": "__import__", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html?highlight=__import__#__import__"}, {"text": "__import__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you need to load the module from an arbitrary path in the filesystem, use imp.load_module."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "imp.load_module", "tag": "a", "pos": 0, "childList": [{"text": "imp.load_module", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/imp.html?highlight=__import__#imp.load_module"}, {"text": "imp.load_module", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Be sure to consider the security implications of loading arbitrary user-specified code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["execfile"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "execfile", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#execfile"}]}], [{"text": ["try the imp module : http://docs.python.org/library/imp.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/imp.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/imp.html"}]}]]