[[{"text": ["ls does a stat(2) call for every file.", "Other tools, like find(1) and the shell wildcard expansion, may avoid this call and just do readdir.", "One shell command combination that might work is find dir -maxdepth 1|wc -l, but it will gladly list the directory itself and miscount any filename with a newline in it."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "ls", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "stat(2)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "find(1)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "readdir", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "find dir -maxdepth 1|wc -l", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["From Python, the straight forward way to get just these names is os.listdir(directory).", "Unlike os.walk and os.path.walk, it does not need to recurse, check file types, or make further Python function calls."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "os.listdir(directory)", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/os.html#os.listdir"}]}, {"text": ["Addendum: It seems ls doesn't always stat.", "At least on my GNU system, it can do only a getdents call when further information (such as which names are directories) is not requested.", "getdents is the underlying system call used to implement readdir in GNU/Linux."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Total number of files in the given directory"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n find . -maxdepth 1 -type f | wc -l\n</code>\n</pre>\n", "senID": 1}, {"text": ["Total number of files in the given directory and all subdirectories under it"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n find . -type f | wc -l\n</code>\n</pre>\n", "senID": 3}, {"text": ["For more details drop into a terminal and do man find"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "man find", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I think ls is spending most of its time before displaying the first line because it has to sort the entries, so ls -U should display the first line much faster (though it may not be that much better in total)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "ls", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ls -U", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I'm not sure about speed, but if you want to just use shell builtins this should work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/bin/sh\nCOUNT=0;\nfor file in /path/to/directory/*\ndo\nCOUNT=$(($COUNT+1));\ndone\necho $COUNT\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This should be pretty fast in Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from os import listdir\nfrom os.path import isfile, join\ndirectory = '/home/myname/Maildir/new'\nprint sum(1 for entry in listdir(directory) if isfile(join(directory,entry)))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The fastest way would be to avoid all the overhead of interpreted languages and write some code that directly addresses your problem.", "Doing so is difficult to do in a portable way, but pretty straightforward.", "At the moment I'm on an OS X box, but converting the following to Linux should be extremely straightforward.", "(I opted to ignore hidden files and only count regular files...modify as necessary or add command line switches to get the functionality you want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n&#35;include &#60;dirent.h&#62;\n&#35;include &#60;stdio.h&#62;\n&#35;include &#60;stdlib.h&#62;\n\nint\nmain( int argc, char &#42;&#42;argv )\n{\n    DIR &#42;d;\n    struct dirent &#42;f;\n    int count = 0;\n    char &#42;path = argv[ 1 ];\n\n    if( path == NULL ) {\n        fprintf( stderr, \"usage: %s path\", argv[ 0 ]);\n        exit( EXIT&#95;FAILURE );\n    }\n    d = opendir( path );\n    if( d == NULL ) { perror( path );exit( EXIT&#95;FAILURE ); }\n    while( ( f = readdir( d ) ) != NULL ) {\n        if( f-&#62;d&#95;name[ 0 ] != '.'  &&  f-&#62;d&#95;type == DT&#95;REG )\n            count += 1;\n    }\n    printf( \"%d\\n\", count );\n    return EXIT&#95;SUCCESS;\n}\n</pre>\n", "senID": 1}]]