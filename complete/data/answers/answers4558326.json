[[{"text": ["This might help you:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def all_same_sign(ints):\n    return all(x &lt; 0 for x in ints) or all(x &gt; 0 for x in ints)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You may want to change &lt; and > to &lt;= and >= depending on how you want to treat 0."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["After @EOL's solution, but works without list indexing or iterating multiple times."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def all_same_sign(sequence):\n    items = iter(sequence)\n    try:\n        first = items.next() &gt; 0\n    except StopIteration:\n        return True\n    return all((item &gt; 0) == first for item in items)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This also occurred to me, but doesn't take advantage of all/any short-circuiting:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def all_same_sign(sequence):\n    return len(set(item &gt; 0 for item in sequence)) &lt;= 1\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here is a nice pythonic way of doing this (using all()):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "all()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from math import copysign\n\nsign = lambda x: copysign(1, x)  # Sign function\n\ndef check_consistent_categories(sequence):\n    main_sign = sign(sequence[0])\n    return all(sign(y) == main_sign for y in sequence)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(for Python 2.6+, which introduced the math.copysign() function).", "This solution considers that 0 is positive."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "math.copysign()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Mark Byers' solution is more flexible, though, and it is also arguably more legible."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Just one unrelated nit, since you are doing this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    [...]\nexcept:\n    [...]\n</code>\n</pre>\n", "senID": 1}, {"text": ["You are ignoring all of the exceptions, be very careful my friend, this will be hiding lots of bugs, instead always be precise while doing exception handling e.g:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "all", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n try:\n    [...]\nexcept IndexError:\n    # Handle out of index\nexcept IOError:\n    # Handle I/O error\n</code>\n</pre>\n", "senID": 3}, {"text": ["etc.", "Keep this in mind while coding a larger python application."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Here is one that works fine with generators etc.", "too"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def all_same_sign(ints):\n    ints = iter(ints)\n    first_is_positive = next(ints) &gt; 0\n    return all( (x&gt;0) == first_is_positive for x in ints)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If ints is empty, you get a StopIteration exception."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "ints", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This version gorups 0 with the negative numbers.", "Use &gt;= if you wish to group with the positive numbers instead"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "&gt;=", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"code": "<pre>\n<code>\n def all_same_sign(iterable):\n    # Works with any iterable producing any items that can be compared to zero.\n    # Iterates through the input no more than once, and this fact is immediately\n    # obvious from the code.\n    # Exits as soon as a bad combination has been detected.\n    pos = neg = zero = False\n    for item in iterable:\n        if item &gt; 0:\n            pos = True\n        elif item &lt; 0:\n            neg = True\n        else:\n            zero = True\n        # Adjust the following statement if a different\n        # treatment of zero is required.\n        # Redundant parentheses added for clarity.\n        if (pos and neg) or zero:\n            return False\n    return True\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If your numbers are sorted you only need to compare the ends.", "If not you could sort them:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def same_sign(numbers):\n    numbers = sorted(numbers)\n    #if numbers[0]==0: return True                Uncomment if you consider 0 positive\n    if numbers[0]*numbers[-1]&gt;0: return True\n    return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you changed this to &gt;=0 zero would be considered sign neutral.", "I'm not sure if this is a better implementation than the current answers, but it could be faster for large sets of data."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "&gt;=0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Why not take advantage of the fact that if all numbers are the same sign, then the sum of the absolute value of each individual number will be equal to the absolute value of the sum of each number?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def check_sign(queryset):\n    return abs(sum(queryset)) == sum(map(abs, queryset))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example Showing Details of the Math"], "childNum": 0, "tag": "h2", "senID": 2, "childList": []}, {"text": ["Case 1: All numbers have the same sign"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Case 1:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a = (-1, -4, -8)\nsum(a) = -13\nabs(sum(a)) = 13        # the absolute value of the tuple's sum\nmap(abs, a) = [1, 4, 8]\nsum(map(abs, a)) = 13   # the tuple's sum of each element's absolute value\n</code>\n</pre>\n", "senID": 4}, {"text": ["Both methods yield 13, so the signs are the same."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Case 2: Not all numbers have the same sign"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Case 2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n b = (-1, 4, 8)\nsum(b) = 11\nabs(sum(b)) = 11        # the absolute value of the tuple's sum \nmap(abs, b) = [1, 4, 8]\nsum(map(abs, b)) = 13   # the tuple's sum of each element's absolute value\n</code>\n</pre>\n", "senID": 7}, {"text": ["The methods yield different numbers (11 and 13), so the signs are not all the same."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Using the principal that multiplying your numbers gives a positive result if they all the same, else negative,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\n\ndef all_same_sign(intlist):\n    return reduce(operator.mul, intlist) &gt; 0\n\n&gt;&gt;&gt; all_same_sign([-1, -4, -6, -8])\nTrue\n&gt;&gt;&gt; all_same_sign([-1, -4, 12, -8])\nFalse\n</code>\n</pre>\n", "senID": 1}, {"text": ["This doesn't handle zeros though..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You need to show us more code.", "What's queryset?", "As of right now, it doesn't make sense.", "You're first_item is of type queryset[0].amount, and you're comparing that sign to that of queryset[i]"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]