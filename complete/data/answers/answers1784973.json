[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; a = {'tuple': (23, 32)}\n&gt;&gt;&gt; a\n{'tuple': (23, 32)}\n&gt;&gt;&gt; a['tuple'] = (42, 24)\n&gt;&gt;&gt; a\n{'tuple': (42, 24)}\n&gt;&gt;&gt; del a['tuple']\n&gt;&gt;&gt; a\n{}\n</code>\n</pre>\n", "senID": 0}, {"text": ["if you meant to use tuples as keys you could do:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; b = {(23, 32): 'tuple as key'}\n&gt;&gt;&gt; b\n{(23, 32): 'tuple as key'}\n&gt;&gt;&gt; b[23, 32] = 42\n&gt;&gt;&gt; b\n{(23, 32): 42}\n</code>\n</pre>\n", "senID": 2}, {"text": ["Generally speaking there is nothing specific about tuples being in dictionary, they keep behaving as tuples."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You can't change a tuple itself.", "You have to replace it by a different tuple."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When you use a list, you could also add values to it (changing the list itself) without need to replace it:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt; a = {'list': (23, 32)}\n&gt;&gt; a\n{'list': [23, 32]}\n&gt;&gt; a['list'].append(99)\n&gt;&gt; a\n{'list': [23, 32, 99]}\n</code>\n</pre>\n", "senID": 2}, {"text": ["In most cases, lists can be used as replacement for tuples (since as much I know they support all tuple functions -- this is duck typing, man!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Since tuples are immutable, you cannot add a value to the tuple.", "What you can do, is construct a new tuple from the current tuple and an extra value.", "The += operator does this for you, provided the left argument is a variable (or in this case a dictionary value):"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "immutable", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "can", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; t = {'k': (1, 2)}\n&gt;&gt;&gt; t['k'] += (3,)\n&gt;&gt;&gt; t\n{'k': (1, 2, 3)}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Regardless, if you plan on altering the tuple value, perhaps it's better to store lists?", "Those are mutable."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: Since you updated your question&dagger;, observe the following:"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/1784973/tuples-in-dicts/1785112#1785112", "text": "updated", "childNum": 0, "tag": "a", "childList": []}, {"text": "&dagger;", "childNum": 0, "tag": "sup", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d = {42: ('name', 'date')}\n&gt;&gt;&gt; d[42][0] = 'name2'\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment\n</code>\n</pre>\n", "senID": 4}, {"text": ["This happens because, as stated before, tuples are immutable.", "You cannot change them.", "If you want to change them, then in fact you'll have to create a new one.", "Thus:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d[42] = ('name2', d[42][2])\n&gt;&gt;&gt; d\n{42: ('name2', 'date')}\n</code>\n</pre>\n", "senID": 6}, {"text": ["As a side note, you may want to use namedtuples.", "They work just like regular tuples, but allow you to refer to elements within the tuple by name:"], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "As a side note", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "namedtuple", "tag": "a", "pos": -1, "childList": [{"text": "namedtuple", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/collections.html#collections.namedtuple"}, {"text": "namedtuple", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "by name", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; Person = namedtuple('Person', 'name date')\n&gt;&gt;&gt; t = {42: Person('name', 'date')}\n&gt;&gt;&gt; t[42] = Person('name2', t[42].date)\n&gt;&gt;&gt; t\n{42: Person(name='name2', date='date')}\n</code>\n</pre>\n", "senID": 8}, {"tag": "hr", "senID": 9}, {"text": ["&nbsp; &dagger;: Next time please edit your actual question.", "Do not post an answer containing only further questions.", "This is not a forum."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "&dagger;", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}, {"text": "Do not", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}], [{"code": "<pre>\n<code>\n t1=('name','date')\nt2=('x','y')\n\n# \"Number\" is a String key!\nd1={\"Number\":t1}\n# Update the value of \"Number\"\nd1[\"Number\"] = t2\n\n# Use a tuple as key, and another tuple as value\nd1[t1] = t2\n\n# Obtain values (getters)\n\n# Can throw a KeyError if \"Number\" not a key\nfoo = d1[\"Number\"]\n\n# Does not throw a key error, t1 is the value if \"Number\" is not in the dict\nd1.get(\"Number\", t1)\n\n# t3 now is the same as t1\nt3 = d1[ ('name', 'date') ]\n</code>\n</pre>\n", "senID": 0}, {"text": ["You updated your question again.", "Please take a look at Python dict docs.", "Python documentation is one of it's strong points!", "And play with the interpreter (python)on the command line!", "But let's continue."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Python dict docs", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#mapping-types-dict"}]}, {"text": ["And please consider using a "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Person(object):\n    personIdCounter = 1\n    def __init__(self):\n      self.id = Person.personIdCounter\n      Person.personIdCounter += 1\n      self.name\n      self.date\n</code>\n</pre>\n", "senID": 3}, {"text": ["then "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n persons = {}\nperson = Person()\npersons[person.id] = person\nperson.name = \"something\"\n\npersons[1].name = \"something else\"\n</code>\n</pre>\n", "senID": 5}, {"text": ["That looks better than a tuple and models your data better."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["The question is that:\ni want a dictionary with the basic infos of some people lets say.", "The dict contains numbers as keys and tuples as values.Tuples contain\nthe name and the date for every person.", "I wann fix a menu choice in which:\n1)i can add in the dict a new person(with initional date 0)\n2)i can remove a person from the dict (using only his number)\n3)i can add a new date(again using only his number)\n4)and finally print the dict!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n t1=('name','date')\nd1={Number:'(name,date)'}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I was thinking sth like that (the specific doesnt work :ppp):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n names=[]                     \ndates=[]                   \nNumber=[]                       \n\nt1=tuple()\nt1=(names) + (dates)       \n\nd1=dict((Number)='t1')             \n\n\ndef new_person(name,date,Number1):\n\n    names.append('name')\n    print(names)\n    grade.append('date')\n    print(dates)\n    t1=(names) + (dates)\n    print(t1)\n</code>\n</pre>\n", "senID": 1}]]