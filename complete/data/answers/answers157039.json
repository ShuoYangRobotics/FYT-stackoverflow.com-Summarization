[[{"text": ["Having to iterate over the list multiple times isn't elegant IMHO."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I'd probably create a function that allows doing:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n twos, threes = countmatching(xrange(1,10),\n                             lambda a: a % 2 == 0,\n                             lambda a: a % 3 == 0)\n</code>\n</pre>\n", "senID": 2}, {"text": ["A starting point would be something like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def countmatching(iterable, *predicates):\n    v = [0] * len(predicates)\n    for e in iterable:\n        for i,p in enumerate(predicates):\n            if p(e):\n                v[i] += 1\n    return tuple(v)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Btw, \"itertools recipes\" has a recipe for doing much like your alt4."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def quantify(seq, pred=None):\n    \"Count how many times the predicate is true in the sequence\"\n    return sum(imap(pred, seq))\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Alt 4!", "But maybe you should refactor the code to a function that takes an argument which should contain the divisible number (two and three).", "And then you could have a better functionname."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def methodName(divNumber, r):\n  return sum(1 for v in r if v % divNumber == 0)\n\n\nprint methodName(2, xrange(1, 10))\nprint methodName(3, xrange(1, 10))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could use the filter function."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "filter", "tag": "a", "pos": 0, "childList": [{"text": "filter", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/lib/built-in-funcs.html"}, {"text": "filter", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It filters a list (or strictly an iterable) producing a new list containing only the items for which the specified function evaluates to true."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n r = xrange(1, 10)\n\ndef is_div_two(n):\n    return n % 2 == 0\n\ndef is_div_three(n):\n    return n % 3 == 0\n\nprint len(filter(is_div_two,r))\nprint len(filter(is_div_three,r))\n</code>\n</pre>\n", "senID": 2}, {"text": ["This is good as it allows you keep your statistics logic contained in a function and the intent of the filter should be pretty clear."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "filter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Well you could do one list comprehension/expression to get a set of tuples with that stat test in them and then reduce that down to get the sums."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n r=xrange(10)\ns=( (v % 2 == 0, v % 3 == 0) for v in r )\ndef add_tuples(t1,t2):\n     return tuple(x+y for x,y in zip(t1, t2))\nsums=reduce(add_tuples, s, (0,0)) # (0,0) is starting amount\n\nprint sums[0] # sum of numbers divisible by 2\nprint sums[1] # sum of numbers divisible by 3\n</code>\n</pre>\n", "senID": 1}, {"text": ["Using generator expression etc should mean you'll only run through the iterator once (unless reduce does anything odd?).", "Basically you'd be doing map/reduce..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["True booleans are coerced to unit integers, and false booleans to zero integers.", "So if you're happy to use scipy or numpy, make an array of integers for each element of your sequence, each array containing one element for each of your tests, and sum over the arrays.", "E.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sum(scipy.array([c % 2 == 0, c % 3 == 0]) for c in xrange(10))\narray([5, 4])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would choose a small variant of your (alt 4):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def count(predicate, list):\n    print sum(1 for x in list if predicate(x))\n\nr = xrange(1, 10)\n\ncount(lambda x: x % 2 == 0, r)\ncount(lambda x: x % 3 == 0, r)\n# ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want to change what count does, change its implementation in one place."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note: since your predicates are complex, you'll probably want to define them in functions instead of lambdas.", "And so you'll probably want to put all this in a class rather than the global namespace."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I would definitely be looking at a numpy array instead of an iterable list if you just have numbers.", "You will almost certainly be able to do what you want with some terse arithmetic on the array."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.numpy.org/"}]}], [{"text": ["Not as terse as you are looking for, but more efficient, it actually works with any iterable, not just iterables you can loop over multiple times, and you can expand the things to check for without complicating it further:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n r = xrange(1, 10)\n\ncounts = {\n   2: 0,\n   3: 0,\n}\n\nfor v in r:\n    for q in counts:\n        if not v % q:\n            counts[q] += 1\n        # Or, more obscure:\n        #counts[q] += not v % q\n\nfor q in counts:\n    print \"%s's: %s\" % (q, counts[q])\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n from itertools import groupby\nfrom collections import defaultdict\n\ndef multiples(v):\n    return 2 if v%2==0 else 3 if v%3==0 else None\nd = defaultdict(list)\n\nfor k, values in groupby(range(10), multiples):\n    if k is not None:\n        d[k].extend(values)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["The idea here is to use reduction to avoid repeated iterations.", "Also, this does not create any extra data structures, if memory is an issue for you.", "You start with a dictionary with your counters ({'div2': 0, 'div3': 0}) and increment them along the iteration."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "{'div2': 0, 'div3': 0}", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n def increment_stats(stats, n):\n    if n % 2 == 0: stats['div2'] += 1\n    if n % 3 == 0: stats['div3'] += 1\n    return stats\n\nr = xrange(1, 10)\nstats = reduce(increment_stats, r, {'div2': 0, 'div3': 0})\nprint stats\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want to count anything more complicated than divisors, it would be appropriate to use a more object-oriented approach (with the same advantages), encapsulating the logic for stats extraction."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Stats:\n\n    def __init__(self, div2=0, div3=0):\n        self.div2 = div2\n        self.div3 = div3\n\n    def increment(self, n):\n        if n % 2 == 0: self.div2 += 1\n        if n % 3 == 0: self.div3 += 1\n        return self\n\n    def __repr__(self):\n        return 'Stats(%d, %d)' % (self.div2, self.div3)\n\nr = xrange(1, 10)\nstats = reduce(lambda stats, n: stats.increment(n), r, Stats())\nprint stats\n</code>\n</pre>\n", "senID": 3}, {"text": ["Please point out any mistakes."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["@Henrik: I think the first approach is less maintainable since you have to control initialization of the dictionary in one place and update in another, as well as having to use strings to refer to each stat (instead of having attributes).", "And I do not think OO is overkill in this case, for you said the predicates and objects will be complex in your application.", "In fact if the predicates were really simple, I wouldn't even bother to use a dictionary, a single fixed size list would be just fine.", "Cheers :)"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Henrik", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "#158250"}]}], [{"text": ["Inspired by the OO-stab above, I had to try my hands on one as well (although this is way overkill for the problem I'm trying to solve :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Stat(object):\n  def update(self, n):\n    raise NotImplementedError\n\n  def get(self):\n    raise NotImplementedError\n\n\nclass TwoStat(Stat):\n  def __init__(self):\n    self._twos = 0\n\n  def update(self, n):\n    if n % 2 == 0: self._twos += 1\n\n  def get(self):\n    return self._twos\n\n\nclass ThreeStat(Stat):\n  def __init__(self):\n    self._threes = 0\n\n  def update(self, n):\n    if n % 3 == 0: self._threes += 1\n\n  def get(self):\n    return self._threes\n\n\nclass StatCalculator(object):\n  def __init__(self, stats):\n    self._stats = stats\n\n  def calculate(self, r):\n    for v in r:\n      for stat in self._stats:\n        stat.update(v)\n    return tuple(stat.get() for stat in self._stats)\n\n\ns = StatCalculator([TwoStat(), ThreeStat()])\n\nr = xrange(1, 10)\nprint s.calculate(r)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Alt 3, for the reason that it doesn't use memory proportional to the number of \"hits\".", "Given a pathological case like xrange(one_trillion), many of the other offered solutions would fail badly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]