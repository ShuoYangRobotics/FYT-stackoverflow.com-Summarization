[[{"text": ["multiprocessing can get around the GIL, but it introduces its own issues such as communication between the processes."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "multiprocessing", "tag": "a", "pos": 0, "childList": [{"text": "multiprocessing", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/multiprocessing.html"}, {"text": "multiprocessing", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Python is not very good for CPU-bound concurrent programming.", "The GIL will (in many cases) make your program run as if it was running on a single core - or even worse.", "Even Unladen Swallow will (probably) not solve that problem (quote from their project plan: \"we are no longer as optimistic about our chances of removing the GIL completely\")."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "project plan", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://code.google.com/p/unladen-swallow/wiki/ProjectPlan"}]}, {"text": ["As you already stated, other languages claim to be better in concurrent programming.", "Haskell, for example, has built-in functionality for programming concurrent applications.", "You could also try C++ with OpenMP, which I think makes parallelization very simple."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Haskell", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.haskell.org/"}]}, {"text": ["If your application is I/O-bound, Python may be a serious solution as the GIL is normally released while doing blocking calls."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["In my limited experience, the \"context switch cost\" is overrated as a performance limitation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I/O bandwidth and memory are the most common limiting factors.", "Python's I/O is comparable to many other languages, since it simply uses the standard C libraries pretty directly."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Your actual problem may not be typical.", "However, many problems work out really well in multi-processing mode because they're actually I/O bound.", "Often it's filesystem, web page reading or Database operations that limit performance long before context switches."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you're considering learning Python for addressing this problem, I might suggest taking a look at Erlang instead.", "It has excellent support for very lightweight processes, and built-in primitives for IPC."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Not to discourage you from learning Python, of course, just suggesting there might be a better tool for this particular task."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Also if you are looking at object sharing between the python processes, i suggest you look at the answer by Alex in this question"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1268252/python-possible-to-share-in-memory-data-between-2-separate-processes/1269055#1269055"}]}], [{"text": ["writing codes for multiple process is not an easy task. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But if you start thinking to this way first, eventually, it is easier to scale if one machine isn't enough...Threads can't be used across machines..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]