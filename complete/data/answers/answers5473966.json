[[{"text": ["Well, the &lt;div&gt; and &lt;span&gt; tags have a structural meaning, that cannot be automatically guessed as \"superfluous\"."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "&lt;div&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "&lt;span&gt;", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Your problem looks very similar to AST (Abstract Syntax Tree) optimization done in compilers.", "You could try to define some rules and build a SoupOptimizer to take a tree (your document) and produce an optimized output tree.", "Rules could be:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "SoupOptimizer", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "span(content) -> content, if span.attributes is empty", "tag": "none", "senID": 2}, {"text": "div(content) -> content, if div.attributes is empty", "tag": "none", "senID": 3}]}, {"text": ["Note, that tree transformations on XML dialects can be done with XSLT.", "Just be ready to have your brain turned inside out before you see the light!"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The way we do it is to use lxml and determine the parents and children of every element.", "If there is no text content difference in the parents and children then we have a set of rules that we follow to retain certain children while tossing the parents.", "And then forcing the appropriate block elements  In your case b is a child of span, div and td we know that the td tag is the structuring element that is relevant so we get rid of the others.", "Again this requires testing the text content of each of the nested elements.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You could use the strip_tags function of Jesse Dhillon's answer of this question"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "strip_tags", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/1765848/remove-a-tag-using-beautifulsoup-but-keep-its-contents", "text": "this question", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["You could rearrange the parse tree like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from BeautifulSoup import BeautifulSoup\n\nsoup = BeautifulSoup(\"&lt;td&gt;&lt;div&gt;&lt;span&gt;&lt;b&gt;Patienten&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;/td&gt;\")\ntd = soup.td\nb = soup.td.div.span.b\ntd.insert(0,b)\ntd.div.extract()\nprint soup\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I like the approach suggested by @Daren Thomas, but be aware that removing those \"useless\" tags could drastically affect the rendered appearance of the document thanks to JavaScript (less likely) or CSS (much more likely, possibly even probable) that relies on the resulting HTML to follow certain structural patterns, even if they are wasteful."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "approach suggested by @Daren Thomas", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/5473966/beautifulsoup-removing-unneccessary-inner-tags/5474050#5474050"}]}, {"text": ["This makes the life of the tool writer much easier.", "Assume that some given construct in the DOCX has two possible variations.", "One of these requires a lot of boilerplate so you can attach a few special attributes (say a text-align or some such).", "The other doesn't.", "It's way easier to just always generate the boilerplate and write your CSS or what-have-you with that fact in mind."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "text-align", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["If Beautiful Soup alone isn't sufficient, you can resort to regular expression."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nch = 'sunny day&lt;td&gt;&lt;div&gt;&lt;span&gt;&lt;b&gt;Patienten&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;/td&gt;rainy week'\n# &lt;td&gt;&lt;b&gt;Patienten&lt;/b&gt;&lt;/td&gt;\n\nRE = '(&lt;td&gt;)&lt;div&gt;&lt;span&gt;(&lt;b&gt;.*?&lt;/b&gt;)&lt;/span&gt;&lt;/div&gt;(&lt;/td&gt;)'\n\npat = re.compile(RE)\n\nprint ch\nprint pat.sub('\\\\1\\\\2\\\\3',ch)\n</code>\n</pre>\n", "senID": 1}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n sunny day&lt;td&gt;&lt;div&gt;&lt;span&gt;&lt;b&gt;Patienten&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;/td&gt;rainy week\nsunny day&lt;td&gt;&lt;b&gt;Patienten&lt;/b&gt;&lt;/td&gt;rainy week\n</code>\n</pre>\n", "senID": 3}, {"text": ["Easy, easyn't it ?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["A preliminary inspection can be done to determine if the replacement must really be done or not."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]