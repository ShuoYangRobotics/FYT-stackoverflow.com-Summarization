[[{"text": ["If you need to wrap around on overflow, simply take your sum modulo MAX_LONG at the end."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["A direct, Pythonic translation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def memSum(data):\n    return sum(ord(c) for c in data) &amp; 0xFFFFFFFF\n</code>\n</pre>\n", "senID": 1}], [{"text": ["As I mentioned in my comment, you need to convert the string into a list of ints.", "This probably what you want:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n f=open(\"infile.txt\",'rb')\nm=f.read()\nf.close()\nm=map(ord,list(m))\nprint sum(m)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The ord function returns the ascii int corresponding to a character."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "ord", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I've tried your code, and seems to be working (it opens the data in binary, convert it to a list of unsigned char and adds all). "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What is your problem?", "Could be an overflow problem?", "Maybe there is a problem with the length?", "How are you saving the file?", "Sorry, but with this information we can only guess!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The code is not equivalent, as the Python code seems to deal with files and the C code seems to deal with a memory array."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You really need to give an example input and what you expect as output.", "Any code that uses a recent version of Python, extracts an integer in range(256) from each byte, sums those integers, and finally does total &amp;= 0xFFFFFFFF should do the job (assuming that your unsigned long is 32 bits wide)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "total &amp;= 0xFFFFFFFF", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "unsigned long", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Note that the last step ( the &amp;=) is pointless if your file is less than about 16MB in size ... it won't overflow; 16843009 * 255 &lt;= 0xFFFFFFFF &lt; (16843009 + 1) * 255"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "&amp;=", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["That means that if your test file is smaller than 16843010 bytes, you must have a problem in your C code or your Python code or both."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You said that \"of course\" this code:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n f=open(\"file_to_sum\",'rb')\nm = f.read()\nf.close()\nsum( array.array('B', m) )\n</code>\n</pre>\n", "senID": 4}, {"text": ["\"doesn't work\".", "Does it work if you replace the last line by "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n print sum( array.array('B', m) )\n</code>\n</pre>\n", "senID": 6}, {"text": [], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["If none of the above is of any help, and you want sensible answers instead of guesses, provide example input, expected output, C code, C output, Python code, Python output.", "Both the C code and the Python code should be standalone-runnable, and should include printing the size of the byte array being summed."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["first, thank you all for your help"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I have written successfully the C implementation and tested over 20 different files the checksum function.", "And then the 2 complement of the computed checksum is compared to a checksum a the file.", "It works perfectly in C as mentionned: with unsigned char and unsigned long."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["the right value of the sum is 3da4be70 (from C implementation)\nfrom your suggestions:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n print '%x' % ( sum( array.array('B', m[ o2+4:o2+len2 ]) ) )\n</code>\n</pre>\n", "senID": 3}, {"text": ["and"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n n = map(ord, list(m[ o2+4: o2+len2 ]))\nprint '%x' % (sum(n))\n</code>\n</pre>\n", "senID": 5}, {"text": ["give 504a022a"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I suppose it is because bytes here in python as interpreted as signed instead of unsigned (like in C)..."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["update:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["even"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n for i in range(o2+4, o2+len2):\n cchk = ( (cchk + unpack('B', m[i])[0]) &amp; 0xffffffff)\nprint '%x' % (cchk)\n</code>\n</pre>\n", "senID": 10}, {"text": ["does not work and gives again 504a022a"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["SOLVED : MY FAULT, SORRY"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #include&lt;stdio.h&gt;\n\nunsigned long memSum(unsigned char *p, unsigned long len)\n{\n   unsigned long i, sum=0;\n\n   for(i=0; i&lt;len; i++) \n      sum = sum + *p++;\n\n   return sum;\n}  \n\n#define LEN2SUM (0xa13b10-4)\n\nint main(int argc, char *argv[] )\n{\n\n  FILE *f;\n  unsigned char *buf;\n  unsigned long sum;\n\n  f=fopen(\"test2.dat\", \"rb\");\n  fseek(f, 0x7c+4, SEEK_SET); \n\n  buf = (unsigned char*)malloc(LEN2SUM);\n  fread(buf, sizeof(char), LEN2SUM, f);\n  sum = memSum( buf, LEN2SUM);\n  printf(\"0x%08x\\n\", sum );\n\n  free(buf);  \n  fclose(f);\n\n\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["and "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n f = open('test2.dat','rb')\nf.seek(0x7c+4)\n\nm = f.read(0xa13b10-4)\nprint '%x' % ( ( sum(ord(c) for c in m) &amp; 0xFFFFFFFF ) )\n</code>\n</pre>\n", "senID": 3}, {"text": ["give the same answer, the good one"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["the difference is that in C, i checksum a given memory area which contains decrypted data, where decryption has been done 'in place'"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["in my python implementation, decryption is done in another buffer, and I still checksum the encrypted area."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["since my a beginner in python, I was focused on this point : bad track.", "i'm kicking my ass twenty times....."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["sorry for the stupid question and thanks again your kind help !!"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}]]