[[{"text": ["If you care only about ordered relationship, you could do the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for i, u in enumerate(users[1:]):\n    print(users[i], u)           # or do something else\n\n\n1 2\n2 3\n3 4\n4 5\n</code>\n</pre>\n", "senID": 1}, {"text": ["if you need all combinations you should use itertools.combinations:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "itertools.combinations", "tag": "a", "pos": 0, "childList": [{"text": "itertools.combinations", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.combinations"}, {"text": "itertools.combinations", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import itertools\n&gt;&gt;&gt; for i in itertools.combinations(users, 2):\n    print(*i)\n\n1 2\n1 3\n1 4\n1 5\n2 3\n2 4\n2 5\n3 4\n3 5\n4 5\n</code>\n</pre>\n", "senID": 3}], [{"text": ["use for loops, or list comprehension."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["here is for loop example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for u in users:\n    for su in users:\n        if su == u:\n            pass\n        else:\n            score = compatibility(u, su)\n            # do score whatever you want\n</code>\n</pre>\n", "senID": 2}, {"text": ["list comprehension:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n score = [compatibility(x, y) for x in users for y in users if x!=y and compatibility(x,y) not in score]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Something like the following should work (not tested):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n users_range = range(len(users))\n\n# Initialize a 2-dimensional array\nscores = [None for j in users_range for i in users_range]\n\n# Assign a compatibility to each pair of users.\nfor i in users_range:\n    for j in users_range:\n        scores[i][j] = compatibility(users[i], users[j])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I managed to do what I wanted with this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n i = 0\nfor user1 in users:   \n    i += 1     \n    for user2 in users[i:]:\n        print compatibility( user1, user2 )\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you mean that:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n compatibility(user[0], user[1]) == compatibility(user[1], user[0])\n</code>\n</pre>\n", "senID": 1}, {"text": ["you could use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for i, user1 in enumerate(users):\n    for user2 in users[i:]:\n        score = compatibility(user1, user2)\n</code>\n</pre>\n", "senID": 3}, {"text": ["this will also calculate the compatibility between the same users (maybe applicable)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n import itertools\n\ndef compatibility(u1, u2):\n    \"just a stub for demonstration purposes\"\n    return abs(u1 - u2)\n\ndef compatibility_map(users):\n    return dict(((u1, u2), compatibility(u1, u2))\n         for u1, u2 in itertools.combinations(users, 2))\n\n&gt; compat.compatiblity_map([1,2,3,4,5])\n{(1, 2): 1, (1, 3): 2, (4, 5): 1, (1, 4): 3, (1, 5): 4,\n (2, 3): 1, (2, 5): 3, (3, 4): 1, (2, 4): 2, (3, 5): 2}\n</code>\n</pre>\n", "senID": 0}, {"text": ["Use itertools.permuations instead of itertools.combinations if compatibility(a,b) doesn't mean the same thing as compatibility(b,a)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]