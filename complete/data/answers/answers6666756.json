[[{"text": ["Because the file's already been read by that point, so there's nothing for the second loop to do.", "You should close and reopen the file after the first loop, and move the instantiation of inv_reader to after that."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "inv_reader", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Better still, you should merge the loops into one - it'll be much more efficient."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["It's like you hand a glass full of water to the first loop and have it drink it, then hand the empty glass to the next loop.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["They both use the same underlying file-object (f).", "After the first loop, this has been exhausted.", "You could do this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "f", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n reader = csv.DictReader(open(\"transport.csv\"))\ninv_reader = csv.DictReader(open(\"transport.csv\"))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This way both readers have independent file-objects."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Be also aware that, according to the documentation (http://docs.python.org/library/csv.html#csv.reader), the file should be open with the \u2018b\u2019 flag on platforms where that makes a difference."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/csv.html#csv.reader", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/csv.html#csv.reader"}]}], [{"text": ["You have created to csv readers (an iterable) using the same file object (also an iterable).", "When you consume the rows from the first csv reader (reader) you consume the lines of the file (f).", "When you come to iterate the second csv reader (inv_reader), the lines of the file object (f) have been consumed; there is nothing left to iterate."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "reader", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "inv_reader", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Here, for reference, is how I would neaten your code considerably.", "This is without alterations to its actual functionality.", "Note that if you have lots and lots of entries in transport.csv, this will be less efficient as I have chosen to go for still a single handle on the file.", "If I knew that that would be a problem, then I would rework it to use the DictReader instead of pulling it all into a tuple immediately (including changing the way of treating len(items), and reinitialise theDictReaderafterwards f.seek(0) (good suggestion, Evpok!", ") and f.readline() to get rid of the header line."], "childNum": 8, "tag": "p", "senID": 0, "childList": [{"text": "transport.csv", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "less", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "DictReader", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "len(items)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "reinitialise theDictReaderafterwards", "childNum": 1, "tag": "s", "pos": -1, "childList": [{"text": "DictReader", "tag": "code"}]}, {"text": "DictReader", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "f.seek(0)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "f.readline()", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"code": "<pre>\n<code>\n import csv\nfrom collections import defaultdict\n\nwith open('transport.csv', 'rb') as f:\n    items = tuple(csv.DictReader(f))\n\ncharges_per_inv = defaultdict(float)\nfor row in items:\n    charges_per_inv[row['Batch#']] += float(row['Amount'])\n\ntotal = sum(charges_per_inv.values())\nprint 'The total charges is, ', total\nprint 'The average charge is, ', total / len(items)\n\na = raw_input('Enter Invoice#: ')\n\ninvoice_amount = 0.0\ninvoice_items = 0\nfor row in items:\n    invoice_num = row['Invoice#']\n    if invoice_num == a:\n        invoice_amount += float(row['Amount'])\n        invoice_items += 1\n\nprint 'The total charges is, ', invoice_amount\nprint 'The average charge is, ', invoice_amount / invoice_items\n</code>\n</pre>\n", "senID": 1}, {"text": ["The efficiency problem I mentioned could also be removed by getting the invoice number at the start and so only having one loop which needs to access the CSV file:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import csv\nfrom collections import defaultdict\n\na = raw_input('Enter Invoice#: ')\n\nwith open('transport.csv', 'rb') as f:\n    reader = csv.DictReader(f)\n\n    num_items = 0\n    charges_per_inv = defaultdict(float)\n    invoice_amount = 0.0\n    invoice_items = 0\n\n    for row in reader:\n        charges_per_inv[row['Batch#']] += float(row['Amount'])\n        invoice_num = row['Invoice#']\n        if invoice_num == a:\n            invoice_amount += float(row['Amount'])\n            invoice_items += 1\n        num_items += 1\n\n    total = sum(charges_per_inv.values())\n    print 'The total charges is, ', total\n    print 'The average charge is, ', total / num_items\n\n    print 'The total invoice item charges is, ', invoice_amount\n    print 'The average invoice item charge is, ', invoice_amount / invoice_items\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you have any questions to ask about things that I've done, please ask."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]