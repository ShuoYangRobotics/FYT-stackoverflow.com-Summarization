[[{"text": ["One way is to just convert it to a two-dimensional NumPy array:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n FFnetlayer0 = FFnetlayer0.reshape(-1, 2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now, accessing FFnetlayer0[i] for some i will give you a NumPy array with two entries."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "FFnetlayer0[i]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "i", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Well your FFnetlayer0 isn't an numpy array, its still just a python list.", "You can slice it"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy array", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from numpy import array\nFFnetlayer = [0,243, 9,243, 18,243]\nfirst_array = array(FFnetlayer[0::2]) # array([0,9,18])\nsecond_array = array(FFnetlayer[1::2]) # array([243,243,243])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Unless its a matrix, I don't see the benefit of making it a two-dimensional array rather than two separate arrays."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You can also zip the two lists together if you didn't need to use them in numpy as a:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n list_of_tuples = zip(FFnetlayer0[0::2], FFnetlayer0[1::2]) # [(0,243), (9,243), (18,243)]\narray_of_list_of_tuples = array(list_of_tuples) # array([[0,243],[9,243],[18,243]])\n</code>\n</pre>\n", "senID": 4}, {"text": ["For more into extended slices (or strides) see: http://docs.python.org/release/2.3/whatsnew/section-slices.html"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "http://docs.python.org/release/2.3/whatsnew/section-slices.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/release/2.3/whatsnew/section-slices.html"}]}, {"text": ["For more on zip see:\nhttp://docs.python.org/library/functions.html#zip"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "http://docs.python.org/library/functions.html#zip", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#zip"}]}, {"text": ["Noticed in the comments that you created the numpy array via append.", "Noted that numpy.append doesn't append in-place, so isn't an efficient way of extending long arrays."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["E.g.,"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n ff_list = [(0,243), (9,243)]\norig_id = id(ff_list)\nfor i in range(1000):\n    ff_list.append((i,243))\n    assert(orig_id == id(ff_list)) # Assertion is always True\nff_array = numpy.array(ff_list) # This will copy the list into an array; but does this only once rather than N times.\n</code>\n</pre>\n", "senID": 9}, {"text": ["whereas "], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n ff_array = numpy.array([(0,243), (9,243)])\nlast_id = id(ff_array)\nfor i in range(1000):\n    ff_array = numpy.append(ff_array, (i,243))\n    assert(last_id != id(ff_array)) # Assertion is True as array is always different.\n    last_id = id(ff_array)\n</code>\n</pre>\n", "senID": 11}, {"text": ["id tells the memory location of a python object.", "Note, this may not be a big difference unless your arrays are large and frequently appended.", "Also if at all possible its best to do array math to construct large arrays, rather than element by element for loops or appending."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "id", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n a = [ 0,  243,    9,  243,   18,  243]\nzip(a[::2],a[1::2])\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Aside: The values in parentheses you are referring to are known as 'tuples', they can hold an arbitrary number of objects. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The default behavior when appending to numpy arrays is to flatten them.", "But once you have a 2-d numpy array, you can append to it without flattening it; you just have to specify the axis argument:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; conec = []\n&gt;&gt;&gt; for i in range(3):\n...     conec = numpy.append(conec,[(i,243),(i+9,243),(i+18,243)])\n...     conec = conec.reshape(-1, 2)\n...     d = 4\n...     conec = numpy.append(conec,[(i+d,244),(i+9+d,244),(i+18+d,244)], axis=0)\n... \n&gt;&gt;&gt; conec\narray([[  0,   0], [  0, 243], [  9, 243], [ 18, 243], [  4, 244],\n       [ 13, 244], [ 22, 244], [  1, 243], [ 10, 243], [ 19, 243],\n       [  5, 244], [ 14, 244], [ 23, 244], [  2, 243], [ 11, 243],\n       [ 20, 243], [  6, 244], [ 15, 244], [ 24, 244]])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Still, it may be easier to simply fill the array and then reshape."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: As jimbob correctly points out, this isn't the most efficient way to build a large array.", "As an alternative, consider numpy.fromiter()"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "numpy.fromiter()", "tag": "a", "pos": 1, "childList": [{"text": "numpy.fromiter()", "tag": "code"}], "childNum": 1, "href": "http://docs.scipy.org/doc/numpy/reference/generated/numpy.fromiter.html#numpy.fromiter"}, {"text": "numpy.fromiter()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You can achieve this using numpy records."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy records", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/numpy/user/basics.rec.html"}]}, {"text": ["It seems that all of your numbers are under 255; therefore I assume that you will not need a datatype that can handle numbers larger than that.", "Should you require another datatype, you can replace np.int8 with the appropriate type."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "appropriate type", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html"}]}, {"code": "<pre>\n<code>\n import numpy as np\n\nstructure_type = np.dtype([('field1', np.int8), ('field2', np.int8)])\nvalues = np.array([(0, 243), (9, 243), (18, 243)], dtype=structure_type)\nprint \"Entire array:\", values\nprint \"First field only:\", values['field1']\nprint \"Second element:\", values[1]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n Entire array: [(0, 243) (9, 243) (18, 243)]\nFirst field only: [  0   9  18]\nSecond element: (9, 243)\n</code>\n</pre>\n", "senID": 4}, {"text": ["As an aside, you do not seem to be using numpy arrays in your code; rather, you are using the function numpy.append to extend a Python list."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "numpy.append", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]