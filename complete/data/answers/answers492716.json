[[{"text": ["Although I don't see much sense in this, here goes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nimport string\n\ndef traverse(tree):\n    retval = ''\n    for node in tree:\n        if node[0] == 'any':\n            retval += 'x'\n        elif node[0] == 'at':\n            pass\n        elif node[0] in ['min_repeat', 'max_repeat']:\n            retval += traverse(node[1][2]) * node[1][0]\n        elif node[0] == 'in':\n            if node[1][0][0] == 'negate':\n                letters = list(string.ascii_letters)\n                for part in node[1][1:]:\n                    if part[0] == 'literal':\n                        letters.remove(chr(part[1]))\n                    else:\n                        for letter in range(part[1][0], part[1][1]+1):\n                            letters.remove(chr(letter))\n                retval += letters[0]\n            else:\n                if node[1][0][0] == 'range':\n                    retval += chr(node[1][0][1][0])\n                else:\n                    retval += chr(node[1][0][1])\n        elif node[0] == 'not_literal':\n            if node[1] == 120:\n                retval += 'y'\n            else:\n                retval += 'x'\n        elif node[0] == 'branch':\n            retval += traverse(node[1][1][0])\n        elif node[0] == 'subpattern':\n            retval += traverse(node[1][1])\n        elif node[0] == 'literal':\n            retval += chr(node[1])\n    return retval\n\nprint traverse(re.sre_parse.parse(regex).data)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I took everything from the Regular Expression Syntax up to groups -- this seems like a reasonable subset -- and I ignored some details, like line endings.", "Error handling, etc.", "is left as an exercise to the reader."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Regular Expression Syntax", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html#regular-expression-syntax"}]}, {"text": ["Of the 12 special characters in a regex, we can ignore 6 completely (2 even with the atom they apply to), 4.5 lead to a trivial replacement and 1.5 make us actually think."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["What comes out of this is not too terribly interesting, I think."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I don't know of any module to do this.", "If you don't find anything like this in the Cookbook or PyPI, you could try rolling your own, using the (undocumented) re.sre_parse module.", "This might help getting you started:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In [1]: import re\n\nIn [2]: a = re.sre_parse.parse(\"[abc]+[def]*\\d?z\")\n\nIn [3]: a\nOut[3]: [('max_repeat', (1, 65535, [('in', [('literal', 97), ('literal', 98), ('literal', 99)])])), ('max_repeat', (0, 65535, [('in', [('literal', 100), ('literal', 101), ('literal', 102)])])), ('max_repeat', (0, 1, [('in', [('category', 'category_digit')])])), ('literal', 122)]\n\nIn [4]: eval(str(a))\nOut[4]: \n[('max_repeat',\n  (1, 65535, [('in', [('literal', 97), ('literal', 98), ('literal', 99)])])),\n ('max_repeat',\n  (0,\n   65535,\n   [('in', [('literal', 100), ('literal', 101), ('literal', 102)])])),\n ('max_repeat', (0, 1, [('in', [('category', 'category_digit')])])),\n ('literal', 122)]\n\nIn [5]: a.dump()\nmax_repeat 1 65535\n  in\n    literal 97\n    literal 98\n    literal 99\nmax_repeat 0 65535\n  in\n    literal 100\n    literal 101\n    literal 102\nmax_repeat 0 1\n  in\n    category category_digit\nliteral 122\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Unless your regex is extremely simple (i.e.", "no stars or pluses), there will be infinitely many strings which match it.", "If your regex only involves concatenation and alternation, then you can expand each alternation into all of its possibilities, e.g.", "(foo|bar)(baz|quux) can be expanded into the list ['foobaz', 'fooquux', 'barbaz', 'barquux']."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "(foo|bar)(baz|quux)", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "['foobaz', 'fooquux', 'barbaz', 'barquux']", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I haven't seen a Python module to do this, but I did see a (partial) implementation in Perl: Regexp::Genex.", "From the module description, it sounds like the implementation relies on internal details of Perl's regular expression engine, so it may not be useful even from a theoretical point of view (I haven't investigated the implementation, just going by the comments in the documentation)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Regexp::Genex", "tag": "a", "pos": 0, "childList": [{"text": "Regexp::Genex", "tag": "code"}], "childNum": 1, "href": "http://search.cpan.org/~bowmanbs/Regexp-Genex-0.07/lib/Regexp/Genex.pm"}, {"text": "Regexp::Genex", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["I think doing what you propose in general is a hard problem and may require the use of nondeterministic programming techniques.", "A start would be to parse the regular expression and build a parse tree, then traverse the tree and build sample string(s) as you go.", "Challenging bits will probably be things like backreferences and avoiding infinite loops in your implementation."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["While the other answers use the re engine to parse out the elements I have whipped up my own that parses the re and returns a minimal pattern that would match.", "(Note it doesn't handle [^ads], fancy grouping constructs, start/end of line special characters).", "I can supply the unit tests if you really like :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nclass REParser(object):\n\"\"\"Parses an RE an gives the least greedy value that would match it\"\"\"\n\n def parse(self, parseInput):\n    re.compile(parseInput) #try to parse to see if it is a valid RE\n    retval = \"\"\n    stack = list(parseInput)\n    lastelement = \"\"\n    while stack:\n        element = stack.pop(0) #Read from front\n        if element == \"\\\\\":\n            element = stack.pop(0)\n            element = element.replace(\"d\", \"0\").replace(\"D\", \"a\").replace(\"w\", \"a\").replace(\"W\", \" \")\n        elif element in [\"?\", \"*\"]:\n            lastelement = \"\"\n            element = \"\"\n        elif element == \".\":\n            element = \"a\"\n        elif element == \"+\":\n            element = \"\"\n        elif element == \"{\":\n            arg = self._consumeTo(stack, \"}\")\n            arg = arg[:-1] #dump the }     \n            arg = arg.split(\",\")[0] #dump the possible ,\n            lastelement = lastelement * int(arg)\n            element = \"\"\n        elif element == \"[\":\n            element = self._consumeTo(stack, \"]\")[0] # just use the first char in set\n            if element == \"]\": #this is the odd case of []&lt;something&gt;]\n                self._consumeTo(stack, \"]\") # throw rest away and use ] as first element\n        elif element == \"|\":\n            break # you get to an | an you have all you need to match\n        elif element == \"(\":\n            arg = self._consumeTo(stack, \")\")\n            element = self.parse( arg[:-1] )\n\n        retval += lastelement\n        lastelement = element\n    retval += lastelement #Complete the string with the last char\n\n    return retval\n\n def _consumeTo(self, stackToConsume, endElement ):\n    retval = \"\"\n    while not retval.endswith(endElement):\n        retval += stackToConsume.pop(0)\n    return retval\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Check out the regex inverter at UtilityMill.", "(Source code is viewable, based on this example from the pyparsing wiki."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "regex inverter at UtilityMill", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://utilitymill.com/utility/Regex_inverter"}, {"text": "this example", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/file/view/invRegex.py"}]}], [{"text": ["Somebody else had a similar (duplicate?", ") question here, and I'd like to offer a little helper library for generating random strings with Python that I've been working on."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4627464/generate-a-string-that-matches-a-regex-in-python"}, {"href": "https://bitbucket.org/leapfrogdevelopment/rstr/", "text": "generating random strings with Python", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["It includes a method, xeger() that allows you to create a string from a regex:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "xeger()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import rstr\n&gt;&gt;&gt; rstr.xeger(r'[A-Z]\\d[A-Z] \\d[A-Z]\\d')\nu'M5R 2W4'\n</code>\n</pre>\n", "senID": 2}, {"text": ["Right now, it works with most basic regular expressions, but I'm sure it could be improved."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Perhaps you should consider changing your string with a [::-1]\nie"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["foo = \"Lampole\""], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["foo = foo[::-1]"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["print foo"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["elopmaL"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]