[[{"text": ["Generally, you can't.", "Three variables, three loops."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But this is a special case, as nobody pointed out.", "You can solve this problem with two loops."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "nobody", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/588052/a-question-on-for-loops-in-python/588087#588087"}]}, {"text": ["Also, there's no point in checking y, z and z, y."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Oh, and range(10000, 1000) = []."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "range(10000, 1000) = []", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import math\n\nfor x in range(1, 1000):\n  for y in range(x, 1000):\n      z = math.sqrt(x**2 + y**2)\n      if int(z) == z:\n        print x, y, int(z)\n        print '-'*50\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You can arrange your code in a single main loop like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n MIN = 10000\nMAX = 10010\na = [MIN, MIN, MIN]\nwhile True:\n    print a\n    for i in range(len(a)):\n        a[i] = a[i] + 1\n        if a[i] &lt; MAX:\n            break\n        a[i] = MIN\n        i += 1\n    else:\n        break\n</code>\n</pre>\n", "senID": 1}, {"text": ["Instead of the print a, you can do your Pythagorean triplet test there.", "This will work for an arbitrary number of dimensions."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "print a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you really want to do this infinitely, you will have to use a different iteration technique such as diagonalization."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "diagonalization", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Diagonal%5Fargument"}]}], [{"text": ["You would only need two loops - just check to see if math.sqrt(x*x+y*y) is an integer.", "If it is, you've discovered a pythagorean triple."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "math.sqrt(x*x+y*y)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I'm new to Python, so I don't know what range(10000, 1000) does - where does it start and stop?", "I ask because you can halve your runtime by having the range for y start at x instead of fixing it, due to the fact that addition is commutative."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "range(10000, 1000)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["edit: This answer is what I was getting at, and what I would have written if I knew more Python. "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/588052/a-question-on-for-loops-in-python/588067#588067", "text": "This answer", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Using xrange instead of range should use less memory, especially if you want to try large ranges."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "xrange", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#xrange"}, {"text": "range", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Here's an efficient version, using iterators, that generates all such triples,\nin order.", "The trick here is to iterate up through the sets of (x,y) pairs \nthat sum to N, for all N."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\nimport math\nimport itertools\n\ndef all_int_pairs():\n    \"generate all pairs of positive integers\"\n    for n in itertools.count(1):\n        for x in xrange(1,n/2+1):\n            yield x,n-x\n\nfor x,y in all_int_pairs():\n    z = math.sqrt(x**2 + y**2)\n    if int(z) == z:\n        print x, y, int(z)\n        print '-'*50\n</pre>\n", "senID": 1}], [{"text": ["Not the most efficient (Python will build an array with a billion tuples), but this is a single loop:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for x, y, z in [(x, y, z) for x in range(10000, 11000) for y in range(10000, 11000) for z in range(10000, 11000)]:\n    if x*x == y*y + z*z:\n        print y, z, x\n        print '-'*50\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or, as suggested by Christian Witts,"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Christian Witts", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/69893/christian-witts"}]}, {"code": "<pre>\n<code>\n for x, y, z in ((x, y, z) for x in xrange(10000, 11000) for y in xrange(10000, 11000) for z in xrange(10000, 11000)):\n    if x*x == y*y + z*z:\n        print y, z, x\n        print '-'*50\n</code>\n</pre>\n", "senID": 3}, {"text": ["(assuming Python >= 2.4) uses generators instead of building a billion-tuple array."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "generators", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0289/"}]}, {"text": ["Either way, you shouldn't code like this...", "Your initial code with nested loops is clearer."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["This is the same as Can Berk Guder's answer, but done as a generator, just for fun.", "It's not really useful with the nested loops here, but it can often be a cleaner solution.", "Your function produces results; you worry later about how many to retrieve."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import math\n\ndef triplets(limit):\n    for x in range(1, limit):\n        for y in range(x, limit):\n            z = math.sqrt(x**2 + y**2)\n            if int(z) == z:\n                yield x, y, int(z)\n\nfor x, y, z in triplets(10):\n    print x, y, z\n    print \"-\" * 50\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using the same algorithm (see the other answers for better approaches), you can use itertools.count to get a loop that runs forever."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\nfor x in itertools.count(1):\n    for y in xrange(1, x):\n         for z in xrange(1, y):\n              if x*x == y*y + z*z:\n                  print x, y, z\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Besides what has already been posted, people would expect three loops for three collections.", "Anything else may get very confusing and provide no added benefit."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you want to count to infinity .."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Create a generator function that counts from zero and never stops, and use the for loop on it"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def inf():\n   i = 0\n   while True:\n     yield i\n     i = i + 1\n\nfor i in inf():\n    print i  # or do whatever you want!\n</code>\n</pre>\n", "senID": 2}, {"text": ["I don't know if there's already such a builtin function"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["At least three loops are needed for infinity.", "To make something flexible takes a ton of loops.", "This example is a solution to Project Euler Problem 9 and more."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Project Euler Problem 9", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://projecteuler.net/index.php?section=problems&id=9"}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\ndef fcount(start=1):\n    n = float(start)\n    while True:\n        yield n\n        n += 1\n\ndef find_triples():\n    for c in fcount():\n        for b in fcount():\n            if b &gt; c:\n                break\n            for a in fcount():\n                if a &gt; b:\n                    break\n                if a ** 2 + b ** 2 == c ** 2:\n                    yield (a, b, c)\n\ndef triples_by_sum(targetsum):\n    for a, b, c in find_triples():\n        if a + b + c == targetsum:\n            yield a, b, c\n        if c &gt; targetsum:\n            break\n\nif __name__ == '__main__':\n    # Finds multiple triples\n    for a, b, c in triples_by_sum(252):\n        print a, b, c\n    # Finds single triples\n    a, b, c = triples_by_sum(1000).next()\n    print a, b, c\n    # Goes forever\n    for a, b, c in find_triples():\n        print a, b, c\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about use itertools.product instead?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # range is [10000, 1000)\nfor x, y, z in itertools.product(range(10000, 1000, -1), repeat=3): \n    if x * x == y * y + z * z:\n        print(y, z, x)\n</code>\n</pre>\n", "senID": 1}, {"text": ["with a litter bit optimize:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for x, y, z in itertools.product(range(10000, 1000, -1), repeat=3):\n    if y &gt;= x or z &gt;= x or x &gt;= (y + z) or z &lt; y:\n        continue\n    if x * x == y * y + z * z:\n        print(y, z, x)\n</code>\n</pre>\n", "senID": 3}, {"text": ["EDIT:Here I just give a way to use product instead of multiple for loop.", "And you can find more efficient method in above posts."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "product", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]