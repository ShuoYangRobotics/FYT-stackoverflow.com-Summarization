[[{"text": ["Sure, it's the easy way to make your code look good:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n char *someGlobalString = \"very long \"\n                         \"so broken \"\n                         \"onto multiple \"\n                         \"lines\";\n</code>\n</pre>\n", "senID": 1}, {"text": ["The best reason, though, is for weird printf formats, like type forcing:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n uint64_t num = 5;\nprintf(\"Here is a number:  %\"PRIX64\", what do you think of that?\", num);\n</code>\n</pre>\n", "senID": 3}, {"text": ["There are a bunch of those defined, and they can come in handy if you have type size requirements.", "Check them all out at this link.", "A few examples:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "at this link", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.opengroup.org/onlinepubs/9699919799/basedefs/inttypes.h.html"}]}, {"code": "<pre>\n<code>\n PRIo8 PRIoLEAST16 PRIoFAST32 PRIoMAX PRIoPTR\n</code>\n</pre>\n", "senID": 5}], [{"text": ["It's a great feature that allows you to combine preprocessor strings with your strings."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n // Here we define the correct printf modifier for time_t\n#ifdef TIME_T_LONG\n    #define TIME_T_MOD \"l\"\n#elif defined(TIME_T_LONG_LONG)\n    #define TIME_T_MOD \"ll\"\n#else\n    #define TIME_T_MOD \"\"\n#endif\n\n// And he we merge the modifier into the rest of our format string\nprintf(\"time is %\" TIME_T_MOD \"u\\n\", time(0));\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Cases where this can be useful:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Generating strings including components defined by the preprocessor (this is perhaps the largest use case in C, and it's one I see very, very frequently).", "tag": "none", "senID": 1}, {"text": "Splitting string constants over multiple lines", "tag": "none", "senID": 2}]}, {"text": ["To provide a more concrete example for the former:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n // in version.h\n#define MYPROG_NAME \"FOO\"\n#define MYPROG_VERSION \"0.1.2\"\n\n// in main.c\nputs(\"Welcome to \" MYPROG_NAME \" version \" MYPROG_VERSION \".\");\n</code>\n</pre>\n", "senID": 4}], [{"text": ["From the python lexical analysis reference, section 2.4.2:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://docs.python.org/reference/lexical_analysis.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/reference/lexical_analysis.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/lexical_analysis.html"}]}], [{"text": ["So that you can split long string literals across lines."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["And yes, I've seen it in production code."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I'm not sure about other programming languages, but for example C# doesn't allow you to do this (and I think this is a good thing).", "As far as I can tell, most of the examples that show why this is useful in C++ would still work if you could use some special operator for string concatenation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n string someGlobalString = \"very long \" +\n                          \"so broken \" +\n                          \"onto multiple \" +\n                          \"lines\";\n</code>\n</pre>\n", "senID": 1}, {"text": ["This may not be as comfortable, but it is certainly safer.", "In your motivating example, the code would be invalid unless you added either , to separate elements or + to concatenate strings..."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": ",", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "+", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I certainly have in both C and C++.", "Offhand, I don't see much relationship between its utility and how \"modern\" the language is."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["While people have taken the words out of my mouth about the practical uses of the feature, nobody has so far tried to defend the choice of syntax."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For all I know, the typo that can slip through as a result was probably just overlooked.", "After all, it seems robustness against typos wasn't at the front of Dennis's mind, as shown further by:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if (a = b);\n{\n    printf(\"%d\", a);\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["Furthermore, there's the possible view that it wasn't worth using up an extra symbol for concatenation of string literals - after all, there isn't much else that can be done with two of them, and having a symbol there might create temptation to try to use it for runtime string concatenation, which is above the level of C's built-in features."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Some modern, higher-level languages based on C syntax have discarded this notation presumably because it is typo-prone.", "But these languages have an operator for string concatenation, such as + (JS, C#), .", "(Perl, PHP), ~ (D, though this has also kept C's juxtaposition syntax), and constant folding (in compiled languages, anyway) means that there is no runtime performance overhead."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": ".", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "~", "childNum": 0, "tag": "code", "childList": []}]}]]