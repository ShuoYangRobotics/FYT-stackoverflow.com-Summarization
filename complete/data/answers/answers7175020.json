[[{"text": ["How slow is too slow?", "I just did an a in b test for a unique string at the end of a 170 MB string.", "It finished before my finger left the Enter key."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "a in b", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You can use one of these algorithms:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["Rabin\u2013Karp string search algorithm"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Rabin\u2013Karp string search algorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_string_search_algorithm"}]}, {"text": ["Knuth\u2013Morris\u2013Pratt algorithm (aka KMP) see an implementation here"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Knuth\u2013Morris\u2013Pratt algorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm"}, {"href": "http://code.activestate.com/recipes/117214-knuth-morris-pratt-string-matching/", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}]}, {"text": ["Although I believe KMP is more efficient, it's more complicated to implement.The first link includes some pseudo-code that should make it very easy to implement in python."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["you can look for alternatives here: http://en.wikipedia.org/wiki/String_searching_algorithm"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://en.wikipedia.org/wiki/String_searching_algorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/String_searching_algorithm"}]}], [{"text": ["I do not see how to make it more optimal on the comparison, to be honest.", "But you can use less memory and lose less time with I/O if you read the file line by line:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n has_small_string = False\nfor line in large_file:\n    if small_string in line:\n        has_small_string = True\n        break\nif has_small_string:\n   # ... Your stuff here ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is no revolutionary improvement, and can be even less useful if you really need the large string in the memory, but it may be helpful, so I am posting here :)"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "really", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "may", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["Is it really slow?", "You're talking about 30MB string; let's try it with even bigger string:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In [12]: string=\"agu82934u\"*50*1024*1024+\"string to be found\"\n\nIn [13]: len(string)\nOut[13]: 471859218\n\nIn [14]: %timeit \"string to be found\" in string\n1 loops, best of 3: 335 ms per loop\n\nIn [15]: %timeit \"string not to be found\" in string\n1 loops, best of 3: 200 ms per loop\n</code>\n</pre>\n", "senID": 1}, {"text": ["I wouldn't say that 335 ms is much time looking for substring in 450MB string."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you just want to check if that substring exists,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for line in open(\"file\"):\n    if substring in line:\n         print \"exists\"\n         sys.exit() # or break to do some other stuff\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Are you implying that only a complete line will match?", "(your EDIT: matching on a newline only example seems to)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Then I imagine"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for line in open('file').readlines():\n  if line==small_string:\n    return True\nreturn False\n</code>\n</pre>\n", "senID": 2}, {"text": ["IE,  using == is quicker than 'in' - perhaps.", "I wouldn't be surprised if the underlying implementation of in catches the case where the line to search and the string to search for are the same length and just attempts an == itself."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["woudl be better."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I would rely on fast implementation by someone else:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import subprocess\nfrom subprocess import STDOUT\nimport os\n\n...\nwith open(os.devnull, 'w') as devnull:\n    if subprocess.call('grep %s \"%s\"' % (smallstring, file), shell=True, stdout=devnull, stderr=STDOUT) == 0:\n        pass #do stuff\n</code>\n</pre>\n", "senID": 1}, {"text": ["Won't work on windows."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["edit: I'm worried taht grep returns 0 wheter it finds something or not.", "But I don't have any shell available to me now so I can't test it."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]