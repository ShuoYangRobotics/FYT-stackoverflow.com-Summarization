[[{"text": ["As other answers have suggested, you can provide your function with a copy of the list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As an alternative, your function could take a copy of the argument:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def burninate(b):\n    c = []\n    b = list(b)\n    for i in range(3):\n        c.append(b.pop())\n    return c\n</code>\n</pre>\n", "senID": 2}, {"text": ["Basically, you need to be clear in your mind (and in your documentation) whether your function will change its arguments.", "In my opinion, functions that return computed values should not change their arguments, and functions that change their arguments should not return anything.", "See python's [].sort(), [].extend(), {}.update(), etc.", "for examples.", "Obviously there are exceptions (like .pop())."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Also, depending on your particular case, you could rewrite the function to avoid using pop() or other functions that modify the argument.", "e.g."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def burninante(b):\n    return b[:-4:-1]   # return the last three elements in reverse order\n</code>\n</pre>\n", "senID": 5}], [{"text": ["You can call burninate() with a copy of the list like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "burninate()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["d = burninate(a[:])"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "d = burninate(a[:])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["or,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["d = burninate(list(a))"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "d = burninate(list(a))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The other alternative is to make a copy of the list in your method:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def burninate(b):\n    c=[]\n    b=b[:]\n    for i in range(3):\n        c.append(b.pop())\n    return c\n\n&gt;&gt;&gt; a = range(6)\n&gt;&gt;&gt; b = burninate(a)\n&gt;&gt;&gt; print a, b\n&gt;&gt;&gt; [0, 1, 2, 3, 4, 5] [5, 4, 3]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["A slightly more readable way to do the same thing is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d = burninate(list(a))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here, the list() constructor creates a new list based on a."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "list()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["A more general solution would be to import copy, and use copy.copy() on the parameter."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "import copy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "copy.copy()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Other versions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def burninate(b):\n    c = []\n    for i in range(1, 4):\n        c.append(b[-i])\n    return c\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n<code>\n def burninate(b):\n    c = b[-4:-1]\n    c.reverse()\n    return c\n</code>\n</pre>\n", "senID": 2}, {"text": ["And someday you will love list comprehensions:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def burninate(b):\n    return [b[-i] for i in range(1,4)]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You can use copy.deepcopy()"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n burninate = lambda x: x[:-4:-1]\n</code>\n</pre>\n", "senID": 0}]]