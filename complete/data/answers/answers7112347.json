[[{"text": ["Can you accept some degree of vote loss?", "If so, you can do a hybrid solution.", "Every modulo 100 (10, something), update the SQL database with the current memcache value.", "You can also have a periodic script scan and update if required."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "memcache", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["I just ran this, which is basically the sqlite example from the docs except inserting 5000 rows:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sqlite", "tag": "a", "pos": 0, "childList": [{"text": "sqlite", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/sqlite3.html"}, {"text": "sqlite", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import time\nimport sqlite3\n\nconn = sqlite3.connect('example')\n\nc = conn.cursor()\n\n# Create table\nc.execute('''create table stocks \n    (date text, trans text, symbol text, qty real, price real)''')\n\nprint time.time()\n\nfor i in xrange(5000):\n\n    # Insert a row of data\n    c.execute(\"\"\"insert into stocks\n              values ('2006-01-05','BUY','RHAT',100,35.14)\"\"\")\n\n\n# We can also close the cursor if we are done with it\n# Save (commit) the changes\nconn.commit()\nc.close()\n\nprint time.time()\n</code>\n</pre>\n", "senID": 1}, {"text": ["in four tenths of a second on my laptop."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "four tenths of a second", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The vast majority of that time is spent in the database commit.", "So as long as you don't commit to the database too often (once every couple of seconds or less), SQLite can easily handle a load of 5000 votes per second."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "5000 votes per second", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["4000 votes per minute won't phase it at all, so long as you're not committing after every vote."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You may have something drastically misconfigured in your MySQL server.", "MySQL should easily be able to handle 4000 queries per minute.", "There are benchmarks of MySQL handling over 25k INSERTs per second."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can have a look at CUBRID.", "I haven't tried it, but it seems promising, they advertise almost 100% MySQL compatibility, plus some nice stuff like SELECT INCR(field)"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "CUBRID", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cubrid.org/"}, {"text": "SELECT INCR(field)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Mongodb can work well.Since it can be faster or Google App Engine was designed to scale."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Mongodb", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Google App Engine", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If you like memcached but don't like the fact that it doesn't persist data then you should consider using Membase.", "Membase is basically memcached with sqlite as the persistence layer.", "It is very easy to set up and supports the memcached protocol so if you already have memcached set up you can use Membase as a drop in replacement."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]