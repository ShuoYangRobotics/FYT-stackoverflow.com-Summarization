[[{"text": ["For 100000 elements, the Python code took 6.9 seconds while the C++ originally took above 37 seconds."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I did some basic optimizations on your code and managed to get the C++ code above 100 times faster than the Python implementation.", "It now does 100000 elements in 0.06 seconds.", "That is 617 faster than the original C++ code. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The most important thing is to compile in Release mode, with all optimizations.", "This code is literally orders of magnitude slower in Debug mode."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Next, I will explain the optimizations I did."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 7, "lis": [{"text": "Moved all vector declarations outside of the loop; replaced them by a clear() operation, which is much faster than calling the constructor.", "tag": "none", "senID": 4}, {"text": "Replaced the call to pow(value, 2) by a multiplication : value * value.", "tag": "none", "senID": 5}, {"text": "Instead of having a squares vector and calling sum on it, I sum the values in-place using just an integer.", "tag": "none", "senID": 6}, {"text": "Avoided all string operations, which are very slow compared to integer operations. For instance, it is possible to compute the squares of each digit by repeatedly dividing by 10 and fetching the modulus 10 of the resulting value, instead of converting the value to a string and then each character back to int.", "tag": "none", "senID": 7}, {"text": "Avoided all vector copies, first by replacing passing by value with passing by reference, and finally by eliminating the helper functions completely.", "tag": "none", "senID": 8}, {"text": "Eliminated a few temporary variables.", "tag": "none", "senID": 9}, {"text": "And probably many small details I forgot. Compare your code and mine side-by-side to see exactly what I did.", "tag": "none", "senID": 10}]}, {"text": ["It may be possible to optimize the code even more by using pre-allocated arrays instead of vectors, but this would be a bit more work and I'll leave it as an exercise to the reader.", ":P"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Here's the optimized code :"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;ctime&gt;\n#include &lt;algorithm&gt;\n#include &lt;windows.h&gt;\n\nusing namespace std;\n\nvoid calcMain(int upperBound, vector&lt;int&gt;&amp; known);\n\nint main()\n{\n    while(true)\n    {\n        vector&lt;int&gt; results;\n        int upperBound;\n        cout &lt;&lt; \"Pick an upper bound: \";\n        cin &gt;&gt; upperBound;\n        long start, end;\n        start = GetTickCount();\n        calcMain(upperBound, results);\n        end = GetTickCount();\n        for (size_t i = 0; i &lt; results.size(); ++i) {\n            cout &lt;&lt; results[i] &lt;&lt; \", \";\n        }\n        cout &lt;&lt; endl;\n        double seconds = (double)(end-start) / 1000.0;\n        cout &lt;&lt; seconds &lt;&lt; \" seconds.\" &lt;&lt; endl &lt;&lt; endl;\n    }\n    return 0;\n}\n\nvoid calcMain(int upperBound, vector&lt;int&gt;&amp; known)\n{\n    vector&lt;int&gt; history;\n    for(int i = 0; i &lt;= upperBound; i++)\n    {\n        int current = i;\n        history.clear();\n        while(true)\n        {\n                int temp = current;\n                int sum = 0;\n                while (temp &gt; 0) {\n                    sum += (temp % 10) * (temp % 10);\n                    temp /= 10;\n                }\n                current = sum;\n                if(find(history.begin(), history.end(), current) != history.end())\n                {\n                        if(current == 1)\n                        {\n                                known.push_back(i);\n                        }\n                        break;\n                }\n                history.push_back(current);\n        }\n    }\n}\n</code>\n</pre>\n", "senID": 13}], [{"text": ["There's a new, radically faster version asa separate answer, so this answer is deprecated."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "There's a new, radically faster version asa separate answer, so this answer is deprecated.", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "a separate answer", "tag": "a"}]}, {"href": "http://stackoverflow.com/questions/1269795/unusual-speed-difference-between-python-and-c/1275074#1275074", "text": "a separate answer", "childNum": 0, "tag": "a", "childList": []}]}, {"tag": "hr", "senID": 1}, {"text": ["I rewrote your algorithm making it cache whenever it finds the number to be happy or unhappy.", "I also tried to make it as pythonic as I could, for example by creating separate functions digits() and happy().", "Sorry for using Python 3, but I get to show off a couple a useful things from it as well."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "rewrote", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "pythonic", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "digits()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "happy()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Python 3", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["This version is much faster, though since I'm in the middle of doing some other work and my MacBook is busy, I didn't do exact measures.", "It runs at 1.7s which is 10 times faster than your original program that takes 18s (well, my MacBook is quite old and slow :) )"], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "much faster", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "though since I'm in the middle of doing some other work and my MacBook is busy, I didn't do exact measures.", "childNum": 0, "tag": "s", "pos": -1, "childList": []}, {"text": "1.7s", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "10 times", "childNum": 0, "tag": "strong", "childList": []}, {"text": "18s", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["(FYI, I've been rewriting this thing for a while and this is like the 5th version :) )"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python3\n\nfrom timeit import Timer\nfrom itertools import count\n\nprint_numbers = False\nupperBound = 10**5  # Default value, can be overidden by user.\n\n\ndef digits(x:'nonnegative number') -&gt; \"yields number's digits\":\n    if not (x &gt;= 0): raise ValueError('Number should be nonnegative')\n    while x:\n        yield x % 10\n        x //= 10\n\n\ndef happy(number, known = {1}, happies = {1}) -&gt; 'True/None':\n    '''This function tells if the number is happy or not, caching results.\n\n    It uses two static variables, parameters known and happies; the\n    first one contains known happy and unhappy numbers; the second \n    contains only happy ones.\n\n    If you want, you can pass your own known and happies arguments. If\n    you do, you should keep the assumption commented out on the 1 line.\n\n    '''\n\n#        assert 1 in known and happies &lt;= known  # &lt;= is expensive\n\n    if number in known:\n        return number in happies\n\n    history = set()\n    while True:\n        history.add(number)\n        number = sum(x**2 for x in digits(number))\n        if number in known or number in history:\n            break\n\n    known.update(history)\n    if number in happies:\n        happies.update(history)\n        return True\n\n\ndef calcMain():\n    happies = {x for x in range(upperBound) if happy(x) }\n    if print_numbers:\n        print(happies)\n\n\nif __name__ == '__main__':\n    upperBound = eval(\n            input(\"Pick an upper bound [default {0}]: \"\n                    .format(upperBound)).strip()\n            or repr(upperBound))\n    result = Timer(calcMain).timeit(1)\n    print ('This computation took {0} seconds'.format(result))\n</code>\n</pre>\n", "senID": 5}], [{"text": ["It looks like you're passing vectors by value to other functions.", "This will be a significant slowdown because the program will actually make a full copy of your vector before it passes it to your function.", "To get around this, pass a constant reference to the vector instead of a copy.", "So instead of: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n int sum(vector&lt;int&gt; given)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n int sum(const vector&lt;int&gt;& given)\n</code>\n</pre>\n", "senID": 3}, {"text": ["When you do this, you'll no longer be able to use the vector::iterator because it is not constant.", "You'll need to replace it with vector::const_iterator."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You can also pass in non-constant references, but in this case, you don't need to modify the parameter at all."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I can see that you have quite a few heap allocations that are unnecessary"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n while(!next)\n    \t{\n    \t\tchar* buffer = new char[10];\n</code>\n</pre>\n", "senID": 2}, {"text": ["This doesn't look very optimized.", "So, you probably want to have the array pre-allocated and using it inside your loop.", "This is a basic optimizing technique which is easy to spot and to do.", "It might become into a mess too, so be careful with that."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You are also using the atoi() function, which I don't really know if it is really optimized.", "Maybe doing a modulus 10 and getting the digit might be better (you have to measure thou, I didn't test this)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The fact that you have a linear search (inVector) might be bad.", "Replacing the vector data structure with a std::set might speed things up.", "A hash_set could do the trick too."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["But I think that the worst problem is the string and this allocation of stuff on the heap inside that loop.", "That doesn't look good.", "I would try at those places first."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["This is my second answer; which caches things like sum of squares for values &lt;= 10**6:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "caches things like sum of squares", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "&lt;= 10**6", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n happy_list[sq_list[x%happy_base] + sq_list[x//happy_base]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["That is, "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "the number is split into 3 digits + 3 digits", "tag": "none", "senID": 3}, {"text": "the ", "tag": "none", "senID": 4}, {"text": "these two results are added", "tag": "none", "senID": 5}, {"text": "the precomputed table is consulted to get the happiness of number:", "tag": "none", "senID": 6}]}, {"text": ["I don't think Python version can be made much faster than that (ok, if you throw away fallback to old version, that is try: overhead, it's 10% faster). "], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "try:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I think this is an excellent question which shows that, indeed, "], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "excellent question", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 4, "lis": [{"text": "things that have to be fast should be written in C", "tag": "none", "senID": 9}, {"text": "however, usually you don't need things to be fast (even if you needed the program to run for a day, it would be less then the combined time of programmers optimizing it)", "tag": "none", "senID": 10}, {"text": "it's easier and faster to write programs in Python", "tag": "none", "senID": 11}, {"text": "but for some problems, especially computational ones, a C++ solution, like the ones above, are actually more readable and more beautiful than an attempt to optimize Python program.", "tag": "none", "senID": 12}]}, {"tag": "hr", "senID": 13}, {"text": ["Ok, here it goes (2nd version now...):"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python3\n'''Provides slower and faster versions of a function to compute happy numbers.\n\nslow_happy() implements the algorithm as in the definition of happy\nnumbers (but also caches the results).\n\nhappy() uses the precomputed lists of sums of squares and happy numbers\nto return result in just 3 list lookups and 3 arithmetic operations for\nnumbers less than 10**6; it falls back to slow_happy() for big numbers.\n\nUtilities: digits() generator, my_timeit() context manager.\n\n'''\n\n\nfrom time import time  # For my_timeit.\nfrom random import randint # For example with random number.\n\nupperBound = 10**5  # Default value, can be overridden by user.\n\n\nclass my_timeit:\n    '''Very simple timing context manager.'''\n\n    def __init__(self, message):\n        self.message = message\n        self.start = time()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *data):\n        print(self.message.format(time() - self.start))\n\n\ndef digits(x:'nonnegative number') -&gt; \"yields number's digits\":\n    if not (x &gt;= 0): raise ValueError('Number should be nonnegative')\n    while x:\n        yield x % 10\n        x //= 10\n\n\ndef slow_happy(number, known = {1}, happies = {1}) -&gt; 'True/None':\n    '''Tell if the number is happy or not, caching results.\n\n    It uses two static variables, parameters known and happies; the\n    first one contains known happy and unhappy numbers; the second \n    contains only happy ones.\n\n    If you want, you can pass your own known and happies arguments. If\n    you do, you should keep the assumption commented out on the 1 line.\n\n    '''\n    # This is commented out because &lt;= is expensive.\n    # assert {1} &lt;= happies &lt;= known \n\n    if number in known:\n        return number in happies\n\n    history = set()\n    while True:\n        history.add(number)\n        number = sum(x**2 for x in digits(number))\n        if number in known or number in history:\n            break\n\n    known.update(history)\n    if number in happies:\n        happies.update(history)\n        return True\n\n\n# This will define new happy() to be much faster ------------------------.\n\nwith my_timeit('Preparation time was {0} seconds.\\n'):\n\n    LogAbsoluteUpperBound = 6 # The maximum possible number is 10**this.\n    happy_list = [slow_happy(x)\n                  for x in range(81*LogAbsoluteUpperBound + 1)]\n    happy_base = 10**((LogAbsoluteUpperBound + 1)//2)\n    sq_list = [sum(d**2 for d in digits(x))\n               for x in range(happy_base + 1)]\n\n    def happy(x):\n        '''Tell if the number is happy, optimized for smaller numbers.\n\n        This function works fast for numbers &lt;= 10**LogAbsoluteUpperBound.\n\n        '''\n        try:\n            return happy_list[sq_list[x%happy_base] + sq_list[x//happy_base]]\n        except IndexError:\n            return slow_happy(x)\n\n# End of happy()'s redefinition -----------------------------------------.\n\n\ndef calcMain(print_numbers, upper_bound):\n    happies = [x for x in range(upper_bound + 1) if happy(x)]\n    if print_numbers:\n        print(happies)\n\n\nif __name__ == '__main__':\n    while True:\n\n        upperBound = eval(input(\n            \"Pick an upper bound [{0} default, 0 ends, negative number prints]: \"\n            .format(upperBound)).strip() or repr(upperBound))\n        if not upperBound:\n            break\n\n        with my_timeit('This computation took {0} seconds.'):\n            calcMain(upperBound &lt; 0, abs(upperBound))\n\n        single = 0\n        while not happy(single):\n            single = randint(1, 10**12)\n        print('FYI, {0} is {1}.\\n'.format(single,\n                    'happy' if happy(single) else 'unhappy')) \n\n    print('Nice to see you, goodbye!')\n</code>\n</pre>\n", "senID": 15}], [{"text": ["Well, I also gave it a once-over.", "I didn't test or even compile, though."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["General rules for numerical programs:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["Never process numbers as text.", "That's what makes lesser languages than Python slow, so if you do it in C, the program will be slower than Python."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Don't use data structures if you can avoid them.", "You were building an array just to add the numbers up.", "Better keep a running total."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Keep a copy of the STL reference open so you can use it rather than writing your own functions."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]}, {"tag": "hr", "senID": 5}, {"code": "<pre>\n<code>\n void calcMain(int upperBound)\n{\n    vector&lt;int&gt; known;\n    for(int i = 0; i &lt;= upperBound; i++)\n    {\n    \tint current = i;\n    \tvector&lt;int&gt; history;\n    \tdo\n    \t{\n    \t\tsquaresum = 0\n    \t\tfor ( ; current; current /= 10 )\n    \t\t{\n    \t\t\tint digit = current % 10;\n    \t\t\tsquaresum += digit * digit;\n    \t\t}\n    \t\tcurrent = squaresum;\n    \t\thistory.push_back(current);\n    \t} while ( ! count(history.begin(), history.end() - 1, current) );\n\n    \tif(current == 1)\n    \t{\n    \t\tknown.push_back(i);\n    \t\t//cout &lt;&lt; i &lt;&lt; \"\\t\";\n    \t}\n\n    }\n    //cout &lt;&lt; \"\\n\\n\";\n}\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Just to get a little more closure on this issue by seeing how fast I could truely find these numbers, I wrote a multithreaded C++ implementation of Dr_Asik's algorithm.", "There are two things that are important to realize about the fact that this implementation is multithreaded."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The code for this implementation (all credit for the algorithm goes to Dr_Asik) is here.", "Also, I wrote some speed tests with a double check for each test to help back up those 3 points."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://dawnofdigital.net/script/happy%5Fmultithreaded.cpp.txt"}]}, {"text": ["Calculation of the first 100,000,000 happy numbers:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Calculation of the first 100,000,000 happy numbers:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Original    - 39.061 / 39.000 (Dr_Asik's original implementation)\n1 Thread    - 39.000 / 39.079\n2 Threads   - 19.750 / 19.890\n10 Threads  - 11.872 / 11.888\n30 Threads  - 10.764 / 10.827\n50 Threads  - 10.624 / 10.561 &lt;--\n100 Threads - 11.060 / 11.216\n500 Threads - 13.385 / 12.527"], "childNum": 8, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["From these results it looks like our happy medium is about 50 threads, plus or minus ten or so."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I am not an expert at C++ optimization, but I believe the speed difference may be due to the fact that Python lists have preallocated more space at the beginning while your C++ vectors must reallocate and possibly copy every time it grows."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As for GMan's comment about find, I believe that the Python \"in\" operator is also a linear search and is the same speed."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Also I just noticed that you rolled your own pow function.", "There is no need to do that and the stdlib is likely faster."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Here is another way that relies on memorising all the numbers already explored.", "I obtain a factor x4-5, which is oddly stable against DrAsik's code for 1000 and 1000000, I expected the cache to be more efficient the more numbers we were exploring.", "Otherwise, the same kind of classic optimizations have been applied.", "BTW, if the compiler accepts NRVO (/RNVO ?", "I never remember the exact term) or rvalue references, we wouldn't need to pass the vector as an out parameter."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "(/RNVO ? I never remember the exact term)", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "out", "childNum": 0, "tag": "em", "pos": 4, "childList": []}]}, {"text": ["NB: micro-optimizations are still possible IMHO, and moreover the caching is naive as it allocates much more memory than really needed."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n enum Status {\n    never_seen,\n    being_explored,\n    happy,\n    unhappy\n};\n\nchar const* toString[] = { \"never_seen\", \"being_explored\", \"happy\", \"unhappy\" };\n\n\ninline size_t sum_squares(size_t i) {\n    size_t s = 0;\n    while (i) {\n        const size_t digit = i%10;\n        s += digit * digit;\n        i /= 10;\n    }\n    return s ;\n}\n\nstruct Cache {\n    Cache(size_t dim) : m_cache(dim, never_seen) {}\n    void set(size_t n, Status status) {\n        if (m_cache.size() &lt;= n) {\n            m_cache.resize(n+1, never_seen);\n        }\n        m_cache[n] = status;\n        // std::cout &lt;&lt; \"(c[\" &lt;&lt; n &lt;&lt; \"]&lt;-\"&lt;&lt;toString[status] &lt;&lt; \")\";\n    }\n    Status operator[](size_t n) const {\n        if (m_cache.size() &lt;= n) {\n            return never_seen;\n        } else {\n            return m_cache[n];\n        }\n    }\n\nprivate:\n    std::vector&lt;Status&gt; m_cache;\n};\n\nvoid search_happy_lh(size_t upper_bound, std::vector&lt;size_t&gt; &amp; happy_numbers)\n{\n    happy_numbers.clear();\n    happy_numbers.reserve(upper_bound); // it doesn't improve much the performances\n\n    Cache cache(upper_bound+1);\n    std::vector&lt;size_t&gt; current_stack;\n\n    cache.set(1,happy);\n    happy_numbers.push_back(1);\n    for (size_t i = 2; i&lt;=upper_bound ; ++i) {\n        // std::cout &lt;&lt; \"\\r\" &lt;&lt; i &lt;&lt; std::flush;\n        current_stack.clear();\n        size_t s= i;\n        while ( s != 1 &amp;&amp; cache[s]==never_seen)\n        {\n            current_stack.push_back(s);\n            cache.set(s, being_explored);\n            s = sum_squares(s);\n            // std::cout &lt;&lt; \" - \" &lt;&lt; s &lt;&lt; std::flush;\n        }\n        const Status update_with = (cache[s]==being_explored ||cache[s]==unhappy) ? unhappy : happy;\n        // std::cout &lt;&lt; \" =&gt; \" &lt;&lt; s &lt;&lt; \":\" &lt;&lt; toString[update_with] &lt;&lt; std::endl;\n        for (size_t j=0; j!=current_stack.size(); ++j) {\n            cache.set(current_stack[j], update_with);\n        }\n        if (cache[i] == happy) {\n            happy_numbers.push_back(i);\n        }\n    }\n}\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Other optimizations: by using arrays and direct access using the loop index rather than searching in a vector, and by caching prior sums, the following code (inspired by Dr Asik's answer but probably not optimized at all) runs 2445 times faster than the original C++ code, about 400 times faster than the Python code."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "Other optimizations", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "2445", "childNum": 1, "tag": "strong", "childList": [{"text": "2445", "tag": "em"}]}, {"text": "2445", "childNum": 0, "tag": "em", "childList": []}, {"text": "400", "childNum": 1, "tag": "strong", "childList": [{"text": "400", "tag": "em"}]}, {"text": "400", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n #include &lt;iostream&gt;\n#include &lt;windows.h&gt;\n#include &lt;vector&gt;\n\nvoid calcMain(int upperBound, std::vector&lt;int&gt;&amp; known)\n{\n    int tempDigitCounter = upperBound;\n    int numDigits = 0;\n    while (tempDigitCounter &gt; 0)\n    {\n    \tnumDigits++;\n    \ttempDigitCounter /= 10;\n    }\n    int maxSlots = numDigits * 9 * 9;\n    int* history = new int[maxSlots + 1];\n\n    int* cache = new int[upperBound+1];\n    for (int jj = 0; jj &lt;= upperBound; jj++)\n    {\n    \tcache[jj] = 0;\n    }\n\n    int current, sum, temp;\n    for(int i = 0; i &lt;= upperBound; i++)\n    {\n        current = i;\n    \twhile(true)\n        {\n    \t\tsum = 0;\n    \t\ttemp = current;\n\n    \t\tbool inRange = temp &lt;= upperBound;\n    \t\tif (inRange)\n    \t\t{\n    \t\t\tint cached = cache[temp];\n    \t\t\tif (cached)\n    \t\t\t{\n    \t\t\t\tsum = cached;\n    \t\t\t}\n    \t\t}\n\n    \t\tif (sum == 0)\n    \t\t{\n    \t\t\twhile (temp &gt; 0)\n    \t\t\t{\n    \t\t\t\tint tempMod = temp % 10;\n    \t\t\t\tsum += tempMod * tempMod;\n    \t\t\t\ttemp /= 10;\n    \t\t\t}\n    \t\t\tif (inRange)\n    \t\t\t{\n    \t\t\t\tcache[current] = sum;\n    \t\t\t}\n    \t\t}\n    \t\tcurrent = sum;\n        \tif(history[current] == i)\n        \t{\n        \t\tif(current == 1)\n        \t\t{\n    \t\t\t\tknown.push_back(i);\n        \t\t}\n        \t\tbreak;\n    \t\t}\n        \thistory[current] = i;\n        }\n    }\n}\n\nint main()\n{\n    while(true)\n    {\n        int upperBound;\n    \tstd::vector&lt;int&gt; known;\n    \tstd::cout &lt;&lt; \"Pick an upper bound: \";\n    \tstd::cin &gt;&gt; upperBound;\n    \tlong start, end;\n    \tstart = GetTickCount();\n        calcMain(upperBound, known);\n    \tend = GetTickCount();\n    \tfor (size_t i = 0; i &lt; known.size(); ++i) {\n    \t\tstd::cout &lt;&lt; known[i] &lt;&lt; \", \";\n        }   \t\t\t\n    \tdouble seconds = (double)(end-start) / 1000.0;\n    \tstd::cout &lt;&lt; std::endl &lt;&lt; seconds &lt;&lt; \" seconds.\" &lt;&lt; std::endl &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's some food for thought: If given the choice of running a 1979 algorithm for finding prime numbers in a 2009 computer or a 2009 algorithm on a 1979 computer, which would you choose?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The new algorithm on ancient hardware would be the better choice by a huge margin.", "Have a look at your \"helper\" functions."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["There are quite a few optimizations possible:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(1) Use const references "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n bool inVector(int inQuestion, const vector&lt;int&gt;&amp; known)\n{\n    for(vector&lt;int&gt;::const_iterator it = known.begin(); it != known.end(); ++it)\n    \tif(*it == inQuestion)\n    \t\treturn true;\n    return false;\n}\n\nint sum(const vector&lt;int&gt;&amp; given)\n{\n    int sum = 0;\n    for(vector&lt;int&gt;::const_iterator it = given.begin(); it != given.end(); ++it)\n    \tsum += *it;\n    return sum;\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["(2) Use counting down loops"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n int pow(int given, int power)\n{\n    int current = 1;\n    while(power--)\n    \tcurrent *= given;\n    return current;\n}\n</code>\n</pre>\n", "senID": 4}, {"text": ["Or, as others have said, use the standard library code."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["(3) Don't allocate buffers where not required"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n vector&lt;int&gt; squares;\n\t\tfor (int temp = current; temp != 0; temp /= 10)\n\t\t{\n\t\t\tsquares.push_back(pow(temp % 10, 2));\n\t\t}\n</code>\n</pre>\n", "senID": 7}], [{"text": ["With similar optimizations as PotatoSwatter I got time for 10000 numbers down from 1.063 seconds to 0.062 seconds (except I replaced itoa with standard sprintf in the original). "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["With all the memory optimizations (don't pass containers by value - in C++ you have to explicitly decide whether you want a copy or a reference; move operations that allocate memory out of inner loops; if you already have the number in a char buffer, what's the point of copying it to std::string etc) I got it down to 0.532. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The rest of the time came from using %10 to access digits, rather than converting numbers to string."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I suppose there might be another algorithmic level optimization (numbers that you have encountered while finding a happy number are themselves also happy numbers?", ") but I don't know how much that gains (there is not that many happy numbers in the first place) and this optimization is not in the Python version either."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["By the way, by not using string conversion and a list to square digits, I got the Python version from 0.825 seconds down to 0.33 too."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Here's a C# version:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace CSharp\n{\n  class Program\n  {\n    static void Main (string [] args)\n    {\n      while (true)\n      {\n        Console.Write (\"Pick an upper bound: \");\n\n        String\n          input = Console.ReadLine ();\n\n        uint\n          upper_bound;\n\n        if (uint.TryParse (input, out upper_bound))\n        {\n          DateTime\n            start = DateTime.Now;\n\n          CalcHappyNumbers (upper_bound);\n\n          DateTime\n            end = DateTime.Now;\n\n          TimeSpan\n            span = end - start;\n\n          Console.WriteLine (\"Time taken = \" + span.TotalSeconds + \" seconds.\");\n        }\n        else\n        {\n          Console.WriteLine (\"Error in input, unable to parse '\" + input + \"'.\");\n        }\n      }\n    }\n\n    enum State\n    {\n      Happy,\n      Sad,\n      Unknown\n    }\n\n    static void CalcHappyNumbers (uint upper_bound)\n    {\n      SortedDictionary&lt;uint, State&gt;\n        happy = new SortedDictionary&lt;uint, State&gt; ();\n\n      SortedDictionary&lt;uint, bool&gt;\n        happy_numbers = new SortedDictionary&lt;uint, bool&gt; ();\n\n      happy [1] = State.Happy;\n      happy_numbers [1] = true;\n\n      for (uint current = 2 ; current &lt; upper_bound ; ++current)\n      {\n        FindState (ref happy, ref happy_numbers, current);\n      }\n\n      //foreach (KeyValuePair&lt;uint, bool&gt; pair in happy_numbers)\n      //{\n      //  Console.Write (pair.Key.ToString () + \", \");\n      //}\n\n      //Console.WriteLine (\"\");\n    }\n\n    static State FindState (ref SortedDictionary&lt;uint, State&gt; happy, ref SortedDictionary&lt;uint,bool&gt; happy_numbers, uint value)\n    {\n      State\n        current_state;\n\n      if (happy.TryGetValue (value, out current_state))\n      {\n        if (current_state == State.Unknown)\n        {\n          happy [value] = State.Sad;\n        }\n      }\n      else\n      {\n        happy [value] = current_state = State.Unknown;\n\n        uint\n          new_value = 0;\n\n        for (uint i = value ; i != 0 ; i /= 10)\n        {\n          uint\n            lsd = i % 10;\n\n          new_value += lsd * lsd;\n        }\n\n        if (new_value == 1)\n        {\n          current_state = State.Happy;\n        }\n        else\n        {\n          current_state = FindState (ref happy, ref happy_numbers, new_value);\n        }\n\n        if (current_state == State.Happy)\n        {\n          happy_numbers [value] = true;\n        }\n\n        happy [value] = current_state;\n      }\n\n      return current_state;\n    }\n  }\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["I compared it against Dr_Asik's C++ code.", "For an upper bound of 100000 the C++ version ran in about 2.9 seconds and the C# version in 0.35 seconds.", "Both were compiled using Dev Studio 2005 using default release build options and both were executed from a command prompt."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Skizz"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nimport timeit\n\nupperBound = 0\n\ndef calcMain():\n    known = set()\n    for i in xrange(0,upperBound+1):\n        next = False\n        current = i\n        history = set()\n        while not next:\n            squaresum=0\n            while current &gt; 0:\n                current, digit = divmod(current, 10)\n                squaresum += digit * digit\n            current = squaresum\n            if current in history:\n                next = True\n                if current == 1:\n                    known.add(i)\n            history.add(current)\n\nwhile True:\n    upperBound = input(\"Pick an upper bound: \")\n    result = timeit.Timer(calcMain).timeit(1)\n    print result, \"seconds.\\n\"\n</code>\n</pre>\n", "senID": 0}, {"text": ["I made a couple of minor changes to your original python code example that make a better than 16x improvement to the performance of the code.", "The changes I made took the 100,000 case from about 9.64 seconds to about 3.38 seconds."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The major change was to make the mod 10 and accumulator changes to run in a while loop.", "I made a couple of other changes that improved execution time in only fractions of hundredths of seconds.", "The first minor change was changing the main for loop from a range list comprehension to an xrange iterator.", "The second minor change was substituting the set class for the list class for both the known and history variables.", "I also experimented with iterator comprehensions and precalculating the squares but they both had negative effects on the efficiency.", "I seem to be running a slower version of python or on a slower processor than some of the other contributers.", "I would be interest in the results of someone else's timing comparison of my python code against one of the optimized C++ versions of the same algorithm.", "I also tried using the python -O and -OO optimizations but they had the reverse of the intended effect."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Why is everyone using a vector in the c++ version?", "Lookup time is O(N)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Even though it's not as efficient as the python set, use std::set.", "Lookup time is O(log(N))."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]