[[{"text": ["Basically naive multiplication is O(n) with a very low constant factor.", "Taking the power is O(log n) with a higher constant factor (There are special cases that need to be tested... fractional exponents, negative exponents, etc) .", "Edit: just to be clear, that's O(n) where n is the exponent."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Of course the naive approach will be faster for small n, you're only really implementing a small subset of exponential math so your constant factor is negligible. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Adding a check is an expense, too.", "Do you always want that check there?", "A compiled language could make the check for a constant exponent to see if it's a relatively small integer because there's no run-time cost, just a compile-time cost.", "An interpreted language might not make that check."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's up to the particular implementation unless that kind of detail is specified by the language."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Python doesn't know what distribution of exponents you're going to feed it.", "If it's going to be 99% non-integer values, do you want the code to check for an integer every time, making runtime even slower?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Doing this in the exponent check will slow down the cases where it isn't a simple power of two very slightly, so isn't necessarily a win.", "However, in cases where the exponent is known in advance( eg.", "literal 2 is used), the bytecode generated could be optimised with a simple peephole optimisation.", "Presumably this simply hasn't been considered worth doing (it's a fairly specific case).  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's a quick proof of concept that does such an optimisation (usable as a decorator).", "Note: you'll need the byteplay module to run it."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "byteplay", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.google.com/p/byteplay/"}]}, {"code": "<pre>\n<code>\n import byteplay, timeit\n\ndef optimise(func):\n    c = byteplay.Code.from_code(func.func_code)\n    prev=None\n    for i, (op, arg) in enumerate(c.code):\n        if op == byteplay.BINARY_POWER:\n            if c.code[i-1] == (byteplay.LOAD_CONST, 2):\n                c.code[i-1] = (byteplay.DUP_TOP, None)\n                c.code[i] = (byteplay.BINARY_MULTIPLY, None)\n    func.func_code = c.to_code()\n    return func\n\ndef square(x):\n    return x**2\n\nprint \"Unoptimised :\", timeit.Timer('square(10)','from __main__ import square').timeit(10000000)\nsquare = optimise(square)\nprint \"Optimised   :\", timeit.Timer('square(10)','from __main__ import square').timeit(10000000)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Which gives the timings:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n Unoptimised : 6.42024898529\nOptimised   : 4.52667593956\n</code>\n</pre>\n", "senID": 4}, {"text": ["[Edit] \nActually, thinking about it a bit more, there's a very good reason why this optimisaton isn't done.", "There's no guarantee that someone won't create a user defined class that overrides the __mul__ and __pow__ methods and do something different for each.", "The only way to do it safely is if you can guarantee that the object on the top of the stack is one that has the same result \"x**2\" and \"x*x\", but working that out is much harder.", "Eg.", "in my example it's impossible, as any object could be passed to the square function."], "childNum": 5, "tag": "p", "senID": 5, "childList": [{"text": "[Edit]", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "__mul__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__pow__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "**2", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "x*x", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["I'd suspect that nobody was expecting this to be all that important.", "Typically, if you want to do serious calculations, you do them in Fortran or C or C++ or something like that (and perhaps call them from Python)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Treating everything as exp(n * log(x)) works well in cases where n isn't integral or is pretty large, but is relatively inefficient for small integers.", "Checking to see if n is a small enough integer does take time, and adds complication."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Whether the check is worth it depends on the expected exponents, how important it is to get best performance here, and the cost of the extra complexity.", "Apparently, Guido and the rest of the Python gang decided the check wasn't worth doing."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you like, you could write your own repeated-multiplication function."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["It might do ;) Some optimizing compilers/interpreters do that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["how about x*x*x*x*x?", "is it still faster than x**5?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["as int exponents gets larger, taking powers might be faster than multiplication.", "but the number where actual crossover occurs depends on various conditions, so in my opinion, that's why the optimization was not done(or couldn't be done) in language/library level.", "But users can still optimize for some special cases :)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Use numpy, which optimizes all this stuff in C."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org/"}]}, {"text": ["Doesn't make a whole ton of sense for interpreted languages to spend much time doing low-level optimizations like this.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Python handles this \"problem\" by providing a nice C API, allowing speed-critical operations to be outsourced to libraries."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]