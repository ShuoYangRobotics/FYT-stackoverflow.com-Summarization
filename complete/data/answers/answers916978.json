[[{"text": ["You can write a little function for that"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def maplist(func, values):\n    return [map(func, values[i:]) for i in xrange(len(values))]\n\n&gt;&gt;&gt; maplist(lambda a: a* 2, [1,2,3])\n[[2, 4, 6], [4, 6], [6]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["[Edit]"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[Edit]", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["if you want to apply the function on the sublists you can change the function to this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def maplist(func, values):\n    return [func(values[i:]) for i in xrange(len(values))]\n\n&gt;&gt;&gt; maplist(lambda l: list(reversed(l)), [1,2,3])\n[[3, 2, 1], [3, 2], [3]]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["As @Cybis and others mentioned, you can't keep the O(N) complexity with Python lists; you'll have to create a linked list.", "At the risk of proving Greenspun's 10th rule, here is such a solution:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Greenspun's 10th rule", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Greenspun%27s%5FTenth%5FRule"}]}, {"code": "<pre>\n<code>\n class cons(tuple):\n    __slots__=()\n\n    def __new__(cls, car, cdr):\n        return tuple.__new__(cls, (car,cdr))\n\n    @classmethod\n    def from_seq(class_, l):\n        result = None\n        for el in reversed(l):\n            result = cons(el, result)\n        return result\n\n    @property\n    def car(self): return self._getitem(0)\n\n    @property\n    def cdr(self): return self._getitem(1)\n\n    def _getitem(self, i):\n        return tuple.__getitem__(self, i)\n\n    def __repr__(self):\n        return '(%s %r)' % (self.car, self.cdr)\n\n    def __iter__(self):\n        v = self\n        while v is not None:\n            yield v.car\n            v = v.cdr\n\n    def __len__(self):\n        return sum(1 for x in self)\n\n    def __getitem__(self, i):\n        v = self\n        while i &gt; 0:\n            v = v.cdr\n            i -= 1\n        return v.car\n\ndef maplist(func, values):\n    result = [ ]\n    while values is not None:\n        result.append(func(values))\n        values = values.cdr\n    return result\n</code>\n</pre>\n", "senID": 1}, {"text": ["Testing yields:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l = cons.from_seq([1,2,3,4])\n&gt;&gt;&gt; print l\n(1 (2 (3 (4 None))))\n&gt;&gt;&gt; print list(l)\n[1, 2, 3, 4]\n&gt;&gt;&gt; print maplistr(lambda l: list(reversed(l)), cons.from_seq([1,2,3]))\n[[3, 2, 1], [3, 2], [3]]\n</code>\n</pre>\n", "senID": 3}, {"text": ["EDIT: Here is a generator-based solution that basically solves the same problem without the use of linked lists:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\ndef mapiter(func, iter_):\n    while True:\n        iter_, iter2 = itertools.tee(iter_)\n        iter_.next()\n        yield func(iter2)\n</code>\n</pre>\n", "senID": 5}, {"text": ["Testing yields:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print list(mapiter(lambda l: list(reversed(list(l))), [1,2,3]))\n[[3, 2, 1], [3, 2], [3]]\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Eewww... Slicing a list is a linear-time operation.", "All of the solutions posted thus far have O(n^2) time complexity.", "Lisp's maplist, I believe, has O(n)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The problem is, Python's list type isn't a linked list.", "It's a dynamically resizable array (i.e., like C++ STL's \"vector\" type). "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If maintaining linear time complexity is important to you, it isn't possible to create a \"maplist\" function over Python lists.", "It would be better to modify your code to work with indices into the list, or convert the list into an actual linked list (still a linear-time operation, but would have a lot of overhead)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["this works like your example (I've modified reyjavikvi's code)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def maplist(func, l):\n    result=[]\n    for i in range(len(l)):\n        result.append(func(l[i:]))\n    return result\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can use nested list comprehensions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def p(x): return x\n&gt;&gt;&gt; l = range(4)[1:]\n&gt;&gt;&gt; [p([i:]) for i in range(len(l))]\n[[1, 2, 3], [2, 3], [3]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which you can use to define maplist yourself:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def maplist(p, l): return [p([i:]) for i in range(len(l))]\n&gt;&gt;&gt; maplist(p, l)\n[[1, 2, 3], [2, 3], [3]]\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n maplist = lambda f, lst: cons(f(lst), maplist(f, cdr(lst))) if lst else lst\n</code>\n</pre>\n", "senID": 0}, {"text": ["See Python Linked List question."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Python Linked List", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/280243/python-linked-list"}]}], [{"text": ["I think there isn't, but the following function can work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def maplist(func, l):\n    for i in range(len(l)):\n        func(l[i:])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Modifying Aaron's answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In [8]: def maplist(p, l): return [p([x for x in l[i:]]) for i in range(len(l))]\n   ...: \n\nIn [9]: maplist(lambda x: x + x, [1,2,3])\nOut[9]: [[1, 2, 3, 1, 2, 3], [2, 3, 2, 3], [3, 3]]\n</code>\n</pre>\n", "senID": 1}]]