[[{"text": ["As you clarify that long-ish preprocessing is acceptable, I'd suggest a variant of Rabin-Karp: \"an algorithm of choice for multiple pattern search\", as wikipedia puts it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Rabin-Karp", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Rabin-karp"}]}, {"text": ["Define a \"rolling hash\" function, i.e., one such that, when you know the hash for haystack[x:x+N], computing the hash for haystack[x+1:x+N+1] is O(1).", "(Normal hashing functions such as Python's built-in hash do not have this property, which is why you have to write your own, otherwise the preprocessing becomes exhaustingly long rather than merely long-ish;-).", "A polynomial approach is fruitful, and you could use, say, 30-bit hash results (by masking if needed, i.e., you can do the computation w/more precision and just store the masked 30 bits of choice).", "Let's call this rolling hash function RH for clarity."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "haystack[x:x+N]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "haystack[x+1:x+N+1]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "hash", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "exhaustingly", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["So, compute 1G of RH results as you roll along the haystack 1GB string; if you just stored these it would give you an array H of 1G 30-bit values (4GB) mapping index-in-haystack->RH value.", "But you want the reverse mapping, so use instead an array A of 2**30 entries (1G entries) that for each RH value gives you all the indices of interest in the haystack (indices at which that RH value occurs); for each entry you store the index of the first possibly-interesting haystack index into another array B of 1G indices into the haystack which is ordered to keep all indices into haystack with identical RH values (\"collisions\" in hashing terms) adjacent.", "H, A and B both have 1G entries of 4 bytes each, so 12GB total."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Now for each incoming 1K needle, compute its RH, call it k, and use it as an index into A; A[k] gives you the first index b into B at which it's worth comparing.", "So, do:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n ib = A[k]\nb = B[ib]\nwhile b &lt; len(haystack) - 1024:\n  if H[b] != k: return \"not found\"\n  if needle == haystack[b:b+1024]: return \"found at\", b\n  ib += 1\n  b = B[ib]\n</code>\n</pre>\n", "senID": 4}, {"text": ["with a good RH you should have few collisions, so the while should execute very few times until returning one way or another.", "So each needle-search should be really really fast."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["There are a number of string matching algorithms use in the field of genetics to find substrings.", "You might try this paper or this paper"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "this paper", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://cat.inist.fr/?aModele=afficheN&cpsidt=13397373"}, {"href": "http://www.springerlink.com/content/3g5316143gr25124/", "text": "this paper", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Are you willing to spend a significant time preprocessing the string?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you are, what you can do is build a list of n-grams with offsets."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Suppose your alphabet is hex bytes and you are using 1-grams. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Then for 00-ff, you can create a dictionary that looks like this(perlese, sorry)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n $offset_list{00} = @array_of_offsets\n$offset_list{01} = #...etc\n</code>\n</pre>\n", "senID": 4}, {"text": ["where you walk down the string and build the @array_of_offsets from all points where bytes happen.", "You can do this for arbitrary n-grams. "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["This provides a \"start point for search\" that you can use to walk. "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Of course, the downside is that you have to preprocess the string, so that's your tradeoff."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["edit:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"tag": "hr", "senID": 9}, {"text": ["The basic idea here is to match prefixes.", "This may bomb out badly if the information is super-similar, but if it has a fair amount of divergence between n-grams, you should be able to match prefixes pretty well."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Let's quantify divergence, since you've not discussed the kind of info you're analyzing.", "For the purposes of this algorithm, we can characterize divergence as a distance function: you need a decently high Hamming distance.", "If the hamming distance between n-grams is, say, 1, the above idea won't work.", "But if it's n-1, the above algorithm will be much easier."], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "decently", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "Hamming distance", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Hamming%5Fdistance"}]}, {"text": ["To improve on my algorithm, let's build an algorithm that does some successive elimination of possibilities:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["We can invoke Shannon Entropy to define information of a given n-gram.", "Take your search string and successively build a prefix based upon the first m characters.", "When the entropy of the m-prefix is 'sufficiently high', use it later."], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "Shannon Entropy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Entropy%5F%28information%5Ftheory%29"}]}, {"text": ["In a sense, this is like reversing Huffman encoding."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}], [{"text": ["As far as I know, standard find algorithm is naive algorithm with complexity about n*m comparisons, because\nit checks patterns against every possible offset.", "There are some more effective algoithms, requiring about n+m comparisons.", "If your string is not a natural language string, you can try \nKnuth\u2013Morris\u2013Pratt algorithm .", "Boyer\u2013Moore search algorithm is fast and simple enough too."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Knuth\u2013Morris\u2013Pratt algorithm", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Knuth-Morris-Pratt%5Falgorithm"}]}], [{"text": ["With infinite memory, you can hash every 1k string along with its position in the 1 GB file."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["With less than infinite memory, you will be bounded by how many memory pages you touch when searching."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I don't know definitively if the find() method for strings is faster than the search() method provided by Python's re (regular expressions) module, but there's only one way to find out."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "find()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "search()", "childNum": 0, "tag": "code", "childList": []}, {"text": "re", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you're just searching a string, what you want is this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import re\ndef findit(1_gb_string):\n    yield re.search(1_kb_pattern, 1_gb_string)\n</code>\n</pre>\n", "senID": 2}, {"text": ["However, if you really only want the first match, you might be better off using finditer(), which returns an iterator, and with such large operations might actually be better."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "finditer()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["http://www.youtube.com/watch?v=V5hZoJ6uK-s\nWill be of most value to you.", "Its an MIT lecture on Dynamic Programming"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.youtube.com/watch?v=V5hZoJ6uK-s", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.youtube.com/watch?v=V5hZoJ6uK-s"}]}], [{"text": ["If the patterns are fairly random, you can precompute the location of n-prefixes of strings."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Instead of going over all options for n-prefixes, just use the actual ones in the 1GB string - there will be less than 1Gig of those.", "Use as big a prefix as fits in your memory, I don't have 16GB RAM to check but a prefix of 4 could work (at least in a memory-efficient data structures), if not try 3 or even 2."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For a random 1GB string and random 1KB patterns, you should get a few 10s of locations per prefix if you use 3-byte prefixes, but 4-byte prefixes should get you an average of 0 or 1 , so lookup should be fast."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Precompute Locations"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Precompute Locations", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def find_all(pattern, string):\n  cur_loc = 0\n  while True:\n     next_loc = string.find(pattern, cur_loc)\n     if next_loc &lt; 0: return\n     yield next_loc\n     cur_loc = next_loc+1\n\nbig_string = ...\nCHUNK_SIZE = 1024\nPREFIX_SIZE = 4\nprecomputed_indices = {}\nfor i in xrange(len(big_string)-CHUNK_SIZE):\n  prefix = big_string[i:i+PREFIX_SIZE]\n  if prefix not in precomputed_indices:\n    precomputed_indices[prefix] = tuple(find_all(prefix, big_string))\n</code>\n</pre>\n", "senID": 4}, {"text": ["Look up a pattern"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Look up a pattern", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def find_pattern(pattern):\n  prefix = pattern[:PREFIX_SIZE]\n  # optimization - big prefixes will result in many misses\n  if prefix not in precomputed_indices:\n    return -1\n  for loc in precomputed_indices[prefix]:\n    if big_string[loc:loc+CHUNK_SIZE] == pattern:\n        return loc\n  return -1\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Someone hinted at a possible way to index this thing if you have abundant RAM (or possibly even disk/swap) available."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Imagine if you performed a simple 32-bit CRC on a 1K block extending from each character in the original Gig string.", "This would result in 4bytes of checksum data for each byte offset from the beginning of the data."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["By itself this might give a modest improvement in search speed.", "The checksum of each 1K search target could be checked against each CRC ... which each collision tested for a true match.", "That should still be a couple orders of magnitude faster than a normal linear search."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["That, obviously, costs us 4GB of RAM for he CRC array (plus the original Gig for the original data and a little more overhead for the environment and our program)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If we have ~16GB we could sort the checksums and store a list of offsets where each is found.", "That becomes an indexed search (average of about 16 probes per target search ... worst case around 32 or 33 (might be a fence post there)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["It's possible that a 16BG file index would still give better performance than a linear checksum search and it would almost certainly be better than a linear raw search (unless you have extremely slow filesystems/storage)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["(Adding):  I should clarify that this strategy is only beneficial given that you've described a need to do many searches on the same one gigabyte data blob."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["You might use a threaded approach to building the index (while reading it as well as having multiple threads performing the checksumming).", "You might also offload the indexing into separate processes or a cluster of nodes (particularly if you use a file-based index --- the ~16GB option described above).", "With a simple 32-bit CRC you might be able to perform the checksums/indexing as fast as your reader thread can get the data (but we are talking about 1024 checksums for each 1K of data so perhaps not)."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["You might further improve performance by coding a Python module in C for actually performing the search ... and/or possibly for performing the checksumming/indexing."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["The development and testing of such C extensions entail other trade-offs, obviously enough.", "It sounds like this would have near zero re-usability."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["One efficient but complex way is full-text indexing with the Burrows-Wheeler transform.", "It involves performing a BWT on your source text, then using a small index on that to quickly find any substring in the text that matches your input pattern."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "full-text indexing with the Burrows-Wheeler transform", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ddj.com/architect/184405504"}]}, {"text": ["The time complexity of this algorithm is roughly O(n) with the length of the string you're matching - and independent of the length of the input string!", "Further, the size of the index is not much larger than the input data, and with compression can even be reduced below the size of the source text."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]