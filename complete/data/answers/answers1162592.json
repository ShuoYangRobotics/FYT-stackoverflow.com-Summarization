[[{"text": ["Dunno about cleaner, but there's another alternative:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for (op, code) in zip(s[0::2], s[1::2]):\n    print op, code\n</code>\n</pre>\n", "senID": 1}, {"text": ["A no-copy version:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip, islice\nfor (op, code) in izip(islice(s, 0, None, 2), islice(s, 1, None, 2)):\n    print op, code\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Maybe this would be cleaner?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s = \"+c-R+D-e\"\nfor i in xrange(0, len(s), 2):\n    op, code = s[i:i+2]\n    print op, code\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could perhaps write a generator to do what you want, maybe that would be more pythonic :)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Triptych inspired this more general solution:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Triptych", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/43089/triptych"}]}, {"code": "<pre>\n<code>\n def slicen(s, n, truncate=False):\n    assert n &gt; 0\n    while len(s) &gt;= n:\n        yield s[:n]\n        s = s[n:]\n    if len(s) and not truncate:\n        yield s\n\nfor op, code in slicen(\"+c-R+D-e\", 2):\n    print op,code\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n from itertools import izip_longest\ndef grouper(iterable, n, fillvalue=None):\n    args = [iter(iterable)] * n\n    return izip_longest(*args, fillvalue=fillvalue)\ndef main():\n    s = \"+c-R+D-e\"\n    for item in grouper(s, 2):\n        print ' '.join(item)\nif __name__ == \"__main__\":\n    main()\n##output\n##+ c\n##- R\n##+ D\n##- e\n</code>\n</pre>\n", "senID": 0}, {"text": ["izip_longest requires Python 2.6( or higher).", "If on Python 2.4 or 2.5, use the definition for izip_longest from the document or change the grouper function to:"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "izip_longest", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "izip_longest", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://docs.python.org/library/itertools.html#itertools.izip%5Flongest", "text": "document", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import izip, chain, repeat\ndef grouper(iterable, n, padvalue=None):\n    return izip(*[chain(iterable, repeat(padvalue, n-1))]*n)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The other answers work well for n = 2, but for the general case you could try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def slicen(s, n, truncate=False):\n    nslices = len(s) / n\n    if not truncate and (len(s) % n):\n        nslices += 1\n    return (s[i*n:n*(i+1)] for i in range(nslices))\n\n&gt;&gt;&gt; s = '+c-R+D-e'\n&gt;&gt;&gt; for op, code in slicen(s, 2):\n...     print op, code\n... \n+ c\n- R\n+ D\n- e\n\n&gt;&gt;&gt; for a, b, c in slicen(s, 3):\n...     print a, b, c\n... \n+ c -\nR + D\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in ?\nValueError: need more than 2 values to unpack\n\n&gt;&gt;&gt; for a, b, c in slicen(s,3,True):\n...     print a, b, c\n... \n+ c -\nR + D\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Great opportunity for a generator.", "For larger lists, this will be much more efficient than zipping every other elemnent.", "Note that this version also handles strings with dangling ops"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "op", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def opcodes(s):\n    while True:\n        try:\n            op   = s[0]\n            code = s[1]\n            s    = s[2:]\n        except IndexError:\n            return\n        yield op,code        \n\n\nfor op,code in opcodes(\"+c-R+D-e\"):\n   print op,code\n</code>\n</pre>\n", "senID": 1}, {"text": ["edit: minor rewrite to avoid ValueError exceptions."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; s = \"+c-R+D-e\"\n&gt;&gt;&gt; s\n'+c-R+D-e'\n&gt;&gt;&gt; s[::2]\n'+-+-'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Maybe not the most efficient, but if you like regexes..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\ns = \"+c-R+D-e\"\nfor op, code in re.findall('(.)(.)', s):\n    print op, code\n</code>\n</pre>\n", "senID": 1}]]