[[{"text": ["Not really an answer but an observation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This looks overengineered to me, a common trap when looking for excuses to use python magic."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you can be bothered to define a defaults dict for a class why not just define the attributes instead?", "the effect is the same."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "defaults", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class A:\n    a = 1\n\nclass B(A):\n    b = 2\n\nclass C(B):\n    c = 3\n\n\nc = C()\nprint('c.a =', c.a)\n</code>\n</pre>\n", "senID": 3}, {"text": ["EDIT:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["As for answering the question, I would probably use __getattribute__ in combination with my suggestion like this:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "__getattribute__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def __getattribute__(self, name):\n    try:\n        return object.__getattribute__(self.base, name)\n    except AttributeError:\n        return object.__getattribute__(self, name)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["To be more clear about your \"base\" vs \"default\" case. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class A(object):\n...     a = 1\n... \n&gt;&gt;&gt; class B(A):\n...     b = 2\n... \n&gt;&gt;&gt; class C(B):\n...     c = 3\n... \n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; b = B()\n&gt;&gt;&gt; c = C()\n&gt;&gt;&gt; \n&gt;&gt;&gt; b.b = 23\n&gt;&gt;&gt; b.a\n1\n&gt;&gt;&gt; b.b\n23\n&gt;&gt;&gt; c.a\n1\n&gt;&gt;&gt; c.b\n2\n&gt;&gt;&gt; c.c\n3\n&gt;&gt;&gt; c.c = 45\n&gt;&gt;&gt; c.c\n45\n</code>\n</pre>\n", "senID": 1}, {"text": ["This covers your stated use case.", "You need no magick at all.", "If your usecase is somewhat different, explain what it is, and we'll tell you how to do that with no magick.", ";)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["How about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    def __init__(self,base=None):\n        self.a=1\n        if base is not None:\n            self.set_base(base)\n        super(A,self).__init__() \n    def set_base(self,base):\n        for key in ('a b c'.split()):\n            setattr(self,key,getattr(base,key))\nclass B(A): \n    def __init__(self,base=None):\n        self.b=2\n        super(B,self).__init__(base)        \nclass C(B): \n    def __init__(self,base=None):\n        self.c=3\n        super(C,self).__init__(base)\n\nc1=C()\nc1.b=55\nprint(c1.a)\nprint(c1.b)\nprint(c1.c)\n# 1\n# 55\n# 3\n\nc2=C(c1)\nc2.c=99\nprint(c2.a)\nprint(c2.b)\nprint(c2.c)\n# 1\n# 55\n# 99\n\nc1.set_base(c2)\nprint(c1.a)\nprint(c1.b)\nprint(c1.c)\n# 1\n# 55\n# 99\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think the trouble results from misunderstanding the purpose of super(). "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "super()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["http://docs.python.org/library/functions.html#super"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/functions.html#super", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#super"}]}, {"text": ["Essentially, wrapping your object (or class) in super() makes Python skip the most-recently-inherited class when doing attribute lookup.", "In your code, this results in class C being skipped when looking for get_default, but this doesn't really do anything, since C doesn't define a get_default anyway.", "Naturally, this results in an infinite loop."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The solution is to define this function in each class that derives from A.", "This can be done using a metaclass:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class DefaultsClass(type):\n    def __init__(cls, name, bases, dct):\n\n        def get_default(self, name):\n            # some debug output\n            print('A.get_default(%s) - %s' % (name, cls))\n            try:\n                print(cls.defaults) # as expected\n            except AttributeError: #except for the base object class, of course\n                pass\n\n            # the actual function body\n            try:\n                return cls.defaults[name]\n            except KeyError:\n                return super(cls, self).get_default(name) # cooperative superclass\n\n        cls.get_default = get_default\n        return super(DefaultsClass, cls).__init__(name, bases, dct)\n\nclass A(object):\n    defaults = {'a': 1}\n    __metaclass__ = DefaultsClass\n\n    def __getattr__(self, name):\n        return self.get_default(name)\n\n\n\nclass B(A):\n    defaults = {'b': 2}\n\nclass C(B):\n    defaults = {'c': 3}\n\n\nc = C()\nprint('c.a =', c.a)\nprint('c.b =', c.b)\nprint('c.c =', c.c)\n</code>\n</pre>\n", "senID": 4}, {"text": ["results:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n A.get_default(c) - &lt;class '__main__.C'&gt;\n{'c': 3}\n('c.c =', 3)\nA.get_default(b) - &lt;class '__main__.C'&gt;\n{'c': 3}\nA.get_default(b) - &lt;class '__main__.B'&gt;\n{'b': 2}\n('c.b =', 2)\nA.get_default(a) - &lt;class '__main__.C'&gt;\n{'c': 3}\nA.get_default(a) - &lt;class '__main__.B'&gt;\n{'b': 2}\nA.get_default(a) - &lt;class '__main__.A'&gt;\n{'a': 1}\n('c.a =', 1)\n</code>\n</pre>\n", "senID": 6}, {"text": ["I should note that most Python people will consider this a very bizarre solution, and you should only use this if you really need to, maybe to support legacy code."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "really", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["You should use name mangling here."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "name mangling", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html#private-variables"}]}, {"text": ["Rename defaults to __defaults"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "defaults", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__defaults", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["That gives each class an unambiguous attribute so they are not confused with each other"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The solution proposed in the second edit of the question is still the only one that provides everything my application requires.", "While unutbu's code might be simpler to understand, the __mro__ solution provides some advantages IMO (see comments)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__mro__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]