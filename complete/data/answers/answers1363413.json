[[{"text": ["For such large data structures numpy will work well.", "For this example, it's over 200x faster (see below), and a bit easier to code, basically just"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "over 200x faster", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n add.accumulate(diff)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Comparison between numpy and direct list manipulation:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import numpy as nx\nimport timeit\n\nN = 10000\n\ndiff_nx = nx.zeros(N, dtype=nx.int)\ndiff_py = list(diff_nx)\n\nstart = 1005\n\ndef f0():\n    orig = [start]\n    for x in diff_py: \n        orig.append(orig[-1] + x)\n\ndef f1():\n    diff_nx[0] = start\n    nx.add.accumulate(diff_nx)\n\nt = timeit.Timer(\"f0()\", \"from __main__ import f0, f1, diff_nx, diff_py, nx, start\")\nprint t.timeit(number=1000)\nt = timeit.Timer(\"f1()\", \"from __main__ import f0, f1, diff_nx, diff_py, nx, start\")\nprint t.timeit(number=1000)\n</code>\n</pre>\n", "senID": 3}, {"text": ["gives"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n 13.4044158459     # for list looping\n0.0474112033844   # for numpy accumulate\n</code>\n</pre>\n", "senID": 5}, {"text": ["Really, though, it seems better to reuse an established compression algorithm, like can easily be done with PyTables, rather than rolling your own like it seems that you're doing here."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "PyTables", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.pytables.org/moin"}]}, {"text": ["Also, here, I'm suggesting that you read in the data with room for the prepended start term, rather than rebuild the list with the prepended term, of course, so you don't have to do the copy."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["The following works for me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n orig = [start]\nfor x in diff:\n    orig.append(orig[-1] + x)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Using map will create an new array of the same size, filled with None.", "I also find a simple for loop more readable, and in this case as fast as you can get."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Perfect for generators:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def diff2abs( diffs, start ):\n    yield start\n    for diff in diffs:\n        start += diff\n        yield start\n\nstart = 1005\ndiffs = [-1, -1, 1, 2]\noriginal_list = list( diff2abs( diffs, start ))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Several of the other respondents have reasonable implementations of the algorithm you asked for, but I'm unclear on exactly what problem it is you're really trying to solve."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Unless the numbers being stored are very large (i.e., overflow an integer and require bignums), your list of diffs won't gain you any efficiency -- an integer is an integer from the Python runtime POV, so your example \"diff\" list of [-1, -1, 1, 2] will consume just as much memory as the original list [1005, 1004, 1003, 1004, 1006]."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "[-1, -1, 1, 2]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[1005, 1004, 1003, 1004, 1006]", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n class runningtotal:\n    def __init__(self, start = 0):\n        self.total = start\n    def __call__(self, value):\n        self.total += value\n        return self.total\n</code>\n</pre>\n", "senID": 0}, {"text": ["Now try:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; map(runningtotal(start), [0,]+diff)\n[1005, 1004, 1003, 1004, 1006]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["As mshsayem suggested, use list comprehensions - they are generally faster than for loops or map/lambdas (according do Mark Lutz's book Learning Python)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you really want to use an more FP-ish solution, the proper function would be \"scan\", wich [I believe] isn't implemented in Python so you would have to implement it yourself (which is not a hard task)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["\"scan\" is basically a reduce, but instead of reducing the list to a single value, it stores the result of each \"iteration\" in a new list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you implemented it, you could do something like:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n scan(lambda x,y: x+y, [start]++diff)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Although I don't get why this should be more efficient, I am pretty sure a for loop will give the best performance:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = [start]\nfor i in diff:\n    l.append(l[-1] + i)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I don't know about your reasoning for storing the integers as diffs -- rcoder gave a good answer about why this generally is not more efficient than storing the integers themselves -- but if you don't need to have access to the entire list at once, it's more efficient memory-wise for you to use a generator.", "Since you say this is a \"big list,\" you can save a lot of memory this way, instead of allocating the entire list at once.", "Here's a generator comprehension to get your list back:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n start = 1005\ndef mod_start(x):\n    global start\n    start += x\n    return start\nint_generator = (mod_start(i) for i in diffs)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can then iterate over int_generator like you would any list, without having the entire list in memory at once.", "Note, however, that you cannot subscript or slice a generator, but you can use it in many useful situations."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You can clean up the example so that the start variable does not need to be global.", "It just can't be local to the mod_start function."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Edit: You don't have to use the generator comprehension to get a generator.", "You can also use a generator function with the yield expression, like THC4k did.", "That avoids the start variable scope issue and is probably a little cleaner.", "You can also get a list from a generator at any time by passing it to the list() built-in function."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["No comment on the performance of this, but you can use reduce here."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n start = 1005\ndiffs = [-1,-1,1,2]\nreduce(lambda undiffed_list, diff: undiffed_list + [undiffed_list[-1] + diff],diffs,[start])\n</code>\n</pre>\n", "senID": 1}, {"text": ["gets you what you want."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]