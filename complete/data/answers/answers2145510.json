[[{"text": ["The Birthday Paradox, or why PRNGs produce duplicates more often than you might think."], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["There are a couple of issues at play in the OP's problem.", "One is the birthday paradox as mentioned above and the second is the nature of what you are generating, which does not inherently guarantee that a given number will not be repeated.  "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "birthday paradox", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Birthday_problem"}]}, {"text": ["The Birthday Paradox applies where given value can occur more than once during the period of the generator - and therefore duplicates can happen within a sample of values.", "The effect of the Birthday Paradox is that the real likelihood of getting such duplicates is quite significant and the average period between them is smaller than one might otherwise have thought.", "This dissonance between the percived and actual probabilities makes the Birthday Paradox a good example example of a cognitive bias, where a naive intuitive estimate is likely to be wildly wrong."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "cognitive bias", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Cognitive_bias"}]}, {"text": ["A quick primer on Pseudo Random Number Generators (PRNGs)"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "A quick primer on Pseudo Random Number Generators (PRNGs)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The first part of your problem is that you are taking the exposed value of a random number generator and converting it to a much smaller number, so the space of possible values is reduced.", "Although some pseudo-random number generators do not repeat values during their period this transformation changes the domain to a much smaller one.", "The smaller domain invalidates the 'no repeats' condition so you can expect a significant likelihood of repeats.   "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "pseudo-random number generators", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Pseudorandom_number_generator"}]}, {"text": ["Some algorithms, such as the linear congruential PRNG (A'=AX|M) do guarantee uniqueness for the entire period.", "In a LCG the generated value contains the entire state of the accumulator and no additional state is held.", "The generator is deterministic and cannot repeat a number within the period - any given accumulator value can imply only one possible successive value.", "Therefore, each value can only occur once within the period of the generator.", "However, the period of such a PRNG is relatively small - about 2^30 for typical implementations of the LCG algorithm - and cannot possibly be larger than the number of distinct values."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "linear congruential PRNG", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Linear_congruential_generator"}, {"text": "A'=AX|M", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "do", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["Not all PRNG algorithms share this characteristic; some can repeat a given value within the period.", "In the OP's problem the Mersenne Twister algorithm (used in Python's random module) has a very long period - much greater than 2^32.", "Unlike a Linear Congruential PRNG, the result is not purely a function of the previous output value as the accumulator contains additional state.", "With 32 bit integer output and a period of ~2^19937 it cannot possibly provide a such a guarantee.  "], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "Mersenne Twister", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Mersenne_twister"}, {"text": "random", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/random.html"}]}, {"text": ["The Merseene Twister is a popular algorithm for PRNGs because it has good statistical and geometric properties and a very long period - desirable characteristics for a PRNG used on simulation models.   "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["Good statistical properties mean that the numbers generated by the algorithm are evenly distributed with no numbers having a significantly higher probability of appearing than others.", "Poor statistical properties could produce unwanted skew in the results."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "statistical properties", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Uniform_distribution_%28discrete%29"}]}, {"text": ["Good geometric properies mean that sets of N numbers do not lie on a hyperplane in N dimensional space.", "Poor geometric properties can generate spurious correlations in a simulation model and distort the results."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "geometric properies", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://random.mat.sbg.ac.at/~charly/server/node3.html"}]}, {"text": ["A long period means that you can generate a lot of numbers before the sequence wraps around to the start.", "If a model needs a large number of iterations or has to be run from several seeds then the 2^30 or so discrete numbers available from a typical LCG implementation may not be sufficient.", "The MT19337 algorithm has a very long period - 2^19337-1, or about 10^5821.", "By comparison the total number of atoms in the universe is estimated at about 10^80."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}]}, {"text": ["The 32 bit integer produced by a MT19337 PRNG cannot possibly represent enough discrete values to avoid repeating during such a large period.", "In this case duplicate values are likely to occur and inevitable with a large enough sample.  "], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["The Birthday Paradox in a nutshell"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "The Birthday Paradox in a nutshell", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This problem is originally defined as the probability of any two people in the room sharing the same birthday.", "The key point is that any two people in the room could share a birthday.", "People tend to naively misinterpret the problem as the probability of someone in the room sharing a birthday with a specific individual, which is the source of the cognitive bias that often causes people to underestimate the probability.", "This is the incorrect assumption - there is no requirement for the match to be to a specific individual and any two individuals could match.  "], "childNum": 3, "tag": "p", "senID": 13, "childList": [{"text": "any two", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "any two", "tag": "em"}]}, {"text": "any two", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "cognitive bias", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Cognitive_bias"}]}, {"src": "http://upload.wikimedia.org/wikipedia/commons/thumb/5/56/Birthday_paradox.png/450px-Birthday_paradox.png", "tag": "img", "senID": 14}, {"text": ["The probability of a match occurring between any two individuals is much higher than the probability of a match to a specific individual as the match does not have to be to a specific date.", "Rather, you only have to find two individuals that share the same birthday.", "From this graph (which can be found on the wikipedia page on the subject), we can see that we only need 23 people in the room for there to be a 50% chance of finding two that match in this way."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["From the Wikipedia entry on the subject we can get a nice summary.", "In the OP's problem we have 4,500 possible 'birthdays', rather than 365.", "For a given number of random values generated (equating to 'people') we want to know the probability of any two identical values appearing within the sequence.  "], "childNum": 3, "tag": "p", "senID": 16, "childList": [{"text": "Wikipedia entry on the subject", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Birthday_problem"}, {"text": "nice summary.", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Birthday_problem#Understanding_the_problem"}, {"text": "any", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Computing the likely effect of the Birthday Paradox on the OP's problem"], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "Computing the likely effect of the Birthday Paradox on the OP's problem", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["For a sequence of 100 numbers, we have  pairs (see Understanding the Problem) that could potentially match (i.e.", "the first could match with the second, third etc., the second could match the third, fourth etc.", "and so on), so the number of combinations that could potentially match is rather more than just 100.  "], "childNum": 3, "tag": "p", "senID": 18, "childList": [{"text": "", "childNum": 0, "tag": "img", "pos": 0, "childList": []}, {"text": "Understanding the Problem", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Birthday_problem#Understanding_the_problem"}, {"text": "combinations", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["From Calculating the Probability we get an expression of .", "The following snippet of Python code below does a naive evaluation of the probability of a matching pair occurring.  "], "childNum": 2, "tag": "p", "senID": 19, "childList": [{"text": "Calculating the Probability", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Birthday_problem#Calculating_the_probability"}, {"text": "", "childNum": 0, "tag": "img", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n # === birthday.py ===========================================\n#\nfrom math import log10, factorial\n\nPV=4500          # Number of possible values\nSS=100           # Sample size\n\n# These intermediate results are exceedingly large numbers;\n# Python automatically starts using bignums behind the scenes.\n#\nnumerator = factorial (PV)          \ndenominator = (PV ** SS) * factorial (PV - SS)\n\n# Now we need to get from bignums to floats without intermediate\n# values too large to cast into a double.  Taking the logs and \n# subtracting them is equivalent to division.\n#  \nlog_prob_no_pair = log10 (numerator) - log10 (denominator)\n\n# We've just calculated the log of the probability that *NO*\n# two matching pairs occur in the sample.  The probability\n# of at least one collision is 1.0 - the probability that no \n# matching pairs exist.\n#\nprint 1.0 - (10 ** log_prob_no_pair)\n</code>\n</pre>\n", "senID": 20}, {"text": ["This produces a sensible looking result of p=0.669 for a match occuring within 100 numbers sampled from a population of 4500 possible values (Maybe someone could verify this and post a comment if it's wrong).", "From this we can see that the lengths of runs between matching numbers observed by the OP seem to be quite reasonable."], "childNum": 2, "tag": "p", "senID": 21, "childList": [{"text": "p=0.669", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "p=0.669", "tag": "em"}]}, {"text": "p=0.669", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["Footnote: using shuffling to get a unique sequence of pseudo-random numbers "], "childNum": 1, "tag": "p", "senID": 22, "childList": [{"text": "Footnote: using shuffling to get a unique sequence of pseudo-random numbers", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["See this answer below from S. Mark for a means of getting a guaranteed unique set of random numbers.", "The technique the poster refers to takes an array of numbers (which you supply, so you can make them unique) and shuffles them into random order.", "Drawing the numbers in sequence from the shuffled array will give you a sequence of pseudo-random numbers that are guaranteed not to repeat."], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "this answer below from S. Mark", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2145510/python-random-is-barely-random-at-all/2145533#2145533"}]}, {"text": ["Footnote: Cryptographically Secure PRNGs "], "childNum": 1, "tag": "p", "senID": 24, "childList": [{"text": "Footnote: Cryptographically Secure PRNGs", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The MT algorithm is not cryptographically secure as it is relatively easy to infer the internal state of the generator by observing a sequence of numbers.", "Other algorithms such as Blum Blum Shub are used for cryptographic applications, but may be unsuitable for simulation or general random number applications.", "Cryptographically secure PRNGs may be expensive (perhaps requiring bignum calculations) or may not have good geometric properties.", "In the case of this type of algorithm the primary requirement is that it should be computationally infeasible to infer the internal state of the generator by observing a sequence of values."], "childNum": 2, "tag": "p", "senID": 25, "childList": [{"text": "cryptographically secure", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator"}, {"text": "Blum Blum Shub", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Blum_Blum_Shub"}]}], [{"text": ["Before blaming Python, you should really brush up some probability &amp; statistics theory.", "Start by reading about the birthday paradox"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "birthday paradox", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Birthday_paradox"}]}, {"text": ["By the way, the random module in Python uses the Mersenne twister PRNG, which is considered very good, has an enormous period and was extensively tested.", "So rest assured you're in good hands."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "random", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Mersenne twister", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Mersenne_twister"}]}], [{"text": ["If you don't want repetative one, generate sequential array and use random.shuffle"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "random.shuffle", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/random.html#random.shuffle"}]}], [{"src": "http://dilbert.com/dyn/str_strip/000000000/00000000/0000000/000000/00000/2000/300/2318/2318.strip.gif", "tag": "img", "senID": 0}], [{"text": ["True randomness definitely includes repetition of values before the whole set of possible values is exhausted.", "It would not be random otherwise, as you would be able to predict for how long a value would not be repeated."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you ever rolled dice, you surely got 3 sixes in row quite often..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["As an answer to the answer of Nimbuz:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://xkcd.com/221/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://xkcd.com/221/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://xkcd.com/221/"}]}, {"src": "http://imgs.xkcd.com/comics/random_number.png", "tag": "img", "senID": 2}], [{"text": ["You are generating 4500 random numbers from a range 500 &lt;= x &lt;= 5000.", "You then check to see for each number whether it has been generated before.", "The birthday problem tells us what the probability is for two of those numbers to match given n tries out of a range d."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "4500", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "500 &lt;= x &lt;= 5000", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "birthday problem", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Birthday_problem"}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}, {"text": "d", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You can also invert the formula to calculate how many numbers you have to generate until the chance of generating a duplicate is more than 50%.", "In this case you have a &gt;50% chance of finding a duplicate number after 79 iterations."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "50%", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "&gt;50%", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "79", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Python's random implementation is actually quite state of the art: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["http://en.wikipedia.org/wiki/Mersenne_twister"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["http://docs.python.org/library/random.html"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}]}], [{"text": ["That's not a repeater.", "A repeater is when you repeat the same sequence.", "Not just one number."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sequence", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["You have defined a random space of 4501 values  (500-5000), and you are iterating 4500 times.", "You are basically guaranteed to get a collision in the test you wrote."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To think about it another way:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "When the result array is empty P(dupe) = 0", "tag": "none", "senID": 2}, {"text": "1 value in Array P(dupe) = 1/4500", "tag": "none", "senID": 3}, {"text": "2 values in Array P(dupe) = 2/4500", "tag": "none", "senID": 4}, {"text": "etc.", "tag": "none", "senID": 5}]}, {"text": ["So by the time you get to 45/4500, that insert has a 1% chance of being a duplicate, and that probability keeps increasing with each subsequent insert."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["To create a test that truly tests the abilities of the random function, increase the universe of possible random values (eg: 500-500000)  You may, or may not get a dupe.", "But you'll get far more iterations on average."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["For anyone else with this problem, I used uuid.uuid4() and it works like a charm."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I want to write a program that will simulate 3 dice being rolled at the same time but I want the 3 dice to always have a different number from each other every time they are rolled.", "ex on the first roll I get 2,1,6 that is fine but I dont want the prog.", "to ever roll duplicates for ex 2,4,2."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["die1 = random.randint(1, 6) "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["die2 = random.randrange(1, 6)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["die3 = random.randrange(1, 6)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["this is all I have so far, im a beginner ... "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]