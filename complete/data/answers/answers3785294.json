[[{"text": ["unless you have BLOBs in there, thousands of rows shouldn't be a problem.", "Do you know that it is?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also, why bring shame on yourself and your entire family by doing something like"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n \"SELECT * FROM tbl_subscriber LIMIT %d,%d;\" % (actualLimit,steps)\n</code>\n</pre>\n", "senID": 2}, {"text": ["when the cursor will make the substitution for you in a manner that avoids SQL injection?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n c.execute(\"SELECT * FROM tbl_subscriber LIMIT %i,%i;\", (actualLimit,steps))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["First of all maybe you don't need Select * from... "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["maybe it's enough for you just to get some stuff like: \"SELECT email from...\""], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["that would decrease the amount of memory usage anyway:)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Do you have actual memory problems?", "When iterating over a cursor, results are fetched one at a time (your DB-API implementation might decide to prefetch results, but then it might offer a function to set the number of prefetched results)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Most MySQL connectors based on libmysqlclient will buffer all the results in client memory by default for performance reasons (with the assumption you won't be reading large resultsets)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When you do need to read a large result in MySQLdb you can use a SSCursor to avoid buffering entire large resultsets."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://mysql-python.sourceforge.net/MySQLdb.html#using-and-extending"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://mysql-python.sourceforge.net/MySQLdb.html#using-and-extending", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mysql-python.sourceforge.net/MySQLdb.html#using-and-extending"}]}, {"text": ["This does introduce complications that you must be careful of.", "If you don't read all the results from the cursor, a second query will raise an ProgrammingError:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import MySQLdb\n&gt;&gt;&gt; import MySQLdb.cursors\n&gt;&gt;&gt; conn = MySQLdb.connect(read_default_file='~/.my.cnf')\n&gt;&gt;&gt; curs = conn.cursor(MySQLdb.cursors.SSCursor)\n&gt;&gt;&gt; curs.execute('SELECT * FROM big_table')\n18446744073709551615L\n&gt;&gt;&gt; curs.fetchone()\n(1L, '2c57b425f0de896fcf5b2e2f28c93f66')\n&gt;&gt;&gt; curs.execute('SELECT NOW()')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"/usr/lib64/python2.6/site-packages/MySQLdb/cursors.py\", line 173, in execute\n    self.errorhandler(self, exc, value)\n  File \"/usr/lib64/python2.6/site-packages/MySQLdb/connections.py\", line 36, in defaulterrorhandler\n    raise errorclass, errorvalue\n_mysql_exceptions.ProgrammingError: (2014, \"Commands out of sync; you can't run this command now\")\n</code>\n</pre>\n", "senID": 4}, {"text": ["This means you have to always read everything from the cursor (and potentially multiple resultsets) before issuing another - MySQLdb won't do this for you."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["You don't have to modify the query, you can use the fetchmany method of cursors.", "Here is how I do it :  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "fetchmany", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def fetchsome(cursor, some=1000):\n    fetch=cursor.fetchmany\n    while True:\n        rows=fetch(some)\n        if not rows: break\n        for row in rows:\n            yield row\n</code>\n</pre>\n", "senID": 1}, {"text": ["This way you can \"SELECT * FROM tbl_subscriber;\" but you will only fetch some at a time."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "some", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Wouldn't it be good, if you fetched one row at a time like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Table:\n   def __init__(self, db, name):\n      self.db = db\n      self.name = name\n      self.dbc = self.db.cursor()\n\n   def __getitem__(self, item):\n      self.dbc.execute(\"select * from %s limit %s, 1\" % \n         (self.name, item))\n      return self.dbc.fetchone()\n\n   def __len__(self):\n      self.dbc.execute(\"select count(*) from %s\" % (self.name))\n      r = int(self.dbc.fetchone()[0])\n      return r\n\n\nimport MySQLdb\ndb = MySQLdb.connect(user=\"user\", passwd=\"passwd\", db=db)\nsubscribers = Table(db, \"name\")\nfor i in xrange(len(subscribers)):\n   print subscribers[i]\n</code>\n</pre>\n", "senID": 1}]]