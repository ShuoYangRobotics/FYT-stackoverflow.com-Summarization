[[{"text": ["'\\n' is one character.", "It is a new line escape character and is just a representation of the new line. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["please rephrase your question in a readable way."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["[Edit]\nI think I know what your problem is.", "I ran your program and it is working just fine.", "You are probably trying to pass '\\n' to your program from the command line.", "That will not work! "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You see, if you gave raw_input() this string: line1\\nline2 it will escape the \\n and make it \\\\n like this: 'line1\\\\nline2'"], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "line1\\nline2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\n", "childNum": 0, "tag": "code", "childList": []}, {"text": "\\\\n", "childNum": 0, "tag": "code", "childList": []}, {"text": "'line1\\\\nline2'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So a quick hacky fix is to find and replace '\\\\n' with '\\n':"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n text.replace('\\\\n', '\\n')\n</code>\n</pre>\n", "senID": 5}, {"text": ["I don't like this.", "But it will work for you."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["A much better way is to read multiple lines, like this:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n input = raw_input('Please type in something: ')\nlines = [input]\nwhile input:\n    input = raw_input()\n    lines.append(input)\n\ntext = '\\n'.join(lines)\n\nprint text\n</code>\n</pre>\n", "senID": 8}], [{"text": ["I'm guessing that your real problem is not with reading in \\n as a '\\' 'n' -- internally, Python should automagically translate \\n into a single character."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["My guess is that the real problem is that your newlines are probably actually two characters -- carriage return ('\\r') and newline ('\\n').", "Try handling \\r in addition to \\n, and I wonder if that won't make your problem go away."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Newline character is a single character."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = '\\n'\n&gt;&gt;&gt; print len(a)\n1\n&gt;&gt;&gt; a = '\\n\\n\\n'\n&gt;&gt;&gt; a[1]\n'\\n'\n&gt;&gt;&gt; len(a)\n3\n&gt;&gt;&gt; len(a[0])\n1\n</code>\n</pre>\n", "senID": 1}, {"text": ["So you misunderstand what your problem is."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I assume the problem is if there is \\n in the text to be decrypted, it breaks:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n KeyError: \\\n\nmodule body   in untitled at line 166\nfunction Crypt    in untitled at line 94\n</code>\n</pre>\n", "senID": 1}, {"text": ["Basically, raw_input() returns a string containing two characters \\ and n - and you have no mapping for \\ thus the error."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "raw_input()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\", "childNum": 0, "tag": "code", "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}, {"text": "\\", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The simplest solution is so simply replace the literal characters \\n with the \\n escape sequence"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "\\n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\n", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def Crypt(text, cipher):\n    text.replace(r\"\\n\", \"\\n\")\n    ...\n</code>\n</pre>\n", "senID": 4}, {"text": ["The raw string r\"\\n\" creates a string containing the literal character \\ followed by n (the same as doing \"\\\\n\")."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "r\"\\n\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\", "childNum": 0, "tag": "code", "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}, {"text": "\"\\\\n\"", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In a regular string \"\\n\" it's treated as the escape-sequence for a new-line.", "So the above code-block replaces \\n in text with an newline."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "\"\\n\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\n", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You may have to define a mapping for \"\\n\" in your keyDict mapping."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "keyDict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Another solution would be to split the text using text.split(r\"\\n\") and treat each line separately.", "Or as others have suggested, use ord() every character and deal with numbers, rather than making your own numerical mapping."], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "text.split(r\"\\n\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ord()", "tag": "a", "pos": 1, "childList": [{"text": "ord()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#ord"}, {"text": "ord()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["As the docs explains, chr() is the opposite, and will turn the number back into a ASCII or Unicode character:"], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "chr()", "tag": "a", "pos": 0, "childList": [{"text": "chr()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#chr"}, {"text": "chr()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Basically you would do.."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n def Crypt(text, cipher):\n    keyvalue = [ord(x) for x in cipher)\n    textvalue = [ord(x) for x in text]\n</code>\n</pre>\n", "senID": 11}, {"text": ["..instead of the two for loops (the list-comprehension is basically the same as making a list, looping over each character in text or cipher, and appending to the list each time)"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "list-comprehension", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions"}]}], [{"text": ["I'm new to Python, but there could be a way to simplify what you are doing by using the ord and chr functions to change characters to ASCII values and vice versa.", "Here's a link to the built-in function documentation in Python."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "ord", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "chr", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "built-in function documentation in Python", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html"}]}], [{"text": ["You should probably take advantage of a number's numeric value to perform your encryption and avoid those big data structures that will fail for non-ascii text anyway."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]