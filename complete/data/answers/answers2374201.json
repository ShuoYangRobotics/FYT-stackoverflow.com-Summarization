[[{"text": ["I'd say Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Have a look here for string permutations: Permutations using a Combinations Generator (Python).", "Another thing to look at is itertools in Python 2.6+ - Generating all permutations of a list in python.", "I do note however that your requirements are more in depth, however you will probably find it easier to add in the necessary constraints in Python rather than Bash."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "Permutations using a Combinations Generator (Python)", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.daniweb.com/code/snippet216786.html"}, {"text": "itertools", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "2.6", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.python.org/download/releases/2.6/"}, {"text": "Generating all permutations of a list in python", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/104420/how-to-generate-all-permutations-of-a-list-in-python"}]}, {"text": ["Simple, clean and easy."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Now, I'm not expert on Bash, but looking at it, you would have to have multiple lines that repeat pretty much the same text over and over depending on your combinations.", "It would be great to use simple combinations, but not linked combinations."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["While I don't know bash and don't see how permutations would solve your problem, it seems that itertools.product is a fairly straightforward way to do this:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "permutations", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools.product", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = 'atgc'\n&gt;&gt;&gt; d = dict(zip(s, 'tacg'))\n&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; for i in itertools.product(s, repeat=10):\n    sta = ''.join(i)\n    stb = ''.join(d[x] for x in i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["while proposed method is valid in terms of obtaining all possible permutations with replacement of the 'atgc' string, i.e., finding sta string, finding stb would be more efficient not through the dictionary look-up, but rather the translation mechanism:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "'atgc'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sta", "childNum": 0, "tag": "code", "childList": []}, {"text": "stb", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; trans = str.maketrans(s, 'tacg')\n&gt;&gt;&gt; for i in itertools.product(s, repeat=10):\n    sta = ''.join(i)\n    stb = sta.translate(trans)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Thanks to Dave, for highlighting more efficient solution."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Others have said how to generate STA."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The most efficient way to convert a string STA into the equivalent string STB is to use the string translate &amp; maketrans functions."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "translate", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#str.translate"}, {"href": "http://docs.python.org/library/string.html#string.maketrans", "text": "maketrans", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import string\n&gt;&gt;&gt; s = \"AGTC\" * 100\n&gt;&gt;&gt; trans = string.maketrans(\"ATGC\", \"TACG\")\n&gt;&gt;&gt; s.translate(trans)\n'TCAG...TCAG'\n</code>\n</pre>\n", "senID": 2}, {"text": ["On my system this is ~100 times faster than doing a dictionary lookup on each character as suggested by SilentGhost."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Here you go: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import product\n&gt;&gt;&gt; seq = (\"AGCT\",) * 10\n&gt;&gt;&gt; STA = [''.join(a) for a in product(*seq)]\n&gt;&gt;&gt; STB = list(reversed(STA))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Incidentally, len(STA) is 220. "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "len(STA)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "20", "childNum": 0, "tag": "sup", "childList": []}]}, {"text": ["itertools.product is available in Python 2.6."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "itertools.product", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["See @hop's answer here for an implementation of product in Python 2.5"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/533905/get-the-cartesian-product-of-a-series-of-lists-in-python"}, {"text": "product", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["bash baby :)"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"code": "<pre>\n<code>\n STA=$(echo {A,C,T,G}{A,C,T,G}{A,C,T,G}{A,C,T,G}{A,C,T,G}{A,C,T,G}{A,C,T,G}{A,C,T,G}{A,C,T,G}{A,C,T,G})\nSTB=$(echo $STA | tr ATCG TAGC)\n\necho $STA\necho $STB\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Unrelated to your actual question but related to what you're (apparently) doing, have you checked out BioPython?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "BioPython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://biopython.org"}]}]]