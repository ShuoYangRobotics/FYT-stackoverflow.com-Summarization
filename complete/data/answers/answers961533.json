[[{"text": ["You are using extend wrong.", "A.extend( B ), requires that B is some iterable object( ie a list, tuple ).", "You really want to use append instead."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n t=raw_input()\nc=[]\nfor j in range(0,int(t)):\n    n=raw_input()\n    a,b= (int(i) for i in n.split(' '))\n    c.append( pow(a,b) ) ## or you could extend c.extend( [ pow(a,b) ] ), but thats silly.\nfor j in c:\n    print j\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You should try GMPY.", "Try something like:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "GMPY", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://gmpy.sourceforge.net/"}]}, {"code": "<pre>\n<code>\n import gmpy\na = gmpy.mpz(10**10)\nb = a**10000000\n</code>\n</pre>\n", "senID": 1}, {"text": ["I don't know how much \"big\" your numbers are, this solution isn't that fast (but the result is big enough :P )"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["python integer ops are arbitrary precision\nIf you want arbitrary precision floating point ops import Decimal"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from decimal import *\nd=Decimal('2.0')\nprint d**1234\n</code>\n</pre>\n", "senID": 1}], [{"text": ["10000**10000 prints in my machine in under a second."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["How large is your input."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Your problem is not related to power function."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Use "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n c.append()\n</code>\n</pre>\n", "senID": 4}, {"text": ["instead of"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n c.extend()\n</code>\n</pre>\n", "senID": 6}, {"text": ["c.extend takes an iterable (a list/tuple/set/custom iterables) as an input."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["x**y works greatly for exponents.", "If you want a more original solution, you can use:\n    def exp(base, exponent):\n      round(exponent, 0)\n      if exponent &lt; 0:\n        return 1.0 / exp(base, -1 * exponent)\n      if exponent == 0:\n        return 1\n      if exponent &gt; 0:\n        return base * exp(base, exponent - 1)\nSadly, this only works exactly for integer exponents."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "x**y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "def exp(base, exponent):\n      round(exponent, 0)\n      if exponent &lt; 0:\n        return 1.0 / exp(base, -1 * exponent)\n      if exponent == 0:\n        return 1\n      if exponent &gt; 0:\n        return base * exp(base, exponent - 1)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Another way you might want to try calculating exponents is by using logarithm laws."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["x^y = e^(y ln x)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I can't say for certain but this might reduce the number of operations required to calculate large exponents."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]