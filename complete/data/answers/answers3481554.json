[[{"text": ["not x in L isn't explicitly disallowed because that would be silly.", "x not in L is explicitly allowed (though it compiles to the same bytecode) because it's more readable."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "not x in L", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x not in L", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["x not in L is what everyone uses, though."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "x not in L", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; dis.dis(lambda: a not in b)\n1           0 LOAD_GLOBAL              0 (a)\n          3 LOAD_GLOBAL              1 (b)\n          6 COMPARE_OP               7 (not in)\n          9 RETURN_VALUE      \n\n&gt;&gt;&gt; dis.dis(lambda: not a in b)\n1           0 LOAD_GLOBAL              0 (a)\n          3 LOAD_GLOBAL              1 (b)\n          6 COMPARE_OP               7 (not in)\n          9 RETURN_VALUE\n</code>\n</pre>\n", "senID": 0}, {"text": ["when you do \"not a in b\" it will need be converted for (not in)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["so, the right way is \"a not in b\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The two forms make identical bytecode, as you can clearly verify:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import dis\n&gt;&gt;&gt; dis.dis(compile('if x not in d: pass', '', 'exec'))\n  1           0 LOAD_NAME                0 (x)\n              3 LOAD_NAME                1 (d)\n              6 COMPARE_OP               7 (not in)\n              9 JUMP_IF_FALSE            4 (to 16)\n             12 POP_TOP             \n             13 JUMP_FORWARD             1 (to 17)\n        &gt;&gt;   16 POP_TOP             \n        &gt;&gt;   17 LOAD_CONST               0 (None)\n             20 RETURN_VALUE        \n&gt;&gt;&gt; dis.dis(compile('if not x in d: pass', '', 'exec'))\n  1           0 LOAD_NAME                0 (x)\n              3 LOAD_NAME                1 (d)\n              6 COMPARE_OP               7 (not in)\n              9 JUMP_IF_FALSE            4 (to 16)\n             12 POP_TOP             \n             13 JUMP_FORWARD             1 (to 17)\n        &gt;&gt;   16 POP_TOP             \n        &gt;&gt;   17 LOAD_CONST               0 (None)\n             20 RETURN_VALUE\n</code>\n</pre>\n", "senID": 1}, {"text": ["so obviously they're semantically identical."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["As a matter of style, PEP 8 does not mention the issue."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "PEP 8", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0008/"}]}, {"text": ["Personally, I strongly prefer the if x not in y form -- that makes it immediately clear that not in is a single operator, and \"reads like English\".", "if not x in y may mislead some readers into thinking it means if (not x) in y, reads a bit less like English, and has absolutely no compensating advantages."], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "if x not in y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not in", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "and", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "if not x in y", "childNum": 0, "tag": "code", "childList": []}, {"text": "if (not x) in y", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["It just personal preference.", "You could also compare if x != 3 and if not x == 3.", "There's no difference between the two expressions you've shown."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "if x != 3", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "if not x == 3", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["When you write a not in b it is using the not in operator, whereas not a in b uses the in operator and then negates the result.", "But the not in operator is defined to return the same as not a in b so they do exactly the same thing.", "From the documentation:"], "childNum": 7, "tag": "p", "senID": 0, "childList": [{"text": "a not in b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not in", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "not a in b", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "in", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "not in", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "not a in b", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "documentation", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/expressions.html#notin"}]}, {"text": ["Similarly there is a is not b versus not a is b."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "a is not b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not a is b", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The extra syntax was added because it makes it easier for a human to read it naturally."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Same.", "No difference whatsoever"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]