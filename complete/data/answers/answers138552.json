[[{"text": ["I was able to do this with Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; re.sub(r\"x(?=[^']*'([^']|'[^']*')*$)\", \"P\", \"axbx'cxdxe'fxgh'ixj'k\")\n\"axbx'cPdPe'fxgh'iPj'k\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["What this does is use the non-capturing match (?=...) to check that the character x is within a quoted string.", "It looks for some nonquote characters up to the next quote, then looks for a sequence of either single characters or quoted groups of characters, until the end of the string."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This relies on your assumption that the quotes are always balanced.", "This is also not very efficient."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I converted Greg Hewgill's python code to C# and it worked!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [Test]\npublic void ReplaceTextInQuotes()\n{\n  Assert.AreEqual(\"axbx'cPdPe'fxgh'iPj'k\", \n    Regex.Replace(\"axbx'cxdxe'fxgh'ixj'k\",\n      @\"x(?=[^']*'([^']|'[^']*')*$)\", \"P\"));\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["That test passed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Not with plain regexp.", "Regular expressions have no \"memory\" so they cannot distinguish between being \"inside\" or \"outside\" quotes. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You need something more powerful, for example using gema it would be straighforward:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "gema", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://gema.sourceforge.net"}]}, {"code": "<pre>\n<code>\n '&lt;repl&gt;'=$0\nrepl:x=P\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The trick is to use non-capturing group to match the part of the string following the match (character x) we are searching for.", "Trying to match the string up to x will only find either the first or the last occurence, depending whether non-greedy quantifiers are used.", "Here's Greg's idea transposed to Tcl, with comments."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "following", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "x", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "x", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"code": "<pre>\nset strIn {axbx'cxdxe'fxgh'ixj'k}\nset regex {(?x)                     # enable expanded syntax \n                                    # - allows comments, ignores whitespace\n            x                       # the actual match\n            (?=                     # non-matching group\n                [^']*'              # match to end of current quoted substring\n                                    ##\n                                    ## assuming quotes are in pairs,\n                                    ## make sure we actually were \n                                    ## inside a quoted substring\n                                    ## by making sure the rest of the string \n                                    ## is what we expect it to be\n                                    ##\n                (\n                    [^']*           # match any non-quoted substring\n                    |               # ...or...\n                    '[^']*'         # any quoted substring, including the quotes\n                )*                  # any number of times\n                $                   # until we run out of string :)\n            )                       # end of non-matching group\n}\n\n#the same regular expression without the comments\nset regexCondensed {(?x)x(?=[^']*'([^']|'[^']*')*$)}\n\nset replRegex {P}\nset nMatches [regsub -all -- $regex $strIn $replRegex strOut]\nputs \"$nMatches replacements. \"\nif {$nMatches > 0} {\n    puts \"Original: |$strIn|\"\n    puts \"Result:   |$strOut|\"\n}\nexit\n</pre>\n", "senID": 1}, {"text": ["This prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 3 replacements. \nOriginal: |axbx'cxdxe'fxgh'ixj'k|\nResult:   |axbx'cPdPe'fxgh'iPj'k|\n</code>\n</pre>\n", "senID": 3}], [{"text": ["A more general (and simpler) solution which allows non-paired quotes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Sorry to break your hopes, but you need a push-down automata to do that.", "There is more info here:\nPushdown Automaton"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Pushdown Automaton", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Pushdown_automaton"}]}, {"text": ["In short, Regular expressions, which are finite state machines can only read and has no memory while pushdown automaton has a stack and manipulating capabilities."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit: spelling..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Similar discussion about balanced text replaces: http://stackoverflow.com/questions/133601/can-regular-expressions-be-used-to-match-nested-patterns#133771"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://stackoverflow.com/questions/133601/can-regular-expressions-be-used-to-match-nested-patterns#133771", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/133601/can-regular-expressions-be-used-to-match-nested-patterns#133771"}]}, {"text": ["Although you can try this in Vim, but it works well only if the string is on one line, and there's only one pair of 's."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n :%s:\\('[^']*\\)x\\([^']*'\\):\\1P\\2:gci\n</code>\n</pre>\n", "senID": 2}, {"text": ["If there's one more pair or even an unbalanced ', then it could fail.", "That's way I included the c a.k.a.", "confirm flag on the ex command."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "c", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ex", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["The same can be done with sed, without the interaction - or with awk so you can add some interaction."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "awk", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["One possible solution is to break the lines on pairs of 's then you can do with vim solution. "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n Pattern:     (?s)\\G((?:^[^']*'|(?&lt;=.))(?:'[^']*'|[^'x]+)*+)x\nReplacement: \\1P\n</code>\n</pre>\n", "senID": 0}, {"text": ["One sweep trough the source string, except for a single character look-behind."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n #!/usr/bin/perl -w\n\nuse strict;\n\n# Break up the string.\n# The spliting uses quotes\n# as the delimiter.\n# Put every broken substring\n# into the @fields array.\n\nmy @fields;\nwhile (&lt;&gt;) {\n    @fields = split /'/, $_;\n}\n\n# For every substring indexed with an odd\n# number, search for x and replace it\n# with P.\n\nmy $count;\nmy $end = $#fields;\nfor ($count=0; $count &lt; $end; $count++) {\n    if ($count % 2 == 1) {\n        $fields[$count] =~ s/a/P/g;\n    }    \n}\n</code>\n</pre>\n", "senID": 0}, {"text": ["Wouldn't this chunk do the job?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]