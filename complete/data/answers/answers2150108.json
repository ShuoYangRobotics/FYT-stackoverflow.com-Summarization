[[{"text": ["A collection.deque is optimized for pulling and pushing on both ends.", "They even have a dedicated rotate() method."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "collection.deque", "tag": "a", "pos": 0, "childList": [{"text": "collection.deque", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/collections.html#deque-objects"}, {"text": "collection.deque", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "rotate()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["It depends on what you want to have happen when you do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; shift([1,2,3], 14)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You might want to change your:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def shift(seq, n):\n    return seq[n:]+seq[:n]\n</code>\n</pre>\n", "senID": 3}, {"text": ["to:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def shift(seq, n):\n    n = n % len(seq)\n    return seq[n:] + seq[:n]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["what about just using pop(0)?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["list.pop([i])\nRemove the item at the given position in the list, and return it.", "If no index is specified, a.pop() removes and returns the last item in the list.", "(The square brackets around the i in the method signature denote that the parameter is optional, not that you should type square brackets at that position.", "You will see this notation frequently in the Python Library Reference."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This also depends on if you want to shift the list in place (mutating it), or if you want the function to return a new list.", "Because, according to my tests, something like this is at least twenty times faster than your implementation that adds two lists:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def shiftInPlace(l, n):\n    n = n % len(l)\n    head = l[:n]\n    l[:n] = []\n    l.extend(head)\n    return l\n</code>\n</pre>\n", "senID": 1}, {"text": ["In fact, even adding a l = l[:] to the top of that to operate on a copy of the list passed in is still twice as fast."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "l = l[:]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Various implementations with some timing at http://gist.github.com/288272"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://gist.github.com/288272", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://gist.github.com/288272"}]}], [{"text": ["Possibly a ringbuffer is more suitable.", "It is not a list, although it is likely that it can behave enough like a list for your purposes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The problem is that the efficiency of a shift on a list is O(n), which becomes significant for large enough lists."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Shifting in a ringbuffer is simply updating the head location which is O(1)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If efficiency is your goal, (cycles?", "memory?", ") you may be better off looking at the array module: http://docs.python.org/library/array.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/array.html", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/array.html"}]}, {"text": ["Arrays do not have the overhead of lists.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As far as pure lists go though, what you have is about as good as you can hope to do."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]