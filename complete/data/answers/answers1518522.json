[[{"text": ["A simpler one-liner:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def most_common(lst):\n    return max(set(lst), key=lst.count)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["With so many solutions proposed, I'm amazed nobody's proposed what I'd consider an obvious one (for non-hashable but comparable elements) -- [itertools.groupby][1].", "itertools offers fast, reusable functionality, and lets you delegate some tricky logic to well-tested standard library components.", "Consider for example:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "itertools.groupby", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\nimport operator\n\ndef most_common(L):\n  # get an iterable of (item, iterable) pairs\n  SL = sorted((x, i) for i, x in enumerate(L))\n  # print 'SL:', SL\n  groups = itertools.groupby(SL, key=operator.itemgetter(0))\n  # auxiliary function to get \"quality\" for an item\n  def _auxfun(g):\n    item, iterable = g\n    count = 0\n    min_index = len(L)\n    for _, where in iterable:\n      count += 1\n      min_index = min(min_index, where)\n    # print 'item %r, count %r, minind %r' % (item, count, min_index)\n    return count, -min_index\n  # pick the highest-count/earliest item\n  return max(groups, key=_auxfun)[0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This could be written more concisely, of course, but I'm aiming for maximal clarity.", "The two print statements can be uncommented to better see the machinery in action; for example, with prints uncommented:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "print", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "with", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n print most_common(['goose', 'duck', 'duck', 'goose'])\n</code>\n</pre>\n", "senID": 3}, {"text": ["emits:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n SL: [('duck', 1), ('duck', 2), ('goose', 0), ('goose', 3)]\nitem 'duck', count 2, minind 1\nitem 'goose', count 2, minind 0\ngoose\n</code>\n</pre>\n", "senID": 5}, {"text": ["As you see, SL is a list of pairs, each pair an item followed by the item's index in the original list (to implement the key condition that, if the \"most common\" items with the same highest count are > 1, the result must be the earliest-occurring one)."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "SL", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["groupby groups by the item only (via operator.itemgetter).", "The auxiliary function, called once per grouping during the max computation, receives and internally unpacks a group - a tuple with two items (item, iterable) where the iterable's items are also two-item tuples, (item, original index) [[the items of SL]]."], "childNum": 6, "tag": "p", "senID": 7, "childList": [{"text": "groupby", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "operator.itemgetter", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "max", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "(item, iterable)", "childNum": 0, "tag": "code", "childList": []}, {"text": "(item, original index)", "childNum": 0, "tag": "code", "childList": []}, {"text": "SL", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Then the auxiliary function uses a loop to determine both the count of entries in the group's iterable, and the minimum original index; it returns those as combined \"quality key\", with the min index sign-changed so the max operation will consider \"better\" those items that occurred earlier in the original list."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "and", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "max", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This code could be much simpler if it worried a little less about big-O issues in time and space, e.g....:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "little", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def most_common(L):\n  groups = itertools.groupby(sorted(L))\n  def _auxfun((item, iterable)):\n    return len(list(iterable)), -L.index(item)\n  return max(groups, key=_auxfun)[0]\n</code>\n</pre>\n", "senID": 10}, {"text": ["same basic idea, just expressed more simply and compactly... but, alas, an extra O(N) auxiliary space (to embody the groups' iterables to lists) and O(N squared) time (to get the L.index of every item).", "While premature optimization is the root of all evil in programming, deliberately picking an O(N squared) approach when an O(N log N) one is available just goes too much against the grain of scalability!-)"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "L.index", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Finally, for those who prefer \"oneliners\" to clarity and performance, a bonus 1-liner version with suitably mangled names:-)."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n from itertools import groupby as g\ndef most_common_oneliner(L):\n  return max(g(sorted(L)), key=lambda(x, v):(len(list(v)),-L.index(x)))[0]\n</code>\n</pre>\n", "senID": 13}], [{"text": ["If they are not hashable, you can sort them and do a single loop over the result counting the items (identical items will be next to each other).", "But it might be faster to make them hashable and use a dict."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def most_common(lst):\n    cur_length = 0\n    max_length = 0\n    cur_i = 0\n    max_i = 0\n    cur_item = None\n    max_item = None\n    for i, item in sorted(enumerate(lst), key=lambda x: x[1]):\n        if cur_item is None or cur_item != item:\n            if cur_length &gt; max_length or (cur_length == max_length and cur_i &lt; max_i):\n                max_length = cur_length\n                max_i = cur_i\n                max_item = cur_item\n            cur_length = 1\n            cur_i = i\n            cur_item = item\n        else:\n            cur_length += 1\n    if cur_length &gt; max_length or (cur_length == max_length and cur_i &lt; max_i):\n        return cur_item\n    return max_item\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Sort a copy of the list and find the longest run.", "You can decorate the list before sorting it with the index of each element, and then choose the run that starts with the lowest index in the case of a tie."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n # use Decorate, Sort, Undecorate to solve the problem\n\ndef most_common(iterable):\n    # Make a list with tuples: (item, index)\n    # The index will be used later to break ties for most common item.\n    lst = [(x, i) for i, x in enumerate(iterable)]\n    lst.sort()\n\n    # lst_final will also be a list of tuples: (count, index, item)\n    # Sorting on this list will find us the most common item, and the index\n    # will break ties so the one listed first wins.  Count is negative so\n    # largest count will have lowest value and sort first.\n    lst_final = []\n\n    # Get an iterator for our new list...\n    itr = iter(lst)\n\n    # ...and pop the first tuple off.  Setup current state vars for loop.\n    count = 1\n    tup = next(itr)\n    x_cur, i_cur = tup\n\n    # Loop over sorted list of tuples, counting occurrences of item.\n    for tup in itr:\n        # Same item again?\n        if x_cur == tup[0]:\n            # Yes, same item; increment count\n            count += 1\n        else:\n            # No, new item, so write previous current item to lst_final...\n            t = (-count, i_cur, x_cur)\n            lst_final.append(t)\n            # ...and reset current state vars for loop.\n            x_cur, i_cur = tup\n            count = 1\n\n    # Write final item after loop ends\n    t = (-count, i_cur, x_cur)\n    lst_final.append(t)\n\n    lst_final.sort()\n    answer = lst_final[0][2]\n\n    return answer\n\nprint most_common(['x', 'e', 'a', 'e', 'a', 'e', 'e']) # prints 'e'\nprint most_common(['goose', 'duck', 'duck', 'goose']) # prints 'goose'\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This is the obvious slow solution (O(n^2)) if neither sorting nor hashing is feasible, but equality comparison (==) is available:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "==", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def most_common(items):\n  if not items:\n    raise ValueError\n  fitems = [] \n  best_idx = 0\n  for item in items:   \n    item_missing = True\n    i = 0\n    for fitem in fitems:  \n      if fitem[0] == item:\n        fitem[1] += 1\n        d = fitem[1] - fitems[best_idx][1]\n        if d &gt; 0 or (d == 0 and fitems[best_idx][2] &gt; fitem[2]):\n          best_idx = i\n        item_missing = False\n        break\n      i += 1\n    if item_missing:\n      fitems.append([item, 1, i])\n  return items[best_idx]\n</code>\n</pre>\n", "senID": 1}, {"text": ["But making your items hashable or sortable (as recommended by other answers) would almost always make finding the most common element faster if the length of your list (n) is large.", "O(n) on average with hashing, and O(n*log(n)) at worst for sorting."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A one-liner:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def most_common (lst):\n    return max(((item, lst.count(item)) for item in set(lst)), key=lambda a: a[1])[0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is an O(n) solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n mydict   = {}\ncnt, itm = 0, ''\nfor item in reversed(lst):\n     mydict[item] = mydict.get(item, 0) + 1\n     if mydict[item] &gt;= cnt :\n         cnt, itm = mydict[item], item\n\nprint itm\n</code>\n</pre>\n", "senID": 1}, {"text": ["(reversed is used to make sure that it returns the lowest index item)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You probably don't need this anymore, but this is what I did for a similar problem.", "(It looks longer than it is because of the comments."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n itemList = ['hi', 'hi', 'hello', 'bye']\n\ncounter = {}\nmaxItemCount = 0\nfor item in itemList:\n    try:\n        # Referencing this will cause a KeyError exception\n        # if it doesn't already exist\n        counter[item]\n        # ... meaning if we get this far it didn't happen so\n        # we'll increment\n        counter[item] += 1\n    except KeyError:\n        # If we got a KeyError we need to create the\n        # dictionary key\n        counter[item] = 1\n\n    # Keep overwriting maxItemCount with the latest number,\n    # if it's higher than the existing itemCount\n    if counter[item] &gt; maxItemCount:\n        maxItemCount = counter[item]\n        mostPopularItem = item\n\nprint mostPopularItem\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def most_common(l):\n    max = 0\n    maxitem = None\n    for x in set(l):\n        count =  l.count(x)\n        if count &gt; max:\n            max = count\n            maxitem = x\n    return maxitem\n</code>\n</pre>\n", "senID": 1}, {"text": ["I have a vague feeling there is a method somewhere in the standard library that will give you the count of each element, but I can't find it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; li  = ['goose', 'duck', 'duck']\n\n&gt;&gt;&gt; def foo(li):\n         st = set(li)\n         mx = -1\n         for each in st:\n             temp = li.count(each):\n             if mx &lt; temp:\n                 mx = temp \n                 h = each \n         return h\n\n&gt;&gt;&gt; foo(li)\n'duck'\n</code>\n</pre>\n", "senID": 0}]]