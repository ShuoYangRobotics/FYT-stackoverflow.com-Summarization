[[{"text": ["My initial reaction was to split the list extension and \"filling in the blanks\" into separate parts as so:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i, v in enumerate(my_list):\n    my_list[i] = v or \"Choice %s\" % (i+1)\n\nfor j in range(len(my_list)+1, 10):\n    my_list.append(\"Choice %s\" % (j))\n\n# maybe this is nicer for the extension?\nwhile len(my_list) &lt; 10:\n    my_list.append(\"Choice %s\" % (len(my_list)+1))\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you do stick with the try...except approach, do catch a specific exception as Douglas shows.", "Otherwise, you'll catch everything: KeyboardInterrupts, RuntimeErrors, SyntaxErrors, ... .", "You do not want to do that."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "try...except", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Douglas", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/516039/most-pythonic-way-to-extend-a-potentially-incomplete-list/516070#516070"}, {"text": "everything", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "KeyboardInterrupts", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "RuntimeErrors", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "SyntaxErrors", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["EDIT: fixed 1-indexed list error - thanks DNS!"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/users/51025/dns", "text": "DNS", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["EDIT: added alternative list extension"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Unlike zip, Python's map automatically extends shorter sequences with None."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n map(lambda a, b: b if a is None else a,\n    choicesTxt,\n    ['Choice %i' % n for n in range(1, 10)])\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could simplify the lambda to"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n map(lambda a, b: a or b,\n    choicesTxt,\n    ['Choice %i' % n for n in range(1, 10)])\n</code>\n</pre>\n", "senID": 3}, {"text": ["if it's okay to treat other false-like objects in choicesTxt the same as None."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "choicesTxt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I think I'd do something pretty much like that, but with a few tidy ups:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i in range(0,10):\n  try:\n    if choicesTxt[i] is None:\n      choicesTxt[i] = \"Choice %d\"%i\n  except IndexError:\n    choicesTxt.append(\"Choice %d\"%i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of which the only important two are to only catch IndexError rather than any exception, and to index from 0."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "IndexError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["And the only real problem with the original would be if choicesTxt is empty, when the choices added will be off by one."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "choicesTxt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You could use map (dictionary) instead of list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n choices_map = {1:'Choice 1', 2:'Choice 2', 3:'Choice 12'}\nfor key in xrange(1, 10):\n    choices_map.setdefault(key, 'Choice %d'%key)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you have map filled with your data.", "If you want a list instead you can do:   "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n choices = choices_map.values()\nchoices.sort() #if you want your list to be sorted\n#In Python 2.5 and newer you can do:\nchoices = [choices_map[k] for k in sorted(choices_map)]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I think you should treat resizing the array as a separate step.", "To do so, in the case the array is too short, call choicesTxt=choicesTxt+[None]*(10-len(choicesTxt)).", "The None choice reasignment can be done using list comprehensions."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "choicesTxt=choicesTxt+[None]*(10-len(choicesTxt))", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["Simplest and most pythonic for me is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n repl = lambda i: \"Choice %d\" % (i + 1) # DRY\nprint ([(x or repl(i)) for i, x in enumerate(aList)]\n     + [repl(i) for i in xrange(len(aList), 9)])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["What about that (seems to be a dict -- not a list -- when it's incomplete)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "incomplete", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a = {1:'a', 2:None, 5:'e'} #test data\n[a[x] if x in a and a[x] is not None else 'Choice %d'%x for x in xrange(1,10)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit once more: If it's really a list (not a dict):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n b=['a',None,'b']\n[b[x] if len(b)&gt;x and b[x] is not None else 'Choice %d'%x for x in xrange(10)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["needs Python 2.5 I think (because of the ternary operator)?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["(Thanks to joeforker fixed that it uses keys 1 to 10 and not 0 to 10 anymore; thanks to SilentGhost: in is more pythonic than has_key() or len())"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["If you don't mind replacing anything that evaluates to False with \"Choice %d\", then result works for Python 2.4."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "result", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you do mind and have Python 2.5 and above then use result2_5_plus with the power of ternary if."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "result2_5_plus", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "if", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you don't like or can't use ternary if, then take advantage of the fact that True == 1 and False == 0, using the result of x is None to index a list."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "True == 1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "False == 0", "childNum": 0, "tag": "code", "childList": []}, {"text": "x is None", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n x = [\"Blue\", None, 0, \"\", \"No, Yelloooow!\"]\ny = [None]*9\n\nresult = [(t or \"Choice %d\" % (i+1))\\ \n        for i, t in enumerate(x + y[len(x):])]\n\nresult2_5_plus = [(t if t is not None else \"Choice %d\" % (i+1))\\ \n        for i, t in enumerate(x + y[len(x):])]\n\nresult_no_ternary_if = [[t, \"Choice %d\" % (i+1)][t is None]\\\n    for i, t in enumerate(x + y[len(x):])]\n\n['Blue', 'Choice 2', 'Choice 3', 'Choice 4', 'No, Yelloooow!', 'Choice 6', 'Choice 7', 'Choice 8', 'Choice 9']\n['Blue', 'Choice 2', 0, '', 'No, Yelloooow!', 'Choice 6', 'Choice 7', 'Choice 8', 'Choice 9']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I'm a little unclear about why you're using range(1, 10); since you're using choicesTxt[i], that ends up skipping the None check for the first element in your list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also, there are obviously easier ways to do this if you're creating a new list, but you're asking specifically to add to an existing list."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I don't think this is really cleaner or faster, but it's a different idea for you to think about."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for i, v in enumerate(choicesTxt):\n    choicesTxt[i] = v or \"Choice \" + str(i + 1)\n\nchoicesTxt.extend([ \"Choice \" + str(i) for i in range(len(choicesTxt) + 1, 10) ])\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I would do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i, c in enumerate(choices):\n    if c is None:\n        choices[i] = 'Choice X'\n\nchoices += ['Choice %d' % (i+1) for i in range(len(choices), 10)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["which only replaces actual None values (not anything that evaluates as false), and extends the list in a separated step which I think is clearer."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I find that when list comprehensions get long it's better to just use a standard for loop.", "Nearly the same as others but anyway:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; in_list = [\"a\",\"b\",None,\"c\"]\n&gt;&gt;&gt; full_list = in_list + ([None] * (10 - len(in_list)))\n&gt;&gt;&gt; for idx, value in enumerate(full_list):\n...     if value == None:\n...             full_list[idx] = 'Choice %d' % (idx + 1)\n...\n&gt;&gt;&gt; full_list\n['a', 'b', 'Choice 3', 'c', 'Choice 5', 'Choice 6', 'Choice 7', 'Choice 8', 'Choice 9', 'Choice 10']\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n choices[:] = ([{False: x, True: \"Choice %d\" % (i + 1)}[x is None] for i, x in enumerate(choices)] +\n  [\"Choice %d\" % (i + 1) for i in xrange(len(choices), 9)])\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You could go simpler with a list comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n extendedChoices = choices + ([None] * (10 - len(choices)))\nnewChoices = [\"Choice %d\" % (i+1) if x is None else x\n    for i, x in enumerate(extendedChoices)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This appends None to your choices list until it has at least 10 items, enumerates through the result, and inserts \"Choice X\" if the Xth element is missing."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n def choice_n(index):\n  return \"Choice %d\" % (index + 1)\n\ndef add_choices(lst, length, default=choice_n):\n  \"\"\"\n  &gt;&gt;&gt; add_choices(['a', 'b', None, 'c'], 9)\n  ['a', 'b', 'Choice 3', 'c', 'Choice 5', 'Choice 6', 'Choice 7', 'Choice 8', 'Choice 9']\n  \"\"\"\n\n  for i, v in enumerate(lst):\n    if v is None:\n      lst[i] = default(i)\n\n  for i in range(len(lst), length):\n    lst.append(default(i))\n\n  return lst\n\nif __name__ == \"__main__\":\n  import doctest\n  doctest.testmod()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Well in one line:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["[a or 'Choice %d' % i for a,i in map(None,[\"a\",\"b\",None,\"c\"],range(10))]"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[a or 'Choice %d' % i for a,i in map(None,[\"a\",\"b\",None,\"c\"],range(10))]", "childNum": 0, "tag": "pre", "childList": []}]}, {"text": ["Though that will replace anything that evaluates to False (e.g.", "None, '', 0 etc) with \"Choice n\".", "Best to replace the \"a or 'Choice %d' % i\" with a function if yuo don't want that."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "\"a or 'Choice %d' % i\"", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["The key thing is that map with an argument of None can be used to extend the list to the length needed with None in the required places."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["A tidier (more pythonic) version would be:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["def extend_choices(lst,length):\n    def replace_empty(value,index):\n        if value is None:\n            return 'Choice %d' % index\n        return value\n    return [replace_empty(value,index) for value,index in map(None,lst,range(length))]"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "def extend_choices(lst,length):\n    def replace_empty(value,index):\n        if value is None:\n            return 'Choice %d' % index\n        return value\n    return [replace_empty(value,index) for value,index in map(None,lst,range(length))]", "childNum": 0, "tag": "pre", "childList": []}]}], [{"text": ["I would also recommend using xrange instead of range.", "The xrange function generates the numbers as needed.", "Range generates them in advance.", "For small sets it doesn't make much difference, but for large ranges the savings can be huge."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; in_list = [\"a\",\"b\",None,\"c\"]\n&gt;&gt;&gt; new = ['choice ' + str(i + 1) if j is None else j for i, j in enumerate(in_list)]\n&gt;&gt;&gt; new.extend(('choice ' +str(i + 1) for i in range(len(new), 9)))\n&gt;&gt;&gt; new\n['a', 'b', 'choice 3', 'c', 'choice 5', 'choice 6', 'choice 7', 'choice 8', 'choice 9']\n</code>\n</pre>\n", "senID": 0}], [{"text": ["My two cents..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def extendchoices(clist):\n    clist.extend( [None]*(9-len(clist)) )\n    for i in xrange(9):\n        if clist[i] is None: clist[i] = \"Choice %d\"%(i+1)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If it's ok to replace any false value, eg '' or 0"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; mylist = ['a','b',None,'c']\n&gt;&gt;&gt; map(lambda a,b:a or \"Choice %s\"%b, mylist, range(1,10))\n['a', 'b', 'Choice 3', 'c', 'Choice 5', 'Choice 6', 'Choice 7', 'Choice 8', 'Choice 9']\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you really can only replace for None"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; map(lambda a,b:\"Choice %s\"%b if a is None else a, mylist, range(1,10))\n['a', 'b', 'Choice 3', 'c', 'Choice 5', 'Choice 6', 'Choice 7', 'Choice 8', 'Choice 9']\n</code>\n</pre>\n", "senID": 3}]]