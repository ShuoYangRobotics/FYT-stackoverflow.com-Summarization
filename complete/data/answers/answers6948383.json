[[{"text": ["These data types all serve different purposes, and in an ideal world you might be able to unify them more.", "However, in the real world we need to have efficient implementations of the basic collections, and e.g.", "ordering adds a runtime penalty."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "efficient", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["The named tuples mainly serve to make the interface of stat() and the like more usable, and also can be nice when dealing with SQL row sets."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The big unification you're looking for is actually there, in the form of the different access protocols (getitem, getattr, iter, ...), which these types mix and match for their intended purposes."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can make changes to dictionaries, lists, and sets.", "Tuples cannot be \"changed\" without making a copy."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": ["Mutable: dict, list, set"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}]}, {"text": ["A dictionary, like a set, has no inherent conceptual order to it.", "This is in contrast to lists and tuples, which do have an order.", "The order for the items in a dict or a set is abstracted away from the programmer, meaning that if element A comes before B in a for k in mydata loop, you shouldn't (and can't generally) rely on A being before B once you start making changes to mydata.", "If you iterate over mydata twice in a row it'll be in the same order, but this is more a convenient feature of the mechanics of python, and not really a part of the set abstract data type.", "Lists and tuples do guarantee order though, especially tuples which are immutable."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "abstracted", "childNum": 1, "tag": "strong", "pos": 2, "childList": [{"text": "abstracted", "tag": "em"}]}, {"text": "abstracted", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "for k in mydata", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "mydata", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "mydata", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"tag": "ul", "num": 1, "lis": [{"text": ["Order-preserving: list, tuple"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}]}]}, {"text": ["Also note the following, which I will bring up below."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": ["One \"item\" per \"element\": set, list, tuple"], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}]}]}, {"text": ["I'd say that lists and tuples are the closest of the data types you describe, since from what I understand a tuple is an immutable \"freeze-frame\" version of a list.", "This makes lists useful for data sets that will be changing over time (since you don't have to copy a list to modify it) but tuples useful for things like dictionary keys (which must be immutable types)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["No, there are several differences.", "Dictionaries have no inherent order, which is different from a list, which does."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Also, a dictionary has a key and a value for each \"element\".", "A tuple, on the other hand, can have an arbitrary number of elements, but each with only a value."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Most importantly, though, dictionaries can be changed, while tuples cannot."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Again, I'd stress that sets have no inherent ordering, while lists do.", "This makes lists much more useful for representing things like stacks and queues, where you want to be able to remember the order in which you appended items.", "Sets offer no such guarantee."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["To some degree I agree with you.", "However throughout my experience coding in python I have often found myself coding up custom solutions to represent data cases that were more elegantly represented by, for example, ordered dictionaries.", "I think that adding libraries to support common use-cases for already well-established data structures could be a very good thing; as long as it doesn't get out of hand, and we can still see the unique usefulness in each solution."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["A great example is the Counter() class.", "This specialized dictionary has been of use to me more times than I can count (badoom-tshhhhh!", ") and it has saved me the effort of coding up a custom solution.", "I'd much rather have a solution that the community is helping me to develop and keep with proper python best-practices than something that sits around in my custom data structures folder and only gets used once or twice a year."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["First of all, Ordered Dictionaries and Named Tuples were introduced in Python 2, but that's beside the point."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I won't point you at the docs since if you were really interested you would have read them already."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The first difference between collection types is mutability.", "tuple and frozenset are immutable types.", "This means they can be more efficient than list or set."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "tuple", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "frozenset", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you want something you can access randomly or in order, but will mainly change at the end, you want a list.", "If you want something you can also change at the beginning, you want a deque."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "deque", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You simply can't have your cake and eat it too -- every feature you add causes you to lose some speed."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["dict and set are fundamentally different from lists and tuples`.", "They store the hash of their keys, allowing you to see if an item is in them very quickly, but requires the key be hashable.", "You don't get the same membership testing speed with linked lists or arrays."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "lists", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["When you get to OrderedDict and NamedTuple, you're talking about subclasses of the builtin types implemented in Python, rather than in C. They are for special cases, just like any other code in the standard library you have to import.", "They don't clutter up the namespace but are nice to have when you need them."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "OrderedDict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "NamedTuple", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "any other code in the standard library you have to import", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["One of these days, you'll be coding, and you'll say, \"Man, now I know exactly what they meant by 'There should be one-- and preferably only one --obvious way to do it', a set is just what I needed for this, I'm so glad it's part of the Python language!", "If I had to use a list, it would take forever.", "\" That's when you'll understand why these different types exist."], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "exactly", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "just", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "forever", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}], [{"text": ["A dictionary is indexed by key (in fact, it's a hash map); a generic list of tuples won't be.", "You might argue that both should be implemented as relations, with the ability to add indices at will, but in practice having optimized types for the common use cases is both more convenient and more efficient."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["New specialized collections get added because they are common enough that lots of people would end up implementing them using more basic data types, and then you'd have the usual problems with wheel reinvention (wasted effort, lack of interoperability...).", "And if Python just offered an entirely generic construct, then we'd get lots of people asking \"how do I implement a set using a relation\", etc."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(btw, I'm using relation in the mathematical or DB sense)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["All of these specialized collection types provide specific functionalities that are not adequately or efficiently provided by the \"standard\" data types of list, tuple, dict, and set. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, sometimes you need a collection of unique items, and you also need to retain the order in which you encountered them.", "You can do this using a set to keep track of membership and a list to keep track of order, but your solution will probably be slower and more memory-hungry than a specialized data structure designed for exactly this purpose, such as an ordered set."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["These additional data types, which you see as combinations or variations on the basic ones, actually fill gaps in functionality left by the basic data types.", "From a practical perspective, if Python's core or standard library did not provide these data types, then anyone who needed them would invent their own inefficient versions.", "They are used less often than the basic types, but often enough to make it worth while to provide standard implementations."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["One of the things I like in Python the most is agility.", "And a lot of functional, effective and usable collections types gives it to me."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["And there is still one way to do this - each type does its own job."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The world of data structures (language agnostic) can generally be boiled down to a few small basic structures - lists, trees, hash-tables and graphs, etc.", "and variants and combinations thereof.", "Each has its own specific purpose in terms of use and implementation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I don't think that you can do things like reduce a dictionary to a list of tuples with a particular uniqueness constraint without actually specifying a dictionary.", "A dictionary has a specific purpose - key/value look-ups - and the implementation of the data structure is generally tailored to those needs.", "Sets are like dictionaries in many ways, but certain operations on sets don't make sense on a dictionary (union, disjunction, etc)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I don't see this violating the 'Zen of Python' of doing things one way.", "While you can use a sorted dictionary to do what a dictionary does without using the sorted part, you're more violating Occam's razor and likely causing a performance penalty.", "I see this as different than being able to syntactically do thing different ways a la Perl."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Not remotely.", "There are several different things being done here.", "We choose the right tool for the job.", "All of these containers are modeled on decades-old tried, tested and true CS concepts."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Dictionaries are not like tuples: they are optimized for key-value lookup.", "The tuple is also immutable, which distinguishes it from a list (you could think of it as sort of like a frozenlist).", "If you find yourself converting dictionaries to lists and back, you are almost certainly doing something wrong; an example would help."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "frozenlist", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Named tuples exist for convenience and are intended to replace simple classes rather than dictionaries, really.", "Ordered dictionaries are just a bit of wrapping to remember the order in which things were added to the dictionary.", "And neither is new in 3.x (although there may be better language support for them; I haven't looked)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]