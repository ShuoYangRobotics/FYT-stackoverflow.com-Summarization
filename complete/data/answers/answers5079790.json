[[{"text": ["One could use Python's collections.defaultdict instead of creating an AutoVivification class and then instantiating dictionary as an object of that type."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import collections\ndictionary = collections.defaultdict(lambda: collections.defaultdict(int))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will create a dictionary of dictionaries with a default value of 0.", "When you wish to increment an entry, use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n dictionary[keyword][filename] += 1\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n if (word == keyword and dictionary[keyword][filename] is not None):\n</code>\n</pre>\n", "senID": 0}, {"text": ["that is not a correct usage i guess, instead try this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if (word == keyword and filename in dictionary[keyword]):\n</code>\n</pre>\n", "senID": 2}, {"text": ["Because, checking the value of a non-existing key raise KeyError.", ":so You must check if key exists in dictionary..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I think you are trying to add 1 to a dictionary entry that doesn't yet exist.", "Your getitem method is for some reason returning a new instance of the AutoVivification class when a lookup fails.", "You're therefore trying to add 1 to a new instance of the class. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I think the answer is to update the getitem method so that it sets the counter to 0 if it doesn't yet exist. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class AutoVivification(dict):\n    \"\"\"Implementation of perl's autovivification feature.\"\"\"\n    def __getitem__(self, item):\n        try:\n            return dict.__getitem__(self, item)\n        except KeyError:\n            self[item] = 0\n            return 0\n</code>\n</pre>\n", "senID": 2}, {"text": ["Hope this helps. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Not sure why you need nested dicts here.", "In a typical index scenario you have a forward index mapping"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["document id -> [word_ids]"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["and an inverse index mapping"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["word_id -> [document_ids]"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Not sure if this is related here but using two indexes you can perform all kind of queries\nvery efficiently and the implementation is straight forward since you don't need to deal\nwith nested data structures."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["In the AutoVivification class, you define"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n value = self[item] = type(self)()\nreturn value\n</code>\n</pre>\n", "senID": 1}, {"text": ["which returns an instance of self, which is an AutoVivification in that context.", "The error becomes then clear."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Are you sure you want to return an AutoVivification on any missing key query?", "From the code, I would assume you want to return a normal dictionary with string key and int values."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["By the way, maybe you would be interested in the defaultdict class."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "defaultdict", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html#collections.defaultdict"}]}], [{"text": ["It would be better to kick AutoVivification out all together, because it adds nothing."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "AutoVivification", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The following line:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if (word == keyword and dictionary[keyword][filename] is not None):\n</code>\n</pre>\n", "senID": 2}, {"text": ["Doesn't work as expected, because of the way your class works, dictionary[keyword] will always return an instance of AutoVivification, and so will dictionary[keyword][filename]."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "dictionary[keyword]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "AutoVivification", "childNum": 0, "tag": "code", "childList": []}, {"text": "dictionary[keyword][filename]", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["This AutoVivification class is not the magic you are looking for."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Check out collections.defaultdict from the standard library.", "Your inner dicts should be defaultdicts that default to integer values, and your outer dicts would then be defaultdicts that default to inner-dict values."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "collections.defaultdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n #!/usr/bin/env python\n# encoding: utf-8\nfrom os.path import join\nfrom glob import glob as glob_\nfrom collections import defaultdict, Counter\nfrom string import punctuation\n\nWORKDIR  = 'temp/'\nFILETYPE = '*.html'\nOUTF     = 'doc_{0}'.format\n\ndef extract(text, startTag='&lt;pre&gt;', endTag='&lt;/pre&gt;'):\n    \"\"\"Extract text between start tag and end tag\n\n    Start at first char following first occurrence of startTag\n      If none, begin at start of text\n    End at last char preceding first subsequent occurrence of endTag\n      If none, end at end of text\n    \"\"\"\n    return text.split(startTag, 1)[-1].split(endTag, 1)[0]    \n\ndef main():\n    DocWords = defaultdict(dict)\n\n    infnames = glob_(join(WORKDIR, FILETYPE))\n    for docId,infname in enumerate(infnames, 1):\n        outfname = OUTF(docId)\n        with open(infname) as inf:\n            text = inf.read().lower()\n        words = extract(text).strip(punctuation).split()\n        for wd,num in Counter(words).iteritems():\n            DocWords[wd][outfname] = num\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n", "senID": 0}]]