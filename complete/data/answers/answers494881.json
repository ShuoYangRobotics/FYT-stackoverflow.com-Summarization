[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; from pyfo import pyfo\n&gt;&gt;&gt; d = ('site', { 'name': 'stackoverflow', 'blogger': [ 'Jeff', 'Joel' ] } )\n&gt;&gt;&gt; result = pyfo(d, pretty=True, prolog=True, encoding='ascii')\n&gt;&gt;&gt; print result.encode('ascii', 'xmlcharrefreplace')\n&lt;?xml version=\"1.0\" encoding=\"ascii\"?&gt;\n&lt;site&gt;\n  &lt;blogger&gt;\n    Jeff\n    Joel\n  &lt;/blogger&gt;\n  &lt;name&gt;stackoverflow&lt;/name&gt;\n&lt;/site&gt;\n</code>\n</pre>\n", "senID": 0}, {"text": ["To install pyfo:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "pyfo", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://foss.cpcc.edu/pyfo/"}]}, {"code": "<pre>\n<code>\n $ easy_install pyfo\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I noticed you have commonality in adding items.", "Using this commonality I would refactor adding an item to a separate function."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def addItem(item, name, offset):\n          if isinstance(item, dict):\n                lines.append(offset + u\"&lt;%s&gt;\" % name)\n                addDict(item, offset + u\" \" * 4)\n                lines.append(offset + u\"&lt;/%s&gt;\" % name)\n          else:\n                lines.append(offset + u\"&lt;%s&gt;%s&lt;/%s&gt;\" % (name, escape(unicodify(item)), name))\n\ndef addList(value,name, offset):\n        for item in value:\n            addItem(item, name, offset)\n\ndef addDict(node, offset):\n        for name, value in node.iteritems():\n            if isinstance(value, list):\n                addList(value, name, offset)\n            else:\n                addItem(value, name, offset)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Advisory warning: this code is not tested or written by anybody who actually uses Python."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["To get rid of repeated \"offset+\":"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n offset = 0\ndef addLine(str):\n    lines.append(u\" \" * (offset * 4) + str\n</code>\n</pre>\n", "senID": 1}, {"text": ["then"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ...\n    addLine(u\"&lt;%s&gt;\" % name)\n    offset = offset + 1\n    addDict(value)\n    offset = offset - 1\n    addLine(u\"&lt;/%s&gt;\" % name)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Don't have access to an interpreter here, so take this with a grain of salt :("], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Your original code produce malformed XML and can produce the same XML for two different dictionaries (is not injective, speaking mathematically)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "injective", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["For example, if you have a list as a value of the only key in a dictionary:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n d = { 'list': [1,2,3] }\n</code>\n</pre>\n", "senID": 2}, {"text": ["I expect that your code would produce"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &lt;list&gt;1&lt;/list&gt;&lt;list&gt;2&lt;/list&gt;&lt;list&gt;3&lt;/list&gt;\n</code>\n</pre>\n", "senID": 4}, {"text": ["and there is no root element.", "Any XML should have one and only one root element."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Then given the XML produced by your code, it is impossible to say if this XML"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &lt;tag&gt;1&lt;/tag&gt;\n</code>\n</pre>\n", "senID": 7}, {"text": ["was produced from { 'tag': 1 }  or from { 'tag': [1] }."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "{ 'tag': 1 }", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "{ 'tag': [1] }", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So, I suggest"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "always start from the root element", "tag": "none", "senID": 10}, {"text": "represent lists with either two special tags (e.g. ", "tag": "none", "senID": 11}]}, {"text": ["Then, after decisions about these conceptual shortcomings we can generate correct and unambiguous XML.", "I chose to use attributes to markup lists, and used ElementTree to construct the XML tree automatically.", "Also, recursion helps (add_value_to_xml is called recursively):"], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "conceptual", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "add_value_to_xml", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n from xml.etree.ElementTree import Element, SubElement, tostring\n\ndef is_scalar(v):\n    return isinstance(v,basestring) or isinstance(v,float) \\\n        or isinstance(v,int) or isinstance(v,bool)\n\ndef add_value_to_xml(root,v):\n    if type(v) == type({}):\n        for k,kv in v.iteritems():\n            vx = SubElement(root,unicode(k))\n            vx = add_value_to_xml(vx,kv)\n    elif type(v) == list:\n        root.set('type','list')\n        for e in v:\n            li = SubElement(root,root.tag)\n            li = add_value_to_xml(li,e)\n            li.set('type','item')\n    elif is_scalar(v):\n        root.text = unicode(v)\n    else:\n        raise Exception(\"add_value_to_xml: unsuppoted type (%s)\"%type(v))\n    return root\n\ndef dict_to_xml(d,root='dict'):\n    x = Element(root)\n    x = add_value_to_xml(x,d)\n    return x\n\nd = { 'float': 5194.177, 'str': 'eggs', 'int': 42,\n        'list': [1,2], 'dict': { 'recursion': True } }\nx = dict_to_xml(d)\nprint tostring(x)\n</code>\n</pre>\n", "senID": 13}, {"text": ["The result of the conversion of the test dict is:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n &lt;dict&gt;&lt;int&gt;42&lt;/int&gt;&lt;dict&gt;&lt;recursion&gt;True&lt;/recursion&gt;&lt;/dict&gt;&lt;float&gt;5194.177&lt;/float&gt;&lt;list type=\"list\"&gt;&lt;list type=\"item\"&gt;1&lt;/list&gt;&lt;list type=\"item\"&gt;2&lt;/list&gt;&lt;/list&gt;&lt;str&gt;eggs&lt;/str&gt;&lt;/dict&gt;\n</code>\n</pre>\n", "senID": 15}], [{"text": ["Here is my short sketch for a solution:\nhave a general addSomething() function that dispatches based on the type of the value to addDict(), addList() or addElse().", "Those functions recursively call addSomething() again."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "addSomething()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "addDict()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "addList()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "addElse()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "addSomething()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Basically you are factoring out the parts in the if clause and add a recursive call."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Here's what I find helpful when working with XML.", "Actually create the XML node structure first, then render this into text second."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This separates two unrelated concerns."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It's hard when you put these two things together into one function.", "If, on the other hand, you separate them, then you have two things.", "First, you have a considerably simpler function to \"walk\" your Python structure and return an XML node.", "Your XML Nodes can be rendered into text with some preferred encoding and formatting rules applied."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from xml.sax.saxutils import escape\n\nclass Node( object ):\n    def __init__( self, name, *children ):\n        self.name= name\n        self.children= children\n    def toXml( self, indent ):\n        if len(self.children) == 0:\n            return u\"%s&lt;%s/&gt;\" % ( indent*4*u' ', self.name )\n        elif len(self.children) == 1:\n            child= self.children[0].toXml(0)\n            return u\"%s&lt;%s&gt;%s&lt;/%s&gt;\" % ( indent*4*u' ', self.name, child, self.name )\n        else:\n            items = [ u\"%s&lt;%s&gt;\" % ( indent*4*u' ', self.name ) ]\n            items.extend( [ c.toXml(indent+1) for c in self.children ] )\n            items.append( u\"%s&lt;/%s&gt;\" % ( indent*4*u' ', self.name ) )\n            return u\"\\n\".join( items )\n\nclass Text( Node ):\n    def __init__( self, value ):\n        self.value= value\n    def toXml( self, indent ):\n        def unicodify(o):\n            if o is None:\n                return u'';\n            return unicode(o)\n        return \"%s%s\" % ( indent*4*u' ', escape( unicodify(self.value) ), )\n\ndef dictToXml(d):\n\n    def dictToNodeList(node):\n        nodes= []\n        for name, value in node.iteritems():\n            if isinstance(value, dict):\n                n= Node( name, *dictToNodeList( value ) )\n                nodes.append( n )\n            elif isinstance(value, list):\n                for item in value:\n                    if isinstance(item, dict):\n                        n= Node( name, *dictToNodeList( value ) )\n                        nodes.append( n )\n                    else:\n                        n= Node( name, Text( item ) )\n                        nodes.append( n )\n            else:\n                n= Node( name, Text( value ) )\n                nodes.append( n )\n        return nodes\n\n    return u\"\\n\".join( [ n.toXml(0) for n in dictToNodeList(d) ] )\n</code>\n</pre>\n", "senID": 3}]]