[[{"text": ["Here it is as an O(n) (average case) generator expression.", "The others are all roughly O(n2)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "O(n)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "2", "childNum": 0, "tag": "sup", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n chars = set()\nstring = \"aaaaa\"\nnewstring = ''.join(chars.add(char) or char for char in string if char not in chars)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It works because set.add returns None, so the or will always cause the character to be yielded from the generator expression when the character isn't already in the set."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "set.add", "tag": "a", "pos": 0, "childList": [{"text": "set.add", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#set.add"}, {"text": "set.add", "childNum": 0, "tag": "code", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}, {"text": "or", "childNum": 0, "tag": "code", "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: Also see refaim's solutions.", "My solution is like his second one, but it uses the set in the opposite way."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["My take on his OrderedDict solution:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "OrderedDict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n ''.join(OrderedDict((char, None) for char in word))\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Here is an inefficient method:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n x = 'eventually'\nnewx = ''.join([c for i,c in enumerate(x) if c not in x[:i]])\n</code>\n</pre>\n", "senID": 1}, {"text": ["I don't think that there is an efficient way to do it in a list comprehension."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Without list comprehensions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import OrderedDict\n\nword = 'eventually'\nprint ''.join(OrderedDict(zip(word, range(len(word)))).keys())\n</code>\n</pre>\n", "senID": 1}, {"text": ["With list comprehensions (quick and dirty solution):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n word = 'eventually'\nuniq = set(word)\nprint ''.join(c for c in word if c in uniq and not uniq.discard(c))\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; s='eventually'\n&gt;&gt;&gt; \"\".join([c for i,c in enumerate(s) if i==s.find(c)])\n'evntualy'\n</code>\n</pre>\n", "senID": 0}, {"text": ["note that using a list comprehension with join() is silly when you can just use a generator expression.", "You should tell your teacher to update their question"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "join()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You could make a set from the string, then join it together again.", "This works since sets can only contain unique values.", "The order wont be the same though: "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "The order wont be the same though", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n In [1]: myString = \"mississippi\"\n\nIn [2]: set(myString))\nOut[2]: set(['i', 'm', 'p', 's'])\n\nIn [3]: print \"\".join(set(myString))\nOut[3]: ipsm\n\nIn [4]: set(\"iowa\")\nOut[4]: set(['a', 'i', 'o', 'w'])\n\nIn [5]: set(\"eventually\")\nOut[5]: set(['a', 'e', 'l', 'n', 't', 'u', 'v', 'y'])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: Just saw the \"List Comprehension\" in the title so this probably isnt what your looking for."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Create a set from the original string, and then sort by position of character in original string:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s='eventually'\n&gt;&gt;&gt; ''.join(sorted(set(s), key=s.index))\n'evntualy'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Taken from this question, I think this is the fastest way:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/480214/how-do-you-remove-duplicates-from-a-list-in-python-whilst-preserving-order"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def remove_dupes(str):\n...    chars = set()\n...    chars_add = chars.add\n...    return ''.join(c for c in str if c not in chars and not chars_add(c))\n... \n&gt;&gt;&gt; remove_dupes('hello')\n'helo'\n&gt;&gt;&gt; remove_dupes('testing')\n'tesing'\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n word = \"eventually\"\nevntualy = ''.join(\n     c \n     for d in [dict(zip(word, word))] \n         for c in word \n     if d.pop(c, None) is not None)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Riffing off of agf's (clever) solution but without making a set outside of the generator expression:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n evntualy = ''.join(s.add(c) or c for s in [set()] for c in word if c not in s)\n</code>\n</pre>\n", "senID": 2}]]