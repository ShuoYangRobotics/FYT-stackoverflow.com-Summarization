[[{"text": ["To explain why your script isn't working right now, I'll rename the variable unsorted to sorted."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "unsorted", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sorted", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["At first, your list isn't yet sorted.", "Of course, we set sorted to False."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "sorted", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["As soon as we start the while loop, we assume that the list is already sorted.", "The idea is this: as soon as we find two elements that are not in the right order, we set sorted back to False.", "sorted will remain True only if there were no elements in the wrong order."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "while", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sorted", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sorted", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "childList": []}, {"text": "only if there were no elements in the wrong order", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n sorted = False  # We haven't started sorting yet\n\nwhile not sorted:\n    sorted = True  # Assume the list is now sorted\n    for element in range(0, length):\n        if badList[element] &gt; badList[element + 1]:\n            sorted = False  # We found two elements in the wrong order\n            hold = badList[element + 1]\n            badList[element + 1] = badList[element]\n            badList[element] = hold\n    # We went through the whole list. At this point, if there were no elements\n    # in the wrong order, sorted is still True. Otherwise, it's false, and the\n    # while loop executes again.\n</code>\n</pre>\n", "senID": 3}, {"text": ["There are also minor little issues that would help the code be more efficient or readable."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": ["In the for loop, you use the variable element.", "Technically, element is not an element; it's a number representing a list index.", "Also, it's quite long.", "In these cases, just use a temporary variable name, like i for \"index\"."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "element", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "element", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "i", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["The range command can also take just one argument (named stop).", "In that case, you get a list of all the integers from 0 to that argument."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "range", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "stop", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The Python Style Guide recommends that variables be named in lowercase with underscores.", "This is a very minor nitpick for a little script like this; it's more to get you accustomed to what Python code most often resembles."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Python Style Guide", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0008/"}]}, {"text": ["To swap the values of two variables, write them as a tuple assignment.", "The right hand side gets evaluated as a tuple (say, (badList[i+1], badList[i]) is (3, 5)) and then gets assigned to the two variables on the left hand side ((badList[i], badList[i+1]))."], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "(badList[i+1], badList[i])", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "(3, 5)", "childNum": 0, "tag": "code", "childList": []}, {"text": "(badList[i], badList[i+1])", "childNum": 0, "tag": "code", "childList": []}]}]}, {"text": ["Put it all together, and you get this:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n my_list = [12, 5, 13, 8, 9, 65]\n\ndef bubble(bad_list):\n    length = len(bad_list) - 1\n    sorted = False\n\n    while not sorted:\n        sorted = True\n        for i in range(length):\n            if bad_list[i] &gt; bad_list[i+1]:\n                sorted = False\n                bad_list[i], bad_list[i+1] = bad_list[i+1], bad_list[i]\n\nbubble(my_list)\nprint my_list\n</code>\n</pre>\n", "senID": 10}, {"text": ["(I removed your print statement too, by the way."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["The goal of bubble sort is to move the heavier items at the bottom in each round, while moving the lighter items up.", "In the inner loop, where you compare the elements, you don't have to iterate the whole list in each turn.", "The heaviest is already placed last.", "The swapped variable is an extra check so we can mark that the list is now sorted and avoid continuing with unnecessary calculations."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "heavier", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "lighter", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "you don't have to iterate the whole list in each turn", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "heaviest", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "swapped", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n def bubble(badList):\n    length = len(badList)\n    for i in range(0,length):\n        swapped = False\n        for element in range(0, length-i-1):\n            if badList[element] &gt; badList[element + 1]:\n                hold = badList[element + 1]\n                badList[element + 1] = badList[element]\n                badList[element] = hold\n                swapped = True\n        if not swapped: break\n\n    return badList\n</code>\n</pre>\n", "senID": 1}, {"text": ["Your version 1, corrected:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def bubble(badList):\n    length = len(badList) - 1\n    unsorted = True\n    while unsorted:\n        unsorted = False\n        for element in range(0,length):\n            #unsorted = False\n            if badList[element] &gt; badList[element + 1]:\n                 hold = badList[element + 1]\n                 badList[element + 1] = badList[element]\n                 badList[element] = hold\n                 unsorted = True\n                 #print badList\n             #else:\n                 #unsorted = True\n\n     return badList\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This is what happens when you use variable name of negative meaning, you need to invert their values.", "The following would be easier to understand:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sorted = False\nwhile not sorted:\n    ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["On the other hand, the logic of the algorithm is a little bit off.", "You need to check whether two elements swapped during the for loop.", "Here's how I would write it:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def bubble(values):\n    length = len(values) - 1\n    sorted = False\n    while not sorted:\n        sorted = True\n        for element in range(0,length):\n            if values[element] &gt; values[element + 1]:\n                 hold = values[element + 1]\n                 values[element + 1] = values[element]\n                 values[element] = hold\n                 sorted = False\n    return values\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Your use of the Unsorted variable is wrong; you want to have a variable that tells you if you have swapped two elements; if you have done that, you can exit your loop, otherwise, you need to loop again.", "To fix what you've got here, just put the \"unsorted = false\" in the body of your if case; remove your else case; and put \"unsorted = true before your for loop."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You've got a couple of errors in there.", "The first is in length, and the second is in your use of unsorted (as stated by McWafflestix).", "You probably also want to return the list if you're going to print it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n mylist = [12, 5, 13, 8, 9, 65]\n\ndef bubble(badList):\n    length = len(badList) - 2\n    unsorted = True\n\n    while unsorted:\n        for element in range(0,length):\n            unsorted = False\n\n            if badList[element] &gt; badList[element + 1]:\n                hold = badList[element + 1]\n                badList[element + 1] = badList[element]\n                badList[element] = hold\n                print badList\n                unsorted = True\n\n    return badList\n\nprint bubble(mylist)\n</code>\n</pre>\n", "senID": 1}, {"text": ["eta: You're right, the above is buggy as hell.", "My bad for not testing through some more examples."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def bubble2(badList):\n    swapped = True\n    length = len(badList) - 2\n\n    while swapped:\n        swapped = False\n        for i in range(0, length):\n            if badList[i] &gt; badList[i + 1]:\n\n                # swap\n                hold = badList[i + 1]\n                badList[i + 1] = badList[i]\n                badList[i] = hold\n\n                swapped = True\n\n    return badList\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Answers provided by the-fury and Martin Cote fixed the problem of the infinite loop, but my code would still not work correctly (for a larger list, it would not sort correctly.).", "I ended up ditching the unsorted variable and used a counter instead."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "unsorted", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def bubble(badList):\n    length = len(badList) - 1\n    n = 0\n    while n &lt; len(badList):\n    \tfor element in range(0,length):\n    \t\tif badList[element] &gt; badList[element + 1]:\n    \t\t\thold = badList[element + 1]\n    \t\t\tbadList[element + 1] = badList[element]\n    \t\t\tbadList[element] = hold\n    \t\t\tn = 0\n    \t\telse:\n    \t\t\tn += 1\n    return badList\n\nif __name__ == '__main__':\n    mylist = [90, 10, 2, 76, 17, 66, 57, 23, 57, 99]\n    print bubble(mylist)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If anyone could provide any pointers on how to improve my code in the comments, it would be much appreciated."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n def bubble_sort(l):\n    for passes_left in range(len(l)-1, 0, -1):\n        for index in range(passes_left):\n            if l[index] &lt; l[index + 1]:\n               l[index], l[index + 1] = l[index + 1], l[index]\n    return l\n</code>\n</pre>\n", "senID": 0}]]