[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; ''.join('1' if x == '0' else '0' for x in '1000110')\n'0111001'\n</code>\n</pre>\n", "senID": 0}, {"text": ["The a for b in c pattern is a generator expression, which produces a series of items based on a different series.", "In this case, the original series is the characters (since you can iterate over strings in Python, which gives you the characters that make up that string), and the new series is a set of characters with the 0's and 1's flipped."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "a for b in c", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "generator expression", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["'1' if x == '0' else '0' is pretty straightforward - it gives us whichever of 1 or 0 isn't x.", "We do this for each such x in the original set of characters, and then join() them all together (with an empty string '', a.k.a.", "nothing, in between each item), thus giving us a final string which is all of the opposite characters from the original, combined."], "childNum": 7, "tag": "p", "senID": 2, "childList": [{"text": "'1' if x == '0' else '0'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "join()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "''", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Another way to do it is with string.translate() and string.maketrans()"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "string.translate()", "tag": "a", "pos": 0, "childList": [{"text": "string.translate()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#str.translate"}, {"text": "string.translate()", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/string.html#string.maketrans", "text": "string.maketrans()", "childNum": 1, "tag": "a", "childList": [{"text": "string.maketrans()", "tag": "code"}]}, {"text": "string.maketrans()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from string import maketrans\nbitString = \"10101010100011010\"\nflippedString = bitString.translate(maketrans(\"10\",\"01\"))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Amber's answer, while superior, possibly isn't the most clear, so here's a super basic iterative example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n b_string = \"1100101\"\nib_string = \"\"\n\nfor bit in b_string:\n  if bit == \"1\":\n    ib_string += \"0\"\n  else:\n    ib_string += \"1\"\n\nprint ib_string\n</code>\n</pre>\n", "senID": 1}, {"text": ["This can be done in much better ways...replacements, comprehensions, but this is an example."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "much better", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I would learn from the other answers in this question once you understand the basis of this one.", "This method is slow and painful.", "For the best performance, as Muhammad Alkarouri pointed out, the string.translate/maketrans combo is the way to go.", "Right behind it is the comprehension.", "My code is the slowest by a significant margin."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "best", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "Muhammad Alkarouri", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "string.translate", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "maketrans", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["http://docs.python.org/library/string.html#string.replace"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/string.html#string.replace", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/string.html#string.replace"}]}, {"text": ["Replace all the 1's with 2's, then replace the 0's with 1's, finally replacing the 2's with 0's."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n \"10011\".replace(\"1\", \"2\").replace(\"0\", \"1\").replace(\"2\", \"0\")\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Using a dictionary should be very straightforward."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; flip={\"1\":\"0\",\"0\":\"1\"}\n&gt;&gt;&gt; s=\"100011\"\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; for i in s:\n...   sys.stdout.write(flip[i])\n...\n011100\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Along the lines of Amber, but using ASCII arithmetic (for no particular reason).", "This obviously isn't meant for production code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ''.join(chr(97 - ord(c)) for c in my_bit_string)\n</code>\n</pre>\n", "senID": 1}, {"text": ["48 and 49 are the ASCII (and Unicode) values for '0' and '1' respectively.", "ord gives you the numeric value for a character, while chr does the reverse."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "ord", "tag": "a", "pos": 1, "childList": [{"text": "ord", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#ord"}, {"text": "ord", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/functions.html#chr", "text": "chr", "childNum": 1, "tag": "a", "childList": [{"text": "chr", "tag": "code"}]}, {"text": "chr", "childNum": 0, "tag": "code", "childList": []}]}]]