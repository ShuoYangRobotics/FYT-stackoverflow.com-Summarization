[[{"text": ["Do you want to define these individually in your source file, statically?", "Then your best option would be to write a script to generate them."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If on the other hand you want these functions at runtime you can use a higher order function.", "For e.g. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def make_func(value_to_print):\n    def _function():\n        print value_to_print\n    return _function\n\n&gt;&gt;&gt; f1 = make_func(1)\n&gt;&gt;&gt; f1()\n1\n&gt;&gt;&gt; f2 = make_func(2)\n&gt;&gt;&gt; f2()\n2\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can generate a list of these and store, again at runtime."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; my_functions = [make_func(i) for i in range(1, 11)]\n&gt;&gt;&gt; for each in my_functions:\n    each()\n\n\n1\n2\n3\n...\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Here's another two line answer that produces function names exactly like you wanted (and is a bit simpler than the \"Dynamic/runtime method creation\" answer pointed out by @Goutham):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "exactly", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n fntemplate = \"\"\"def activate_field_%d(): print %d\"\"\"\nfor x in range(1, 11): exec fntemplate % (x,x)\n\n&gt;&gt;&gt; activate_field_1()\n1\n&gt;&gt;&gt; activate_field_7()\n7\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Maybe you could adapt this recipe for your needs."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from functools import partial\nclass FunctionPool:\n    def __init__(self,function):\n        self.function = function\n    def __getitem__(self,item):\n        return partial(self.function,item)\n\n&gt;&gt;&gt; @FunctionPool\ndef func(item,param):\n    print \"function#{item} called with {param}\".format(\n        item = item,\n        param = param )\n&gt;&gt;&gt; f = func[2]\n&gt;&gt;&gt; f(3)\nfunction#2 called with 3\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You may put new symbols into the dictionary of current variable bindings returned by vars():"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "vars()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for i in range(1, 11):\n    def f(x):\n        def g():\n            print x\n        return g\n    vars()['activate_field_%d' % i] = f(i)\n\n&gt;&gt;&gt; activate_field_3()\n3\n</code>\n</pre>\n", "senID": 1}, {"text": ["But this trick is generally not recommented unless you definitely sure you need it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["How about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import print_function\n\nactivate_field_ = [lambda i=i: print(i) for i in range(11)]\n\nfor x in range(1, 11):\n    activate_field_[x]()\n</code>\n</pre>\n", "senID": 1}, {"text": ["This creates one extra function, activate_field_[0] which prints '0', but you can just not use it."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "activate_field_[0]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["There's already a thread that talks about dynamic code generation in detail.", "Refer: http://stackoverflow.com/questions/533382/dynamic-runtime-method-creation-code-generation-in-python"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://stackoverflow.com/questions/533382/dynamic-runtime-method-creation-code-generation-in-python", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/533382/dynamic-runtime-method-creation-code-generation-in-python"}]}]]