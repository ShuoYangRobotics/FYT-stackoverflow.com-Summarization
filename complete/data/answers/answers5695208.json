[[{"code": "<pre>\n<code>\n values = set(map(lambda x:x[1], list))\nnewlist = [[y[0] for y in list if y[1]==x] for x in values]\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n from operator import itemgetter\nfrom itertools import groupby\n\nlki = [[\"A\",0], [\"B\",1], [\"C\",0], [\"D\",2], [\"E\",2]]\nlki.sort(key=itemgetter(1))\n\nglo = [[x for x,y in g]\n       for k,g in  groupby(lki,key=itemgetter(1))]\n\nprint glo\n</code>\n</pre>\n", "senID": 0}, {"text": [], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["EDIT"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Another solution that needs no import , is more readable, keeps the orders, and is 22 % less long than the preceding one:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n oldlist = [[\"A\",0], [\"B\",1], [\"C\",0], [\"D\",2], [\"E\",2]]\n\nnewlist, dicpos = [],{}\nfor val,k in oldlist:\n    if k in dicpos:\n        newlist[dicpos[k]].extend(val)\n    else:\n        newlist.append([val])\n        dicpos[k] = len(dicpos)\n\nprint newlist\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Howard's answer is concise and elegant, but it's also O(n^2) in the worst case.", "For large lists with large numbers of grouping key values, you'll want to sort the list first and then use itertools.groupby: "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.groupby", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import groupby\n&gt;&gt;&gt; from operator import itemgetter\n&gt;&gt;&gt; seq = [[\"A\",0], [\"B\",1], [\"C\",0], [\"D\",2], [\"E\",2]]\n&gt;&gt;&gt; seq.sort(key = itemgetter(1))\n&gt;&gt;&gt; groups = groupby(seq, itemgetter(1))\n&gt;&gt;&gt; [[item[0] for item in data] for (key, data) in groups]\n[['A', 'C'], ['B'], ['D', 'E']]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I changed this after seeing eyequem's answer:  itemgetter(1) is nicer than lambda x: x[1]."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "itemgetter(1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "lambda x: x[1]", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n len = max(key for (item, key) in list)\nnewlist = [[] for i in range(len+1)]\nfor item,key in list:\n  newlist[key].append(item)\n</code>\n</pre>\n", "senID": 0}, {"text": ["You can do it in a single list comprehension, perhaps more elegant but O(n**2):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n [[item for (item,key) in list if key==i] for i in range(max(key for (item,key) in list)+1)]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I don't know about elegant, but it's certainly doable:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n oldlist = [[\"A\",0], [\"B\",1], [\"C\",0], [\"D\",2], [\"E\",2]]\n# change into: list = [[\"A\", \"C\"], [\"B\"], [\"D\", \"E\"]]\n\norder=[]\ndic=dict()\nfor value,key in oldlist:\n  try:\n    dic[key].append(value)\n  except KeyError:\n    order.append(key)\n    dic[key]=[value]\nnewlist=map(dic.get, order)\n\nprint newlist\n</code>\n</pre>\n", "senID": 1}, {"text": ["This preserves the order of the first occurence of each key, as well as the order of items for each key.", "It requires the key to be hashable, but does not otherwise assign meaning to it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import collections\n&gt;&gt;&gt; D1 = collections.defaultdict(list)\n&gt;&gt;&gt; for element in L1:\n...     D1[element[1]].append(element[0])\n... \n&gt;&gt;&gt; L2 = D1.values()\n&gt;&gt;&gt; print L2\n[['A', 'C'], ['B'], ['D', 'E']]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}]]