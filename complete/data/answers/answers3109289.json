[[{"text": ["Solution"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Make one of the function's default arguments be a reference to the function itself."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def f(self):\n    return self.x\nf.func_defaults = (f,)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Example usage:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; f.x = 17\n&gt;&gt;&gt; b = f\n&gt;&gt;&gt; del f\n&gt;&gt;&gt; b()\n17\n</code>\n</pre>\n", "senID": 4}, {"text": ["Explanation"], "childNum": 0, "tag": "h2", "senID": 5, "childList": []}, {"text": ["The original poster wanted a solution that does not require a global name lookup.", "The simple solution"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def f():\n    return f.x\n</code>\n</pre>\n", "senID": 7}, {"text": ["performs a lookup of the global variable f on each call, which does not meet the requirements.", "If f is deleted, then the function fails.", "The more complicated inspect proposal fails in the same way."], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "f", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "inspect", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["What we want is to perform early binding and store the bound reference within the object itself.", "The following is conceptually what we are doing:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "early binding", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def f(self=f):\n    return self.x\n</code>\n</pre>\n", "senID": 10}, {"text": ["In the above, self is a local variable, so no global lookup is performed.", "However, we can't write the code as-is, because f is not yet defined when we try to bind the default value of self to it.", "Instead, we set the default value after f is defined."], "childNum": 4, "tag": "p", "senID": 11, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Decorator"], "childNum": 0, "tag": "h2", "senID": 12, "childList": []}, {"text": ["Here's a simple decorator to do this for you.", "Note that the self argument must come last, unlike methods, where self comes first.", "This also means that you must give a default value if any of your other arguments take a default value."], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def self_reference(f):\n    f.func_defaults = f.func_defaults[:-1] + (f,)\n    return f\n\n@self_reference\ndef foo(verb, adverb='swiftly', self=None):\n    return '%s %s %s' % (self.subject, verb, adverb)\n</code>\n</pre>\n", "senID": 14}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; foo.subject = 'Fred'\n&gt;&gt;&gt; bar = foo\n&gt;&gt;&gt; del foo\n&gt;&gt;&gt; bar('runs')\n'Fred runs swiftly'\n</code>\n</pre>\n", "senID": 16}], [{"text": ["You could just use a class to do this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class F(object):\n...     def __call__(self, *args, **kw):\n...         return self._x\n... \n&gt;&gt;&gt; f=F()\n&gt;&gt;&gt; f._x = \"foo\"\n&gt;&gt;&gt; f()\n'foo'\n&gt;&gt;&gt; g=f\n&gt;&gt;&gt; del f\n&gt;&gt;&gt; g()\n'foo'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Well, let's look at what function is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo():\n...     return x\n... \n&gt;&gt;&gt; foo.x = 777\n&gt;&gt;&gt; foo.x\n777\n&gt;&gt;&gt; foo()\nTraceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;interactive input&gt;\", line 2, in foo\nNameError: global name 'x' is not defined\n&gt;&gt;&gt; dir(foo)\n['__call__', '__class__', '__delattr__', '__dict__', '__doc__', '__get__', \n'__getattribute__', '__hash__', '__init__', '__module__', '__name__', '__new__', \n'__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__str__', \n'func_closure', 'func_code', 'func_defaults', 'func_dict', 'func_doc', \n'func_globals', 'func_name', 'x']\n&gt;&gt;&gt; getattr(foo, 'x')\n777\n</code>\n</pre>\n", "senID": 1}, {"text": ["Aha!", "So the attribute was added to the function object but it won't see it because it is looking for global x instead."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["We can try to grab the frame of the function execution and try to look what's there (essentially what Anthony Kong suggested but w/o inspect module):"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "inspect", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo():\n...     import sys\n...     return sys._getframe()\n... \n&gt;&gt;&gt; fr = foo()\n&gt;&gt;&gt; dir(fr)\n['__class__', '__delattr__', '__doc__', '__getattribute__', '__hash__', '__init__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__str__', 'f_back', 'f_builtins', 'f_code', 'f_exc_traceback', 'f_exc_type', 'f_exc_value', 'f_globals', 'f_lasti', 'f_lineno', 'f_locals', 'f_restricted', 'f_trace']\n&gt;&gt;&gt; fr.f_locals\n{'sys': &lt;module 'sys' (built-in)&gt;}\n&gt;&gt;&gt; fr.f_code\n&lt;code object foo at 01753020, file \"&lt;interactive input&gt;\", line 1&gt;\n&gt;&gt;&gt; fr.f_code.co_code\n'd\\x01\\x00d\\x00\\x00k\\x00\\x00}\\x00\\x00|\\x00\\x00i\\x01\\x00\\x83\\x00\\x00S'\n&gt;&gt;&gt; fr.f_code.co_name\n'foo'\n</code>\n</pre>\n", "senID": 4}, {"text": ["Aha!", "So maybe we can get the name of the function from the name of the code block and then look in round-about way for the attribute?", "Sure enough:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; getattr(fr.f_globals[fr.f_code.co_name], 'x')\n777\n&gt;&gt;&gt; fr.f_globals[fr.f_code.co_name].x\n777\n&gt;&gt;&gt; def foo():\n...     import sys\n...     frm = sys._getframe()\n...     return frm.f_globals[frm.f_code.co_name].x\n... \n&gt;&gt;&gt; foo.x=777\n&gt;&gt;&gt; foo()\n777\n</code>\n</pre>\n", "senID": 6}, {"text": ["That's great!", "But would it stand the renaming and deletion of original function?"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; g = foo\n&gt;&gt;&gt; g.func_name\n'foo'\n&gt;&gt;&gt; g.func_code.co_name\n'foo'\n</code>\n</pre>\n", "senID": 8}, {"text": ["Ah, very doubtful.", "The function object and its code object still insist they are called foo.", "Sure enough, here is where it breaks:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; g.x\n777\n&gt;&gt;&gt; g.x=888\n&gt;&gt;&gt; foo.x\n888\n&gt;&gt;&gt; g()\n888\n&gt;&gt;&gt; del foo\n&gt;&gt;&gt; g()\nTraceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;interactive input&gt;\", line 4, in foo\nKeyError: 'foo'\n</code>\n</pre>\n", "senID": 10}, {"text": ["Dang!", "So in general it can't be done through introspection via the execution frames.", "The problems seems to be that there is a difference between function object and code object - code objects are what is executed and is just one attribute func_code of the function-object and as such has no access to the func_dict attribute, where our attribute x is:"], "childNum": 5, "tag": "p", "senID": 11, "childList": [{"text": "function object", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "code object", "childNum": 0, "tag": "em", "childList": []}, {"text": "func_code", "childNum": 0, "tag": "code", "childList": []}, {"text": "func_dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; g\n&lt;function foo at 0x0173AE30&gt;\n&gt;&gt;&gt; type(g)\n&lt;type 'function'&gt;\n&gt;&gt;&gt; g.func_code\n&lt;code object foo at 017532F0, file \"&lt;interactive input&gt;\", line 1&gt;\n&gt;&gt;&gt; type(g.func_code)\n&lt;type 'code'&gt;\n&gt;&gt;&gt; g.func_dict\n{'x': 888}\n</code>\n</pre>\n", "senID": 12}, {"text": ["There is of course other chicanery you can do so that it seems as function - in particular the trick with class definition... but that is not a function per se.", "It all depends on what do you really need to do with that."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["As a workaround you could use a factory function to fix your scope:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def factory():\n    def inner():\n        print inner.x\n    return inner\n\n\n&gt;&gt;&gt; foo=factory()\n&gt;&gt;&gt; foo.x=11\n&gt;&gt;&gt; foo()\n11\n&gt;&gt;&gt; bar = foo\n&gt;&gt;&gt; del foo\n&gt;&gt;&gt; bar()\n11\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I doubt this is the best way to accomplish this, but you can access the attributes by using the method's name within the method:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "best", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo():\n...   print foo.x\n... \n&gt;&gt;&gt; foo()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 2, in foo\nAttributeError: 'function' object has no attribute 'x'\n&gt;&gt;&gt; foo.x = 5\n&gt;&gt;&gt; foo()\n5\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The answer is rather simple.", "Just use the fact name is looked for at execution time, not compile time:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f():\n    return f._x\n\nf._x = \"foo\"\nf()           # -&gt; \"foo\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Why would you want to do such a thing?", "Why not passing it as parameter?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f(SOMETHING):\n    return SOMETHING\n\nf('foo')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Although functions are first class objects, I would not treat them as such in the sense of using properties.", "This is what classes are for."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It definitely does not increase readability of your code!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you want it to be totally independent of the function name, you need some frame magic.", "For example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f2():\n    import inspect\n    frame = inspect.currentframe()\n    fname = frame.f_code.co_name\n    fobj = frame.f_globals[fname]\n    print fobj._x\n\n\nf2._x = 2\nf2()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's a decorator that injects current_fun into the functions globals before executing the function.", "It's quite the hack, but also quite effective."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from functools import wraps\n\n\ndef introspective(f):\n    @wraps(f)\n    def wrapper(*args, **kwargs):\n        exists = 'current_fun' in f.func_globals\n        old = f.func_globals.get('current_fun',None)\n        f.func_globals['current_fun'] = wrapper\n        try:\n            return f(*args, **kwargs)\n        finally:\n            if exists:\n                f.func_globals['current_fun'] = old\n            else:\n                del f.func_globals['current_fun']\n    return wrapper\n\n@introspective\ndef f():\n    print 'func_dict is ',current_fun.func_dict\n    print '__dict__ is ',current_fun.__dict__\n    print 'x is ',current_fun.x\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here's a usage example"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n In [41]: f.x = 'x'\n\nIn [42]: f()\nfunc_dict is  {'x': 'x'}\n__dict__ is  {'x': 'x'}\nx is  x\n\nIn [43]: g = f\n\nIn [44]: del f\n\nIn [45]: g()\nfunc_dict is  {'x': 'x'}\n__dict__ is  {'x': 'x'}\nx is  x\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This uses a bit of a hackish approach, but it's possibly the most correct so far given that it works with the g() call as well.", "It works because it's relying on whatever bytecode inspection is performed by the dis module, as a shortcut."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "g()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dis", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/release/2.6.5/library/dis.html#module-dis"}]}, {"text": ["It looks more hackish than it really is partly because the dis.disassemble() call prints to stdout, so I redirect that into a StringIO.", "I use disassemble() for its feature of highlighting the last instruction (add a print text line in there to see how it looks) and that makes it easier to grab the previous LOAD_NAME and the variable it used."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "dis.disassemble()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "disassemble()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "print text", "childNum": 0, "tag": "code", "childList": []}, {"text": "LOAD_NAME", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It would be possible to use a cleaner bytecode inspection library to do this without using the dis module at all, but this proves that it's possible.", "This might not be the most robust approach, but then again maybe it will work in most cases.", "I haven't spent enough time poking into Python internals or bytecode to know whether most CALL_FUNCTION bytecodes are preceded immediately by instructions that the regex trick would pick out."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "dis", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "CALL_FUNCTION", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n import inspect\nimport dis\nimport re\nimport sys\nimport StringIO\n\ndef f():\n    caller = inspect.stack()[1][0]\n    sys.stdout = StringIO.StringIO()\n    dis.disassemble(caller.f_code, caller.f_lasti)\n    text = sys.stdout.getvalue()\n    sys.stdout = sys.__stdout__\n    match = re.search(r'LOAD_NAME.*\\((.*?)\\)\\s+--&gt;', text)\n    name = match.group(1)\n    try:\n        func = caller.f_locals[name]\n    except KeyError:\n        func = caller.f_globals[name]\n    return func._x\n\nf._x = 'foo'\nprint 'call f():', f()\ng = f\ndel f\nprint 'call g():', g()\n</code>\n</pre>\n", "senID": 3}, {"text": ["This generates the following output:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n call f(): foo\ncall g(): foo\n</code>\n</pre>\n", "senID": 5}]]