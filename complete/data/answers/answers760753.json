[[{"text": ["A generator function would be neat:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def batch_gen(data, batch_size):\n    for i in range(0, len(data), batch_size):\n            yield data[i:i+batch_size]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a = \"abcdef\"\nfor i in batch_gen(a, 2): print i\n</code>\n</pre>\n", "senID": 3}, {"text": ["prints:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n ab\ncd\nef\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I've got an alternative approach, that works for iterables that don't have a known length. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def groupsgen(seq, size):\n    it = iter(seq)\n    while True:\n        values = ()        \n        for n in xrange(size):\n            values += (it.next(),)        \n        yield values\n</code>\n</pre>\n", "senID": 1}, {"text": ["It works by iterating over the sequence (or other iterator) in groups of size, collecting the values in a tuple.", "At the end of each group, it yield the tuple."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["When the iterator runs out of values, it produces a StopIteration exception which is then propagated up, indicating that groupsgen is out of values."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["It assumes that the values come in sets of size (sets of 2, 3, etc).", "If not, any values left over are just discarded."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Don't forget about the zip() function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = 'abcdef'\nfor x,y in zip(a[::2], a[1::2]):\n  print '%s%s' % (x,y)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["but the more general way would be (inspired by this answer):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/756550/multiple-tuple-to-two-pair-tuple-in-python/756602#756602"}]}, {"code": "<pre>\n<code>\n for i in zip(*(seq[i::size] for i in range(size))):\n    print(i)                            # tuple of individual values\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I am sure someone is going to come up with some more \"Pythonic\" but how about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for y in range(0, len(x), 2):\n    print \"%s%s\" % (x[y], x[y+1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that this would only work if you know that len(x) % 2 == 0;"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "len(x) % 2 == 0;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["you can create the following generator"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def chunks(seq, size):\n    a = range(0, len(seq), size)\n    b = range(size, len(seq) + 1, size)\n    for i, j in zip(a, b):\n        yield seq[i:j]\n</code>\n</pre>\n", "senID": 1}, {"text": ["and use it like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for i in chunks('abcdef', 2):\n    print(i)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Responses to this question show a few methods."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/756550/multiple-tuple-to-two-pair-tuple-in-python"}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; a = \"abcdef\"\n&gt;&gt;&gt; size = 2\n&gt;&gt;&gt; [a[x:x+size] for x in range(0, len(a), size)]\n['ab', 'cd', 'ef']\n</code>\n</pre>\n", "senID": 0}, {"text": ["..or, not as a list comprehension:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a = \"abcdef\"\nsize = 2\noutput = []\nfor x in range(0, len(a), size):\n    output.append(a[x:x+size])\n</code>\n</pre>\n", "senID": 2}, {"text": ["Or, as a generator, which would be best if used multiple times (for a one-use thing, the list comprehension is probably \"best\"):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def chunker(thelist, segsize):\n    for x in range(0, len(thelist), segsize):\n            yield thelist[x:x+segsize]\n</code>\n</pre>\n", "senID": 4}, {"text": ["..and it's usage:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for seg in chunker(a, 2):\n...     print seg\n... \nab\ncd\nef\n</code>\n</pre>\n", "senID": 6}], [{"text": ["And then there's always the documentation."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html"}]}, {"code": "<pre>\n<code>\n def pairwise(iterable):\n    \"s -&gt; (s0,s1), (s1,s2), (s2, s3), ...\"\n    a, b = tee(iterable)\n    try:\n        b.next()\n    except StopIteration:\n        pass\n    return izip(a, b)\n\ndef grouper(n, iterable, padvalue=None):\n    \"grouper(3, 'abcdefg', 'x') --&gt; ('a','b','c'), ('d','e','f'), ('g','x','x')\"\n    return izip(*[chain(iterable, repeat(padvalue, n-1))]*n)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note: these produce tuples instead of substrings, when given a string sequence as input."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["One solution, although I challenge someone to do better ;-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = 'abcdef'\nb = [[a[i-1], a[i]] for i in range(1, len(a), 2)]\n\nfor x, y in b:\n  print \"%s%s\\n\" % (x, y)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about itertools?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import islice, groupby\n\ndef chunks_islice(seq, size):\n    while True:\n        aux = list(islice(seq, 0, size))\n        if not aux: break\n        yield \"\".join(aux)\n\ndef chunks_groupby(seq, size):\n    for k, chunk in groupby(enumerate(seq), lambda x: x[0] / size):\n        yield \"\".join([i[1] for i in chunk])\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n s = 'abcdefgh'\nfor e in (s[i:i+2] for i in range(0,len(s),2)):\n  print(e)\n</code>\n</pre>\n", "senID": 0}]]