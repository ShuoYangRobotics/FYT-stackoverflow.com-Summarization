[[{"text": ["The calendar works like this.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def month_year_iter( start_month, start_year, end_month, end_year ):\n    ym_start= 12*start_year + start_month - 1\n    ym_end= 12*end_year + end_month - 1\n    for ym in range( ym_start, ym_end ):\n        y, m = divmod( ym, 12 )\n        yield y, m+1\n</code>\n</pre>\n", "senID": 1}, {"text": ["All multiple-unit things work like this.", "Feet and Inches, Hours, Minutes and Seconds, etc., etc.", "The only thing that's not this simple is months-days or months-weeks because months are irregular.", "Everything else is regular, and you need to work in the finest-grained units."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "not", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}], [{"text": ["Perhaps the elegance or speed of this could be improved, but it's the straightforward solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def months(start_month, start_year, end_month, end_year):\n    month, year = start_month, start_year\n    while True:\n        yield month, year\n        if (month, year) == (end_month, end_year):\n            return\n        month += 1\n        if (month &gt; 12):\n            month = 1\n            year += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: And here's a less straightforward one that avoids even needing to use yield by using a generator comprehension:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def months2(start_month, start_year, end_month, end_year):\n    return (((m_y % 12) + 1, m_y / 12) for m_y in\n            range(12 * start_year + start_month - 1, 12 * end_year + end_month))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["A simpler version of dfan's approach, and also a simpler solution than S. Lott's (no division, no modulo):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def months(start_month, start_year, end_month, end_year):\n\n    month, year = start_month, start_year\n\n    while (year, month) &lt;= (end_year, end_month):\n\n        yield month, year\n\n        month += 1\n        if month &gt; 12:\n            month = 1\n            year += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["This approach is close to the method one would use if they had to do this by hand.", "It runs in the same amount of time as S. Lott's (the tests in the code above take about as much time as a division and a modulo)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This isn't as short as the other solutions, but it's straightforward to understand.", "Basically, it has two branches."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "The start year is the same as the end year", "tag": "none", "senID": 1}, {"text": "The start year is different from the end year", "tag": "none", "senID": 2}]}, {"text": ["The latter case has three phases:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "From the start month to December of the start year", "tag": "none", "senID": 4}, {"text": "Every month from each year between the start year to the end year", "tag": "none", "senID": 5}, {"text": "From January to the end month of the end year", "tag": "none", "senID": 6}]}, {"text": ["If the end year is the year after the start year, the second phase above is skipped (no need for an explicit test, the range is simply empty)."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def months(start_month, start_year, end_month, end_year):\n    if start_year == end_year:\n        for month in xrange(start_month, end_month+1):\n           yield month, start_year\n    else:\n        for month in xrange(start_month, 13):\n            yield month, start_year\n        for year in xrange(start_year+1, end_year):\n            for month in xrange(1, 13):\n               yield month, year\n        for month in xrange(1, end_month+1):\n           yield end_month, end_year\n</code>\n</pre>\n", "senID": 8}, {"text": ["For Python 3.x, change xrange to range."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "xrange", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "range", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Your question is a little ambiguous in that you ask for an iterator, but then show a function returning a tuple of tuples.", "So here's both:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import calendar\nimport datetime\n\ndef months_iter(start_month, start_year, end_month, end_year):\n    start_date = datetime.date(start_year, start_month, 1)\n    end_date = datetime.date(end_year, end_month, 1)\n    date = start_date\n    while date &lt;= end_date:\n        yield (date.month, date.year)\n        days_in_month = calendar.monthrange(date.year, date.month)[1]\n        date += datetime.timedelta(days_in_month)\n\ndef months(start_month, start_year, end_month, end_year):\n    return tuple(d for d in months_iter(start_month, start_year, end_month, end_year))\n\nprint months(8, 2010, 3, 2011)\n\n# ((8, 2010), (9, 2010), (10, 2010), (11, 2010), (12, 2010), (1, 2011), (2, 2011), (3, 2011))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Having a little fun with Python built-in iterators, but certainly not elegant ;)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["from datetime import timedelta, date"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class MonthRange:\n    def __init__ (self, date1, date2):\n        self.start_date = date1 - timedelta(days=1)\n        self.end_date = date2\n        self.data = self.start_date\n    def __iter__(self):\n        return self\n    def next(self):\n        if self.data &gt;= self.end_date.replace(day=1) + timedelta(days=32):\n            raise StopIteration\n        ret = self.data\n        self.data = self.data + timedelta(days=32)\n        return ret.replace(day=1)\n\nfor x in MonthRange(date.today(), date(2012, 11, 01)):\n    print (x.year, x.month)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["months function using the dateutil module"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "months", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dateutil", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from dateutil.rrule import rrule, MONTHLY\nfrom datetime import datetime\n\ndef months(start_month, start_year, end_month, end_year):\n    start = datetime(start_year, start_month, 1)\n    end = datetime(end_year, end_month, 1)\n    return [(d.month, d.year) for d in rrule(MONTHLY, dtstart=start, until=end)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example Usage"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n print months(11, 2010, 2, 2011)\n#[(11, 2010), (12, 2010), (1, 2011), (2, 2011)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or in iterator form"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def month_iter(start_month, start_year, end_month, end_year):\n    start = datetime(start_year, start_month, 1)\n    end = datetime(end_year, end_month, 1)\n\n    return ((d.month, d.year) for d in rrule(MONTHLY, dtstart=start, until=end))\n</code>\n</pre>\n", "senID": 5}, {"text": ["Iterator usage"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n for m in month_iter(11, 2010, 2, 2011):\n    print m\n    #(11, 2010)\n    #(12, 2010)\n    #(1, 2011)\n    #(2, 2011)\n</code>\n</pre>\n", "senID": 7}]]