[[{"text": ["In this case you do have a way to avoid try/except, although I wouldn't recommend it (assuming your input string is named s, and you're in a function that must return something):"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "try", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "except", "childNum": 0, "tag": "code", "childList": []}, {"text": "s", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n xs = s.strip()\nif xs[0:1] in '+-': xs = xs[1:]\nif xs.isdigit(): return int(s)\nelse: ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["the ... part in the else is where you return whatever it is you want if, say, s was 'iamnotanumber', '23skidoo', empty, all-spaces, or the like."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "...", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "else", "childNum": 0, "tag": "code", "childList": []}, {"text": "s", "childNum": 0, "tag": "code", "childList": []}, {"text": "'iamnotanumber'", "childNum": 0, "tag": "code", "childList": []}, {"text": "'23skidoo'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Unless a lot of your input strings are non-numbers, try/except is better:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n try: return int(s)\nexcept ValueError: ...\n</code>\n</pre>\n", "senID": 4}, {"text": ["you see the gain in conciseness, and in avoiding the fiddly string manipulation and test!-)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I see many answers do int(s.strip()), but that's supererogatory: the stripping's not needed!"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "int(s.strip())", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; int('  23  ')\n23\n</code>\n</pre>\n", "senID": 7}, {"text": ["int knows enough to ignore leading and trailing whitespace all by itself!-)"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["int('243\\r\\n'.strip())"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "int('243\\r\\n'.strip())", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["But that won't help you, if something else than a number is passed.", "Always put try, except and catch ValueError."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "ValueError", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Anyway, this also works: int('243\\n\\r  '), so maybe you don't even need strip."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "int('243\\n\\r  ')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "strip", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["EDIT:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Why don't you just write your own function, that will catch the exception and return a sane default and put into some utils module?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n try:\n    x=int(\"234\\r\\n\".strip())\nexcept ValueError:\n    x=0\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n import re\nint(re.sub(r'[^\\d-]+', '', your_string))\n</code>\n</pre>\n", "senID": 0}, {"text": ["This will strip everything except for numbers and the \"-\" sign.", "If you can be sure that there won't be ever any excess characters except for whitespace, use gruszczy's method instead. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You could just:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def to_int(unsafe_string):\n    return int(unsafe_string.strip())\n</code>\n</pre>\n", "senID": 1}, {"text": ["But it will throw a ValueError if the stripped unsafe_string is not a valid number.", "You can of course catch the ValueError and do what you like with it."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "ValueError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "unsafe_string", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Without knowing what kinds of inputs you are expecting, it's hard to say what is 'enough' to solve this.", "If you are just worried about trailing newlines, then Xavier Combelle's or gruszczy's answer is enough:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    x = int(value)\nexcept ValueError:\n    x = 0\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you have to find any integer, anywhere in a string, then you might need something like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import re\ntry:\n    x = int(re.search(r'(0|(-?[1-9][0-9]*))', searchstring).group(0))\nexcept TypeError: # Catch exception if re.search returns None\n    x = 0\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Under Python 3.0 (IDLE) this worked nicely"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "br", "senID": 1}, {"text": ["If you're dealing with input you cannot trust, you never should anyway, then it's a good idea to use try, except, pass blocks to control exceptions when users provide incompatible data.", "It might server you better to think about try, except, pass structures as defensive measures for protecting data compatibility rather than simply hidding errors."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I hope this helps."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]