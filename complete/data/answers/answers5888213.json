[[{"text": ["You could define a function for the action required by each regex and do something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def dostuff():\n    stuff\n\ndef dootherstuff():\n    otherstuff\n\ndef doevenmorestuff():\n    evenmorestuff\n\nactions = ((regex1, dostuff), (regex2, dootherstuff), (regex3, doevenmorestuff))\n\nfor regex, action in actions:\n    m = re.match(regex, line)\n    if m: \n        action()\n        break\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would break your regex up into smaller components and search for simple first with longer matches later. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if re.match(simplepart,line):\n      if re.match(complexregex, line):\n          do stuff\nelif re.match(othersimple, line):\n      if re.match(complexother, line):\n          do other stuff\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n for patt in (regex1, regex2, regex3):\n    match = patt.match(line)\n    if match:\n        if patt == regex1:\n            # some handling\n        elif patt == regex2:\n            # more\n        elif patt == regex3:\n            # more\n        break\n</code>\n</pre>\n", "senID": 0}, {"text": ["I like Tim's answer because it separates out the per-regex matching code to keep things simple.", "For my answer, I wouldn't put more than a line or two of code for each match, and if you need more, call a separate method."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Why not use a dictionnary/switch statement ?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def action1(stuff):\n    do the stuff 1\ndef action2(stuff):\n    do the stuff 2\n\nregex_action_dict = {regex1 : action1, regex2 : action2}\nfor regex, action in regex_action_dict.iteritems():\n    match_object = re.match(regex, line):\n    if match_object:\n        action(match_object, line)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["First off, do you really need to use regexps for your matching?", "Where I would use regexps in, e.g., perl, I'll often use string functions in python (find, startswith, etc)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you really need to use regexps, you can make a simple search function that does the search, and if the match is returned, sets a store object to keep your match around before returning True."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["e.g.,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def search(pattern, s, store):\n    match = re.search(pattern, s)\n    store.match = match\n    return match is not None\n\nclass MatchStore(object):\n    pass   # irrelevant, any object with a 'match' attr would do\n\nwhere = MatchStore()\nif search(pattern1, s, where):\n    pattern1 matched, matchobj in where.match\nelif search(pattern2, s, where):\n    pattern2 matched, matchobj in where.match\n...\n</code>\n</pre>\n", "senID": 3}], [{"text": ["FWIW, I've stressed over the same thing, and I usually settle for the 2nd form (nested elses) or some variation.", "I don't think you'll find anything much better in general, if you're looking to optimize readability (many of these answers seem significantly less readable than your candidates to me)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "else", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Sometimes if you're in an outer loop or a short function, you can use a variation of your 3rd form (the one with break statements) where you either continue or return, and that's readable enough, but I definitely wouldn't create a while True block just to avoid the \"ugliness\" of the other candidates."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "break", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "continue", "childNum": 0, "tag": "code", "childList": []}, {"text": "return", "childNum": 0, "tag": "code", "childList": []}, {"text": "while True", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["My solution with an exemple; there is only one re.search() that is performed:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re.search()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n text = '''\\\nkoala + image @ wolf - snow\nGood evening, ladies and gentlemen\nAn uninteresting line\nThere were 152 ravens on a branch\nsea mountain sun ocean ice hot desert river'''\n\nimport re\nregx3 = re.compile('hot[ \\t]+([^ ]+)')\nregx2 = re.compile('(\\d+|ev.+?ng)')\nregx1 = re.compile('([%~#`\\@+=\\d]+)')\nregx  = re.compile('|'.join((regx3.pattern,regx2.pattern,regx1.pattern)))\n\ndef one_func(line):\n    print 'I am one_func on : '+line\n\ndef other_func(line):\n    print 'I am other_func on : '+line\n\ndef another_func(line):\n    print 'I am another_func on : '+line\n\ntupl_funcs = (one_func, other_func, another_func) \n\n\nfor line in text.splitlines():\n    print line\n    m = regx.search(line)\n    if m:\n        print 'm.groups() : ',m.groups()\n        group_number = (i for i,m in enumerate(m.groups()) if m).next()\n        print \"group_number : \",group_number\n        tupl_funcs[group_number](line)\n    else:\n        print 'No match'\n        print 'No treatment'\n    print\n</code>\n</pre>\n", "senID": 1}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n koala + image @ wolf - snow\nm.groups() :  (None, None, '+')\ngroup_number :  2\nI am another_func on : koala + image @ wolf - snow\n\nGood evening, ladies and gentlemen\nm.groups() :  (None, 'evening', None)\ngroup_number :  1\nI am other_func on : Good evening, ladies and gentlemen\n\nAn uninteresting line\nNo match\nNo treatment\n\nThere were 152 ravens on a branch\nm.groups() :  (None, '152', None)\ngroup_number :  1\nI am other_func on : There were 152 ravens on a branch\n\nsea mountain sun ocean ice hot desert river\nm.groups() :  ('desert', None, None)\ngroup_number :  0\nI am one_func on : sea mountain sun ocean ice hot desert river\n</code>\n</pre>\n", "senID": 3}], [{"text": ["In this particular case there appears to be no convenient way to do this in python.", "if python would accept the syntax: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if (m = re.match(pattern,string)):\n    text = m.group(1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["then all would be fine, but apparently you\ncannot do that"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]