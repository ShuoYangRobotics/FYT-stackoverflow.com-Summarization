[[{"text": ["Tuples are immutable; you can't change which variables they contain after construction.", "However, you can concatenate or slice them to form new tuples:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = (1, 2, 3)\nb = a + (4, 5, 6)\nc = b[1:]\n</code>\n</pre>\n", "senID": 1}, {"text": ["And, of course, build them from existing values:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n name = \"Joe\"\n   age = 40\n   location = \"New York\"\n   joe = (name, age, location)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["It's as easy as the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n info_1 = \"one piece of info\"\ninfo_2 = \"another piece\"\nvars = (info_1, info_2)\n# 'vars' is now a tuple with the values (\"info_1\", \"info_2\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, tuples in Python are immutable, so you cannot append variables to a tuple once it is created."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "immutable", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["You can start with a blank tuple with something like t = ().", "You can add with +, but you have to add another tuple.", "If you want to add a single element, make it a singleton: t = t + (element,).", "You can add a tuple of multiple elements with or without that trailing comma."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; t = ()\n&gt;&gt;&gt; t = t + (1,)\n&gt;&gt;&gt; t\n(1,)\n&gt;&gt;&gt; t = t + (2,)\n&gt;&gt;&gt; t\n(1, 2)\n&gt;&gt;&gt; t = t + (3, 4, 5)\n&gt;&gt;&gt; t\n(1, 2, 3, 4, 5)\n&gt;&gt;&gt; t = t + (6, 7, 8,)\n&gt;&gt;&gt; t\n(1, 2, 3, 4, 5, 6, 7, 8)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm pretty sure the syntax for this in python is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n user_input1 = raw_input(\"Enter Name: \")\nuser_input2 = raw_input(\"Enter Value: \")\ninfo = (user_input1, user_input2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["once set, tuples cannot be changed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As other answers have noted, you cannot change an existing tuple, but you can always create a new tuple (which may take some or all items from existing tuples and/or other sources)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, if all the items of interest are in scalar variables and you know the names of those variables:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def maketuple(variables, names):\n  return tuple(variables[n] for n in names)\n</code>\n</pre>\n", "senID": 2}, {"text": ["to be used, e.g, as in this example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def example():\n  x = 23\n  y = 45\n  z = 67\n  return maketuple(vars(), 'x y z'.split())\n</code>\n</pre>\n", "senID": 4}, {"text": ["of course this one case would be more simply expressed as (x, y, z) (or even foregoing the names altogether, (23, 45, 67)), but the maketuple approach might be useful in some more complicated cases (e.g.", "where the names to use are also determined dynamically and appended to a list during the computation)."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "(x, y, z)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(23, 45, 67)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "maketuple", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["\" once the info is added to the DB, should I delete the tuple?", "i mean i dont need the tuple anymore."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\" once the info is added to the DB, should I delete the tuple? i mean i dont need the tuple anymore.\"", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["No."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Generally, there's no reason to delete anything.", "There are some special cases for deleting, but they're very, very rare."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Simply define a narrow scope (i.e., a function definition or a method function in a class) and the objects will be garbage collected at the end of the scope."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Don't worry about deleting anything."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["[Note.", "I worked with a guy who -- in addition to trying to delete objects -- was always writing \"reset\" methods to clear them out.", "Like he was going to save them and reuse them.", "Also a silly conceit.", "Just ignore the objects you're no longer using.", "If you define your functions in small-enough blocks of code, you have nothing more to think about."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]