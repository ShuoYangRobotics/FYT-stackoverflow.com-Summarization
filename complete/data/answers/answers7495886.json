[[{"text": ["You can't change the globals without affecting all other users of the module, but what you sort of can do is create a private copy of the whole module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "can", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I trust you are familiar with sys.modules, and that if you remove a module from there, Python forgets it was imported, but old objects referencing it will continue to do so.", "When imported again, a new copy of the module will be made."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "sys.modules", "tag": "a", "pos": 0, "childList": [{"text": "sys.modules", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/sys.html#sys.modules"}, {"text": "sys.modules", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["A hacky solution to your problem could would be something like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import sys\nimport threading\n\n# Remove the original module, but keep it around\nmain_threading = sys.modules.pop('threading')\n\n# Get a private copy of the module\nimport threading as private_threading\n\n# Cover up evidence by restoring the original\nsys.modules['threading'] = main_threading\n\n# Modify the private copy\nprivate_threading._allocate_lock = my_allocate_lock()\n</code>\n</pre>\n", "senID": 3}, {"text": ["And now, private_threading.Lock has globals entirely separate from threading.Lock!"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "private_threading.Lock", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "threading.Lock", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Needless to say, the module wasn't written with this in mind, and especially with a system module such as threading you might run into problems.", "For example, threading._active is supposed to contain all running threads, but with this solution, neither _active will have them all.", "The code may also eat your socks and set your house on fire, etc.", "Test rigorously."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "threading", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "threading._active", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "_active", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Okay, here's a proof-of-concept that shows how to do it.", "Note that it only goes one level deep -- properties and nested functions are not adjusted.", "To implement that, as well as make this more robust, each function's globals() should be compared to the globals() that should be replaced, and only make the substitution if they are the same."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def migrate_class(cls, globals):\n    \"\"\"Recreates a class substituting the passed-in globals for the\n    globals already in the existing class.  This proof-of-concept\n    version only goes one-level deep (i.e. properties and other nested\n    functions are not changed).\"\"\"\n    name = cls.__name__\n    bases = cls.__bases__\n    new_dict = dict()\n    if hasattr(cls, '__slots__'):\n        new_dict['__slots__'] = cls.__slots__\n        for name in cls.__slots__:\n            if hasattr(cls, name):\n                attr = getattr(cls, name)\n                if callable(attr):\n                    closure = attr.__closure__\n                    defaults = attr.__defaults__\n                    func_code = attr.__code__\n                    attr = FunctionType(func_code, globals)\n                new_dict[name] = attr\n    if hasattr(cls, '__dict__'):\n        od = getattr(cls, '__dict__')\n        for name, attr in od.items():\n            if callable(attr):\n                closure = attr.__closure__\n                defaults = attr.__defaults__\n                kwdefaults = attr.__kwdefaults__\n                func_code = attr.__code__\n                attr = FunctionType(func_code, globals, name, defaults, closure)\n                if kwdefaults:\n                    attr.__kwdefaults__ = kwdefaults\n            new_dict[name] = attr\n    return type(name, bases, new_dict)\n</code>\n</pre>\n", "senID": 1}, {"text": ["After having gone through this excercise, I am really curious as to why you need to do this?"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "really", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["\"One cannot change these globals without changing it for all the classes in that module.", "\" That's the root of the problem isn't it, and a good explanation of the problem with global variables in general.", "The use of globals in threading tethers its classes to those global objects. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "global", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "globals", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["By the time you jerry-rig something to find and monkey patch each use of a global variable within an individual class from the module, are you any further ahead of just reimplementing the code for your own use?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The only work around that \"might\" be of use in your situation is something like mock.", "Mock's patch decorators/context managers (or something similar) could be used to swap out a global variable for the life-time of a given object.", "It works well within the very controlled context of unit testing, but in any other circumstances I wouldn't recommend it and would think about just reimplementing the code to suit my needs."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "mock", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.voidspace.org.uk/python/mock/patch.html"}]}], [{"text": ["Globals are bad for exactly this reason, as I am sure you know well enough. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I'd try to reimplement A and B (maybe by subclassing them) in my own module and with all references to \nmy_global replaced by an injected dependency on A and B, which I'll call registry here."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class A(orig.A):\n\n    def __init__(self, registry):\n        self.registry = registry\n        self.registry.append(self)\n\n    # more updated methods\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you are creating all instances of A yourself you are pretty much done.", "You might want to create a factory which hides away the new init parameter."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n my_registry = []\ndef A_in_my_registry():\n    return A(my_registry)\n</code>\n</pre>\n", "senID": 4}, {"text": ["If foreign code creates orig.A instances for you, and you would rather have new A instances, you have to hope the foreign code is customizeable\nwith factories.", "If not, derive from the foreign classes and update them to use (newly injected) A factories instead.", ".... And rinse repeat for for the creation of those updated classes.", "I realize this can be tedious to almost impossible depending on the complexity of the foreign code, but most std libs are quite flat."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["--"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Edit: Monkey patch std lib code."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["If you don't mind monkey patching std libs, you could also try to modifiy the original classes to work\nwith a redirection level which defaults to the original globals, but is customizable per instance:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n import orig\n\nclass A(orig.A):\n\n    def __init__(self, registry=orig.my_globals):\n        self.registry = registry\n        self.registry.append(self)\n\n    # more updated methods\n\norig.A = A\n</code>\n</pre>\n", "senID": 9}, {"text": ["As before you will need to control creations of A which should use non \"standard globals\",\nbut you won't have different A classes around as long as you monkey patch early enough."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["If you use Python 3, you can subclass B and redefine the __globals__ attribute of the __init__ method like this:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__globals__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from module_a import B\n\nfunction = type(lambda: 0)  # similar to 'from types import FunctionType as function', but faster\nmy_global = []\n\n\nclass My_B (B):\n    __init__ = function(B.__init__.__code__, globals(), '__init__',  B.__init__.__defaults__, B.__init__.__closure__)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["IMHO it is not possible to override global variables..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Globals are rarely a good idea."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Implicit variables are rarely a good idea."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["An implicitly-used  global is easy to indict as also \"rarely good\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Additionally, you don't want A.__init__() doing anything \"class-level\" like updating some mysterious collection that exists for the class as a whole.", "That's often a bad idea.   "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "A.__init__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Rather than mess with implicit class-level collection, you want a Factory in module_a that (1) creates A or B instances and (b) updates an explicit collection."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "Factory", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "module_a", "childNum": 0, "tag": "code", "childList": []}, {"text": "A", "childNum": 0, "tag": "code", "childList": []}, {"text": "B", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You can then use this factory in module_b, except with a different collection."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "module_b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This can promote testability by exposing an implicit dependency."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["module_a.py"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n class Factory( object ):\n    def __init__( self, collection ):\n        self.collection= collection\n    def make( self, name, *args, **kw ):\n        obj= eval( name )( *args, **kw )\n        self.collection.append( obj )\n        return obj\n\nmodule_collection = []\nfactory= Factory( module_collection )\n</code>\n</pre>\n", "senID": 8}, {"text": ["module_b.py"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n module_collection = []\nfactory = module_a.Factory( module_collection )\n</code>\n</pre>\n", "senID": 10}, {"text": ["Now a client can do this"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n import module_b\na = module_b.factory.make( \"A\" )\nb = module_b.factory.make( \"B\" )\nprint( module_b.module_collection )\n</code>\n</pre>\n", "senID": 12}, {"text": ["You can make the API a bit more fluent by making the factory \"callable\" (implementing __call__ instead of make."], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "__call__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "make", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The point is to make the collection explicit via a factory class."], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "explicit", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}]]