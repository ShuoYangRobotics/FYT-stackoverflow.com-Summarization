[[{"text": ["A simple use of De Moivre's formula, is sufficient  to show that the cube root of a value, regardless of sign, is a multi-valued function.", "That means, for any input value, there will be three solutions.", "Most of the solutions presented to far only return the principle root.", "A solution that returns all valid roots, and explicitly tests for non-complex special cases, is shown below."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "De Moivre's formula", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/De%5FMoivre%27s%5Fformula"}]}, {"code": "<pre>\n<code>\n import numpy\nimport math\ndef cuberoot( z ):\n    z = complex(z)\n    x = z.real\n    y = z.imag\n    mag = abs(z)\n    arg = math.atan2(y,x)\n    return [ mag**(1./3) * numpy.exp( 1j*(arg+2*n*math.pi)/3 ) for n in range(1,4) ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: As requested, in cases where it is inappropriate to have dependency on numpy, the following code does the same thing."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def cuberoot( z ):\n    z = complex(z) \n    x = z.real\n    y = z.imag\n    mag = abs(z)\n    arg = math.atan2(y,x)\n    resMag = mag**(1./3)\n    resArg = [ (arg+2*math.pi*n)/3. for n in range(1,4) ]\n    return [  resMag*(math.cos(a) + math.sin(a)*1j) for a in resArg ]\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n math.pow(abs(x),float(1)/3) * (1,-1)[x&lt;0]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You could use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n -math.pow(3, float(1)/3)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or more generally:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if x &gt; 0:\n    return math.pow(x, float(1)/3)\nelif x &lt; 0:\n    return -math.pow(abs(x), float(1)/3)\nelse:\n    return 0\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Taking the earlier answers and making it into a one-liner:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import math\ndef cubic_root(x):\n    return math.copysign(math.pow(abs(x), 1.0/3.0), x)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can get the complete (all n roots) and more general (any sign, any power) solution using:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import cmath\n\nx, t = -3., 3  # x**(1/t)\n\na = cmath.exp((1./t)*cmath.log(x))\np = cmath.exp(1j*2*cmath.pi*(1./t))\n\nr = [a*(p**i) for i in range(t)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Explanation:\na is using the equation xu = exp(u*log(x)).", "This solution will then be one of the roots, and to get the others, rotate it in the complex plane by a (full rotation)/t."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "u", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}]}], [{"text": ["You can also wrap the libm library that offers a cbrt (cube root) function:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "libm", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "cbrt", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from ctypes import *\nlibm = cdll.LoadLibrary('libm.so.6')\nlibm.cbrt.restype = c_double\nlibm.cbrt.argtypes = [c_double]\nlibm.cbrt(-8.0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["gives the expected"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n -2.0\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The cubic root of a negative number is just the negative of the cubic root of the absolute value of that number."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["i.e.", "x^(1/3) for x &lt; 0 is the same as (-1)*(|x|)^(1/3)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Just make your number positive, and then perform cubic root."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Primitive solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def cubic_root(nr):\n   if nr&lt;0:\n     return -math.pow(-nr, float(1)/3)\n   else:\n     return math.pow(nr, float(1)/3)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Probably massively non-pythonic, but it should work."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Maybe math.pow is the problem:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (Using Python 2.5.4)\n&gt;&gt;&gt; -1**(1/3.)\n-1.0\n</code>\n</pre>\n", "senID": 1}]]