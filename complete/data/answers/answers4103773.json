[[{"text": ["I would use a decorator on the function to handle keeping track of how many times it runs."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def run_once(f):\n    def wrapper(*args, **kwargs):\n        if not wrapper.has_run:\n            wrapper.has_run = True\n            return f(*args, **kwargs)\n    wrapper.has_run = False\n    return wrapper\n\n\n@run_once\ndef my_function(foo, bar):\n    return foo+bar\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now my_function will only run once.", "Other calls to it will return None.", "Just add an else clause to the if if you want it to return something else.", "From your example, it doesn't need to return anything ever."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "my_function", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "else", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "if", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["If you don't control the creation of the function, or the function needs to be used normally in other contexts, you can just apply the decorator manually as well."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n action = run_once(my_function)\nwhile 1:\n    if predicate:\n        action()\n</code>\n</pre>\n", "senID": 4}, {"text": ["This will leave my_function available for other uses."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "my_function", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Finally, if you need to only run it once twice, then you can just do"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n action = run_once(my_function)\naction() # run once the first time\n\naction.has_run = False\naction() # run once the second time\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Run the function before the loop.", "Example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n myFunction()\nwhile True:\n    # all the other code being executed in your loop\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is the obvious solution.", "If there's more than meets the eye, the solution may be a bit more complicated."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I'm assuming this is an action that you want to be performed at most one time, if some conditions are met.", "Since you won't always perform the action, you can't do it unconditionally outside the loop.", "Something like lazily retrieving some data (and caching it) if you get a request, but not retrieving it otherwise."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def do_something():\n    [x() for x in expensive_operations]\n    global action\n    action = lambda : None\n\naction = do_something\nwhile True:\n    # some sort of complex logic...\n    if foo:\n        action()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There are many ways to do what you want; however, do note that it is quite possible that \u2014as described in the question\u2014 you don't have to call the function inside the loop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you insist in having the function call inside the loop, you can also do:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n needs_to_run= expensive_function\nwhile 1:\n    \u2026\n    if needs_to_run: needs_to_run(); needs_to_run= None\n    \u2026\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Assuming there is some reason why myFunction() can't be called before the loop"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "myFunction()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import count\nfor i in count():\n    if i==0:\n        myFunction()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Why is this any different from your code?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n myFunction()\nwhile 1:\n    # rest of your code\n    pass\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm not sure that I understood your problem, but I think you can divide loop.", "On the part of the function and the part without it and save the two loops."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["One way would be to use an object-oriented approach and make your function a class whose instances keep track whether they've been \"run\" or not.", "Since your updated question indicates you may need many of them, I've updated my answer how to handle that using the class factory pattern."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "class factory", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2526879/what-exactly-is-a-class-factory"}]}, {"code": "<pre>\n<code>\n def RunOnceFactory():\n    _shared_state = {} # created class instances share state (aka borg pattern)\n\n    class RunOnceBase(object): # an abstract base class\n        has_run = False\n        def __init__(self):\n            self.__dict__ = _shared_state\n            if self.has_run: return\n            self._do_stuff()\n            self.has_run = True\n\n        def _do_stuff(self):\n            \"\"\" abstract method (i.e. subclasses MUST implement) \"\"\"\n            raise NotImplementedError\n\n    return RunOnceBase # the class created\n\n# usage examples\nclass my_function1(RunOnceFactory()):\n    def __init__(self):\n        super(self.__class__, self).__init__()\n    def _do_stuff(self):\n        print \"{} doing stuff\".format(self.__class__.__name__)\n\nclass my_function2(RunOnceFactory()):\n    def __init__(self):\n        super(self.__class__, self).__init__()\n    def _do_stuff(self):\n        print \"{} doing some other stuff\".format(self.__class__.__name__)\n\nfor i in range(10):\n    my_function1()\n    my_function2()\n\n# output:\n# my_function1 doing stuff\n# my_function2 doing some other stuff\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note: You could make a function/class able to do stuff again by adding a reset() method to its subclass (and calling it ;-)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "reset()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Here's an explicit way to code this up, where the state of which functions have been called is kept locally (so global state is avoided).", "I don't much like the non-explicit forms suggested in other answers: it's too surprising to see f() and for this not to mean that f() gets called."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This works by using dict.pop which looks up a key in a dict, removes the key from the dict, and takes a default value to use in case the key isn't found."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def do_nothing(*args, *kwargs):\n    pass\n\n# A list of all the functions you want to run just once.\nactions = [\n    my_function,\n    other_function\n]\nactions = dict((action, action) for action in actions)\n\nwhile True:\n    if some_condition:\n        actions.pop(my_function, do_nothing)()\n    if some_other_condition:\n        actions.pop(other_function, do_nothing)()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I've thought of aother, very effective way to do this that doesn't require decorator function or classes.", "Instead it just uses a mutable keyword argument, which ought to work in most versions of Python.", "Most of the time these are something to be avoided since normally you wouldn't want a default argument value to be able to change from call-to-call -- but that ability can be leveraged and used as cheap storage mechanism.", "Here's how it would work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def my_function1(_has_run=[]):\n    if _has_run: return\n    print \"my_function1 doing stuff\"\n    _has_run.append(1)\n\ndef my_function2(_has_run=[]):\n    if _has_run: return\n    print \"my_function2 doing some other stuff\"\n    _has_run.append(1)\n\nfor i in range(10):\n    my_function1()\n    my_function2()\n\nmy_function1(_has_run=[]) # force it to run\n\n# output:\n# my_function1 doing stuff\n# my_function2 doing some other stuff\n# my_function1 doing stuff\n</code>\n</pre>\n", "senID": 1}, {"text": ["This could be simplified a little further by doing what @gnibbler suggested in his answer and using an iterator (which were introduced in Python 2.2.", "):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from itertools import count\n\ndef my_function3(_count=count()):\n    if _count.next(): return\n    print \"my_function3 doing something\"\n\nfor i in range(10):\n    my_function3()\n\n# my_function3 doing something\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If I understand the updated question correctly, something like this should work"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def function1():\n    print \"function1 called\"\n\ndef function2():\n    print \"function2 called\"\n\ndef function3():\n    print \"function3 called\"\n\ncalled_functions = set()\nwhile True:\n    n = raw_input(\"choose a function: 1,2 or 3 \")\n    func = {\"1\": function1,\n            \"2\": function2,\n            \"3\": function3}.get(n)\n\n    if func in called_functions:\n        print \"That function has already been called\"\n    else:\n        called_functions.add(func)\n        func()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If the condition check needs to happen only once you are in the loop, having a flag signaling that you have already run the function helps.", "In this case you used a counter, a boolean variable would work just as fine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n signal = False\ncount = 0 \ndef callme(): \n     print \"I am being called\"  \nwhile count &lt; 2: \n     if signal == False : \n         callme()\n         signal = True\n     count +=1\n</code>\n</pre>\n", "senID": 1}]]