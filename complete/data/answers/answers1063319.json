[[{"text": ["If your keys and values are non-overlapping, one obvious approach is to simply store them in the same dict.", "ie:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class BidirectionalDict(dict):\n    def __setitem__(self, key, val):\n        dict.__setitem__(self, key, val)\n        dict.__setitem__(self, val, key)\n\n    def __delitem__(self, key):\n        dict.__delitem__(self, self[key])\n        dict.__delitem__(self, key)\n\nd = BidirectionalDict()\nd['foo'] = 4\nprint d[4]   # Prints 'foo'\n</code>\n</pre>\n", "senID": 1}, {"text": ["(You'll also probably want to implement things like the __init__, update and iter* methods to act like a real dict, depending on how much functionality you need)."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "update", "childNum": 0, "tag": "code", "childList": []}, {"text": "iter*", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This should only involve one lookup, though may not save you much in memory (you still have twice the number of dict entries after all).", "Note however that neither this nor your original will use up twice as much space: the dict only takes up space for the references (effectively pointers), plus an overallocation overhead.", "The space taken up by your data itself will not be repeated twice since the same objects are pointed to."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Related posts:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python mapping inverse"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Python mapping inverse", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/483666/python-reverse-inverse-a-mapping/483833"}]}, {"text": ["Python 1:1 mappings"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Python 1:1 mappings", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/863935/a-data-structure-for-11-mappings-in-python"}]}, {"text": ["Of course, if all values and keys are unique, couldn't you just use a single dictionary, and insert both key:value and value:key initially?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["In The Art of Computer Programming, Vokume 3 Knuth has a section on lookups of secondary keys.", "For purposes of your question, the value could be considered the secondary key."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The first suggestion is to do what you have done: make an efficient index of the keys by value."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The second suggestion is to setup a large btree that is a composite index of the clustered data, where the branch nodes contain values and the leaves contain the key data and pointers to the larger record (if there is one."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If the data is geometric (as yours appears to be) there are things called post-office trees.", "It can answer questions like, what is the nearest object to point x.", "A few examples are here: http://simsearch.yury.name/russir/01nncourse-hand.pdf  Another simple option for this kind of query is the quadtree and the k-d tree.", "http://en.wikipedia.org/wiki/Quadtree"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "http://simsearch.yury.name/russir/01nncourse-hand.pdf", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://simsearch.yury.name/russir/01nncourse-hand.pdf"}, {"text": "http://en.wikipedia.org/wiki/Quadtree", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Quadtree"}]}, {"text": ["Another final option is combinatorial hashing, where you combine the key and value into a special kind of hash that lets you do efficient lookups on the hash, even when you don't have both values.", "I couldn't find a good combinatorial hash explanation online, but it is in TAoCP, Volume 3 Second Edition on page 573."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Granted, for some of these you may have to write your own code.", "But if memory or performance is really key, you might want to take the time."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["It shouldn't use \"twice the space\".", "Dictionaries just store references to data, not the data itself.", "So, if you have a million strings taking up a billion bytes, then each dictionary takes maybe an extra 10-20 million bytes--a tiny fraction of the overall storage.", "Using two dictionaries is the right thing to do."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Insert reversed pair of (key, value) into same dict:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = {1:'a', 2:'b'}\na.update(dict((v, k) for k, v in a.iteritems()))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you will be able to do both, as you required:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n print a[1]\nprint a['a']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here's another solution using a user defined class."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "another solution", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.daniweb.com/code/snippet806.html"}]}, {"text": ["And the code..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # search a dictionary for key or value\n# using named functions or a class\n# tested with Python25 by Ene Uran 01/19/2008\n\ndef find_key(dic, val):\n    \"\"\"return the key of dictionary dic given the value\"\"\"\n    return [k for k, v in symbol_dic.iteritems() if v == val][0]\n\ndef find_value(dic, key):\n    \"\"\"return the value of dictionary dic given the key\"\"\"\n    return dic[key]\n\nclass Lookup(dict):\n    \"\"\"\n    a dictionary which can lookup value by key, or keys by value\n    \"\"\"\n    def __init__(self, items=[]):\n        \"\"\"items can be a list of pair_lists or a dictionary\"\"\"\n        dict.__init__(self, items)\n\n    def get_key(self, value):\n        \"\"\"find the key(s) as a list given a value\"\"\"\n        return [item[0] for item in self.items() if item[1] == value]\n\n    def get_value(self, key):\n        \"\"\"find the value given a key\"\"\"\n        return self[key]\n</code>\n</pre>\n", "senID": 2}]]