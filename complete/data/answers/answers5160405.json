[[{"text": ["Unless there's much more to this problem than you've explained, I don't see the point in using regexes.", "This is very simple to deal with using basic string methods:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "very", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n [s.strip() for s in mys.split(',') if s.strip()]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or if it has to be a tuple:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n tuple(s.strip() for s in mys.split(',') if s.strip())\n</code>\n</pre>\n", "senID": 3}, {"text": ["The code is more readable too.", "Please tell me if this fails to apply."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["EDIT: Ok, there is indeed more to this problem than it initially seemed.", "Leaving this for historical purposes though.", "(Guess I'm not 'disciplined' :) )"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["As described, I think this regex works fine:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nthepattern = re.compile(\"(.+?)(?:,|$)\") # lazy non-empty match \nthepattern.findall(\"a, b, asdf, d\")     # until comma or end of line\n# Result:\nOut[19]: ['a', ' b', ' asdf', ' d']\n</code>\n</pre>\n", "senID": 1}, {"text": ["The key here is to use findall rather than match.", "The phrasing of your question suggests you prefer match, but it isn't the right tool for the job here -- it is designed to return exactly one string for each corresponding group ( ) in the regex.", "Since your 'number of strings' is variable, the right approach is to use either findall or split."], "childNum": 8, "tag": "p", "senID": 2, "childList": [{"text": "findall", "tag": "a", "pos": 0, "childList": [{"text": "findall", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/re.html"}, {"text": "findall", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "match", "childNum": 0, "tag": "code", "childList": []}, {"text": "match", "childNum": 0, "tag": "code", "childList": []}, {"text": "(", "childNum": 0, "tag": "code", "childList": []}, {"text": ")", "childNum": 0, "tag": "code", "childList": []}, {"text": "findall", "childNum": 0, "tag": "code", "childList": []}, {"text": "split", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If this isn't what you need, then please make the question more specific."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Edit: And if you must use tuples rather than lists:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n tuple(Out[19])\n# Result\nOut[20]: ('a', ' b', ' asdf', ' d')\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n import re\n\nregex = \" *((?:[^, ]| +[^, ])+) *, *((?:[^, ]| +[^, ])+) *, *\"\n\nprint re.match(regex, 'some string, another string, ').groups()\n# ('some string', 'another string')\nprint re.match(regex, ' some string, another string, ').groups()\n# ('some string', 'another string')\nprint re.match(regex, ' some string , another string, ').groups()\n# ('some string', 'another string')\n</code>\n</pre>\n", "senID": 0}], [{"text": ["No offense, but you obviously have a lot to learn about regexes, and what you're going to learn, ultimately, is that regexes can't handle this job.", "I'm sure this particular task is doable with regexes, but then what?", "You say you have potentially hundreds of different file formats to parse!", "You even mentioned JSON and XML, which are fundamentally incompatible with regexes."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "particular", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "hundreds", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["Do yourself a favor: forget about regexes and learn pyparsing instead.", "Or skip Python entirely and use a standalone parser generator like ANTLR.", "In either case, you'll probably find that grammars for most of your file formats have already been written."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "pyparsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}, {"text": "ANTLR", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.antlr.org/"}]}], [{"text": ["I don't think there is such a notation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But regexes are not a matter of only NOTATION , that is to say the RE string used to define a regex.", "It is also a matter of TOOLS, that is to say functions. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You should give more information without delaying: we could understand more rapidly what are the constraints.", "Because in my opinion, to answer to your problem as it has been exposed, findall() is indeed OK:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "findall()", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\nfor line in ('string one, string two, ',\n             'some string, another string, third string, ',\n             # the following two lines are only one string\n             'Topaz, Turquoise, Moss Agate, Obsidian, '\n             'Tigers-Eye, Tourmaline, Lapis Lazuli, '):\n\n    print re.findall('(.+?), *',line)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Result"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n ['string one', 'string two']\n['some string', 'another string', 'third string']\n['Topaz', 'Turquoise', 'Moss Agate', 'Obsidian', 'Tigers-Eye', 'Tourmaline', 'Lapis Lazuli']\n</code>\n</pre>\n", "senID": 5}, {"text": ["Now, since you \"have omitted a lot of complexity\" in your question, findall() could incidentally be unsufficient to hold this complexity.", "Then finditer() will be used because it allows more flexibility in the selection of groups of a match"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "findall()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "finditer()", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\nfor line in ('string one, string two, ',\n             'some string, another string, third string, ',\n             # the following two lines are only one string\n             'Topaz, Turquoise, Moss Agate, Obsidian, '\n             'Tigers-Eye, Tourmaline, Lapis Lazuli, '):\n\n    print [ mat.group(1) for mat in re.finditer('(.+?), *',line) ]\n</code>\n</pre>\n", "senID": 7}, {"text": ["gives the same result and can be complexified by writing other expression in place of mat.group(1)"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "mat.group(1)", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["In order to sum this up, it seems I am already using the best solution by constructing the regex pattern in a 'dynamic' manner:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from re import match\n&gt;&gt;&gt; match(2 * '(.*?), ', 'some string, another string, ').groups()\n('some string', 'another string')\n</code>\n</pre>\n", "senID": 1}, {"text": ["the "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 2 * '(.*?)\n</code>\n</pre>\n", "senID": 3}, {"text": ["is what I mean by dynamic.", "The alternative approach"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; match('(?:(.*?), ){2}', 'some string, another string, ').groups()\n('another string',)\n</code>\n</pre>\n", "senID": 5}, {"text": ["fails to return the desired result due to the fact that (as Glenn and Alan kindly explained) "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Thanks for your help everyone!", ":-)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]]