[[{"text": ["I got exactly the same need, and Alex Martelli's answer has totally convinced me: best is keeping a dictionary and a list of partially sorted keys, then sort when needed.", "This is efficient because of the very particular behaviour of python's sort algorithm (AKA Timsort).", "http://stackoverflow.com/questions/1319763/key-ordered-dict-in-python"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://stackoverflow.com/questions/1319763/key-ordered-dict-in-python", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1319763/key-ordered-dict-in-python"}]}, {"text": ["I tested his implementation and mine, and his was best (because he does not insert in the middle of the list)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(I strongly advise you to read the paper linked in AM's comment about the timsort, which is a pearl)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Maybe this will help you."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://pypi.python.org/pypi/rbtree/0.8.0"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://pypi.python.org/pypi/rbtree/0.8.0", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/rbtree/0.8.0"}]}], [{"text": ["As you said, you can roll your own implementation with bisect:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class OrderedDict:\n  def __init__(self, keyvalues_iter):\n    self.__srtlst__ = sorted(keyvalues_iter)\n  def __len__(self):\n    return len(self.__srtlst__)\n  def __contains__(self, key):\n    index = bisect(self.__srtlst__, key)\n    if index&lt;len(self.__srtlst__) and self.__srtlst__[index][0] == key:\n      return True\n    else:\n      return False    \n  def __getitem__(self, key):\n    index = bisect(self.__srtlst__, key)\n    if index&lt;len(self.__srtlst__) and self.__srtlst__[index][0] == key:\n      return self.__srtlst__[index][1]\n    else:\n      raise KeyError(key)\n  def __setitem__(sekf, key, value):\n    index = bisect(self.__srtlst__, key)\n    if index&lt;len(self.__srtlst__) and self.__srtlst__[index][0] == key:\n      self.__srtlst__[index][1] = value\n    else:\n      self.__srtlst__[index]=(key, value)\n  def __delitem__(sekf, key, value):\n    index = bisect(self.__srtlst__, key)\n    if index&lt;len(self.__srtlst__) and self.__srtlst__[index][0] == key:\n      del __srtlst__[index]\n    else:\n      raise KeyError(key)\n   def __iter__(self):\n     return (v for k,v in self.__srtlst__)\n   def clear(self):\n     self.__srtlst__ = []\n   def get(self, key, default=None):\n    index = bisect(self.__srtlst__, key)\n    if index&lt;len(self.__srtlst__) and self.__srtlst__[index][0] == key:\n      return self.__srtlst__[index][1]\n    else:\n      return default\n   def items(self):\n     return self.__srtlst__[:]\n  def iteritems(self):\n    return iter(self.__srtlst__)\n  def iterkeys(self):\n    return (k for k,v in self.__srtlst__)\n  def itervalues(self):\n    return (v for k,v in self.__srtlst__)\n  def keys(self):\n    return [k for k,v in self.__srtlst__]\n  def values(self):\n    return [v for k,v in self.__srtlst__]\n  def setdefault(self, key, default):\n    index = bisect(self.__srtlst__, key)\n    if index&lt;len(self.__srtlst__) and self.__srtlst__[index][0] == key:\n      return self.__srtlst__[index][1]\n    else:\n      self.__srtlst__[index]=(key, default)\n      return default\n  def update(self, other):\n    #a more efficient implementation could be done merging the sorted lists\n    for k, v in other.iteritems():\n      self[k] = v\n</code>\n</pre>\n", "senID": 1}, {"text": ["hmmm... it seems that I already did that for you, d'oh!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Lists are a miserable substitute for a tree."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Insertions need to move the whole list around to make space; deletions need to move the list back down.", "Adding or deleting stuff in batch is fine when it's possible, but it's very often not, or takes unnatural contortions to arrange it.", "A fundamental attribute of a tree is that insertions and deletions are O(log n); no amount of handwaving will turn O(n) into O(log n)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Inserting an item into a tree when you already know where it's going to go is O(1).", "Equivalently, deleting an item from a tree based on its node is also O(1).", "std::map supports both of these.", "These are both O(n) with a list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Another fundamental property of a tree is that iterating over a range of values is O(1) per iteration.", "Combining list and dict loses this, because each iteration needs to do a dict lookup.", "(The list-of-tuples approach doesn't have this problem."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Trees are among the most basic of data types.", "Python's lack of a tree container type is a wart.", "Maybe there's a third-party library implementing one (eg.", "the one linked by Mr. \"Unknown\", which I havn't tried so I can't vouch for), but there's no standard Python type for it."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["For a list that stays sorted, you can try module heapq."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I stumbled on this question needing an OrderedMap myself, and found to my horror that the accepted answer is complete garbage.", "So I rolled my own, in case anyone finds it useful:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from bisect import *\n\nclass OrderedMap:\n    \"\"\"Much less efficient than a dict, \n    but keys don't need to be hashable.\"\"\"\n    __default_arg = object()\n    def __init__(self, keyvalues_iter = None):\n        self.clear()\n        if keyvalues_iter is not None:\n            self.update(keyvalues_iter)\n    def clear(self):\n        self.__keys = []\n        self.__values = []\n    def __index(self, key):\n        if self.__keys:\n            index = bisect(self.__keys, key)-1\n            if self.__keys[index] == key:\n                return index\n        raise KeyError(key)\n    def __len__(self):\n        return len(self.__keys)\n    def __contains__(self, key):\n        try:\n            self.__index(key)\n            return True\n        except KeyError:\n            return False\n    def __getitem__(self, key):\n        index = self.__index(key)\n        return self.__values[index]\n    def __setitem__(self, key, value):\n        try:\n            index = self.__index(key)\n            # exists\n            self.__values[index] = value\n        except KeyError:\n            # new\n            index = bisect(self.__keys, key)\n            self.__keys.insert(index, key)\n            self.__values.insert(index, value)\n    def __delitem__(self, key):\n        index = self.__index(key)\n        self.__keys.pop(index)\n        self.__values.pop(index)\n    def __iter__(self):\n        return iter(self.__keys)\n    def get(self, key, default=__default_arg):\n        try:\n            return self[key]\n        except KeyError:\n            if default != OrderedMap.__default_arg:\n                return default\n            raise\n    def setdefault(self, key, default = None):\n        try:\n            return self[key]\n        except KeyError:\n            if default != OrderedMap.__default_arg:\n                self[key] = default\n                return default\n            raise\n    def items(self):\n        return zip(self.__keys, self.__values)\n    def iteritems(self):\n        return iter((self.__keys[x], self.__values[x])\n                    for x in xrange(len(self)))\n    def keys(self):\n        return self.__keys[:]\n    def iterkeys(self):\n        return iter(self.__keys)\n    def values(self):\n        return self.__values[:]\n    def itervalues(self):\n        return iter(self.__values)\n    def update(self, other):\n        for k, v in other.iteritems():\n            self[k] = v\n    def __repr__(self):\n        s = \", \".join(\"%s: %s\" % (repr(self.__keys[x]),\n                                  repr(self.__values[x]))\n                      for x in xrange(len(self)))\n        return \"OrderedMap{%s}\" % (s,)\n</code>\n</pre>\n", "senID": 1}]]