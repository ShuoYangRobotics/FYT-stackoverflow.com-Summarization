[[{"text": ["This is a hack, but you can wrap the module with a class:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Wrapper(object):\n  def __init__(self, wrapped):\n    self.wrapped = wrapped\n  def __getattr__(self, name):\n    # Perform custom logic here\n    try:\n      return getattr(self.wrapped, name)\n    except AttributeError:\n      return 'default' # Some sensible default\n\nsys.modules[__name__] = Wrapper(sys.modules[__name__])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["We don't usually do it that way.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What we do is this."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n....\n\n# The implicit global instance\na= A()\n\ndef salutation( *arg, **kw ):\n    a.salutation( *arg, **kw )\n</code>\n</pre>\n", "senID": 2}, {"text": ["Why?", "So that the implicit global instance is visible."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["For examples, look at the random module, which creates an implicit global instance to slightly simplify the use cases where you want a \"simple\" random number generator."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "random", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Similar to what @H\u00e5vard S proposed, in a case where I needed to implement some magic on a module (like __getattr__), I would define a new class that inherits from types.ModuleType and put that in sys.modules (probably replacing the module where my custom ModuleType was defined)."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "__getattr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "types.ModuleType", "childNum": 0, "tag": "code", "childList": []}, {"text": "sys.modules", "childNum": 0, "tag": "code", "childList": []}, {"text": "ModuleType", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["See the main __init__.py file of Werkzeug for a fairly robust implementation of this."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "__init__.py", "tag": "a", "pos": 0, "childList": [{"text": "__init__.py", "tag": "code"}], "childNum": 1, "href": "http://dev.pocoo.org/projects/werkzeug/browser/werkzeug/__init__.py"}, {"text": "__init__.py", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://werkzeug.pocoo.org/", "text": "Werkzeug", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["This is hackish, but..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import types\n\nclass A(object):\n    def salutation(self, accusative):\n        print \"hello\", accusative\n\n    def farewell(self, greeting, accusative):\n         print greeting, accusative\n\ndef AddGlobalAttribute(classname, methodname):\n    print \"Adding \" + classname + \".\" + methodname + \"()\"\n    def genericFunction(*args):\n        return globals()[classname]().__getattribute__(methodname)(*args)\n    globals()[methodname] = genericFunction\n\n# set up the global namespace\n\nx = 0   # X and Y are here to add them implicitly to globals, so\ny = 0   # globals does not change as we iterate over it.\n\ntoAdd = []\n\ndef isCallableMethod(classname, methodname):\n    someclass = globals()[classname]()\n    something = someclass.__getattribute__(methodname)\n    return callable(something)\n\n\nfor x in globals():\n    print \"Looking at\", x\n    if isinstance(globals()[x], (types.ClassType, type)):\n        print \"Found Class:\", x\n        for y in dir(globals()[x]):\n            if y.find(\"__\") == -1: # hack to ignore default methods\n                if isCallableMethod(x,y):\n                    if y not in globals(): # don't override existing global names\n                        toAdd.append((x,y))\n\n\nfor x in toAdd:\n    AddGlobalAttribute(*x)\n\n\nif __name__ == \"__main__\":\n    salutation(\"world\")\n    farewell(\"goodbye\", \"world\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["This works by iterating over the all the objects in the global namespace.", "If the item is a class, it iterates over the class attributes.", "If the attribute is callable it adds it to the global namespace as a function. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It ignore all attributes which contain \"__\"."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I wouldn't use this in production code, but it should get you started."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["There are two basic problems you are running into here:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(1) means any solution would have to also keep track of which module was being examined, otherwise every module would then have the instance-substitution behavior; and (2) means that (1) isn't even possible... at least not directly."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "every", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Fortunately, sys.modules is not picky about what goes there so a wrapper will work, but only for module access (i.e.", "import somemodule; somemodule.salutation('world'); for same-module access you pretty much have to yank the methods from the substitution class and add them to globals() eiher with a custom method on the class (I like using .export()) or with a generic function (such as those already listed as answers).", "One thing to keep in mind: if the wrapper is creating a new instance each time, and the globals solution is not, you end up with subtly different behavior.", "Oh, and you don't get to use both at the same time -- it's one or the other."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "import somemodule; somemodule.salutation('world')", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "globals()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": ".export()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Create your module file that has your classes.", "Import the module.", "Run getattr on the module you just imported.", "You can do a dynamic import using __import__ and pull the module from sys.modules."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "getattr", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__import__", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Here's your module some_module.py:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "some_module.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Foo(object):\n    pass\n\nclass Bar(object):\n    pass\n</code>\n</pre>\n", "senID": 2}, {"text": ["And in another module:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import some_module\n\nFoo = getattr(some_module, 'Foo')\n</code>\n</pre>\n", "senID": 4}, {"text": ["Doing this dynamically:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import sys\n\n__import__('some_module')\nmod = sys.modules['some_module']\nFoo = getattr(mod, 'Foo')\n</code>\n</pre>\n", "senID": 6}], [{"text": ["In some circumstances the globals() dictionary can suffice, for example you can instantiate a class by name from the global scope:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "globals()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from somemodule import * # imports SomeClass\n\nsomeclass_instance = globals()['SomeClass']()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Why can't you just override the __getattr__() "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__getattr__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Foo(object):\n    def __getattr__(self, name):\n        if conditionFoo(name):\n            # Do something\n        else:\n            # Default behaviour\n            raise AttributeError\n</code>\n</pre>\n", "senID": 1}]]