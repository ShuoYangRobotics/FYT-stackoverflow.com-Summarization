[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; sum(map(lambda x:1, \"hello world\"))\n11\n\n&gt;&gt;&gt; sum(1 for x in \"foobar\")\n6\n\n&gt;&gt;&gt; from itertools import count\n&gt;&gt;&gt; zip(count(1), \"baz\")[-1][0]\n3\n</code>\n</pre>\n", "senID": 0}, {"text": ["some recursive solutions"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def get_string_length(s):\n...     return 1 + get_string_length(s[1:]) if s else 0\n... \n&gt;&gt;&gt; get_string_length(\"hello world\")\n11\n&gt;&gt;&gt; def get_string_length_gen(s):\n...     yield 1 + next(get_string_length_gen(s[1:])) if s else 0\n... \n&gt;&gt;&gt; next(get_string_length_gen(\"hello world\"))\n11\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Why you need to avoid the len function is beyond me, but strings are iterables.", "You should be able to do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n strlen = 0\n\nfor c in myString:\n  strlen += 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's an O(1) method:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def strlen(s):\n    if s == \"\": return 0\n    return s.rindex(s[-1]) + 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["In other words, it doesn't work by counting the characters, so should be just as fast for a 1GB string as it is for a 1 byte string."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It works by looking at the last character and searching from the very end to find that character.", "Since it's the last character it will always find it at the first place it looks, essentially always returning the index of the last character.", "The length is just one more than the index of the last character."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["easy:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n length=0\nfor x in \"This is a string\":\n    length+=1\nprint(length)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It's a weird question so here's a weird answer!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n  for i in itertools.count(): mystring[i]\nexcept IndexError:\n  pass\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; s\n'mylongstring'\n&gt;&gt;&gt; re.subn(\".\",\"1\",s)[-1]\n12\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}, {"text": ["If string contains new lines"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s=\"mys\\ntring\\n\"\n&gt;&gt;&gt; re.compile(\".\",re.DOTALL).subn(\"\",s)[-1]\n10\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Not very efficient but very concise:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def string_length(s):    \n    if s == '': return 0\n    return 1 + string_length(s[1:])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's a way to do it by counting the number of occurences of the empty string within the string:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def strlen(s):\n    return s.count('') - 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Since \"\".count(\"\") returns 1, you have to subtract 1 to get the string's length."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "\"\".count(\"\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Make a file-like object from the string, read the entire object, then tell your offset:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import StringIO\n&gt;&gt;&gt; ss = StringIO.StringIO(\"ABCDEFGHIJ\")\n&gt;&gt;&gt; ss.read()\n'ABCDEFGHIJ'\n&gt;&gt;&gt; ss.tell()\n10\n</code>\n</pre>\n", "senID": 1}]]