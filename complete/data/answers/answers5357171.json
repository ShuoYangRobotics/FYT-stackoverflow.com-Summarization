[[{"text": ["Generating Every possible matrix of 1's and 0's for 14*10 would generate 2**140 matrixes.", "I don't believe you would have enough lifetime for this.", "I don't know, if the sun would still shine before you finish that.", "This is why it is impossible to generate all those matrices.", "You must look for some other solution, this looks like a brute force."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "14*10", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "2**140", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["The actual implementation depends heavily on how you want to represent matrices\u2026 But assuming the matrix can be represented by a 14 * 10 = 140 element list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import product\nfor matrix in product([0, 1], repeat=140):\n    # ... do stuff with the matrix ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course, as other posters have noted, this probably isn't what you want to do\u2026 But if it really is what you want to do, that's the best code (given your requirements) to do it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Trying this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy\nfor i in xrange(int(1e9)): a = numpy.random.random_integers(0,1,(14,10))\n</code>\n</pre>\n", "senID": 1}, {"text": ["(which is much, much, much smaller than what you require) should be enough to convince you that this is not feasible.", "It also shows you how to calculate one, or few, such random matrices even up to a million is pretty fast)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: changed to xrange to \"improve speed and memory requirements\" :)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Are you sure you want every possible 14x10 matrix?", "There are 140 elements in each matrix, and each element can be on or off.", "Therefore there are 2^140 possible matrices.", "I suggest you reconsider what you really want."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sure", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "2^140", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Edit: I noticed you mentioned in a comment that you are trying to minimize something.", "There is an entire mathematical field called optimization devoted to doing this type of thing.", "The reason this field exists is because quite often it is not possible to exhaustively examine every solution in anything resembling a reasonable amount of time."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "optimization", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Optimization_%28mathematics%29"}]}], [{"text": ["This is absolutely impossible!", "The number of possible matrices is 2140, which is around 1.4e42.", "However, consider the following..."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "140", "childNum": 0, "tag": "sup", "pos": 1, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "If you were to generate two 14-by-10 matrices at random, the odds that they would be the same are 1 in 1.4e42.", "tag": "none", "senID": 1}, {"text": "If you were to generate 1 billion unique 14-by-10 matrices, then the odds that the next one you generate would be the same as one of those would still be exceedingly slim: 1 in 1.4e33.", "tag": "none", "senID": 2}, {"text": "The ", "tag": "none", "senID": 3}]}, {"text": ["Your approach should be thus:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "Find a computer no one ever wants to use again.", "tag": "none", "senID": 5}, {"text": "Give it as much storage space as possible to save your results.", "tag": "none", "senID": 6}, {"text": "Install MATLAB on it and fire it up.", "tag": "none", "senID": 7}, {"text": ["Start computing matrices at random like so:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": "Walk away", "tag": "none", "senID": 9}]}, {"text": ["Since there are so many combinations, you don't have to compare newMatrix with any of the previous matrices since the length of time before a repeat is likely to occur is astronomically large.", "Your processing is more likely to stop due to other reasons first, such as (in order of likely occurrence):"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "newMatrix", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 6, "lis": [{"text": "You run out of disk space to store your results.", "tag": "none", "senID": 11}, {"text": "There's a power outage.", "tag": "none", "senID": 12}, {"text": "Your computer suffers a fatal hardware failure.", "tag": "none", "senID": 13}, {"text": "You pass away.", "tag": "none", "senID": 14}, {"text": "The Earth passes away.", "tag": "none", "senID": 15}, {"text": "The Universe dies a slow ", "tag": "none", "senID": 16}]}, {"text": ["NOTE: Although I injected some humor into the above answer, I think I have illustrated one useful alternative.", "If you simply want to sample a small subset of the possible combinations (where even 1 billion could be considered \"small\" due to the sheer number of combinations) then you don't have to go through the extra time- and memory-consuming steps of saving all of the matrices you've already processed and comparing new ones to it to make sure you aren't repeating matrices.", "Since the odds of repeating a combination are so low, you could safely do this:"], "childNum": 2, "tag": "p", "senID": 17, "childList": [{"text": "NOTE:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "subset", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n for iLoop = 1:whateverBigNumberYouWant\n  newMatrix = randi([0 1],14,10);  %# Generate a new matrix\n  %# Process the matrix and save your results\nend\n</code>\n</pre>\n", "senID": 18}], [{"text": ["You don't have to iterate over this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def everyPossibleMatrix(x,y):\n    N=x*y\n    for i in range(2**N):\n        b=\"{:0{}b}\".format(i,N)\n        yield '\\n'.join(b[j*x:(j+1)*x] for j in range(y))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Depending on what you want to accomplish with the generated matrices, you might be better off generating a random sample and running a number of simulations.", "Something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n matrix_samples = []\n# generate 10 matrices\nfor i in range(10):\n    sample = numpy.random.binomial(1, .5, 14*10)\n    sample.shape = (14, 10)\n    matrix_samples.append(sample)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could do this a number of times to see how results vary across simulations.", "Of course, you could also modify the code to ensure that there are no repeats in a sample set, again depending on what you're trying to accomplish."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Are you saying that you have a table with 140 cells and each value can be 1 or 0 and you'd like to generate every possible output?", "If so, you would have 2^140 possible combinations...which is quite a large number."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Instead of just suggesting the this is unfeasible, I would suggest considering a scheme that samples the important subset of all possible combinations instead of applying a brute force approach.", "As one of your replies suggested, you are doing minimization.", "There are numerical techniques to do this such as simulated annealing, monte carlo sampling as well as traditional minimization algorithms.", "You might want to look into whether one is appropriate in your case."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I was actually much more pessimistic to begin with, but consider:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from math import log, e\n\ndef timeInYears(totalOpsNeeded=2**140, currentOpsPerSecond=10**9, doublingPeriodInYears=1.5):\n    secondsPerYear = 365.25 * 24 * 60 * 60\n    doublingPeriodInSeconds = doublingPeriodInYears * secondsPerYear\n    k = log(2,e) / doublingPeriodInSeconds  # time-proportionality constant\n    timeInSeconds = log(1 + k*totalOpsNeeded/currentOpsPerSecond, e) / k\n    return timeInSeconds / secondsPerYear\n</code>\n</pre>\n", "senID": 1}, {"text": ["if we assume that computer processing power continues to double every 18 months, and you can currently do a billion combinations per second (optimistic, but for sake of argument) and you start today, your calculation will be complete on or about April 29th 2137."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]