[[{"text": ["Alright, a few things."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To assign the integers to an object, you have to surround the groups you want in parentheses.", "In your case, let"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n p = re.compile(r\"p wncf (\\d+) (\\d+) (\\d+)\")\n</code>\n</pre>\n", "senID": 2}, {"text": ["And instead of p.match(line), which returns a match object or None, you could use findall.", "Check out the following as a replacement for what you have."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "p.match(line)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "findall", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n p = re.compile(r\"p wncf (\\d+) (\\d+) (\\d+)\") \nfor line in f: \n    matches = p.findall(line)\n    if len(matches) != 0:\n        print matches[0][0], matches[0][1], matches[0][2]\n    else:\n        print \"No matches.\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["Edit: If your header values can contain negative numbers as well, you should replace r\"p wncf (\\d+) (\\d+) (\\d+)\" with r\"p wncf (-?\\d+) (-?\\d+) (-?\\d+)\"."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "r\"p wncf (\\d+) (\\d+) (\\d+)\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "r\"p wncf (-?\\d+) (-?\\d+) (-?\\d+)\"", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["something like that (lines is a list of all the lines in order):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nif re.match(r'p wncf \\d+ \\d+ \\d+', lines[0]) == None:\n    print \"Bad format\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You might want to use p.match(line) instead.", "You're passing the first character of the line to the regex, not the whole line."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "p.match(line)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n p, wncf, nvar, nclauses, hard = line.split()\nnvar = int(nvar)\nnclauses = int(nclauses)\nhard = int(hard)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["hi\nyou don't need a regex to do this.", "here's one way you can check your header."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fh=open(\"file\")\nheader=fh.readline().rstrip()\nif not header.startswith(\"p wncf\") :\n    print \"error\"\nheader=header.split()\nif len(header) != 5:\n    print \"error\"\nif False in map(str.isdigit, header[2:]):\n    print \"Error\"\nfh.close()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using regular expressions would be about the easiest way to check this header:-"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\np = re.compile('p wncf \\d+ \\d+ \\d+$')\nif p.match(lineToBeChecked) == None:\n  print \"Header does not have correct format\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note the use of the trailing $ in the regex to anchor the regex to the end of the line and so protect against additional information being included on the header line (which I've assumed would make it invalid)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If arbitrary numbers of spaces are allowed between parameters the regular expression could be changed to this:-"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n p = re.compile('p[ ]+wncf[ ]+\\d+[ ]+\\d+[ ]+\\d+$')\n</code>\n</pre>\n", "senID": 4}]]