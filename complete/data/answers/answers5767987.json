[[{"text": ["Here is my hat in the ring.", "Careful study of this regex will teach a few lessons:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n import re\nreobj = re.compile(\n    r\"\"\"# Loosely match a date/time reference\n    ^                    # Anchor to start of string.\n    \\s*                  # Optional leading whitespace.\n    (?P&lt;time&gt;            # $time: military or AM/PM time.\n      (?:                # Group for military hours options.\n        [2][0-3]         # Hour is either 20, 21, 22, 23,\n      | [01]?[0-9]       # or 0-9, 00-09 or 10-19\n      )                  # End group of military hours options.\n      (?:                # Group for optional minutes.\n        :                # Hours and minutes separated by \":\"\n        [0-5][0-9]       # 00-59 minutes\n      )?                 # Military minutes are optional.\n    |                    # or time is given in AM/PM format.\n      (?:1[0-2]|0?[1-9]) # 1-12 or 01-12 AM/PM options (hour)\n      (?::[0-5][0-9])?   # Optional minutes for AM/PM time.\n      \\s*                # Optional whitespace before AM/PM.\n      [ap]m              # Required AM or PM (case insensitive)\n    )                    # End group of time options.\n    \\s+                  # Required whitespace.\n    (?P&lt;offset&gt; \\d+ )    # $offset: count of time increments.\n    \\s+                  # Required whitespace.\n    (?P&lt;units&gt;           # $units: units of time increment.\n      (?:sec(?:ond)?|min(ute)?|hour|day|week|month|year|decade|century)\n      s?                 # Time units may have optional plural \"s\".\n    )                    # End $units: units of time increment.\n    \\s+                  # Required whitespace.\n    (?P&lt;dir&gt;from|before|after|since) # #dir: Time offset direction.\n    \\s+                  # Required whitespace.\n    (?P&lt;base&gt;yesterday|today|tomorrow|(?:right )?now)\n    \\s*                  # Optional whitespace before end.\n    $                    # Anchor to end of string.\"\"\", \n    re.IGNORECASE | re.VERBOSE)\nmatch = reobj.match(' 3 pm 2 days from today')\nif match:\n    print('Time:       %s' % (match.group('time')))\n    print('Offset:     %s' % (match.group('offset')))\n    print('Units:      %s' % (match.group('units')))\n    print('Direction:  %s' % (match.group('dir')))\n    print('Base time:  %s' % (match.group('base')))\nelse:\n    print(\"No match.\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Output:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n r\"\"\"\nTime:       3 pm\nOffset:     2\nUnits:      days\nDirection:  from\nBase time:  today\n\"\"\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["This regex illustrates a few lessons to be learned:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Regular expressions are very powerful (and useful)!", "tag": "none", "senID": 5}, {"text": "This regex does validate the numbers, but as you can see, doing so is cumbersome and difficult (and thus, not recommended - I'm showing it here to demonstrate why not to do it this way). It is much easier to simply capture the numbers with a regex then validate the ranges using procedural code.", "tag": "none", "senID": 6}, {"text": "Named capture groups ease the pain of plucking multiple data sub-strings from larger text.", "tag": "none", "senID": 7}, {"text": "Always write regexes using free-spacing, verbose mode with proper indentation of groups and lots of descriptive comments. This helps while writing the regex and later during maintenance.", "tag": "none", "senID": 8}]}, {"text": ["Modern regular expressions comprise a rich and powerful language.", "Once you learn the syntax and develop a habit of writing verbose, properly indented, well-commented code, then even complex regexes such as the one above are easy to write, easy to read and are easy to maintain.", "It is unfortunate that they have acquired a reputation for being difficult, unwieldy and error-prone (and thus not recommendable for complex tasks)."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "learn the syntax", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.regular-expressions.info/"}]}, {"text": ["Happy regexing!"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["what about"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n test = re.compile(r' ([0-9]|1[012])(am|pm) \\d+ days from (yesterday|today|tomorrow)')\n</code>\n</pre>\n", "senID": 1}, {"text": ["the hours part should match 0, 1, ..., 9 or 10, 11, 12\nbut not 13, 14, ..., 19."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["you can limit days part in similar way for 1, ..., 1000, i.e.", "(1000|\\d{1,3})."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ntest = re.compile('^\\s[0-1]?[0-9]{1}pm \\d+ days from (today|yesterday|tomorrow)$')\n\nprint test.match(\" 12pm 2 days from today\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["The problem that you're having is that you can't specify multiple digit numeric ranges in regex (afaik), so you have to treat them as individual characters."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Sample here"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Sample here", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "Sample here", "tag": "a"}]}, {"href": "http://codepad.org/qMQLn3Ud", "text": "Sample here", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n test = re.compile(' \\d+(am|pm) \\d+ days from (yesterday|today|tomorrow)')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you want to extract the parts of the match individually, you can label the groups with (?P&lt;name&gt;[match]).", "For example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "(?P&lt;name&gt;[match])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\npattern = re.compile(\n    r'\\s*(?P&lt;time&gt;1?[0-9])(?P&lt;ampm&gt;am|pm)\\s+'\n    r'(?P&lt;days&gt;[1-9]\\d*)\\s+days\\s+from\\s+'\n    r'(?P&lt;when&gt;yesterday|today|tomorrow)\\s*')\n\nfor time in range(0, 13):\n    for ampm in ('am', 'pm'):\n        for days in range(1, 1000):\n            for when in ('yesterday', 'today', 'tomorrow'):\n                text = ' %d%s %d days from %s ' % (time, ampm, days, when)\n                match = pattern.match(text)\n                assert match is not None\n                keys = sorted(match.groupdict().keys())\n                assert keys == ['ampm', 'days', 'time', 'when']\n\ntext = ' 3pm 2 days from today '\nprint pattern.match(text).groupdict()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {'time': '3', 'when': 'today', 'days': '2', 'ampm': 'pm'}\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n test = re.compile(' 1?\\d[ap]m \\d{1,3} days? from (?:yesterday|today|tomorrow)')\n</code>\n</pre>\n", "senID": 0}, {"text": ["EDIT"], "childNum": 0, "tag": "h2", "senID": 1, "childList": []}, {"text": ["Having read the discussion between Rumple Stiltskin and Demian Brecht, I noticed that my above proposition is poor because it detects a certain structure of string, but it doesn't validate precisely it is a good \"time-pattern\" string, because it can detect \" 18pm 2 days from today\" for exemple."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["So I propose now a pattern that allows to detect precisely a string verifying your requirement and that points out every string having the same structure as a valid one but not with the required values of a valid good \"time-pattern\" string:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nregx = re.compile(\"(?&lt;= )\"  # better than a blank as first character\n                  \"\"\n                  \"(?:(1[012]|\\d)([ap]m) (?!0 )(\\d{1,3}|1000)\"\n                  \"|\"\n                  \"(\\d+)([ap]m) (\\d+))\"\n                  \"\"\n                  \" days? from (yesterday|today|tomorrow)\") # shared part\n\n\n\n\nfor ch in (\" 12pm 2 days from today\",\n           \" 4pm 1 day from today\",\n           \" 12pm 0 days from today\",\n           \" 12pm 1001 days from today\",\n           \" 18pm 2 days from today\",\n           \" 1212pm 2 days from today\",\n           \" 12pm five days from today\"):\n\n    print ch\n    mat = regx.search(ch)\n    if mat:\n        if mat.group(1):\n            print mat.group(1,2,3,7),'\\n# time-pattern-VALIDATED string #'\n        else:\n            print mat.group(4,5,6,7),'\\n* SIMILI-time-pattern STRUCTURED string*'\n    else:\n        print '- NO STRUCTURED STRING in the text -'\n    print\n</code>\n</pre>\n", "senID": 4}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n 12pm 2 days from today\n('12', 'pm', '2', 'today') \n# time-pattern-VALIDATED string #\n\n 4pm 1 day from today\n('4', 'pm', '1', 'today') \n# time-pattern-VALIDATED string #\n\n 12pm 0 days from today\n('12', 'pm', '0', 'today') \n* SIMILI-time-pattern STRUCTURED string*\n\n 12pm 1001 days from today\n('12', 'pm', '1001', 'today') \n* SIMILI-time-pattern STRUCTURED string*\n\n 18pm 2 days from today\n('18', 'pm', '2', 'today') \n* SIMILI-time-pattern STRUCTURED string*\n\n 1212pm 2 days from today\n('1212', 'pm', '2', 'today') \n* SIMILI-time-pattern STRUCTURED string*\n\n 12pm five days from today\n- NO STRUCTURED STRING in the text -\n</code>\n</pre>\n", "senID": 6}, {"text": ["If you need only a regex that detects a time-pattern validated string, you use only"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n regx = re.compile(\"(?&lt;= )(1[012]|\\d)([ap]m) (?!0 )(\\d{1,3}|1000) days?\"\n                  \" from (yesterday|today|tomorrow)\")\n</code>\n</pre>\n", "senID": 8}], [{"text": ["It is easier (and more readable) to check integer ranges after the match:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n m = re.match(r' (\\d+)(?:pm|am) (\\d+) days from (yesterday|today|tomorrow)',\n             \" 3pm 2 days from today\")\nassert m and int(m.group(1)) &lt;= 12 and 1 &lt;= int(m.group(2)) &lt;= 1000\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or you could use an existing library e.g., pip install parsedatetime:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "pip install parsedatetime", "tag": "a", "pos": 0, "childList": [{"text": "pip install parsedatetime", "tag": "code"}], "childNum": 1, "href": "https://code.google.com/p/parsedatetime/"}, {"text": "pip install parsedatetime", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import parsedatetime.parsedatetime as pdt\n\ncal = pdt.Calendar()\nprint cal.parse(\"3pm 2 days from today\")\n</code>\n</pre>\n", "senID": 3}, {"code": "<pre>\n<code>\n ((2011, 4, 26, 15, 0, 0, 1, 116, -1), 3)\n</code>\n</pre>\n", "senID": 4}]]