[[{"text": ["First you open the file and read it into a string with readline().", "Later on you try to readline() from the string you obtained in the first step."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You need to take care what object (thing) you're handling: open() gave you a file \"jargon\", readline on jargon gave you the string \"jargonFile\"."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So jargonFile.readline does not make sense anymore "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Update as answer to comment:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Okay, now that the str error problem is solved think about the program structure:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n big loop\n  enter a search term\n  open file\n  inner loop\n     read a line\n     print result if string found\n  close file\n</code>\n</pre>\n", "senID": 5}, {"text": ["You'd need to change your program so it follows that descripiton"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Update II:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["SD, if you want to avoid reopening the file you'd still need two loops, but this time one loop reads the file into memory, when that's done the second loop asks for the search term.", "So you would structure it like"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n create empty list\nopen file\nread loop:\n    read a line from the file\n    append the file to the list\nclose file\nquery loop:\n    ask the user for input\n    for each line in the array:\n        print result if string found\n</code>\n</pre>\n", "senID": 9}, {"text": ["For extra points from your professor add some comments to your solution that mention both possible solutions and say why you choose the one you did.", "Hint: In this case it is a classic tradeoff between execution time (memory is fast) and memory usage (what if your jargon file contains 100 million entries ... ok, you'd use something more complicated than a flat file in that case, bu you can't load it in memory either."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Oh and one more hint to the second solution: Python supports tuples (\"a\",\"b\",\"c\") and lists [\"a\",\"b\",\"c\"].", "You want to use the latter one, because list can be modified (a tuple can't."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n myList = [\"Hello\", \"SD\"]\nmyList.append(\"How are you?\")\nforeach line in myList:\n    print line\n</code>\n</pre>\n", "senID": 12}, {"text": ["==>"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n Hello\nSD\nHow are you?\n</code>\n</pre>\n", "senID": 14}, {"text": ["Okay that last example contains all the new stuff (define list, append to list, loop over list) for the second solution of your program.", "Have fun putting it all together."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}], [{"text": ["Your file is jargon, not jargonFile (a string).", "That's probably what's causing your error message.", "You'll also need a second loop to read each line of the file from the beginning until you find the word you're looking for.", "Your code currently stops searching if the word is not found in the current line of the file."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "jargon", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "jargonFile", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["How about trying to write code that only gives the user one chance to enter a string?", "Input that string, search the file until you find it (or not) and output a result.", "After you get that working you can go back and add the code that allows multiple searches and ends on an empty string."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Update:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["To avoid iterating the file multiple times, you could start your program by slurping the entire file into a list of strings, one line at a time.", "Look up the readlines method of file objects.", "You can then search that list for each user input instead of re-reading the file."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "readlines", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Everytime you enter a search phrase, it looks for it on the next line, not the first one.", "You need to re-open the file for every search phrase, if you want it behave like you describe.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "next", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Take a look at the documentation for File objects:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://docs.python.org/library/stdtypes.html#file-objects"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/stdtypes.html#file-objects", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#file-objects"}]}, {"text": ["You might be interested in the readlines method.", "For a simple case where your file is not enormous, you could use that to read all the lines into a list.", "Then, whenever you get a new search string, you can run through the whole list to see whether it's there."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "readlines", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Hmm, I don't know anything at all about Python, but it looks to me like you are not iterating through all the lines of the file for the search string entered."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Typically, you need to do something like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n enter search string\nopen file\nif file has data\n   start loop\n     get next line of file\n     search the line for your string and do something\n\n   Exit loop if line was end of file\n</code>\n</pre>\n", "senID": 2}, {"text": ["So for your code:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n jargon = open(\"jargonFile.txt\",\"r\")\nsearchPhrase = raw_input(\"Enter the search phrase: \")\nwhile searchPhrase != \"\":\n    &lt;&lt;if file has data?&gt;&gt;\n      &lt;&lt;while&gt;&gt;\n        result = jargon.readline().find(searchPhrase)\n        if result == -1:\n            print \"Cannot find this term.\"\n        else:\n            print result\n      &lt;&lt;result is not end of file&gt;&gt;\n   searchPhrase = raw_input(\"Enter the search phrase: \")\njargon.close()\n</code>\n</pre>\n", "senID": 4}, {"text": ["Cool, did a little research on the page DNS provided and Python happens to have the \"with\" keyword.", "Example:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n with open(\"hello.txt\") as f:\n    for line in f:\n        print line\n</code>\n</pre>\n", "senID": 6}, {"text": ["So another form of your code could be:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n searchPhrase = raw_input(\"Enter the search phrase: \")\nwhile searchPhrase != \"\":\n    with open(\"jargonFile.txt\") as f:\n        for line in f:\n           result = line.find(searchPhrase)\n           if result == -1:\n              print \"Cannot find this term.\"\n           else:\n              print result\n    searchPhrase = raw_input(\"Enter the search phrase: \")\n</code>\n</pre>\n", "senID": 8}, {"text": ["Note that \"with\" automatically closes the file when you're done."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["you shouldn't try to re-invent the wheel.", "just use the\nre module functions.", "your program could work better if you used:\nresult = jargon.read() .", "instead of:\nresult = jargon.readline() .", "then you could use the re.findall() function\nand join the strings (with the indexes) you searched for with str.join() \nthis could get a little messy but if take some time to work it out, this could fix your problem.", "the python documentation has this perfectly documented"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re module functions", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/3.0/library/re.html?highlight=findall#re.findall"}]}]]