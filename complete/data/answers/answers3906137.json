[[{"text": ["read() reads through the entire file - so the read cursor is now at the end (with nothing more to read)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you are looking to read a certain amount of lines at a time you could use  readline() or readlines()"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "readline()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "readlines()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To answer your question, once a file has been read, with read(), calling it again will not work - you can use seek() to return the read cursor to the start of the file.", "Or save the read() output to a variable, using it in your findall expressions."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "seek()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Ps.", "Dont forget to close the file after you are done with it ;)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The read pointer moves to after the last read byte/character.", "Use the seek() method to rewind the read pointer to the beginning."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "seek()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Everyone who has answered this question so far is absolutely right - read() moves through the file, so after you've called it, you can't call it again."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What i'll add is that in your particular case, you don't need to seek back to the start or reopen the file, you can just store the text that you've read in a local variable, and use it twice, or as many times as you like, in your program:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n f = f.open()\ntext = f.read() # read the file into a local variable\n# get the year\nmatch = re.search(r'Popularity in (\\d+)', text)\nif match:\n  print match.group(1)\n# get all the names\nmatches = re.findall(r'&lt;td&gt;(\\d+)&lt;/td&gt;&lt;td&gt;(\\w+)&lt;/td&gt;&lt;td&gt;(\\w+)&lt;/td&gt;', text)\nif matches:\n  # matches will now not always be None\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Every open file has an associated position.", "When you read() you read from that position.", "For example read(10) reads the first 10 bytes from a newly opened file, then another read(10) reads the next 10 bytes.", "read() without arguments reads all of the contents of the file, leaving the file position at the end of the file.", "Next time you call read() there is nothing to read."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "read(10)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "read(10)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "read()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "read()", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"text": ["You can use seek to move the file position.", "Or probably better in your case would be to do one read() and keep the result for both searches."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "seek", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "read()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["yeah, as above..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["i'll write just an example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = open('file.txt')\n&gt;&gt;&gt; a.read()\n#output\n&gt;&gt;&gt; a.seek(0)\n&gt;&gt;&gt; a.read()\n#same output\n</code>\n</pre>\n", "senID": 2}], [{"text": ["read() consumes.", "So, you could reset the file, or seek to the start before re-reading.", "Or, if it suites your task, you can use read(n) to consume only n bytes."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "read()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "consumes", "childNum": 0, "tag": "i", "pos": -1, "childList": []}, {"text": "reset", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "seek", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "read(n)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I always find the read method something of a walk down a dark alley.", "You go down a bit and stop but if you are not counting your steps you are not sure how far along you are.", "Seek gives the solution by repositioning, the other option is Tell which returns the position along the file.", "May be the Python file api can combine read and seek into a read_from(position,bytes) to make it simpler - till that happens you should read this page."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this page", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html?#file-objects"}]}]]