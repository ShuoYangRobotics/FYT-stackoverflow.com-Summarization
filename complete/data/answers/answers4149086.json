[[{"text": ["I don't believe there's any way to do this in a language with no run-time introspection capabilities."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["perhaps xml Data Binding?", "gsoap is just one of many options.", "You can automatically generate code for mapping between data structure and xml schema.", "Not sure that setting this up would be easier than other options you mention"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Data Binding", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "gsoap", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://gsoap2.sourceforge.net/"}]}], [{"text": ["This is not possible in C++.", "Python, C#, Java et al.", "use run-time introspection to achieve this.", "You can't do that in C++, RTTI is not powerful enough."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In essence, there is nothing in the C++ language that would enable someone to discover the member variables of an object at run-time.", "Without that, you can't automatically serialize them."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["it's true that C++ does not have run-time introspection, but I think Roni was asking for a solution more like what, for instance, swig does: parse the c++ code in a separate step and generate a serialization interface automatically.", "the problem seems to be that using the methods he mentions, whenever a member is added or removed from the class definition the serialization stuff needs to be altered, and forgetting to do so could mean some members get defaults when unserializing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["There's the standard C++ serialization with the &lt;&lt; and >> operators, although you'll have to implement these for each of your classes (which it sounds like you don't want to do).", "Some practitioners say you should alway implement these operators, although of course, most of us rarely do."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["One quick way to do this that I got working once when I needed to save a struct to a file was to cast my struct to a char array and write it out to a file.", "Then when I wanted to load my struct back in, I would read the entire file (in binary mode), and cast the whole thing to my struct's type.", "Easy enough and exploits the fact that structs are stored as a contiguous block in memory.", "I wouldn't expect this to work with convoluted data structures or pointers, though, but food for thought."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "char", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]