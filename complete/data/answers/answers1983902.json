[[{"text": ["It's not the fastest way but I think it's quite easy to understand:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def transpose(grid):\n    return zip(*grid)\n\ndef removeBlankRows(grid):\n    return [list(row) for row in grid if any(row)]\n\nprint removeBlankRows(transpose(removeBlankRows(transpose(grid))))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [[{'some': 'thing'}, None, None],\n [None, None, {'something': 'else'}],\n [None, {'another': 'thing'}, None]]\n</code>\n</pre>\n", "senID": 3}, {"text": ["How it works: I use zip to write a function that transposes the rows and columns.", "A second function removeBlankRows removes rows where all elements are None (or anything that evaluates to false in a boolean context).", "Then to perform the entire operation I transpose the grid, remove blank rows (which are the columns in the original data), transpose again, then remove blank rows."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "removeBlankRows", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If it's important to only strip None and not other things that evaluate to false, change the removeBlankRows function to:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def removeBlankRows(grid):\n    return [list(row) for row in grid if any(x is not None for x in row)]\n</code>\n</pre>\n", "senID": 6}], [{"code": "<pre>\n<code>\n grid = ...\n\n# remove empty rows\ngrid = [x for x in grid if any(x)]\n# if any value you put in won't evaluate to False\n# e.g. an empty string or empty list wouldn't work here\n# in that case, use:\ngrid = [x for x in grid if any(n is not None for n in x)]\n\n# remove empty columns\nif not grid:\n  raise ValueError(\"empty grid\")\n  # or whatever, as next line assumes grid[0] exists\nempties = range(len(grid[0])) # assume all empty at first\nfor r in grid:\n  empties = [c for c in empties if r[c] is None] # strip out non-empty\nif empties:\n  empties.reverse() # apply in reversed order\n  for r in grid:\n    for c in empties:\n      r.pop(c)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Use zip() to transpose the ragged array, run the clearing routine again, then zip() it again."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "zip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "zip()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If only you had a transpose function, you could do: transpose(removeRows(transpose(removeRows(mat))))"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Actually ... using a bitmask is a better idea."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Let me think about that ..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["First compute gridmask:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n grid_mask = [\n10000,\n00000,\n00000,\n00010,\n00000\n]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now remove zeroes:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n grid_mask = [\n10000,\n00010,\n]\n</code>\n</pre>\n", "senID": 6}, {"text": ["Now and all values bitwise:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n grid_mask = 10010\n</code>\n</pre>\n", "senID": 8}, {"text": ["Now remove all but 1st and 4th columns."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["Here is quick attempt"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It will work for any size matrix and rows can be different sizes too , and may be fast :)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\ngrid = [\n        [{\"some\" : \"thing\"}, None, None, None, None],\n        [None, None, None, None, None],\n        [None, None, None, None, None],\n        [None, None, None, {\"something\" : \"else\"}, None],\n        [None, {\"another\" : \"thing\"}, None, None, None],\n        [None, None, None, None, None],\n        ]\n\n# go thru the grid remove, rows which have all None\n# doing that count None in each columns, remove such columns later\nnewGrid = []\ncolSize = len(grid)\ncolCount = defaultdict(int)\nfor row in grid:\n    allNone = True\n    for c, cell in enumerate(row):\n        if cell is None:\n            colCount[c] += 1\n        else:\n            allNone = False\n\n    if not allNone: # only add rows which are not all none\n        newGrid.append(row)\n\n# get cols which need to be removed\nremoveCols = [col for col, count in colCount.iteritems() if count == colSize]\nremoveCols.sort(reverse=True) \n\n# now go thru each column and remove all None Columns\nfor row in newGrid:\n    for col in removeCols:\n        row.pop(col)\n\ngrid = newGrid\nimport pprint\npprint.pprint(grid)\n</code>\n</pre>\n", "senID": 2}, {"text": ["output:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "output:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n [[{'some': 'thing'}, None, None],\n [None, None, {'something': 'else'}],\n [None, {'another': 'thing'}, None]]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You can also use the built-in function any(), which checks if any of the elements of an iterable has a not None value.", "It's faster than comparing and you don't need to know the size of the iterable."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "any()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def remove_rows( matrix ):\n...    '''Returns a matrix without empty rows'''\n...    ret_matrix = []\n...    for row in matrix:\n...        #Check if the row has any value or all are None\n...        if any(row):\n...            ret_matrix.append(row)\n...\n...    return ret_matrix\n#You can do it also with a list comprehension, which will be even faster\n&gt;&gt;&gt; def remove_rows(matrix):\n...     '''Returns a matrix without empty rows'''\n...     ret_matrix = [ row for row in matrix if  any(row) ]\n...     return ret_matrix\n\n&gt;&gt;&gt; grid = [\n...         [{\"some\" : \"thing\"}, None, None, None, None],\n...         [None, None, None, None, None],\n...         [None, None, None, None, None],\n...         [None, None, None, {\"something\" : \"else\"}, None],\n...         [None, {\"another\" : \"thing\"}, None, None, None],\n...         [None, None, None, None, None],\n...         ]\n\n\n&gt;&gt;&gt; grid = remove_rows( grid )\n&gt;&gt;&gt; grid\n[\n [{'some': 'thing'}, None, None, None, None], \n [None, None, None, {'something': 'else'}, None], \n [None, {'another': 'thing'}, None, None, None]\n]\n\n#transpose grid using zip (using asterisk)\n&gt;&gt;&gt; grid = zip(*grid)\n#Note that zip returns tuples\n&gt;&gt;&gt; grid\n[\n  ({'some': 'thing'}, None, None), \n  (None, None, {'another': 'thing'}),\n  (None, None, None), \n  (None, {'something': 'else'}, None), \n  (None, None, None)\n]\n\n&gt;&gt;&gt; grid = remove_rows(grid)\n&gt;&gt;&gt; grid\n[\n  ({'some': 'thing'}, None, None), \n  (None, None, {'another': 'thing'}),\n  (None, {'something': 'else'}, None)\n]\n&gt;&gt;&gt; #Transpose again to get the first matrix, without empty rows or columns\n&gt;&gt;&gt; final_grid = zip(*grid)\n&gt;&gt;&gt; final_grid\n[\n ({'some': 'thing'}, None, None),\n (None, None, {'something': 'else'}), \n (None, {'another': 'thing'}, None)\n]\n</code>\n</pre>\n", "senID": 1}]]