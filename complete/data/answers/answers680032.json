[[{"text": ["A variable name is just a name--it has no real meaning as far as the program is concerned, except as a convenience to the programmer (this isn't quite true in Python, but bear with me).", "As far as the Python interpreter is concerned, the name dict1 is just the programmer's way of telling Python to look at memory address 0x1234."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "dict1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "0x1234", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Furthermore, the very idea of turning a memory address (0x1234) back into a variable name (dict1) doesn't make sense, especially considering that more than one variable name can reference the same object:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "0x1234", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict1", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n dict1 = {...}\ndictCopy = dict1\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now dictCopy is just as much the name of the dictionary as dict1 is--they both reference the same thing.", "If the function you're looking for existed, which name should Python choose?"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "dictCopy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["To add what zenazn said:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The short answer is that you don't want really want to.", "If you think you need to, there's something very wrong with the design of your program.", "If you told us more concretely what problem you were trying to solve, we could help you work out a better way to accomplish it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The trivial answer: instead of"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n WhichDict[WhichDict.keys()[0]][2]='newcomment'\n</code>\n</pre>\n", "senID": 1}, {"text": ["use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n WhichDict.values()[0][2]='newcomment'\n</code>\n</pre>\n", "senID": 3}, {"text": ["But using a dictionary to represent a single movie is grossly inappropriate.", "Why not use a class instead?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class Movie(object):\n    def __init__(self, filename, movie_duration, movie_type, comments):\n        self.filename = filename\n        self.movie_duration = movie_duration\n        self.movie_type = movie_type\n        self.comments = comments\n\ndatabase = dict()\ndatabase['unique_id_1'] = Movie(\"FooBar1.avi\", duration, type, comments)\n# ...\n\nsome_movie = database[some_id]\nsome_movie.comment = 'newcomment'\n</code>\n</pre>\n", "senID": 5}], [{"text": ["You need to rethink your design."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A quick hack would be to actually put the variable name in ..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n dict2['item_n'] = 'dict1'\n</code>\n</pre>\n", "senID": 2}, {"text": ["or maybe use a tuple .."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n dict2['item_n'] = ('dict1', dict1)\n</code>\n</pre>\n", "senID": 4}, {"text": ["There's a function called locals() which gives a dictionary of local variable names, maybe you can consider it when you rethink about your design."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "locals()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Here, have a look at how locals() works:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "locals()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = 10\n&gt;&gt;&gt; y = 20\n&gt;&gt;&gt; c = \"kmf\"\n&gt;&gt;&gt; olk = 12\n&gt;&gt;&gt; km = (1,6,\"r\",x)\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; pprint( locals() )\n{'__builtins__': &lt;module '__builtin__' (built-in)&gt;,\n '__doc__': None,\n '__name__': '__main__',\n 'c': 'kmf',\n 'km': (1, 6, 'r', 10),\n 'olk': 12,\n 'pprint': &lt;function pprint at 0x016A0EB0&gt;,\n 'x': 10,\n 'y': 20}\n</code>\n</pre>\n", "senID": 7}, {"tag": "hr", "senID": 8}, {"text": ["UPDATE"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "UPDATE", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Well, this is trivial"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["dict_databse[identifier][2] = the_new_comment"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["Right now, for each movie, you're doing:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dict_n = {}\ndict_n[\"000n\"] = [movie_duration,movie_type,comments]\n</code>\n</pre>\n", "senID": 1}, {"text": ["with only one entry per dict.", "Then you're storing multiple movie dicts in a central one:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n dict_database = {}\ndict_database[\"0001\"] = dict_1\ndict_database[\"0002\"] = dict_2\ndict_database[\"0003\"] = dict_3\ndict_database[\"000n\"] = dict_n\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit: This is probably what you had in mind."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["For each movie, there's a dict going from property names to values."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n movie_n = {}\nmovie_n[\"movie_duration\"] = 333\nmovie_n[\"movie_type\"] = \"Fantasy\"\nmovie_n[\"comments\"] = \"\"\n</code>\n</pre>\n", "senID": 6}, {"text": ["Then movies[\"any_file.avi\"] gives you that dict.", "To add the movie to the directory and then add a comment, you enter:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "movies[\"any_file.avi\"]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n movies[\"any_file.avi\"] = movie_n\nmovies[\"any_file.avi\"][\"comments\"] = \"new comment\"\n</code>\n</pre>\n", "senID": 8}, {"text": ["If you have to choose between the number of that movie and the filename, I'd go with the filename because it's simply more relevant when you're actually trying to access a movie.", "Plus, if necessary you can enumerate your movies (albeit out of order) through movies.keys() or something similar.", "If you want to use both a number and the filename, add the filename as another key for each movie."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "movies.keys()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n movie_n[\"filename\"] = \"any_file.avi\"\n</code>\n</pre>\n", "senID": 10}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n movies[\"000n\"][\"filename\"] = \"any_file.avi\"\n</code>\n</pre>\n", "senID": 12}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; print dict2['nth_dict_item'] is dict1\nTrue\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Use Guppy."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Guppy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://guppy-pe.sourceforge.net/"}]}, {"code": "<pre>\n<code>\n from guppy import hpy\nh=hpy()\nh.iso(dict2['nth_dict_item']).sp\n\n0: h.Root.i0_modules['__main__'].__dict__['dict1']\n</code>\n</pre>\n", "senID": 1}]]