[[{"text": ["Expressed as a generator function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def neighborhood(iterable):\n    iterator = iter(iterable)\n    prev = None\n    item = iterator.next()  # throws StopIteration if empty.\n    for next in iterator:\n        yield (prev,item,next)\n        prev = item\n        item = next\n    yield (prev,item,None)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for prev,item,next in neighborhood(l):\n    print prev, item, next\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit: I thought it would reduce the readability, but this way seem to look better."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["When dealing with generators where you need some context, I often use the below utility function to give a sliding window view on an iterator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import collections, itertools\n\ndef window(it, winsize, step=1):\n    \"\"\"Sliding window iterator.\"\"\"\n    it=iter(it)  # Ensure we have an iterator\n    l=collections.deque(itertools.islice(it, winsize))\n    while 1:  # Continue till StopIteration gets raised.\n        yield tuple(l)\n        for i in range(step):\n            l.append(it.next())\n            l.popleft()\n</code>\n</pre>\n", "senID": 1}, {"text": ["It'll generate a view of the sequence N items at a time, shifting step places over.", "eg."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(window([1,2,3,4,5],3))\n[(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["When using in lookahead/behind situations where you also need to deal with numbers without having a next or previous value, you may want pad the sequence with an appropriate value such as None."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n l= range(10)\n# Print adjacent numbers\nfor cur, next in window(l + [None] ,2):\n    if next is None: print \"%d is the last number.\" % cur\n    else: print \"%d is followed by %d\" % (cur,next)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Check out the looper utility from the Tempita project.", "It gives you a wrapper object around the loop item that provides properties such as previous, next, first, last etc."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Tempita project", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pythonpaste.org/tempita/#bunch-and-looper"}]}, {"text": ["Take a look at the source code for the looper class, it is quite simple.", "There are other such loop helpers out there, but I cannot remember any others right now."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "source code", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.pythonpaste.org/Tempita/trunk/tempita/_looper.py"}]}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n > easy_install Tempita\n> python\n>>> from tempita import looper\n>>> for loop, i in looper([1, 2, 3]):\n...     print loop.previous, loop.item, loop.index, loop.next, loop.first, loop.last, loop.length, loop.odd, loop.even\n... \nNone 1 0 2 True False 3 True 0\n1 2 1 3 False False 3 False 1\n2 3 2 None False True 3 True 0\n</code>\n</pre>\n", "senID": 3}], [{"text": ["you can iterate through a list 3 at a time, or in n-tuples:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/303279"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/303279", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/303279"}]}, {"text": ["http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/303060"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/303060", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/303060"}]}], [{"code": "<pre>\n<code>\n l=[1,2,3]\nfor i,item in enumerate(l):\n    if item==2:\n        get_previous=l[i-1]\n        print get_previous\n\n&gt;&gt;&gt;1\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Iterators only have the next() method so you cannot look forwards or backwards, you can only get the next item."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["enumerate(iterable) can be useful if you are iterating a list or tuple."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I don't think there is a straightforward way, especially that an iterable can be a generator (no going back).", "There's a decent workaround, relying on explicitly passing the index into the loop body:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for itemIndex, item in enumerate(l):\n    if itemIndex&gt;0:\n        previousItem = l[itemIndex-1]\n    else:\n        previousItem = None\n</code>\n</pre>\n", "senID": 1}, {"text": ["The enumerate() function is a builtin."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "enumerate()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Immediately previous?  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You mean the following, right?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n previous = None\nfor item in someList:\n    if item == target: break\n    previous = item\n# previous is the item before the target\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you want n previous items, you can do this with a kind of circular queue of size n."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "n", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "n", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n queue = []\nfor item in someList:\n    if item == target: break\n    queue .append( item )\n    if len(queue ) &gt; n: queue .pop(0)\nif len(queue ) &lt; n: previous = None\nprevious = previous[0]\n# previous is *n* before the target\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Not very pythonic, but gets it done and is simple:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l=[1,2,3]\nfor index in range(len(l)):\n    if l[index]==2:\n        l[index-1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["TO DO: protect the edges "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The most simple way is to search the list for the item:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def get_previous(l, item):\n    idx = l.find(item)\n    return None if idx == 0 else l[idx-1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course, this only works if the list only contains unique items.", "The other solution is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for idx in range(len(l)):\n    item = l[idx]\n    if item == 2:\n        l[idx-1]\n</code>\n</pre>\n", "senID": 3}]]