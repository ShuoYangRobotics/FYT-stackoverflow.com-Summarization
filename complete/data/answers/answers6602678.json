[[{"code": "<pre>\n<code>\n d = [{'A': [3, 45, 34, 4, 2, 5, 94, 2139, 230345, 283047, 230847]}, {'B': [92374, 324, 345, 345, 45879, 34857987, 3457938457]}, {'C': [23874923874987, 2347]}]\n[{x.keys()[0]:sum(x.values()[0])} for x in d]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a={'a':range(100), 'b':range(200)}\nb={}\n\nfor k,v in a.iteritems():\n    b[k]=sum(v)\n\nprint b\n</code>\n</pre>\n", "senID": 1}, {"text": ["gives"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {'a': 4950, 'b': 19900}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Assuming the values are in a list,  like: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d = {A: [3, 45, 34, 4, 2, 5, 94, 2139, 230345, 283047, 230847]}, {B: [92374, 324, 345, 345, 45879, 34857987, 3457938457]), {C: [23874923874987, 2347]}\n</code>\n</pre>\n", "senID": 1}, {"text": ["then:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n new_d = []\nfor i in d:\n    new_d.append(dict([(k,sum(v)) for k,v in i.itervalues()]))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If you have lots and lots and lots of values, something like this might work (assuming by \"list of dictionaries\" you mean \"dictionary of lists\", as having a big list of one-key/value-pair dictionaries would be silly, and thus the values are stored in a dict like {'A': [3, 45, 34, 4, 2, 5, 94, 2139, 230345, 283047, 230847], 'B': [92374, 324, 345, 345, 45879, 34857987, 3457938457], ...}):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "{'A': [3, 45, 34, 4, 2, 5, 94, 2139, 230345, 283047, 230847], 'B': [92374, 324, 345, 345, 45879, 34857987, 3457938457], ...}", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from multiprocessing import Process, Lock\n\ndef sumfunc(lock, key, values):\n    total = sum(values)\n\n    lock.acquire()\n    print(key + ':', total)   # The actual code would be better off utilizing shared multiprocessing.Array objects, but I haven't used them before so am not sure quite how you set them up so decided to leave that aside for now as this is just a theoretical example.\n    lock.release()\n\nif __name__ == '__main__':\n    lock = Lock()\n\n    for key, values in dict_of_values_to_sum.items():\n        Process(target=sumfunc, args=(lock, key, values)).start()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you have a real big number of values i'll probably use numpy and do a vector addition."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So, something like"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a = numpy.arange(10, 2000000)\n total = numpy.sum(a)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Nothing more, nothing less :)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n d = [{'A': [3, 45, 34, 4, 2, 5, 94, 2139, 230345, 283047, 230847]}, {'B': [92374, 324, 345, 345, 45879, 34857987, 3457938457]}, {'C': [23874923874987, 2347]}]\nabc = {}\nfor x in d:\n    for k, v in x.iteritems():\n        abc[k] = reduce(lambda x,y: x+y, v)\n</code>\n</pre>\n", "senID": 0}]]