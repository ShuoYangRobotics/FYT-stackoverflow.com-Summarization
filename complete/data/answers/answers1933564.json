[[{"text": ["Though this doesn't answer your question (other answers are getting at that) something that has helped me a lot in doing things similar to what you're doing are List Comprehensions.", "They allow you to build lists in a concise and (I think) easy to read way. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "List Comprehensions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions"}]}, {"text": ["For instance, the below code builds a 2-dimenstional array with the values you're trying to get at.", "some_funct here would be a little regex, if I were doing it, that uses the index of the last space in the key as the parameter, and looks ahead to collect the value you're trying to get in the line (the value which corresponds to the key currently being looked at) and appends it to the correct index in the seen_keys 2D array. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "some_funct", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Wordy, yes, but if you get list-comprehension and you're able to construct the regex to do that, you've got a nice, concise solution. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n keys = [\"model.paramName \",\"model.paramValue \",\"model.optimizeParam \"\"model.paramLowerBound \",\"model.paramUpperBound \"]\nfor line in lines:\n    seen_keys = [[],[],[],[],[]]\n    [seen_keys[keys.index(k)].some_funct(line.index(k) for k in keys if k in line]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["There is a lot of duplication there, and if you ever add another key or param, you're going to have to add it in many places, which leaves you ripe for errors.", "What you want to do is pare down all of the places you have repeated things and use some sort of data model, such as a dict."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "key", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "param", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Some others have provided some excellent examples, so I'll just leave my answer here to give you something to think about."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["It's not totally easy to see the expected format.", "From what I can see, the format is like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n lines = [\n    \"model.paramName 1 foo\",\n    \"model.paramValue 2 bar\",\n    \"model.optimizeParam 3 bat\",\n    \"model.paramLowerBound 4 zip\",\n    \"model.paramUpperBound 5 ech\",\n    \"model.paramName 1 foo2\",\n    \"model.paramValue 2 bar2\",\n    \"model.optimizeParam 3 bat2\",\n    \"model.paramLowerBound 4 zip2\",\n    \"model.paramUpperBound 5 ech2\",\n]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I don't see the above code working if there is more than one value in each line.", "Which means the digit is not really significant unless I'm missing something.", "In that case this works very easily:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef parse_params(num_of_params,lines):\n    key_to_collection = {\n        \"model.paramName\":names,\n        \"model.paramValue\":params,\n        \"model.optimizeParam\":optimize,\n        \"model.paramLowerBound\":upper,\n        \"model.paramUpperBound\":lower,\n    }\n\n    reg = re.compile(r'(.+?) (\\d) (.+)')\n\n    for line in lines:\n        m = reg.match(line)\n        key, digit, value = m.group(1, 2, 3)\n        key_to_collection[key].append(value)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["It's not entirely obvious from your code, but it looks like each line can have one \"hit\" at most; if that's indeed the case, then something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef parse_params(num_of_params, lines):\n  sn = 'Names Params Optimize Upper Lower'.split()\n  ks = '''paramName paramValue optimizeParam\n          paramLowerBound paramUpperBound'''.split()\n  vals = dict((k, []) for k in ks)\n  are = re.compile(r'model\\.(%s) (\\d+) (.*)' % '|'.join(ks))\n  for line in lines:\n    mo = are.search(line)\n    if not mo: continue\n    p = int(mo.group(2))\n    if p &lt; 1 or p &gt; num_of_params: continue\n    vals[mo.group(1)].append(mo.group(3).rstrip())\n  for k, s in zip(ks, sn):\n    print '%-8s =' % s,\n    print vals[k]\n</code>\n</pre>\n", "senID": 1}, {"text": ["might work -- I exercised it with a little code as follows:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if __name__ == '__main__':\n  lines = '''model.paramUpperBound 1 ZAP\n    model.paramLowerBound 1 zap\n    model.paramUpperBound 5 nope'''.splitlines()\n  parse_params(2, lines)\n</code>\n</pre>\n", "senID": 3}, {"text": ["and it emits"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n Names    = []\nParams   = []\nOptimize = []\nUpper    = ['zap']\nLower    = ['ZAP']\n</code>\n</pre>\n", "senID": 5}, {"text": ["which I think is what you want (if some details must differ, please indicate exactly what they are and let's see if we can fix it)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["The two key ideas are: use a dict instead of lots of ifs; use a re to match \"any of the following possibilities\" with parenthesized groups in the re's pattern to catch the bits of interest (the keyword after model., the integer number after that, and the \"value\" which is the rest of the line) instead of lots of if x in y checks and string manipulation."], "childNum": 5, "tag": "p", "senID": 7, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "if", "childNum": 0, "tag": "code", "childList": []}, {"text": "re", "childNum": 0, "tag": "code", "childList": []}, {"text": "model.", "childNum": 0, "tag": "code", "childList": []}, {"text": "if x in y", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The code given in the OP does multiple tests per line to try to match against the expected set of values, each of which is being constructed on the fly.", "Rather than construct paramValue1, paramValue2, etc.", "for each line, we can use a regular expression to try to do the matching in a cheaper (and more robust) manner."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "paramValue1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "paramValue2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Here's my code snippet, drawing from some ideas that have already been posted.", "This lets you add a new keyword to the key_to_collection dictionary and not have to change anything else."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "key_to_collection", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\ndef parse_params(num_of_params, lines):\n\n    pattern = re.compile(r\"\"\"\n        model\\.\n        (.+)    # keyword\n        (\\d+)   # index to keyword\n        [ ]+    # whitespace\n        (.+)    # value\n        \"\"\", re.VERBOSE)\n\n    key_to_collection = {\n        \"paramName\": names,\n        \"paramValue\": params,\n        \"optimizeParam\": optimize,\n        \"paramLowerBound\": upper,\n        \"paramUpperBound\": lower,\n    }\n\n    for line in lines:\n        match = pattern.match(line)\n        if not match:\n            print \"Invalid line: \" + line\n        elif match[1] not in key_to_collection:\n            print \"Invalid key: \" + line\n        # Not sure if you really care about enforcing this\n        elif match[2] &gt; num_of_params:\n            print \"Invalid param: \" + line\n        else:\n            key_to_collection[match[1]].append(match[3])\n</code>\n</pre>\n", "senID": 2}, {"text": ["Full disclosure: I have not compiled/tested this."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Are you sure that parse_params is the bottle-neck?", "Have you profiled your app?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nfrom collections import defaultdict \n\nnames = (\"paramName paramValue optimizeParam \"\n         \"paramLowerBound paramUpperBound\".split())\nstmt_regex = re.compile(r'model\\.(%s)\\s+(\\d+)\\s+(.*)' % '|'.join(names))\n\ndef parse_params(num_of_params, lines):\n    stmts = defaultdict(list)\n    for m in (stmt_regex.match(s) for s in lines):\n        if m and 1 &lt;= int(m.group(2)) &lt;= num_of_params: \n           stmts[m.group(1)].append(m.group(3).rstrip())\n\n    for k, v in stmts.iteritems():\n        print \"%s = %s\" % (k, ' '.join(v))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It can certainly be made more efficient.", "But, to be honest, unless this function is called hundreds of times a second, or works on thousands of lines, is it necessary?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I would be more concerned about making it clear what is happening... currently, I'm far from clear on that aspect."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Just eyeballing it, the input seems to look like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["model.paramName 1 A model.paramValue 1 B model.optimizeParam 1 C model.paramLowerBound 1 D model.paramUpperBound 1 E model.paramName 2 F model.paramValue 2 G model.optimizeParam 2 H model.paramLowerBound 2 I model.paramUpperBound 2 J"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "model.paramName 1 A model.paramValue 1 B model.optimizeParam 1 C model.paramLowerBound 1 D model.paramUpperBound 1 E model.paramName 2 F model.paramValue 2 G model.optimizeParam 2 H model.paramLowerBound 2 I model.paramUpperBound 2 J", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["And your desired output seems to be something like:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\nNames     = AF\nParams    = BG\netc...\n</pre>\n", "senID": 5}, {"text": ["Now, since my input certainly doesn't match yours, the output is likely off too, but I think I have the gist."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["There are a few points.", "First, does it matter how many parameters are passed to the function?", "For example, if the input has two sets of parameters, do I just want to read both, or is it necessary to allow the function to only read one?", "For example, your code allows me to call parse_params(1,1) and have it only read parameters ending in a 1 from the same input.", "If that's not actually a requirement, you can skip a large chunk of the code."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "parse_params(1,1)", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Second, is it important to ONLY read the given parameters?", "If I, for example, have a parameter called 'paramFoo', is it bad if I read it?", "You can also simplify the procedure by just grabbing all parameters regardless of their name, and extracting their value."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def parse_params(input):\n  parameter_list = {}\n  param = re.compile(r\"model\\.([^ ]+) [0-9]+ ([^ ]+)\")\n  each_parameter = param.finditer(input)\n  for match in each_parameter:\n    key = match[0]\n    value = match[1]\n    if not key in paramter_list:\n      parameter_list[key] = []\n\n    parameter_list[key].append(value)\n\n  return parameter_list\n</code>\n</pre>\n", "senID": 9}, {"text": ["The output, in this instance, will be something like this:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["{'paramName':[A, F], 'paramValue':[B, G], 'optimizeParam':[C, H], etc...}"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Notes: I don't know Python well, I'm a Ruby guy, so my syntax may be off.", "Apologies."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}]]