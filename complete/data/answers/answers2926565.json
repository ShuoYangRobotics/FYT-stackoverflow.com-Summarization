[[{"text": ["I study programming languages for a living.", "I've never seen a language with a built-in syntax for that operation.", "I'm not even sure what you want such a syntax to look like, especially since you can define a function for any of these patterns."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["People who like extensible syntax tend to define Lisp macros :-)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Are you looking for function overloading?", "For example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "function overloading", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Function_overloading"}]}, {"code": "<pre>\n<code>\n doSomething(Person p);\n// these could do lookup and dispatch to doSomething(Person p)...\ndoSomething(String personName);\ndoSomething(Integer personId);\n</code>\n</pre>\n", "senID": 1}, {"text": ["Any OO strongly-typed language should be able to do that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For dynamically-typed languages though I'm not aware of any other way than manually doing some kind of type check (instanceof) operation, and that method can get nasty really fast.", "You're better off just doing what we did before OOP: use differently-named functions, for example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n doSomethingByName(personName);\ndoSomethingById(personId);\n</code>\n</pre>\n", "senID": 4}, {"text": ["If your code is well-structured otherwise, most of these \"duplicate\" functions will be pretty small."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Scheme, LISP, or just about any language with macro's."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can do this in any language that doesn't check the type of function parameters at compile time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["JavaScript:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n function doSomething(person)\n{\n  var name;\n  if(typeof(person) == \"string\")\n    name = person;\n  else\n    name = person.name;\n  //you can simplify it to\n  name = (typeof(person) == \"string\") ? name : person.name;\n}\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I've never seen built-in syntax for this in any language I've used."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "built-in", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Note that in Python this is typically handled by exceptions:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def getMyRelatedStuff(person_or_id):\n    \"The verbose way\"\n    try:\n        my_id= person_or_id.id\n    except AttributeError:\n        my_id= person_or_id\n</code>\n</pre>\n", "senID": 2}, {"text": ["but preferably:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def getMyRelatedStuff(person_or_id):\n    \"The terse way\"\n    my_id= getattr(person_or_id, \"id\", person_or_id)\n</code>\n</pre>\n", "senID": 4}, {"text": ["and as for someFileStuff:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "someFileStuff", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def someFileStuff(file_or_name):\n    try:\n        fobj= open(file_or_name)\n    except TypeError:\n        fobj= file_or_name\n</code>\n</pre>\n", "senID": 6}, {"text": ["Try to avoid using built-in names like id and file in your code; they introduce subtle bugs to your programs."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "id", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "file", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Lisp"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Lisp", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This can easily be implemented using Lisp macros:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n (defmacro get-if-not [func val alt]\n  `(if (~func ~val)\n    ~val\n    ~alt))\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can use that expression like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n (get-if-not file? file_or_name (open file_or_name))\n</code>\n</pre>\n", "senID": 4}, {"text": ["That will expand to:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n (if (file? file_or_name) file_or_name (open file_or_name))\n</code>\n</pre>\n", "senID": 6}, {"text": ["Macros are incredible.", "I personally refuse to use any language that doesn't have them."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]]