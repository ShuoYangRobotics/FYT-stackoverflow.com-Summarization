[[{"text": ["Try a more pythonic approach to the filtering, something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [x for x in list1 if x not in set(list2)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Converting both lists to sets is unnessescary, and will be very slow and memory hungry on large amounts of data."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Since your data is a list of lists, you need to do something in order to hash it.", "Try out"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n list2_set = set([tuple(x) for x in list2])\ndiff = [x for x in list1 if tuple(x) not in list2_set]\n</code>\n</pre>\n", "senID": 4}, {"text": ["I tested out your original function, and my approach, using the following test data:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n list1 = [[x+1, x*2] for x in range(38000)]\nlist2 = [[x+1, x*2] for x in range(10000, 160000)]\n</code>\n</pre>\n", "senID": 6}, {"text": ["Timings - not scientific, but still:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n #Original function\n real    2m16.780s\n user    2m16.744s\n sys     0m0.017s\n\n #My function\n real    0m0.433s\n user    0m0.423s\n sys     0m0.007s\n</code>\n</pre>\n", "senID": 8}], [{"text": ["There are 2 issues that cause your algorithm to scale poorly:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Both situations cause it to scale poorly O(n^2) for large amounts of data.", "gnud's implementation would probably be the best solution since it solves both problems without changing the order of elements or removing potential duplicates."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If we rule the data structure itself out, look at your memory usage next.", "If you end up asking the OS to swap in for you (i.e., the list takes up more memory than you have), Python's going to sit in iowait waiting on the OS to get the pages from disk, which makes sense given your description."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "iowait", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Is Python sitting in a jacuzzi of iowait when this slowdown happens?", "Anything else going on in the environment?"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "iowait", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["(If you're not sure, update with your platform and one of us will tell you how to tell."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The only reason why the code can become slower is that you have big elements in both lists which share a lot of common elements (so the list1[curIndex] in list2 takes more time)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "list1[curIndex] in list2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Here are a couple of ways to fix this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["If you don't care about the order, convert both lists into sets and use set1.difference(set2)"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set1.difference(set2)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If the order in list1 is important, then at least convert list2 into a set because in is much faster with a set."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "list2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "in", "childNum": 0, "tag": "code", "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Lastly, try a filter: filter(list1, lambda x: x not in set2)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "filter(list1, lambda x: x not in set2)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}, {"text": ["[EDIT] Since set() doesn't work on recursive lists (didn't expect that), try:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "set()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n result = filter(list1, lambda x: x not in list2)\n</code>\n</pre>\n", "senID": 6}, {"text": ["It should still be much faster than your version.", "If it isn't, then your last option is to make sure that there can't be duplicate elements in either list.", "That would allow you to remove items from both lists (and therefore making the compare ever cheaper as you find elements from list2)."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "both", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "list2", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["EDIT: I've updated my answer to account for lists being unhashable, as well as some other feedback.", "This one is even tested."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It probably relates to the cost of poping an item out of a middle of a list."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Alternatively have you tried using sets to handle this?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def difference(list1, list2):\n    return [x for x in list1 if tuple(x) in set(tuple(y) for y in list2)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["You can then set list one to the resulting list if that is your intention by doing"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n list1 = difference(list1, list2)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["The often suggested set wont work here, because the two lists contain lists, which are unhashable.", "You need to change your data structure first."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You can"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "convert the sublists into tuples or class instances to make them hashable, then use sets.", "tag": "none", "senID": 2}, {"text": "Keep both lists sorted, then you just have to compare the lists' heads.", "tag": "none", "senID": 3}]}]]