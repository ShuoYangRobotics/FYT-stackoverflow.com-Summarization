[[{"text": ["Yes, map(f, L) is equivalent to [f(x) for x in L].", "filter(f, L) is equivalent to [x for x in L if f(x)].", "But, since list comprehensions with side effects are generally bad (and here you modify the state of the generator), you can use itertools for a bit cleaner solution:"], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "map(f, L)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[f(x) for x in L]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "filter(f, L)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "[x for x in L if f(x)]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "itertools", "tag": "a", "pos": 2, "childList": [{"text": "itertools", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html"}, {"text": "itertools", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n a = fib_gen()\n a = itertools.islice(a, int(sys.argv[1]))\n a = itertools.ifilter(even, a)\n print list(a)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could use a generator to store the intermediate result, and \"filter\" on it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fibs = (a.next() for i in whatever)\neven_fibs = [num for num in fibs if num % 2 == 0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["or in one line:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n even_fibs = [num for num in (a.next() for i in whatever) if num % 2 == 0]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that, if you want to take a definite number of elements from an iterator, you could use itertools.islice instead:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "itertools.islice", "tag": "a", "pos": 0, "childList": [{"text": "itertools.islice", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.islice"}, {"text": "itertools.islice", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import islice\nfibs_max_count = int(sys.argv[1])\neven_fibs = [num for num in islice(fib_gen(), fibs_max_count) if num%2 == 0]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["filter and map converts quite easily into a list comprehension. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "filter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Here's a basic example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n [hex(n) for n in range(0, 100) if n &gt; 20]\n</code>\n</pre>\n", "senID": 2}, {"text": ["This is equivalent to:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n list(map(hex, filter(lambda x: x &gt; 20, range(0, 100))))\n</code>\n</pre>\n", "senID": 4}, {"text": ["The comprehension is in my opinion more readable.", "However if the conditions become very advanced, I prefer filter."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "filter", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["So in your case:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n [n for n in itertools.islice(fib_gen(), 100) if even(n)]\n</code>\n</pre>\n", "senID": 7}, {"text": ["I have used islice here because the sequence is infinite.", "But if you use a generator expression it becomes an infinite stream as well:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "islice", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n gen = (n for n in fib_gen() if even(n))\n</code>\n</pre>\n", "senID": 9}, {"text": ["Now you can slice the sequence as well with islice:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "islice", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n print itertools.islice(gen, int(sys.argv[1]))\n</code>\n</pre>\n", "senID": 11}, {"text": ["This avoids the need to use next in the comprehensions themselves.", "As long as you don't try to evaluate the infinite sequence (as we would if we omitted islice in the list comprehension), we can work with your sequence."], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "next", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "islice", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I don't thing this is going to work with a generator.", "In order to have this work with list comprehension, you would need to have:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n print [a.next() for i in range(int(sys.argv[1])) if even(a.next())]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This returns:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [1, 3, 13, 55, 233]\n</code>\n</pre>\n", "senID": 3}, {"text": ["The problem is you need to access twice the next number in the list but the second a.next() call makes what it supposed to do, ie get the next number.", "To my knowledge, it is not possible to store the value of a.next() with list comprehension to use twice."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You could use the following code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = fib_gen()\nprint [a.next() for i in range(int(sys.argv[1])) if i%3==0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is a particular case that works because every third fibbonacci number is even. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can always generate the even fibo numbers only too..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def evenfib():\n    \"\"\" Generates the even fibonacci numbers \"\"\"\n    a, b = 2, 0\n    while True:\n        a, b = b, a+4*b\n        yield a\n</code>\n</pre>\n", "senID": 1}]]