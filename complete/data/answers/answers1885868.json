[[{"code": "<pre>\n<code>\n import itertools\n\nheader_lines = list(itertools.islice(file_handle, header_len))\n# or\nheader = \"\".join(itertools.islice(file_handle, header_len))\n</code>\n</pre>\n", "senID": 0}, {"text": ["Note that with the first, the newline chars will still be present, to strip them:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n header_lines = list(n.rstrip(\"\\n\")\n                    for n in itertools.islice(file_handle, header_len))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I'm not sure what the Pylint rules are, but you could use the '_' throwaway variable name."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n header = ''\nheader_len = 4\nfor _ in range(1, header_len):\n    header += file_handle.readline()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["My best answer is as follows:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["file test.dat:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n This is line 1\nThis is line 2\nThis is line 3\nThis is line 4\nThis is line 5\nThis is line 6\nThis is line 7\nThis is line 8\nThis is line 9\n</code>\n</pre>\n", "senID": 2}, {"text": ["Python script:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n f = open('test.dat')\nnlines = 4\nheader = \"\".join(f.readline() for _ in range(nlines))\n</code>\n</pre>\n", "senID": 4}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; header\n'This is line 1\\nThis is line 2\\nThis is line 3\\nThis is line 4\\n'\n</code>\n</pre>\n", "senID": 6}, {"text": ["Notice that you don't need to call any modules; also that you could use any dummy variable in place of _ (it works with i, or j, or ni, or whatever) but I recomend you don't (to avoid confusion).", "You could strip the newline characters (though I don't recommend you do - this way you can distinguish among lines) or do anything that you can do with strings in Python."], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "_", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "i", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "j", "childNum": 0, "tag": "code", "childList": []}, {"text": "ni", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Notice that I did not provide a mode for opening the file, so it defaults to \"read only\" - this is not Pythonic; in Python \"explicit is better than implicit\".", "Finally, nice people close their files; in this case it is automatic (because the script ends) but it is best practice to close them using f.close()."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "f.close()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Happy Pythoning."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Edit: As pointed out by Roger Pate the square brackets are unnecessary in the list comprehension, thereby reducing the line by two characters.", "The original script has been edited to reflect this."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n f = open('fname')\nheader = [next(f) for _ in range(header_len)]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Since you're going to write header back to the new files, you don't need to do anything with it.", "To write it back to the new file:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n open('new', 'w').writelines(header + list_of_lines)\n</code>\n</pre>\n", "senID": 2}, {"text": ["if you know the number of lines in the old file, list_of_lines would become:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "list_of_lines", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n list_of_lines = [next(f) for _ in range(chunk_len)]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["May be this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n header_len = 4\nheader = open(\"file.txt\").readlines()[:header_len]\n</code>\n</pre>\n", "senID": 1}, {"text": ["But, it will be troublesome for long files."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I do not see any thing wrong with your solution, may be just replace i with _, I also do not like invoking itertools everywhere where simpler solution will work, it is like people using jQuery for trivial javascript tasks.", "anyway just to have itertools revenge here is my solution"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["as you want to read whole file anyway line by line, why not just first read header and after that do whatever you want to do"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n header = ''\nheader_len = 4\n\nfor i, line in enumerate(file_handle):\n    if i &lt; header_len:\n        header += line\n    else:\n        # output chunks to separate files\n        pass\n\nprint header\n</code>\n</pre>\n", "senID": 2}], [{"text": ["What about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n header = []\nfor i,l in enumerate(file_handle):\n    if i &lt;= 3: \n         header += l\n         continue\n    #proc rest of file here\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n s=\"\"\nf=open(\"file\")\nfor n,line in enumerate(f):\n  if n&lt;=3 : s=s+line\n  else:\n      # do something here to process the rest of the lines          \nprint s\nf.close()\n</code>\n</pre>\n", "senID": 0}]]