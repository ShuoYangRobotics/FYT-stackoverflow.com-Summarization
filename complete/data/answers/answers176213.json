[[{"text": ["I found these two books very useful when I used to build full-text search engines."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Information Retrieval"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Information Retrieval", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://rads.stackoverflow.com/amzn/click/0134638379"}]}, {"text": ["Managing Gigabytes"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Managing Gigabytes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://rads.stackoverflow.com/amzn/click/1558605703"}]}], [{"text": ["Read Tim Bray's series of posts on the subject."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "series of posts on the subject", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.tbray.org/ongoing/When/200x/2003/07/30/OnSearchTOC"}]}], [{"text": ["Here's an original idea:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Don't build an index.", "Seriously."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Don't", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I was faced with a similar progblem some time ago.", "I needed a fast method to search megs and megs of text that came from documentation.", "I needed to match not just words, but word proximity in large documents (is this word near that word).", "I just ended up writing it in C, and the speed of it surprised me.", "It was fast enough that it didn't need any optimizing or indexing."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "near", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["With the speed of today's computers, if you write code that runs straight on the metal (compiled code), you often don't need an order log(n) type algorithm to get the performance you need."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["As always start in wikipedia.", "First start is usually building an inverted index."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "wikipedia", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Index_(search_engine)"}]}], [{"text": ["I would not build it yourself, if possible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["App Engine includes the basics of a Full Text searching engine, and there is a great blog post here that describes how to use it."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "great blog post here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://appengineguy.com/2008/06/how-to-full-text-search-in-google-app.html"}]}, {"text": ["There is also a feature request in the bug tracker that seems to be getting some attention lately, so you may want to hold out, if you can, until that is implemented."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "feature request in the bug tracker", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/googleappengine/issues/detail?id=217"}]}], [{"text": ["Lucene or Autonomy!", "These are not out of the box solutions for you.", "You will have to write wrappers on top of their interfaces.", "They certainly do take care of the stemming, grammar , relational operators etc"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Lucene", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Lucene"}, {"text": "Autonomy", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.searchtools.com/tools/autonomy.html"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}], [{"text": ["First build your index.", "Go through the input, split into words\nFor each word check if it is already in the index, if it is add the current record number to the index list, if not add the word and record number.", "To look up a word go to the (possibly sorted) index and return all the record numbers for that word.", "It's very esy to do this for a reasoable size list using Python's builtin storage types."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}]}, {"text": ["As an extra refinement you only want to store the base part of a word, eg 'find' for 'finding' - look up stemming algorithms.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The book Introduction to Information Retrieval provides a good introduction to the field."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Introduction to Information Retrieval", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www-csli.stanford.edu/~hinrich/information-retrieval-book.html"}]}, {"text": ["A dead-tree version is published by Cambridge University Press, but you can also find a free online edition (in HTML and PDF) following the link above."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["See also a question I asked: How-to: Ranking Search Results."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "How-to: Ranking Search Results", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/47762/how-to-ranking-search-results"}]}, {"text": ["Surely there are more approaches, but this is the one I'm using for now."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Honestly, smarter people than I have figured this stuff out.", "I'd load up the solr app and make json calls from my appengine app and let solr take care of indexing. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I just found this article this weekend: http://www.perl.com/pub/a/2003/02/19/engine.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.perl.com/pub/a/2003/02/19/engine.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.perl.com/pub/a/2003/02/19/engine.html"}]}, {"text": ["Looks not too complicated to do a simple one (though it would need heavy optimizing to be an enterprise type solution for sure).", "I plan on trying a proof of concept with some data from Project Gutenberg."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you're just looking for something you can explore and learn from I think this is a good start."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Look into the book \"Managing Gigabytes\" it covers storage and retrieval of huge amounts of plain text data -- eg.", "both compression and actual searching, and a variety of the algorithms that can be used for each."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also for plain text retrieval you're best off using a vector based search system rather than a keyword->document indexing system as vector based systems can be much faster, and, more importantly can provide relevancy ranking relatively trivially."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]