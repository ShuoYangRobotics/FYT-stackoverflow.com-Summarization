[[{"text": ["\"but the first one is slower when (for example) the first char of a is nowhere in b\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This kind of degenerate-case performance analysis is not a good idea.", "It's a rat-hole of lost time thinking up all kinds of obscure special cases.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Only do the O-style \"overall\" analysis."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "O", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Overall, the sorts are O( n log( n ) )."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "O", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "n", "childNum": 0, "tag": "em", "childList": []}, {"text": "n", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["The a.count(char) for char in a solution is O( n 2 ).", "Each count pass is a full examination of the string."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "a.count(char) for char in a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "O", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "n", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "2", "childNum": 0, "tag": "sup", "childList": []}]}, {"text": ["If some obscure special case happens to be faster -- or slower, that's possibly interesting.", "But it only matters when you know the frequency of your obscure special cases.", "When analyzing sort algorithms, it's important to note that a fair number of sorts involve data that's already in the proper order (either by luck or by a clever design), so sort performance on pre-sorted data matters."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["In your obscure special case (\"the first char of a is nowhere in b\") is this frequent enough to matter?", "If it's just a special case you thought of, set it aside.", "If it's a fact about your data, then consider it."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Here is a way which is O(n), asymptotically better than the two ways you suggest. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import collections\n\ndef same_permutation(a, b):\n    d = collections.defaultdict(int)\n    for x in a:\n        d[x] += 1\n    for x in b:\n        d[x] -= 1\n    return not any(d.itervalues())\n\n## same_permutation([1,2,3],[2,3,1])\n#. True\n\n## same_permutation([1,2,3],[2,3,1,1])\n#. False\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think the first one is the \"obvious\" way.", "It is shorter, clearer, and likely to be faster in many cases because Python's built-in sort is highly optimized."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Your second example won't actually work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n all(a.count(char) == b.count(char) for char in a)\n</code>\n</pre>\n", "senID": 1}, {"text": ["will only work if b does not contain extra characters not in a.", "It also does duplicate work if the characters in string a repeat."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you want to know whether two strings are permutations of the same unique characters, just do:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "unique", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n set(a) == set(b)\n</code>\n</pre>\n", "senID": 4}, {"text": ["To correct your second example:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n all(str1.count(char) == str2.count(char) for char in set(a) | set(b))\n</code>\n</pre>\n", "senID": 6}, {"text": ["set() objects overload the bitwise OR operator so that it will evaluate to the union of both sets.", "This will make sure that you will loop over all the characters of both strings once for each character only."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["That said, the sorted() method is much simpler and more intuitive, and would be what I would use."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["heuristically you're probably better to split them off based on string size."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Pseudocode:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n returnvalue = false\nif len(a) == len(b)\n   if len(a) &lt; threshold\n      returnvalue = (sorted(a) == sorted(b))\n   else\n       returnvalue = naminsmethod(a, b)\nreturn returnvalue\n</code>\n</pre>\n", "senID": 2}, {"text": ["If performance is critical, and string size can be large or small then this is what I'd do."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["It's pretty common to split things like this based on input size or type.", "Algorithms have different strengths or weaknesses and it would be foolish to use one where another would be better...", "In this case Namin's method is O(n), but has a larger constant factor than the O(n log n) sorted method. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Go with the first one - it's much more straightforward and easier to understand.", "If you're actually dealing with incredibly large strings and performance is a real issue, then don't use Python, use something like C."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As far as the Zen of Python is concerned, that there should only be one obvious way to do things refers to small, simple things.", "Obviously for any sufficiently complicated task, there will always be zillions of small variations on ways to do it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Here is a sample code with three methods - 1. using set and len, 2. using sorted and 3. method defined by namin."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a='confused'\nb='unfocused'\nc='foncused'\nsort_method=lambda x,y: sorted(x)==sorted(y)\ndef same_permutation(a, b):\n    d = {}\n    for x in a:\n        d[x] = d.get(x, 0) + 1\n    for x in b:\n        d[x] = d.get(x, 0) - 1\n    for v in d.itervalues():\n        if v != 0:\n            return False\n    return True\n</code>\n</pre>\n", "senID": 1}, {"text": ["the average run times (over 100000 loops) of the 2 methods are:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["for a non match a,b"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n jv@Pioneer:~/jai/thekid$ python -m timeit -s 'import temp' 'temp.sort_method(temp.a,temp.b)'\n100000 loops, best of 3: 9.72 usec per loop\njv@Pioneer:~/jai/thekid$ python -m timeit -s 'import temp' 'temp.same_permutation(temp.a,temp.b)'\n10000 loops, best of 3: 28.1 usec per loop\n</code>\n</pre>\n", "senID": 4}, {"text": ["for a match a,c"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n jv@Pioneer:~/jai/thekid$ python -m timeit -s 'import temp' 'temp.sort_method(temp.a,temp.c)'\n100000 loops, best of 3: 9.47 usec per loop\njv@Pioneer:~/jai/thekid$ python -m timeit -s 'import temp' 'temp.same_permutation(temp.a,temp.c)'\n100000 loops, best of 3: 24.6 usec per loop\n</code>\n</pre>\n", "senID": 6}, {"text": ["here the strings are small.", "You can check out the timer for real strings you have and decide."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Edit1: before answering i thought O(n) method from namin is the one, but it seems that efficiency will matter when strings grow large.", "But anywayz you have 2 methods and timer - choose for urself according to your data."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Edit2: removed an incorrect soution"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["I did a pretty thorough comparison in Java with all words in a book I had.", "The counting method beats the sorting method in every way.", "The results:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Testing against 9227 words.\n\nPermutation testing by sorting ... done.    \t18.582 s\nPermutation testing by counting ... done.   \t14.949 s\n</code>\n</pre>\n", "senID": 1}, {"text": ["If anyone wants the algorithm and test data set, comment away."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This is a PHP function I wrote about a week ago which checks if two words are anagrams.", "How would this compare (if implemented the same in python) to the other methods suggested?", "Comments?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n public function is_anagram($word1, $word2) {\n    $letters1 = str_split($word1);\n    $letters2 = str_split($word2);\n    if (count($letters1) == count($letters2)) {\n        foreach ($letters1 as $letter) {\n            $index = array_search($letter, $letters2);\n            if ($index !== false) {\n                unset($letters2[$index]);\n            }\n            else { return false; }\n        }\n        return true;\n    }\n    return false;        \n}\n</code>\n</pre>\n", "senID": 1}, {"tag": "hr", "senID": 2}, {"text": ["Here's a literal translation to Python of the PHP version (by JFS):"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "literal", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def is_anagram(word1, word2):\n    letters2 = list(word2)\n    if len(word1) == len(word2):\n       for letter in word1:\n           try:\n               del letters2[letters2.index(letter)]\n           except ValueError:\n               return False               \n       return True\n    return False\n</code>\n</pre>\n", "senID": 4}, {"text": ["Comments: "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n1. The algorithm is O(N**2). Compare it to @namin's version (it is O(N)).\n    2. The multiple returns in the function look horrible.\n</pre>\n", "senID": 6}], [{"text": ["This version is faster than any examples presented so far except it is 20% slower than sorted(x) == sorted(y) for short strings.", "It depends on use cases but generally 20% performance gain is insufficient to justify a complication of the code by using different version for short and long strings (as in @patros's answer)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sorted(x) == sorted(y)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["It doesn't use len so it accepts any iterable therefore it works even for data that do not fit in memory e.g., given two big text files with many repeated lines it answers whether the files have the same lines (lines can be in any order)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "len", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def isanagram(iterable1, iterable2):\n    d = {}\n    get = d.get\n    for c in iterable1:\n        d[c] = get(c, 0) + 1\n    try:\n        for c in iterable2:\n            d[c] -= 1\n        return not any(d.itervalues())\n    except KeyError:\n        return False\n</code>\n</pre>\n", "senID": 2}, {"text": ["It is unclear why this version is faster then defaultdict (@namin's) one for large iterable1 (tested on 25MB thesaurus)."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "defaultdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "iterable1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If we replace get in the loop by try: ... except KeyError then it performs 2 times slower for short strings i.e.", "when there are few duplicates."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "try: ... except KeyError", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Sorry that my code is not in Python, I have never used it, but I am sure this can be easily translated into python.", "I believe this is faster than all the other examples already posted.", "It is also O(n), but stops as soon as possible:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n public boolean isPermutation(String a, String b) {\n    if (a.length() != b.length()) {\n        return false;\n    }\n\n    int[] charCount = new int[256];\n    for (int i = 0; i &lt; a.length(); ++i) {\n        ++charCount[a.charAt(i)];\n    }\n\n    for (int i = 0; i &lt; b.length(); ++i) {\n        if (--charCount[b.charAt(i)] &lt; 0) {\n            return false;\n        }\n    }\n    return true;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["First I don't use a dictionary but an array of size 256 for all the characters.", "Accessing the index should be much faster.", "Then when the second string is iterated, I immediately return false when the count gets below 0.", "When the second loop has finished, you can be sure that the strings are a permutation, because the strings have equal length and no character was used more often in b compared to a."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's martinus code in python.", "It only works for ascii strings:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_permutation(a, b):\n    if len(a) != len(b):\n        return False\n\n    char_count = [0] * 256\n    for c in a:\n        char_count[ord(c)] += 1\n\n    for c in b:\n        char_count[ord(c)] -= 1\n        if char_count[ord(c)] &lt; 0:\n            return False\n\n    return True\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In Python 3.1/2.7 you can just use collections.Counter(a) == collections.Counter(b)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "collections.Counter(a) == collections.Counter(b)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["But sorted(a) == sorted(b) is still the most obvious IMHO.", "You are talking about permutations - changing order - so sorting is the obvious operation to erase that difference."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "sorted(a) == sorted(b)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]