[[{"text": ["For this particular case, BeautifulSoup is harder to write than a regex, but it is much more robust...", "I'm just contributing with the BeautifulSoup example, given that you already know which regexp to use :-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from BeautifulSoup import BeautifulSoup\n\n#Or retrieve it from the web, etc. \nhtml_data = open('/yourwebsite/page.html','r').read()\n\n#Create the soup object from the HTML data\nsoup = BeautifulSoup(html_data)\nfooId = soup.find('input',name='fooId',type='hidden') #Find the proper tag\nvalue = fooId.attrs[2][1] #The value of the third attribute of the desired tag \n                          #or index it directly via fooId['value']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I agree with Vinko BeautifulSoup is the way to go.", "However I suggest using fooId['value'] to get the attribute rather than relying on value being the third attribute."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "BeautifulSoup", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/"}, {"text": "fooId['value']", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://www.crummy.com/software/BeautifulSoup/documentation.html#The%20attributes%20of%20Tags", "text": "get the attribute", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n from BeautifulSoup import BeautifulSoup\n#Or retrieve it from the web, etc.\nhtml_data = open('/yourwebsite/page.html','r').read()\n#Create the soup object from the HTML data\nsoup = BeautifulSoup(html_data)\nfooId = soup.find('input',name='fooId',type='hidden') #Find the proper tag\nvalue = fooId['value'] #The value attribute\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import re\nreg = re.compile('&lt;input type=\"hidden\" name=\"([^\"]*)\" value=\"&lt;id&gt;\" /&gt;')\nvalue = reg.search(inputHTML).group(1)\nprint 'Value is', value\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Parsing is one of those areas where you really don't want to roll your own if you can avoid it, as you'll be chasing down the edge-cases and bugs for years go come"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I'd recommend using BeautifulSoup.", "It has a very good reputation and looks from the docs like it's pretty easy to use."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "BeautifulSoup", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/"}]}], [{"text": ["Pyparsing is a good interim step between BeautifulSoup and regex.", "It is more robust than just regexes, since its HTML tag parsing comprehends variations in case, whitespace, attribute presence/absence/order, but simpler to do this kind of basic tag extraction than using BS."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Your example is especially simple, since everything you are looking for is in the attributes of the opening \"input\" tag.", "Here is a pyparsing example showing several variations on your input tag that would give regexes fits, and also shows how NOT to match a tag if it is within a comment:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n html = \"\"\"&lt;html&gt;&lt;body&gt;\n&lt;input type=\"hidden\" name=\"fooId\" value=\"**[id is here]**\" /&gt;\n&lt;blah&gt;\n&lt;input name=\"fooId\" type=\"hidden\" value=\"**[id is here too]**\" /&gt;\n&lt;input NAME=\"fooId\" type=\"hidden\" value=\"**[id is HERE too]**\" /&gt;\n&lt;INPUT NAME=\"fooId\" type=\"hidden\" value=\"**[and id is even here TOO]**\" /&gt;\n&lt;!--\n&lt;input type=\"hidden\" name=\"fooId\" value=\"**[don't report this id]**\" /&gt;\n--&gt;\n&lt;foo&gt;\n&lt;/body&gt;&lt;/html&gt;\"\"\"\n\nfrom pyparsing import makeHTMLTags, withAttribute, htmlComment\n\n# use makeHTMLTags to create tag expression - makeHTMLTags returns expressions for\n# opening and closing tags, we're only interested in the opening tag\ninputTag = makeHTMLTags(\"input\")[0]\n\n# only want input tags with special attributes\ninputTag.setParseAction(withAttribute(type=\"hidden\", name=\"fooId\"))\n\n# don't report tags that are commented out\ninputTag.ignore(htmlComment)\n\n# use searchString to skip through the input \nfoundTags = inputTag.searchString(html)\n\n# dump out first result to show all returned tags and attributes\nprint foundTags[0].dump()\nprint\n\n# print out the value attribute for all matched tags\nfor inpTag in foundTags:\n    print inpTag.value\n</code>\n</pre>\n", "senID": 2}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n ['input', ['type', 'hidden'], ['name', 'fooId'], ['value', '**[id is here]**'], True]\n- empty: True\n- name: fooId\n- startInput: ['input', ['type', 'hidden'], ['name', 'fooId'], ['value', '**[id is here]**'], True]\n  - empty: True\n  - name: fooId\n  - type: hidden\n  - value: **[id is here]**\n- type: hidden\n- value: **[id is here]**\n\n**[id is here]**\n**[id is here too]**\n**[id is HERE too]**\n**[and id is even here TOO]**\n</code>\n</pre>\n", "senID": 4}, {"text": ["You can see that not only does pyparsing match these unpredictable variations, it returns the data in an object that makes it easy to read out the individual tag attributes and their values."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"code": "<pre>\n<code>\n /&lt;input type=\"hidden\" name=\"fooId\" value=\"([\\d-]+)\" \\/&gt;/\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n /&lt;input\\s+type=\"hidden\"\\s+name=\"([A-Za-z0-9_]+)\"\\s+value=\"([A-Za-z0-9_\\-]*)\"\\s*/&gt;/\n\n&gt;&gt;&gt; import re\n&gt;&gt;&gt; s = '&lt;input type=\"hidden\" name=\"fooId\" value=\"12-3456789-1111111111\" /&gt;'\n&gt;&gt;&gt; re.match('&lt;input\\s+type=\"hidden\"\\s+name=\"([A-Za-z0-9_]+)\"\\s+value=\"([A-Za-z0-9_\\-]*)\"\\s*/&gt;', s).groups()\n('fooId', '12-3456789-1111111111')\n</code>\n</pre>\n", "senID": 0}]]