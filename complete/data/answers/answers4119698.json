[[{"text": ["If you can live with equality defined as identity, you can create a hashable list subtype and use these as set members for fast access/removal:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class hlist(list):\n\"Hashable list\"\n    def __hash__(self):\n        return id(self)\n    def __eq__(self, other):\n        return self is other\n    def __ne__{self, other}:\n        return self is not other\n\nin1 = hlist([1,2,3])\nin2 = hlist([4,5,6])\nouter = set([in1, in2])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You delete them by instance?", "Using a dict approach, you can always use id() as their \"arbitrary\" ID?"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "id()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["One dict for groups with their id() as key, inner dict for invidual's id().", "And another global dict with individuals with their id() as key."], "childNum": 6, "tag": "p", "senID": 1, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "id()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "id()", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "id()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It's not clear if an individual can be in multiple groups...", "If so, you would need to verify if the invidual is in any group before deleting it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Dictionary is the collection you want in this case because it has O(1) find and delete.", "There is a cost you will incur, which is generating a key for each object when you want to add/remove, but it'll be significantly faster than the O(n) approach of scanning a list.", "Generating a key for your objects is correct in this situation.", "If you have a primary key (did they come from a DB?", ") that will negate the hash function to a property lookup, and you'll achieve near perfect performance."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You seem to think that using a dictionary as a data structure in this case is a bad thing - it isn't at all.", "The purpose of a dictionary is to quickly find items in a collection.", "This is what you need, use it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If you are spending a lot of time remove-ing elements from a list, perhaps you should consider filtering it instead?", "In other words.", "make a large initial list and then subsequent generators consuming elements in the list."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "remove", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["It's perhaps not exactly what you're asking for, but collections.deque might meet some of your requirements:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "collections.deque", "tag": "a", "pos": 0, "childList": [{"text": "collections.deque", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/collections.html#collections.deque"}, {"text": "collections.deque", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Why not have something like a master list of sets and then another set that contains the indices to the list for the set you want to keep track of?", "Sure it might be  a little extra work, but you should be able to abstract it out into a class."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sets", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}]]