[[{"text": ["In Python, calling the super-class' __init__ is optional.", "If you call it, it is then also optional whether to use the super identifier, or whether to explicitly name the super class:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "super", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n object.__init__(self)\n</code>\n</pre>\n", "senID": 1}, {"text": ["In case of object, calling the super method is not strictly necessary, since the super method is empty.", "Same for __del__."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "__del__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["OTOH, for __new__, you should indeed call the super method, and use its return as the newly-created object - unless you explicitly want to return something different."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "__new__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If you need something from super's __init__ to be done in addition to what is being done in the current class's __init__, you must call it yourself, since that will not happen automatically.", "But if you don't need anything from super's __init__, no need to call it.", "Example:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__,", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__init__,", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class C(object):\n    def __init__(self):\n    \tself.b = 1\n\n\n&gt;&gt;&gt; class D(C):\n    def __init__(self):\n    \tsuper().__init__()\n    \tself.a = 1\n\n\n&gt;&gt;&gt; class E(C):\n    def __init__(self):\n    \tself.a = 1\n\n\n&gt;&gt;&gt; d = D()\n&gt;&gt;&gt; d.a\n1\n&gt;&gt;&gt; d.b  # This works because of the call to super's init\n1\n&gt;&gt;&gt; e = E()\n&gt;&gt;&gt; e.a\n1\n&gt;&gt;&gt; e.b  # This is going to fail since nothing in E initializes b...\nTraceback (most recent call last):\n  File \"&lt;pyshell#70&gt;\", line 1, in &lt;module&gt;\n    e.b  # This is going to fail since nothing in E initializes b...\nAttributeError: 'E' object has no attribute 'b'\n</code>\n</pre>\n", "senID": 1}, {"text": ["__del__ is the same way, (but be wary of relying on __del__ for finalization - consider doing it via the with statement instead)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "__del__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__del__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I rarely use __new__.", "I do all the initialization in __init__."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "__new__.", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__.", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Edit: (after the code change)\nThere is no way for us to tell you whether you need or not to call your parent's __init__ (or any other function).", "Inheritance obviously would work without such call.", "It all depends on the logic of your code: for example, if all your __init__ is done in parent class, you can just skip child-class __init__ altogether."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["consider the following example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class A:\n    def __init__(self, val):\n    \tself.a = val\n\n\n&gt;&gt;&gt; class B(A):\n    pass\n\n&gt;&gt;&gt; class C(A):\n    def __init__(self, val):\n    \tA.__init__(self, val)\n    \tself.a += val\n\n\n&gt;&gt;&gt; A(4).a\n4\n&gt;&gt;&gt; B(5).a\n5\n&gt;&gt;&gt; C(6).a\n12\n</code>\n</pre>\n", "senID": 2}], [{"text": ["There's no hard and fast rule.", "The documentation for a class should indicate whether subclasses should call the superclass method.", "Sometimes you want to completely replace superclass behaviour, and at other times augment it - i.e.", "call your own code before and/or after a superclass call."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Update: The same basic logic applies to any method call.", "Constructors sometimes need special consideration (as they often set up state which determines behaviour) and destructors because they parallel constructors (e.g.", "in the allocation of resources, e.g.", "database connections).", "But the same might apply, say, to the render() method of a widget."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "render()", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"text": ["Further update: What's the OPP?", "Do you mean OOP?", "No - a subclass often needs to know something about the design of the superclass.", "Not the internal implementation details - but the basic contract that the superclass has with its clients (using classes).", "This does not violate OOP principles in any way.", "That's why protected is a valid concept in OOP in general (though not, of course, in Python)."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "Further update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "something", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "protected", "childNum": 0, "tag": "code", "pos": 5, "childList": []}]}], [{"text": ["IMO, you should call it.", "If your superclass is object, you should not, but in other cases I think it is exceptional not to call it.", "As already answered by others, it is very convenient if your class doesn't even have to override __init__ itself, for example when it has no (additional) internal state to initialize."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "object", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["In Anon's answer:\n\"If you need something from super's__init__to be done in addition to what is being done in the current class's__init__, you must call it yourself, since that will not happen automatically\" "], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "\"If you need something from super's__init__to be done in addition to what is being done in the current class's__init__, you must call it yourself, since that will not happen automatically\"", "childNum": 2, "tag": "em", "childList": [{"text": "__init__", "tag": "code"}, {"text": "__init__", "tag": "code"}]}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It's incredible: he is wording exactly the contrary of the principle of inheritance."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": [". "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It is not that \"something from super's__init__(...)  will not happen automatically\" , it is that it WOULD happen automatically, but it doesn't happen because the base-class' __init__ is overriden by the definition of the derived-clas __init__ "], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "\"something from super's__init__(...)  will not happen automatically\"", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "__init__", "tag": "code"}]}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So then, WHY defining a derived_class' __init__ , since it overrides what is aimed at when someone resorts to inheritance ?", "?    "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["It's because one needs to define something that is NOT done in the base-class' __init__ , and the only possibility to obtain that is to put its execution in a derived-class' __init__ function.", "In other words, one needs something in base-class'__init__in addition to what would be automatically done in the base-classe' __init__ if this latter wasn't overriden.", "NOT the contrary.   "], "childNum": 7, "tag": "p", "senID": 5, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}, {"text": "one needs something in base-class'__init__in addition", "childNum": 1, "tag": "strong", "childList": [{"text": "__init__", "tag": "code"}]}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Then, the problem is that the desired instructions present in the base-class' __init__ are no more activated at the moment of instanciation.", "In order to offset this inactivation, something special is required: calling explicitly the base-class' __init__ , in order to KEEP , NOT TO ADD, the initialization performed by the base-class' __init__ .", "That's exactly what is said in the official doc:"], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "KEEP", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["That's all the story:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["when the aim is to KEEP the initialization performed by the base-class, that is pure inheritance, nothing special is needed, one must just avoid to define an __init__ function in the derived class"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["when the aim is to REPLACE the initialization performed by the base-class, __init__ must be defined in the derived-class"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["when the aim is to ADD processes to the initialization performed by the base-class, a derived-class' __init__  must be defined , comprising an explicit call to the base-class __init__ "], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["What I feel astonishing in the post of Anon is not only that he expresses the contrary of the inheritance theory, but that there have been 5 guys passing by that upvoted without turning a hair, and moreover there have been nobody to react in 2 years in a thread whose interesting subject must be read relatively often."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}]]