[[{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import collections\nmerged = collections.defaultdict(list)\nfor k in d1:\n   merged[k].append( d1[k] )\nfor k in d2:\n   merged[k].append( d2[k] )\n</code>\n</pre>\n", "senID": 1}, {"text": ["This may be what you're looking for."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Or possibly this."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import collections\nmerged = collections.defaultdict(set)\nfor k in d1:\n   merged[k].add( d1[k] )\nfor k in d2:\n   merged[k].add( d2[k] )\n</code>\n</pre>\n", "senID": 4}], [{"text": ["One good place to start is by getting iPython (easy_install ipython) then poking around with tab completion, ?", "and dir:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "easy_install ipython", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "?", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "dir", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n In [2]: dir {}\n------&gt; dir({})\n\nOut[2]: \n['__class__',\n ...\n 'keys',\n 'pop',\n 'popitem',\n 'setdefault',\n 'update',\n 'values']\n\nIn [3]: {}.update?\nType:   \tdict\nBase Class: &lt;type 'dict'&gt;\nString Form:    {}\nNamespace:  Interactive\nLength: \t0\nDocstring:\n    dict() -&gt; new empty dictionary.\n    dict(mapping) -&gt; new dictionary initialized from a mapping object's\n        (key, value) pairs.\n    dict(seq) -&gt; new dictionary initialized as if via:\n        d = {}\n        for k, v in seq:\n            d[k] = v\n    dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs\n        in the keyword argument list.  For example:  dict(one=1, two=2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(just for example)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Anyway, your problem with checking keys common between the two dictionaries: there are a few things to consider (maybe look at the set class?", "), but here's how I'd do it:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n common_keys = [k for k in dict1 if k in dict2]\n</code>\n</pre>\n", "senID": 4}, {"text": ["(ie, \"each key k in dict1 if that key is also in dict2\")\n(note, too, that testing for dictionary membership is an O(1) operation, so this will run in O(|dict1|))"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "k", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["edit: alright, so this doesn't solve the problem of merging the two dicts into one with lists...", "But Lott's answer is good for that, or you could use the setdefault method:"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "setdefault", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n new = {}\nfor (k, v) in dict1.items():\n    new.setdefault(k, []).append(v)\nfor (k, v) in dict2.items():\n    new.setdefault(k, []).append(v)\n</code>\n</pre>\n", "senID": 7}], [{"text": ["I believe here is what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d1={'key1':1, 'key2':2}\n&gt;&gt;&gt; d2={'key1':1, 'key2':'A', 'key4':4}\n&gt;&gt;&gt; d = {}\n&gt;&gt;&gt; d.update(d1)\n&gt;&gt;&gt; for i in d2:\n        if i in d and d2[i] != d[i]:\n            d[i] = [d[i], d2[i]]\n        else:\n            d[i] = d2[i]        \t\n&gt;&gt;&gt; d\n{'key2': [2, 'A'], 'key1': 1, 'key4': 4}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here are some good links:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.diveintopython.org/getting_to_know_python/dictionaries.html\nhttp://docs.python.org/tutorial/datastructures.html#dictionaries"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "http://www.diveintopython.org/getting_to_know_python/dictionaries.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.diveintopython.org/getting_to_know_python/dictionaries.html"}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"href": "http://docs.python.org/tutorial/datastructures.html#dictionaries", "text": "http://docs.python.org/tutorial/datastructures.html#dictionaries", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Python dictionaries also work much like associative arrays in PHP, if you have any experience in that language."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The Built-in Types page in the Python docs also has a good section on dictionaries, and the section also has a list of functions available for them:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://docs.python.org/library/stdtypes.html#mapping-types-dict"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://docs.python.org/library/stdtypes.html#mapping-types-dict", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#mapping-types-dict"}]}], [{"text": ["well, for your first case, you might want a helper that combines two objects into a list of two objects, and two lists into one list containing items from the two lists, "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is assuming of course, that you always merge keys into lists, but you don't want your keys to end up being \"lists of lists\""], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def listify( obj ): \n   if type(obj) != type([]): return [obj]\n   else: return obj\n\ndef merge( v1, v2 ):\n    return listify(v1) + listify(v2)\n\n#so now you can merge two dictionaries:\ndict1 = dict(a = 2, b = 5, c = 7 )\ndict2 = dict(b = 4, d = 9, f = 10 )\ndikt = {}\n\nfor k in set( dict1.keys() + dict2.keys() ):\n    dikt[k] = merge( dict1.get(k, []), dict2.get(k, []) )\n#resutls in:\n# {'a': [2], 'c': [7], 'b': [5, 4], 'd': [9], 'f': [10]}\n</code>\n</pre>\n", "senID": 2}, {"text": ["You may notice, dict.keys() returns a list of keys, \nset returns a list without duplicate items, so set( d1.keys(), d2.keys() ) returns union of the keys of d1 and d2"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "dict.keys()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}, {"text": "set( d1.keys(), d2.keys() )", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["A variation on @SilentGhost's answer (all other answers produce wrong dictionaries):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@SilentGhost's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/631463/dictionaries-in-python/631549#631549"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d1 = dict(key1=1, key2=2)\n&gt;&gt;&gt; d2 = dict(key1=1, key2='A', key4=4)\n&gt;&gt;&gt; d = dict(d1)\n&gt;&gt;&gt; for k, v2 in d2.iteritems():\n...     v = d.get(k, None)\n...     d[k] = [v, v2] if v is not None and v != v2 else v2\n...\n&gt;&gt;&gt; d\n{'key2': [2, 'A'], 'key1': 1, 'key4': 4}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Maybe this is a bit awkward to do because the data structure you are trying to create is not as natural as it could be.", "For example instead of having some values be lone values, and some be lists, why not keep everything in lists?", "E.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n {'key1': [1], 'key2': [2, 'A'], 'key4': [4]}\n</code>\n</pre>\n", "senID": 1}, {"text": ["It is possible in Python to have a collection of mixed data types but your code will often be cleaner if you keep it coherent.", "If you use this sort of data structure, inserting is as easy as"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # Inserting a (key, value) pair\nif key in my_dict:\n    my_dict[key].append(value)\nelse:\n    my_dict[key] = [value]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here is another variation.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d1 = {'key1'=1, 'key2'=2}\nd2 = {'key1'=1, 'key2'='A', 'key4'=4)\nd = d2\nfor k, v in d.iteritems():\n... if k in d1.keys() and v!=d1[k]:\n... d[k] = [d1[k], v2]\nd\n{'key2': [2, 'A'], 'key1': 1, 'key4': 4}\n</code>\n</pre>\n", "senID": 1}]]