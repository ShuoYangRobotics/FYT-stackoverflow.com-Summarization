[[{"text": ["Here are a few possible problems:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "You may find it difficult to provide the user with helpful error messages in case of a problem.  This seems likely, as any compilation-time syntax error could be just a syntax extension.", "tag": "none", "senID": 1}, {"text": "Performance hit.", "tag": "none", "senID": 2}]}, {"text": ["I was trying to find some discussion of the pluses, minuses, and/or implementation of dynamic parsing in Perl 6, but I couldn't find anything appropriate.", "However, you may find this quote from Nicklaus Wirth (designer of Pascal and other languages) interesting:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Edit: Here's Perl 6's Synopsis 6: Subroutines, unfortunately in markup form because I couldn't find an updated, formatted version; search within for \"macro\".", "Unfortunately, it's not too interesting, but you may find some things relevant, like Perl 6's one-pass parsing rule, or its syntax for abstract syntax trees.", "The approach Perl 6 takes is that a macro is a function that executes immediately after its arguments are parsed and returns either an AST or a string; Perl 6 continues parsing as if the source actually contained the return value.", "There is mention of generation of error messages, but they make it seem like if macros return ASTs, you can do alright."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "Edit", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "Synopsis 6: Subroutines", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://svn.pugscode.org/pugs/docs/Perl6/Spec/S06-routines.pod"}, {"text": "too", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["Pushing this one step further, you could do \"lazy\" parsing and always only parse enough to evaluate the next statement.", "Like some kind of just-in-time parser.", "Then syntax errors could become normal runtime errors that just raise a normal Exception that could be handled by surrounding code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fun():\n   not implemented yet\n\ntry:\n  fun()\nexcept:\n  pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["That would be an interesting effect, but if it's useful or desirable is a different question.", "Generally it's good to know about errors even if you don't call the code at the moment."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Macros would not be evaluated until control reaches them and naturally the parser would already know all previous definitions.", "Also the macro definition could maybe even use variables and data that the program has calculated so far (like adding some syntax for all elements in a previously calculated list).", "But this is probably a bad idea to start writing self-modifying programs for things that could usually be done as well directly in the language.", "This could get confusing..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["In any case you should make sure to parse code only once, and if it is executed a second time use the already parsed expression, so that it doesn't lead to performance problems."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Another thing I've considered is making this the default behavior across the board, but allow languages (meaning a set of macros to parse a given language) to throw a parse error at compile-time.", "Python 2.5 in my system, for example, would do this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Instead of the stub idea, simply recompile functions that couldn't be handled completely at compile-time when they're executed.", "This will also make self-modifying code easier, as you can modify the code and recompile it at runtime."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Here are some ideas from my master's thesis, which may or may not be helpful.", "The thesis was about robust parsing of natural language.", "The main idea: given a context-free grammar for a language, try to parse a given \ntext (or, in your case, a python program).", "If parsing failed, you will have a partially generated parse tree.", "Use the tree structure to suggest new grammar rules that will better cover the parsed text.", "I could send you my thesis, but unless you read Hebrew this will probably not be useful."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In a nutshell:\nI used a bottom-up chart parser.", "This type of parser generates edges for productions from the grammar.", "Each edge is marked with the part of the tree that was consumed.", "Each edge gets a score according to how close it was to full coverage, for example: "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "bottom-up", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Bottom-up_parser"}, {"text": "chart parser", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Chart_parser"}]}, {"code": "<pre>\n<code>\n S -&gt; NP . VP\n</code>\n</pre>\n", "senID": 2}, {"text": ["Has a score of one half (We succeeded in covering the NP but not the VP).", "The highest-scored edges suggest a new rule (such as X->NP).", "In general, a chart parser is less efficient than a common LALR or LL parser (the types usually used for programming languages) - O(n^3) instead of O(n) complexity, but then again you are trying something more complicated than just parsing an existing language.", "If you can do something with the idea, I can send you further details.", "I believe looking at natural language parsers may give you some other ideas."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You'll probably need to delimit the bits of input text with unknown syntax, so that the rest of the syntax tree can be resolved, apart from some character sequences nodes which will be expanded later.", "Depending on your top level syntax, that may be fine. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You may find that the parsing algorithm and the lexer and the interface between them all need updating, which might rule out most compiler creation tools."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(The more usual approach is to use string constants for this purpose, which can be parsed to a little interpreter at run time)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I don't think your approach would work very well.", "Let's take a simple example written in pseudo-code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n define some syntax M1 with definition D1\nif _whatever_:\n    define M1 to do D2\nelse:\n    define M1 to do D3\ncode that uses M1\n</code>\n</pre>\n", "senID": 1}, {"text": ["So there is one example where, if you allow syntax redefinition at runtime, you have a problem (since by your approach the code that uses M1 would be compiled by definition D1).", "Note that verifying if syntax redefinition occurs is undecidable.", "An over-approximation could be computed by some kind of typing system or some other kind of static analysis, but Python is not well known for this :D."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Another thing that bothers me is that your solution does not 'feel' right.", "I find it evil to store source code you can't parse just because you may be able to parse it at runtime."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Another example that jumps to mind is this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n ...function definition fun1 that calls fun2...\ndefine M1 (at runtime)\nuse M1\n...function definition for fun2\n</code>\n</pre>\n", "senID": 5}, {"text": ["Technically, when you use M1, you cannot parse it, so you need to keep the rest of the program (including the function definition of fun2) in source code.", "When you run the entire program, you'll see a call to fun2 that you cannot call, even if it's defined."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]