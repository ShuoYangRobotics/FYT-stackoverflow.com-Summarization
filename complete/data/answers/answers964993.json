[[{"text": ["If it's XML, use ElementTree to parse it:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ElementTree", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/xml.etree.elementtree.html"}]}, {"code": "<pre>\n<code>\n from xml.etree import ElementTree\n\nline = '&lt;word id=\"8\" form=\"hibernis\" lemma=\"hibernus1\" postag=\"n-p---nb-\" head=\"7\" relation=\"ADV\"/&gt;'\n\nelement = ElementTree.fromstring(line)\n</code>\n</pre>\n", "senID": 1}, {"text": ["For each XML element you can easily extract the name and all the attributes:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; element.tag\n'word'\n&gt;&gt;&gt; element.attrib\n{'head': '7', 'form': 'hibernis', 'postag': 'n-p---nb-', 'lemma': 'hibernus1', 'relation': 'ADV', 'id': '8'}\n</code>\n</pre>\n", "senID": 3}, {"text": ["So if you have a document with a bunch of word XML elements, something like this will extract the information you want from each one:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "word", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from xml.etree import ElementTree\n\nXML = '''\n&lt;words&gt;\n    &lt;word id=\"8\" form=\"hibernis\" lemma=\"hibernus1\" postag=\"n-p---nb-\" head=\"7\" relation=\"ADV\"/&gt;\n&lt;/words&gt;'''\n\nroot = ElementTree.fromstring(XML)\n\nfor element in root.findall('word'):\n    form = element.attrib['form']\n    lemma = element.attrib['lemma']\n    postag = element.attrib['postag']\n\n    print form, lemma, postag\n</code>\n</pre>\n", "senID": 5}, {"text": ["Use parse() instead of fromstring() if you only have a filename."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "parse()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fromstring()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I'd suggest using the regular expression module: re"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html"}]}, {"text": ["Something along these lines perhaps?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\nimport re\n\nif __name__ == '__main__':\n    data = open('x').read()\n    RE = re.compile('.*form=\"(.*)\" lemma=\"(.*)\" postag=\"(.*?)\"', re.M)\n    matches = RE.findall(data)\n    for m in matches:\n        print m\n</code>\n</pre>\n", "senID": 2}, {"text": ["This does assume that the &lt;word ...&gt; lines are each on a single line and that each part is in that exact order, and that you don't need to deal with full xml parsing."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "&lt;word ...&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Is your file proper XML?", "If so, try a SAX parser:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import xml.sax\nclass Handler (xml.sax.ContentHandler):\n   def startElement (self, tag, attrs):\n       if tag == 'word':\n           print 'form=', attrs['form']\n           print 'lemma=',attrs['lemma']\n           print 'postag=',attrs['postag']\n\nch = Handler ()\nf = open ('myfile')\nxml.sax.parse (f, ch)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(this is rough .. it may not be entirely correct)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["In addition to the usual RegEx answer, since this appears to be a form of XML, you might try something like BeautifulSoup ( http://www.crummy.com/software/BeautifulSoup/ )"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.crummy.com/software/BeautifulSoup/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/"}]}, {"text": ["It's very easy to use, and find tags/attributes in things like HTML/XML, even if they're not \"well formed\".", "Might be worth a look. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Parsing xml by hand is usually the\n   wrong thing.", "For one thing, your code\n   will break if there's an escaped\n   quote in any of the attributes.", "Getting the attributes from an xml\n   parser is probably cleaner and less\n   error-prone."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["An approach like this can also run into problems parsing the entire file if you have lines that don't match the format.", "You can deal with this either by creating a parseline method (something like"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def parse (line):\n      try: \n          return parsed values here\n        except:\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can also simplify this with filter and map functions:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n lines = filter( lambda line: parseable(line), f.readlines())\nvalues = map (parse, lines)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Just to highlight your problem:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n finished = False\ncounter = 0\nwhile not finished:\n   counter += 1\n   finished=True\nprint counter\n</code>\n</pre>\n", "senID": 1}], [{"text": ["With regular expressions, this is the gist (you can do the file.readline() part):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nline = '&lt;word id=\"8\" form=\"hibernis\" lemma=\"hibernus1\" postag=\"n-p---nb-\" head-\"7\" relation=\"ADV\"/&gt;'\nr = re.compile( 'form=\"([^\"]*)\".*lemma=\"([^\"]*)\".*postag=\"([^\"]*)\"' )\nmatch = r.search( line )\nprint match.groups()\n\n&gt;&gt;&gt; \n('hibernis', 'hibernus1', 'n-p---nb-')\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["First, don't spend a lot of time rewriting your file.", "It's generally a waste of time.", "The processing to clean up and parse the tags is so fast, that you'll be perfectly happy working from the source file all the time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n source= open( \"blank.txt\", \"r\" )\nfor line in source:\n    # line has a tag-line structure\n    # &lt;word id=\"8\" form=\"hibernis\" lemma=\"hibernus1\" postag=\"n-p---nb-\" head-\"7\" relation=\"ADV\"/&gt;\n    # Assumption -- no spaces in the quoted strings.\n    parts = line.split()\n    # parts is [ '&lt;word', 'id=\"8\"', 'form=\"hibernis\"', ... ]\n    assert parts[0] == \"&lt;word\"\n    nameValueList = [ part.partition('=') for part in parts[1:] ]\n    # nameValueList is [ ('id','=','\"8\"'), ('form','=','\"hibernis\"'), ... ]\n    attrs = dict( (n,eval(v)) for n, _, v in nameValueList )\n    # attrs is { 'id':'8', 'form':'hibernis', ... }\n    print attrs['form'], attrs['lemma'], attrs['posttag']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["wow, you guys are fast :)\nIf you want all attributes of a list (and the ordering is known), then you can use something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nprint re.findall('\"(.+?)\"',INPUT)\n</code>\n</pre>\n", "senID": 1}, {"text": ["INPUT is a line like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &lt;word id=\"8\" form=\"hibernis\" lemma=\"hibernus1\" postag=\"n-p---nb-\" head=\"7\" relation=\"ADV\"/&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["and the printed list is:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n ['8', 'hibernis', 'hibernus1', 'n-p---nb-', '7', 'ADV']\n</code>\n</pre>\n", "senID": 5}]]