[[{"text": ["I would have written a generator myself, but like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def joinit(iterable, delimiter):\n    it = iter(iterable)\n    yield next(it)\n    for x in it:\n        yield delimiter\n        yield x\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would go with a simple generator."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def intersperse(val, sequence):\n    first = True\n    for item in sequence:\n        if not first:\n            yield val\n        yield item\n        first = False\n</code>\n</pre>\n", "senID": 1}, {"text": ["and then you can get your list like so:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(intersperse(666, [\"once\", \"upon\", \"a\", 90, None, \"time\"]))\n['once', 666, 'upon', 666, 'a', 666, 90, 666, None, 666, 'time']\n</code>\n</pre>\n", "senID": 3}, {"text": ["alternatively you could do:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def intersperse(val, sequence):\n    for i, item in enumerate(sequence):\n        if i != 0:\n            yield val\n        yield item\n</code>\n</pre>\n", "senID": 5}, {"text": ["I'm not sure which is more pythonic"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["itertools to the rescue\n- or -\nHow many itertools functions can you use in one line?"], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "tag": "a", "pos": 0, "childList": [{"text": "itertools", "tag": "strong"}, {"text": "itertools", "tag": "code"}], "childNum": 2, "href": "http://docs.python.org/library/itertools.html"}, {"text": "itertools", "childNum": 1, "tag": "strong", "childList": [{"text": "itertools", "tag": "code"}]}, {"text": "itertools", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "How many itertools functions can you use in one line?", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import chain, izip, repeat, islice\n\ndef intersperse(delimiter, seq):\n    return islice(chain.from_iterable(izip(repeat(delimiter), seq)), 1, None)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(intersperse(666, [\"once\", \"upon\", \"a\", 90, None, \"time\"])\n[\"once\", 666, \"upon\", 666, \"a\", 666, 90, 666, None, 666, \"time\"]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["How about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import chain,izip_longest\n\ndef intersperse(x,y):\n     return list(chain(*izip_longest(x,[],fillvalue=y)))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Dunno if it's pythonic, but it's pretty simple:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def intersperse(elem, list):\n    result = []\n    for e in list:\n      result.extend([e, elem])\n    return result[:-1]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's one way of doing it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def intersperse(x, l):\n  return sum([[i, x] for i in l], [])[:-1]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This works: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def intersperse(e, l):\n...    return reduce(lambda x,y: x+y, zip(l, [e]*len(l)))\n&gt;&gt;&gt; intersperse(666, [\"once\", \"upon\", \"a\", 90, None, \"time\"])\n('once', 666, 'upon', 666, 'a', 666, 90, 666, None, 666, 'time', 666)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you don't want a trailing 666, then return reduce(...)[:-1]. "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "666", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return reduce(...)[:-1]", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Another option that works for sequences:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def intersperse(seq, value):\n    res = [value] * (2 * len(seq) - 1)\n    res[::2] = a\n    return res\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def intersperse(word,your_list):\n    x = [j for i in your_list for j in [i,word]]\n\n&gt;&gt;&gt; intersperse(666, [\"once\", \"upon\", \"a\", 90, None, \"time\"])\n['once', 666, 'upon', 666, 'a', 666, 90, 666, None, 666, 'time', 666]\n</code>\n</pre>\n", "senID": 0}, {"text": ["[Edit] Corrected code below:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "[Edit]", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def intersperse(word,your_list):\n    x = [j for i in your_list for j in [i,word]]\n    x.pop()\n    return x\n\n&gt;&gt;&gt; intersperse(666, [\"once\", \"upon\", \"a\", 90, None, \"time\"])\n['once', 666, 'upon', 666, 'a', 666, 90, 666, None, 666, 'time']\n</code>\n</pre>\n", "senID": 2}]]