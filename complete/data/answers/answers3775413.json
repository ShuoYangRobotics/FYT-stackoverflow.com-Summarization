[[{"text": ["For an even more flexible solution than Python's generators, I have written the module List::Gen on CPAN which provides random access lazy generator arrays:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "List::Gen", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/perldoc?List%3a%3aGen"}]}, {"code": "<pre>\n<code>\n use List::Gen;\n\nmy $fib; $fib = cache gen {$_ &lt; 2  ? $_ : $$fib[$_ - 1] + $$fib[$_ - 2]};\n\nsay \"@$fib[0 .. 15]\";  #  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610\n</code>\n</pre>\n", "senID": 1}, {"text": ["Since generators pretend to be arrays, they can mix seamlessly with normal perl code.", "There is also an object oriented approach:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n my $fib; $fib = cache gen {$_ &lt; 2 ? $_ : $fib-&gt;get($_ - 1) + $fib-&gt;get($_ - 2)};\n\nsay join ' ' =&gt; $fib-&gt;slice(0 .. 15);\n</code>\n</pre>\n", "senID": 3}, {"text": ["In each case, the generator is lazy, calculating nothing upon creation, and then calculating only those values required to satisfy the slices.", "The recursive definition of the Fibonacci sequence calls itself many times, so the cache function is used to make sure each value is only calculated once. "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "cache", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You can also use generators as iterators:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n while (my $num = $fib-&gt;next) {\n    last if $num &gt; 10**15;\n    print \"$_\\n\";\n}\n</code>\n</pre>\n", "senID": 6}, {"text": ["$fib-&gt;next can also be written $fib-&gt;().", "Since the generator is still random access, you can $fib-&gt;reset() or $fib-&gt;index = 10;"], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "$fib-&gt;next", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "$fib-&gt;()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "$fib-&gt;reset()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "$fib-&gt;index = 10;", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Let me know if you have any questions."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Update:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["I have released a new version of the module (0.80) that makes it easier to use iterative algorithms in generators.", "Here is an example that closely mirrors the OP's example:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n use List::Gen '*';\n\nsub fibonacci {\n    my $limit   = 10**shift;\n    my ($x, $y) = (0, 1);\n\n    While {$_ &lt; $limit} gather {\n        ($x, $y) = ($y, take($x) + $y)\n    }\n}\n\nsay for @{fibonacci 15};\n</code>\n</pre>\n", "senID": 11}, {"text": ["if you use bigint; before or at the top of the sub, you can of course:"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "use bigint;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n say for @{fibonacci 400}; # or more\n</code>\n</pre>\n", "senID": 13}], [{"text": ["The concept of an iterator is a little different in Perl.", "You basically want to return a one-use subroutine \"closed\" over the persistent variables."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n use bigint;\nuse strict;\nuse warnings;\n\nsub fibonacci {\n    my $limit = 10**( shift || 0 );\n    my ( $a, $b ) = ( 0, 1 );\n    return sub { \n        return if $a &gt; $limit;\n        ( my $r, $a, $b ) = ( $a, $b, $a + $b );\n        return $r;\n    };\n}\nmy $fit = fibonacci( 15 );\nmy $n = 0;\nwhile ( defined( my $f = $fit-&gt;())) { \n     print \"F($n): $f\\n\";\n     $n++;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["And if you don't like the while loop, then here is two shots at some syntactic sugar, which basically accomplish a each item loop."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "while", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n sub iterate ($$) {\n    my $iter   = shift;\n    my $action = shift;\n    while ( defined( my $nextval = $iter-&gt;())) { \n        local *_ = \\$nextval;\n        $action-&gt;( $_ );\n    }\n    return;\n}\n\niterate fibonacci( 15 ) =&gt; sub { print \"$_\\n\"; };\n\nsub iter (&amp;$) { \n    my $action = shift;\n    my $iter   = shift;\n    while ( defined( my $nextval = $iter-&gt;())) { \n        local *_ = \\$nextval;\n        $action-&gt;( $_ );\n    }\n    return;\n}\n\niter { print \"$_\\n\" } fibonacci( 15 );\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The excellent Higher-Order Perl book (available for free at the specified link) contains a lot of information on related topics, and in particular has a whole chapter on iterators.", "By \"higher order\" the author implies using Perl's abilities as a functional language with first-class functions to implement all kinds of cool stuff.", "It really is a very good book - I read most of it, and the chapters on iterators and streams are terrific.", "I highly recommend to at least skim through it if you plan to write Perl code."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Higher-Order Perl", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://hop.perl.plover.com/book/"}]}], [{"text": ["There is a similar method to produce a Iterator / Generator, but it is not a \"first class citizen\" as it is on Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In Perl, if you do not see what you want (after a MANDATORY trip to CPAN FIRST!", "), you can roll your own that is similar to a Python iterator based on Perl closures and an anonymous subroutine. "], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "MANDATORY", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "CPAN", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://search.cpan.org/search?query=iterator&mode=all"}, {"text": "FIRST", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Consider:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n use strict; use warnings;\n\nsub fibo {\n    my ($an, $bn)=(1,0);\n    my $mag=(shift || 1);\n    my $limit=10**$mag;\n    my $i=0;\n\n    return sub {\n        ($an, $bn)=($bn, $an+$bn);      \n        return undef if ($an &gt;=$limit || wantarray );\n        return $an;\n    }\n}\n\nmy $num;\nmy $iter=fibo(15);\nwhile (defined($num=$iter-&gt;()) ) { printf \"%17d\\n\", $num; }\n</code>\n</pre>\n", "senID": 3}, {"text": ["The sub fibo maintains a Perl closure that allows persistent variables to be maintained.", "You can do the same by having a module, similar to C / C++.", "Inside fibo an anonymous subroutine does the work of returning the next data item. "], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "fibo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "closure", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://perldoc.perl.org/perlfaq7.html#What%27s-a-closure%3f"}, {"text": "fibo", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["To quote from the Perl Bible \"You will be miserable until you learn the difference between scalar and list context\" -- p 69 (A highly recommended book btw...)"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Perl Bible", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://rads.stackoverflow.com/amzn/click/0596000278"}]}, {"text": ["In this case, the annon sub only returns a single value.", "The only looping mechanism that I know of in Perl that can work in scalar context is while; The others try to fill the list before proceeding I think.", "Therefor, if you called the anon sub in list context, it will dutifully return the next fibonacci number, unlike Python's for iterators, and the loop would terminate.", "That is why I put the return undef if .... wantarray because it does not work in list context as written. "], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "while", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "return undef if .... wantarray", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["There are ways to fix that.", "Indeed, you can write subroutines that act like map foreach etc but it is not as straightforward as Python's yield.", "You will need an additional function to use inside a foreach loop.", "The tradeoff is the Perl approach has tremendous power and flexibility.  "], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "foreach", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["You can read more about Perl iterators in Mark Jason Dominus' excellent book \"Higher Order Perl\" Chapter 4 is all about Interators brian d foy also has an excellent article on Interators in the Perl Review."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "Chapter 4 is all about Interators", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://hop.perl.plover.com/book/pdf/04Iterators.pdf"}, {"href": "http://www.theperlreview.com/Articles/v0i5/iterators.pdf", "text": "article", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["There's a good practical example here and a PDF article here... but I'm too rusty in Perl to try to implement your challenge directly (as you'll see, both the example and the approach in the PDF use a less direct approach)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.perl.com/pub/2005/06/16/iterators.html"}, {"href": "http://www.theperlreview.com/Articles/v0i5/iterators.pdf", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["In this case, memoization can be used."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n use strict;\nuse warnings;\n\nuse Memoize;\nmemoize('fib');\n\nforeach my $i (1..15) {\n  print \"$i -&gt; \",fib($i),\"\\n\";\n}\n\nsub fib {\n  my $n = shift;\n  return $n if $n &lt; 2;\n  fib($n-1) + fib($n-2);\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is a response tailored to conform closely to the question as originally posed."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Any perl module that implements lazy lists (e.g.", "List::Gen, Memoize, etc.", ") and also lets you supply your own generator subroutine (I don't mean 'generator' as in Python) will allow you to do as shown in this example.", "Here the module that lazily produces the list is called Alef."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/perl -w\n\nuse strict; use warnings; \nuse Alef;\n\nmy $fibo;\n\nBEGIN {\n\n    my ($a, $b) = (0, 1);\n\n    $fibo = sub {\n        ($a, $b) = ($b, $a+$b);\n        $a;\n    }\n}\n\nmy $fibonacci = new Alef($fibo);\n\nforeach my $number ($fibonacci-&gt;take(15)){ print $number . \"\\n\"; }\n</code>\n</pre>\n", "senID": 2}, {"text": ["Here is the output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["[spl@briareus ~]$ ./fibo.pl \n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["There is nothing magical happening behind the scenes with the lazy list module used here.", "This is what Alef's take subroutine looks like."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n sub take {\n\n    my ($self,$n) = (@_);\n\n    my @these = ();\n\n    my $generator = $self-&gt;{'generator'};\n    for (1..$n){\n        push(@these,$self-&gt;{'this'});\n        $self-&gt;{'this'} = &amp;$generator($self-&gt;{'this'});\n    }\n    @these;\n}\n</code>\n</pre>\n", "senID": 6}]]