[[{"text": ["See http://webcache.googleusercontent.com/search?q=cache:EAuL4vECPBEJ:docs.python.org/library/datetime.html+python+datetime&amp;hl=en&amp;client=firefox-a&amp;gl=us&amp;strip=1 since the main Python site is having problems."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://webcache.googleusercontent.com/search?q=cache:EAuL4vECPBEJ:docs.python.org/library/datetime.html+python+datetime&amp;hl=en&amp;client=firefox-a&amp;gl=us&amp;strip=1", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://webcache.googleusercontent.com/search?q=cache:EAuL4vECPBEJ:docs.python.org/library/datetime.html+python+datetime&hl=en&client=firefox-a&gl=us&strip=1"}]}, {"text": ["The function you want is datetime.strptime or time.strptime, which create either a datetime or time object from a string with a time and another string describing the format."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "datetime.strptime", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "time.strptime", "childNum": 0, "tag": "code", "childList": []}, {"text": "datetime", "childNum": 0, "tag": "code", "childList": []}, {"text": "time", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you want to not have to describe the format, use dateutil, http://labix.org/python-dateutil."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "dateutil", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://labix.org/python-dateutil", "text": "http://labix.org/python-dateutil", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n from dateutil.parser import parse\n&gt;&gt;&gt; d = parse('2009/05/13 19:19:30 -0400')\n&gt;&gt;&gt; d\ndatetime.datetime(2009, 5, 13, 19, 19, 30, tzinfo=tzoffset(None, -14400))\n</code>\n</pre>\n", "senID": 3}, {"text": ["See How to parse dates with -0400 timezone string in python?"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "How to parse dates with -0400 timezone string in python?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1101508/how-to-parse-dates-with-0400-timezone-string-in-python"}]}], [{"text": ["Other than the following, string parsing (or if you want to be even slower for something so simple, use the re module) is the only way I can think of if you rely on the standard library.", "TimeDelta doesn't seem to suit the task."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import time\n&gt;&gt;&gt; x = \"02:40\"\n&gt;&gt;&gt; t = time.strptime(x, \"%H:%M\")\n&gt;&gt;&gt; minutes = t.tm_hour * 60 + t.tm_min\n&gt;&gt;&gt; minutes\n160\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Personally, I think simply parsing the string is far easier to read:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = '02:40'\n&gt;&gt;&gt; int(s[:-3]) * 60 + int(s[-2:])\n160\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that using negative indexing means it will handle strings without the leading zero on the hour:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = '2:40'\n&gt;&gt;&gt; int(s[:-3]) * 60 + int(s[-2:])\n160\n</code>\n</pre>\n", "senID": 3}, {"text": ["You could also use the split() function:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "split()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; hours, minutes = s.split(':')\n&gt;&gt;&gt; int(hours) * 60 + int(minutes)\n160\n</code>\n</pre>\n", "senID": 5}, {"text": ["Or use the map() function to convert the pieces to integers:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "map()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; hours, minutes = map(int, s.split(':'))\n&gt;&gt;&gt; hours * 60 + minutes\n160\n</code>\n</pre>\n", "senID": 7}, {"text": ["Using the timeit module indicates it is also faster than other methods proposed here:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "timeit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import timeit\n&gt;&gt;&gt; parsetime = timeit.timeit(\"mins = int(s[:-3]) * 60 + int(s[-2:])\", \"s='02:40'\", number=100000) / 100000\n&gt;&gt;&gt; parsetime\n9.018449783325196e-06\n</code>\n</pre>\n", "senID": 9}, {"text": ["The split() method is a bit slower:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "split()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; splittime = timeit.timeit(\"hours,minutes = s.split(':'); mins=int(hours)*60 + int(minutes)\", \"s='02:40'\", number=100000)/100000\n&gt;&gt;&gt; splittime\n1.1217889785766602e-05\n&gt;&gt;&gt; splittime/parsetime\n1.2438822697120402\n</code>\n</pre>\n", "senID": 11}, {"text": ["And using map() a bit slower again:"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "map()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; splitmaptime = timeit.timeit(\"hours,minutes = map(int, s.split(':')); mins=hours*60 + minutes\", \"s='02:40'\", number=100000)/100000\n&gt;&gt;&gt; splitmaptime\n1.3971350193023682e-05\n&gt;&gt;&gt; splitmaptime/parsetime\n1.5491964282881776\n</code>\n</pre>\n", "senID": 13}, {"text": ["John Machin's map and sum is about 2.4 times slower:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; summaptime = timeit.timeit('mins=sum(map(lambda x, y: x * y, map(int, \"2:40\".split(\":\")), [60, 1]))', \"s='02:40'\", number=100000) / 100000\n&gt;&gt;&gt; summaptime\n2.1276121139526366e-05\n&gt;&gt;&gt; summaptime/parsetime\n2.43\n</code>\n</pre>\n", "senID": 15}, {"text": ["Chrono Kitsune's strptime()-based answer is ten times slower:"], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "strptime()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; strp = timeit.timeit(\"t=time.strptime(s, '%H:%M');mins=t.tm_hour * 60 + t.tm_min\", \"import time; s='02:40'\", number=100000)/100000\n&gt;&gt;&gt; strp\n9.0362770557403569e-05\n&gt;&gt;&gt; strp/parsetime\n10.019767557444432\n</code>\n</pre>\n", "senID": 17}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; sum(map(lambda x, y: x * y, map(int, \"2:40\".split(\":\")), [60, 1]))\n160\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I'm sure you can represent the given time as a TimeDelta object.", "From there I am sure there is an easy way to represent the TimeDelta in minutes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["There is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from time import strptime\nfrom calendar import timegm\n\nT = '02:40'\nt = timegm(strptime('19700101'+T,'%Y%m%d%H:%M'))\nprint t\n</code>\n</pre>\n", "senID": 1}, {"text": ["But is this really better than brute calculus ?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["An exotic solution, that doesn't need importing functions :"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n T = '02:40'\nexec('x = %s' % T.replace(':','*60+'))\nprint x\n</code>\n</pre>\n", "senID": 5}, {"text": ["edit: corrected second solution to obtain minutes, not seconds"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Simplest solution"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n T = '02:40'\n\nprint int(T[0:2])*60 + int(T[3:])\n</code>\n</pre>\n", "senID": 9}]]