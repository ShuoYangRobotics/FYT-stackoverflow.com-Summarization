[[{"text": ["What could be more pythonic than PyPy?  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Look at what I discovered starting at line 284 in ctypes_configure/configure.py:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for i in range(0, info['size'] - csize + 1, info['align']):\n        if layout[i:i+csize] == [None] * csize:\n            layout_addfield(layout, i, ctype, '_alignment')\n            break\n    else:\n        raise AssertionError(\"unenforceable alignment %d\" % (\n            info['align'],))\n</code>\n</pre>\n", "senID": 2}, {"text": ["And here, from line 425 in pypy/annotation/annrpython.py (clicky)"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "clicky", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://codespeak.net/pypy/dist/pypy/annotation/annrpython.py"}]}, {"code": "<pre>\n<code>\n if cell.is_constant():\n    return Constant(cell.const)\nelse:\n    for v in known_variables:\n        if self.bindings[v] is cell:\n            return v\n    else:\n        raise CannotSimplify\n</code>\n</pre>\n", "senID": 4}, {"text": ["In pypy/annotation/binaryop.py, starting at line 751:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def is_((pbc1, pbc2)):\n    thistype = pairtype(SomePBC, SomePBC)\n    s = super(thistype, pair(pbc1, pbc2)).is_()\n    if not s.is_constant():\n        if not pbc1.can_be_None or not pbc2.can_be_None:\n            for desc in pbc1.descriptions:\n                if desc in pbc2.descriptions:\n                    break\n            else:\n                s.const = False    # no common desc in the two sets\n    return s\n</code>\n</pre>\n", "senID": 6}, {"text": ["A non-one-liner in pypy/annotation/classdef.py, starting at line 176:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def add_source_for_attribute(self, attr, source):\n    \"\"\"Adds information about a constant source for an attribute.\n    \"\"\"\n    for cdef in self.getmro():\n        if attr in cdef.attrs:\n            # the Attribute() exists already for this class (or a parent)\n            attrdef = cdef.attrs[attr]\n            s_prev_value = attrdef.s_value\n            attrdef.add_constant_source(self, source)\n            # we should reflow from all the reader's position,\n            # but as an optimization we try to see if the attribute\n            # has really been generalized\n            if attrdef.s_value != s_prev_value:\n                attrdef.mutated(cdef) # reflow from all read positions\n            return\n    else:\n        # remember the source in self.attr_sources\n        sources = self.attr_sources.setdefault(attr, [])\n        sources.append(source)\n        # register the source in any Attribute found in subclasses,\n        # to restore invariant (III)\n        # NB. add_constant_source() may discover new subdefs but the\n        #     right thing will happen to them because self.attr_sources\n        #     was already updated\n        if not source.instance_level:\n            for subdef in self.getallsubdefs():\n                if attr in subdef.attrs:\n                    attrdef = subdef.attrs[attr]\n                    s_prev_value = attrdef.s_value\n                    attrdef.add_constant_source(self, source)\n                    if attrdef.s_value != s_prev_value:\n                        attrdef.mutated(subdef) # reflow from all read positions\n</code>\n</pre>\n", "senID": 8}, {"text": ["Later in the same file, starting at line 307, an example with an illuminating comment:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n def generalize_attr(self, attr, s_value=None):\n    # if the attribute exists in a superclass, generalize there,\n    # as imposed by invariant (I)\n    for clsdef in self.getmro():\n        if attr in clsdef.attrs:\n            clsdef._generalize_attr(attr, s_value)\n            break\n    else:\n        self._generalize_attr(attr, s_value)\n</code>\n</pre>\n", "senID": 10}], [{"text": ["If you have a for loop you don't really have any condition statement.", "So break is your choice if you like to abort and then else can serve perfectly to handle the case where you were not happy."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for fruit in basket:\n   if fruit.kind in ['Orange', 'Apple']:\n       fruit.eat()\n       break\nelse:\n   print 'The basket contains no desirable fruit'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Without using break, else blocks have no benefit for for and while statements.", "The following two examples are equivalent:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "break", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "else", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "while", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n for x in range(10):\n  pass\nelse:\n  print \"else\"\n\nfor x in range(10):\n  pass\nprint \"else\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["The only reason for using else with for or while is to do something after the loop if it terminated normally, meaning without an explicit break."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "else", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}, {"text": "while", "childNum": 0, "tag": "code", "childList": []}, {"text": "break", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["After a lot of thinking, I can finally come up with a case where this might be useful:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def commit_changes(directory):\n    for file in directory:\n        if file_is_modified(file):\n            break\n    else:\n        # No changes\n        return False\n\n    # Something has been changed\n    send_directory_to_server()\n    return True\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Basically, it simplifies any loop that uses a boolean flag like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n found = False                # &lt;-- initialize boolean\nfor divisor in range(2, n):\n    if n % divisor == 0:\n        found = True         # &lt;-- update boolean\n        break  # optional, but continuing would be a waste of time\n\nif found:                    # &lt;-- check boolean\n    print n, \"is composite\"\nelse:\n    print n, \"is prime\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["and allows you to skip the management of the flag:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for divisor in range(2, n):\n    if n % divisor == 0:\n        print n, \"is composite\"\n        break\nelse:\n    print n, \"is prime\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that there is already a natural place for code to execute when you do find a divisor - right before the break.", "The only new feature here is a place for code to execute when you  tried all divisor and did not find any."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "break", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This helps only in conjuction withbreak.", "You still need booleans if you can't break (e.g.", "because you looking for the last match, or have to track several conditions in parallel)."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "This helps only in conjuction withbreak", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "break", "tag": "code"}]}, {"text": "break", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Oh, and BTW, this works for while loops just as well."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["any/all"], "childNum": 0, "tag": "h2", "senID": 7, "childList": []}, {"text": ["Nowdays, if the only purpose of the loop is a yes-or-no answer, you might be able to write it much shorter with the any()/all() functions with a generator or generator expression that yields booleans:"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "any()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "all()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n if any(n % divisor == 0 \n       for divisor in range(2, n)):\n    print n, \"is composite\"\nelse:\n    print n, \"is prime\"\n</code>\n</pre>\n", "senID": 9}, {"text": ["Note the elegancy!", "The code is 1:1 what you want to say!"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["[This is as effecient as a loop with a break, because the any() function is short-circuiting, only running the generator expression until it yeilds True.", "In fact it's usually even faster than a loop.", "Simpler Python code tends to have less overhear."], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "break", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "any()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["This is less workable if you have other side effects - for example if you want to find the divisor.", "You can still do it (ab)using the fact that non-0 value are true in Python:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n divisor = any(d for d in range(2, n) if n % d == 0)\nif divisor:\n    print n, \"is divisible by\", divisor\nelse:\n    print n, \"is prime\"\n</code>\n</pre>\n", "senID": 13}, {"text": ["but as you see this is getting shaky - wouldn't work if 0 was a possible divisor value..."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}], [{"text": ["Perhaps the best answer comes from the official Python tutorial:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["break and continue Statements, and else Clauses on Loops:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "break and continue Statements, and else Clauses on Loops", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops"}]}], [{"text": ["Here you go:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = ('y','a','y')\nfor x in a:\n  print x,\nelse:\n  print '!'\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's for the caboose."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["edit:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # What happens if we add the ! to a list?\n\ndef side_effect(your_list):\n  your_list.extend('!')\n  for x in your_list:\n    print x,\n\nclaimant = ['A',' ','g','u','r','u']\nside_effect(claimant)\nprint claimant[-1]\n\n# oh no, claimant now ends with a '!'\n</code>\n</pre>\n", "senID": 4}, {"text": ["edit:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n a = ((\"this\",\"is\"),(\"a\",\"contrived\",\"example\"),(\"of\",\"the\",\"caboose\",\"idiom\"))\nfor b in a:\n  for c in b:\n    print c,\n    if \"is\" == c:\n      break\n  else:\n    print\n</code>\n</pre>\n", "senID": 6}]]