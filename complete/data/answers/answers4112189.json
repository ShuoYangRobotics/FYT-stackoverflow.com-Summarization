[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; from string import lowercase\n&gt;&gt;&gt; dict((j,i) for i,j in enumerate(lowercase, 1)) \n{'a': 1, 'c': 3, 'b': 2, 'e': 5, 'd': 4, 'g': 7, 'f': 6, 'i': 9, 'h': 8, 'k': 11, 'j': 10, 'm': 13, 'l': 12, 'o': 15, 'n': 14, 'q': 17, 'p': 16, 's': 19, 'r': 18, 'u': 21, 't': 20, 'w': 23, 'v': 22, 'y': 25, 'x': 24, 'z': 26}\n</code>\n</pre>\n", "senID": 0}, {"text": ["enumerate(lowercase) returns this sequence (0, 'a'), (1, 'b'), (2, 'c'),..."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "enumerate(lowercase)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(0, 'a'), (1, 'b'), (2, 'c'),...", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["by adding the optional parameter, enumerate starts at 1 instead of 0"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["enumerate(lowercase, 1) returns this sequence (1, 'a'), (2, 'b'), (3, 'c'),..."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "enumerate(lowercase, 1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(1, 'a'), (2, 'b'), (3, 'c'),...", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The optional parameter is not supported by python older than 2.6, so you could write it this way instead"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dict((j,i+1) for i,j in enumerate(lowercase))\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n dict((chr(x + 96), x) for x in range(1, 27))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Guess I didn't reat the question closely enough.", "Fixed"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dict( (chr(x), x-ord('a') +1 ) for x in range(ord('a'), ord('z')+1))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You are on the right track, but notice that zip requires a sequence."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So this is what you need:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n alphabets = dict(zip([chr(x) for x in range(ord('a'), ord('z')+1)], range(1, 27)))\n</code>\n</pre>\n", "senID": 2}, {"text": ["ord returns the integer ordinal of a one character string.", "So you can't do a chr(sequence) or an ord(sequence).", "It has to be a single character, or a single number."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "ord", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "chr(sequence)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "ord(sequence)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["I'm not sure of an exact implementation, but wouldn't it make sense to use the ASCII codes to your advantage as they're in order?", "Specify the start and end then loop through them adding the ASCII character and the ASCII code minus the starting point."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["dictionary comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n {chr(a + 96):a for a in range(1,27)}\n\n&gt;&gt;&gt; {chr(a + 96):a for a in range(1,27)}\n{'a': 1, 'c': 3, 'b': 2, 'e': 5, 'd': 4, 'g': 7, 'f': 6, 'i': 9, 'h': 8, 'k': 11, 'j': 10, 'm': 13, 'l': 12, 'o': 15, 'n': 14, 'q': 17, 'p': 16, 's': 19, 'r': 18, 'u': 21, 't': 20, 'w': 23, 'v': 22, 'y': 25, 'x': 24, 'z': 26}\n</code>\n</pre>\n", "senID": 1}, {"text": ["this only works in versions of python that support dictionary comprehensions, e.g.", "3.x and i think 2.7"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]