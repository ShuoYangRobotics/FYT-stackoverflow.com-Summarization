[[{"text": ["Look at this answer for a robust method to convert a number to an alphanumeric id"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this answer for a robust method to convert a number to an alphanumeric id", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/410485/whats-the-5-character-alphanumeric-id-in-reddit-url/410504#410504"}]}, {"text": ["The code I present doesn't go from 'Z' to 'AA', instead goes to 'BA', but I suppose that doesn't matter, it still produces a unique id"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from string import uppercase as up\nimport itertools\n\ndef to_base(q, alphabet):\n    if q &lt; 0: raise ValueError( \"must supply a positive integer\" )\n    l = len(alphabet)\n    converted = []\n    while q != 0:\n        q, r = divmod(q, l)\n        converted.insert(0, alphabet[r])\n    return \"\".join(converted) or alphabet[0]\n\nclass TimestampUniqifier( object ):\n    def __init__(self):\n        self.last = ''\n        self.counter = itertools.count()\n    def __call__( self, str ):\n        if str == self.last:\n            suf = self.counter.next()\n            return str + to_base( suf, up )\n        else:\n            self.last = str\n            self.counter = itertools.count()\n            return str            \n\ntimestamp_uniqify = TimestampUniqifier()\n</code>\n</pre>\n", "senID": 2}, {"text": ["usage:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n timestamp_uniqify('1')\n'1'\ntimestamp_uniqify('1')\n'1A'\ntimestamp_uniqify('1')\n'1B'\ntimestamp_uniqify('1')\n'1C'\ntimestamp_uniqify('2')\n'2'\ntimestamp_uniqify('3')\n'3'\ntimestamp_uniqify('3')\n'3A'\ntimestamp_uniqify('3')\n'3B'\n</code>\n</pre>\n", "senID": 4}, {"text": ["You can call it maaaany times and it will still produce good results:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n for i in range(100): print timestamp_uniqify('4')\n\n4\n4A\n4B\n4C\n4D\n4E\n4F\n4G\n4H\n4I\n4J\n4K\n4L\n4M\n4N\n4O\n4P\n4Q\n4R\n4S\n4T\n4U\n4V\n4W\n4X\n4Y\n4Z\n4BA\n4BB\n4BC\n4BD\n4BE\n4BF\n4BG\n4BH\n4BI\n4BJ\n4BK\n4BL\n4BM\n4BN\n4BO\n4BP\n4BQ\n4BR\n4BS\n4BT\n4BU\n4BV\n4BW\n4BX\n4BY\n4BZ\n4CA\n4CB\n4CC\n4CD\n4CE\n4CF\n4CG\n4CH\n4CI\n4CJ\n4CK\n4CL\n4CM\n4CN\n4CO\n4CP\n4CQ\n4CR\n4CS\n4CT\n4CU\n4CV\n4CW\n4CX\n4CY\n4CZ\n4DA\n4DB\n4DC\n4DD\n4DE\n4DF\n4DG\n4DH\n4DI\n4DJ\n4DK\n4DL\n4DM\n4DN\n4DO\n4DP\n4DQ\n4DR\n4DS\n4DT\n4DU\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Well, sorry to say, but you can't just do a direct translation from Perl to Python (including bit-for-bit Perlisms) and expect the outcome to be prettier.", "It won't be, it will be considerably uglier."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want the prettiness of Python you will need to use Python idioms instead."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Now for the question at hand:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from string import uppercase\n\nclass Uniquifier(object):\n\n    def __init__(self):\n        self.last_timestamp = None\n        self.last_suffix = 0\n\n    def uniquify(self, timestamp):\n        if timestamp == self.last_timestamp:\n            timestamp = '%s%s' % (timestamp,\n                                  uppercase[self.last_suffix])\n            self.last_suffix += 1\n        else:\n            self.last_suffix = 0\n            self.timestamp = timestamp\n        return timestamp\n\nuniquifier = Uniquifier()\nuniquifier.uniquify(a_timestamp)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Prettier?", "Maybe.", "More readable?", "Probably."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Edit (re comments): Yes this fails after Z, and I am altogether unhappy with this solution.", "So I won't fix it, but might offer something better, like using a number instead:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Edit (re comments):", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n timestamp = '%s%s' % (timestamp,\n                      self.last_suffix)\n</code>\n</pre>\n", "senID": 6}, {"text": ["If it were me, I would do this:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import uuid\n\ndef uniquify(timestamp):\n    return '%s-%s' % (timestamp, uuid.uuid4())\n</code>\n</pre>\n", "senID": 8}, {"text": ["And just be happy."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["I just tested this up to 1000 against the original perl implementation and diff returns the same results for both.", "The suffix code is tricky -- this is not a base 36 counter.", "Hasen J's solution - though it produces a unique timestamp - isn't quite the same since it goes from 'Z' to 'BA', when it should instead go to 'AA' to match the perl ++ operator."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n\nclass uniqify:\n    def __init__(self):\n        self.last_timestamp = -1\n        self.next_suffix = 'A'\n        return\n\n    def suffix(self):\n        s = self.next_suffix\n        letters = [l for l in self.next_suffix]\n        if letters[-1] == 'Z':\n            letters.reverse()\n            nonz = None\n            for i in range(len(letters)):\n                if letters[i] != 'Z':\n                    nonz = i\n                    break\n            if nonz is not None:\n                letters[nonz] = chr(ord(letters[nonz]) + 1)\n                for i in range(0, nonz):\n                    letters[i] = 'A'\n            else:\n                letters = ['A'] * (len(letters) + 1)\n            letters.reverse()\n        else:\n            letters[-1] = chr(ord(letters[-1]) + 1)\n\n        self.next_suffix = ''.join(letters)\n        return s\n\n    def reset(self):\n        self.next_suffix = 'A'\n        return\n\n    def __call__(self, timestamp):\n        if timestamp == self.last_timestamp:\n            timestamp_str = '%s%s' % (timestamp, self.suffix())\n        else:\n            self.last_timestamp = timestamp\n            self.reset()\n            timestamp_str = '%s' % timestamp\n\n        return timestamp_str\n\nuniqify = uniqify()\n\nif __name__ == '__main__':\n    for n in range(1000):\n        print uniqify(1)\n    for n in range(1000):\n        print uniqify(2)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The class is generic and boring, but This is my very first recursive generator.", "&lt;3"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "but This is my very first recursive generator.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def stamptag():\n    yield ''\n    prefixtag = stamptag()\n    prefix = prefixtag.next()\n    while True:\n        for i in range(ord('A'),ord('Z')+1):\n            yield prefix+chr(i)\n        prefix = prefixtag.next()\n\ntagger = stamptag()\nfor i in range(3000):\n    tagger.next()\nprint tagger.next()\n\nclass uniquestamp:\n    def __init__(self):\n        self.timestamp = -1\n        self.tagger = stamptag()\n\n    def format(self,newstamp):\n        if self.timestamp &lt; newstamp:\n            self.tagger = stamptag()\n            self.timestamp = newstamp\n        return str(newstamp)+self.tagger.next()\n\nstamper = uniquestamp()\nprint map(stamper.format, [1,1,1,2,2,3,4,4])\n</code>\n</pre>\n", "senID": 1}, {"text": ["output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n DKJ\n['1', '1A', '1B', '2', '2A', '3', '4', '4A']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Quite similar to Ali A, but I'll post mine anyway:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class unique_timestamp:\n    suffixes = \" ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    def __init__(self):\n        self.previous_timestamps = {}\n        pass\n    def uniquify(self, timestamp):\n        times_seen_before = self.previous_timestamps.get(timestamp, 0)\n        self.previous_timestamps[timestamp] = times_seen_before + 1\n        if times_seen_before &gt; 0:\n            return str(timestamp) + self.suffixes[times_seen_before]\n        else:\n            return str(timestamp)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; u = unique_timestamp()\n&gt;&gt;&gt; u.uniquify(1)\n'1'\n&gt;&gt;&gt; u.uniquify(1)\n'1A'\n&gt;&gt;&gt; u.uniquify(1)\n'1B'\n&gt;&gt;&gt; u.uniquify(2)\n'2'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Does the suffix have to be letters like that?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import count\ndef unique(timestamp): \n  if timestamp in unique.ts.keys():\n    return timestamp + '.' + str(unique.ts[timestamp].next())\n  else:\n    unique.ts[timestamp] = count()\n    return timestamp\nunique.ts = {}\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can define a different count if you want the letters back."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This isn't the same as your perl code, though."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "It keeps a dict around so if you have lots of unique timestamps then you'll use lots of memory.", "tag": "none", "senID": 4}, {"text": "It handles out of order calls, which the original doesn't (i.e. u(1), u(2), u(1)).", "tag": "none", "senID": 5}]}], [{"text": ["This is my first time answering, and I used globals, but it seemed the simplest way to me."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from string import uppercase\n\nlast_ts = None\nletters = None\n\ndef increment(letters):\n    if not letters:\n        return \"A\"\n    last_letter = letters[-1]\n    if last_letter == \"Z\":\n        return increment(letters[:-1])  + \"A\" \n    return letters[:-1] + uppercase[uppercase.index(last_letter) + 1]\n\ndef uniquify(timestamp):\n    global last_ts, letters\n    if timestamp == last_ts:\n        letters = increment(letters)\n        return timestamp + letters\n    last_ts = timestamp\n    letters = None\n    return timestamp\n\nprint uniquify(\"1\")\nprint uniquify('1')\nprint uniquify(\"1\")\nprint uniquify(\"2\")\nfor each in range(100): print uniquify(\"2\")\n\n\n1\n1A\n1B\n2\n2A\n2B\n2C\n2D\n2E\n2F\n2G\n2H\n2I\n2J\n2K\n2L\n2M\n2N\n2O\n2P\n2Q\n2R\n2S\n2T\n2U\n2V\n2W\n2X\n2Y\n2Z\n2AA\n2AB\n2AC\n2AD\n2AE\n2AF\n2AG\n2AH\n2AI\n2AJ\n2AK\n2AL\n2AM\n2AN\n2AO\n2AP\n2AQ\n2AR\n2AS\n2AT\n2AU\n2AV\n2AW\n2AX\n2AY\n2AZ\n2BA\n2BB\n2BC\n2BD\n2BE\n2BF\n2BG\n2BH\n2BI\n2BJ\n2BK\n2BL\n2BM\n2BN\n2BO\n2BP\n2BQ\n2BR\n2BS\n2BT\n2BU\n2BV\n2BW\n2BX\n2BY\n2BZ\n2CA\n2CB\n2CC\n2CD\n2CE\n2CF\n2CG\n2CH\n2CI\n2CJ\n2CK\n2CL\n2CM\n2CN\n2CO\n2CP\n2CQ\n2CR\n2CS\n2CT\n2CU\n2CV\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Looking at the problem it seems like a good fit for a coroutine (Python 2.5 or higher).", "Here's some code that will roughly produce the same result:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def uniqify():\n    seen = {}\n    val = (yield None)\n    while True:\n        if val in seen:\n            idxa, idxb = seen[val]\n            idxb += 1\n        else:\n            idxa, idxb = (len(seen)+1, ord('a'))\n        seen[val] = (idxa, idxb)\n        uniq = \"%s%s\" % (idxa, chr(idxb))\n        val = (yield uniq)\n</code>\n</pre>\n", "senID": 1}, {"text": ["And here's how you use it:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; u = send.uniqify()\n&gt;&gt;&gt; u.next() #need this to start the generator\n&gt;&gt;&gt; u.send(1)\n'1a'\n&gt;&gt;&gt; u.send(1)\n'1b'\n&gt;&gt;&gt; u.send(1)\n'1c'\n&gt;&gt;&gt; u.send(2)\n'2a'\n&gt;&gt;&gt; u.send(2)\n'2b'\n&gt;&gt;&gt; u.send(1) #you can go back to previous values\n'1d'\n&gt;&gt;&gt; u.send('stringy') #you can send it anything that can be used as a dict key\n'3a'\n</code>\n</pre>\n", "senID": 3}]]