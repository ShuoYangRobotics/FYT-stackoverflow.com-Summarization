[[{"text": ["You have two options here."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I wouldn't recommend you to choose 2., because you're in fact repeating cron functionality.", "The Linux system paradigm is to let multiple simple tools interact and solve your problems.", "Unless there are additional reasons why you should make a daemon (in addition to trigger periodically), choose the other approach."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Also, if you use daemonize with a loop and a crash happens, noone will check the mail after that (as pointed out by Ivan Nevostruev in comments to this answer).", "While if the script is added as a cron job, it will just trigger again."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Ivan Nevostruev", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/93988/ivan-nevostruev"}, {"text": "this", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1603109/how-to-make-a-python-script-run-like-a-service-or-daemon-in-linux/1603146#1603146"}]}], [{"text": ["You should use a library, it takes care of everything:  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://pypi.python.org/pypi/python-daemon/\nFrom PyPI: Library to implement a well-behaved Unix daemon process."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "http://pypi.python.org/pypi/python-daemon/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/python-daemon/"}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "Library to implement a well-behaved Unix daemon process.", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["Recipe 278731: Creating a daemon the Python way"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Recipe 278731: Creating a daemon the Python way", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/278731/"}]}], [{"text": ["Here's a nice class that is taken from here:  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/"}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nimport sys, os, time, atexit\nfrom signal import SIGTERM\n\nclass Daemon:\n        \"\"\"\n        A generic daemon class.\n\n        Usage: subclass the Daemon class and override the run() method\n        \"\"\"\n        def __init__(self, pidfile, stdin='/dev/null', stdout='/dev/null', stderr='/dev/null'):\n                self.stdin = stdin\n                self.stdout = stdout\n                self.stderr = stderr\n                self.pidfile = pidfile\n\n        def daemonize(self):\n                \"\"\"\n                do the UNIX double-fork magic, see Stevens' \"Advanced\n                Programming in the UNIX Environment\" for details (ISBN 0201563177)\n                http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16\n                \"\"\"\n                try:\n                        pid = os.fork()\n                        if pid &gt; 0:\n                                # exit first parent\n                                sys.exit(0)\n                except OSError, e:\n                        sys.stderr.write(\"fork #1 failed: %d (%s)\\n\" % (e.errno, e.strerror))\n                        sys.exit(1)\n\n                # decouple from parent environment\n                os.chdir(\"/\")\n                os.setsid()\n                os.umask(0)\n\n                # do second fork\n                try:\n                        pid = os.fork()\n                        if pid &gt; 0:\n                                # exit from second parent\n                                sys.exit(0)\n                except OSError, e:\n                        sys.stderr.write(\"fork #2 failed: %d (%s)\\n\" % (e.errno, e.strerror))\n                        sys.exit(1)\n\n                # redirect standard file descriptors\n                sys.stdout.flush()\n                sys.stderr.flush()\n                si = file(self.stdin, 'r')\n                so = file(self.stdout, 'a+')\n                se = file(self.stderr, 'a+', 0)\n                os.dup2(si.fileno(), sys.stdin.fileno())\n                os.dup2(so.fileno(), sys.stdout.fileno())\n                os.dup2(se.fileno(), sys.stderr.fileno())\n\n                # write pidfile\n                atexit.register(self.delpid)\n                pid = str(os.getpid())\n                file(self.pidfile,'w+').write(\"%s\\n\" % pid)\n\n        def delpid(self):\n                os.remove(self.pidfile)\n\n        def start(self):\n                \"\"\"\n                Start the daemon\n                \"\"\"\n                # Check for a pidfile to see if the daemon already runs\n                try:\n                        pf = file(self.pidfile,'r')\n                        pid = int(pf.read().strip())\n                        pf.close()\n                except IOError:\n                        pid = None\n\n                if pid:\n                        message = \"pidfile %s already exist. Daemon already running?\\n\"\n                        sys.stderr.write(message % self.pidfile)\n                        sys.exit(1)\n\n                # Start the daemon\n                self.daemonize()\n                self.run()\n\n        def stop(self):\n                \"\"\"\n                Stop the daemon\n                \"\"\"\n                # Get the pid from the pidfile\n                try:\n                        pf = file(self.pidfile,'r')\n                        pid = int(pf.read().strip())\n                        pf.close()\n                except IOError:\n                        pid = None\n\n                if not pid:\n                        message = \"pidfile %s does not exist. Daemon not running?\\n\"\n                        sys.stderr.write(message % self.pidfile)\n                        return # not an error in a restart\n\n                # Try killing the daemon process       \n                try:\n                        while 1:\n                                os.kill(pid, SIGTERM)\n                                time.sleep(0.1)\n                except OSError, err:\n                        err = str(err)\n                        if err.find(\"No such process\") &gt; 0:\n                                if os.path.exists(self.pidfile):\n                                        os.remove(self.pidfile)\n                        else:\n                                print str(err)\n                                sys.exit(1)\n\n        def restart(self):\n                \"\"\"\n                Restart the daemon\n                \"\"\"\n                self.stop()\n                self.start()\n\n        def run(self):\n                \"\"\"\n                You should override this method when you subclass Daemon. It will be called after the process has been\n                daemonized by start() or restart().\n                \"\"\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["First, read up on mail aliases.", "A mail alias will do this inside the mail system without you having to fool around with daemons or services or anything of the sort."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can write a simple script that will be executed by sendmail each time a mail message is sent to a specific mailbox."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["See http://www.feep.net/sendmail/tutorial/intro/aliases.html"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.feep.net/sendmail/tutorial/intro/aliases.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.feep.net/sendmail/tutorial/intro/aliases.html"}]}, {"text": ["If you really want to write a needlessly complex server, you can do this."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n nohup python myscript.py &amp;\n</code>\n</pre>\n", "senID": 4}, {"text": ["That's all it takes.", "Your script simply loops and sleeps."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import time\ndef do_the_work():\n    # one round of polling -- checking email, whatever.\nwhile True:\n    time.sleep( 600 ) # 10 min.\n    try:\n        do_the_work()\n    except:\n        pass\n</code>\n</pre>\n", "senID": 6}], [{"text": ["You can use fork() to detach your script from the tty and have it continue to run, like so:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os, sys\nfpid = os.fork()\nif fpid!=0:\n  # Running as daemon now. PID is fpid\n  sys.exit(0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course you also need to implement an endless loop, like"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n while 1:\n  do_your_check()\n  sleep(5)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Hope this get's you started."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["how about using $nohup command on linux?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "$nohup", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I use it for running my commands on my Bluehost server."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Please advice if I am wrong."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]