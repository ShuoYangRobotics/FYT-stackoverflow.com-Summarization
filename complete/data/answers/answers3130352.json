[[{"text": ["Reduce is often used in combination with map.", "Google for example has developed a map-reduce framework for querying their databases and this map-reduce pattern is now used in several other projects (e.g.", "CouchDB, Hadoop, etc)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First, you need to map the input variables [2, 1, 3, 4, 5] to something like:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "input", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[2, 1, 3, 4, 5]", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n [(1, 2), (1, 1), (1, 3), (1, 4), (1, 5)]\n</code>\n</pre>\n", "senID": 2}, {"text": ["In that case, x[0] will represent the number of the elements to get the sum x[1].", "Of course, the number of elements is 1 at the beginning for each single element."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "x[0]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x[1]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The next thing then, is to operate on those tuples:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n reduce(\n    lambda a, b: a if a[1] + b[1] &gt; 8 else (a[0] + b[0], a[1] + b[1]),\n    map(lambda x: (1, x), input))\n</code>\n</pre>\n", "senID": 5}, {"text": ["This will return (3, 6), meaning the partial sum is 6 using 3 elements."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "(3, 6)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "6", "childNum": 0, "tag": "code", "childList": []}, {"text": "3", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I hope you got the idea behind map-reduce-algorithms."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Regards,\nChristoph"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}], [{"text": ["I agree with JaredPar that writing your own recursive function that behaves similarly to fold, but allows you to stop the computation earlier is the best approach.", "The way I would write it is a bit more general (so that you can use the function for any situation where you need folding that can stop earlier):"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "fold", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "folding", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "stop earlier", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n // Generalized 'fold' function that allws you to stop the execution earlier\n// The function 'f' has a type 'State -&gt; 'T -&gt; Option&lt;'State&gt;\n// By returning 'None' we can stop the execution (and return the \n// current state), by returning Some(newState), we continue folding\nlet rec foldStop f state input = \n  match input with\n  | x::xs -&gt; \n      match f state x with\n      | None -&gt; state\n      | Some(newState) -&gt; foldStop f newState xs\n  | [] -&gt; state\n\n// Example that stops folding after state is larger than 10\nfoldStop (fun st n -&gt; if st &gt; 10 then None else Some(st + n)) 0 [ 1 .. 10 ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is a very general function and you can use it for all similar scenarios.", "The nice thing about writing it is that you will never need to write similar explicit recursion again (because you can just use foldStop once you have it)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "foldStop", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Note that you can use foldStop to implement fold by always wrapping the result of the accumulation function in 'Some' (so it is more general):"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "foldStop", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fold", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n let fold f state input = \n  foldStop (fun st n -&gt; Some(f st n)) state input\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I think that the 'most functional' way to do this is probably via lazy evaluation.", "If you're in a lazy language like Haskell, or in an eager language but using a lazy list data structure (like LazyList in the F# PowerPack), you can create e.g.", "a 'scan' of the running sums, and then leave it in the hands of the consumer of the list to decide how much she wants/needs to evaluate."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "LazyList", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Or, you know, write a simple recursive function, like @JaredPar's answer.", "For some reason I often get a mental block on that, preventing me from noticing that \"not everything has to be a fold, you can in fact write your own recursive functions\" :)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "fold", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Let's imagine Python had two functions called ireduce (similar to reduce but it would yield intermediate values; it's called scanl in some languages) and ilast (return last item in iterable).", "Then we could write this pure functional code:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "ireduce", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "reduce", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "scanl", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "ilast", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import takewhile\nfrom operator import add\na = [1, 2, 3, 4, 5]\nprint ilast(enumerate(takewhile(lambda x: x &lt; 8, ireduce(add, a, 0))))\n# (3, 6)\n</code>\n</pre>\n", "senID": 1}, {"text": ["For a ireduce implementation see http://gnosis.cx/publish/programming/charming_python_b13.html"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "ireduce", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"href": "http://gnosis.cx/publish/programming/charming_python_b13.html", "text": "http://gnosis.cx/publish/programming/charming_python_b13.html", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["For ilast see http://stackoverflow.com/questions/2138873/cleanest-way-to-get-last-item-from-python-iterator"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "ilast", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/2138873/cleanest-way-to-get-last-item-from-python-iterator", "text": "http://stackoverflow.com/questions/2138873/cleanest-way-to-get-last-item-from-python-iterator", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["And how would this look in Haskell?", "(probably the prettiest functional language out there)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt; last $ zip [0..] (takeWhile (&lt; 8) (scanl (+) 0 a))\n(3,6)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Try the following"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n let sumUntil list stopAfter = \n    let rec inner list sum = \n        if sum &gt;= stopAfter then sum\n        else \n            match list with\n            | [] -&gt; sum\n            | h::t-&gt; inner t (sum + h)\n    inner list 0\n</code>\n</pre>\n", "senID": 1}, {"text": ["F# interactive result"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt; sumUntil [1;2;3;4;5] 8;;\nval it : int = 10\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This is a function that implements that functional program:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def limited_reduce(reducer, pred, lst):\n...  i = 0\n...  y = lst[0]\n...  while pred(y) and i &lt; len(lst):\n...    i += 1\n...    y = reducer(lst[i], y)\n...  return (i, y)\n</code>\n</pre>\n", "senID": 1}, {"text": ["or recursively:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def limited_reduce(reducer, pred, lst):\n...   def helper(i, accum, rest):\n...     if not rest or not pred(accum): return (i, accum)\n...     return helper(i+1, reducer(rest[0], accum), rest[1:])\n...   return helper(0, lst[0], lst[1:])\n</code>\n</pre>\n", "senID": 3}, {"text": ["There's probably a way to clean it up a bit, but you would use it like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;&gt; limited_reduce(lambda x,y: x+y, lambda r: r &lt; 6, [1,2,1,3,2])\n(3, 7)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Another functional approch could be using a \"continution\"-based version of reduce/fold:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n let rec foldC fn acc cont = function\n    | []      -&gt; acc\n    | x :: xs -&gt; fn x acc (fun acc -&gt; foldC fn acc cont xs)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Call with 'id' (fun x -> x) as 'initial continuation':"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n foldC (fun x sum c -&gt; \n           if (sum + x) &gt; 8 \n           then sum \n           else c (sum + x))\n      0\n      (fun x -&gt; x) \n      [1; 2; 3; 4; 5]\n</code>\n</pre>\n", "senID": 3}, {"text": ["And you will get your '6'. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Note that this version of foldC is not tail recursive - or otherwise recommended - thought...  "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "foldC", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I think this does what you are after, using functions built-in to the F# Seq module:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n let answer =\n    [1; 2; 3; 4; 5]\n    |&gt; Seq.scan (fun (count,sum) x -&gt; (count+1, sum + x) ) (0,0)\n    |&gt; Seq.find (fun (_,x) -&gt; x &gt; 8)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The \"scan\" function is similar to \"fold\", but returns a sequence containing intermediate (and final) states, rather than just the final state.", "In this case, the state is a tuple containing a count and sum of items thus far processed, starting with (0,0).", "This gets computed and fed, one at a time, into the \"find\" function, which returns the first element which matches the supplied condition (v>8), in this case (4,10)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The only issue you'd need to handle with the above is the case where the \"find\" condition is never satisfied, in which case a KeyNotFoundException is thrown.", "You could use \"tryFind\" which returns an option value.", "However, I can't see a graceful way to return the last element computed if no earlier state matches the condition, short of pre-computing the length of the sequence:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n let xs = [1; 2; 3; 4; 5]\nlet len = Seq.length xs\nlet answer =\n    xs\n    |&gt; Seq.scan (fun (count,acc) v -&gt; (count+1, v + acc) ) (0,0)\n    |&gt; Seq.find (fun (count,v) -&gt; v &gt; 99 || count = len)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Here is a slight variation of Stephen's code, using foldl instead of foldr (I hope) and not requiring a sequence:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "foldl", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foldr", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nimport operator\nimport functools\n\ndef limited_reduce(op, it, start, pred):\n    if not pred(start):\n        return 0, start\n    for i, x in enumerate(it):\n        y = op(start, x)\n        if pred(y):\n            start = y\n        else:\n            break\n    return i, start\n\nprint limited_reduce(operator.add, xrange(1, 6), 0,\n                     functools.partial(operator.gt, 8))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The only way to get out of the builtin reduce part way through is to throw an exception.", "Fortunately it's not hard to get the desired result this way:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "reduce", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def interruptible_reduce(fn, *args):\n    try:\n        return reduce(fn, *args)\n    except StopIteration, e:\n        return e.args[0]\n\ndef reducefn(a, b):\n    total = a[1] + b[1]\n    if total &gt; 8:\n        raise StopIteration(a)\n    return (a[0]+b[0], total)\n\ninput = [2, 1, 3, 4, 5]\n\n&gt;&gt;&gt; from itertools import imap\n&gt;&gt;&gt; interruptible_reduce(reducefn, imap(lambda x: (1,x), input))\n(3, 6)\n</code>\n</pre>\n", "senID": 1}]]