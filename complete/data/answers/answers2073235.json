[[{"text": ["Generate a Cumulative Distribution Function for each ID1 thus:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n cdfs = defaultdict()\nfor id1,id2,val in d:\n    prevtotal = cdfs[id1][-1][0]\n    newtotal = prevtotal + val\n    cdfs[id1].append( (newtotal,id2) )\n</code>\n</pre>\n", "senID": 1}, {"text": ["So you will have"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n cdfs = { 701 : [ (0.2,1), (0.5,2), (1.0,3) ], \n         702 : [ (0.2,1), (0.5,2) ],\n         703 : [ (0.5,3) ] }\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then generate a random number and search for it in the list."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def func(id1):\n    max = cdfs[id1][-1][0]\n    rand = random.random()*max\n    for upper,id2 in cdfs[id1]:\n        if upper&gt;rand:\n            return id2\n        else:\n            return None\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Use a discrete uniform distribution from the random module over a sufficient number of values, then partition it:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "random module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/random.html"}]}, {"text": ["For example, for case 701 use a distribution over 10 values, for 2 values return 1, for another 3, return 2, and for the other 5, return 3."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can build any distribution using enough uniform distributions :)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Realizing that my first answer was quite buggy in its math, I have produced a new idea.", "I believe the algorithm here is similar to that of several of the other answers, but this implementation seems to qualify for the \"pretty\" (if that equals simple) requirement of the question:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def func(id):\n    rnd = random()\n    sum = 0\n    for row in d:\n        if row[0] == id:\n            sum = sum + row[2]\n            if rnd &lt; sum:\n                return row[1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["With the example data from the OP it goes like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Pick a random number between 0 and 1.0", "tag": "none", "senID": 3}, {"text": "If the number is ", "tag": "none", "senID": 4}, {"text": "Else if the number is ", "tag": "none", "senID": 5}, {"text": "Else (if the number is ", "tag": "none", "senID": 6}]}], [{"text": ["A very quick hack:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random\n\nd = {\n    701: [(1,0.2),(2,0.3),(3,0.5)],\n    702: [(1,0.2),(2,0.3),(3,0.5)]\n}\n\ndef func(value):\n    possible_values=d[value]\n    total=sum(p[-1] for p in possible_values)\n    random_value=random.random()\n    prob=possible_values[0][-1]/total\n    index=1\n    while index&lt;len(possible_values) and prob&lt;random_value:\n        prob+=possible_values[index][-1]/total\n        index+=1\n    return possible_values[index-1][0]\n\nif __name__=='__main__':\n    testcases=1000\n    cnt=[0,0,0]\n    for case in xrange(testcases):\n        answer=func(701)\n        cnt[answer-1]+=1\n    for i in xrange(3):\n        print \"Got %d %f%% of the time\"%(i+1,float(cnt[i])/testcases*100)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It isn't pretty, but it is the first thing that came to mind, and appears to work as expected."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["What this does is to get a random value in the interval [0,1) (using random.random()).", "It then uses whether the random value falls in the intervals [0,0.2),[0.2,0.5) or [0.5,1), to figure out which value to return."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If your percent values will not be more precise than whole percent values, use a random number generator to generate a number 0-99."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Then in your function, use (programmatic) cases to choose the correct number.", "For example (clean this up):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\nif 701\n  if random_num &lt; 20\n    return 1\n  else if random number &lt; 50   // ( 20 + 30 )\n    return 2\n  else if random number &lt; 100  // ( 20 + 30 + 50 )\n    return 3\n  else\n    // error\n</pre>\n", "senID": 2}], [{"text": ["Two ideas (allow me to illustrate it with separated options and ratios for the sake of clarity in the argument names, if they're packed in a tuple you can save the \"zip\"):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["a) Denormalize the weights to get integer ratios, then put in a list as many copies as the ratio and use random.choice."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "random.choice", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def choice_with_ratios(options, ratios):\n    tmp = sum([[v]*n for v, n in zip(options, ratios)], [])\n    return random.choice(tmp)\n</code>\n</pre>\n", "senID": 2}, {"text": ["b) Use the normalized weights and start summing up until you reach a random generated uniform value"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def choice_with_weights(options, weights):\n    s = 0\n    r = random.random()\n    for v, w in zip(options, weights):\n        s += w\n        if s &gt;= r: break\n    return v\n</code>\n</pre>\n", "senID": 4}, {"text": ["By the way, if the first field is used as a key, you should have it in a dictionary, like:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n d = {\n  701: ((1, 0.2), (2, 0.3), (3, 0.5),\n  702: ((1, 0.3), (2, 0.2), (3, 0.5)\n}\n</code>\n</pre>\n", "senID": 6}], [{"text": ["You can also create a 100-element list for each value, and then let random.choice do the selecting from a seeded list whose members are loaded in the weighting that you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random\nfrom collections import defaultdict\n\nd = ( \n  (701, 1, 0.2), \n  (701, 2, 0.3), \n  (701, 3, 0.5), \n  (702, 1, 0.2), \n  (702, 2, 0.3), \n  (702, 3, 0.5) \n) \n\nclass WeightedLookup(object):\n    def __init__(self, valueTupleList):\n        self.valdict = defaultdict(list)\n        for key, val, prob in valueTupleList:\n            self.valdict[key] += [val]*(int)(prob*100)\n\n    def __getitem__(self,key):\n        return random.choice(self.valdict[key])\n\n\nlookup = WeightedLookup(d)\n\n# test out our lookup distribution, sample it 100000 times\nres = { 1:0, 2:0, 3:0 }\nfor i in range(100000):\n    res[lookup[701]] += 1\n\n# print how many times each value was returned\nfor k in (1,2,3):\n    print k, res[k]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 1 20059\n2 30084\n3 49857\n</code>\n</pre>\n", "senID": 3}]]