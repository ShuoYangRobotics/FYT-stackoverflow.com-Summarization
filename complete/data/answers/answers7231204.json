[[{"text": ["The biggest problem with your code is that it's unreadable.", "Python code rule number one, if it's not readable, no one's gonna look at it for long enough to get any useful information out of it.", "Always use descriptive variable names.", "Almost didn't catch the bug in your code, let's see it again with good names, slow-motion replay style:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n to_modify = [5,4,3,2,1,0]\nindexes = [0,1,3,5]\nreplacements = [0,0,0,0]\n\nfor index in indexes:\n    to_modify[indexes[index]] = replacements[index]\n    # to_modify[indexes[index]]\n    # indexes[index]\n    # Yo dawg, I heard you liked indexes, so I put an index inside your indexes\n    # so you can go out of bounds while you go out of bounds.\n</code>\n</pre>\n", "senID": 1}, {"text": ["As is obvious when you use descriptive variable names, you're indexing the list of indexes with values from itself, which doesn't make sense in this case."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Also when iterating through 2 lists in parallel I like to use the zip function (or izip if you're worried about memory consumption, but I'm not one of those iteration purists).", "So try this instead."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "izip", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n for (index, replacement) in zip(indexes, replacements):\n    to_modify[index] = replacement\n</code>\n</pre>\n", "senID": 4}, {"text": ["If your problem is only working with lists of numbers then I'd say that @steabert has the answer you were looking for with that numpy stuff.", "However you can't use sequences or other variable-sized data types as elements of numpy arrays, so if your variable to_modify has anything like that in it, you're probably best off doing it with a for loop."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "to_modify", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["numpy has arrays that allow you to use other lists/arrays as indices:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy\nS=numpy.array(s)\nS[a]=m\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Why not just:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n map(s.__setitem__, a, m)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A little slower, but readable I think:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s, l, m\n([5, 4, 3, 2, 1, 0], [0, 1, 3, 5], [0, 0, 0, 0])\n&gt;&gt;&gt; d = dict(zip(l, m))\n&gt;&gt;&gt; d  #dict is better then using two list i think\n{0: 0, 1: 0, 3: 0, 5: 0}\n&gt;&gt;&gt; [d.get(i, j) for i, j in enumerate(s)]\n[0, 0, 3, 0, 1, 0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This will cause index to take on the values of the elements of a, so using them as indices is not what you want.", "In Python, we iterate over a container by actually iterating over it."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "index", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "elements", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["\"But wait\", you say, \"For each of those elements of a, I need to work with the corresponding element of m. How am I supposed to do that without indices?"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "m", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Simple.", "We transform a and m into a list of pairs (element from a, element from m), and iterate over the pairs.", "Which is easy to do - just use the built-in library function zip, as follows:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "m", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "zip", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n for a_element, m_element in zip(a, m):\n  s[a_element] = m_element\n</code>\n</pre>\n", "senID": 3}, {"text": ["To make it work the way you were trying to do it, you would have to get a list of indices to iterate over.", "This is doable: we can use range(len(a)) for example.", "But don't do that!", "That's not how we do things in Python.", "Actually directly iterating over what you want to iterate over is a beautiful, mind-liberating idea."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "range(len(a))", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Not really relevant here.", "The purpose of operator.itemgetter is to turn the act of indexing into something, into a function-like thing (what we call \"a callable\"), so that it can be used as a callback (for example, a 'key' for sorting or min/max operations).", "If we used it here, we'd have to re-call it every time through the loop to create a new itemgetter, just so that we could immediately use it once and throw it away.", "In context, that's just busy-work."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "operator.itemgetter", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You can use operator.setitem."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "operator.setitem", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from operator import setitem\na = [5, 4, 3, 2, 1, 0]\nell = [0, 1, 3, 5]\nm = [0, 0, 0, 0]\nfor b, c in zip(ell, m):\n    setitem(a, b, c)\n&gt;&gt;&gt; a\n[0, 0, 3, 0, 1, 0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Is it any more readable or efficient than your solution?", "I am not sure!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]