[[{"text": ["Here's a literal answer to your question:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import struct\nwith open('gibberish.bin', 'wb') as f:\n    f.write(struct.pack('&lt;4d', 3.14159, 42.0, 123.456, 987.654))\n</code>\n</pre>\n", "senID": 1}, {"text": ["That's packing those 4 floating point numbers into a binary format (little-endian IEEE 756 64-bit floating point)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "IEEE 756", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/IEEE_754-2008"}]}, {"text": ["Here's (some of) what you need to know:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Reading and writing a file in binary mode incurs no transformation on the data that you read or write.", "In text mode, as well as any decoding/encoding to/from Unicode, the data that you read or write is transformed according to the platform conventions for \"text files\"."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Unix/Linux/Mac OS X: no change"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["older Mac: line separator is \\r, changed to/from Python standard \\n"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "\\r", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\n", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Windows: line separator is \\r\\n, changed to/from \\n.", "Also (little known fact), Ctrl-Z aka \\x1a is interpreted as end-of-file, a convention inherited from CP/M which recorded file sizes as the number of 128-byte sectors used."], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "\\r\\n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\n", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\\x1a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "CP/M", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["So-called \"text\" files are simply files that follow certain conventions: the bytes are usually a subset of all the possible bytes, generally ASCII or Unicode values, and are organized into \"lines\" with \"line terminators\".", "The standard line terminators vary by platform - Unix uses \\n, Mac \\r, and Windows \\r\\n - so part of the convention is to translate these on the fly.", "This works fine with text files, but will clobber other kinds of files, because an 0x0a (\\n) byte in a sound file or something won't take well to being converted to 0x0d 0x0a (\\r\\n).", "Of course, if you've only been using Unix, this won't have come up."], "childNum": 8, "tag": "p", "senID": 0, "childList": [{"text": "\\n", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\\r", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "\\r\\n", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "0x0a", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\\n", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "0x0d", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "0x0a", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\\r\\n", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["In Python 3, all strings are Unicode, and opening a file as text means you have to read and write Unicode strings, and perhaps specify an encoding (it defaults to UTF-8).", "Opening a file as binary means you have to use bytes objects, which are simple lists of 8-bit bytes and don't get encoded."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "bytes", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Does this clarify things?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You'll have to change your approach when you upgrade to Python 3.x:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; f = open(filename, 'wb')\n&gt;&gt;&gt; f.write(\"Hello, world!\\n\")\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: must be bytes or buffer, not str\n&gt;&gt;&gt; f.write(b\"Hello, world!\\n\")\n14\n</code>\n</pre>\n", "senID": 1}, {"text": ["But your question isn't really about binary files.", "It's about str."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In Python 2.x, str is a byte sequence that has an overloaded meaning:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "byte", "childNum": 0, "tag": "strong", "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "A non-Unicode string, or", "tag": "none", "senID": 4}, {"text": "Raw binary data (like pixels in an image).", "tag": "none", "senID": 5}]}, {"text": ["If you print the latter as it were the former, you get gibberish."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Python 3.x got rid of this double meaning by introducing a separate bytes type for binary data, leaving str unambiguously as a text string (and making it Unicode)."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "Python 3.x", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://diveintopython3.org/strings.html"}, {"text": "bytes", "childNum": 0, "tag": "code", "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Binary files are normally created when you try to encode objects.", "For example, you might have a Person object with properties like Name, Age, Height.", "If you were to write this file as text so that it can be read back in later, you might output something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Name:Ralph\nAge:25\nHeight:5'6\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["But you can represent it more compactly in binary.", "In binary, you might just output the name, age and height one right after the other, and you'd have to read them back in in the exact same order because you no longer have these delimiters.", "In that case, your string would have to encoded with something like Ralph\\0.", "The \\0 is the null character so that it knows where the string ends. "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Ralph\\0", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "\\0", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["The 25 can be represented as just 2 characters in text/ASCII but if you tried putting two numbers side-by-side, like 25 and 26, you'd get 2526 and you wouldn't know where one ends and the next begins.", "These numbers are actually integers and be represented by 4 bytes.", "When you write a file as binary, you'd write out all 4 bytes, even if the left-most bits are all 0.", "That way it always knows exactly how much to read it.", "And so forth..."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "25", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["That's why \"binary files\" look like jibberish, because they've got all this extra information in them."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["To generate these files, you'd have to encode or \"pack\" your data like John Machin suggests."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Maybe your are sending string in your binary file and your computer can decode it and show it to you?", "Try to write a file with random byte.", "Or you could show us your code so we can understand the problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I recommend using the codecs module of Python for writing text files (it allows you to set the related charset/encoding).", "For writing binary file use the standard file() method.", "On windows you may need use 'wb' or 'rb' for binary modes (does not matter on Unix)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "codecs", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}]]