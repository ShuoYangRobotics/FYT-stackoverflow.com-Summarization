[[{"text": ["The purpose of metaclasses isn't to replace the class/object distinction with metaclass/class - it's to change the behaviour of class definitions (and thus their instances) in some way.", "Effectively it's to alter the behaviour of the class statement in ways that may be more useful for your particular domain than the default.", "The things I have used them for are:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["Tracking subclasses, usually to register handlers.", "This is handy when using a plugin style setup, where you wish to register a handler for a particular thing simply by subclassing and setting up a few class attributes.", "eg.", "suppose you write a handler for various music formats, where each class implements appropriate methods (play / get tags etc) for its type.", "Adding a handler for a new type becomes:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Changing behaviour.", "You may want to attach a special meaning to certain attributes, resulting in altered behaviour when they are present.", "For example, you may want to look for methods with the name _get_foo and _set_foo and transparently convert them to properties.", "As a real-world example, here's a recipe I wrote to give more C-like struct definitions.", "The metaclass is used to convert the declared items into a struct format string, handling inheritance etc, and produce a class capable of dealing with it."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "_get_foo", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "_set_foo", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "here's", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/498149/"}]}]}], [{"text": ["Let's start with Tim Peter's classic quote:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Having said that, I have (periodically) run across true uses of metaclasses.", "The one that comes to mind is in Django where all of your models inherit from models.Model.", "models.Model, in turn, does some serious magic to wrap your DB models with Django's ORM goodness.", "That magic happens by way of metaclasses.", "It creates all manner of exception classes, manager classes, etc.", "etc."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["See django/db/models/base.py, class ModelBase() for the beginning of the story. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I was thinking the same thing just yesterday and completely agree.", "The complications in the code caused by attempts to make it more declarative generally make the codebase harder to maintain, harder to read and less pythonic in my opinion.", "It  also normally requires a lot of copy.copy()ing (to maintain inheritance and to copy from class to instance) and means you have to look in many places to see whats going on (always looking from metaclass up) which goes against the python grain also.", "I have been picking through formencode and sqlalchemy code to see if such a declarative style was worth it and its clearly not.", "Such style should be left to descriptors (such as property and methods) and immutable data.", "Ruby has better support for such declarative styles and I am glad the core python  language is not going down that route."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I can see their use for debugging, add a metaclass to all your base classes to get richer info.", "I also see their use only in (very) large projects to get rid of some boilerplate code (but at the loss of clarity).", "sqlalchemy for example does use them elsewhere, to add a particular custom method to all subclasses based on an attribute value in their class definition\ne.g a toy example"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "example", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.sqlalchemy.org/trac/browser/sqlalchemy/trunk/lib/sqlalchemy/sql/visitors.py"}]}, {"code": "<pre>\n<code>\n class test(baseclass_with_metaclass):\n    method_maker_value = \"hello\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["could have a metaclass that generated a method in that class with special properties based on \"hello\" (say a method that added \"hello\" to the end of a string).", "It could be good for maintainability to make sure you did not have to write a method in every subclass you make instead all you have to define is method_maker_value. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The need for this is so rare though and only cuts down on a bit of typing that its not really worth considering unless you have a large enough codebase."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Metaclasses can be handy for construction of Domain Specific Languages in Python.", "Concrete examples are Django, SQLObject 's declarative syntax of database schemata. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A basic example from A Conservative Metaclass by Ian Bicking:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "A Conservative Metaclass", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://blog.ianbicking.org/a-conservative-metaclass.html"}]}, {"code": "<pre>\n<code>\n class Registration(schema.Schema):\n    first_name = validators.String(notEmpty=True)\n    last_name = validators.String(notEmpty=True)\n    mi = validators.MaxLength(1)\n    class Numbers(foreach.ForEach):\n        class Number(schema.Schema):\n            type = validators.OneOf(['home', 'work'])\n            phone_number = validators.PhoneNumber()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Some other techniques: Ingredients for Building a DSL in Python (pdf). "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Ingredients for Building a DSL in Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://media.brianbeck.com/files/Python_DSLs_I.pdf"}]}, {"text": ["Edit (by Ali): An example of doing this using collections and instances is what I would prefer.", "The important fact is the instances, which give you more power, and eliminate reason to use metaclasses.", "Further worth noting that your example uses a mixture of classes and instances, which is surely an indication that you can't just do it all with metaclasses.", "And creates a truly non-uniform way of doing it."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n number_validator = [\n    v.OneOf('type', ['home', 'work']),\n    v.PhoneNumber('phone_number'),\n]\n\nvalidators = [\n    v.String('first_name', notEmpty=True),\n    v.String('last_name', notEmpty=True),\n    v.MaxLength('mi', 1),\n    v.ForEach([number_validator,])\n]\n</code>\n</pre>\n", "senID": 5}, {"text": ["It's not perfect, but already there is almost zero magic, no need for metaclasses, and improved uniformity."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["You never absolutely need to use a metaclass, since you can always construct a class that does what you want using inheritance or aggregation of the class you want to modify."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "need", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["That said, it can be very handy in Smalltalk and Ruby to be able to modify an existing class, but Python doesn't like to do that directly."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There's an excellent DeveloperWorks article on metaclassing in Python that might help.", "The Wikipedia article is also pretty good."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "DeveloperWorks article", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ibm.com/developerworks/linux/library/l-pymeta.html"}, {"text": "Wikipedia article", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Metaclass"}]}], [{"text": ["The only time I used metaclasses in Python was when writing a wrapper for the Flickr API. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["My goal was to scrape flickr's api site and dynamically generate a complete class hierarchy to allow API access using Python objects:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "flickr's api site", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.flickr.com/services/api/"}]}, {"code": "<pre>\n<code>\n # Both the photo type and the flickr.photos.search API method \n# are generated at \"run-time\"\nfor photo in flickr.photos.search(text=balloons):\n    print photo.description\n</code>\n</pre>\n", "senID": 2}, {"text": ["So in that example, because I generated the entire Python Flickr API from the website, I really don't know the class definitions at runtime.", "Being able to dynamically generate types was very useful.  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I have a class that handles non-interactive plotting, as a frontend to Matplotlib.", "However, on occasion one wants to do interactive plotting.", "With only a couple functions I found that I was able to increment the figure count, call draw manually, etc, but I needed to do these before and after every plotting call.", "So to create both an interactive plotting wrapper and an offscreen plotting wrapper, I found it was more efficient to do this via metaclasses, wrapping the appropriate methods, than to do something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class PlottingInteractive:\n    add_slice = wrap_pylab_newplot(add_slice)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This method doesn't keep up with API changes and so on, but one that iterates over the class attributes in __init__ before re-setting the class attributes is more efficient and keeps things up to date:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class _Interactify(type):\n    def __init__(cls, name, bases, d):\n        super(_Interactify, cls).__init__(name, bases, d)\n        for base in bases:\n            for attrname in dir(base):\n                if attrname in d: continue # If overridden, don't reset\n                attr = getattr(cls, attrname)\n                if type(attr) == types.MethodType:\n                    if attrname.startswith(\"add_\"):\n                        setattr(cls, attrname, wrap_pylab_newplot(attr))\n                    elif attrname.startswith(\"set_\"):\n                        setattr(cls, attrname, wrap_pylab_show(attr))\n</code>\n</pre>\n", "senID": 3}, {"text": ["Of course, there might be better ways to do this, but I've found this to be effective.", "Of course, this could also be done in __new__ or __init__, but this was the solution I found the most straightforward."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "__new__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Metaclasses aren't replacing programming!", "They're just a trick which can automate or make more elegant some tasks.", "A good example of this is Pygments syntax highlighting library.", "It has a class called RegexLexer which lets the user define a set of lexing rules as regular expressions on a class.", "A metaclass is used to turn the definitions into a useful parser."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Pygments", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://pygments.org/"}, {"text": "RegexLexer", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["They're like salt; it's easy to use too much."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The way I used metaclasses was to provide some attributes to classes.", "Take for example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class NameClass(type):\n    def __init__(cls, *args, **kwargs):\n       type.__init__(cls, *args, **kwargs)\n       cls.name = cls.__name__\n</code>\n</pre>\n", "senID": 1}, {"text": ["will put the name attribute on every class that will have the metaclass set to point to NameClass."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "name", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["The only legitimate use-case of a metaclass is to keep other nosy developers from touching your code.", "Once a nosy developer masters metaclasses and starts poking around with yours, throw in another level or two to keep them out.", "If that doesn't work, start using type.new or perhaps some scheme using a recursive metaclass."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "new", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["(written tongue in cheek, but I've seen this kind of obfuscation done.", "Django is a perfect example)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["A reasonable pattern of metaclass use is doing something once when a class is defined rather than repeatedly whenever the same class is instantiated. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When multiple classes share the same special behaviour, repeating __metaclass__=X is obviously better than repeating the special purpose code and/or introducing ad-hoc shared superclasses."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__metaclass__=X", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["But even with only one special class and no foreseeable extension,  __new__ and __init__ of a metaclass are a cleaner way to initialize class variables or other global data than intermixing special-purpose code and normal def and class statements in the class definition body."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "__new__", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "strong", "childList": []}, {"text": "def", "childNum": 0, "tag": "strong", "childList": []}, {"text": "class", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["This is a minor use, but... one  thing I've found metaclasses useful for is to invoke a function whenever a subclass is created.", "I codified this into a metaclass which looks for an __initsubclass__ attribute: whenever a subclass is created, all parent classes which define that method are invoked with __initsubclass__(cls, subcls).", "This allows creation of a parent class which then registers all subclasses with some global registry, runs invariant checks on subclasses whenever they are defined, perform late-binding operations, etc... all without have to manually call functions or to create custom metaclasses that perform each of these separate duties. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__initsubclass__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__initsubclass__(cls, subcls)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "or", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Mind you, I've slowly come to realize the implicit magicalness of this behavior is somewhat undesirable, since it's unexpected if looking at a class definition out of context... and so I've moved away from using that solution for anything serious besides initializing a __super attribute for each class and instance. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__super", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]