[[{"text": ["Linearize the voxel coordinates, and put them into two scipy.sparse.sparse.csc matrices.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Let v be the number of voxels, m the number of masks, and t the number of tracks.", "Let M be the mask csc matrix, size (m x v), where a 1 at (i,j) means mask i overlaps voxel j.", "Let T be the track csc matrix, size (t x v), where a 1 at (k,j) means track k overlaps voxel j.  "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n Overlap = (M * T.transpose() &gt; 0)  # track T overlaps mask M  \nConnected = (Overlap * Overlap.tranpose() &gt; 0) # Connected masks\nDensity[mask_idx] = numpy.take(T, nonzero(Overlap[mask_idx, :])[0], axis=0).sum(axis=0)\n</code>\n</pre>\n", "senID": 2}, {"text": ["I might be wrong on the last one, and I'm not sure css_matrices can be operated on by nonzero &amp; take.", "You might need to pull out each column in a loop and convert it to a full matrix."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "hr", "senID": 4}, {"text": ["I ran some experiments trying to simulate what I thought was a reasonable amount of data.", "The code below takes about 2 minutes on a 2-year old MacBook.", "If you use csr_matrices, it takes about 4 minutes.", "There is probably a tradeoff depending on how long each track is.  "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from numpy import *\nfrom scipy.sparse import csc_matrix\n\nnvox = 1000000\nntracks = 300000\nnmask = 100\n\n# create about 100 entries per track\ntcoords = random.uniform(0, ntracks, ntracks * 100).astype(int)\nvcoords = random.uniform(0, nvox, ntracks * 100).astype(int)\nd = ones(ntracks * 100)\nT = csc_matrix((d,  vstack((tcoords, vcoords))), shape=(ntracks, nvox), dtype=bool)\n\n# create around 10000 entries per mask\nmcoords = random.uniform(0, nmask, nmask * 10000).astype(int)\nvcoords = random.uniform(0, nvox, nmask * 10000).astype(int)\nd = ones(nmask * 10000)\nM = csc_matrix((d, vstack((mcoords, vcoords))), shape=(nmask, nvox), dtype=bool)\n\nOverlap = (M * T.transpose()).astype(bool) # mask M overlaps track T\nConnected = (Overlap * Overlap.transpose()).astype(bool) # mask M1 and M2 are connected\nDensity = Overlap * T.astype(float) # number of tracks overlapping mask M summed across voxels\n</code>\n</pre>\n", "senID": 6}], [{"text": ["OK, I think I finally have something that will reduce the complexity.", "This code should really fly compared to what you've got."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It seems like first you need to know which tracks coincide with which masks, the incidence matrix."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "incidence matrix", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Incidence%5Fmatrix"}]}, {"code": "<pre>\n<code>\n import numpy\nfrom collections import defaultdict\n\ndef by_point(sets):\n    d = defaultdict(list)\n    for i, s in enumerate(sets):\n        for pt in s:\n            d[pt].append(i)\n    return d\n\ndef calc(xdim, ydim, zdim, mask_coords_list, tracks):\n    masks_by_point = by_point(mask_coords_list)\n    tracks_by_point = by_point(tracks)\n\n    a = numpy.zeros((len(mask_coords_list), len(tracks)), dtype=int)\n    for pt, maskids in masks_by_point.iteritems():\n        for trackid in tracks_by_point.get(pt, ()):\n            a[maskids, trackid] = 1\n    m = numpy.matrix(a)\n</code>\n</pre>\n", "senID": 2}, {"text": ["The adjacency matrix you're looking for is m * m.T."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "adjacency matrix", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Adjacency%5Fmatrix"}, {"text": "m * m.T", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The code you have so far computes the upper triangle only.", "You can use triu to grab just that half."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "triu", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n am = m * m.T  # calculate adjacency matrix\n    am = numpy.triu(am, 1)  # keep only upper triangle\n    am = am.A  # convert matrix back to array\n</code>\n</pre>\n", "senID": 5}, {"text": ["The voxel calculation can use the incidence matrix too."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n vox_tracks_img = numpy.zeros((xdim, ydim, zdim, len(mask_coords_list)), dtype=int)\n    for trackid, track in enumerate(tracks):\n        for x, y, z in track:\n            vox_tracks_img[x, y, z, :] += a[:,trackid]\n    return am, vox_tracks_img\n</code>\n</pre>\n", "senID": 7}, {"text": ["For me this runs in under a second for data sets having hundreds of masks and tracks."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["If you have many points that appear in masks but are not on any tracks, it might be worthwhile to delete the entries for those points from masks_by_point before entering the loop."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "masks_by_point", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can probably start by combining the two functions to create both results at once.", "Also there's no need to make a list of the combinations before looping, as it is already a generator, and that might save you some time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def mask_connectivity_matrix_and_tracks(tracks,masks,masks_coords_list):\n    connect_mat=zeros((len(masks),len(masks)))\n    vox_tracks_img=zeros((xdim,ydim,zdim,len(masks)))\n    for track in tracks:\n        cur=[]\n        for count,mask_coords in enumerate(masks_coords_list):\n            if any(set(track) &amp; set(mask_coords)):\n                cur.append(count)\n                for x,y,z in track:\n                    vox_tracks_img[x,y,z,count] += 1\n            for x,y in itertools.combinations(cur,2):\n                connect_mat[x,y] += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also, this will probably never be \"fast\" as in \"finished before we die\", so the best way is to eventually compile it with Cython as a c module for python."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you stored the each mask set of points:\n(1,2,3), (1,2,4), (1,3,1) as a dictionary like this: {1: [{2: set([3, 4])}, {3: set([1])}]}, you might end up being able to check for matches faster...but maybe not.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "{1: [{2: set([3, 4])}, {3: set([1])}]}", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["A minor optimization (same big-O, sligthly smaller multiplier) can be had by removing redundant operations:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Won't make a dramatic difference, but might minutely help."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Lame to suggest yet another incremental improvement that might be made, I know, but:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Sets of small integers can be modeled as bit-vectors using Python's long ints.", "Suppose you replace each tuple with a small integer id, then convert each track and each set of mask-coords into a set of those small ids.", "You could represent those sets as long ints, making the intersection operation a bit faster (but not asymptotically faster)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]