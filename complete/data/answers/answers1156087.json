[[{"text": ["Nothing against RichieHindle's and Anon's answers, but here's how I'd write it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n data = [['a','b'], ['a','c'], ['b','d']]\nsearch = 'c'\nany(e[1] == search for e in data)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Like RichieHindle said, there is a hidden loop in the implementation of any (although I think it breaks out of the loop as soon as it finds a match)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "any", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; the_list =[ ['a','b'], ['a','c'], ['b''d'] ]\n&gt;&gt;&gt; any('c' == x[1] for x in the_list)\nTrue\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; my_list =[ ['a', 'b'], ['a', 'c'], ['b', 'd'] ]\n&gt;&gt;&gt; 'd' in (x[1] for x in my_list)\nTrue\n</code>\n</pre>\n", "senID": 0}, {"text": ["Editing to add:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Both David's answer using any and mine using in will end when they find a match since we're using generator expressions.", "Here is a test using an infinite generator to show that:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "any", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "in", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def mygen():\n    ''' Infinite generator '''\n    while True:\n        yield 'xxx'  # Just to include a non-match in the generator\n        yield 'd'\n\nprint 'd' in (x for x in mygen())     # True\nprint any('d' == x for x in mygen())  # True\n# print 'q' in (x for x in mygen())     # Never ends if uncommented\n# print any('q' == x for x in mygen())  # Never ends if uncommented\n</code>\n</pre>\n", "senID": 3}, {"text": ["I just like simply using in instead of both == and any."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "in", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "==", "childNum": 0, "tag": "strong", "childList": []}, {"text": "any", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["You're always going to have a loop - someone might come along with a clever one-liner that hides the loop within a call to map() or similar, but it's always going to be there."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "map()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["My preference would always be to have clean and simple code, unless performance is a major factor."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here's perhaps a more Pythonic version of your code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n data = [['a','b'], ['a','c'], ['b','d']]\nsearch = 'c'\nfor sublist in data:\n    if sublist[1] == search:\n        print \"Found it!\", sublist\n        break\n# Prints: Found it! ['a', 'c']\n</code>\n</pre>\n", "senID": 3}, {"text": ["It breaks out of the loop as soon as it finds a match."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["(You have a typo, by the way, in ['b''d']."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "['b''d']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["the above all look good"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["but do you want to keep the result?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["if so..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["you can use the following"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n result = [element for element in data if element[1] == search]\n</code>\n</pre>\n", "senID": 4}, {"text": ["then a simple"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n len(result)\n</code>\n</pre>\n", "senID": 6}, {"text": ["lets you know if anything was found (and now you can do stuff with the results)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["of course this does not handle elements which are length less than one\n(which you should be checking unless you know they always are greater than\nlength 1, and in that case should you be using a tuple?", "(tuples are immutable))"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "of course", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["if you know all items are a set length you can also do:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n any(second == search for _, second in data)\n</code>\n</pre>\n", "senID": 10}, {"text": ["or for len(data[0]) == 4:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n any(second == search for _, second, _, _ in data)\n</code>\n</pre>\n", "senID": 12}, {"text": ["...and I would recommend using"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n for element in data:\n   ...\n</code>\n</pre>\n", "senID": 14}, {"text": ["instead of"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n for i in range(len(data)):\n   ...\n</code>\n</pre>\n", "senID": 16}, {"text": ["(for future uses, unless you want to save or use 'i', and just so you know\nthe '0' is not required, you only need use the full syntax if you are starting\nat a non zero value)"], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "unless you want to save or use 'i'", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; the_list =[ ['a','b'], ['a','c'], ['b','d'] ]\n&gt;&gt;&gt; \"b\" in zip(*the_list)[1]\nTrue\n</code>\n</pre>\n", "senID": 0}, {"text": ["zip() takes a bunch of lists and groups elements together by index, effectively transposing the list-of-lists matrix.", "The asterisk takes the contents of the_list and sends it to zip as arguments, so you're effectively passing the three lists separately, which is what zip wants.", "All that remains is to check if \"b\" (or whatever) is in the list made up of elements with the index you're interested in."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "zip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "the_list", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "zip", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "zip", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\"b\"", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["Markus has one way to avoid using the word for -- here's another, which should have much better performance for long the_lists...:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "the_list", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\nfound = any(itertools.ifilter(lambda x:x[1]=='b', the_list)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Nothing wrong with using a gen exp, but if the goal is to inline the loop..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import itertools, operator\n&gt;&gt;&gt; 'b' in itertools.imap(operator.itemgetter(1), the_list)\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["Should be the fastest as well."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]