[[{"text": ["Just my 2 cents."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Case tools like Enterprise Architect can generate class diagrams from python code, however for the purpose of understanding I prefer to coarsely model the classes and relationships by hand."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Case tools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Computer-aided_software_engineering"}, {"href": "http://www.sparxsystems.com/products/ea/index.html", "text": "Enterprise Architect", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["I too use UML when I want to understand new code, to get a coarse overview of the collaborations between classes, and to get a view of inheritance heirachies.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Most IDEs have means to explore the code, but I find small cohesive UML diagrams easier to digest and memorize."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I also find domain models easier to understand when on a class diagram."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If you are seeking IDEs that have that feature, then:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["gaphor has a feature to import python module and generate uml class diagrams, anyway it's not so good."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "gaphor", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://gaphor.sourceforge.net"}]}, {"text": ["Anyway, code analysis tools on python don't work very well since no one can \"predict\" which arguments will be passed (or returned) by functions and so on.", "Most of them \"guess\" the type passed."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Hoping that python 3 with the \"function annotation\" can solve this sort of \"problem\""], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Great question!", "Depending on how hands-on you are, you can consider using the trace module on a run of your code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n python -m trace -T yourprogram.py\n</code>\n</pre>\n", "senID": 1}, {"text": ["Will give you who-called-who information.", "You can either parse this, or write some code that uses trace programatically to extract your call graph."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Once that's done, a bit of dot hacking, and you've got a diagram.", "Once you've done this, it'd make a cool blog post about what you did and how it worked out."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "dot", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/DOT_language"}]}], [{"text": ["Check out epydoc.", "It's generally thought of as a documentation generator, but check out the (automatically generated) graph in this example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "epydoc", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://epydoc.sourceforge.net/"}]}, {"text": ["http://epydoc.sourceforge.net/api/epydoc.apidoc.RoutineDoc-class.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://epydoc.sourceforge.net/api/epydoc.apidoc.RoutineDoc-class.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://epydoc.sourceforge.net/api/epydoc.apidoc.RoutineDoc-class.html"}]}], [{"text": ["If it's Django you can also do "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ./manage.py graph_models\n</code>\n</pre>\n", "senID": 1}, {"text": ["if you are using Django Command Extenstions"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]