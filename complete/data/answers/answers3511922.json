[[{"text": ["Apologies for the format of the answer which evolved with the question.", "The short answer is OCaml.", "I will rewrite this answer to have a better order if any other addition is needed."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "OCaml", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["Edit 3: With a platform Linux/x86, a computationally intensive operation would be similar to the work done in High Performance Computing, for example machine learning.", "Here is a discussion about programming languages for machine learning.", "OCaml is highly regarded there."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Edit 3", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "Here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://hunch.net/?p=230"}]}, {"text": ["The more important thing would be to utilise optimised versions of libraries such as Blas/Lapack, or to write in a good programming language and profile then rewrite the critical parts as C. I have done this with Python/Numpy with critical sections written in Cython or even pure C. It is also doable with OCaml/C.", "Interestingly, most of the HPC tends to lean towards C rather than C++, with some work also in Fortran."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I would add that OCaml has a much more optimising compiler than Go at the moment, as the Go compiler is still in flux: the common compiler 6g is not much optimised, and the more efficient gccgo is lagging in development and much less tested."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Edit 2: Given that your question cites C++ and static/strong typing and no VM, I would say your main options are: OCaml and Go, with D being a not fully open source language that is both community friendly and has large portions open.", "I still advocate OCaml as your best option."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "Edit 2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "OCaml", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://caml.inria.fr/ocaml/"}, {"href": "http://golang.org/", "text": "Go", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://www.digitalmars.com/d/", "text": "D", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["OCaml has a longer history than Go and a bigger community.", "The language is also more stable than Go which is still at the startup phase.", "Still, Go might be better if the syntax being C-like is more important to you."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Original Answer:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Original Answer", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This may or may not fit your requirements, but I would say OCaml or F#.", "They are very similar, but F# is a Microsoft language hosted on .Net originally based on OCaml."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "OCaml", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "F#", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["OCaml/F# is strongly typed, with type inference.", "So you can omit explicit type definitions that can be inferred, or you may have them explicit.", "They also don't have GIL."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["The reason that they may fall short is if you reject insufficiently C like (joke) languages are not modern syntax.", "Also, F# may not make you happy if you don't want to depend on a virtual machine, though this is more than compensated by the availability of libraries compared to OCaml."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "insufficiently C like (joke)", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html"}]}, {"text": ["Edit: The edited question excludes .Net and similar environments hence F# is no longer viable.", "My answer still stands regarding OCaml, though people coming from a Python background will feel the lack of a nice and complete library."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Boo"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Boo", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "Boo", "tag": "a"}]}, {"href": "http://en.wikipedia.org/wiki/Boo_%28programming_language%29", "text": "Boo", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["cython"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "cython", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "cython", "tag": "a"}]}, {"href": "http://www.cython.org", "text": "cython", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I think GO would fit your requirements."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "GO", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://golang.org/doc/go_spec.html#Introduction"}]}, {"text": ["This is my personal feeling but go code looks very similar to python code."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "go", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["It still has classic compile approach but google will develop some interpreter certainly."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["From google site:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Anything in the ML family might work for you.", "Ocaml is a great place to start, but it does have a stop-the-world GC last I looked.", "Haskell is famous as a lab for innovative concurrency models.", "Python's comprehensions came from Haskell, where they'rr a convenient syntax for some very fundamental ideas.", "And Erlang is strongly dynamcally typed, fun to write in, and does concurrency better than anybody else. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["After reading your updated spec:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What exactly does \"computing extensive\" mean?", "What problem domain?", "What do others who work in this problem domain use?", "If you are serious with this specification, you can't do much other things than using C++ in connection with well-tested libraries for multithreading and numerical computing."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "serious with this specification", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}, {"text": ["my $0.02"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["rbo"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Ada is a strongly-typed, compiled language with a modern, easy-to-read syntax and proven reliability for multicore computing.", "Ada was designed for use in large, critical, real-time systems where software MUST work at all costs.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Ada", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Ada_%28programming_language%29"}]}, {"text": ["\"Ada supports run-time checks to protect against access to unallocated memory, buffer overflow errors, off-by-one errors, array access errors, and other detectable bugs.", "These checks can be disabled in the interest of runtime efficiency, but can often be compiled efficiently.", "It also includes facilities to help program verification.", "For these reasons, Ada is widely used in critical systems, where any anomaly might lead to very serious consequences, i.e., accidental death or injury.", "Examples of systems where Ada is used include avionics, weapon systems (including thermonuclear weapons), and spacecraft.", "\"  (quote from Wikipedia article linked above)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Ada is freely available as part of GCC / GNAT and should be an easy \"apt-get install\" on Debian.", "You can also find up-to-date compilers and libraries (both community-supported GPL-licensed and commercially-supported packages) at http://libre.adacore.com/libre/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://libre.adacore.com/libre/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://libre.adacore.com/libre/"}]}, {"text": ["Ada can compile to Java bytecode for use in a JVM or compile to binary for bare-metal or embedded use."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]