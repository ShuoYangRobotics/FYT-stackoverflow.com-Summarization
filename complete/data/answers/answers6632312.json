[[{"text": ["Use a collections.deque.", "Push N items from the source on the first invocation.", "On each subsequent invocation, pop an item out, push an item in from the source, and yield the popped item."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "collections.deque", "tag": "a", "pos": 0, "childList": [{"text": "collections.deque", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/dev/library/collections.html#collections.deque"}, {"text": "collections.deque", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Just for the fun of it, here's a variation on Ignacio's solution that doesn't require a deque."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def truncate(it, n):\n...     cache = [next(it) for i in range(n)]\n...     index = 0\n...     for val in it:\n...         val, cache[index] = cache[index], val\n...         index = (index + 1) % n\n...         yield val\n</code>\n</pre>\n", "senID": 1}, {"text": ["I wasn't especially concerned with speed when I wrote the above... but perhaps this would be a tad faster:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def truncate(it, n):\n    cache = [next(it) for i in range(n)]\n    index = 0\n    for val in it:\n        yield cache[index]\n        cache[index] = val\n        index = (index + 1) % n\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Based on Ignacio Vazquez-Abrams's description:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import deque\n\ndef all_but_the_last_n(iterable, count):\n    q = deque()\n    i = iter(iterable)\n    for n in range(count):\n        q.append(i.next())\n    for item in i:\n        q.append(item)\n        yield q.popleft()\n</code>\n</pre>\n", "senID": 1}, {"text": ["I wondered whether it was better to use the deque right to left (append, popleft) or left to right  (appendleft, pop).", "So i timed it with python 2.5.2 and found that rtl was 3.59 usec while ltr was 3.53 usec.", "The difference of 0.06 usec is not significant.", "the test was to append a single item and pop a single item."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "3.59 usec", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "3.53 usec", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "0.06 usec", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"code": "<pre>\n<code>\n l = [0, 3, 5, 5, 2]\nlast = l[0:-2] # Where 2 is N-1 (I think -1, you might want to check that\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Using Ignacio's solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import collections\ndef all_but_the_last_n(iterable, n):\n    it = iter(iterable)\n    fifo = collections.deque()\n    for _, i in zip(range(n), it):\n        fifo.append(i)\n    for i in it:\n        fifo.append(i)\n        yield fifo.popleft()\n\nprint(list(all_but_the_last_n(range(10), 3)))\nprint(list(all_but_the_last_n('abcdefghijkl', 3)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["It is unfortunate that collections does not have a circular buffer.", "This would be more efficient from a cache miss standpoint with one."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "collections", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["elements[:-N]"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "elements[:-N]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["or list(elements)[:-N]"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "list(elements)[:-N]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["{Edit}"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["And iterator based solution:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from itertools import islice\nelements = xrange(10)\nN = 2\ncrop = islice(elements, len(elements)-N)\n</code>\n</pre>\n", "senID": 4}, {"text": ["if elements is an iterator, you may not have len..."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "len", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]