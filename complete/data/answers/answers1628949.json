[[{"text": ["using a regexp :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n\nimport re, sys\n\n\ndef isPrime(n):\n    # see http://www.noulakaz.net/weblog/2007/03/18/a-regular-expression-to-check-for-prime-numbers/\n    return re.match(r'^1?$|^(11+?)\\1+$', '1' * n) == None\n\n\nN = int(sys.argv[1]) # number of primes wanted (from command-line)\nM = 100              # upper-bound of search space\nl = list()           # result list\n\nwhile len(l) &lt; N:\n    l += filter(isPrime, range(M - 100, M)) # append prime element of [M - 100, M] to l\n    M += 100                                # increment upper-bound\n\nprint l[:N] # print result list limited to N elements\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The line k = k-1 does not do what you think.", "It has no effect.", "Changing k does not affect the loop.", "At each iteration, k is assigned to the next element of the range, so any changes you have made to k inside the loop will be overwritten."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "k = k-1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "k", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "k", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "k", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["For reference, there's a pretty significant speed difference between the various stated solutions.", "Here is some comparison code.", "The solution pointed to by Lennart is called \"historic\", the one proposed by Ants is called \"naive\", and the one by RC is called \"regexp."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from sys import argv\nfrom time import time\n\ndef prime(i, primes):\n    for prime in primes:\n        if not (i == prime or i % prime):\n            return False\n    primes.add(i)\n    return i\n\ndef historic(n):\n    primes = set([2])\n    i, p = 2, 0\n    while True:\n        if prime(i, primes):\n            p += 1\n            if p == n:\n                return primes\n        i += 1\n\ndef naive(n):\n    from itertools import count, islice\n    primes = (n for n in count(2) if all(n % d for d in range(2, n)))\n    return islice(primes, 0, n)\n\ndef isPrime(n):\n    import re\n    # see http://tinyurl.com/3dbhjv\n    return re.match(r'^1?$|^(11+?)\\1+$', '1' * n) == None\n\ndef regexp(n):\n    import sys\n    N = int(sys.argv[1]) # number of primes wanted (from command-line)\n    M = 100              # upper-bound of search space\n    l = list()           # result list\n\n    while len(l) &lt; N:\n        l += filter(isPrime, range(M - 100, M)) # append prime element of [M - 100, M] to l\n        M += 100                                # increment upper-bound\n\n    return l[:N] # print result list limited to N elements\n\ndef dotime(func, n):\n    print func.__name__\n    start = time()\n    print sorted(list(func(n)))\n    print 'Time in seconds: ' + str(time() - start)\n\nif __name__ == \"__main__\":\n    for func in naive, historic, regexp:\n        dotime(func, int(argv[1]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["The output of this on my machine for n = 100 is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n naive\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541]\nTime in seconds: 0.0219371318817\nhistoric\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541]\nTime in seconds: 0.00515413284302\nregexp\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541]\nTime in seconds: 0.0733318328857\n</code>\n</pre>\n", "senID": 3}, {"text": ["As you can see, there's a pretty big discrepancy.", "Here it is again for 1000 (prime outputs removed):"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n naive\nTime in seconds: 1.49018788338\nhistoric\nTime in seconds: 0.148319005966\nregexp\nTime in seconds: 29.2350409031\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Super quick sieve implementation - takes 0.146s for the first 1000 primes on my PC:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def gen_primes():\n    \"\"\" Generate an infinite sequence of prime numbers.\n    \"\"\"\n    # Maps composites to primes witnessing their compositeness.\n    # This is memory efficient, as the sieve is not \"run forward\"\n    # indefinitely, but only as long as required by the current\n    # number being tested.\n    #\n    D = {}  \n\n    # The running integer that's checked for primeness\n    q = 2  \n\n    while True:\n        if q not in D:\n            # q is a new prime.\n            # Yield it and mark its first multiple that isn't\n            # already marked in previous iterations\n            # \n            yield q        \n            D[q * q] = [q]\n        else:\n            # q is composite. D[q] is the list of primes that\n            # divide it. Since we've reached q, we no longer\n            # need it in the map, but we'll mark the next \n            # multiples of its witnesses to prepare for larger\n            # numbers\n            # \n            for p in D[q]:\n                D.setdefault(p + q, []).append(p)\n            del D[q]\n\n        q += 1\n\nprimes = gen_primes()\n\n\nx = set()\ny = 0\na = gen_primes()\nwhile y &lt; 10000:\n  x |= set([a.next()])\n  y+=1\n\nreturn sorted(x)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["What you need is a Prime Sieve (a fast type of algorithm for finding primes), a very simple one is Sieve of Eratosthenes (check wikipedia) and here is an implementation in PHP http://www.scriptol.com/programming/sieve.php"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.scriptol.com/programming/sieve.php", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.scriptol.com/programming/sieve.php"}]}], [{"text": ["What you want is something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n x = int(input(\"Enter the number:\"))\ncount = 0\nnum = 2\nwhile count &lt; x:\n     if isnumprime(x):\n        print x\n        count = count + 1\n     num = num + 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'll leave it up to you to implement \"isnumprime()\".", ";)\nHint: You only need to test division with all previously found primenumbers."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Using generator expressions to create a sequence of all primes and slice the 100th out of that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import count, islice\nprimes = (n for n in count(2) if all(n % d for d in range(2, n)))\nprint(\"100th prime is %d\" % next(islice(primes, 99, 100)))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This code is very confused, and I can't figure out exactly what you were thinking when you wrote it or what you were attempting to accomplish.", "The first thing I would suggest when trying to figure out how to code is to start by making your variable names extremely descriptive.", "This will help you get the ideas of what you're doing straight in your head, and it will also help anyone who's trying to help you show you how to get your ideas straight."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That being said, here is a sample program that accomplishes something close to the goal:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n primewanted = int(input(\"This program will give you the nth prime.\\nPlease enter n:\"))\nif primewanted &lt;= 0:\n    print \"n must be &gt;= 1\"\nelse:\n    lastprime = 2 # 2 is the very first prime number\n    primesfound = 1  # Since 2 is the very first prime, we've found 1 prime\n    possibleprime = lastprime + 1 # Start search for new primes right after\n    while primesfound &lt; primewanted:\n        # Start at 2.  Things divisible by 1 might still be prime\n        testdivisor = 2\n        # Something is still possibly prime if it divided with a remainder.\n        still_possibly_prime = ((possibleprime % testdivisor) != 0)\n        # (testdivisor + 1) because we never want to divide a number by itself.\n        while still_possibly_prime and ((testdivisor + 1) &lt; possibleprime):\n            testdivisor = testdivisor + 1\n            still_possibly_prime = ((possibleprime % testdivisor) != 0)\n        # If after all that looping the prime is still possibly prime,\n        # then it is prime.\n        if still_possibly_prime:\n            lastprime = possibleprime\n            primesfound = primesfound + 1\n        # Go on ahead to see if the next number is prime\n        possibleprime = possibleprime + 1\n    print \"This nth prime is:\", lastprime\n</code>\n</pre>\n", "senID": 2}, {"text": ["This bit of code:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n testdivisor = 2\n        # Something is still possibly prime if it divided with a remainder.\n        still_possibly_prime = ((possibleprime % testdivisor) != 0)\n        # (testdivisor + 1) because we never want to divide a number by itself.\n        while still_possibly_prime and ((testdivisor + 1) &lt; possibleprime):\n            testdivisor = testdivisor + 1\n            still_possibly_prime = ((possibleprime % testdivisor) != 0)\n</code>\n</pre>\n", "senID": 4}, {"text": ["could possibly be replaced by the somewhat slow, but possibly more understandable:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n # Assume the number is prime until we prove otherwise\n        still_possibly_prime = True\n        # Start at 2.  Things divisible by 1 might still be prime\n        for testdivisor in xrange(2, possibleprime, 1):\n            # Something is still possibly prime if it divided with a\n            # remainder.  And if it is ever found to be not prime, it's not\n            # prime, so never check again.\n            if still_possibly_prime:\n                still_possibly_prime = ((possibleprime % testdivisor) != 0)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Until we have N primes, take natural numbers one by one, check whether any of the so-far-collected-primes divide it. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If none does, \"yay\", we have a new prime... "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["that's it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def generate_n_primes(N):\n...     primes  = []\n...     chkthis = 2\n...     while len(primes) &lt; N:\n...         ptest    = [chkthis for i in primes if chkthis%i == 0]\n...         primes  += [] if ptest else [chkthis]\n...         chkthis += 1\n...     return primes\n...\n&gt;&gt;&gt; print generate_n_primes(15)\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\n</code>\n</pre>\n", "senID": 3}]]