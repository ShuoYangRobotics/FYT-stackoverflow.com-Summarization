[[{"text": ["What about using logging.disable?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "logging.disable", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/logging.html?highlight=logging#logging.disable"}]}, {"text": ["I've also found I had to use logging.isEnabledFor if the logging message is expensive to create."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "logging.isEnabledFor", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/logging.html?highlight=logging#logging.Logger.isEnabledFor"}]}], [{"text": ["As an imperfect shortcut, how about mocking out logging in specific modules using something like MiniMock?"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "logging", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://pypi.python.org/pypi/MiniMock/", "text": "MiniMock", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["For example, if my_module.py was:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "my_module.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import logging\nclass C(object):\n    def __init__(self, *args, **kw):\n        logging.info(\"Instantiating\")\n</code>\n</pre>\n", "senID": 2}, {"text": ["You would replace your use of my_module with:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "my_module", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from minimock import Mock\nimport my_module\nmy_module.logging = Mock('logging')\nc = my_module.C()\n</code>\n</pre>\n", "senID": 4}, {"text": ["You'd only have to do this once, before the initial import of the module."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Getting the level specific behaviour would be simple enough by mocking specific methods, or having logging.getLogger return a mock object with some methods impotent and others  delegating to the real logging module."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "logging.getLogger", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "logging", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In practice, you'd probably want to replace MiniMock with something simpler and faster; at the very least something which doesn't print usage to stdout!", "Of course, this doesn't handle the problem of module A importing logging from module B (and hence A also importing the log granularity of B)..."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "logging", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This will never be as fast as not running the log statements at all, but should be much faster than going all the way into the depths of the logging module only to discover this record shouldn't be logged after all."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["You could try something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # Create something that accepts anything\nclass Fake(object):\n    def __getattr__(self, key):\n        return self\n    def __call__(self, *args, **kwargs):\n        return True\n\n# Replace the logging module\nimport sys\nsys.modules[\"logging\"] = Fake()\n</code>\n</pre>\n", "senID": 1}, {"text": ["It essentially replaces (or initially fills in) the space for the logging module with an instance of Fake which simply takes in anything.", "You must run the above code (just once!", ") before the logging module is attempted to be used anywhere.", "Here is a test:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Fake", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Here is a test:", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n import logging\n\nlogging.basicConfig(level=logging.DEBUG,\n                    format='%(asctime)s %(levelname)-8s %(message)s',\n                    datefmt='%a, %d %b %Y %H:%M:%S',\n                    filename='/temp/myapp.log',\n                    filemode='w')\nlogging.debug('A debug message')\nlogging.info('Some information')\nlogging.warning('A shot across the bows')\n</code>\n</pre>\n", "senID": 3}, {"text": ["With the above, nothing at all was logged, as was to be expected."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I'd use some fancy logging decorator, or a bunch of them:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def doLogging(logTreshold):\n    def logFunction(aFunc):\n        def innerFunc(*args, **kwargs):\n            if LOGLEVEL &gt;= logTreshold:\n                print \"&gt;&gt;Called %s at %s\"%(aFunc.__name__, time.strftime(\"%H:%M:%S\"))\n                print \"&gt;&gt;Parameters: \", args, kwargs if kwargs else \"\" \n            try:\n                return aFunc(*args, **kwargs)\n            finally:\n                print \"&gt;&gt;%s took %s\"%(aFunc.__name__, time.strftime(\"%H:%M:%S\"))\n        return innerFunc\n    return logFunction\n</code>\n</pre>\n", "senID": 1}, {"text": ["All you need is to declare LOGLEVEL constant in each module (or just globally and just import it in all modules) and then you can use it like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n @doLogging(2.5)\ndef myPreciousFunction(one, two, three=4):\n    print \"I'm doing some fancy computations :-)\"\n    return\n</code>\n</pre>\n", "senID": 3}, {"text": ["And if LOGLEVEL is no less than 2.5 you'll get output like this:  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;Called myPreciousFunction at 18:49:13\n&gt;&gt;Parameters:  (1, 2) \nI'm doing some fancy computations :-)\n&gt;&gt;myPreciousFunction took 18:49:13\n</code>\n</pre>\n", "senID": 5}, {"text": ["As you can see, some work is needed for better handling of kwargs, so the default values will be printed if they are present, but that's another question."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["You should probably use some logger module instead of raw print statements, but I wanted to focus on the decorator idea and avoid making code too long."], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "logger", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "logger", "tag": "code"}]}, {"text": "logger", "childNum": 0, "tag": "code", "childList": []}, {"text": "print", "childNum": 1, "tag": "strong", "childList": [{"text": "print", "tag": "code"}]}, {"text": "print", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Anyway - with such decorator you get function-level logging, arbitrarily many log levels, ease of application to new function, and to disable logging you only need to set LOGLEVEL.", "And you can define different output streams/files for each function if you wish.", "You can write doLogging as:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def doLogging(logThreshold, outStream=sys.stdout):\n      .....\n      print &gt;&gt;outStream, \"&gt;&gt;Called %s at %s\" etc.\n</code>\n</pre>\n", "senID": 9}, {"text": ["And utilize log files defined on a per-function basis."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["This is an issue in my project as well--logging ends up on profiler reports pretty consistently."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I've used the _ast module before in a fork of PyFlakes (http://github.com/kevinw/pyflakes) ... and it is definitely possible to do what you suggest in your question--to inspect and inject guards before calls to logging methods (with your acknowledged caveat that you'd have to do some runtime type checking).", "See http://pyside.blogspot.com/2008/03/ast-compilation-from-python.html for a simple example."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "http://github.com/kevinw/pyflakes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/kevinw/pyflakes"}, {"text": "http://pyside.blogspot.com/2008/03/ast-compilation-from-python.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pyside.blogspot.com/2008/03/ast-compilation-from-python.html"}]}, {"text": ["Edit: I just noticed MetaPython on my planetpython.org feed--the example use case is removing log statements at import time."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://blog.pythonisito.com/2009/03/announcing-metapython-macros-for-python.html", "text": "MetaPython", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Maybe the best solution would be for someone to reimplement logging as a C module, but I wouldn't be the first to jump at such an...opportunity :p"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I've also seen assert used in this fashion."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n assert logging.warn('disable me with the -O option') == None\n</code>\n</pre>\n", "senID": 1}, {"text": ["(I'm guessing that warn always returns none.. if not, you'll get an AssertionError"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["But really that's just a funny way of doing this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n if __debug__: logging.warn('disable me with the -O option')\n</code>\n</pre>\n", "senID": 4}, {"text": ["When you run a script with that line in it with the -O option, the line will be removed from the optimized .pyo code.", "If, instead, you had your own variable, like in the following, you will have a conditional that is always executed (no matter what value the variable is), although a conditional should execute quicker than a function call:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n my_debug = True\n...\nif my_debug: logging.warn('disable me by setting my_debug = False')\n</code>\n</pre>\n", "senID": 6}, {"text": ["so if my understanding of debug is correct, it seems like a nice way to get rid of unnecessary logging calls.", "The flipside is that it also disables all of your asserts, so it is a problem if you need the asserts."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "debug", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Use pypreprocessor"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pypreprocessor", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/pypreprocessor/"}]}, {"text": ["Which can also be found on PYPI (Python Package Index) and be fetched using pip."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "PYPI (Python Package Index)", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/pypreprocessor"}]}, {"text": ["Here's a basic usage example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from pypreprocessor import pypreprocessor\n\npypreprocessor.parse()\n\n#define nologging\n\n#ifdef nologging\n...logging code you'd usually comment out manually...\n#endif\n</code>\n</pre>\n", "senID": 3}, {"text": ["Essentially, the preprocessor comments out code the way you were doing it manually before.", "It just does it on the fly conditionally depending on what you define."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You can also remove all of the preprocessor directives and commented out code from the postprocessed code by adding 'pypreprocessor.removeMeta = True' between the import and \nparse() statements."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The bytecode output (.pyc) file will contain the optimized output."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["SideNote: pypreprocessor is compatible with python2x and python3k."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "SideNote: pypreprocessor is compatible with python2x and python3k.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Disclaimer: I'm the author of pypreprocessor."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Disclaimer: I'm the author of pypreprocessor.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["I like the 'if _debug' solution except that putting it in front of every call is a bit distracting and ugly.", "I had this same problem and overcame it by writing a script which automatically parses your source files and replaces logging statements with pass statements (and commented out copies of the logging statements).", "It can also undo this conversion."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "debug", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I use it when I deploy new code to a production environment when there are lots of logging statements which I don't need in a production setting and they are affecting performance."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can find the script here: http://dound.com/2010/02/python-logging-performance/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://dound.com/2010/02/python-logging-performance/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://dound.com/2010/02/python-logging-performance/"}]}], [{"text": [":-) We used to call that a preprocessor and although C's preprocessor had some of those capablities, the \"king of the hill\" was the preprocessor for IBM mainframe PL/I.", "It provided extensive language support in the preprocessor (full assignments, conditionals, looping, etc.", ") and it was possible to write \"programs that wrote programs\" using just the PL/I PP."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I wrote many applications with full-blown sophisticated program and data tracing (we didn't have a decent debugger for a back-end process at that time) for use in development and testing which then, when compiled with the appropriate \"runtime flag\" simply stripped all the tracing code out cleanly without any performance impact.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I think the decorator idea is a good one.", "You can write a decorator to wrap the functions that need logging.", "Then, for runtime distribution, the decorator is turned into a \"no-op\" which eliminates the debugging statements."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Jon R"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]