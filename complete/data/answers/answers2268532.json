[[{"code": "<pre>\n<code>\n import re\ns = \"\\t\\tthis line has two tabs of indention\"\nre.match(r\"\\s*\", s).group()\n// \"\\t\\t\"\ns = \"    this line has four spaces of indention\"\nre.match(r\"\\s*\", s).group()\n// \"    \"\n</code>\n</pre>\n", "senID": 0}, {"text": ["And to strip leading spaces, use lstrip."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "lstrip", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#str.lstrip"}]}, {"text": ["As there are down votes probably questioning the efficiency of regex, I've done some profiling to check the efficiency of each cases."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Very long string, very short leading space"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"text": ["RegEx > Itertools >> lstrip"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; timeit.timeit('r.match(s).group()', 'import re;r=re.compile(r\"\\s*\")s=\"          hello world!\"*10000', number=100000)\n0.10037684440612793\n&gt;&gt;&gt; timeit.timeit('\"\".join(itertools.takewhile(lambda x:x.isspace(),s))', 'import itertools;s=\"          hello world!\"*10000', number=100000)\n0.7092740535736084\n&gt;&gt;&gt; timeit.timeit('\"\".join(itertools.takewhile(str.isspace,s))', 'import itertools;s=\"          hello world!\"*10000', number=100000)\n0.51730513572692871\n&gt;&gt;&gt; timeit.timeit('s[:-len(s.lstrip())]', 's=\"          hello world!\"*10000', number=100000)\n2.6478431224822998\n</code>\n</pre>\n", "senID": 5}, {"text": ["Very short string, very short leading space"], "childNum": 0, "tag": "h2", "senID": 6, "childList": []}, {"text": ["lstrip > RegEx > Itertools"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["If you can limit the string's length to thousounds of chars or less, the lstrip trick maybe better."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; timeit.timeit('r.match(s).group()', 'import re;r=re.compile(r\"\\s*\");s=\"          hello world!\"*100', number=100000)\n0.099548101425170898\n&gt;&gt;&gt; timeit.timeit('\"\".join(itertools.takewhile(str.isspace,s))', 'import itertools;s=\"          hello world!\"*100', number=100000)\n0.53602385520935059\n&gt;&gt;&gt; timeit.timeit('s[:-len(s.lstrip())]', 's=\"          hello world!\"*100', number=100000)\n0.064291000366210938\n</code>\n</pre>\n", "senID": 9}, {"text": ["This shows the lstrip trick scales roughly as O(\u221an) and the RegEx and itertool methods are O(1) if the number of leading spaces is not a lot."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Very short string, very long leading space"], "childNum": 0, "tag": "h2", "senID": 11, "childList": []}, {"text": ["lstrip >> RegEx >>> Itertools"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["If there are a lot of leading spaces, don't use RegEx."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; timeit.timeit('s[:-len(s.lstrip())]', 's=\" \"*2000', number=10000)\n0.047424077987670898\n&gt;&gt;&gt; timeit.timeit('r.match(s).group()', 'import re;r=re.compile(r\"\\s*\");s=\" \"*2000', number=10000)\n0.2433168888092041\n&gt;&gt;&gt; timeit.timeit('\"\".join(itertools.takewhile(str.isspace,s))', 'import itertools;s=\" \"*2000', number=10000)\n3.9949162006378174\n</code>\n</pre>\n", "senID": 14}, {"text": ["Very long string, very long leading space"], "childNum": 0, "tag": "h2", "senID": 15, "childList": []}, {"text": ["lstrip >>> RegEx >>>>>>>> Itertools"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; timeit.timeit('s[:-len(s.lstrip())]', 's=\" \"*200000', number=10000)\n4.2374031543731689\n&gt;&gt;&gt; timeit.timeit('r.match(s).group()', 'import re;r=re.compile(r\"\\s*\");s=\" \"*200000', number=10000)\n23.877214908599854\n&gt;&gt;&gt; timeit.timeit('\"\".join(itertools.takewhile(str.isspace,s))', 'import itertools;s=\" \"*200000', number=100)*100\n415.72158336639404\n</code>\n</pre>\n", "senID": 17}, {"text": ["This shows all methods scales roughly as O(m) if the non-space part is not a lot."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}], [{"text": ["A sneaky way: abuse lstrip!"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "lstrip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n fullstr = \"\\t\\tthis line has two tabs of indentation\"\nstartwhites = fullstr[:len(fullstr)-len(fullstr.lstrip())]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This way you don't have to work through all the details of whitespace!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["(Thanks Adam for the correction)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This can also be done with str.isspace and itertools.takewhile instead of regex. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "str.isspace", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools.takewhile", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\n\ntests=['\\t\\tthis line has two tabs of indention',\n       '    this line has four spaces of indention']\n\ndef indention(astr):\n    # Using itertools.takewhile is efficient -- the looping stops immediately after the first\n    # non-space character.\n    return ''.join(itertools.takewhile(str.isspace,astr))\n\nfor test_string in tests:\n    print(indention(test_string))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about using the regex \\s* which matches any whitespace characters.", "You only want the whitespace at the beginning of the line so either search with the regex ^\\s* or simply match with \\s*."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "regex", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html"}, {"text": "\\s*", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "search", "childNum": 0, "tag": "code", "childList": []}, {"text": "^\\s*", "childNum": 0, "tag": "code", "childList": []}, {"text": "match", "childNum": 0, "tag": "code", "childList": []}, {"text": "\\s*", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If you're interested in using regular expressions you can use that.", "/\\s/ usually matches one whitespace character, so /^\\s+/ would match the whitespace starting a line."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "/\\s/", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "/^\\s+/", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n def whites(a):\nreturn a[0:a.find(a.strip())]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Basically, the my idea is:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]