[[{"text": ["Two possible solutions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The problem is that the internal representation of bigints does not directly include the binary data you ask for."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I think for unsigned integers (and ignoring endianness) something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import binascii\n\ndef binify(x):\n    h = hex(x)[2:].rstrip('L')\n    return binascii.unhexlify('0'*(32-len(h))+h)\n\n>>> for i in 0, 1, 2**128-1:\n...     print i, repr(binify(i))\n... \n0 '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n1 '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01'\n340282366920938463463374607431768211455 '\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff'\n</code>\n</pre>\n", "senID": 1}, {"text": ["might technically satisfy the requirements of having non-Python-specific output, not using an explicit mask, and (I assume) not using any non-standard modules.", "Not particularly elegant, though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This may not avoid the \"mask and shift each integer\" requirement.", "I'm not sure that avoiding mask and shift means in the context of Python long values. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The bytes are these:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def bytes( long_int ):\n    bytes = []\n    while long_int != 0:\n        b = long_int%256\n        bytes.insert( 0, b )\n        long_int //= 256\n    return bytes\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can then pack this list of bytes using struct.pack( '16b', bytes )"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "struct.pack( '16b', bytes )", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The PyPi bitarray module in combination with the builtin bin() function seems like a good combination for a solution that is simple and flexible."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "PyPi bitarray", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/bitarray"}, {"text": "bin()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n bytes = bitarray(bin(my_long)).tostring()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The indianness can be controlled with a few more lines of code.", "You'll have to evaluate the efficiency."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could pickle the object to binary, use protocol buffers (I don't know if they allow you to serialize unlimited precision integers though) or BSON if you do not want to write code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But writing a function that dumps 16 byte integers by shifting it should not be so hard to do if it's not time critical."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Why not use struct with the unsigned long long type twice?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "unsigned long long", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import struct\nsome_file.write(struct.pack(\"QQ\", var/(2**64), var%(2**64)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["That's documented here (scroll down to get the table with Q): http://docs.python.org/library/struct.html"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://docs.python.org/library/struct.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/struct.html"}]}], [{"text": ["This may be a little late, but I don't see why you can't use struct:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n bigint = 0xFEDCBA9876543210FEDCBA9876543210L\nprint bigint,hex(bigint).upper()\n\ncbi = struct.pack(\"!QQ\",bigint&amp;0xFFFFFFFFFFFFFFFF,(bigint&gt;&gt;64)&amp;0xFFFFFFFFFFFFFFFF)\n\nprint len(cbi)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The bigint by itself is rejected, but if you mask it with &amp;0xFFFFFFFFFFFFFFFF you can reduce it to an 8 byte int instead of 16.", "Then the upper part is shifted and masked as well.", "You may have to play with byte ordering a bit.", "I used the !", "mark to tell it to produce a network endian byte order.", "Also, the msb and lsb (upper and lower bytes) may need to be reversed.", "I will leave that as an exercise for the user to determine.", "I would say saving things as network endian would be safer so you always know what the endianess of your data is."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["No, don't ask me if network endian is big or little endian..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]