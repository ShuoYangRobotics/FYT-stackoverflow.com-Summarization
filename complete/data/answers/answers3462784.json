[[{"text": ["It looks like you are trying to validate IP addresses.", "A regular expression is probably not the best tool for this."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "validate IP addresses", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/319279/how-to-validate-ip-address-in-python"}]}, {"text": ["If you want to accept all valid IP addresses (including some addresses that you probably didn't even know were valid) then you can use IPy (Source):"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "IPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/IPy/"}, {"href": "http://stackoverflow.com/questions/319279/how-to-validate-ip-address-in-python/330107#330107", "text": "(Source)", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n from IPy import IP\nIP('127.0.0.1')\n</code>\n</pre>\n", "senID": 2}, {"text": ["If the IP address is invalid it will throw an exception."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Or you could use socket (Source):"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "socket", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/319279/how-to-validate-ip-address-in-python/319298#319298", "text": "(Source)", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n import socket\ntry:\n    socket.inet_aton(addr)\n    # legal\nexcept socket.error:\n    # Not legal\n</code>\n</pre>\n", "senID": 5}, {"text": ["If you really want to only match IPv4 with 4 decimal parts then you can split on dot and test that each part is an integer between 0 and 255."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def validate_ip(s):\n    a = s.split('.')\n    if len(a) != 4:\n        return False\n    for x in a:\n        if not x.isdigit():\n            return False\n        i = int(x)\n        if i &lt; 0 or i &gt; 255:\n            return False\n    return True\n</code>\n</pre>\n", "senID": 7}, {"text": ["Note that your regular expression doesn't do this extra check.", "It would accept 999.999.999.999 as a valid address."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "999.999.999.999", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I'm normally the one of the very few Python experts who steadfastly defends regular expressions (they have quite a bad reputation in the Python community), but this is not one of those cases -- accepting (say) '333.444.555.666' as an \"IP address\" is really bad, and if you need to do more checks after matching the RE, much of the point of using a RE is lost anyway.", "So, I second @Mark's recommendations heartily: IPy for generality and elegance (including support of IPv6 if you want!", "), string operations and int checks if you only need IPv4 (but, think twice about that limitation, and then think one more -- IPv6's time has way come!-):"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "'333.444.555.666'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "really", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "IPy", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/IPy/"}, {"text": "way", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n def isgoodipv4(s):\n    pieces = s.split('.')\n    if len(pieces) != 4: return False\n    try: return all(0&lt;=int(p)&lt;256 for p in pieces)\n    except ValueError: return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'd far rather do that than a convoluted RE to match only numbers between 0 and 256!-)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Your regular expression doesn't check for the end of the string, so it would match:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n 123.45.67.89abc123boogabooga\n</code>\n</pre>\n", "senID": 1}, {"text": ["To fix this, use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n '\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$'\n</code>\n</pre>\n", "senID": 3}, {"text": ["(note the $ at the end)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "$", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Finally, in Python the usual style is to use is not None instead of != None."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "is not None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "!= None", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["you should precompile the regexp, if you use it repeatedly"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n re_ip = re.compile('\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$')\n# note the terminating $ to really match only the IPs\n</code>\n</pre>\n", "senID": 1}, {"text": ["then use"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if re_ip.match(st):\n    print '!IP'\n</code>\n</pre>\n", "senID": 3}, {"text": ["but.. is e.g.", "'111.222.333.444' really the IP?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["i'd look at netaddr or ipaddr libraries whether they can be used to match IPs"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "netaddr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ipaddr", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If you are validating IP address I would suggest the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import socket\n\ntry:\n    socket.inet_aton(addr)\n    return True\nexcept socket.error:\n    return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you just want to check if it is in the right format then you would want to do it for all legal bases (not just base 10 numbering)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "legal bases", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/IPv4#Address_representations"}]}, {"text": ["Also, are the IP address IPv4 only (and none are IPv6) then you could just look up what valid address are and use split() (to get individual components of the IP) and int() (to type-caste for comparison).", "A quick reference to valid IPv4 rules is here."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "split()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "components", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "int()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/IP_address#IP_version_4_addresses"}]}], [{"text": ["You can use regular expressions: http://www.regular-expressions.info/python.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.regular-expressions.info/python.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.regular-expressions.info/python.html"}]}], [{"text": ["You can make it a little faster by compiling it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n expression = re.compile('^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$')\nfor st in strs:\n    if expression.match(st):\n       print 'IP!'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["One more validation without re:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def validip(ip):\n    return ip.count('.') == 3 and  all(0&lt;=int(num)&lt;256 for num in ip.rstrip().split('.'))\n\nfor i in ('123.233.42.12','3234.23.453.353','-2.23.24.234','1.2.3.4'):\n    print i,validip(i)\n</code>\n</pre>\n", "senID": 1}]]