[[{"text": ["Low-value integers are preallocated, high value integers are allocated whenever they are computed.", "Integers that appear in source code are the same object.", "On my system,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; id(2) == id(1+1)\nTrue\n&gt;&gt;&gt; id(1000) == id(1000+0)\nFalse\n&gt;&gt;&gt; id(1000) == id(1000)\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["You'll also notice that the ids depend on the system.", "They're just memory addresses, assigned by the system allocator (or possibly the linker, for static objects?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; id(0)\n8402324\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit: The reason id(1000) == id(1000) is because the Python compiler notices that two of the integer constants in the code it's compiling are the same, so it only allocates one object for both.", "This would be an unacceptable performance hit at runtime, but at compile time it's not noticeable.", "(Yes, the interpreter is also a compiler.", "Most interpreters are also compilers, very few aren't."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "id(1000) == id(1000)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The first 256 ints are preallocated"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for n in range(1000):\n&gt;&gt;&gt;  if id(n) != id(n+0):\n&gt;&gt;&gt;   print n\n&gt;&gt;&gt;   break\n\n257\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I seem to recall that Python internally caches copies of ints &lt; 256 to save having to create new Python objects for commonly-used cases.", "So once you go over 256 you're getting newly created objects each time which may appear to be 'randomly' laid out in memory (obviously their locations would make sense to Python's allocator, but probably not to us)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Since others have fully answered why ids have a distinct pattern up to 256, I thought I would answer your addendum instead: 24 is the size in bytes of an integer object in python.", "When the first 256 integers are allocated they are done so contiguously in memory, leading to a difference of 24 between each memory address."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["integers up to 256 are interned, that's why you see a \"pattern\" there.", "All other integers are created during execution and as such allocated random id."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "id", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["In CPython, IDs are the address of the objects."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "IDs are the address of the objects", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#id"}]}]]