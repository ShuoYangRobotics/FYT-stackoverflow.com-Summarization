[[{"text": ["This one is pretty simple actually:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n if re.search(\n    r\"\"\"# Always use VERBOSE when composing non-trivial regex!\n    ^                 # Anchor to start of string.\n    # Apply multiple lookahead assertions from string start:\n    (?!\\.)            # Assert does NOT begin with dot.\n    (?=.*\\.exe$)      # Assert DOES end with .EXE\n    (?!.*-xyz\\.exe$)  # Assert does NOT end with -XYZ.EXE\n    .*                # Ok to match the filename (optional).\n    \"\"\", \n    subject, re.IGNORECASE | re.VERBOSE):\n    # Successful match\nelse:\n    # Match attempt failed\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: After reading your question a bit closer, it appears you are concerned with the case of the EXE.", "In that case the regex can easily handle that, too:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n if re.search(\n    r\"\"\"# Always use VERBOSE when composing non-trivial regex!\n    ^                     # Anchor to start of string.\n    # Apply multiple lookahead assertions from string start:\n    (?!\\.)                # Assert does not begin with dot.\n    (?=.*\\.(?:exe|EXE)$)  # Assert DOES end with .EXE or .exe\n    (?!.*-xyz\\.exe$)      # Assert does NOT end with -xyz-exe\n    .*                    # Ok to match the filename (optional).\n    \"\"\", \n    subject, re.VERBOSE):\n    # Successful match\nelse:\n    # Match attempt failed\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit2:  John Machin has pointed out that with Python, when you are looking for a match that can only occur at the start of a target string, then using the ^ start of string assertion with the re.search method is much slower than using re.match (and is considered bad practice).", "With that in mind, here is an improved version:"], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "Edit2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "^", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "re.search", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "re.match", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n if re.match(\n    r\"\"\"# Always use VERBOSE when composing non-trivial regex!\n    # Apply multiple lookahead assertions from string start:\n    (?!\\.)                # Assert does not begin with dot.\n    (?=.*\\.(?:exe|EXE)$)  # Assert DOES end with .EXE or .exe\n    (?!.*-xyz\\.exe$)      # Assert does NOT end with -xyz-exe\n    .*                    # Ok to match the filename (optional).\n    \"\"\", \n    subject, re.VERBOSE):\n    # Successful match\nelse:\n    # Match attempt failed\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I wouldn't use a regexp, just wrap that onto multiple lines and make it a little smarter:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if not filename.startswith(\".\") \\\n   and filename.lower().endswith(\".exe\") \\\n   and not filename.endswith(\"-xyz.exe\"):\n    #do stuff\n</code>\n</pre>\n", "senID": 1}, {"text": ["Do note that this is slightly different in that *.eXe, *.eXE and other mixed case versions of the extension would then be ignored as well, unlike in the original.", "But I'm betting that it doesn't really matter and that my test is better."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "*.eXe", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "*.eXE", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "really", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["edit: fixed the \".exe\" part because I had the condition flipped, but if you're trying to learn regular expressions this is a weird contrived example and I think it's best not to try and shoehorn regular expressions as a solution to a problem where it's not a good solution"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "\".exe\"", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You need to use a negative lookbehind assertion:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nregex = '[^.].*(?:(?&lt;!-xyz).exe|.EXE)'\n\nvectors = (\n  '.123.dat',\n  '.123.exe',\n  '.123.EXE',\n  '123.dat',\n  '123.exe',\n  '123.EXE',\n  '.123-xyz.dat',\n  '.123-xyz.exe',\n  '.123-xyz.EXE',\n  '123-xyz.dat',\n  '123-xyz.exe',\n  '123-xyz.EXE',\n)\n\nfor v in vectors:\n  print \"%s: \" % (v,),\n  if (bool(re.match(regex, v)) == (not v.startswith(\".\") and\n      re.search(\"(.exe|.EXE)$\", v) is not None and\n      not v.endswith(\"-xyz.exe\"))):\n    print 'PASS'\n  else:\n    print 'FAIL'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Learn to use elementary regular expressions before you start trying to \"shorten\" your code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This piece re.search(\"(.exe|.EXE)$\", fileName) has THREE deficiencies:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "re.search(\"(.exe|.EXE)$\", fileName)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["(1) Should use raw strings by habit, even when it makes no difference, because then you (and your readers) don't need to spend time nutting out whether it matters or not."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["(2) Unescaped .", "matches ANY character (except a newline (in the default case))."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": ".", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["(3) $ matches before a newline at the end of a string; you should use \\Z instead.", "If you don't, foo.exe\\n (easy enough to get by mistake if your input was supplied by someone who didn't strip the \\n) will match."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "$", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\Z", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "foo.exe\\n", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\\n", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["What you need is re.search(r\"(\\.exe|\\.EXE)\\Z\", fileName)"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "re.search(r\"(\\.exe|\\.EXE)\\Z\", fileName)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Update for the benefit of anyone who thinks that re.search(\"^blahblah\", ...) is a good idea:"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "re.search(\"^blahblah\", ...)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;\\python27\\python -mtimeit -s\"import re;s='x'*100\" \"re.match(r'foo',s)\"\n1000000 loops, best of 3: 1.2 usec per loop\n\n&gt;\\python27\\python -mtimeit -s\"import re;s='x'*100\" \"re.search(r'^foo',s)\"\n100000 loops, best of 3: 2.91 usec per loop\n\n&gt;\\python27\\python -mtimeit -s\"import re;s='x'*1000\" \"re.match(r'foo',s)\"\n1000000 loops, best of 3: 1.2 usec per loop\n\n&gt;\\python27\\python -mtimeit -s\"import re;s='x'*1000\" \"re.search(r'^foo',s)\"\n100000 loops, best of 3: 18.5 usec per loop\n</code>\n</pre>\n", "senID": 7}], [{"code": "<pre>\n<code>\n import re\n\npat = re.compile('(?!\\.)'\n                 '.+'\n                 '\\.'\n                 '(?:(?&lt;!-xyz\\.)exe|EXE)'\n                 '\\Z')\n\nnames = ('.123.dat', '.123.exe', '.123.EXE',\n         '123.dat', '123.exe', '123.EXE',\n         '123-xyz.dat', '123-xyz.exe', '123-xyz.EXE', )\n\nprint '\\n'.join(v.ljust(18)+str(bool(pat.match(v))) for v in names)\n</code>\n</pre>\n", "senID": 0}, {"text": [], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["EDIT:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You are right, ridgerunner, [^.", "] is better than (?!\\.", ") : it's more readable, more logic and slightly faster, -4 % (I tested)"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "[^.]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "(?!\\.)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I also compared '(?!\\.).+?\\.(?", ":EXE|(?&lt;!-xyz)exe)\\Z' ( there is .+?", "instead of .+)"], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "'(?!\\.).+?\\.(?:EXE|(?&lt;!-xyz)exe)\\Z'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": ".+?", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".+", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["With this RE, execution is longer.", "The additional time depends of the number of dots in the tested names."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["On names like '78999.abc.juty.123.dat' it is around 15 % longer, and on names like '123.dat' it's  3 % longer.", "I think the reason is that the regex motor examine after each reading of a character if the read character is a dot or not."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "'78999.abc.juty.123.dat'", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "'123.dat'", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["On the contrary, with '.+\\.", "' the regex motor goes until the end, and then come back to search the last dot.", "I think it is a correct explanation because, if the RE '(?!\\.).+?\\.(?", ":EXE|(?&lt;!-xyz)exe)\\Z'  is tested on names like '123.teybertyhbeythbeytberyetynetynetnyetnydat' , the time is again longer (+ 30 %)"], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "'.+\\.'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "'(?!\\.).+?\\.(?:EXE|(?&lt;!-xyz)exe)\\Z'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "'123.teybertyhbeythbeytberyetynetynetnyetnydat'", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["I realized that my RE is very similar to the Ignacio's one, and I wondered why I wrote this RE as it seems to have no particular interest.", "In fact, at the beginning, my idea was to write '(?!\\.).+?", "(?&lt;=.EXE|(?&lt;!-xyz).exe)\\Z' and then I wrote another string.", "By the way, with this abandonned RE , the execution time is 25 % longer on short names and 74 % longer on long names."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "'(?!\\.).+?(?&lt;=.EXE|(?&lt;!-xyz).exe)\\Z'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Finally, when I tested the execution times, Ignacio's solution is 25 % longer on short names ( '123.dat' ) and 47 % longer on long names ( '78999.abc.juty.123.dat' )"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "Ignacio's solution is 25 % longer on short names ( '123.dat' ) and 47 % longer on long names ( '78999.abc.juty.123.dat' )", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Best regex is then"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n pat = re.compile('[^.]'\n                 '.+'\n                 '\\.'\n                 '(?:(?&lt;!-xyz\\.)exe|EXE)'\n                 '\\Z')\n</code>\n</pre>\n", "senID": 13}, {"text": ["I let '.+' , not replaced by '.", "*' , because there must be at least 4 characters in the name if we want the name to end with '.exe' or '.EXE'"], "childNum": 4, "tag": "p", "senID": 14, "childList": [{"text": "'.+'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'.*'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "'.exe'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "'.EXE'", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["That will involve accessing every file that doesn't start with '.", "' or ends with '-xyz.exe'.", "The regex module cannot parse stuff outside its namespace.", "I don't think it's possible, but have you tried checking the module's doc?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]