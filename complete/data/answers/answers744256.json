[[{"text": ["If you only need 200 of 50 million lines, then reading all of it into memory is a waste.", "I would sort the list of search keys and then apply binary search to the file using seek() or something similar.", "This way you would not read the entire file to memory which I think should speed things up."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Slight optimization of S.Lotts answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\nkeyValues= defaultdict(list)\ntargetKeys= # some list of keys as strings\nfor line in fin:\n    key, value = line.split()\n    if key in targetKeys:\n        keyValues[key].append( value )\n</code>\n</pre>\n", "senID": 1}, {"text": ["Since we're using a dictionary rather than a list, the keys don't have to be numbers.", "This saves the map() operation and a string to integer conversion for each line.", "If you want the keys to be numbers, do the conversion a the end, when you only have to do it once for each key, rather than for each of 50 million lines."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It's not clear what \"list[pointer]\" is all about.", "Consider this, however."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\nkeyValues= defaultdict(list)\ntargetKeys= # some list of keys\nfor line in fin:\n    key, value = map( int, line.split())\n    if key in targetKeys:\n        keyValues[key].append( value )\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would use memory-maping: http://docs.python.org/library/mmap.html.", "This way you can use the file as if it's stored in memory, but the OS decides which pages should actually be read from the file."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/mmap.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/mmap.html"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}], [{"text": ["If you have any control over the format of the file, the \"sort and binary search\" responses are correct.", "The detail is that this only works with records of a fixed size and offset (well, I should say it only works easily with fixed length records)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["With fixed length records, you can easily seek() around the sorted file to find your keys."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Here is a recursive binary search on the text file"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os, stat\n\nclass IntegerKeyTextFile(object):\n    def __init__(self, filename):\n        self.filename = filename\n        self.f = open(self.filename, 'r')\n        self.getStatinfo()\n\n    def getStatinfo(self):\n        self.statinfo = os.stat(self.filename)\n        self.size = self.statinfo[stat.ST_SIZE]\n\n    def parse(self, line):\n        key, value = line.split()\n        k = int(key)\n        v = int(value)\n        return (k,v)\n\n    def __getitem__(self, key):\n        return self.findKey(key)\n\n    def findKey(self, keyToFind, startpoint=0, endpoint=None):\n        \"Recursively search a text file\"\n\n        if endpoint is None:\n            endpoint = self.size\n\n        currentpoint = (startpoint + endpoint) // 2\n\n        while True:\n            self.f.seek(currentpoint)\n            if currentpoint &lt;&gt; 0:\n                # may not start at a line break! Discard.\n                baddata = self.f.readline() \n\n            linestart = self.f.tell()\n            keyatpoint = self.f.readline()\n\n            if not keyatpoint:\n                # read returned empty - end of file\n                raise KeyError('key %d not found'%(keyToFind,))\n\n            k,v = self.parse(keyatpoint)\n\n            if k == keyToFind:\n                print 'key found at ', linestart, ' with value ', v\n                return v\n\n            if endpoint == startpoint:\n                    raise KeyError('key %d not found'%(keyToFind,))\n\n            if k &gt; keyToFind:\n                return self.findKey(keyToFind, startpoint, currentpoint)\n            else:\n                return self.findKey(keyToFind, currentpoint, endpoint)\n</code>\n</pre>\n", "senID": 1}, {"text": ["A sample text file created in jEdit seems to work:    "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; i = integertext.IntegerKeyTextFile('c:\\\\sampledata.txt')\n&gt;&gt;&gt; i[1]\nkey found at  0  with value  345\n345\n</code>\n</pre>\n", "senID": 3}, {"text": ["It could definitely be improved by caching found keys and using the cache to determine future starting seek points."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["One possible optimization is to do a bit of buffering using the sizehint option in file.readlines(..).", "This allows you to load multiple lines in memory totaling to approximately sizehint bytes."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "sizehint", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "file.readlines(..)", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#file.readlines"}, {"text": "sizehint", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You need to implement binary search using seek()"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]