[[{"text": ["In the general case, you'll want to write your key-extraction fucntion for sorting purposes; only in special (though important) cases it happens that you can just reuse an existing callable to extract the keys for you, or just conjoin a couple of existing ones (in a \"quick and dirty\" way using lambda, since there's no built-in way to do function composition)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you often need to perform these two kinds of operations for key extraction (get an item and call a method on that item), I suggest:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def combiner(itemkey, methodname, *a, **k):\n  def keyextractor(container):\n    item = container[itemkey]\n    method = getattr(item, methodname)\n    return method(*a, **k)\n  return keyextractor\n</code>\n</pre>\n", "senID": 2}, {"text": ["so listofdicts.sort(key=combiner('name', 'lower')) will work in your case."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "listofdicts.sort(key=combiner('name', 'lower'))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Note that while excessive generalization has costs, tasteful and moderate generalization (leaving the item key, method name, and method arguments if any, as runtime-determined, in this case) generally has benefits -- one general function, not more complex than a dozen specific and specialized ones (with the extractor, method to call, or both, hardwired in their code), will be easier to maintain (and, of course, much easier to reuse!-)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["How about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n list_of_dicts.sort(key=lambda a: a['name'].lower())\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You probably should go with a lambda for the sake of readability.", "But as an interesting study into higher order functions, here's the extended version of q-combinator in Python (also known as the queer bird combinator).", "This allows you to create a new function by composing two functions"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def compose(inner_func, *outer_funcs):\n     if not outer_funcs:\n         return inner_func\n     outer_func = compose(*outer_funcs)\n     return lambda *args, **kwargs: outer_func(inner_func(*args, **kwargs))\n\n from operator import itemgetter, methodcaller\n name_lowered = compose(itemgetter('name'), methodcaller('lower'))\n print(name_lowered( {'name': 'Foo'} ))\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you reverse the definitions of inner and outer in the compose function, you get the more traditional b-combinator (bluebird).", "I like the q-combinator more because of the similarity to unix pipes."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "compose", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n def lower_getter(field):\n    def _getter(obj):\n        return obj[field].lower()\n    return _getter\n\nlist_of_dicts.sort(key=lower_getter(key_field))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This solution will use your system locale, and as a bonus, it will sort eventual other characters according to the current locale as well (Will put \"\u00fc\" after \"u\" in a german locale etc)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from locale import setlocale, strxfrm, LC_ALL\nimport operator\n\n# call setlocale to init current locale\nsetlocale(LC_ALL, \"\")\n\ndef locale_keyfunc(keyfunc):  \n  def locale_wrapper(obj):\n    return strxfrm(keyfunc(obj))\n  return locale_wrapper\n\nlist_of_dicts.sort(key=locale_keyfunc(operator.itemgetter(\"name\")))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This of course uses that the locale sort is the User interface \"natural\" sort that you wish to emulate with .lower()."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I'm amazed that python's locale module is unknown and unused, it for sure is an important component in the application I write (translated to multiple languages, but the locale module is important for even getting one module right.", "Case in point: in swedish 'V' and 'W' sort alike, so you have to collate them.", "locale does all that for you.).", "In the POSIX locale (not default), this will revert to sorting \"a\" after \"Z\"."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "locale", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "one", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "locale", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "POSIX", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["Personally, I wish there were two functions in the Python standard library (probably in functools):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def compose(*funcs):\n\t\"\"\"\n\tCompose any number of unary functions into a single unary\n\tfunction.\n\n\t&gt;&gt;&gt; import textwrap\n\t&gt;&gt;&gt; str.strip(textwrap.dedent(compose.__doc__)) == compose(str.strip, textwrap.dedent)(compose.__doc__)\n\tTrue\n\t\"\"\"\n\n\tcompose_two = lambda f1, f2: lambda v: f1(f2(v))\n\treturn reduce(compose_two, funcs)\n\ndef method_caller(method_name, *args, **kwargs):\n\t\"\"\"\n\tReturn a function that will call a named method on the\n\ttarget object with optional positional and keyword\n\targuments.\n\n\t&gt;&gt;&gt; lower = method_caller('lower')\n\t&gt;&gt;&gt; lower('MyString')\n\t'mystring'\n\t\"\"\"\n\tdef call_method(target):\n\t\tfunc = getattr(target, method_name)\n\t\treturn func(*args, **kwargs)\n\treturn call_method\n</code>\n</pre>\n", "senID": 1}, {"text": ["I have implemented these for my own use in jaraco.util.functools. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "jaraco.util.functools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://svn.jaraco.com/jaraco/python/jaraco.util/jaraco/util/functools.py"}]}, {"text": ["Either way, now your code is quite clear, self-documented, and robust (IMO)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n lower = method_caller('lower')\nget_name = itemgetter('name')\nlowered_name = compose(lower, get_name)\n\nlist_of_dicts.sort(key=lowered_name)\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n from functools import partial\n\ndef nested_funcs(*funcs):\n    return partial(reduce, lambda arg, func: func(arg), funcs)\n\n\nsorted(list_of_dicts, key=nested_funcs(itemgetter('name'), str.strip, str.lower))\n</code>\n</pre>\n", "senID": 0}]]