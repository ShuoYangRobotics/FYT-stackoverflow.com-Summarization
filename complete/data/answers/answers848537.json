[[{"text": ["You don't need to assign to slices, just build the string using % formatting."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "% formatting", "tag": "a", "pos": 0, "childList": [{"text": "% formatting", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#string-formatting-operations"}, {"text": "% formatting", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["An example with a fixed format for 3 data items:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; fmt=\"%4s%10s%10s\"\n&gt;&gt;&gt; fmt % (1,\"ONE\",2)\n'   1       ONE         2'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["Same thing, field width supplied with the data:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; fmt2 = \"%*s%*s%*s\"\n&gt;&gt;&gt; fmt2 % (4,1, 10,\"ONE\", 10,2)\n'   1       ONE         2'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 4}, {"text": ["Separating data and field widths, and using zip() and str.join() tricks:"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "zip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "str.join()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; widths=(4,10,10)\n&gt;&gt;&gt; items=(1,\"ONE\",2)\n&gt;&gt;&gt; \"\".join(\"%*s\" % i for i in zip(widths, items))\n'   1       ONE         2'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 6}], [{"text": ["You can use justify functions to left-justify, right-justify and center a string in a field of given width."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "justify", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/string.html#string.ljust"}]}, {"code": "<pre>\n<code>\n 'hi'.ljust(10) -&gt; 'hi        '\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Hopefully I understand what you're looking for: some way to conveniently identify each part of the line by a simple variable, but output it padded to the correct width?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The snippet below may give you what you want"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class FixWidthFieldLine(object):\n\n    fields = (('foo', 10),\n              ('bar', 30),\n              ('ooga', 30),\n              ('booga', 10))\n\n    def __init__(self):\n        self.foo = ''\n        self.bar = ''\n        self.ooga = ''\n        self.booga = ''\n\n    def __str__(self):\n        return ''.join([getattr(self, field_name).ljust(width) \n                        for field_name, width in self.fields])\n\nf = FixWidthFieldLine()\nf.foo = 'hi'\nf.bar = 'joe'\nf.ooga = 'howya'\nf.booga = 'doin?'\n\nprint f\n</code>\n</pre>\n", "senID": 2}, {"text": ["This yields:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n hi        joe                           howya                         doing\n</code>\n</pre>\n", "senID": 4}, {"text": ["It works by storing a class-level variable, fields which records the order in which each field should appear in the output, together with the number of columns that field should have.", "There are correspondingly-named instance variables in the __init__ that are set to an empty string initially."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "fields", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The __str__ method outputs these values as a string.", "It uses a list comprehension over the class-level fields attribute, looking up the instance value for each field by name, and then left-justifying it's output according to the columns.", "The resulting list of fields is then joined together by an empty string."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "__str__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fields", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Note this doesn't parse input, though you could easily override the constructor to take a string and parse the columns according to the field and field widths in fields.", "It also doesn't check for instance values that are longer than their allotted width."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "fields", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["It's a little difficult to parse your question, but I'm gathering that you are receiving a file or file-like-object, reading it, and replacing some of the values with some business logic results.", "Is this correct?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The simplest way to overcome string immutability is to write a new string:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # Won't work:\ntest_string[3:6] = \"foo\"\n\n# Will work:\ntest_string = test_string[:3] + \"foo\" + test_string[6:]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Having said that, it sounds like it's important to you that you do something with this string, but I'm not sure exactly what that is.", "Are you writing it back to an output file, trying to edit a file in place, or something else?", "I bring this up because the act of creating a new string (which happens to have the same variable name as the old string) should emphasize the necessity of performing an explicit write operation after the transformation."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You can convert the string to a list and do the slice manipulation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; text = list(\"some text\")\n&gt;&gt;&gt; text[0:4] = list(\"fine\")\n&gt;&gt;&gt; text\n['f', 'i', 'n', 'e', ' ', 't', 'e', 'x', 't']\n&gt;&gt;&gt; text[0:4] = list(\"all\")\n&gt;&gt;&gt; text\n['a', 'l', 'l', ' ', 't', 'e', 'x', 't']\n&gt;&gt;&gt; import string\n&gt;&gt;&gt; string.join(text, \"\")\n'all text'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It is easy to write function to \"modify\" string."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def change(string, start, end, what):\n    length = end - start\n    if len(what)&lt;length: what = what + \" \"*(length-len(what))\n    return string[0:start]+what[0:length]+string[end:]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n test_string = 'This is test string'\n\nprint test_string[5:7]  \n# is\ntest_string = change(test_string, 5, 7, 'IS')\n# This IS test string\ntest_string = change(test_string, 8, 12, 'X')\n# This IS X    string\ntest_string = change(test_string, 8, 12, 'XXXXXXXXXXXX')\n# This IS XXXX string\n</code>\n</pre>\n", "senID": 3}]]