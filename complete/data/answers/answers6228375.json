[[{"text": ["Part of the way there would be to generate a list of tuples of list-elements and indexes, I think.", "This can then be sorted by list-element value and the index extracted."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n L1order = [t[1] for t in sorted(zip(L1, range(len(L1))))]\nL2order = [t[1] for t in sorted(zip(L2, range(len(L2))))]\nL1order == L2order\n</code>\n</pre>\n", "senID": 2}, {"text": ["Turning this into a function should be trivial."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I'm not 100% sure if this is what you are after, but it works for the examples you have provided:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\n\ndef compatible(l1,l2):\n    return ordered_indices(l1) == ordered_indices(l2)\n\ndef ordered_indices(l):\n    tmp = list(enumerate(l))\n    tmp.sort(key=operator.itemgetter(1))\n    return map(operator.itemgetter(0), tmp)\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n>>> compatible([1,3,4,5,2], [1,3,5,5,1])\nTrue\n>>> compatible([1,2,3,4,5], [1,2,4,2,5])\nFalse\n</pre>\n", "senID": 2}, {"text": ["Updated version:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import operator, itertools\n\ndef compatible(l1,l2):\n    if len(l1) != len(l2): return False\n    i1 = ordered_indices(l1)\n    i2 = ordered_indices(l2)\n    g1 = None\n    g2 = None\n    while i1 and i2:\n        g1 = g1 or i1.pop(0)\n        g2 = g2 or i2.pop(0)\n        if len(g1) > len(g2):\n            g1,g2 = g2,g1\n            i1,i2 = i2,i1\n        x = g1.pop()\n        if x not in g2:\n            return False\n        g2.remove(x)\n    return True\n\n\ndef ordered_indices(l):\n    tmp = list(enumerate(l))\n    value = operator.itemgetter(1)\n    index = operator.itemgetter(0)\n    tmp.sort(key=value)\n    groups = itertools.groupby(tmp, value)\n    return [set(map(index, g)) for k, g in groups]\n</code>\n</pre>\n", "senID": 4}, {"code": "<pre>\n>>> compatible([1,3,5,5,1],[1,2,2,3,2])\nTrue\n</pre>\n", "senID": 5}], [{"text": ["I did the following expanding on shang's answer.", "It takes into consideration the special fact involved when two values are the same.", "Simply ordering the lists and comparing them could give the wrong result.", "For example, if the order in list 1 is 0 &lt; 1 &lt; 2 and the order in list 2 is 0 &lt; 1 &lt;= 2, ordering the second list could give as result both [0,1,2] and [0,2,1], and in this last case, shang's method would fail.", "This depends on the behavior of the sorting routine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\n\ndef order_indexes(l):\n    tmp = list(enumerate(l))\n    tmp.sort(key=operator.itemgetter(1))\n    return map(operator.itemgetter(0), tmp)\n\ndef are_compatible(l1, l2):\n    # Order one list, retaining the indexes\n    ordered = order_indexes(l1)\n    # For each pair of indexes on the list\n    for i in xrange(len(ordered) - 1):\n        pair = (ordered[i], ordered[i + 1])\n        # See if the pairs in the other list are compatible\n        # If a1 &lt;= b1 then a2 must be &lt;= b2 \n        if l2[pair[0]] &gt; l2[pair[1]]:\n            return False\n    # If all pairs are compatible, then the lists are compatible\n    return True\n\nif __name__ == '__main__':\n    l1 = [1,3,4,5,2]\n    l2 = [1,3,5,5,1]\n    l3 = [1,2,3,4,5]\n    l4 = [1,2,4,2,5]\n    print \"L1 X L2 \",are_compatible(l1, l2)\n    print \"L2 X L1 \",are_compatible(l2, l1)\n    print \"L3 X L4 \",are_compatible(l3, l4)\n    print \"L4 X L3 \",are_compatible(l4, l3)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["One possible algorithm is as follows:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def compatible\n    temp1=L1[:]\n    temp2=L2[:]\n    max1=max(L1)+1\n    max2=max(L2)+2\n    order1=[]\n    for i in range(len(L1)):\n        pos=t1.index(min(t1))\n        order1.append(pos)\n        t1[pos]=max1\n    for i in range(len(L2)):\n        pos=t2.index(min(t2))\n        order2.append(pos)\n        t2[pos]=max2\n    return order1==order2\n</code>\n</pre>\n", "senID": 1}, {"text": ["This algorithm relies on the members of each list being unequal.", "If you want to use lists with duplicates, you would need to keep track of the pairs that are equal and check whether switching any of the pairs would make the orderings the same."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Sorry, your definition given here of compatible doesn't match your example.", "In L2, 4&lt;=0, but the same is not true in L1.", "I suspect the definition you meant to give is: if a&lt;b in one list, then a&lt;=b in the other list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In that case, none of the previous solutions work.", "L1 = [1,1] and L2 = [2,1] should be compatible."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Any solution would need to realize that compatibility is not transitive.", "For instance, if L1 = [1,2], L2 = [1,1], and L3 = [2,1], then L1 is compatible with L2 and L2 is compatible with L3, but L1 is not compatible with L3.", "So any solution that checks for equality between some \"orderings\" computed from the lists will fail."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Thiago Chaves's solution doesn't have this problem, but it fails on L1 = [2,2,1], L2 = [2,1,1].", "These should be compatible."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT: If efficiency is not a huge concern, here's a quick O(N^2) solution that simply tests each pair of numbers:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def compat5(L1, L2):\n    z = zip(L1, L2)\n    return not any(j1&lt;k1 and j2&gt;k2 for j1,j2 in z for k1,k2 in z)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["[EDIT]\nOk, I'm stupid.", "It can be made even simpler, obviously:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def compatible_ordering(xs, ys):\n    return all(\n        y1 &lt;= y2\n            for (_, y1), (_, y2) in pairwise(sorted(izip(xs, ys)))\n    )\n</code>\n</pre>\n", "senID": 1}, {"text": ["[/EDIT]"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here's an O(n * log n) solution:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip, tee\n\ndef pairwise(iterable):\n    a, b = tee(iterable)\n    next(b)\n    return izip(a, b)\n\ndef compatible_ordering(xs, ys):\n    return all(\n        x1 == x2 or y1 &lt;= y2\n            for (x1, y1), (x2, y2) in pairwise(sorted(izip(xs, ys)))\n    )\n</code>\n</pre>\n", "senID": 4}, {"text": ["It's basically a one liner, if you don't count the pairwise()recipe from itertools.", "Man, you gotta love Python for this."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "pairwise()recipe from itertools", "tag": "a", "pos": 0, "childList": [{"text": "pairwise()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#recipes"}, {"text": "pairwise()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["BTW, notice the similarity to the wrong solution at the end."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["How it works can probably be easier explained if we rewrite the algorithm into a more procedural form:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def compatible_ordering(xs, ys):             # line 0\n    xys = zip(xs, ys)                        # line 1\n    xys.sort()                               # line 2\n    for (x1, y1), (x2, y2) in pairwise(xys): # line 3\n        if x1 &lt; x2 and y1 &gt; y2:              # line 4\n            return False                     # line 5\n    return True                              # line 6\n</code>\n</pre>\n", "senID": 8}, {"text": ["This time we don't try to find out if a condition holds for all elements ( = success), but instead if a condition holds for some element ( = failure), so the testing formula is basically negated."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "success", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "failure", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Now, for every pair of neighbouring tuples ((x1, y1), (x2, y2)):"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "((x1, y1), (x2, y2))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 5, "lis": [{"text": ["Always x1 &lt;= x2, since we sorted them that way.", "That implies that if x1 != x2 then x1 &lt; x2."], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "x1 &lt;= x2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x1 != x2", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "x1 &lt; x2", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If x1 == x2 we know that y1 &lt;= y2, again because we sorted them so."], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "x1 == x2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y1 &lt;= y2", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If x1 &lt; x2 and y1 &lt;= y2, both (x1, x2) and (y1, y2) have the same ordering and we continue."], "childNum": 4, "tag": "p", "senID": 13, "childList": [{"text": "x1 &lt; x2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y1 &lt;= y2", "childNum": 0, "tag": "code", "childList": []}, {"text": "(x1, x2)", "childNum": 0, "tag": "code", "childList": []}, {"text": "(y1, y2)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Otherwise if x1 &lt; x2 and y1 &gt; y2, our two lists have incompatible orderings and we return False."], "childNum": 3, "tag": "p", "senID": 14, "childList": [{"text": "x1 &lt; x2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y1 &gt; y2", "childNum": 0, "tag": "code", "childList": []}, {"text": "return False", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If we're done iterating and haven't found any incompatibility, we return True."], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "return True", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}, {"text": ["IOW: the sorting creates an ordering for ys defined by xs, and by ysitself for equal elements in xs (since equal elements of xs don't impose any ordering on ys).", "Then all we have to do is to test if ys is indeed ordered."], "childNum": 7, "tag": "p", "senID": 16, "childList": [{"text": "ys", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "xs", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "ys", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "xs", "childNum": 0, "tag": "code", "childList": []}, {"text": "xs", "childNum": 0, "tag": "code", "childList": []}, {"text": "ys", "childNum": 0, "tag": "code", "childList": []}, {"text": "ys", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Here's an example.", "After line 0 we have e.g."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n xs == [4, 3, 4, 2, 5, 4, 0, 2, 0, 5]\nys == [4, 1, 5, 1, 5, 5, 2, 2, 1, 3]\n</code>\n</pre>\n", "senID": 18}, {"text": ["In line 2 we zip those and get:"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"code": "<pre>\n<code>\n xys == [(4, 4), (3, 1), (4, 5), (2, 1), (5, 5), (4, 5), (0, 2), (2, 2), (0, 1), (5, 3)]\n</code>\n</pre>\n", "senID": 20}, {"text": ["In line 3 we sort:"], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"code": "<pre>\n<code>\n xys == [(0, 1), (0, 2), (2, 1), (2, 2), (3, 1), (4, 4), (4, 5), (4, 5), (5, 3), (5, 5)]\n</code>\n</pre>\n", "senID": 22}, {"text": ["In line 4 we iterate through all pairs of neighbouring tuples of the sorted list and test in line 5:"], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"code": "<pre>\n<code>\n x1  y1     x2  y2       x1     x2      y1    y2\n( 0 , 1 ), ( 0 , 2 )  --&gt;  0  &lt;  0  and  1  &gt;  2   --&gt;  False  --&gt;  continue\n( 0 , 2 ), ( 2 , 1 )  --&gt;  0  &lt;  2  and  2  &gt;  1   --&gt;  True   --&gt;  return False\n</code>\n</pre>\n", "senID": 24}, {"text": ["BTW #2: It's very possible that this version is faster then the oneliner."], "childNum": 0, "tag": "p", "senID": 25, "childList": []}, {"text": ["[EDIT]"], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"text": ["The following was my first and WRONG answer to the OP's question.", "Still, I don't delete it, as an example to what happens if you post without reading carefully."], "childNum": 1, "tag": "p", "senID": 27, "childList": [{"text": "WRONG", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Here's an O(n) solution:"], "childNum": 0, "tag": "p", "senID": 28, "childList": []}, {"code": "<pre>\n<code>\n def compatible_ordering(xs, ys):\n    return all(\n        (x1 &lt;= x2) == (y1 &lt;= y2)\n            for (x1, x2), (y1, y2) in izip(pairwise(xs), pairwise(ys))\n    )\n</code>\n</pre>\n", "senID": 29}]]