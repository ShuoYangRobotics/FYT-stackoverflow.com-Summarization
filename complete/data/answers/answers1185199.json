[[{"text": ["You can achieve your example if you make \"op\" a function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n>>> def magic(left, op, right):\n    ...     return op(left, right)\n    ...\n    >>> magic(5, (lambda a, b: a == b), 5)\n    True\n    >>> magic(5, (lambda a, b: a == b), 4)\n    False\n</pre>\n", "senID": 1}, {"text": ["This is more Pythonic than passing a String.", "It's how functions like sort() work."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "sort()", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/HowTo/Sorting"}]}, {"text": ["Those SQLAlchemy examples with filter() are puzzling.", "I don't know the internals about SQLAlchemy, but I'm guessing in an example like query.filter(User.name == 'ed') what's going on is that User.name is a SQLAlchemy-specific type, with an odd implementation of the __eq() function that generates SQL for the filter() function instead of doing a comparison.", "Ie: they've made special classes that let you type Python expressions that emit SQL code.", "It's an unusual technique, one I'd avoid unless building something that's bridging two languages like an ORM."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["An even more pythonic variant of Nelson's solution is to use the operator functions from the operator module in the standard library; there is no need to create your own lambdas."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "operator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/operator.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from operator import eq\n&gt;&gt;&gt; def magic(left, op, right):\n...   return op(left, right)\n... \n&gt;&gt;&gt; magic(5, eq, 5)\nTrue\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can't.", "The expression 5 == 5 is evaluated and only then is the result passed to someFunc.", "The function just gets True (the True object, to be precise), no matter what the expression was."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "5 == 5", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: Concerning your edit, this question is kind of close."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "this question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1179096/suggestions-for-python-assert-function"}]}, {"text": ["Edit 2: You could just pass the expression as a string and use eval, like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def someFunc(expression_string):\n...    print(expression_string, \"evaluates to\", eval(expression_string))\n\n&gt;&gt;&gt; someFunc(\"5 == 5\")\n5 == 5 evaluates to True\n</code>\n</pre>\n", "senID": 3}, {"text": ["Don't know whether that helps you.", "Keep in mind that eval is a powerful tool, so it's dangerous to pass arbitrary (and possibly even user-generated) input to it."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "eval", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["It appears you can return tuples from eq:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "eq", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Foo:\n    def __init__(self, value):\n            self.value = value\n\n    def __eq__(self, other):\n            return (self.value, other.value)\n\n\nf1 = Foo(5)\nf2 = Foo(10)\nprint(f1 == f2)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You need to wrap the whole thing as a literal string.", "You're trying to print that out as a string I assume, correct?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Short answer: You can't.", "The result of the expression evaluation is passed to the function rather than the expression itself."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Time has passed but, I found this post looking for a similar solution.", "I have a list of dictionaries which I wanted to be able to search in a familiar way.", "Since I've always found that the filtering in SQLAlchemy seemed visual and better then .eq/.lt/etc functions I wanted something similar with my list search without too much effort. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want to have the magic of passing a condition to a function you will need to wrap the 'keys' in some kind of object either like i do below or by having a key (or column) class.", "In any case you'll need to allow the expression to be solved before it passes as the param.", "Having such a method would allow additional logic like 'and' and 'or'.", "But, this is far more detail then I have need for.", "I think want you want to get out of using the magic function can be achieved with this."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "the magic of passing a condition to a function", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The (simple) collection looks something like this:\nclass mycollection( list ):"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "class mycollection( list ):", "childNum": 1, "tag": "pre", "pos": 0, "childList": [{"text": "class mycollection( list ):", "tag": "code"}]}, {"text": "class mycollection( list ):", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def search( self ): \n       return Search( self )\n</code>\n</pre>\n", "senID": 3}, {"senID": 4}, {"text": ["The (simplified) search class.", "Side note: use bisect to do the .eq/.lt/etc operations Searching Sorted Lists"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "Searching Sorted Lists", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/bisect.html#searching-sorted-lists"}]}, {"text": ["class Search:"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "class Search:", "childNum": 1, "tag": "pre", "pos": 0, "childList": [{"text": "class Search:", "tag": "code"}]}, {"text": "class Search:", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def __init__( self, result ):\n        self.result = result\n\n    def filter( self, key  ):\n        return expressionKey( self, key )\n\n    def eq(self, key, value): \n        \"\"\"eq search logic modify self.result\"\"\"\n        return len( self.result ) != 0\n\n    def ne(self, key, value ):\n        \"\"\"ne search logic modify self.result\"\"\"\n        return len( self.result ) != 0\n\n    def lt(self, key, value ):\n        \"\"\"lt search logic modify self.result\"\"\"\n        return len( self.result ) != 0\n\n    def le(self, key, value ):\n        \"\"\"le search logic modify self.result\"\"\"\n        return len( self.result ) != 0\n\n    def gt(self, key, value):\n        \"\"\"gt search logic modify self.result\"\"\"\n        return len( self.result ) != 0\n\n    def ge(self, key, value ):\n        \"\"\"ge search logic modify self.result\"\"\"\n         return len( self.result ) != 0\n</code>\n</pre>\n", "senID": 7}, {"senID": 8}, {"text": ["The expresssionKey class can wrap the key value into something we can do an expression on "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["class expressionKey:"], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "class expressionKey:", "childNum": 1, "tag": "pre", "pos": 0, "childList": [{"text": "class expressionKey:", "tag": "code"}]}, {"text": "class expressionKey:", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def __init__(self, search, key): \n        self.search = search \n        self.key    = key\n\n    def __lt__(self, value): \n        return self.search.lt( self.key, value )\n\n    def __le__(self, value): \n        return self.search.le( self.key, value )\n\n    def __gt__(self, value): \n        return self.search.gt( self.key, value )\n\n    def __ge__(self, value): \n        return self.search.ge( self.key, value )\n\n    def __eq__(self, value): \n        return self.search.eq( self.key, value )\n\n    def __ne__(self, value): \n        return self.search.ne( self.key, value )\n</code>\n</pre>\n", "senID": 11}, {"senID": 12}, {"text": ["So to filter we use it like this and call search.result to get the values we have filterd out of mycollection\nfilled_collection = mycollection()\nsearch = filled_collection.Search( )\nsearch.filter( 'enabled' ) == True\nsearch.filter( 'last_access' ) >= datetime.now( ).date()\nprint search.result"], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "filled_collection = mycollection()\nsearch = filled_collection.Search( )\nsearch.filter( 'enabled' ) == True\nsearch.filter( 'last_access' ) >= datetime.now( ).date()\nprint search.result", "childNum": 1, "tag": "pre", "pos": 0, "childList": [{"text": "filled_collection = mycollection()\nsearch = filled_collection.Search( )\nsearch.filter( 'enabled' ) == True\nsearch.filter( 'last_access' ) >= datetime.now( ).date()\nprint search.result", "tag": "code"}]}, {"text": "filled_collection = mycollection()\nsearch = filled_collection.Search( )\nsearch.filter( 'enabled' ) == True\nsearch.filter( 'last_access' ) >= datetime.now( ).date()\nprint search.result", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["search = filled_collection.Search( )\nsome_method( search.filter( 'id' ) != 1 )\n"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["Hope that helps"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}]]