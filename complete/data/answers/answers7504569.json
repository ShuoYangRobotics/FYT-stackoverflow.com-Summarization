[[{"text": ["You can do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n        myfunc()\n    except IndexError:\n        trace = sys.exc_info()[2]\n        if trace.tb_next.tb_next is None:\n            pass\n        else:\n            raise\n</code>\n</pre>\n", "senID": 1}, {"text": ["Although it is kinda ugly and would seem to violate encapsulation."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Stylistically, wanting to catch having passed too many arguments seem strange.", "I suspect that a more general rethink of what you are doing may resolve the problem.", "But without more details I can't be sure. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Possible approach: check if function you are calling has the arguments *args,**kwargs.", "If it does, assume its a decorator and adjust the code above to check if the exception was one further layer in.", "If not, check as above."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "*args,**kwargs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Still, I think you need to rethink your solution. "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I am not a fan of doing magic this way.", "I suspect you have an underlying design problem rather."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["--original answer and code which was too unspecific to the problem removed--"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit after understanding specific problem:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from inspect import getargspec\n\ndef can_call_effectively(f, args):\n    (fargs, varargs, _kw, df) = getattr(myfunc, 'effective_argspec', \\\n        getargspec(myfunc))\n    fargslen = len(fargs)\n    argslen = len(args)\n    minargslen = fargslen - len(df)\n    return (varargs and argslen &gt;= minargslen) or minargslen &lt;= argslen &lt;= fargslen\n\nif can_call_effectively(myfunc, args)\n    myfunc(*args)\nelse:\n    fixit()\n</code>\n</pre>\n", "senID": 3}, {"text": ["All your decorators, or at least those you want to be transparent in regard to\ncalling via the above code, need to set 'effective_argspec' on the returned callable.", "Very explicit, no magic.", "To achieve this, you could decorate your decorators with the appropriate code..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Edit: more code, the decorator for transparent decorators."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def transparent_decorator(decorator):\n    def wrapper(f):\n        wrapped = decorator(f)\n        wrapped.effective_argspec = getattr(f, 'effective_argspec', getargspec(f))\n        return wrapped\n    return wrapper\n</code>\n</pre>\n", "senID": 6}, {"text": ["Use this on your decorator:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n @transparent_decorator\ndef decorator(func):\n\"The most trivial (and common) decorator\"\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper  # line missing in example above\n</code>\n</pre>\n", "senID": 8}, {"text": ["Now if you create myfunc1 - myfunc3 as above, they work exactly as expected."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["Ugh unfortunately not really.", "Your best bet is to introspect the error object that is returned and see if myfunc and the number of arguments is mentioned."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So you'd do something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n except TypeError, err:\n    if err.has_some_property or 'myfunc' in str(err):\n        fixit()\n    raise\n</code>\n</pre>\n", "senID": 2}], [{"text": ["you can do it by doing something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def f(x,y,z):\n    print (f(0))\n\n\n&gt;&gt;&gt; try:\n    f(0)\nexcept TypeError as e:\n    print (e.__traceback__.tb_next is None)\n\n\nTrue\n&gt;&gt;&gt; try:\n    f(0,1,2)\nexcept TypeError as e:\n    print (e.__traceback__.tb_next is None)\n\n\nFalse\n</code>\n</pre>\n", "senID": 1}, {"text": ["but a better way should be to count the number of args of function and comparing with the number of args expected"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n len(inspect.getargspec(f).args) != len (args)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Well-written wrappers will preserve the function name, signature, etc, of the functions they wrap; however, if you have to support wrappers that don't, or if you have situations where you want to catch an error in a wrapper (not just the final wrapped function), then there is no general solution that will work."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can retrieve the traceback and look at its length.", "Try:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import traceback as tb\nimport sys\n\ndef a():\n    1/0\n\ndef b():\n    a()\n\ndef c():\n    b()\n\ntry:\n    a()\nexcept:\n    print len(tb.extract_tb(sys.exc_traceback))\n\ntry:\n    b()\nexcept:\n    print len(tb.extract_tb(sys.exc_traceback))\n\ntry:\n    c()\nexcept:\n    print len(tb.extract_tb(sys.exc_traceback))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This prints"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 2\n3\n4\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Seems to me what you're trying to do is exactly the problem that exceptions are supposed to solve, ie where an exception will be caught somewhere in the call stack, so that there's no need to propagate errors upwards."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Instead, it sounds like you are trying to do error handling the C (non-exception handling) way, where the return value of a function indicates either no error (typically 0) or an error (non 0 value).", "So, I'd try just writing your function to return a value, and have the caller check for the return value."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]