[[{"text": ["If x and y are row vectors, you can do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i=[x;y]\n# do stuff with i(1) and i(2)\nend\n</code>\n</pre>\n", "senID": 1}, {"text": ["With column vectors, use x' and y'."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If I'm not mistaken the zip function you use in python creates a pair of the items found in list1 and list2.", "Basically it still is a for loop with the addition that it will retrieve the data from the two seperate lists for you, instead that you have to do it yourself."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "creates a pair of the items found in list1 and list2", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://groups.google.com/group/comp.lang.python/browse_thread/thread/195e57735ff6ee56"}]}, {"text": ["So maybe your best option is to use a standard for loop like this:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "standard", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for i=1:length(a)\n  c(i) = a(i) + b(i);\nend\n</code>\n</pre>\n", "senID": 2}, {"text": ["or whatever you have to do with the data."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If you really are talking about parallel computing then you should take a look at the Parallel Computing Toolbox for matlab, and more specifically at parfor"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "Parallel Computing Toolbox", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.mathworks.com/products/parallel-computing/"}, {"href": "http://www.mathworks.com/access/helpdesk/help/toolbox/distcomp/index.html?/access/helpdesk/help/toolbox/distcomp/brb2x2l-1.html", "text": "parfor", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Tested only in octave... (no matlab license).", "Variations of arrayfun() exist, check the documentation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/octave -qf\n\nfunction result = dostuff(my_ten, my_one)\n  result = my_ten + my_one\nendfunction\n\ntens = [ 10 20 30 ];\nones = [ 1 2 3];\n\nx = arrayfun(@dostuff, tens, ones);\n\nx\n</code>\n</pre>\n", "senID": 1}, {"text": ["Yields..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n x =\n\n   11   22   33\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I second mattiast's answer."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But, to dig a little deeper, is there no way to vectorize what you're trying to accomplish and avoid the iterative for loop?", "Perhaps with more details about what goes on inside the loop we could help vectorize the solution..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["for loops in MATLAB used to be slow, but this is not true anymore."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So Vectorizing is not always the miracle solution.", "just use the profiler, and toc and toc functions to help you identify possible bottlenecks"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I would recommend to join the two arrays for the computation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n % assuming you have column vectors a and b\nx = [a b];\n\nfor i = 1:length(a)\n    % do stuff with one row...\n    x(i,:);\nend\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will work great if your functions can work with vectors.", "Then again, many functions can even work with matrices, so you wouldn't even need the loop."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]