[[{"text": ["Try"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for arg in arguments:\n    lst = equal if '=' in arg else plain\n    lst.append(arg)\n</code>\n</pre>\n", "senID": 1}, {"text": ["or (holy ugly)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for arg in arguments:\n    (equal if '=' in arg else plain).append(arg)\n</code>\n</pre>\n", "senID": 3}, {"text": ["A third option: Create a class which offers append() and which sorts into several lists."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "append()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can use itertools.groupby() for this:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "itertools.groupby()", "tag": "a", "pos": 0, "childList": [{"text": "itertools.groupby()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.groupby"}, {"text": "itertools.groupby()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\nf = lambda x: '=' in x\ngroups = itertools.groupby(sorted(data, key=f), key=f)\nfor k, g in groups:\n    print k, list(g)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would just go for two list comprehensions.", "While that does incur some overhead (two loops on the list), it is more Pythonic to use a list comprehension than to use a for.", "It's also (in my mind) much more readable than using all sorts of really cool tricks, but that less people know about."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n def which_list(s):\n    if \"=\" in s: \n        return 1\n    return 0\n\nlists = [[], []]\n\nfor arg in arguments:\n    lists[which_list(arg)].append(arg)\n\nplain, equal = lists\n</code>\n</pre>\n", "senID": 0}, {"text": ["If you have more types of data, add an if clause to which_list, and initialize lists to more empty lists."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "which_list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "lists", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I would go for Edan's approach, e.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n equal = [arg for arg in arguments if '=' in arg]\nplain = [arg for arg in arguments if '=' not in arg]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I read somewhere here that you might be interested in a solution that\nwill work for more than two identifiers (equals sign and space). "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "more", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["The following solution just requires you update the uniques set with\nanything you would like to match, the results are placed in a dictionary of lists\nwith the identifier as the key.   "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "uniques", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n uniques = set('= ')\nmatches = dict((key, []) for key in uniques)\n\nfor arg in args:\n    key = set(arg) &amp; uniques\n    try:\n        matches[key.pop()].append(arg)\n    except KeyError:\n        # code to handle where arg does not contain = or ' '.\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now the above code assumes that you will only have a single match for your identifier\nin your arg.", "I.e that you don't have an arg that looks like this 'John= equalspace'.", "You will have to also think about how you would like to treat cases that don't match anything in the set (KeyError occurs."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "arg", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "arg", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "'John= equalspace'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "KeyError", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["Another approach is to use the filter function, although it's not the most efficient solution.", "Example:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "filter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l = ['a=s','aa','bb','=', 'a+b']\n&gt;&gt;&gt; l2 = filter(lambda s: '=' in s, l)\n&gt;&gt;&gt; l3 = filter(lambda s: '+' in s, l)\n&gt;&gt;&gt; l2\n['a=s', '=']\n&gt;&gt;&gt; l3\n['a+b']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I put this together, and then see that Ned Batchelder was already on this same tack.", "I chose to package the splitting method instead of the list chooser, though, and to just use the implicit 0/1 values for False and True."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def split_on_condition(source, condition):\n    ret = [],[]\n    for s in source:\n        ret[condition(s)].append(s)\n    return ret\n\nsrc = \"z=1;q=2;lady jane;y=a;lucy in the sky\".split(';')\n\nplain,equal = split_on_condition(src, lambda s:'=' in s)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Your approach is the best one.", "For sorting just into two lists it can't get clearer than that.", "If you want it to be a one-liner, encapsulate it in a function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def classify(arguments):\n    equal, plain = [], []\n    for arg in arguments:\n        if '=' in arg:\n            equal.append(arg)\n        else:\n            plain.append(arg)\n    return equal, plain\n\n\nequal, plain = classify(lst)\n</code>\n</pre>\n", "senID": 1}]]