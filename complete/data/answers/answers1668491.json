[[{"text": ["My 2 cents:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sum(len(set(x - i for i, x in enumerate(t))) for t in nums)\n7\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's basically the same idea as descriped in Alex' post, but using a set instead of itertools.groupby, resulting in a shorter expression.", "Since sets are implemented in C and len() of a set runs in constant time, this should also be pretty fast."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "Alex' post", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1668491#answer-1668616"}, {"text": "set", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "itertools.groupby", "childNum": 0, "tag": "code", "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}, {"text": "len()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Consider:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; nums = ((1, 2, 3, 4), (1, 5, 6), (19, 20, 24, 29, 400))\n&gt;&gt;&gt; flat = [[(x - i) for i, x in enumerate(tu)] for tu in nums]\n&gt;&gt;&gt; print flat\n[[1, 1, 1, 1], [1, 4, 4], [19, 19, 22, 26, 396]]\n&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; print sum(1 for tu in flat for _ in itertools.groupby(tu))\n7\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["we \"flatten\" the \"increasing ramps\" of interest by subtracting the index from the value, turning them into consecutive \"runs\" of identical values; then we identify and could the \"runs\" with the precious itertools.groupby.", "This seems to be a pretty elegant (and speedy) solution to your problem."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "itertools.groupby", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Just to show something closer to your original code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def sumranges(nums):\n    return sum( (1 for i in nums\n                   for j, v in enumerate(i)\n                   if j == 0 or v != i[j-1] + 1) )\n</code>\n</pre>\n", "senID": 1}, {"text": ["The idea here was to:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "avoid building intermediate lists but use a generator instead, it will save some resources", "tag": "none", "senID": 3}, {"text": "avoid using indices when you already have selected a subelement (i and v above).", "tag": "none", "senID": 4}]}, {"text": ["The remaining sum() is still necessary with my example though."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "sum()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Here's my attempt:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def ranges(ls):\n    for l in ls:\n        consec = False\n        for (a,b) in zip(l, l[1:]+(None,)):\n            if b == a+1:\n                consec = True\n            if b is not None and b != a+1:\n                consec = False\n            if consec:\n                yield 1\n\n'''\n&gt;&gt;&gt; nums = ((1, 2, 3, 4), (1, 5, 6), (19, 20, 24, 29, 400))\n&gt;&gt;&gt; print sum(ranges(nums))\n7\n'''\n</code>\n</pre>\n", "senID": 1}, {"text": ["It looks at the numbers pairwise, checking if they are a consecutive pair (unless it's at the last element of the list).", "Each time there's a consecutive pair of numbers it yields 1."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This could probably be put together in a more compact form, but I think clarity would suffer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def pairs(seq):\n    for i in range(1,len(seq)):\n        yield (seq[i-1], seq[i])\n\ndef isadjacent(pair):\n    return pair[0]+1 == pair[1]\n\ndef sumrange(seq):\n    return 1 + sum([1 for pair in pairs(seq) if not isadjacent(pair)])\n\ndef sumranges(nums):\n    return sum([sumrange(seq) for seq in nums])\n\n\nnums = ((1, 2, 3, 4), (1, 5, 6), (19, 20, 24, 29, 400))\nprint sumranges(nums)   # prints 7\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could probably do this better if you had an IntervalSet class because then you would scan through your ranges to build your IntervalSet, then just use the count of set members."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "IntervalSet class", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/interval/1.0.0"}]}, {"text": ["Some tasks don't always lend themselves to neat code, particularly if you need to write the code for performance."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["There is a formula for this, the sum of the first n numbers,  1+ 2+ ... + n = n(n+1) / 2 .", "Then if you want to have the sum of i-j then it is (j(j+1)/2) - (i(i+1)/2) this I am sure simplifies but you can work that out.", "It might not be pythonic but it is what I would use."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]