[[{"text": ["Use np.intersect1d. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nimport numpy as np\na = np.array([1,2,3,4,5,6])\nb = np.array([1,4,5])\nc=np.intersect1d(a,b)\nprint(c)\n# [1 4 5]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that np.intersect1d gives the wrong answer if a or b have nonunique elements.", "In that case use\nnp.intersect1d_nu."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["There is also np.setdiff1d, setxor1d, setmember1d, and union1d.", "See\nNumpy Example List With Doc"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Numpy Example List With Doc", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.scipy.org/Numpy%5FExample%5FList%5FWith%5FDoc"}]}], [{"text": ["Actually, there's an even simpler solution than any of these:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy as np\n\na = array([1,2,3,4,5,6])\nb = array([1,4,5])\n\nc = np.in1d(a,b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The resulting c is then:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n array([ True, False, False,  True,  True, False], dtype=bool)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Thanks for your reply kaizer.se.", "It's not quite what I was looking for, but with a suggestion from a friend and what you said I came up with the following. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy as np\n\na = np.array([1,4,5]).astype(np.float32)\nb = np.arange(10).astype(np.float32)\n\n# Assigning matching values from a in b as np.nan\nb[b.searchsorted(a)] = np.nan\n\n# Now generating Boolean arrays\nmatch = np.isnan(b)\nnonmatch = match == False\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's a bit of a cumbersome process, but it beats writing loops or using weave with loops. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Cheers"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Numpy has a set function numpy.setmember1d() that works on sorted and uniqued arrays and returns exactly the boolean array that you want.", "If the input arrays don't match the criteria you'll need to convert to the set format and invert the transformation on the result."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy as np\na = np.array([6,1,2,3,4,5,6])\nb = np.array([1,4,5])\n\n# convert to the uniqued form\na_set, a_inv = np.unique1d(a, return_inverse=True)\nb_set = np.unique1d(b)\n# calculate matching elements\nmatches = np.setmea_set, b_set)\n# invert the transformation\nresult = matches[a_inv]\nprint(result)\n# [False  True False False  True  True False]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit:\nUnfortunately the setmember1d method in numpy is really inefficient.", "The search sorted and assign method you proposed works faster, but if you can assign directly you might as well assign directly to the result and avoid lots of unnecessary copying.", "Also your method will fail if b contains anything not in a.", "The following corrects those errors:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n result = np.zeros(a.shape, dtype=np.bool)\nidxs = a.searchsorted(b)\nidxs = idxs[np.where(idxs &lt; a.shape[0])] # Filter out out of range values\nidxs = idxs[np.where(a[idxs] == b)] # Filter out where there isn't an actual match\nresult[idxs] = True\nprint(result)\n</code>\n</pre>\n", "senID": 3}, {"text": ["My benchmarks show this at 91us vs. 6.6ms for your approach and 109ms for numpy setmember1d on 1M element a and 100 element b."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["ebresset, your answer won't work unless a is a subset of b (and a and b are sorted).", "Otherwise the searchsorted will return false indices.", "I had to do something similar, and combining that with your code:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "your answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1613249/numpy-comparing-elements-in-two-arrays/1613531#1613531"}]}, {"code": "<pre>\n<code>\n # Assume a and b are sorted\nidxs = numpy.mod(b.searchsorted(a),len(b))\nidxs = idxs[b[idxs]==a]\nb[idxs] = numpy.nan\nmatch = numpy.isnan(b)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Your example implies set-like behavior, caring more about existance in the array than having the right element at the right place.", "Numpy does this differently with its mathematical arrays and matrices, it will tell you only about items at the exact right spot.", "Can you make that work for you?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "existance in the array", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import numpy\n&gt;&gt;&gt; a = numpy.array([1,2,3])\n&gt;&gt;&gt; b = numpy.array([1,3,3])\n&gt;&gt;&gt; a == b\narray([ True, False,  True], dtype=bool)\n</code>\n</pre>\n", "senID": 1}]]