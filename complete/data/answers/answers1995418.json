[[{"text": ["There are only slight differences in the two.", "You can use the dis module to examine this sort of thing for yourself.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dis", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Edit: My first version decompiled the generator expression created at module-scope in the interactive prompt.", "That's slightly different from the OP's version with it used inside a function.", "I've modified this to match the actual case in the question."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["As you can see below, the \"yield\" generator (first case) has three extra instructions in the setup, but from the first FOR_ITER they differ in only one respect:  the \"yield\" approach uses a LOAD_FAST in place of a LOAD_DEREF inside the loop.", "The LOAD_DEREF is \"rather slower\" than LOAD_FAST, so it makes the \"yield\" version slightly faster than the generator expression for large enough values of x (the outer loop) because the value of y is loaded slightly faster on each pass.", "For smaller values of x it would be slightly slower because of the extra overhead of the setup code."], "childNum": 9, "tag": "p", "senID": 2, "childList": [{"text": "FOR_ITER", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "LOAD_FAST", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "LOAD_DEREF", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "LOAD_DEREF", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\"rather slower\"", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.opensubscriber.com/message/python-list@python.org/7844960.html"}, {"text": "LOAD_FAST", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It might also be worth pointing out that the generator expression would usually be used inline in the code, rather than wrapping it with the function like that.", "That would remove a bit of the setup overhead and keep the generator expression slightly faster for smaller loop values even if LOAD_FAST gave the \"yield\" version an advantage otherwise."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "LOAD_FAST", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In neither case would the performance difference be enough to justify deciding between one or the other.", "Readability counts far more, so use whichever feels most readable for the situation at hand.  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def Generator(x, y):\n...     for i in xrange(x):\n...         for j in xrange(y):\n...             yield(i, j)\n...\n&gt;&gt;&gt; dis.dis(Generator)\n  2           0 SETUP_LOOP              54 (to 57)\n              3 LOAD_GLOBAL              0 (xrange)\n              6 LOAD_FAST                0 (x)\n              9 CALL_FUNCTION            1\n             12 GET_ITER\n        &gt;&gt;   13 FOR_ITER                40 (to 56)\n             16 STORE_FAST               2 (i)\n\n  3          19 SETUP_LOOP              31 (to 53)\n             22 LOAD_GLOBAL              0 (xrange)\n             25 LOAD_FAST                1 (y)\n             28 CALL_FUNCTION            1\n             31 GET_ITER\n        &gt;&gt;   32 FOR_ITER                17 (to 52)\n             35 STORE_FAST               3 (j)\n\n  4          38 LOAD_FAST                2 (i)\n             41 LOAD_FAST                3 (j)\n             44 BUILD_TUPLE              2\n             47 YIELD_VALUE\n             48 POP_TOP\n             49 JUMP_ABSOLUTE           32\n        &gt;&gt;   52 POP_BLOCK\n        &gt;&gt;   53 JUMP_ABSOLUTE           13\n        &gt;&gt;   56 POP_BLOCK\n        &gt;&gt;   57 LOAD_CONST               0 (None)\n             60 RETURN_VALUE\n&gt;&gt;&gt; def Generator_expr(x, y):\n...    return ((i, j) for i in xrange(x) for j in xrange(y))\n...\n&gt;&gt;&gt; dis.dis(Generator_expr.func_code.co_consts[1])\n  2           0 SETUP_LOOP              47 (to 50)\n              3 LOAD_FAST                0 (.0)\n        &gt;&gt;    6 FOR_ITER                40 (to 49)\n              9 STORE_FAST               1 (i)\n             12 SETUP_LOOP              31 (to 46)\n             15 LOAD_GLOBAL              0 (xrange)\n             18 LOAD_DEREF               0 (y)\n             21 CALL_FUNCTION            1\n             24 GET_ITER\n        &gt;&gt;   25 FOR_ITER                17 (to 45)\n             28 STORE_FAST               2 (j)\n             31 LOAD_FAST                1 (i)\n             34 LOAD_FAST                2 (j)\n             37 BUILD_TUPLE              2\n             40 YIELD_VALUE\n             41 POP_TOP\n             42 JUMP_ABSOLUTE           25\n        &gt;&gt;   45 POP_BLOCK\n        &gt;&gt;   46 JUMP_ABSOLUTE            6\n        &gt;&gt;   49 POP_BLOCK\n        &gt;&gt;   50 LOAD_CONST               0 (None)\n             53 RETURN_VALUE\n</code>\n</pre>\n", "senID": 5}], [{"text": ["In this example, not really.", "But yield can be used for more complex constructs - for example it can accept values from the caller as well and modify the flow as a result.", "Read PEP 342 for more details (it's an interesting technique worth knowing)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "for example", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://eli.thegreenplace.net/2009/08/29/co-routines-as-an-alternative-to-state-machines/"}, {"text": "PEP 342", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0342/"}]}, {"text": ["Anyway, the best advice is use whatever is clearer for your needs."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "use whatever is clearer for your needs", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["P.S.", "Here's a simple coroutine example from Dave Beazley:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Dave Beazley", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/coroutines/index.html"}]}, {"code": "<pre>\n<code>\n def grep(pattern):\n    print \"Looking for %s\" % pattern\n    while True:\n        line = (yield)\n        if pattern in line:\n            print line,\n\n# Example use\nif __name__ == '__main__':\n    g = grep(\"python\")\n    g.next()\n    g.send(\"Yeah, but no, but yeah, but no\")\n    g.send(\"A series of tubes\")\n    g.send(\"python generators rock!\")\n</code>\n</pre>\n", "senID": 3}], [{"text": ["There is no difference for the kind of simple loops that you can fit into a generator expression.", "However yield can be used to create generators that do much more complex processing.", "Here is a simple example for generating the fibonacci sequence:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def fibgen():\n...    a = b = 1\n...    while 1:\n...        yield a\n...        a, b = b, a+b\n\n&gt;&gt;&gt; list(itertools.takewhile((lambda x: x&lt;100), fibgen()))\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using yield is nice if the expression is more complicated than just nested loops.", "Among other things you can return a special first or special last value.", "Consider:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def Generator(x):\n  for i in xrange(x):\n    yield(i)\n  yield(None)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would use a generator expression when possible, since the syntax readable, short and sweet."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I would define a generator using the yield statement when I need something more complicated.", "For example,"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def Generator(x, y):\n    for i in xrange(x):\n        for j in xrange(y):\n            yield i+j\n            yield i-j\n</code>\n</pre>\n", "senID": 2}, {"text": ["Here is a generator that yields different things every time next is called.", "You can do more complicated things with yield than you can with generator expressions."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "next", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "yield", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["(Note: \"generator comprehensions\" are called \"generator expressions\" in the docs.", "http://docs.python.org/reference/expressions.html?highlight=generator#generator.next)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://docs.python.org/reference/expressions.html?highlight=generator#generator.next", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/expressions.html?highlight=generator#generator.next"}]}], [{"text": ["When thinking about iterators, the itertools module:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For performance, consider itertools.product(*iterables[, repeat])"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "itertools.product(*iterables[, repeat])", "tag": "a", "pos": 0, "childList": [{"text": "itertools.product(*iterables[, repeat])", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.product"}, {"text": "itertools.product(*iterables[, repeat])", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import itertools\n&gt;&gt;&gt; def gen(x,y):\n...     return itertools.product(xrange(x),xrange(y))\n... \n&gt;&gt;&gt; [t for t in gen(3,2)]\n[(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Pick the one that you find most readable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In usage, note a distinction between a generator object vs a generator function."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A generator object is use-once-only, in contrast to a generator function, which can be reused each time you call it again, because it returns a fresh generator object."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Generator expressions are in practice usually used \"raw\", without wrapping them in a function, and they return a generator object."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["E.g."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def range_10_gen_func():\n    x = 0\n    while x &lt; 10:\n        yield x\n        x = x + 1\n\nprint(list(range_10_gen_func()))\nprint(list(range_10_gen_func()))\nprint(list(range_10_gen_func()))\n</code>\n</pre>\n", "senID": 4}, {"text": ["which outputs:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code>\n</pre>\n", "senID": 6}, {"text": ["Compare with a slightly different usage:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n range_10_gen = range_10_gen_func()\nprint(list(range_10_gen))\nprint(list(range_10_gen))\nprint(list(range_10_gen))\n</code>\n</pre>\n", "senID": 8}, {"text": ["which outputs:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[]\n[]\n</code>\n</pre>\n", "senID": 10}, {"text": ["And compare with a generator expression:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n range_10_gen_expr = (x for x in range(10))\nprint(list(range_10_gen_expr))\nprint(list(range_10_gen_expr))\nprint(list(range_10_gen_expr))\n</code>\n</pre>\n", "senID": 12}, {"text": ["which also outputs:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n[]\n[]\n</code>\n</pre>\n", "senID": 14}]]