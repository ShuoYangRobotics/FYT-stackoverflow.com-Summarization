[[{"text": ["The idea behind this omission is that static variables are only useful in two situations: when you really should be using a class and when you really should be using a generator."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want to attach stateful information to a function, what you need is a class.", "A trivially simple class, perhaps, but a class nonetheless:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def foo(bar):\n    static my_bar # doesn't work\n\n    if not my_bar:\n        my_bar = bar\n\n    do_stuff(my_bar)\n\nfoo(bar)\nfoo()\n\n# -- becomes -&gt;\n\nclass Foo(object):\n    def __init__(self, bar):\n        self.bar = bar\n\n    def __call__(self):\n        do_stuff(self.bar)\n\nfoo = Foo(bar)\nfoo()\nfoo()\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you want your function's behavior to change each time it's called, what you need is a generator:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def foo(bar):\n    static my_bar # doesn't work\n\n    if not my_bar:\n        my_bar = bar\n\n    my_bar = my_bar * 3 % 5\n\n    return my_bar\n\nfoo(bar)\nfoo()\n\n# -- becomes -&gt;\n\ndef foogen(bar):\n    my_bar = bar\n\n    while True:\n        my_bar = my_bar * 3 % 5\n        yield my_bar\n\nfoo = foogen(bar)\nfoo.next()\nfoo.next()\n</code>\n</pre>\n", "senID": 4}, {"text": ["Of course, static variables are useful for quick-and-dirty scripts where you don't want to deal with the hassle of big structures for little tasks.", "But there, you don't really need anything more than global \u2014 it may seem a but kludgy, but that's okay for small, one-off scripts:"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "are", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "global", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def foo():\n    global bar\n    do_stuff(bar)\n\nfoo()\nfoo()\n</code>\n</pre>\n", "senID": 6}], [{"text": ["One alternative to a class is a function attribute:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def foo(arg):\n    if not hasattr(foo, 'cache'):\n        foo.cache = get_data_dict()\n    return foo.cache[arg]\n</code>\n</pre>\n", "senID": 1}, {"text": ["While a class is probably cleaner, this technique can be useful and is nicer, in my opinion, then a global.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I think most uses of local static variables is to simulate generators, that is, having some function which performs some iteration of a process, returns the result, but mantains the state for the subsequent invocation.", "Python handles this very elegantly using the yield command, so it seems there is not so much need for static variables."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["It's a design choice."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I'm assuming Guido thinks you don't need them very often, and you never really need them: you can always just use a global variable and tell everyone to keep their greasy paws offa' your variable ;-)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "really", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["For caching or memoization purposes, decorators can be used as an elegant and general solution."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "memoization", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/52201/"}]}], [{"text": ["In Python 3, I would use a closure:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def makefoo():\n    x = 0\n    def foo():\n        nonlocal x\n        x += 1\n        return x\n    return foo\n\nfoo = makefoo()\n\nprint(foo())\nprint(foo())\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The answer's pretty much the same as why nobody uses static methods (even though they exist).", "You have a module-level namespace that serves about the same purpose as a class would anyway."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["An ill-advised alternative:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can also use the side-effects of the definition time evaluation of function defaults:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def func(initial=0, my_static=[])\n  if not my_static:\n    my_static.append(initial)\n\n   my_static[0] += 1\n  return my_static[0]\n\nprint func(0), func(0), func(0)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Its really ugly and easily subverted, but works.", "Using global would be cleaner than this, imo."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "really", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "global", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["From one of your comments: \"I'd like to use them to cache things loaded from disk.", "I think it clutters the instance less, if I could assign them to the function\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Use a caching class then, as a class or instance attribute to your other class.", "That way, you can use the full feature set of classes without cluttering other things.", "Also, you get a reusable tool."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This shows that on SO it always pays off to state one's problem instead of asking for a specific, low level solution (e.g.", "for a missing language feature).", "That way, instead of endless debates about simulating \"static\" (a deprecated feature from an ancient language, in my view) someone could have given a good answer to you problem sooner."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]