[[{"text": ["As far as I can see any of the existing solutions work on a general one shot, possiboly infinite iter**ator**, all of them seem to require an iter**able**."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Heres a solution to that."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def batch_by(condition, seq):\n    it = iter(seq)\n    batch = [it.next()]\n    for jump_item in it:\n        if condition(jump_item):\n            for item in batch:\n                yield item, jump_item\n            batch = []\n        batch.append(jump_item)\n</code>\n</pre>\n", "senID": 2}, {"text": ["This will easily work on infinite iterators:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from itertools import count, islice\nis_prime = lambda n: n == 2 or all(n % div for div in xrange(2,n))\nprint list(islice(batch_by(is_prime, count()), 100))\n</code>\n</pre>\n", "senID": 4}, {"text": ["This will print first 100 integers with the prime number that follows them."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I have no idea what compare() is doing, but 80% of the time, you can do this with a trivial dictionary or pair of dictionaries.", "Jumping around in a list is a kind of linear search.", "Linear Search -- to the extent possible -- should always be replaced with either a direct reference (i.e., a dict) or a tree search (using the bisect module)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "compare()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["How about this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n paired_values = []\nfor elmt in reversed(items):\n    if &lt;condition&gt;:\n        current_val = elmt\n    try:\n        paired_values.append(current_val)\n    except NameError:  # for the last elements of items that don't pass the condition\n        pass\npaired_values.reverse()\n\nfor (item, jump_item) in zip(items, paired_values):  # zip() truncates to len(paired_values)\n    # do lots of stuff\n</code>\n</pre>\n", "senID": 1}, {"text": ["If the first element of items matches, then it is used as a jump_item.", "This is the only difference with your original code (and you might want this behavior)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The following iterator is time and memory-efficient:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def jump_items(items):\n    number_to_be_returned = 0\n    for elmt in items:\n        if &lt;condition(elmt)&gt;:\n            for i in range(number_to_be_returned):\n                yield elmt\n            number_to_be_returned = 1\n        else:\n            number_to_be_returned += 1\n\nfor (item, jump_item) in zip(items, jump_items(items)):\n    # do lots of stuff\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that you may actually want to set the first number_to_be_returned to 1..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Write a generator function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def myIterator(someValue):\n    yield (someValue[0], someValue[1])\n\nfor element1, element2 in myIterator(array):\n     # do something with those elements.\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I have no idea what you're trying to do with that code.", "But I'm 99% certain that whatever it is could probably be done in 2 lines.", "I also get the feeling that the '==' operator should be an 'is' operator, otherwise what is the compare() function doing?", "And what happens if the item returned from the second jump_iter.next call also equals 'item'?", "It seems like the algorithm would do the wrong thing since you'll compare the second and not the first."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You could put the whole iteration into a single try structure, that way it would be clearer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n jump_item_iter = (j for j in items if some_cond)\ntry:\n    jump_item = jump_item_iter.next()\n    for item in items:\n        if jump_item is item:\n            jump_item = jump_iter.next()\n\n    # do lots of stuff with item and jump_item\n\n except StopIteration:\n     pass\n</code>\n</pre>\n", "senID": 1}], [{"text": ["So you want to compare pairs of items in the same list, the second item of the pair having to meet some condition.", "Normally, when you want to compare pairs in a list use zip (or itertools.izip):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "itertools.izip", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n for item1, item2 in zip(items, items[1:]):\n    compare(item1, item2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Figure out how to fit your some_cond in this :)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "some_cond", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Are you basically trying to compare every item in the iterator with every other item in the original list?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To my mind this should just be a case of using two loops, rather than trying to fit it into one."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n filtered_items = (j for j in items if some_cond)\nfor filtered in filtered_items:\n    for item in items:\n        if filtered != item:\n            compare(filtered, item)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Here is one simple solution that might look a little cleaner: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i, item in enumerate(items):\n    for next_item in items[i+1:]:\n        if some_cond(next_item):\n            break\n    # do some stuff with both items\n</code>\n</pre>\n", "senID": 1}, {"text": ["The disadvantage is that you check the condition for next_item multiple times.", "But you can easily optimize this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n cond_items = [item if some_cond(item) else None for item in items]\nfor i, item in enumerate(items):\n    for next_item in cond_items[i+1:]:\n        if next_item is not None:\n            break\n    # do some stuff with both items\n</code>\n</pre>\n", "senID": 3}, {"text": ["However, both solutions carry more overhead than the original solution from the question.", "And when you start using counters to work around this then I think it is better to use the iterator interface directly (as in the original solution)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["My first answer was wrong because I didn't quite understand what you were trying to achieve.", "So if I understand correctly (this time, I hope), you want the main for item in items: to \"chase\" after an iterator that filters out some items.", "Well, there's not much you can do, except maybe wrap this into a chase_iterator(iterable, some_cond) generator, which would make your main code a little more readable."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "for item in items:", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "chase_iterator(iterable, some_cond)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Maybe that a more readable approach would be an \"accumulator approach\" (if the order of the compare() don't matter), like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n others = []\nfor item in items:\n    if some_cond(item):\n        for other in others:\n            compare(item, other)\n        others = []\n    else:\n        others.append(item)\n</code>\n</pre>\n", "senID": 2}, {"text": ["(man, I'm beginning to hate Stack Overflow... too addictive...)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n for i in range( 0, len( items ) ):\n    for j in range( i+1, len( items ) ):\n        if some_cond:\n            #do something\n            #items[i] = item, items[j] = jump_item\n</code>\n</pre>\n", "senID": 0}], [{"text": ["With just iterators"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def(lst, some_cond):\n      jump_item_iter = (j for j in lst if som_cond(j))\n      pairs = itertools.izip(lst, lst[1:])\n      for last in jump_item_iter:\n        for start, start_next in itertools.takewhile(lambda pair: pair[0] &lt; last, pairs):\n          yield start, last\n        pairs = itertools.chain([(start_next, 'dummy')], pairs)\n</code>\n</pre>\n", "senID": 1}, {"text": ["with the input: range(10) and some_cond = lambda x : x % 2\ngives [(0, 1), (1, 3), (2, 3), (3, 5), (4, 5), (5, 7), (6, 7), (7, 9), (8, 9)]\n(same that your example)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Even better using itertools.groupby:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def h(lst, cond):\n  remain = lst\n  for last in (l for l in lst if cond(l)):\n    group = itertools.groupby(remain, key=lambda x: x &lt; last)\n    for start in group.next()[1]:\n      yield start, last\n    remain = list(group.next()[1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:\nlst = range(10)\ncond = lambda x: x%2\nprint list(h(lst, cond))"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["will print "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n [(0, 1), (1, 3), (2, 3), (3, 5), (4, 5), (5, 7), (6, 7), (7, 9), (8, 9)]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Maybe it is too late, but what about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = [j for j in items if some_cond]\nfor item, jump_item in zip(l, l[1:]):\n    # do lots of stuff with item and jump_item\n</code>\n</pre>\n", "senID": 1}, {"text": ["If l = [j for j in range(10) if j%2 ==0] then the iteration is over: [(0, 2),(2, 4),(4, 6),(6, 8)]."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could write your loop body as:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools, functools, operator\n\nfor item in items:\n    jump_item_iter = itertools.dropwhile(functools.partial(operator.is_, item), \n                                         jump_item_iter)\n\n    # do something with item and jump_item_iter\n</code>\n</pre>\n", "senID": 1}, {"text": ["dropwhile will return an iterator that skips over all those which match the condition (here \"is item\")."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "is item", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You could do something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\ndef matcher(iterable, compare):\n    iterator= iter(iterable)\n    while True:\n        try: item= iterator.next()\n        except StopIteration: break\n        iterator, iterator2= itertools.tee(iterator)\n        for item2 in iterator2:\n            if compare(item, item2):\n                yield item, item2\n</code>\n</pre>\n", "senID": 1}, {"text": ["but it's quite elaborate (and actually not very efficient), and it would be simpler if you just did a"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n items= list(iterable)\n</code>\n</pre>\n", "senID": 3}, {"text": ["and then just write two loops over items."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "items", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Obviously, this won't work with infinite iterables, but your specification can only work on finite iterables."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]