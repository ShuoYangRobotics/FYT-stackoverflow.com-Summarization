[[{"text": ["locals() returns a dictionary of local variables.", "Similarly, globals() returns a dictionary of global variables.", "You can find the variable and its value in one of those, depending on where it was defined."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "locals()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "globals()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n for i in range(1,101):\n    if ('var%s' % i) in locals():\n        print 'var%s is not None' % i\n        print locals()['var%s' % i]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I wish you hadn't buried your actual requirement in the tenth comment underneath the main question.", "Actually, it appears that what you want is to dynamically get a property of a class - in this instance, a field in a Django model.", "That's simple: you just do:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "tenth comment", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n getattr(instance, varname)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can modify class attributes dynamically:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    pass\nfor i in range(100):\n    setattr(A, \"var%i\" % i, i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["creates a class with 100 attributes called A.var0 to A.var99.", "There are two problems with this approach:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "A.var0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "A.var99", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["From a quick glance at the Django source code, I can see that django.db.models.Model indeed has a custom metaclass, and indeed all attributes must already be defined at class creation time, so the above approach won't work.", "You'll have to create the complete class dictionary before actually creating the class.", "Here is one approach to do so:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "django.db.models.Model", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n model_dict = {}\nfor i in range(100):\n    model_dict[\"var%i\" % i] = models.CharField(max_length=10)\nmodel_dict[\"var_list\"] = model_dict.values()\nMyModel = type(\"MyModel\", (models.Model,), model_dict)\n</code>\n</pre>\n", "senID": 4}, {"text": ["This uses the three-parameter form oftype() to dynamically create a type.", "This part addresses problem 2."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "three-parameter form oftype()", "tag": "a", "pos": 0, "childList": [{"text": "type()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#type"}, {"text": "type()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["To address problem 1, the above code exposes also adds an attribute to the class that allows to acces all the models.CharField instances as a list rather than by name."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "models.CharField", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I think you are looking for the eval command."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "eval", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mfeuerstein.com/using-variables-as-string-in-python"}]}, {"text": ["Hope this helps,"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Regards, Maecky"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Couple different ways to do it, either get the variable from the globals or locals dictionary like so:\nglobals()['var1']"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "globals()['var1']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["or import __main__ and use getattr(__main__,'var1')"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "import __main__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "getattr(__main__,'var1')", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["throw those into a for loop, assigning the variable name to a string andhave it returned eg"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["if your testing that the class exists, use a try except"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "try except", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import __main__\n\nfor i in range(1,101):\n  try:\n    func = getattr(__main__,'var%s' % i)\n    if func is not None:\n      print 'var%s is not None' % i\n  except:\n    print 'var%s does not exist'\n</code>\n</pre>\n", "senID": 4}, {"text": ["if it's buried in a class use the class name rather than __main__.", "If the class name is var%s use getattr on func in the loop above to grab whatever it is you need out of each class."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "__main__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "getattr", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "func", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I think that a list or dictionary actually would be the most appropriate way to solve your problem.", "In Python, data structures can hold others objects.", "This includes objects that you create yourself because there is no technical distinction from the programmer's point of view between the types (classes) you define and the ones that are native to Python (string, int, etc."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]