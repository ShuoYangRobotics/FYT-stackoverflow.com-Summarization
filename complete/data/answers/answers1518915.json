[[{"tag": "ul", "num": 2, "lis": [{"text": "In .NET, elements of an array are certainly contiguous. In Java I'd expect them to be in most implementations, but it appears not to be guaranteed.", "tag": "none", "senID": 0}, {"text": "I think it's reasonable to ", "tag": "none", "senID": 1}]}, {"text": ["For the Java array part, Sun's JNI documentation includes this comment, tucked away in a discussion about strings:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Sun's JNI documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://java.sun.com/docs/books/jni/html/objtypes.html"}]}, {"text": ["For your last question, if you have two int[] then each of those arrays will be a contiguous block of memory, but they could be very \"far apart\" in memory.", "If you have an array of objects with two int fields, then each object could be a long way from each other, but the two integers within each object will be close together.", "Potentially more importantly, you'll end up taking a lot more memory with the \"lots of objects\" solution due to the per-object overhead.", "In .NET you could use a custom struct with two integers instead, and have an array of those - that would keep all the data in one big block."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "int[]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "lot", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "struct", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"text": ["I believe that in both Java and .NET, if you allocate a lot of smallish objects in quick succession within a single thread then those objects are likely to have good locality of reference.", "When the GC compacts a heap, this may improve - or it may potentially become worse, if a heap with"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "likely", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n A B C D E\n</code>\n</pre>\n", "senID": 5}, {"text": ["is compacted to"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n A D E B\n</code>\n</pre>\n", "senID": 7}, {"text": ["(where C is collected) - suddenly A and B, which may have been \"close\" before, are far apart.", "I don't know whether this actually happens in any garbage collector (there are loads around!", ") but it's possible."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Basically in a managed environment you don't usually have as much control over locality of reference as you do in an unmanaged environment - you have to trust that the managed environment is sufficiently good at managing it, and that you'll have saved enough time by coding to a higher level platform to let you spend time optimising elsewhere."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["First, your title is implying C#.", "\"Managed code\" is a term coined by Microsoft, if I'm not mistaken."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Java primitive arrays are guaranteed to be a continuous block of memory.", "If you have a "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n int[] array = new int[4];\n</code>\n</pre>\n", "senID": 2}, {"text": ["you can from JNI (native C) get a int *p to point to the actual array.", "I think this goes for the Array* class of containers as well (ArrayList, ArrayBlockingQueue, etc)."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "int *p", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Early implementations of the JVM had objects as contiuous struct, I think, but this cannot be assumed with newer JVMs.", "(JNI abstracts away this)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Two integers in the same object will as you say probably be \"closer\", but they may not be.", "This will probably vary even using the same JVM."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["An object with two int fields is an object and I don't think any JVM makes any guarantee that the members will be \"close\".", "An int-array with two elements will very likely be backed by a 8 byte long array."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["With regards to arrays here is an excerpt from CLI (Common Language Infrastructure) specification:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Good question!", "I think I would resort to writing extensions in C++ that handle memory in a more carefully managed way and just exposing enough of an interface to allow the rest of the application to manipulate the objects.", "If I was that concerned about performance I would probably resort to a C++ extension anyway."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I don't think anyone has talked about Python so I'll have a go"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In python arrays are more like arrays of pointers in C.  So the pointers will be adjacent, but the actual objects are unlikely to be."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Probably not for the same reason as above.", "The instance will only hold pointers to the objects which are the actual integers.", "Python doesn't have native int (like Java), only boxed Int (in Java-speak)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Probably not.", "However if you use the __slots__ optimisation then some parts of it will be contiguous!"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "__slots__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In python, in terms of memory locality, they are both pretty much the same!", "One will make an array of pointers to objects which will in turn contain two pointers to ints, the other will make two arrays of pointers to integers."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If you need to optimise to that level then I suspect a VM based language is not for you ;)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]