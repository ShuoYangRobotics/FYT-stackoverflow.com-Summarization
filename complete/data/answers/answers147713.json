[[{"text": ["Bitwise operations on Python ints work much like in C. The &amp;, | and ^ operators in Python work just like in C. The ~ operator works as for a signed integer in C; that is, ~x computes -x-1."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You have to be somewhat careful with left shifts, since Python integers aren't fixed-width.", "Use bit masks to obtain the low order bits.", "For example, to do the equivalent of shift of a 32-bit integer do (x &lt;&lt; 5) &amp; 0xffffffff."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n value = 0xdeadbeef\nvalue &amp;= ~(1&lt;&lt;10)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Have you tried copying and pasting your code into the Python REPL to see what will happen?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; value = 0xdeadbeef\n&gt;&gt;&gt; value &amp;= ~(1&lt;&lt;10)\n&gt;&gt;&gt; hex (value)\n'0xdeadbaef'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Omit the 'unsigned long', and the semi-colons are not needed either:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n value = 0xDEADBEEF\nvalue &amp;= ~(1&lt;&lt;10)\nprint value\n\"0x%08X\" % value\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Python has C style bit manipulation operators, so your example is literally the same in Python except without type keywords."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n value = 0xdeadbeef\nvalue &amp;= ~(1 &lt;&lt; 10)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You should also check out BitArray, which is a nice interface for dealing with sequences of bits."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "BitArray", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/bitarray/0.2.3"}]}], [{"text": ["If you're going to do a lot of bit manipulation ( and you care much more about readability rather than performance for your application ) then you may want to create an integer wrapper to enable slicing like in Verilog or VHDL:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\nimport math\n class BitVector:\n     def __init__(self,val):\n         self._val = val\n\n     def __setslice__(self,highIndx,lowIndx,newVal):\n         assert math.ceil(math.log(newVal)/math.log(2)) &lt;= (highIndx-lowIndx+1)\n\n         # clear out bit slice\n         clean_mask = (2**(highIndx+1)-1)^(2**(lowIndx)-1)\n\n         self._val = self._val ^ (self._val & clean_mask)\n         # set new value\n         self._val = self._val | (newVal&lt;&lt;lowIndx)\n\n     def __getslice__(self,highIndx,lowIndx):\n         return (self._val&gt;&gt;lowIndx)&(2L**(highIndx-lowIndx+1)-1)\n\n b = BitVector(0)\n b[3:0]   = 0xD\n b[7:4]   = 0xE\n b[11:8]  = 0xA\n b[15:12] = 0xD\n\n for i in xrange(0,16,4):\n     print '%X'%b[i+3:i]\n</pre>\n", "senID": 1}, {"text": ["Outputs:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\nD\n E\n A\n D\n</pre>\n", "senID": 3}]]