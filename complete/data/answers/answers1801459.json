[[{"text": ["Assuming order matters:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 6, "lis": [{"text": "Create an empty set S and an empty list M.", "tag": "none", "senID": 1}, {"text": "Scan the list L one element at a time.", "tag": "none", "senID": 2}, {"text": "If the element is in the set S, skip it.", "tag": "none", "senID": 3}, {"text": "Otherwise, add it to M and to S.", "tag": "none", "senID": 4}, {"text": "Repeat for all elements in L.", "tag": "none", "senID": 5}, {"text": "Return M.", "tag": "none", "senID": 6}]}, {"text": ["In Python:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; L = [2, 1, 4, 3, 5, 1, 2, 1, 1, 6, 5]\n&gt;&gt;&gt; S = set()\n&gt;&gt;&gt; M = []\n&gt;&gt;&gt; for e in L:\n...     if e in S:\n...         continue\n...     S.add(e)\n...     M.append(e)\n... \n&gt;&gt;&gt; M\n[2, 1, 4, 3, 5, 6]\n</code>\n</pre>\n", "senID": 8}, {"text": ["If order does not matter:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n M = list(set(L))\n</code>\n</pre>\n", "senID": 10}], [{"text": ["Special Case: Hashing and Equality"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Firstly, we need to determine something about the assumptions, namely the existence of an equals and has function relationship.", "What do I mean by this?", "I mean that for the set of source objects S, given any two objects x1 and x2 that are elements of S there exists a (hash) function F such that:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if (x1.equals(x2)) then F(x1) == F(x2)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Java has such a relationship.", "That allows you to check to duplicates as a near O(1) operation and thus reduces the algorithm to a simple O(n) problem.", "If order is unimportant, it's a simple one liner:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n List result = new ArrayList(new HashSet(inputList));\n</code>\n</pre>\n", "senID": 4}, {"text": ["If order is important:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n List outputList = new ArrayList();\nSet set = new HashSet();\nfor (Object item : inputList) {\n  if (!set.contains(item)) {\n    outputList.add(item);\n    set.add(item);\n  }\n}\n</code>\n</pre>\n", "senID": 6}, {"text": ["You will note that I said \"near O(1)\".", "That's because such data structures (as a Java HashMap or HashSet) rely on a method where a portion of the hash code is used to find an element (often called a bucket) in the backing storage.", "The number of buckets is a power-of-2.", "That way the index into that list is easy to calculate.", "hashCode() returns an int.", "If you have 16 buckets you can find which one to use by ANDing the hashCode with 15, giving you a number from 0 to 15."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["When you try and put something in that bucket it may already be occupied.", "If so then a linear comparison of all entries in that bucket will occur.", "If the collision rate gets too high or you try to put too many elements in the structure will be grown, typically doubled (but always by a power-of-2) and all the items are placed in their new buckets (based on the new mask).", "Thus resizing such structures is relatively expensive."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "linear", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["Lookup may also be expensive.", "Consider this class:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n public class A {\n  private final int a;\n\n  A(int a) { this.a == a; }\n\n  public boolean equals(Object ob) {\n    if (ob.getClass() != getClass()) return false;\n    A other = (A)ob;\n    return other.a == a;\n  }\n\n  public int hashCode() { return 7; }\n}\n</code>\n</pre>\n", "senID": 10}, {"text": ["This code is perfectly legal and it fulfills the equals-hashCode contract."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Assuming your set contains nothing but A instances, your insertion/search now turns into an O(n) operation, turning the entire insertion into O(n2)."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "2", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}]}, {"text": ["Obviously this is an extreme example but it's useful to point out that such mechanisms also rely on a relatively good distribution of hashes within the value space the map or set uses."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["Finally, it must be said that this is a special case.", "If you're using a language without this kind of \"hashing shortcut\" then it's a different story."], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "this is a special case", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["General Case: No Ordering"], "childNum": 0, "tag": "h2", "senID": 15, "childList": []}, {"text": ["If no ordering function exists for the list then you're stuck with an O(n2) brute-force comparison of every object to every other object.", "So in Java:"], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "2", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n List result = new ArrayList();\nfor (Object item : inputList) {\n  boolean duplicate = false;\n  for (Object ob : result) {\n    if (ob.equals(item)) {\n      duplicate = true;\n      break;\n    }\n  }\n  if (!duplicate) {\n    result.add(item);\n  }\n}\n</code>\n</pre>\n", "senID": 17}, {"text": ["General Case: Ordering"], "childNum": 0, "tag": "h2", "senID": 18, "childList": []}, {"text": ["If an ordering function exists (as it does with, say, a list of integers or strings) then you sort the list (which is O(n log n)) and then compare each element in the list to the next (O(n)) so the total algorithm is O(n log n).", "In Java:"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"code": "<pre>\n<code>\n Collections.sort(inputList);\nList result = new ArrayList();\nObject prev = null;\nfor (Object item : inputList) {\n  if (!item.equals(prev)) {\n    result.add(item);\n  }\n  prev = item;\n}\n</code>\n</pre>\n", "senID": 20}, {"text": ["Note: the above examples assume no nulls are in the list."], "childNum": 1, "tag": "p", "senID": 21, "childList": [{"text": "Note:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["If the order does not matter, you might want to try this algorithm written in Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; array = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6]\n&gt;&gt;&gt; unique = set(array)\n&gt;&gt;&gt; list(unique)\n[1, 2, 3, 4, 5, 6]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["in haskell this would be covered by the nub and nubBy functions"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "nub", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "nubBy", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n nub :: Eq a =&gt; [a] -&gt; [a]\nnub [] = []\nnub (x:xs) = x : nub (filter (/= x) xs)\n\nnubBy :: (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; [a]\nnubBy f [] = []\nnubBy f (x:xs) = x : nub (filter (not.f x) xs)\n</code>\n</pre>\n", "senID": 1}, {"text": ["nubBy relaxes the dependence on the Eq typeclass, instead allowing you to define your own equality function to filter duplicates."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "nubBy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Eq", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["These functions work over a list of consistent arbitrary types (e.g.", "[1,2,\"three\"] is not allowed in haskell), and they are both order preserving."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "[1,2,\"three\"]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In order to make this more efficient, using Data.Map (or implementing a balanced tree) could be used to gather the data into a set (key being the element, and value being the index into the original list in order to be able to get the original ordering back), then gathering the results back into a list and sorting by index.", "I will try and implement this later."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "hr", "senID": 5}, {"code": "<pre>\n<code>\n import qualified Data.Map as Map\n\nundup x = go x Map.empty\n    where\n        go [] _ = []\n        go (x:xs) m case Map.lookup x m of\n                         Just _  -&gt; go xs m\n                         Nothing -&gt; go xs (Map.insert x True m)\n</code>\n</pre>\n", "senID": 6}, {"text": ["This is a direct translation of @FogleBird's solution.", "Unfortunately it doesn't work without the import."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"tag": "hr", "senID": 8}, {"text": ["a Very basic attempt at replacing Data.Map import would be to implement a tree, something like this"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n data Tree a = Empty\n            | Node a (Tree a) (Tree a)\n            deriving (Eq, Show, Read)\n\ninsert x Empty = Node x Empty Empty\ninsert x (Node a left right)\n    | x &lt; a = Node a (insert x left) right\n    | otherwise = Node a left (insert x right)\n\nlookup x Empty = Nothing --returning maybe type to maintain compatibility with Data.Map\nlookup x (Node a left right)\n    | x == a = Just x\n    | x &lt; a = lookup x left\n    | otherwise = lookup x right\n</code>\n</pre>\n", "senID": 10}, {"text": ["an improvement would be to make it autobalancing on insert by maintaining a depth attribute (keeps the tree from degrading into a linked list).", "This nice thing about this over a hash table is that it only requires your type to be in the typeclass Ord, which is easily derivable for most types."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"tag": "hr", "senID": 12}, {"text": ["I take requests it seems.", "In response to @Jonno_FTWs inquiry here is a solution which completely removes duplicates from the result.", "It's not entirely dissimilar to the original, simply adding an extra case.", "However the runtime performance will be much slower since you are going through each sub-list twice, once for the elem, and the second time for the recusion.", "Also note that now it will not work on infinite lists."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n nub [] = []\nnub (x:xs) | elem x xs = nub (filter (/=x) xs)\n           | otherwise = x : nub xs\n</code>\n</pre>\n", "senID": 14}, {"text": ["Interestingly enough you don't need to filter on the second recursive case because elem has already detected that there are no duplicates."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}], [{"text": ["In java, it's a one liner."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Set set = new LinkedHashSet(list);\n</code>\n</pre>\n", "senID": 1}, {"text": ["will give you a collection with duplicate items removed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["For Java could go with this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n private static &lt;T&gt; void removeDuplicates(final List&lt;T&gt; list)\n{\n    final LinkedHashSet&lt;T&gt; set;\n\n    set = new LinkedHashSet&lt;T&gt;(list); \n    list.clear(); \n    list.addAll(set);\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In Python"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; L = [2, 1, 4, 3, 5, 1, 2, 1, 1, 6, 5]\n&gt;&gt;&gt; a=[]\n&gt;&gt;&gt; for i in L:\n...   if not i in a:\n...     a.append(i)\n...\n&gt;&gt;&gt; print a\n[2, 1, 4, 3, 5, 6]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It depends on what you mean by \"efficently\".", "The naive algorithm is O(n^2), and I assume what you actually mean is that you want something of lower order than that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As Maxim100 says, you can preserve the order by pairing the list with a series of numbers, use any algorithm you like, and then resort the remainder back into their original order.", "In Haskell it would look like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n superNub :: (Ord a) =&gt; [a] -&gt; [a]\nsuperNub xs = map snd \n              . sortBy (comparing fst) \n              . map head . groupBy ((==) `on` snd) \n              . sortBy (comparing snd) \n              . zip [1..] $ xs\n</code>\n</pre>\n", "senID": 2}, {"text": ["Of course you need to import Data.List (sort), Data.Function (on) and Data.Ord (comparing).", "I could just recite the definitions of those functions, but what would be the point?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["One line solution in Python.", "Using lists-comprehesion:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "One line solution in Python", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; L = [2, 1, 4, 3, 5, 1, 2, 1, 1, 6, 5]\n&gt;&gt;&gt; M = []\n&gt;&gt;&gt; zip(*[(e,M.append(e)) for e in L if not e in M])[0]\n(2, 1, 4, 3, 5, 6)\n</code>\n</pre>\n", "senID": 1}], [{"tag": "ul", "num": 4, "lis": [{"text": "go through the list and assign sequential index to each item", "tag": "none", "senID": 0}, {"text": "sort the list basing on some comparison function for elements", "tag": "none", "senID": 1}, {"text": "remove duplicates", "tag": "none", "senID": 2}, {"text": "sort the list basing on assigned indices", "tag": "none", "senID": 3}]}, {"text": ["for simplicity indices for items may be stored in something like std::map"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["looks like O(n*log n) if I haven't missed anything"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Maybe you should look into using associate arrays (aka dict in python) to avoid having duplicate elements in the first place."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Delete duplicates in a list inplace in Python"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["That is we can't use set (dict) or sort."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "sort", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import islice\n\ndef del_dups2(lst):\n    \"\"\"O(n**2) algorithm, O(1) in memory\"\"\"\n    pos = 0\n    for item in lst:\n        if all(item != e for e in islice(lst, pos)):\n            # we haven't seen `item` yet\n            lst[pos] = item\n            pos += 1\n    del lst[pos:]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Solution is taken from here:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/89178/in-python-what-is-the-fastest-algorithm-for-removing-duplicates-from-a-list-so-t/282589#282589"}]}, {"code": "<pre>\n<code>\n def del_dups(seq):\n    \"\"\"O(n) algorithm, O(log(n)) in memory (in theory).\"\"\"\n    seen = {}\n    pos = 0\n    for item in seq:\n        if item not in seen:\n            seen[item] = True\n            seq[pos] = item\n            pos += 1\n    del seq[pos:]\n</code>\n</pre>\n", "senID": 4}, {"text": ["That is we can use sort.", "This solution doesn't preserve original order."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "sort", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def del_dups3(lst):\n    \"\"\"O(n*log(n)) algorithm, O(1) memory\"\"\"\n    lst.sort()\n    it = iter(lst)\n    for prev in it: # get the first element \n        break\n    pos = 1 # start from the second element\n    for item in it: \n        if item != prev: # we haven't seen `item` yet\n            lst[pos] = prev = item\n            pos += 1\n    del lst[pos:]\n</code>\n</pre>\n", "senID": 6}]]