[[{"text": ["GIL is still there in CPython 3.1; the Unladen Swallow projects aims (among many other performance boosts) to eventually remove it, but it's still a way from its goals, and is working on 2.6 first with the intent of eventually porting to 3.x for whatever x will be current by the time the 2.y version is considered to be done.", "For now, multiprocessing (instead of threading) remains the way of choice for using multiple cores in CPython (IronPython and Jython are fine too, but they don't support Python 3 currently, nor do they make C++ integration all that easy either;-)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Unladen Swallow", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/unladen-swallow/"}]}], [{"text": ["The GIL is a good thing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Just make your C++ application release the GIL while it is doing its multithreaded work.", "Python code will continue to run in the other threads, unspoiled.", "Only acquire the GIL when you have to touch python objects."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The GIL will not affect your code which does not use python objects.", "In Numpy, we release the GIL for computational code (linear algebra calls, etc...), and the underlying code can use multithreading freely (in fact, those are generally 3rd party libraries which do not know anything about python)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Significant changes will occur in the GIL for Python 3.2.", "Take a look at the What's New for Python 3.2, and the thread that initiated it in the mailing list."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "What's New for Python 3.2", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/py3k/whatsnew/3.2.html#multi-threading"}, {"href": "http://mail.python.org/pipermail/python-dev/2009-October/093359.html", "text": "the thread that initiated it in the mailing list", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["While the changes don't signify the end of the GIL, they herald potentially enormous performance gains."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Update0"], "childNum": 0, "tag": "h2", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "The general performance gains with the new GIL in 3.2 by Antoine Pitrou were negligible, and instead focused on ", "tag": "none", "senID": 3}, {"text": "An ", "tag": "none", "senID": 4}, {"text": "The Unladen Swallow work was ", "tag": "none", "senID": 5}]}, {"text": ["Efforts have been made for the last 15 years to remove the GIL from CPython but for the foreseeable future it is here to stay."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I guess there will always be a GIL.", "The reason is performance.", "Making all the low level access thread safe - means putting a mutex around each hash operation etc.", "is heavy.", "Remember that a simple statement like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n self.foo(self.bar, 3, val)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Might already have at least 3 (if val is a global) hashtable lookups at the moment and maybe even much more if the method cache is not hot (depending on the inheritance depth of the class)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It's expensive - that's why Java dropped the idea and introduced hashtables which do not use a monitor call to get rid of its \"Java Is Slow\" trademark."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["As I understand it the \"brainfuck\" scheduler will replace the GIL from python 3.2"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["BFS bainfuck scheduler"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "BFS bainfuck scheduler", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bugs.python.org/issue7946"}]}], [{"text": ["If the GIL is getting in the way, just use the multiprocessing module.", "It spawns new processes but uses the threading model and (most of the) api.", "In other words, you can do process-based parallelism in a thread-like way."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "multiprocessing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/multiprocessing.html"}]}]]