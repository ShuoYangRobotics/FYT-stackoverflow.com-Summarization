[[{"text": ["It would be best if you could write a mock urlopen (and possibly Request) which provides the minimum required interface to behave like urllib2's version.", "You'd then need to have your function/method which uses it able to accept this mock urlopen somehow, and use urllib2.urlopen otherwise."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "urllib2.urlopen", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This is a fair amount of work, but worthwhile.", "Remember that python is very friendly to ducktyping, so you just need to provide some semblance of the response object's properties to mock it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class MockResponse(object):\n    def __init__(self, resp_data, code=200, msg='OK'):\n        self.resp_data = resp_data\n        self.code = code\n        self.msg = msg\n        self.headers = {'content-type': 'text/xml; charset=utf-8'}\n\n    def read(self):\n        return self.resp_data\n\n    def getcode(self):\n        return self.code\n\n    # Define other members and properties you want\n\ndef mock_urlopen(request):\n    return MockResponse(r'&lt;xml document&gt;')\n</code>\n</pre>\n", "senID": 3}, {"text": ["Granted, some of these are difficult to mock, because for example I believe the normal \"headers\" is an HTTPMessage which implements fun stuff like case-insensitive header names.", "But, you might be able to simply construct an HTTPMessage with your response data."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["urllib2 has a functions called build_opener() and install_opener() which you should use to mock the behaviour of urlopen()"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "build_opener()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "install_opener()", "childNum": 0, "tag": "code", "childList": []}, {"text": "urlopen()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import urllib2\nfrom StringIO import StringIO\n\ndef mock_response(req):\n    if req.get_full_url() == \"http://example.com\":\n        resp = urllib2.addinfourl(StringIO(\"mock file\"), \"mock message\", req.get_full_url())\n        resp.code = 200\n        resp.msg = \"OK\"\n        return resp\n\nclass MyHTTPHandler(urllib2.HTTPHandler):\n    def http_open(self, req):\n        print \"mock opener\"\n        return mock_response(req)\n\nmy_opener = urllib2.build_opener(MyHTTPHandler)\nurllib2.install_opener(my_opener)\n\nresponse=urllib2.urlopen(\"http://example.com\")\nprint response.read()\nprint response.code\nprint response.msg\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Build a separate class or module responsible for communicating with your external feeds."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Make this class able to be a test double.", "You're using python, so you're pretty golden there; if you were using C#, I'd suggest either in interface or virtual methods."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "test double", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.martinfowler.com/bliki/TestDouble.html"}]}, {"text": ["In your unit test, insert a test double of the external feed class.", "Test that your code uses  the class correctly, assuming that the class does the work of communicating with your external resources correctly.", "Have your test double return fake data rather than live data; test various combinations of the data and of course the possible exceptions urllib2 could throw. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Aand... that's it."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You can't effectively automate unit tests that rely on external sources, so you're best off not doing it.", "Run an occasional integration test on your communication module, but don't include those tests as part of your automated tests. "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "not doing it", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Edit: "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Just a note on the difference between my answer and @Crast's answer.", "Both are essentially correct, but they involve different approaches.", "In Crast's approach, you use a test double on the library itself.", "In my approach, you abstract the use of the library away into a separate module and test double that module. "], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "@Crast", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "#2276727"}]}, {"text": ["Which approach you use is entirely subjective; there's no \"correct\" answer there.", "I prefer my approach because it allows me to build more modular, flexible code, something I value.", "But it comes at a cost in terms of additional code to write, something that may not be valued in many agile situations. "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["You can use pymox to mock the behavior of anything and everything in the urllib2 (or any other) package.", "It's 2010, you shouldn't be writing your own mock classes."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pymox", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/pymox/"}]}], [{"text": ["I think the easiest thing to do is to actually create a simple web server in your unit test.", "When you start the test, create a new thread that listens on some arbitrary port and when a client connects just returns a known set of headers and XML, then terminates."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I can elaborate if you need more info."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here's some code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import threading, SocketServer, time\n\n# a request handler\nclass SimpleRequestHandler(SocketServer.BaseRequestHandler):\n    def handle(self):\n        data = self.request.recv(102400) # token receive\n        senddata = file(self.server.datafile).read() # read data from unit test file\n        self.request.send(senddata)\n        time.sleep(0.1) # make sure it finishes receiving request before closing\n        self.request.close()\n\ndef serve_data(datafile):\n    server = SocketServer.TCPServer(('127.0.0.1', 12345), SimpleRequestHandler)\n    server.datafile = datafile\n    http_server_thread = threading.Thread(target=server.handle_request())\n</code>\n</pre>\n", "senID": 3}, {"text": ["To run your unit test, call serve_data() then call your code that requests a URL that looks like http://localhost:12345/anythingyouwant."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "serve_data()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "http://localhost:12345/anythingyouwant", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Why not just mock a website that returns the response you expect?", "then start the server in a thread in setup and kill it in the teardown.", "I ended up doing this for testing code that would send email by mocking an smtp server and it works great.", "Surely something more trivial could be done for http... "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "mock a website", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/basehttpserver.html"}]}, {"code": "<pre>\n<code>\n from smtpd import SMTPServer\nfrom time import sleep\nimport asyncore\nSMTP_PORT = 6544\n\nclass MockSMTPServer(SMTPServer):\n    def __init__(self, localaddr, remoteaddr, cb = None):\n        self.cb = cb\n        SMTPServer.__init__(self, localaddr, remoteaddr)\n\n    def process_message(self, peer, mailfrom, rcpttos, data):\n        print (peer, mailfrom, rcpttos, data)\n        if self.cb:\n            self.cb(peer, mailfrom, rcpttos, data)\n        self.close()\n\ndef start_smtp(cb, port=SMTP_PORT):\n\n    def smtp_thread():\n        _smtp = MockSMTPServer((\"127.0.0.1\", port), (None, 0), cb)\n        asyncore.loop()\n        return Thread(None, smtp_thread)\n\n\ndef test_stuff():\n        #.......snip noise\n        email_result = None\n\n        def email_back(*args):\n            email_result = args\n\n        t = start_smtp(email_back)\n        t.start()\n        sleep(1)\n\n        res.form[\"email\"]= self.admin_email\n        res = res.form.submit()\n        assert res.status_int == 302,\"should've redirected\"\n\n\n        sleep(1)\n        assert email_result is not None, \"didn't get an email\"\n</code>\n</pre>\n", "senID": 1}]]