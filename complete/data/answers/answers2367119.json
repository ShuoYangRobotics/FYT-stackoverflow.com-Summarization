[[{"text": ["You could define a __cmp__ method on the class and always raise an exception when it is called.", "That might do the trick."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__cmp__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Out of curiosity, why?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["As Will McCutchen has mentioned, you can define a __cmp__ method that raises an exception to prevent garden variety sorting.", "Something like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__cmp__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Foo(object):\n    def __cmp__(self, other):\n        raise Exception()\n\na = [Foo(), Foo(), Foo()]\na.sort()\nTraceback (most recent call last):\n    File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n    File \"&lt;stdin&gt;\", line 3, in __cmp__\nException\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, you cannot truly prevent a developer from sorting a list of your objects.", "Using the key or cmp argument with list.sort() or with the built-in standalone sorted() function , anyone can circumvent the __cmp__ method by using a custom comparison function or sorting key."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "key", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "cmp", "childNum": 0, "tag": "code", "childList": []}, {"text": "list.sort()", "childNum": 0, "tag": "code", "childList": []}, {"text": "sorted()", "childNum": 0, "tag": "code", "childList": []}, {"text": "__cmp__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n # continuing from above\n&gt;&gt;&gt; a = [Foo(), Foo(), Foo()]\n&gt;&gt;&gt; a\n[&lt;__main__.Foo object at 0x1004a3350&gt;, &lt;__main__.Foo object at 0x1004a3390&gt;,\n &lt;__main__.Foo object at 0x1004a33d0&gt;]\n\n&gt;&gt;&gt; a.sort(key=id, reverse=True)\n&gt;&gt;&gt; # or a.sort(cmp=lambda a, b: cmp(id(b), id(a)))\n&gt;&gt;&gt; # or sorted(a, key=id)\n&gt;&gt;&gt; # etc...\n[&lt;__main__.Foo object at 0x1004a33d0&gt;, &lt;__main__.Foo object at 0x1004a3390&gt;,\n &lt;__main__.Foo object at 0x1004a3350&gt;]\n</code>\n</pre>\n", "senID": 3}, {"text": ["As others will point out, I'm not sure there's much value in trying to prevent someone from sorting an object.", "If this isn't just a curious itch you're trying to scratch, what's the use case for this?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The default list sorting uses the built-in cmp() function on its elements.", "The cmp() function checks if its arguments (2 elements from your list) have a __cmp__() method.", "If yes, this method is used for comparison.", "Otherwise, as in your case, the argument object IDs (return value of the built-in function id()) are used for comparison."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "cmp()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "cmp()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__cmp__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "id()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["To let the sorting fail, you could define a comparison method which throws an Exception:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class X(object):\n...    def __cmp__(self, other):\n...        raise StandardError # or whatever Exception you need\n...\n&gt;&gt;&gt; l = [X(), X(), X()]\n&gt;&gt;&gt; l.sort()\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 2, in __cmp__\nStandardError\n</code>\n</pre>\n", "senID": 2}], [{"text": ["For what it's worth, in Python 3 the default will be for new items to not be comparable (and hence not sortable).", "In Python 2, you have to explicitly create a __cmp__ or __lt__ method, as others have said."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__cmp__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__lt__", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Why don't you just write a class that contains a list object and provides methods to access the data inside?", "By doing that you would effectively hide the list and therefore prevent them from sorting it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Sets don't have a total ordering"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s=set((1,2,3))\n&gt;&gt;&gt; t=set(\"abc\")\n&gt;&gt;&gt; s&lt;t\nFalse\n&gt;&gt;&gt; t&lt;s\nFalse\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["But no exception is raise when you try to sort them"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sorted([s,t])\n[set([1, 2, 3]), set(['a', 'c', 'b'])]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The python sort algorithms use the __lt__ special method.", "Keeping in mind that using the cmp and key arguments of the sorting function and methods, it is suggested that your class defines a method:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__lt__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "cmp", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "key", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def __lt__(self, other):\n    raise NotImplementedError\n</code>\n</pre>\n", "senID": 1}]]