[[{"text": ["Here's the lazy iterator approach:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import tee\n\ndef split_on_condition(seq, condition):\n    l1,l2 = tee((condition(item),item) for item in seq)\n    return (i for p, i in l1 if p), (i for p, i in l2 if not p)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It evaluates the condition once per item and returns two generators, first yielding values from the sequence where the condition is true, the other where it's false."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Because it's lazy you can use it on any iterator, even an infinite one:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from itertools import count, islice\n\ndef is_prime(n):\n    return n &gt; 1 and all(n % i for i in xrange(2,n))\n\nprimes, not_primes = split_on_condition(count(), is_prime)\nprint(\"First 10 primes\", list(islice(primes, 10)))\nprint(\"First 10 non-primes\", list(islice(not_primes, 10)))\n</code>\n</pre>\n", "senID": 4}, {"text": ["Usually though the non-lazy list returning approach is better:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def split_on_condition(seq, condition):\n    a, b = [], []\n    for item in seq:\n        (a if condition(item) else b).append(item)\n    return a,b\n</code>\n</pre>\n", "senID": 6}, {"text": ["Edit: For your more specific usecase of splitting items into different lists by some key, heres a generic function that does that:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n DROP_VALUE = lambda _:_\ndef split_by_key(seq, resultmapping, keyfunc, default=DROP_VALUE):\n    \"\"\"Split a sequence into lists based on a key function.\n\n        seq - input sequence\n        resultmapping - a dictionary that maps from target lists to keys that go to that list\n        keyfunc - function to calculate the key of an input value\n        default - the target where items that don't have a corresponding key go, by default they are dropped\n    \"\"\"\n    result_lists = dict((key, []) for key in resultmapping)\n    appenders = dict((key, result_lists[target].append) for target, keys in resultmapping.items() for key in keys)\n\n    if default is not DROP_VALUE:\n        result_lists.setdefault(default, [])\n        default_action = result_lists[default].append\n    else:\n        default_action = DROP_VALUE\n\n    for item in seq:\n        appenders.get(keyfunc(item), default_action)(item)\n\n    return result_lists\n</code>\n</pre>\n", "senID": 8}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n def file_extension(f):\n    return f[2].lower()\n\nsplit_files = split_by_key(files, {'images': IMAGE_TYPES}, keyfunc=file_extension, default='anims')\nprint split_files['images']\nprint split_files['anims']\n</code>\n</pre>\n", "senID": 10}], [{"text": ["That code is perfectly readable, and extremely clear!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # files looks like: [ ('file1.jpg', 33L, '.jpg'), ('file2.avi', 999L, '.avi'), ... ]\nIMAGE_TYPES = ('.jpg','.jpeg','.gif','.bmp','.png')\nimages = [f for f in files if f[2].lower() in IMAGE_TYPES]\nanims  = [f for f in files if f[2].lower() not in IMAGE_TYPES]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Again, this is fine!"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "fine!", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["There might be slight performance improvements using sets, but it's a trivial difference, and I find the list comprehension far easier to read, and you don't have to worry about the order being messed up, duplicates being removed as so on."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["In fact, I may go another step \"backward\", and just use a simple for loop:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n images, anims = [], []\n\nfor f in files:\n    if f.lower() in IMAGE_TYPES:\n        images.append(f)\n    else:\n        anims.append(f)\n</code>\n</pre>\n", "senID": 5}, {"text": ["The a list-comprehension or using set() is fine until you need to add some other check or another bit of logic - say you want to remove all 0-byte jpeg's, you just add something like.."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "set()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if f[1] == 0:\n    continue\n</code>\n</pre>\n", "senID": 7}], [{"text": ["First go (pre-OP-edit): Use sets:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "First go", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n mylist = [1,2,3,4,5,6,7]\ngoodvals = [1,3,7,8,9]\n\nmyset = set(mylist)\ngoodset = set(goodvals)\n\nprint list(myset.intersection(goodset))  # [1, 3, 7]\nprint list(myset.difference(goodset))    # [2, 4, 5, 6]\n</code>\n</pre>\n", "senID": 1}, {"text": ["That's good for both readability (IMHO) and performance."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Second go (post-OP-edit):"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Second go", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Create your list of good extensions as a set:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n IMAGE_TYPES = set(['.jpg','.jpeg','.gif','.bmp','.png'])\n</code>\n</pre>\n", "senID": 5}, {"text": ["and that will increase performance.", "Otherwise, what you have looks fine to me."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Problem with all proposed solutions is that it will scan and apply the filtering function twice.", "I'd make a simple small function like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def SplitIntoTwoLists(l, f):\n  a = []\n  b = []\n  for i in l:\n    if f(i):\n      a.append(i)\n    else:\n      b.append(i)\n return (a,b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["That way you are not processing anything twice and also are not repeating code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Personally, I like the version you cited, assuming you already have a list of goodvals hanging around.", "If not, something like:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "goodvals", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n good = filter(lambda x: is_good(x), mylist)\nbad = filter(lambda x: !is_good(x), mylist)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course, that's really very similar to using a list comprehension like you originally did, but with a function instead of a lookup:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n good = [x for x in mylist if is_good(x)]\nbad  = [x for x in mylist if !is_good(x)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["In general, I find the aesthetics of list comprehensions to be very pleasing.", "Of course, if you don't actually need to preserve ordering and don't need duplicates, using the intersection and difference methods on sets would work well too."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "intersection", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "difference", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["itertools.groupby almost does what you want, except it requires the items to be sorted to ensure that you get a single contiguous range, so you need to sort by your key first (otherwise you'll get multiple interleaved groups for each type).", "eg."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.groupby", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.groupby"}]}, {"code": "<pre>\n<code>\n def is_good(f):\n    return f[2].lower() in IMAGE_TYPES\n\nfiles = [ ('file1.jpg', 33L, '.jpg'), ('file2.avi', 999L, '.avi'), ('file3.gif', 123L, '.gif')]\n\nfor key, group in itertools.groupby(sorted(files, key=is_good), key=is_good):\n    print key, list(group)\n</code>\n</pre>\n", "senID": 1}, {"text": ["gives:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n False [('file2.avi', 999L, '.avi')]\nTrue [('file1.jpg', 33L, '.jpg'), ('file3.gif', 123L, '.gif')]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Similar to the other solutions, the key func can be defined to divide into any number of groups you want."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I agree with RIchieHindle.", "you can also check this link\nhttp://house.hcn-strela.ru/doc/python/lib/types-set.html"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "http://house.hcn-strela.ru/doc/python/lib/types-set.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://house.hcn-strela.ru/doc/python/lib/types-set.html"}]}], [{"text": ["For perfomance, try itertools."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["See itertools.ifilter or imap."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "itertools.ifilter", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.ifilter"}]}], [{"text": ["If you want to make it in FP style:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n good, bad = [ sum(x, []) for x in zip(*(([y], []) if y in goodvals else ([], [y])\n                                        for y in mylist)) ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Not the most readable solution, but at least iterates through mylist only once."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I basically like Anders' approach as it is very general.", "Here's a version that puts the categorizer first (to match filter syntax) and uses a defaultdict (assumed imported)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def categorize(func, seq):\n    \"\"\"Return mapping from categories to lists\n    of categorized items.\n    \"\"\"\n    d = defaultdict(list)\n    for item in seq:\n        d[func(item)].append(item)\n    return d\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you insist on clever, you could take Winden's solution and just a bit spurious cleverness:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def splay(l, f, d=None):\n  d = d or {}\n  for x in l: d.setdefault(f(x), []).append(x)\n  return d\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Sometimes you won't need that other half of the list.", "For example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\nfrom itertools import ifilter\n\ntrustedPeople = sys.argv[1].split(',')\nnewName = sys.argv[2]\n\nmyFriends = ifilter(lambda x: x.startswith('Shi'), trustedPeople)\n\nprint '%s is %smy friend.' % (newName, newName not in myFriends 'not ' or '')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["My take on it.", "I propose a lazy, single-pass, splitBy function, which preserves relative order in the output subsequences."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "splitBy", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I assume that the requirements are:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "maintain elements' relative order (hence, no sets and dictionaries)", "tag": "none", "senID": 2}, {"text": "evaluate condition only once for every element (hence not using (", "tag": "none", "senID": 3}, {"text": "allow for lazy consumption of either sequence (if we can afford to precomute them, then the na\u00efve implementation is likely to be acceptable too)", "tag": "none", "senID": 4}]}, {"text": ["Internally we need to build two subsequences at once, so consuming only one output sequence will force the other one to be computed too.", "And we need to keep state between user requests (store processed but not yet requested elements).", "To keep state, I use two double-ended queues (deques):"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "deques", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n from collections import deque\n</code>\n</pre>\n", "senID": 6}, {"text": ["SplitSeq class takes care of the housekeeping:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "SplitSeq", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class SplitSeq:\n    def __init__(self, condition, sequence):\n        self.cond = condition\n        self.goods = deque([])\n        self.bads = deque([])\n        self.seq = iter(sequence)\n</code>\n</pre>\n", "senID": 8}, {"text": ["Magic happens in its .getNext() method.", "It is almost like .next() of the iterators, but allows to specify which kind of element we want this time.", "Behind the scene it doesn't discard the rejected elements, but instead puts them in one of the two queues:"], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": ".getNext()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".next()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def getNext(self, getGood=True):\n        if getGood:\n            these, those, cond = self.goods, self.bads, self.cond\n        else:\n            these, those, cond = self.bads, self.goods, lambda x: not self.cond(x)\n        if these:\n            return these.popleft()\n        else:\n            while 1: # exit on StopIteration\n                n = self.seq.next()\n                if cond(n):\n                    return n\n                else:\n                    those.append(n)\n</code>\n</pre>\n", "senID": 10}, {"text": ["The end user is supposed to use splitBy function.", "It takes a condition function and a sequence (just like map or filter), and returns two generators.", "The first generator builds a subsequence of elements for which the condition holds, the second one builds the complementary subsequence.", "Iterators and generators allow for lazy splitting of even long or infinite sequences."], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "splitBy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "filter", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def splitBy(condition, sequence):\n    cond = condition if condition else bool  # evaluate as bool if condition == None\n    ss = SplitSeq(cond, sequence)\n    def goods():\n        while 1:\n            yield ss.getNext(getGood=True)\n    def bads():\n        while 1:\n            yield ss.getNext(getGood=False)\n    return goods(), bads()\n</code>\n</pre>\n", "senID": 12}, {"text": ["I choose the test function to be the first argument to facilitate partial application in the future (similar to how map and filter have the test function as the first argument)."], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "filter", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The complete source code with comments and documentations is available on bitbucket.", "Download this file:"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "on bitbucket", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://bitbucket.org/jetxee/python-split/src/"}]}, {"tag": "ul", "num": 1, "lis": [{"text": ["splitBy.py"], "childNum": 1, "tag": "a", "senID": 15, "childList": [{"text": "splitBy.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}, {"text": ["In your case, let the input data be:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; IMAGE_TYPES = ('.jpg','.jpeg','.gif','.bmp','.png')\n&gt;&gt;&gt; files = [ ('file1.jpg', 33L, '.jpg'),\n              ('file2.avi', 999L, '.avi'),\n              ('file3.png', 48L, '.png') ]\n</code>\n</pre>\n", "senID": 17}, {"text": ["Then to separate animations from images, we create a condition function and call splitBy:"], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "splitBy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def isAnim(f): return (f[2].lower() not in IMAGE_TYPES)\n&gt;&gt;&gt; anims, images = splitBy(isAnim, files)\n&gt;&gt;&gt; list(anims)\n[('file2.avi', 999L, '.avi')]\n&gt;&gt;&gt; list(images)\n[('file1.jpg', 33L, '.jpg'), ('file3.png', 48L, '.png')]\n</code>\n</pre>\n", "senID": 19}, {"text": ["To consume elements one by one use .next() method of the returned generators."], "childNum": 1, "tag": "p", "senID": 20, "childList": [{"text": ".next()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]