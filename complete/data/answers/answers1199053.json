[[{"code": "<pre>\n<code>\n import bisect\nbisect.bisect_left([100,300,500,800,1000], p)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You could try a take on this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def check_mapping(p):\n    mapping = [(100, 0), (300, 1), (500, 2)] # Add all your values and returns here\n\n    for check, value in mapping:\n        if p &lt;= check:\n            return value\n\nprint check_mapping(12)\nprint check_mapping(101)\nprint check_mapping(303)\n</code>\n</pre>\n", "senID": 1}, {"text": ["produces:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 0\n1\n2\n</code>\n</pre>\n", "senID": 3}, {"text": ["As always in Python, there will be any better ways to do it."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["It is indeed quite horrible.", "Without a requirement to have no hardcoding, it should have been written like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if p &lt;= 100:\n    return 0\nelif p &lt;= 300:\n    return 1\nelif p &lt;= 500:\n    return 2\nelif p &lt;= 800:\n    return 3\nelif p &lt;= 1000:\n    return 4\nelse:\n    return 5\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here are examples of creating a lookup function, both linear and using binary search, with the no-hardcodings requirement fulfilled, and a couple of sanity checks on the two tables:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def make_linear_lookup(keys, values):\n    assert sorted(keys) == keys\n    assert len(values) == len(keys) + 1\n    def f(query):\n        return values[sum(1 for key in keys if query &gt; key)]\n    return f\n\nimport bisect\ndef make_bisect_lookup(keys, values):\n    assert sorted(keys) == keys\n    assert len(values) == len(keys) + 1\n    def f(query):\n        return values[bisect.bisect_left(keys, query)]\n    return f\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Try something along the lines of:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d = {(None,100): 0, \n    (100,200): 1,\n    ...\n    (1000, None): 5}\nvalue = 300 # example value\nfor k,v in d.items():\n    if (k[0] is None or value &gt; k[0]) and (k[1] is None or value &lt;= k[1]):\n        return v\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def which_interval(endpoints, number):\n    for n, endpoint in enumerate(endpoints):\n        if number &lt;= endpoint:\n            return n\n        previous = endpoint\n    return n + 1\n</code>\n</pre>\n", "senID": 0}, {"text": ["Pass your endpoints as a list in endpoints, like this:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "endpoints", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n which_interval([100, 300, 500, 800, 1000], 5)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Edit:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The above is a linear search.", "Glenn Maynard's answer will have better performance, since it uses a bisection algorithm."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Another way ..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def which(lst, p): \n    return len([1 for el in lst if p &gt; el])\n\nlst = [100, 300, 500, 800, 1000]\nwhich(lst, 2)\nwhich(lst, 101)\nwhich(lst, 1001)\n</code>\n</pre>\n", "senID": 1}]]