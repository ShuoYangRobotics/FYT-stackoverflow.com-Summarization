[[{"text": ["If you're trying to check if someone is 18 years of age, using timedelta will not work correctly on some edge cases because of leap years.", "For example, someone born on January 1, 2000, will turn 18 exactly 6575 days later on January 1, 2018 (5 leap years included), but someone born on January 1, 2001, will turn 18 exactly 6574 days later on January 1, 2019 (4 leap years included).", "Thus, you if someone is exactly 6574 days old, you can't determine if they are 17 or 18 without knowing a little more information about their birthdate."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "timedelta", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The correct way to do this is to calculate the age directly from the dates, by subtracting the two years, and then subtracting one if the current month/day precedes the birth month/day."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You need more than a timedelta to tell how many years have passed; you also need to know the beginning (or ending) date.", "(It's a leap year thing.", ")  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "timedelta", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Your best bet is to use the dateutil.relativedelta object, but that's a 3rd party module.", "If you want to know the datetime that was n years from some date (defaulting to right now), you can do the following::"], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "dateutil.relativedelta", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "object", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://labix.org/python-dateutil"}, {"text": "datetime", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from dateutil.relativedelta import relativedelta\n\ndef yearsago(years, from_date=None):\n    if from_date is None:\n        from_date = datetime.now()\n    return from_date - relativedelta(years=years)\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you'd rather stick with the standard library, the answer is a little more complex::"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from datetime import datetime\ndef yearsago(years, from_date=None):\n    if from_date is None:\n        from_date = datetime.now()\n    try:\n        return from_date.replace(year=from_date.year - years)\n    except:\n        # Must be 2/29!\n        assert from_date.month == 2 and from_date.day == 29 # can be removed\n        return from_date.replace(month=2, day=28,\n                                 year=from_date.year-years)\n</code>\n</pre>\n", "senID": 4}, {"text": ["If it's 2/29, and 18 years ago there was no 2/29, this function will return 2/28.", "If you'd rather return 3/1, just change the last return statement to read::"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "return", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n return from_date.replace(month=3, day=1,\n                             year=from_date.year-years)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Your question originally said you wanted to know how many years it's been since some date.", "Assuming you want an integer number of years, you can guess based on 365.25 days per year and then check using either of the yearsago functions defined above::"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "yearsago", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def num_years(begin, end=None):\n    if end is None:\n        end = datetime.now()\n    num_years = int((end - begin).days / 365.25)\n    if begin &gt; yearsago(num_years, end):\n        return num_years - 1\n    else:\n        return num_years\n</code>\n</pre>\n", "senID": 8}], [{"text": ["First off, at the most detailed level, the problem can't be solved exactly.", "Years vary in length, and there isn't a clear \"right choice\" for year length.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That said, get the difference in whatever units are \"natural\" (probably seconds) and divide by the ratio between that and years.", "E.g."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n delta_in_days / (365.25)\ndelta_in_seconds / (365.25*24*60*60)\n</code>\n</pre>\n", "senID": 2}, {"text": ["...or whatever.", "Stay away from months, since they are even less well defined than years."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["How exact do you need it to be?", "td.days / 365.25 will get you pretty close, if you're worried about leap years."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "td.days / 365.25", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Even though this thread is already dead, might i suggest a working solution for this very same problem i was facing.", "Here it is (date is a string in the format dd-mm-yyyy):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def validatedate(date):\n    parts = date.strip().split('-')\n\n    if len(parts) == 3 and False not in [x.isdigit() for x in parts]: \n        birth = datetime.date(int(parts[2]), int(parts[1]), int(parts[0]))\n        today = datetime.date.today()\n\n        b = (birth.year * 10000) + (birth.month * 100) + (birth.day)\n        t = (today.year * 10000) + (today.month * 100) + (today.day)\n\n        if (t - 18 * 10000) &gt;= b:\n            return True\n\n    return False\n</code>\n</pre>\n", "senID": 1}], [{"text": ["this function returns the difference in years between two dates (taken as strings in ISO format, but it can easily modified to take in any format)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import time\ndef years(earlydateiso,  laterdateiso):\n    \"\"\"difference in years between two dates in ISO format\"\"\"\n\n    ed =  time.strptime(earlydateiso, \"%Y-%m-%d\")\n    ld =  time.strptime(laterdateiso, \"%Y-%m-%d\")\n    #switch dates if needed\n    if  ld &lt; ed:\n        ld,  ed = ed,  ld            \n\n    res = ld[0] - ed [0]\n    if res &gt; 0:\n        if ld[1]&lt; ed[1]:\n            res -= 1\n        elif  ld[1] == ed[1]:\n            if ld[2]&lt; ed[2]:\n                res -= 1\n    return res\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def age(dob):\n    import datetime\n    today = datetime.date.today()\n\n    if today.month &lt; dob.month or \\\n      (today.month == dob.month and today.day &lt; dob.day):\n        return today.year - dob.year - 1\n    else:\n        return today.year - dob.year\n\n&gt;&gt;&gt; import datetime\n&gt;&gt;&gt; datetime.date.today()\ndatetime.date(2009, 12, 1)\n&gt;&gt;&gt; age(datetime.date(2008, 11, 30))\n1\n&gt;&gt;&gt; age(datetime.date(2008, 12, 1))\n1\n&gt;&gt;&gt; age(datetime.date(2008, 12, 2))\n0\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I'll suggest Pyfdate "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Pyfdate", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ferg.org/pyfdate/index.html"}]}, {"text": ["the tutorial"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "tutorial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ferg.org/pyfdate/tutorial.html"}]}], [{"text": ["Yet another 3rd party lib not mentioned here is mxDateTime (predecessor of both python datetime and 3rd party timeutil) could be used for this task."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "datetime", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "timeutil", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The aforementioned yearsago would be:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "yearsago", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from mx.DateTime import now, RelativeDateTime\n\ndef years_ago(years, from_date=None):\n    if from_date == None:\n        from_date = now()\n    return from_date-RelativeDateTime(years=years)\n</code>\n</pre>\n", "senID": 2}, {"text": ["First parameter is expected to be a DateTime instance."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "DateTime", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["To convert ordinary datetime to DateTime you could use this for 1 second precision):"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "datetime", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "DateTime", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def DT_from_dt_s(t):\n    return DT.DateTimeFromTicks(time.mktime(t.timetuple()))\n</code>\n</pre>\n", "senID": 5}, {"text": ["or this for 1 microsecond precision:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def DT_from_dt_u(t):\n    return DT.DateTime(t.year, t.month, t.day, t.hour,\n  t.minute, t.second + t.microsecond * 1e-6)\n</code>\n</pre>\n", "senID": 7}, {"text": ["And yes, adding the dependency for this single task in question would definitely be an overkill compared even with using timeutil (suggested by Rick Copeland)."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Get the number of days, then divide by 365.2425 (the mean Gregorian year) for years.", "Divide by 30.436875 (the mean Gregorian month) for months."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In the end what you have is a maths issue.", "If every 4 years we have an extra day lets then dived the timedelta in days, not by 365 but 365*4 + 1, that would give you the amount of 4 years.", "Then divide it again by 4. \ntimedelta / ((365*4) +1) / 4 = timedelta * 4 / (365*4 +1)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["This is the solution I worked out, I hope can help ;-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def menor_edad_legal(birthday):\n    \"\"\" returns true if aged&lt;18 in days \"\"\" \n    try:\n\n        today = time.localtime()                        \n\n        fa_divuit_anys=date(year=today.tm_year-18, month=today.tm_mon, day=today.tm_mday)\n\n        if birthday&gt;fa_divuit_anys:\n            return True\n        else:\n            return False            \n\n    except Exception, ex_edad:\n        logging.error('Error menor de edad: %s' % ex_edad)\n        return True\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Well, question seems rather easy.", "You need to check the number of 'full' years, and only if it's equal to 18 you need to bother with months and days.", "The edge case is: endDate.year - startDate.year == 18 and it splits to two cases: startDate.month != endDate.month and startDate.month == endDate.month, when you just have to check days:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "endDate.year - startDate.year == 18", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "startDate.month != endDate.month", "childNum": 0, "tag": "code", "childList": []}, {"text": "startDate.month == endDate.month", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def isOfAge(birthDate, age=18):\n     endDate = date.today()\n     years = endDate.year - birthDate.year\n     if years == age:\n         return (birthDate.month &lt; endDate.month or \n                  (birthDate.month == endDate.month and birthDate.day &lt; endDate.day))         \n     return years &gt; age\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's still more than one-liner-lambda, but it's still pretty short, and seems quick in execution."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Sorry guys, but non of your answer was useful.", "This is the answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def haveMoreYearsGone(self, d, years):\n    today = date.today()\n    if (d.year + years &lt; today.year):\n        return True\n    if (d.year + years &gt; today.year):\n        return False\n\n    if (d.day == 29 and d.month == 2):\n        d.replace(day=28)\n    if (today.day == 29 and today.month == 2):\n        today.replace(day=28)\n    d.replace(year=today.year)\n    span = today - d\n\n    return (span.days &gt;= 0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Tough luck it can't be made in lambda (in non-obstruficated way)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]