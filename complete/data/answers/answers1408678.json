[[{"text": ["Just set stdout to be line buffered at the beginning of your C program (before performing any output), like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;stdio.h&gt;\nsetvbuf(stdout, NULL, _IOLBF, 0);\n</code>\n</pre>\n", "senID": 1}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;stdio.h&gt;\nsetlinebuf(stdout);\n</code>\n</pre>\n", "senID": 3}, {"text": ["Either one will work on Linux, but setvbuf is part of the C standard so it will work on more systems."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "setvbuf", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["By default stdout will be block buffered for a pipe or file, or line buffered for a terminal.", "Since stdout is a pipe in this case, the default will be block buffered.", "If it is block buffered then the buffer will be flushed when it is full, or when you call fflush(stdout).", "If it is line buffered then it will be flushed automatically after each line."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "fflush(stdout)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["What you need is for your C program to call fflush(stdout) after every line.", "For example, with the GNU grep tool, you can invoke the option '--line-buffered', which causes this behavior.", "See fflush."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "fflush", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "fflush", "tag": "a"}]}, {"text": "fflush", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.thinkage.ca/english/gcos/expl/nsc/lib/fflush.html"}]}], [{"text": ["If you can modify your C program, you've already received your answer but i thought i'd include a solution for those that can't/won't modify code."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1408678/getting-another-programs-output-as-input-on-the-fly/1408730#1408730"}]}, {"text": ["expect has an example script called unbuffer that will do the trick."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "expect", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://expect.sourceforge.net/"}, {"href": "http://expect.sourceforge.net/example/unbuffer.man.html", "text": "unbuffer", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["All the Unix shells (that I know of) implement shell pipelines via something else than a pty\n(typically, they use Unix pipes!-); therefore, the C/C++ runtime library in cpp_program will KNOW its output is NOT a terminal, and therefore it WILL buffer the output (in chunks of a few KB at a time).", "Unless you write your own shell (or semiquasimaybeshelloid) that implements pipelines via pyt's, I believe there is no way to do what you require using pipeline notation."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "cpp_program", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The \"shelloid\" thing in question might be written in Python (or in C, or Tcl, or...), using the pty module of the standard library or higher-level abstraction based on it such as pexpect, and the fact that the two programs to be connected via a \"pty-based pipeline\" are written in C++ and Python is pretty irrelevant.", "The key idea is to trick the program to the left of the pipe into believing its stdout is a terminal (that's why a pty must be at the root of the trick) to fool its runtime library into NOT buffering output.", "Once you have written such a shelloid, you'd call it with some syntax such as:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "pty", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "pexpect", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://pexpect.sourceforge.net/pexpect.html"}]}, {"text": ["$ shelloid 'cpp_program | python_program.py'"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Of course it would be easier to provide a \"point solution\" by writing python_program in the knowledge that it must spawn cpp_program as a sub-process AND trick it into believing its stdout is a terminal (i.e., python_program would then directly use pexpect, for example).", "But if you have a million of such situations where you want to defeat the normal buffering performed by the system-provided C runtime library, or many cases in which you want to reuse existing filters, etc, writing shelloid might actually be preferable."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "python_program", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "cpp_program", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "python_program", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "pexpect", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "shelloid", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You may want to try flushing the stdout stream in the cpp program."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "flush", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["ok this maybe sound stupid but it might work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["output your pgm to a file"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n $ c_program &gt;&gt; ./out.log\n</code>\n</pre>\n", "senID": 2}, {"text": ["develop a python program that read from tail command"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import os\n\ntailoutput = os.popen(\"tail -n 0 -f ./out.log\")\n\ntry:\n    while 1:\n        line = tailoutput.readline()\n        if len(line) == 0:\n            break\n\n        #do the rest of your things here\n        print line\n\nexcept KeyboardInterrupt:\n        print \"Quitting \\n\"\n</code>\n</pre>\n", "senID": 4}]]