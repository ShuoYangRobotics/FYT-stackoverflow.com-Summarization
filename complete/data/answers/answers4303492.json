[[{"text": ["Your code is fine.", "The problem I think you're trying to solve is that if first_word_passed looks a little bit ugly."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "if first_word_passed", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["One option for fixing this is a generator.", "We can easily make this return one thing for first entry and another for all subsequent entries.", "As Python has first-class functions we can get the generator to return the function we want to use to process each word."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["We then just need to use the conditional operator so we can handle the blank entries returned by double underscores within a list comprehension."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "the conditional operator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0308/"}]}, {"text": ["So if we have a word we call the generator to get the function to use to set the case, and if we don't we just use _ leaving the generator untouched. "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "_", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def underscore_to_camelcase(value):\n    def camelcase(): \n        yield str.lower\n        while True:\n            yield str.capitalize\n\n    c = camelcase()\n    return \"\".join(c.next()(x) if x else '_' for x in value.split(\"_\"))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The problem calls for a function that returns a lowercase word the first time, but capitalized words afterwards.", "You can do that with an if clause, but then the if clause has to be evaluated for every word.", "An appealing alternative is to use a generator.", "It can return one thing on the first call, and something else on successive calls, and it does not require as many ifs."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "if", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "if", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def lower_camelcase(seq):\n    it=iter(seq)\n    for word in it:\n        yield word.lower()\n        if word.isalnum(): break\n    for word in it:\n        yield word.capitalize()\n\ndef underscore_to_camelcase(text):\n    return ''.join(lower_camelcase(word if word else '_' for word in text.split('_')))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here is some test code to show that it works:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n tests=[('get__this_value','get_ThisValue'),\n       ('_get__this_value','_get_ThisValue'),\n       ('_get__this_value_','_get_ThisValue_'),\n       ('get_this_value','getThisValue'),        \n       ('get__this__value','get_This_Value'),        \n       ]\nfor test,answer in tests:\n    result=underscore_to_camelcase(test)\n    try:\n        assert result==answer\n    except AssertionError:\n        print('{r!r} != {a!r}'.format(r=result,a=answer))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I think the code is fine.", "You've got a fairly complex specification, so if you insist on squashing it into the Procrustean bed of a list comprehension, then you're likely to harm the clarity of the code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The only changes I'd make would be:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def underscore_to_camelcase(s):\n    \"\"\"Take the underscore-separated string s and return a camelCase\n    equivalent.  Initial and final underscores are preserved, and medial\n    pairs of underscores are turned into a single underscore.\"\"\"\n    def camelcase_words(words):\n        first_word_passed = False\n        for word in words:\n            if not word:\n                yield \"_\"\n                continue\n            if first_word_passed:\n                yield word.capitalize()\n            else:\n                yield word.lower()\n            first_word_passed = True\n    return ''.join(camelcase_words(s.split('_')))\n</code>\n</pre>\n", "senID": 3}, {"text": ["Depending on the application, another change I would consider making would be to memoize the function.", "I presume you're automatically translating source code in some way, and you expect the same names to occur many times.", "So you might as well store the conversion instead of re-computing it each time.", "An easy way to do that would be to use the @memoized decorator from the Python decorator library."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "@memoized", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"href": "http://wiki.python.org/moin/PythonDecoratorLibrary#Memoize", "text": "Python decorator library", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I agree with Gareth that the code is ok.", "However, if you really want a shorter, yet readable approach you could try something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def underscore_to_camelcase(value):\n    # Make a list of capitalized words and underscores to be preserved\n    capitalized_words = [w.capitalize() if w else '_' for w in value.split('_')]\n\n    # Convert the first word to lowercase\n    for i, word in enumerate(capitalized_words):\n        if word != '_':\n            capitalized_words[i] = word.lower()\n            break\n\n    # Join all words to a single string and return it\n    return \"\".join(capitalized_words)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is a list comprehension style generator expression."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import count\ndef underscore_to_camelcase(value):\n    words = value.split('_')\n    counter = count()\n    return ''.join('_' if w == '' else w.capitalize() if counter.next() else w for w in words )\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Another regexp solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef conv(s):\n    \"\"\"Convert underscore-separated strings to camelCase equivalents.\n\n    &gt;&gt;&gt; conv('get')\n    'get'\n    &gt;&gt;&gt; conv('_get')\n    '_get'\n    &gt;&gt;&gt; conv('get_this_value')\n    'getThisValue'\n    &gt;&gt;&gt; conv('__get__this_value_')\n    '_get_ThisValue_'\n    &gt;&gt;&gt; conv('_get__this_value__')\n    '_get_ThisValue_'\n    &gt;&gt;&gt; conv('___get_this_value')\n    '_getThisValue'\n\n    \"\"\"\n    # convert case:\n    s = re.sub(r'(_*[A-Z])', lambda m: m.group(1).lower(), s.title(), count=1)\n    # remove/normalize underscores:\n    s = re.sub(r'__+|^_+|_+$', '|', s).replace('_', '').replace('|', '_')\n    return s\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n</code>\n</pre>\n", "senID": 1}, {"text": ["It works for your examples, but it might fail for names containting digits - it depends how you would capitalize them."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A slightly modified version:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef underscore_to_camelcase(value):\n    first = True\n    res = []\n\n    for u,w in re.findall('([_]*)([^_]*)',value):\n        if first:\n            res.append(u+w)\n            first = False\n        elif len(w)==0:    # trailing underscores\n            res.append(u)\n        else:   # trim an underscore and capitalize\n            res.append(u[:-1] + w.title())\n\n    return ''.join(res)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This one works except for leaving the first word as lowercase."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def convert(word):\n    return ''.join(x.capitalize() or '_' for x in word.split('_'))\n</code>\n</pre>\n", "senID": 1}, {"text": ["(I know this isn't exactly what you asked for, and this thread is quite old, but since it's quite prominent when searching for such conversions on Google I thought I'd add my solution in case it helps anyone else)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A one liner using generator expressions;"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ''.join(item.title() for item in a.split('_'))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit:\nSame expression with a '_' before and after"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n '_%s_' % ''.join(item.title() for item in a.split('_'))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This is the most compact way to do it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def underscore_to_camelcase(value):\n    words = [word.capitalize() for word in value.split('_')]\n    words[0]=words[0].lower()\n    return \"\".join(words)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["For regexp sake !"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef underscore_to_camelcase(value):\n    def rep(m):\n        if m.group(1) != None:\n            return m.group(2) + m.group(3).lower() + '_'\n        else:\n            return m.group(3).capitalize()\n\n    ret, nb_repl = re.subn(r'(^)?(_*)([a-zA-Z]+)', rep, value)\n    return ret if (nb_repl &gt; 1) else ret[:-1]\n</code>\n</pre>\n", "senID": 1}]]