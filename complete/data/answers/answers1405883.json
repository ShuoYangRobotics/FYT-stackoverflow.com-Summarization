[[{"text": ["Just a thought, and it does little for documentation, but why not try:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def masterFunc(x):\n    firstFunc(x)\n    secondFunc(x)\n    process(x)\n    return x.discard\n\nsecondList = [ x for x in firstList if masterFunc(x) ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Good news: does what you asked, strictly speaking.", "Bad news: it hides firstFunc, secondFunc, and process"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It sounds like you already have trouble with side-effects and command/query separation in the example, so I'm thinking that this hack is not as noble as cleaning up the code a bit.", "You might find that some methods need inverted (x.firstFunc() instead of firstFunc(x)) and others need broken up.", "There may even be a nicer way than 'x.discard' to deal with filtering."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You know, your best solution is really to just initialize secondList how you like, and do all three functions in a regular loop, since they're all dependent and contain logic that is not just filtering (you say process sets attributes...", "I'm assuming you mean other than discard):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # If secondList not initialized...\nsecondList = []\nfor x in firstList:\n    firstFunc(x)\n    secondFunc(x)\n    process(x)\n    if not x.discard:\n        secondList.append(x)\n</code>\n</pre>\n", "senID": 1}, {"text": ["List comprehensions don't help too much here since you're doing processing in each function (they take a line or two off though; depends on what you're looking for in \"clean\" code).", "If all process() did was return True if the item should be in the new list, and False if the item should not be in the new list, then the below would really be better, IMO."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "hr", "senID": 3}, {"text": ["If firstFunc(x) and secondFunc(x) do change the result of x.discard after process(), and the result of process(x) is just x, I would do the following in your situation:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n for x in firstList:\n    firstFunc(x)\n    secondFunc(x)\nsecondList = [ x for x in firstList if not process(x).discard ]\n</code>\n</pre>\n", "senID": 5}, {"text": ["If the result of process(x) is different from x though, as your sample appears to indicate, you could also change that last line to the following:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n interimList = [ process(x) for x in firstList ]\nsecondList = [ x for x in interimList if not x.discard ]\n</code>\n</pre>\n", "senID": 7}, {"text": ["Note that if you wanted to append these results to secondList, use secondList.extend([...])."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Edit: I realized I erroneously wrote \"do not\" change, but I meant if they do change the result of process()."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Edit 2: Cleanup description / code."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["Edit: process(x) is necessary for x.discard, meaning that the answer is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["No there is no cleaner way.", "And the way you are doing it is already clean."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "No there is no cleaner way. And the way you are doing it is already clean.", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Old answer:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Not really, no.", "You can make this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def process_item(x):\n    firstFunc(x)\n    secondFunc(x)\n    x = process(x)\n\ndef test_item(x):\n    return x.discard == False\n\nlist = [process_item(x) for x in firstList if test_item(x)]\n</code>\n</pre>\n", "senID": 4}, {"text": ["But that is not cleaner, and also it requires x.discard to be set before you process it, which it doesn't seem to be from your code."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["List comprehensions are not \"cleaner\".", "They are shorter ways of writing simple list processing.", "You list processing involves three steps.", "That's not really \"simple\".", ":)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["a few things: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "you cannot ", "tag": "none", "senID": 1}, {"text": "no need for ", "tag": "none", "senID": 2}, {"text": "you'd rather create a new list with values that you don't want to discard and don't pollute your loop with removal.", "tag": "none", "senID": 3}]}, {"text": ["so you'd have something along the lines:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n tmp = []\nfor x in first_list:\n    x = process(x)\n    if not x.discard:\n        tmp.append(x)\nsecond_list.extend(tmp)\n</code>\n</pre>\n", "senID": 5}, {"text": ["list comprehension would obviously more pythonic, though:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n [i for i in first_list if not process(i).discard]\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Sounds like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def allProcessing(x)\n  firstFunc(x)\n  secondFunc(x)\n  return !(process(x).discard)\n\nnewList = filter(allProcessing, oldList)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Write this as two list comprehensions, one which assembles the data that might need filtering, and another which does the filtering.", "Make firstFunc and secondFunc return x (as process does), and then you can write it like so:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n unfilteredList = [secondFunc(firstFunc(x)) for x in firstList]\nsecondList = [x for x in unfilteredList if not x.discard]\n</code>\n</pre>\n", "senID": 1}]]