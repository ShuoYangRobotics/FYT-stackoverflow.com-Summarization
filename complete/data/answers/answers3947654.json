[[{"text": ["Here are some tries:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n L4 = [ n for n in L1 if (n not in L2) and (n not in L3) ]  # parens for clarity\n\ntmpset = set( L2 + L3 )\nL4 = [ n for n in L1 if n not in tmpset ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now that I have had a moment to think, I realize that the L2 + L3 thing creates a temporary list that immediately gets thrown away.", "So an even better way is:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "L2 + L3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n tmpset = set(L2)\ntmpset.update(L3)\nL4 = [ n for n in L1 if n not in tmpset ]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Update: I see some extravagant claims being thrown around about performance, and I want to assert that my solution was already as fast as possible.", "Creating intermediate results, whether they be intermediate lists or intermediate iterators that then have to be called into repeatedly, will be slower, always, than simply giving L2 and L3 for the set to iterate over directly like I have done here."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "L2", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "L3", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n $ python -m timeit \\\n  -s 'L1=range(300);L2=range(30,70,2);L3=range(120,220,2)' \\\n  'ts = set(L2); ts.update(L3); L4 = [ n for n in L1 if n not in ts ]'\n10000 loops, best of 3: 39.7 usec per loop\n</code>\n</pre>\n", "senID": 5}, {"text": ["All other alternatives (that I can think of) will necessarily be slower than this.", "Doing the loops ourselves, for example, rather than letting the set() constructor do them, adds expense:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "set()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n $ python -m timeit \\\n  -s 'L1=range(300);L2=range(30,70,2);L3=range(120,220,2)' \\\n  'unwanted = frozenset(item for lst in (L2, L3) for item in lst); L4 = [ n for n in L1 if n not in unwanted ]'\n10000 loops, best of 3: 46.4 usec per loop\n</code>\n</pre>\n", "senID": 7}, {"text": ["Using iterators, will all of the state-saving and callbacks they involve, will obviously be even more expensive:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n $ python -m timeit \\\n  -s 'L1=range(300);L2=range(30,70,2);L3=range(120,220,2);from itertools import ifilterfalse, chain' \\\n  'L4 = list(ifilterfalse(frozenset(chain(L2, L3)).__contains__, L1))' \n10000 loops, best of 3: 47.1 usec per loop\n</code>\n</pre>\n", "senID": 9}, {"text": ["So I believe that the answer I gave last night is still far and away (for values of \"far and away\" greater than around 5\u00b5sec, obviously) the best, unless the questioner will have duplicates in L1 and wants them removed once each for every time the duplicate appears in one of the other lists."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "L1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["update::: post contains a reference to false allegations of inferior performance of sets compared to frozensets.", "I maintain that it's still sensible to use a frozenset in this instance, even though there's no need to hash the set itself, just because it's more correct semantically.", "Though, in practice, I might not bother typing the extra 6 characters.", "I'm not feeling motivated to go through and edit the post, so just be advised that the \"allegations\" link links to some incorrectly run tests.", "The gory details are hashed out in the comments.", ":::update"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "update:::", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": ":::update", "childNum": 0, "tag": "strong", "pos": 5, "childList": []}]}, {"text": ["The second chunk of code posted by Brandon Craig Rhodes is quite good, but as he didn't respond to my suggestion about using a frozenset (well, not when I started writing this, anyway), I'm going to go ahead and post it myself."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "posted", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3947654/python-removing-items-from-lists/3947666#3947666"}]}, {"text": ["The whole basis of the undertaking at hand is to check if each of a series of values (L1) are in another set of values; that set of values is the contents of L2 and L3.", "The use of the word \"set\" in that sentence is telling: even though L2 and L3 are lists, we don't really care about their list-like properties, like the order that their values are in or how many of each they contain.", "We just care about the set (there it is again) of values they collectively contain."], "childNum": 7, "tag": "p", "senID": 2, "childList": [{"text": "L1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "L2", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "L3", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "L2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "L3", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "set", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["If that set of values is stored as a list, you have to go through the list elements one by one, checking each one.", "It's relatively time-consuming, and it's bad semantics: again, it's a \"set\" of values, not a list.", "So Python has these neat set types that hold a bunch of unique values, and can quickly tell you if some value is in them or not.", "This works in pretty much the same way that python's dict types work when you're looking up a key."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["The difference between sets and frozensets is that sets are mutable, meaning that they can be modified after creation.", "Documentation on both types is here."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "sets", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "frozensets", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#set-types-set-frozenset"}]}, {"text": ["Since the set we need to create, the union of the values stored in L2 and L3, is not going to be modified once created, it's semantically appropriate to use an immutable data type.", "This also allegedly has some performance benefits.", "Well, it makes sense that it would have some advantage; otherwise, why would Python have frozenset as a builtin?"], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "L2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "L3", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "allegedly", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://labs.kortina.net/2010/10/13/list-dict-set-and-frozen-set-performance-in-python/"}, {"text": "frozenset", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["update..."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Brandon has answered this question: the real advantage of frozen sets is that their immutability makes it possible for them to be hashable, allowing them to be dictionary keys or members of other sets."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "hashable", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/glossary.html#term-hashable"}]}, {"text": ["I ran some informal timing tests comparing the speed for creation of and lookup on relatively large (3000-element) frozen and mutable sets; there wasn't much difference.", "This conflicts with the above link, but supports what Brandon says about them being identical but for the aspect of mutability."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["...update"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Now, because frozensets are immutable, they don't have an update method.", "Brandon used the set.update method to avoid creating and then discarding a temporary list en route to set creation; I'm going to take a different approach."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "set.update", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n items = (item for lst in (L2, L3) for item in lst)\n</code>\n</pre>\n", "senID": 11}, {"text": ["This generator expression makes items an iterator over, consecutively, the contents of L2 and L3.", "Not only that, but it does it without creating a whole list-full of intermediate objects.", "Using nested for expressions in generators is a bit confusing, but I manage to keep it sorted out by remembering that they nest in the same order that they would if you wrote actual for loops, e.g."], "childNum": 5, "tag": "p", "senID": 12, "childList": [{"text": "generator expression", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html#generator-expressions"}, {"text": "items", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "L2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "L3", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n def get_items(lists):\n    for lst in lists:\n        for item in lst:\n            yield item\n</code>\n</pre>\n", "senID": 13}, {"text": ["That generator function is equivalent to the generator expression that we assigned to items.", "Well, except that it's a parametrized function definition instead of a direct assignment to a variable."], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "generator function", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html#generators"}, {"text": "items", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Anyway, enough digression.", "The big deal with generators is that they don't actually do anything.", "Well, at least not right away: they just set up work to be done later, when the generator expression is iterated.", "This is formally referred to as being lazy.", "We're going to do that (well, I am, anyway) by passing items to the frozenset function, which iterates over it and returns a frosty cold frozenset."], "childNum": 4, "tag": "p", "senID": 15, "childList": [{"text": "iterated", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "lazy", "childNum": 0, "tag": "em", "pos": 3, "childList": []}, {"text": "items", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "frozenset", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n unwanted = frozenset(items)\n</code>\n</pre>\n", "senID": 16}, {"text": ["You could actually combine the last two lines, by putting the generator expression right inside the call to frozenset:"], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "frozenset", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n unwanted = frozenset(item for lst in (L2, L3) for item in lst)\n</code>\n</pre>\n", "senID": 18}, {"text": ["This neat syntactical trick works as long as the iterator created by the generator expression is the only parameter to the function you're calling.", "Otherwise you have to write it in its usual separate set of parentheses, just like you were passing a tuple as an argument to the function."], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "iterator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html#iterators"}]}, {"text": ["Now we can build a new list in the same way that Brandon did, with a list comprehension.", "These use the same syntax as generator expressions, and do basically the same thing, except that they are eager instead of lazy (again, these are actual technical terms), so they get right to work iterating over the items and creating a list from them."], "childNum": 3, "tag": "p", "senID": 20, "childList": [{"text": "list comprehension", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions"}, {"text": "eager", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "lazy", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n L4 = [item for item in L1 if item not in unwanted]\n</code>\n</pre>\n", "senID": 21}, {"text": ["This is equivalent to passing a generator expression to list, e.g."], "childNum": 1, "tag": "p", "senID": 22, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n L4 = list(item for item in L1 if item not in unwanted)\n</code>\n</pre>\n", "senID": 23}, {"text": ["but more idiomatic."], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"text": ["So this will create the list L4, containing the elements of L1 which weren't in either L2 or L3, maintaining the order that they were originally in and the number of them that there were."], "childNum": 4, "tag": "p", "senID": 25, "childList": [{"text": "L4", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "L1", "childNum": 0, "tag": "code", "childList": []}, {"text": "L2", "childNum": 0, "tag": "code", "childList": []}, {"text": "L3", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you just want to know which values are in L1 but not in L2 or L3, it's much easier: you just create that set:"], "childNum": 4, "tag": "p", "senID": 26, "childList": [{"text": "which", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "L1", "childNum": 0, "tag": "code", "childList": []}, {"text": "L2", "childNum": 0, "tag": "code", "childList": []}, {"text": "L3", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n L1_unique_values = set(L1) - unwanted\n</code>\n</pre>\n", "senID": 27}, {"text": ["You can make a list out of it, as does st0le, but that might not really be what you want.", "If you really do want the set of values that are only found in L1, you might have a very good reason to keep that set as a set, or indeed a frozenset:"], "childNum": 6, "tag": "p", "senID": 28, "childList": [{"text": "as does st0le", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3947654/python-removing-items-from-lists/3947659#3947659"}, {"text": "set", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "L1", "childNum": 0, "tag": "code", "childList": []}, {"text": "set", "childNum": 0, "tag": "em", "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}, {"text": "frozenset", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n L1_unique_values = frozenset(L1) - unwanted\n</code>\n</pre>\n", "senID": 29}, {"text": ["...Annnnd, now for something completely different:"], "childNum": 3, "tag": "p", "senID": 30, "childList": [{"text": "...Annnnd", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "...Annnnd", "tag": "strong"}]}, {"text": "...Annnnd", "childNum": 0, "tag": "strong", "childList": []}, {"text": "now for something completely different:", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import ifilterfalse, chain\nL4 = list(ifilterfalse(frozenset(chain(L2, L3)).__contains__, L1))\n</code>\n</pre>\n", "senID": 31}], [{"text": ["Assuming your individual lists won't contain duplicates....Use Set and Difference"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Difference", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n L1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nL2 = [4, 7, 8]\nL3 = [5, 2, 9]\nprint(list(set(L1) - set(L2) - set(L3)))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Doing such operations in Lists can hamper your program's performance very soon.", "What happens is with each remove, List operations do a fresh malloc &amp; move elements around.", "This can be expensive if you have a very huge list or otherwise.", "So I would suggest this -"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I am assuming your list has unique elements.", "Otherwise you need to maintain a list in your dict having duplicate values.", "Anyway for the data your provided, here it is- "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["METHOD 1"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "METHOD 1", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n d = dict()\nfor x in L1: d[x] = True\n\n# Check if L2 data is in 'd'\nfor x in L2:\n    if x in d:\n        d[x] = False\n\nfor x in L3:\n    if x in d:\n        d[x] = False\n\n# Finally retrieve all keys with value as True.\nfinal_list = [x for x in d if d[x]]\n</code>\n</pre>\n", "senID": 3}, {"text": ["METHOD 2\nIf all that looks like too much code.", "Then you could try using set.", "But this way your list will loose all duplicate elements."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "METHOD 2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n final_set  = set.difference(set(L1),set(L2),set(L3))\nfinal_list = list(final_set)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["This may be less pythonesque than the list-comprehension answer, but has a simpler look to it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l1 = [ ... ]\nl2 = [ ... ]\n\ndiff = list(l1) # this copies the list\nfor element in l2:\n    diff.remove(element)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The advantage here is that we preserve order of the list, and if there are duplicate elements, we remove only one for each time it appears in l2."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "preserve order", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "duplicate elements", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["I think intuited's answer is way too long for such a simple problem, and Python already has a builtin function to chain two lists as a generator."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The procedure is as follows:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["And now the code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n L1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nL2 = [4, 7, 8]\nL3 = [5, 2, 9]\n\nfrom itertools import chain\ntmp = frozenset(chain(L2, L3))\nL4 = [x for x in L1 if x not in tmp] # [1, 3, 6]\n</code>\n</pre>\n", "senID": 3}, {"text": ["This should be one of the fastest, simplest and least memory-consuming solution."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]