[[{"text": ["Here is a simple one-pass O(n) solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s = [1,4,2,3,5,4,5,6,7,8,1,3,4,5,9,10,11,42]\nmaxrun = -1\nrl = {}\nfor x in s:\n    run = rl[x] = rl.get(x-1, 0) + 1\n    print x-run+1, 'to', x\n    if run &gt; maxrun:\n        maxend, maxrun = x, run\nprint range(maxend-maxrun+1, maxend+1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The logic may be a little more self-evident if you think in terms of ranges instead of individual variables for the endpoint and run length:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n rl = {}\nbest_range = xrange(0)\nfor x in s:\n    run = rl[x] = rl.get(x-1, 0) + 1\n    r = xrange(x-run+1, x+1)\n    if len(r) &gt; len(best_range):\n        best_range = r\nprint list(best_range)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You can use The Patience Sort implementation of the Largest Ascending Sub-sequence Algorithm"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Patience Sort", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Patience_sorting"}, {"href": "http://en.wikipedia.org/wiki/Longest_increasing_subsequence", "text": "Largest Ascending Sub-sequence Algorithm", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n def LargAscSub(seq):\n    deck = []\n    for x in seq:\n        newDeck = [x]\n        i = bisect.bisect_left(deck, newDeck)\n        deck[i].insert(0, x) if i != len(deck) else deck.append(newDeck)\n    return [p[0] for p in deck]\n</code>\n</pre>\n", "senID": 1}, {"text": ["And here is the Test results "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; LargAscSub([1,4,2,3,5,4,5,6,7,8,1,3,4,5,9,10,11])\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n&gt;&gt;&gt; LargAscSub([1, 2, 3, 11, 12, 13, 14])\n[1, 2, 3, 11, 12, 13, 14]\n&gt;&gt;&gt; LargAscSub([11,12,13,14])\n[11, 12, 13, 14]\n</code>\n</pre>\n", "senID": 3}, {"text": ["The Order of Complexity is O(nlogn)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "O", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["There was one note in the wiki link where they claimed that you can achieve O(n.loglogn) by relying on Van Emde Boas tree"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "O", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"href": "http://en.wikipedia.org/wiki/Van_Emde_Boas_tree", "text": "Van Emde Boas tree", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Not that clever, not O(n), could use a bit of optimization.", "But it works."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def longest(seq):\n  result = []\n  for v in seq:\n    for l in result:\n      if v == l[-1] + 1:\n        l.append(v)\n    else:\n      result.append([v])\n  return max(result, key=len)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about using a modified Radix Sort?", "As JanneKarila pointed out the solution is not O(n).", "It uses Radix sort, which wikipedia says Radix sort's efficiency is O(k\u00b7n) for n keys which have k or fewer digits."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Radix Sort", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Radix_sort"}, {"text": "Radix sort's efficiency is O(k\u00b7n) for n keys which have k or fewer digits.", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["This will only work if you know the range of numbers that we're dealing with so that will be the first step. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["EDIT: Code added.", "Tested and working"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT: Code added. Tested and working", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n #note this doesn't work with negative numbers\n#it's certainly possible to write this to work with negatives\n# but the code is a bit hairier\nimport sys\ndef findLongestSequence(lst):\n    #step 1\n    high = -sys.maxint - 1\n\n    for num in lst:\n        if num &gt; high:\n            high = num\n\n    #step 2\n    result = [None]*(high+1)\n\n    #step 3\n    for num in lst:\n        result[num] = num\n\n    #step 4\n    curr_start_element = 0\n    curr_len = 0\n    longest_start_element = -1\n    longest_len = -1\n\n    for element_counter in range(len(result)):\n        if result[element_counter] == None:\n\n            if curr_len &gt; longest_len:\n                longest_start_element = curr_start_element\n                longest_len = curr_len\n\n            curr_len = 0\n            curr_start_element = -1\n\n        elif curr_start_element == -1:\n            curr_start_element = element_counter\n\n        curr_len += 1\n\n    #just in case the last element makes the longest\n    if curr_len &gt; longest_len:\n        longest_start_element = curr_start_element\n        longest_len = curr_len\n\n\n    #step 5\n    return result[longest_start_element:longest_start_element + longest_len-1]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If the result really does have to be a sub-sequence of consecutive ascending integers, rather than merely ascending integers, then there's no need to remember each entire consecutive sub-sequence until you determine which is the longest, you need only remember the starting and ending values of each sub-sequence.", "So you could do something like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "consecutive", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def longestConsecutiveSequence(sequence):\n    # map starting values to largest ending value so far\n    map = collections.OrderedDict()\n\n    for i in sequence:\n        found = False\n        for k, v in map.iteritems():\n            if i == v:\n                map[k] += 1\n                found = True\n\n        if not found and i not in map:\n            map[i] = i + 1\n\n    return xrange(*max(map.iteritems(), key=lambda i: i[1] - i[0]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["If I run this on the original sample date (i.e.", "[1,4,2,3,5,4,5,6,7,8,1,3,4,5,9,10,11]) I get:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[1,4,2,3,5,4,5,6,7,8,1,3,4,5,9,10,11]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print list(longestConsecutiveSequence([1,4,2,3,5,4,5,6,7,8,1,3,4,5,9,10,11]))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n</code>\n</pre>\n", "senID": 3}, {"text": ["If I run it on one of Abhijit's samples [1,2,3,11,12,13,14], I get:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "[1,2,3,11,12,13,14]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print list(longestConsecutiveSequence([1,2,3,11,12,13,14]))\n[11, 12, 13, 14]\n</code>\n</pre>\n", "senID": 5}, {"text": ["Regrettably, this algorithm is O(n*n) in the worst case."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Warning: This is the cheaty way to do it (aka I use python...)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator as op\nimport itertools as it\n\ndef longestSequence(data):\n\n    longest = []\n\n    for k, g in it.groupby(enumerate(set(data)), lambda(i, y):i-y):\n        thisGroup = map(op.itemgetter(1), g)\n\n        if len(thisGroup) &gt; len(longest):\n            longest = thisGroup\n\n    return longest\n\n\nlongestSequence([1,4,2,3,5,4,5,6,7,8,1,3,4,5,9,10,11, 15,15,16,17,25])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You need the Maximum contiguous sum(Optimal Substructure):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Maximum contiguous sum", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://20bits.com/articles/introduction-to-dynamic-programming/", "text": "Optimal Substructure", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n def msum2(a):\n    bounds, s, t, j = (0,0), -float('infinity'), 0, 0\n\n    for i in range(len(a)):\n        t = t + a[i]\n        if t &gt; s: bounds, s = (j, i+1), t\n        if t &lt; 0: t, j = 0, i+1\n    return (s, bounds)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is an example of dynamic programming and is O(N)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["O(n) solution works even if the sequence does not start from the first element. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Warning does not work if len(A) = 0.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n A = [1,4,2,3,5,4,5,6,7,8,1,3,4,5,9,10,11]\ndef pre_process(A): \n    Last = {}\n    Arrow = []\n    Length = []\n    ArgMax = 0\n    Max = 0\n    for i in xrange(len(A)): \n        Arrow.append(i)\n        Length.append(0)  \n        if A[i] - 1 in Last: \n            Aux = Last[A[i] - 1]\n            Arrow[i] = Aux\n            Length[i] = Length[Aux] + 1\n        Last[A[i]] = i \n        if Length[i] &gt; Max:\n            ArgMax = i \n            Max = Length[i]\n    return (Arrow,ArgMax)  \n\n(Arr,Start) = pre_process(A) \nOld = Arr[Start] \nToRev = []\nwhile 1: \n    ToRev.append(A[Start]) \n    if Old == Start: \n        break\n    Start = Old \n    New = Arr[Start]\n    Old = New\nToRev.reverse()\nprint ToRev\n</code>\n</pre>\n", "senID": 2}, {"text": ["Pythonizations are welcome!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Ok, here's yet another attempt in python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def popper(l):\n    listHolders = []\n    pos = 0\n    while l:\n        appended = False\n        item = l.pop()\n        for holder in listHolders:\n            if item == holder[-1][0]-1:\n                appended = True\n                holder.append((item, pos))\n        if not appended:\n            pos += 1\n            listHolders.append([(item, pos)])\n    longest = []\n    for holder in listHolders:\n        try:\n            if (holder[0][0] &lt; longest[-1][0]) and (holder[0][1] &gt; longest[-1][1]):\n                longest.extend(holder)\n        except:\n            pass\n        if len(holder) &gt; len(longest):\n            longest = holder\n    longest.reverse()\n    return [x[0] for x in longest]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Sample inputs and outputs:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; demo = list(range(50))\n&gt;&gt;&gt; shuffle(demo)\n&gt;&gt;&gt; demo\n[40, 19, 24, 5, 48, 36, 23, 43, 14, 35, 18, 21, 11, 7, 34, 16, 38, 25, 46, 27, 26, 29, 41, 8, 31, 1, 33, 2, 13, 6, 44, 22, 17,\n 12, 39, 9, 49, 3, 42, 37, 30, 10, 47, 20, 4, 0, 28, 32, 45, 15]\n&gt;&gt;&gt; popper(demo)\n[1, 2, 3, 4]\n&gt;&gt;&gt; demo = [1,4,2,3,5,4,5,6,7,8,1,3,4,5,9,10,11]\n&gt;&gt;&gt; popper(demo)\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This should do the trick (and is O(n)):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n target = 1\nresult = []\nfor x in list:\n    for y in result:\n        if y[0] == target:\n            y[0] += 1\n            result.append(x)\n</code>\n</pre>\n", "senID": 1}, {"text": ["For any starting number, this works:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n result = []\nfor x in mylist:\n    matched = False\n    for y in result:\n        if y[0] == x:\n            matched = True\n            y[0] += 1\n            y.append(x)\n    if not matched:\n        result.append([x+1, x])\nreturn max(result, key=len)[1:]\n</code>\n</pre>\n", "senID": 3}]]