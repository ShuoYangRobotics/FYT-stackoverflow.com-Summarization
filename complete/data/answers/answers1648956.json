[[{"text": ["How about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n initialisers = [foo, bar, baz]\n if initialisers.count(None) &lt; len(initialisers) - 1:\n     raise Ex()\n</code>\n</pre>\n", "senID": 1}, {"text": ["It simply counts how many None are present.", "If they're all None or only one isn't then fine, otherwise it raises the exception."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["x!=None returns True (whose numeric value is 1!", ") for non-Nones, False (whose numeric value is 0) for Nones.", "So,"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "x!=None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n sum(x!=None for x in (foo, bar, baz))\n</code>\n</pre>\n", "senID": 1}, {"text": ["is the simplest way to count how many of those identifiers are bound to non-None values (and you can check that count against 1 just like other answers do for their ways of obtaining the count).", "This is a very general approach in that instead of x!=None you could be using any strictly-bool predicate of interest; for example if you have a bunch of integers and want to know how many of them have 3 as the first digit of their decimal representation,"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "their", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "x!=None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "3", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n sum(str(abs(x)).startswith('3') for x in (a, b, c, d, e))\n</code>\n</pre>\n", "senID": 3}, {"text": ["works fine too."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Don't be queasy about \"summing bools\": Python bools are sharply defined as a subclass of int with exactly two instances which have peculiar str/repr but otherwise behave exactly like the plain ints 0 and 1.", "There are good pragmatical reasons for this design and the ability to do arithmetic on bools is one of them, so feel free to use that ability!-)"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "use", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}], [{"text": ["Try"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n count = sum(map(lambda x: 0 if x is None else 1, (foo, bar, baz)))\n if count &gt; 1:\n     raise Ex()\n</code>\n</pre>\n", "senID": 1}, {"text": ["That turns None into 0 and everything into 1 and then sums everything up."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I have even shorter answer, with my favorite python feature - decorators:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def single_keyword(func):\n    def single_keyword_dec(*args, **kw):\n        if len(kw) &gt; 1:\n            raise Exception(\"More than one initializer passed: {0}\".format(kw.keys()))\n        return func(*args, **kw)\n    return single_keyword_dec\n\n@single_keyword\ndef some_func(self, foo=None, bar=None, baz=None):\n    print foo, bar, baz\n\nsome_func(object, foo=0)\nsome_func(object, foo=0, bar=0)\n#result\n0 None None\nTraceback (most recent call last):\n  File \"dec2.py\", line 13, in &lt;module&gt;\n    some_func(object, foo=0, bar=0)\n  File \"dec2.py\", line 4, in single_keyword_dec\n    raise Exception(\"More than one initializer passed: {0}\".format(kw.keys()))\nException: More than one initializer passed: ['foo', 'bar']\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you need distinguish between 'foo', 'bar', 'baz' and some other keywords, you could make similiar decorator which would accept list of keywords to restrict, and use it like this: @single_keyword('foo', 'bar', 'baz')"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "@single_keyword('foo', 'bar', 'baz')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This way its 100% code reuse, no typing same thing over and over, and you get proper keywords in your function, not some obscure dict."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n if len(filter(lambda x: x != None, locals().values())) &gt; 1:\n    raise Exception()\n</code>\n</pre>\n", "senID": 0}, {"text": ["Edited to address Alex's point."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Like this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def func( self, **kw ):\n    assert len(kw) == 1, \"Too Many Arguments\"\n    assert kw.keys[0] in ( 'foo', 'bar', 'baz' ), \"Argument not foo, bar or baz\"\n</code>\n</pre>\n", "senID": 1}]]