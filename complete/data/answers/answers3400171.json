[[{"text": ["b is a string, a is a dict"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "string", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You want (I believe):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["b == a['a']"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "b == a['a']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Possible solutions"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Either write like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a = {\"a\": u\"\u00e7\u00f6\"}\nb = \"\u00e7\u00f6\"\nb.decode('utf-8') == a['a']\n</code>\n</pre>\n", "senID": 2}, {"text": ["Or like this (you may also skip the .decode('utf-8') on both sides):"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": ".decode('utf-8')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a = {\"a\": \"\u00e7\u00f6\"}\nb = \"\u00e7\u00f6\"\nb.decode('utf-8') == a['a'].decode('utf-8')\n</code>\n</pre>\n", "senID": 4}, {"text": ["Or like this (my recommendation):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n a = {\"a\": u\"\u00e7\u00f6\"}\nb = u\"\u00e7\u00f6\"\nb == a['a']\n</code>\n</pre>\n", "senID": 6}, {"text": ["Explanation"], "childNum": 0, "tag": "h2", "senID": 7, "childList": []}, {"text": ["Updated based on Tim's comment.", "In your original code, b.decode('utf-8') == u'\u00e7\u00f6' and a['a'] == '\u00e7\u00f6', so you're actually making the following comparison:"], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "Updated based on Tim's comment.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "b.decode('utf-8') == u'\u00e7\u00f6'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "a['a'] == '\u00e7\u00f6'", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n u'\u00e7\u00f6' == '\u00e7\u00f6'\n</code>\n</pre>\n", "senID": 9}, {"text": ["One of the objects is of type unicode, the other is of type str, so in order to execute the comparison, the str is converted to unicode and then the two unicode objects are compared.", "It works fine in the case of purely ASCII strings, for example: u'a' == 'a', since unicode('a') == u'a'."], "childNum": 7, "tag": "p", "senID": 10, "childList": [{"text": "unicode", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "childList": []}, {"text": "unicode", "childNum": 0, "tag": "code", "childList": []}, {"text": "unicode", "childNum": 0, "tag": "code", "childList": []}, {"text": "u'a' == 'a'", "childNum": 0, "tag": "code", "childList": []}, {"text": "unicode('a') == u'a'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["However, it fails in case of u'\u00e7\u00f6' == '\u00e7\u00f6', since unicode('\u00e7\u00f6') returns the following error: UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position 0: ordinal not in range(128), and therefore the whole comparison returns False and issues the following warning: UnicodeWarning: Unicode equal comparison failed to convert both arguments to Unicode - interpreting them as being unequal."], "childNum": 4, "tag": "p", "senID": 11, "childList": [{"text": "u'\u00e7\u00f6' == '\u00e7\u00f6'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "unicode('\u00e7\u00f6')", "childNum": 0, "tag": "code", "childList": []}, {"text": "UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position 0: ordinal not in range(128)", "childNum": 0, "tag": "em", "childList": []}, {"text": "UnicodeWarning: Unicode equal comparison failed to convert both arguments to Unicode - interpreting them as being unequal", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["Try\n    b == a['a']"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You are comparing a string to a dict."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = {\"a\":\"\u00e7\u00f6\"}\n&gt;&gt;&gt; b = \"\u00e7\u00f6\"\n&gt;&gt;&gt; a == b\nFalse\n&gt;&gt;&gt; a['a'] == b\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you compare the string (b) to the member of a (a['a']), then you get the desired result."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["UTF-8 is an encoding used to record Unicode text in files.", "However, in Python you are working with objects that have a fixed way to represent Unicode text, and that way is not UTF-8."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can still compare Unicode strings in Python, but this is unrelated to UTF-8, except that if you want to put constants into these Unicode strings, then you will need to encode the text of the file containing your source code, in UTF-8.", "As soon as the assignment operator is executed, the string is no longer UTF-8, but is now the Python internal representation."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["By the way, if you are doing comparisons with Unicode, you probably will want to use the unicodedata module and normalize the strings before comparisons are done. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Make sure your code is in UTF-8 (NOT Latin-1) and/or use a coding line as so:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #! /usr/bin/python\n# -*- coding: utf-8 -*-\na = {\"a\": u\"\u00e7\u00f6\"}\nb = \"\u00e7\u00f6\"\nassert b == a['a']\nassert b.decode('utf-8') == a['a'].decode('utf-8')\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you're using unicode across the board, you can import unicode_literals from the future and cut back on encoding heartaches:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #! /usr/bin/python\n# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\na = {\"a\": u\"\u00e7\u00f6\"}\nb = \"\u00e7\u00f6\"\nassert b == a['a']\nassert b == a['a']\nassert b.encode('utf-8') != a['a']\nassert b.encode('utf-8') == a['a'].encode('utf-8')\n</code>\n</pre>\n", "senID": 3}, {"text": ["If a file uses unicode_literals, all \"strings\" are now u\"unicode\" objects (per the coding of the file) if they're not b\"prepended\" with a b (to emulate the string/bytes split in Python 3.X)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["NullUserException is right that this should be correct:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n b == a['a']\n</code>\n</pre>\n", "senID": 1}, {"text": ["You're still getting \"False\" because you're decoding one side as utf-8 (creating a Unicode string) while the other side remains a utf-8 encoded byte string."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]