[[{"text": ["Not necessarily great if you want to do something other than a to z, but you can do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from string import ascii_lowercase\nfor c in ascii_lowercase:\n    print c\n</code>\n</pre>\n", "senID": 1}], [{"text": ["My way is similar to yours but you can use map and  create an arbitrary function like this"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def generate_list(char1,char2):\n...      myl = map(chr, range(ord(char1),ord(char2)+1))\n...      print myl\n...\n&gt;&gt;&gt; generate_list(\"a\",\"d\")\n['a', 'b', 'c', 'd']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can replace the list comprehension with a map(chr,range(ord('a'),ord('z')+1)) call, but that's perhaps not what you're really asking.", "The example you show, however, is more appropriately imported; it is available as a string in string.lowercase. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "map(chr,range(ord('a'),ord('z')+1))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "string.lowercase", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Assuming letters match up with ordinals may be a mistake, considering letters like \u00df and \u00e6, which may be sorted differently depending on locales (i.e.", "\u00e5\u00e4\u00f6 are last in the alphabet for Swedish, but \u00e4 and \u00f6 are variants of a and o in German).", "That's why we have functions like unicode.islower() and locale.strcoll(). "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["There's nothing wrong with your list-comprehension, but maybe you want to try:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from string import lowercase\nprint lowercase\n  abcdefghijklmnopqrstuvwxyz\nprint list(lowercase)\n  ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n</code>\n</pre>\n", "senID": 1}, {"text": ["As noted by julio.alegria and Nathan Binkert lowercase is a string of a all lower-case letters and Python strings are iterables."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "lowercase", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you require subsets of the alphabet, there are nice and Pythonic ways to do this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n print lowercase.find('f')\n  5\nprint lowercase[5,9]\n  fghij\nprint filter(lambda c: ord('f') &lt;= ord(c) &lt;= ord('j'), lowercase)\n  fghij\n</code>\n</pre>\n", "senID": 4}], [{"text": ["As noted elsewhere, the letters 'a' through 'z' are already in string.lowercase.", "Thus you can just take a slice of that."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "string.lowercase", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/string.html#string.lowercase"}]}, {"code": "<pre>\n<code>\n import string\ndef create_letter_list(start_char, end_char):\n    return string.lowercase[ord(start_char) - ord('a'): ord(end_char) - ord('a') + 1]\n\nletter_list = create_letter_list('g', 'n')\n print letter_list\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Yet another option:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from string import ascii_lowercase\n\ndef charRange(start, end):\n    offset = ord('a')\n    return ascii_lowercase[ord(start)-offset:ord(end)-offset+1]\n\ncharRange('a', 'f')\n&gt; 'abcdef'\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import random\n\ndef random_chars(size=10, chrs=string.ascii_uppercase + string.digits):\n    return ''.join(random.choice(chrs) for x in range(size))\n</code>\n</pre>\n", "senID": 0}]]