[[{"text": ["Within the body of a class, the class name isn't defined yet, so it is not available.", "Can you not simply type the name of the class?", "Maybe you need to say more about the problem so we can find a solution for you."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I would create a metaclass to do this work for you.", "It's invoked at class creation time (conceptually at the very end of the class: block), and can manipulate the class being created.", "I haven't tested this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class InputAssigningMetaclass(type):\n    def __new__(cls, name, bases, attrs):\n        cls.input = get_input(name)\n        return super(MyType, cls).__new__(cls, name, bases, newattrs)\n\nclass MyBaseFoo(object):\n    __metaclass__ = InputAssigningMetaclass\n\nclass foo(MyBaseFoo):\n    # etc, no need to create 'input'\n\nclass foo2(MyBaseFoo):\n    # etc, no need to create 'input'\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You can access it by the class' private attributes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n cls_name = self.__class__.__name__\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["As said by Ned Batcheler, this wouldn't work in the class body, but it would in a method."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Ned Batcheler", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Not sure if these links answer your question"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Getting the class name of an instance in Python"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Getting the class name of an instance in Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/510972/getting-the-class-name-of-an-instance-in-python"}]}, {"text": ["How can I access the current executing module or class name in Python?"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "How can I access the current executing module or class name in Python?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/602846/how-can-i-access-the-current-executing-module-or-class-name-in-python"}]}], [{"text": ["You can access and parse the object's class property:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "class", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import collections\n&gt;&gt;&gt; c = collections.Counter()\n&gt;&gt;&gt; str(c.__class__)\n\"&lt;class 'collections.Counter'&gt;\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["obj.__class__.__name__ will get you any objects name, so you can do this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "obj.__class__.__name__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Clazz():\n    def getName(self):\n        return self.__class__.__name__\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; c = Clazz()\n&gt;&gt;&gt; c.getName()\n'Clazz'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["EDIT: Yes, you can; but you have to cheat: The currently running class name is present on the call stack, and the traceback module allows you to access the stack."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/traceback.html#traceback.extract_stack", "text": "traceback", "childNum": 1, "tag": "a", "childList": [{"text": "traceback", "tag": "code"}]}, {"text": "traceback", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import traceback\n&gt;&gt;&gt; def get_input(class_name):\n...     return class_name.encode('rot13')\n... \n&gt;&gt;&gt; class foo(object):\n...      _name = traceback.extract_stack()[-1][2]\n...     input = get_input(_name)\n... \n&gt;&gt;&gt; \n&gt;&gt;&gt; foo.input\n'sbb'\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, I wouldn't do this;  My original answer is still my own preference as a solution.", "Original answer:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["probably the very simplest solution is to use a decorator, which is similar to Ned's answer involving metaclasses, but less powerful (decorators are capable of black magic, but metaclasses are capable of ancient, occult black magic)"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "ancient, occult", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def get_input(class_name):\n...     return class_name.encode('rot13')\n... \n&gt;&gt;&gt; def inputize(cls):\n...     cls.input = get_input(cls.__name__)\n...     return cls\n... \n&gt;&gt;&gt; @inputize\n... class foo(object):\n...     pass\n... \n&gt;&gt;&gt; foo.input\n'sbb'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 4}]]