[[{"code": "<pre>\n<code>\n class Foo(object):\n     pass\n\nsome_global_variable = Foo()\n</code>\n</pre>\n", "senID": 0}, {"text": ["Modules are imported only once, everything else is overthinking.", "Don't use singletons and try not to use globals."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Use a module.", "It is imported only once.", "Define some global variables in it - they will be singleton's 'attributes'.", "Add some functions - the singleton's 'methods'."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Use a Metaclass"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I would recommend Method #2, but you're better off using a metaclass than a base class.", "Here is a sample implementation:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Method #2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "metaclass", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n class Singleton(type):\n    _instances = {}\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass Logger(object):\n    __metaclass__ = Singleton\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you want to run __init__ every time the class is called, add"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n else:\n            cls._instances[cls].__init__(*args, **kwargs)\n</code>\n</pre>\n", "senID": 4}, {"text": ["to the if statement in Singleton.__call__."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Singleton.__call__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["A few words about metaclasses.", "A metaclass is the class of a class; that is, a class is an instance of its metaclass.", "You find the metaclass of an object in Python with type(obj).", "Normal new-style classes are of type type.", "Logger in the code above will be of type class 'your_module.Singleton', just as the (only) instance of Logger will be of type class 'your_module.Logger'.", "When you call logger with Logger(), Python first asks the metaclass of Logger, Singleton, what to do, allowing instance creation to be pre-empted.", "This process is the same as Python asking a class what to do by calling __getattr__ when you reference one of it's attributes by doing myclass.attribute."], "childNum": 13, "tag": "p", "senID": 6, "childList": [{"text": "class of a class", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "instance of its metaclass", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "type(obj)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "type", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "Logger", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "class 'your_module.Singleton'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Logger", "childNum": 0, "tag": "code", "pos": 5, "childList": []}, {"text": "class 'your_module.Logger'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Logger()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Logger", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Singleton", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__getattr__", "childNum": 0, "tag": "code", "pos": 6, "childList": []}, {"text": "myclass.attribute", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["A metaclass essentially decides what the definition of a class means and how to implement that definition.", "See for example http://code.activestate.com/recipes/498149/, which essentially recreates C-style structs in Python using metaclasses.", "The thread What are your (concrete) use-cases for metaclasses in Python?", "also provides some examples, they generally seem to be related to declarative programming, especially as used in ORMs."], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "what the definition of a class means", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "http://code.activestate.com/recipes/498149/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/498149/"}, {"text": "struct", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "What are your (concrete) use-cases for metaclasses in Python?", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/392160/what-are-your-concrete-use-cases-for-metaclasses-in-python"}]}, {"text": ["In this situation, if you use your Method #2, and a subclass defines a __new__ method, it will be executed every time you call SubClassOfSingleton() -- because it is responsible for calling the method that returns the stored instance.", "With a metaclass, it will only be called once, when the only instance is created.", "You want to customize what it means to call the class, which is decided by it's type."], "childNum": 6, "tag": "p", "senID": 8, "childList": [{"text": "Method #2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "executed every time", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "SubClassOfSingleton()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "only be called once", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "customize what it means to call the class", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["In general, it makes sense to use a metaclass to implement a singleton.", "A singleton is special because is created only once, and a metaclass is the way you customize the creation of a class.", "Using a metaclass gives you more control in case you need to customize the singleton class definitions in other ways."], "childNum": 4, "tag": "p", "senID": 9, "childList": [{"text": "makes sense", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "created only once", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "creation of a class", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "more control", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["Your singletons won't need multiple inheritance (because the metaclass is not a base class), but for subclasses of the created class that use multiple inheritance, you need to make sure the singleton class is the first / leftmost one with a metaclass that redefines __call__ This is very unlikely to be an issue.", "The instance dict is not in the instance's namespace so it won't accidentally overwrite it."], "childNum": 5, "tag": "p", "senID": 10, "childList": [{"text": "won't need multiple inheritance", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "subclasses of the created class", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "first / leftmost", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "__call__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "not in the instance's namespace", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["You will also hear that the singleton pattern violates the \"Single Responsibility Principle\" -- each class should do only one thing.", "That way you don't have to worry about messing up one thing the code does if you need to change another, because they are separate and encapsulated.", "The metaclass implementation passes this test.", "The metaclass is responsible for enforcing the pattern and the created class and subclasses need not be aware that they are singletons.", "Method #1 fails this test, as you noted with \"MyClass itself is a a function, not a class, so you cannot call class methods from it."], "childNum": 5, "tag": "p", "senID": 11, "childList": [{"text": "only one thing", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "passes this test", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "enforcing the pattern", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}, {"text": "aware that they are singletons", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "Method #1", "childNum": 0, "tag": "strong", "pos": 4, "childList": []}]}, {"text": ["Corrections"], "childNum": 0, "tag": "h2", "senID": 12, "childList": []}, {"text": ["On another topic, you've probably already noticed this, but the base class implementation in your original post is wrong.", "_instances needs to be referenced on the class, you need to use super() or you're recursing, and __new__ is actually a static method that you have to pass the class to, not a class method, as the actual class hasn't been created yet when it is called.", "All of these things will be true for a metaclass implementation as well."], "childNum": 7, "tag": "p", "senID": 13, "childList": [{"text": "_instances", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "referenced on the class", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "super()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "recursing", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "pass the class to", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "hasn't been created", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n class Singleton(object):\n  _instances = {}\n  def __new__(class_, *args, **kwargs):\n    if class_ not in class_._instances:\n        class_._instances[class_] = super(Singleton, class_).__new__(class_, *args, **kwargs)\n    return class_._instances[class_]\n\nclass MyClass(Singleton):\n  pass\n\nc = MyClass()\n</code>\n</pre>\n", "senID": 14}, {"text": ["Decorator Returning A Class"], "childNum": 0, "tag": "h2", "senID": 15, "childList": []}, {"text": ["I originally was writing a comment but it was too long, so I'll add this here.", "Method #4 is better than the other decorator version, but it's more code than needed for a singleton, and it's not as clear what it does. "], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "Method #4", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["The main problems stem from the class being it's own base class.", "First, isn't it weird to have a class be a subclass of a nearly identical class with the same name that exists only in its __class__ attribute?", "This also means that you can't define any methods that call the method of the same name on their base class with super() because they will recurse.", "This means your class can't customize __new__, and can't derive from any classes that need __init__ called on them."], "childNum": 5, "tag": "p", "senID": 17, "childList": [{"text": "__class__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "any methods that call the method of the same name on their base class", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "super()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["When to use the singleton pattern"], "childNum": 0, "tag": "h2", "senID": 18, "childList": []}, {"text": ["Your use case is one of the better examples of wanting to use a singleton.", "You say in one of the comments \"To me logging has always seemed a natural candidate for Singletons.", "\" You're absolutely right."], "childNum": 2, "tag": "p", "senID": 19, "childList": [{"text": "one of the better examples", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "absolutely right", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["When people say singletons are bad, the most common reason is they are implicit shared state.", "While with global variables and top-level module imports are explicit shared state, other objects that are passed around are generally instantiated.", "This is a good point, with two exceptions."], "childNum": 3, "tag": "p", "senID": 20, "childList": [{"text": "implicit shared state", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "explicit", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "with two exceptions", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["The first, and one that gets mentioned in various places, is when the singletons are constant.", "Use of global constants, especially enums, is widely accepted, and considered sane because no matter what, none of the users can mess them up for any other user.", "This is equally true for a constant singleton."], "childNum": 2, "tag": "p", "senID": 21, "childList": [{"text": "constant", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "none of the users can mess them up for any other user", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["The second exception, which get mentioned less, is the opposite -- when the singleton is only a data sink, not a data source (directly or indirectly).", "This is why loggers feel like a \"natural\" use for singletons.", "As the various users are not changing the loggers in ways other users will care about, there is not really shared state.", "This negates the primary argument against the singleton pattern, and makes them a reasonable choice because of their ease of use for the task."], "childNum": 4, "tag": "p", "senID": 22, "childList": [{"text": "only a data sink", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "not changing the loggers", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "not really shared state", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "ease of use", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}, {"text": ["Here is a quote from http://googletesting.blogspot.com/2008/08/root-cause-of-singletons.html:"], "childNum": 1, "tag": "p", "senID": 23, "childList": [{"text": "http://googletesting.blogspot.com/2008/08/root-cause-of-singletons.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://googletesting.blogspot.com/2008/08/root-cause-of-singletons.html"}]}], [{"text": ["Check out this thread with several solutions."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/31875/is-there-a-simple-elegant-way-to-define-singletons-in-python"}]}, {"text": ["I'd strongly recommend to watch Alex Martelli's talks on design patterns in python: part 1 and part 2.", "In particular, in part 1 he talks about singletons/shared state objects."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "part 1", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.youtube.com/watch?v=1Sbzmz1Nxvo"}, {"text": "part 2", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.youtube.com/watch?v=tJXhtncDBu4"}]}], [{"text": ["Here's my own implementation of singletons.", "All you have to do is decorate the class; to get the singleton, you then have to use the Instance method.", "Here's an example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Instance", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n @Singleton\n   class Foo:\n       def __init__(self):\n           print 'Foo created'\n\n   f = Foo() # Error, this isn't how you get the instance of a singleton\n\n   f = Foo.Instance() # Good. Being explicit is in line with the Python Zen\n   g = Foo.Instance() # Returns already created instance\n\n   print f is g # True\n</code>\n</pre>\n", "senID": 1}, {"text": ["And here's the code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Singleton:\n    \"\"\"\n    A non-thread-safe helper class to ease implementing singletons.\n    This should be used as a decorator -- not a metaclass -- to the\n    class that should be a singleton.\n\n    The decorated class can define one `__init__` function that\n    takes only the `self` argument. Other than that, there are\n    no restrictions that apply to the decorated class.\n\n    To get the singleton instance, use the `Instance` method. Trying\n    to use `__call__` will result in a `TypeError` being raised.\n\n    The decorated class cannot be inherited from.\n\n    \"\"\"\n\n    def __init__(self, decorated):\n        self._decorated = decorated\n\n    def Instance(self):\n        \"\"\"\n        Returns the singleton instance. Upon its first call, it creates a\n        new instance of the decorated class and calls its `__init__` method.\n        On all subsequent calls, the already created instance is returned.\n\n        \"\"\"\n        try:\n            return self._instance\n        except AttributeError:\n            self._instance = self._decorated()\n            return self._instance\n\n    def __call__(self):\n        \"\"\"\n        Call method that raises an exception in order to prevent creation\n        of multiple instances of the singleton. The `Instance` method should\n        be used instead.\n\n        \"\"\"\n        raise TypeError(\n            'Singletons must be accessed through the `Instance` method.')\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Well, other than agreeing with the general Pythonic suggestion on having module-level global, how about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def singleton(class_):\n    class class_w(class_):\n        _instance = None\n        def __new__(class2, *args, **kwargs):\n            if class_w._instance is None:\n                class_w._instance = super(class_w, class2).__new__(class2, *args, **kwargs)\n                class_w._instance._sealed = False\n            return class_w._instance\n        def __init__(self, *args, **kwargs):\n            if self._sealed:\n                return\n            super(class_w, self).__init__(*args, **kwargs)\n            self._sealed = True\n    class_w.__name__ = class_.__name__\n    return class_w\n\n@singleton\nclass MyClass(object):\n    def __init__(self, text):\n        print text\n    @classmethod\n    def name(class_):\n        print class_.__name__\n\nx = MyClass(111)\nx.name()\ny = MyClass(222)\nprint id(x) == id(y)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 111     # the __init__ is called only on the 1st time\nMyClass # the __name__ is preserved\nTrue    # this is actually the same instance\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Google Developers Day US - Python Design Patterns. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Alex Martelli. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Creational Patterns: http://www.youtube.com/watch?v=0vJJlVBVTFg#t=14m38s"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.youtube.com/watch?v=0vJJlVBVTFg#t=14m38s", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.youtube.com/watch?v=0vJJlVBVTFg#t=14m38s"}]}]]