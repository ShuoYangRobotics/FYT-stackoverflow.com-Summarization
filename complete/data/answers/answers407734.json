[[{"text": ["Um, Queue.PriorityQueue ?", "Recall that Python isn't strongly typed, so you can save anything you like: just make a tuple of (priority,thing) and you're set."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Queue.PriorityQueue", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/queue.html#Queue.PriorityQueue"}]}], [{"text": ["How do you know it's too slow?", "Have you profiled it yet?", "Also since 2.4, there's a C implementation of heapq in the standard library which is used."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Did you look at the \"Show Source\" link on the heapq page?", "There's an example a little less than halfway down of using a heap with a list of (int, char) tuples as a priority queue."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\"Show Source\" link", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/_sources/library/heapq.txt"}]}], [{"text": ["I've not used it, but you could try PyHeap.", "It's written in C so hopefully it is fast enough for you. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PyHeap", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://hkn.eecs.berkeley.edu/~dyoo/python/"}]}, {"text": ["Are you positive heapq/PriorityQueue won't be fast enough?", "It might be worth going with one of them to start, and then profiling to see if it really is your performance bottlneck."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I ended up implementing a wrapper for heapq, adding a dict for maintaining the queue's elements unique.", "The result should be quite efficient for all operators:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "heapq", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class PriorityQueueSet(object):\n    \"\"\" Combined priority queue and set data structure. Acts like\n        a priority queue, except that its items are guaranteed to\n        be unique.\n\n        Provides O(1) membership test, O(log N) insertion and \n        O(log N) removal of the smallest item.\n\n        Important: the items of this data structure must be both\n        comparable and hashable (i.e. must implement __cmp__ and\n        __hash__). This is true of Python's built-in objects, but\n        you should implement those methods if you want to use\n        the data structure for custom objects.\n    \"\"\"\n    def __init__(self, items=[]):\n        \"\"\" Create a new PriorityQueueSet.\n\n            items:\n                An initial item list - it can be unsorted and \n                non-unique. The data structure will be created in\n                O(N).\n        \"\"\"\n        self.set = dict((item, True) for item in items)\n        self.heap = self.set.keys()\n        heapq.heapify(self.heap)\n\n    def has_item(self, item):\n        \"\"\" Check if *item* exists in the queue\n        \"\"\"\n        return item in self.set\n\n    def pop_smallest(self):\n        \"\"\" Remove and return the smallest item from the queue\n        \"\"\"\n        smallest = heapq.heappop(self.heap)\n        del self.set[smallest]\n        return smallest\n\n    def add(self, item):\n        \"\"\" Add *item* to the queue. The item will be added only\n            if it doesn't already exist in the queue.\n        \"\"\"\n        if not (item in self.set):\n            self.set[item] = True\n            heapq.heappush(self.heap, item)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can use heapq for non-integer elements (tuples)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from heapq import *\n\nheap = []\ndata = [(10,\"ten\"), (3,\"three\"), (5,\"five\"), (7,\"seven\"), (9, \"nine\"), (2,\"two\")]\nfor item in data:\n    heappush(heap, item)\nsorted = []\nwhile heap:\n    sorted.append(heappop(heap))\nprint sorted\ndata.sort()\nprint data == sorted\n</code>\n</pre>\n", "senID": 1}]]