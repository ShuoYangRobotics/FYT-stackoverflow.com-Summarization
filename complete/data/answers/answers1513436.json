[[{"text": ["I had this problem years ago, in 2001 -- since I was transliterating to Python from a reference-algorithm in C which used assign-and-test heavily, I was keen to keep a similar structure for the first draft (then refactor later once correctness was well tested).", "So I wrote a recipe in the Cookbook (see also here), which boils down to...:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "recipe", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://books.google.com/books?id=1Shx%5FVXS6ioC&lpg=PA181&ots=BB607IWaL1&dq=martelli%20cookbook%20test%20assign&pg=PA181#v=onepage&q=&f=false"}, {"href": "http://code.activestate.com/recipes/66061/", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n class DataHolder(object):\n    def set(self, value): self.value = value; return value\n</code>\n</pre>\n", "senID": 1}, {"text": ["so the if/elif tree can become:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "elif", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n dh = DataHolder()\nif dh.set(something()):\n  # do something with dh.value\nelif dh.set(somethingelse()):\n  # ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["the DataHolder class can clearly be embellished in various ways (and is so embellished in both the online and book versions), but this is the gist of it, and quite sufficient to answer your question."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "DataHolder", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Another alternative which offers some flexibility:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # Functions to be tested (can be expanded):\ntests = [something, somethingelse, yetsomethingelse, anotherfunction, another]\nfor i, f in enumerate(tests):\n    a = f()\n    if a:\n        if i == 0:\n            # do something with a\n        elif 1 &lt;= i &lt;= 3:\n            # do something else with a\n        else:\n            # ...\n        break\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or you can explicitly compare to the function:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n tests = [something, somethingelse, yetsomethingelse, anotherfunction, another]\nfor i, f in enumerate(tests):\n    a = f()\n    if a: break\nif not a:\n    # no result\nelif f == something:\n    # ...\nelif f == somethingelse:\n    # ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["If some of the functions take arguments, you can use lambda to keep the function paradigm:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n tests = [lambda: something(args), somethingelse, lambda: something(otherargs)]\nfor i, f in enumerate(tests):\n    a = f()\n    if a: break\nif not a:\n    # no result\nelif i == 0:\n    # ...\nelif i == 1:\n    # ...\n</code>\n</pre>\n", "senID": 5}], [{"text": ["You could do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = something()\nif a:\n    #do something with a\nelse:\n    a = somethingelse()\n    if a:\n        #...\n    else:\n        #5 more nested ifs\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or, inside a function you can limit the nesting level with a return in each matching case:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "return", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def f():\n    a = something()\n    if a:\n        #do something with a\n        return\n    a = somethingelse()\n    if a:\n        #...\n        return\n    #5 more ifs\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You could use a decorator like this memorise for those functions - assuming they always return the same value.", "Notice that you can call expensive_foo and expensive_bar as many times as you like and the function body only ever gets executed once"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def memoize(f):\n    mem = {}\n    def inner(*args):\n        if args not in mem:\n            mem[args] = f(*args)\n        return mem[args]\n    return inner\n\n@memoize\ndef expensive_foo():\n    print \"expensive_foo\"\n    return False\n\n@memoize\ndef expensive_bar():\n    print \"expensive_bar\"\n    return True\n\nif expensive_foo():\n    a=expensive_foo()\n    print \"FOO\"\nelif expensive_bar():\n    a=expensive_bar()\n    print \"BAR\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I might be missing something, but couldn't you factor each of the branches in your top-level if statement into separate functions, create a list of test to action tuples and loop over them?", "You should be able to apply this pattern to mimic if (value=condition()) {} else if (value=other_condition()) {} style logic."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "test", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "action", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "if (value=condition()) {} else if (value=other_condition()) {}", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This is really an extension of redglyph's response and can probably be compressed down to a iterator that raises StopIteration once it has hit a truth value."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "redglyph's response", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1513436/what-should-i-use-instead-of-assignment-in-an-expression-in-python/1513627#1513627"}, {"href": "http://docs.python.org/tutorial/classes.html#iterators", "text": "iterator", "childNum": 0, "tag": "a", "childList": []}, {"text": "StopIteration", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n #\n# These are the \"tests\" from your original if statements. No\n# changes should be necessary.\n#\ndef something():\n    print('doing something()')\n    # expensive stuff here\ndef something_else():\n    print('doing something_else()')\n    # expensive stuff here too... but this returns True for some reason\n    return True\ndef something_weird():\n    print('doing something_weird()')\n    # other expensive stuff\n\n#\n# Factor each branch of your if statement into a separate function.\n# Each function will receive the output of the test if the test\n# was selected.\n#\ndef something_action(value):\n    print(\"doing something's action\")\ndef something_else_action(value):\n    print(\"doing something_else's action\")\ndef something_weird_action(value):\n    print(\"doing something_weird's action\")\n\n#\n# A simple iteration function that takes tuples of (test,action). The\n# test is called. If it returns a truth value, then the value is passed\n# onto the associated action and the iteration is stopped.\n#\ndef do_actions(*action_tuples):\n    for (test,action) in action_tuples:\n        value = test()\n        if value:\n            return action(value)\n\n#\n# ... and here is how you would use it:\n#\nresult = do_actions(\n             (something, something_action),\n             (something_else, something_else_action),\n             (something_weird, something_weird_action)\n)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Make yourself a simple callable object that saves its returned value:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class ConditionValue(object):\n    def __call__(self, x):\n        self.value = x\n        return bool(x)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now use it like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # example code\nmakelower = lambda c : c.isalpha() and c.lower()\nadd10 = lambda c : c.isdigit() and int(c) + 10\n\ntest = \"ABC123.DEF456\"\nval = ConditionValue()\nfor t in test:\n    if val(makelower(t)):\n        print t, \"is now lower case -&gt;\", val.value\n    elif val(add10(t)):\n        print t, \"+10 -&gt;\", val.value\n    else:\n        print \"unknown char\", t\n</code>\n</pre>\n", "senID": 3}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n A is now lower case -&gt; a\nB is now lower case -&gt; b\nC is now lower case -&gt; c\n1 +10 -&gt; 11\n2 +10 -&gt; 12\n3 +10 -&gt; 13\nunknown char .\nD is now lower case -&gt; d\nE is now lower case -&gt; e\nF is now lower case -&gt; f\n4 +10 -&gt; 14\n5 +10 -&gt; 15\n6 +10 -&gt; 16\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I would solve this the same way I solve several other problems of tricky flow control: move the tricky bit into a function, and then use return to cause an early exit from the function.", "Like so:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "return", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def do_correct_something():\n    a = something()\n    if a:\n        # do something with a\n        return a\n\n    a = somethingelse()\n    if a:\n        # do something else with a\n        return a\n\n    # 5 more function calls, if statements, do somethings, and returns\n\n    # then, at the very end:\n    return None\n\na = do_correct_something()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The major other \"tricky problem of flow control\" for which I do this is breaking out of multiple nested loops:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def find_in_3d_matrix(matrix, x):\n    for 2d_slice in matrix:\n        for row in 2d_slice:\n            for item in row:\n                if test_function(x, item):\n                    return item\n    return None\n</code>\n</pre>\n", "senID": 3}, {"text": ["You can also solve the stated question by writing a for loop that will iterate only once, and use \"break\" for the early exit, but I prefer the function-with-return version.", "It's less tricky, and clearer what is going on; and the function-with-return is the only clean way to break out of multiple loops in Python.", "(Putting \"if break_flag: break\" in each of the for loops, and setting break_flag when you want to break, is not IMHO clean."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "if break_flag: break", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}]]