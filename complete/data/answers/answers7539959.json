[[{"code": "<pre>\n<code>\n for prefix in prefixes:\n    if name.startswith(prefix):\n        name=name[len(prefix):]\n        break\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If you define prefix to be the characters before an underscore, then you can check for "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if name.partition(\"_\")[0] in [\"i\", \"c\", \"m\", \"l\", \"d\", \"t\", \"e\", \"b\", \"foo\"] and name.partition(\"_\")[1] == \"_\":\n    name = name.partition(\"_\")[2]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A bit hard to read, but this works:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n name=name[len(filter(name.startswith,prefixes+[''])[0]):]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["When it comes to search and efficiency always thinks of indexing techniques to improve your algorithms.", "If you have a long list of prefixes you can use an in-memory index by simple indexing the prefixes  by the first character into a dict."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This solution is only worth if you had a long list of prefixes and performance becomes an issue."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n pref = [\"i_\", \"c_\", \"m_\", \"l_\", \"d_\", \"t_\", \"e_\", \"b_\"]\n\n#indexing prefixes in a dict. Do this only once.\nd = dict()\nfor x in pref:\n        if not x[0] in d:\n                d[x[0]] = list()\n        d[x[0]].append(x)\n\n\nname = \"c_abcdf\"\n\n#lookup in d to only check elements with the same first character.\nresult = filter(lambda x: name.startswith(x),\\\n                        [] if name[0] not in d else d[name[0]])\nprint result\n</code>\n</pre>\n", "senID": 2}], [{"text": ["str.startswith(prefix[, start[, end]])\u00b6"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Return True if string starts with the prefix,\n  otherwise return False.", "prefix can also be a tuple of prefixes to \n  look for.", "With optional start, test string beginning at that position.", "With optional end, stop comparing string at that position."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Regexes will likely give you the best speed:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n prefixes = [\"i_\", \"c_\", \"m_\", \"l_\", \"d_\", \"t_\", \"e_\", \"b_\", \"also_longer_\"]\nre_prefixes = \"|\".join(re.escape(p) for p in prefixes)\n\nm = re.match(re_prefixes, my_string)\nif m:\n    my_string = my_string[m.end()-m.start():]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["What about using filter?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "filter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n prefs = [\"i_\", \"c_\", \"m_\", \"l_\", \"d_\", \"t_\", \"e_\", \"b_\"]\nname = list(filter(lambda item: not any(item.startswith(prefix) for prefix in prefs), name))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that the comparison of each list item against the prefixes efficiently halts on the first match.", "This behaviour is guaranteed by the any function that returns as soon as it finds a True value, eg:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "any", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def gen():\n    print(\"yielding False\")\n    yield False\n    print(\"yielding True\")\n    yield True\n    print(\"yielding False again\")\n    yield False\n\n&gt;&gt;&gt; any(gen()) # last two lines of gen() are not performed\nyielding False\nyielding True\nTrue\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or, using re.match instead of startswith:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "re.match", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "startswith", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import re\npatt = '|'.join([\"i_\", \"c_\", \"m_\", \"l_\", \"d_\", \"t_\", \"e_\", \"b_\"])\nname = list(filter(lambda item: not re.match(patt, item), name))\n</code>\n</pre>\n", "senID": 5}], [{"text": ["This edits the list on the fly, removing prefixes.", "The break skips the rest of the prefixes once one is found for a particular item."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "break", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n items = ['this', 'that', 'i_blah', 'joe_cool', 'what_this']\nprefixes = ['i_', 'c_', 'a_', 'joe_', 'mark_']\n\nfor i,item in enumerate(items):\n    for p in prefixes:\n        if item.startswith(p):\n            items[i] = item[len(p):]\n            break\n\nprint items\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n<code>\n ['this', 'that', 'blah', 'cool', 'what_this']\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Regex, tested:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef make_multi_prefix_matcher(prefixes):\n    regex_text = \"|\".join(re.escape(p) for p in prefixes)\n    print repr(regex_text)\n    return re.compile(regex_text).match\n\npfxs = \"x ya foobar foo a|b z.\".split()\nnames = \"xenon yadda yeti food foob foobarre foo a|b a b z.yx zebra\".split()\n\nmatcher = make_multi_prefix_matcher(pfxs)\nfor name in names:\n    m = matcher(name)\n    if not m:\n        print repr(name), \"no match\"\n        continue\n    n = m.end()\n    print repr(name), n, repr(name[n:])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 'x|ya|foobar|foo|a\\\\|b|z\\\\.'\n'xenon' 1 'enon'\n'yadda' 2 'dda'\n'yeti' no match\n'food' 3 'd'\n'foob' 3 'b'\n'foobarre' 6 're'\n'foo' 3 ''\n'a|b' 3 ''\n'a' no match\n'b' no match\n'z.yx' 2 'yx'\n'zebra' no match\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n import re\n\ndef make_multi_prefix_replacer(prefixes):\n    if isinstance(prefixes,str):\n        prefixes = prefixes.split()\n    prefixes.sort(key = len, reverse=True)\n    pat = r'\\b(%s)' % \"|\".join(map(re.escape, prefixes))\n    print 'regex patern :',repr(pat),'\\n'\n    def suber(x, reg = re.compile(pat)):\n        return reg.sub('',x)\n    return suber\n\n\n\npfxs = \"x ya foobar yaku foo a|b z.\"\nreplacer = make_multi_prefix_replacer(pfxs)               \n\nnames = \"xenon yadda yeti yakute food foob foobarre foo a|b a b z.yx zebra\".split()\nfor name in names:\n    print repr(name),'\\n',repr(replacer(name)),'\\n'\n\nss = 'the yakute xenon is a|bcdf in the barfoobaratu foobarii'\nprint '\\n',repr(ss),'\\n',repr(replacer(ss)),'\\n'\n</code>\n</pre>\n", "senID": 0}]]