[[{"text": ["\"Random access O(1)\" is an extremely exacting requirement which basically imposes an underlying hash table -- and I hope you do mean random READS only, because I think it can be mathematically proven than it's impossible in the general case to have O(1) writes as well as O(N) ordered iteration."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I don't think you will find a pre-packaged container suited to your needs because they are so extreme -- O(log N) access would of course make all the difference in the world.", "To get the big-O behavior you want for reads and iterations you'll need to glue two data structures, essentially a dict and a heap (or sorted list or tree), and keep them in sync.", "Although you don't specify, I think you'll only get amortized behavior of the kind you want - unless you're truly willing to pay any performance hits for inserts and deletes, which is the literal implication of the specs you express but does seem a pretty unlikely real-life requirement."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "amortized", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["For O(1) read and amortized O(N) ordered iteration, just keep a list of all keys on the side of a dict.", "E.g."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "amortized", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Crazy(object):\n  def __init__(self):\n    self.d = {}\n    self.L = []\n    self.sorted = True\n  def __getitem__(self, k):\n    return self.d[k]\n  def __setitem__(self, k, v):\n    if k not in self.d:\n      self.L.append(k)\n      self.sorted = False\n    self.d[k] = v\n  def __delitem__(self, k):\n    del self.d[k]\n    self.L.remove(k)\n  def __iter__(self):\n    if not self.sorted:\n      self.L.sort()\n      self.sorted = True\n    return iter(self.L)\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you don't like the \"amortized O(N) order\" you can remove self.sorted and just repeat self.L.sort() in __setitem__ itself.", "That makes writes O(N log N), of course (while I still had writes at O(1)).", "Either approach is viable and it's hard to think of one as intrinsically superior to the other.", "If you tend to do a bunch of writes then a bunch of iterations then the approach in the code above is best; if it's typically one write, one iteration, another write, another iteration, then it's just about a wash."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "self.L.sort()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__setitem__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["BTW, this takes shameless advantage of the unusual (and wonderful;-) performance characteristics of Python's sort (aka \"timsort\"): among them, sorting a list that's mostly sorted but with a few extra items tacked on at the end is basically O(N) (if the tacked on items are few enough compared to the sorted prefix part).", "I hear Java's gaining this sort soon, as Josh Block was so impressed by a tech talk on Python's sort that he started coding it for the JVM on his laptop then and there.", "Most sytems (including I believe Jython as of today and IronPython too) basically have sorting as an O(N log N) operation, not taking advantage of \"mostly ordered\" inputs; \"natural mergesort\", which Tim Peters fashioned into Python's timsort of today, is a wonder in this respect."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["An ordered tree is usually better for this cases, but random access is going to be log(n).", "You should keep into account also insertion and removal costs..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Here is my own implementation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import bisect\nclass KeyOrderedDict(object):\n   __slots__ = ['d', 'l']\n   def __init__(self, *args, **kwargs):\n      self.l = sorted(kwargs)\n      self.d = kwargs\n\n   def __setitem__(self, k, v):\n      if not k in self.d:\n         idx = bisect.bisect(self.l, k)\n         self.l.insert(idx, k)\n       self.d[k] = v\n\n   def __getitem__(self, k):\n      return self.d[k]\n\n   def __delitem__(self, k):\n      idx = bisect.bisect_left(self.l, k)\n      del self.l[idx]\n      del self.d[k]\n\n   def __iter__(self):\n      return iter(self.l)\n\n   def __contains__(self, k):\n      return k in self.d\n</code>\n</pre>\n", "senID": 1}, {"text": ["The use of bisect keeps self.l ordered, and insertion is O(n) (because of the insert, but not a killer in my case, because I append far more often than truly insert, so the usual case is amortized O(1)).", "Access is O(1), and iteration O(n).", "But maybe someone had invented (in C) something with a more clever structure ?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could build a dict that allows traversal by storing a pair (value, next_key) in each position.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "(value, next_key)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Random access:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n my_dict[k][0]   # for a key k\n</code>\n</pre>\n", "senID": 2}, {"text": ["Traversal:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n k = start_key   # stored somewhere\nwhile k is not None:     # next_key is None at the end of the list\n    v, k = my_dict[k]\n    yield v\n</code>\n</pre>\n", "senID": 4}, {"text": ["Keep a pointer to start and end and you'll have efficient update for those cases where you just need to add onto the end of the list."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "start", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "end", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Inserting in the middle is obviously O(n).", "Possibly you could build a skip list on top of it if you need more speed."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "skip list", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Skiplist"}]}], [{"text": ["I'm not sure which python version are you working in, but in case you like to experiment, Python 3.1 includes and official implementation of Ordered dictionaries:\nhttp://www.python.org/dev/peps/pep-0372/\nhttp://docs.python.org/3.1/whatsnew/3.1.html#pep-372-ordered-dictionaries"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "http://www.python.org/dev/peps/pep-0372/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0372/"}, {"href": "http://docs.python.org/3.1/whatsnew/3.1.html#pep-372-ordered-dictionaries", "text": "http://docs.python.org/3.1/whatsnew/3.1.html#pep-372-ordered-dictionaries", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["here's a pastie: I Had a need for something similar.", "Note however that this specific implementation is immutable, there are no inserts, once the instance is created:  The exact performance doesn't quite match what you're asking for, however.", "Lookup is O(log n) and full scan is O(n).", "This works using the bisect module upon a tuple of key/value (tuple) pairs.", "Even if you can't use this precisely, you might have some success adapting it to your needs."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "bisect", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n import bisect\n\nclass dictuple(object):\n    \"\"\"\n        &gt;&gt;&gt; h0 = dictuple()\n        &gt;&gt;&gt; h1 = dictuple({\"apples\": 1, \"bananas\":2})\n        &gt;&gt;&gt; h2 = dictuple({\"bananas\": 3, \"mangoes\": 5})\n        &gt;&gt;&gt; h1+h2\n        ('apples':1, 'bananas':3, 'mangoes':5)\n        &gt;&gt;&gt; h1 &gt; h2\n        False\n        &gt;&gt;&gt; h1 &gt; 6\n        False\n        &gt;&gt;&gt; 'apples' in h1\n        True\n        &gt;&gt;&gt; 'apples' in h2\n        False\n        &gt;&gt;&gt; d1 = {}\n        &gt;&gt;&gt; d1[h1] = \"salad\"\n        &gt;&gt;&gt; d1[h1]\n        'salad'\n        &gt;&gt;&gt; d1[h2]\n        Traceback (most recent call last):\n        ...\n        KeyError: ('bananas':3, 'mangoes':5)\n   \"\"\"\n\n\n    def __new__(cls, *args, **kwargs):\n        initial = {}\n        args = [] if args is None else args\n        for arg in args:\n            initial.update(arg)\n        initial.update(kwargs)\n\n        instance = object.__new__(cls)\n        instance.__items = tuple(sorted(initial.items(),key=lambda i:i[0]))\n        return instance\n\n    def __init__(self,*args, **kwargs):\n        pass\n\n    def __find(self,key):\n        return bisect.bisect(self.__items, (key,))\n\n\n    def __getitem__(self, key):\n        ind = self.__find(key)\n        if self.__items[ind][0] == key:\n            return self.__items[ind][1]\n        raise KeyError(key)\n    def __repr__(self):\n        return \"({0})\".format(\", \".join(\n                        \"{0}:{1}\".format(repr(item[0]),repr(item[1]))\n                          for item in self.__items))\n    def __contains__(self,key):\n        ind = self.__find(key)\n        return self.__items[ind][0] == key\n    def __cmp__(self,other):\n\n        return cmp(self.__class__.__name__, other.__class__.__name__\n                  ) or cmp(self.__items, other.__items)\n    def __eq__(self,other):\n        return self.__items == other.__items\n    def __format__(self,key):\n        pass\n    #def __ge__(self,key):\n    #    pass\n    #def __getattribute__(self,key):\n    #    pass\n    #def __gt__(self,key):\n    #    pass\n    __seed = hash(\"dictuple\")\n    def __hash__(self):\n        return dictuple.__seed^hash(self.__items)\n    def __iter__(self):\n        return self.iterkeys()\n    def __len__(self):\n        return len(self.__items)\n    #def __reduce__(self,key):\n    #    pass\n    #def __reduce_ex__(self,key):\n    #    pass\n    #def __sizeof__(self,key):\n    #    pass\n\n    @classmethod\n    def fromkeys(cls,key,v=None):\n        cls(dict.fromkeys(key,v))\n\n    def get(self,key, default):\n        ind = self.__find(key)\n        return self.__items[ind][1] if self.__items[ind][0] == key else default\n\n    def has_key(self,key):\n        ind = self.__find(key)\n        return self.__items[ind][0] == key\n\n    def items(self):\n        return list(self.iteritems())\n\n    def iteritems(self):\n        return iter(self.__items)\n\n    def iterkeys(self):\n        return (i[0] for i in self.__items)\n\n    def itervalues(self):\n        return (i[1] for i in self.__items)\n\n    def keys(self):\n        return list(self.iterkeys())\n\n    def values(self):\n        return list(self.itervalues())\n    def __add__(self, other):\n        _sum = dict(self.__items)\n        _sum.update(other.__items)\n        return self.__class__(_sum)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n</code>\n</pre>\n", "senID": 1}]]