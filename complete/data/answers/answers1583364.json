[[{"text": ["How about calling any twice, on an iterator (Python 2.x and 3.x compatible)?"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "any", "tag": "a", "pos": 0, "childList": [{"text": "any", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/functions.html#any"}, {"text": "any", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def has_one(seq, predicate=bool):\n...     seq = (predicate(e) for e in seq)\n...     return any(seq) and not any(seq)\n... \n&gt;&gt;&gt; has_one([])\nFalse\n&gt;&gt;&gt; has_one([1])\nTrue\n&gt;&gt;&gt; has_one([0])\nFalse\n&gt;&gt;&gt; has_one([1, 2])\nFalse\n</code>\n</pre>\n", "senID": 1}, {"text": ["any will take at most one element which evaluates to True from the iterator.", "If it succeeds the first time and fails the second time, then only one element matches the predicate."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "any", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "one", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: I see Robert Rossney suggests a generalized version, which checks whether exactly n elements match the predicate.", "Let me join in on the fun, using all:"], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "Robert Rossney", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/19403/robert-rossney"}, {"text": "n", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"href": "http://docs.python.org/3.1/library/functions.html#all", "text": "all", "childNum": 1, "tag": "a", "childList": [{"text": "all", "tag": "code"}]}, {"text": "all", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def has_n(seq, n, predicate=bool):\n...     seq = (predicate(e) for e in seq)\n...     return all(any(seq) for _ in range(n)) and not any(seq)\n... \n&gt;&gt;&gt; has_n(range(0), 3)\nFalse\n&gt;&gt;&gt; has_n(range(3), 3)\nFalse\n&gt;&gt;&gt; has_n(range(4), 3)\nTrue\n&gt;&gt;&gt; has_n(range(5), 3)\nFalse\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I liked Stephan202's answer, but I like this one a little more, even though it's two lines instead of one.", "I like it because it's just as crazy but a tiny bit more explicit about how its craziness works:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def has_one(seq):\n    g = (x for x in seq)\n    return any(g) and not any(g)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Here's a more generalized version that supports a predicate:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def has_exactly(seq, count, predicate = bool):\n    g = (predicate(x) for x in seq)\n    while(count &gt; 0):\n        if not any(g):\n            return False\n        count -= 1\n    if count == 0:\n        return not any(g)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Not sure whether it is any better than the versions you proposed, however..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If predicate is guaranteed to return True/False only, then"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n sum(map(predicate, seq)) == 1\n</code>\n</pre>\n", "senID": 2}, {"text": ["will do (although it won't stop at the second element)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Perhaps something like this is more to your taste?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def has_one(seq,predicate=bool):\n    nwanted=1\n    n=0\n    for item in seq:\n        if predicate(item):\n            n+=1\n            if n&gt;nwanted:\n                return False\n\n    return n==nwanted\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is rather like the list comprehension example, but requires only one pass over one sequence.", "Compared to the second has_one function, and like the list comprehension code, it generalizes more easily to other counts.", "I've demonstrated this (hopefully without error...) by adding in a variable for the number of items wanted."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "has_one", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["How about ..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import functools\nimport operator\n\ndef exactly_one(seq):\n    \"\"\"\n    Handy for ensuring that exactly one of a bunch of options has been set.\n    &gt;&gt;&gt; exactly_one((3, None, 'frotz', None))\n    False\n    &gt;&gt;&gt; exactly_one((None, None, 'frotz', None))\n    True\n    \"\"\"\n    return 1 == functools.reduce(operator.__add__, [1 for x in seq if x])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's modified @Stephan202's answer:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@Stephan202's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1583364/idiomatic-python-hasone/1583465#1583465"}]}, {"code": "<pre>\n<code>\n from itertools import imap, repeat\n\ndef exactly_n_is_true(iterable, n, predicate=None):\n    it = iter(iterable) if predicate is None else imap(predicate, iterable)\n    return all(any(it) for _ in repeat(None, n)) and not any(it)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Differences:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n if exactly_n_is_true(seq, 1, predicate):\n   # predicate() is true for exactly one item from the seq\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Look, Ma!", "No rtfm(\"itertools\"), no dependency on predicate() returning a boolean, minimum evaluation, just works!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Python 1.5.2 (#0, Apr 13 1999, 10:51:12) [MSC 32 bit (Intel)] on win32\nCopyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam\n&gt;&gt;&gt; def count_in_bounds(seq, predicate=lambda x: x, low=1, high=1):\n...     count = 0\n...     for item in seq:\n...         if predicate(item):\n...             count = count + 1\n...             if count &gt; high:\n...                 return 0\n...     return count &gt;= low\n...\n&gt;&gt;&gt; seq1 = [0, 0, 1, 0, 1, 0, 1, 0, 0, 0]\n&gt;&gt;&gt; count_in_bounds(seq1)\n0\n&gt;&gt;&gt; count_in_bounds(seq1, low=3, high=3)\n1\n&gt;&gt;&gt; count_in_bounds(seq1, low=3, high=4)\n1\n&gt;&gt;&gt; count_in_bounds(seq1, low=4, high=4)\n0\n&gt;&gt;&gt; count_in_bounds(seq1, low=0, high=3)\n1\n&gt;&gt;&gt; count_in_bounds(seq1, low=3, high=3)\n1\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}]]