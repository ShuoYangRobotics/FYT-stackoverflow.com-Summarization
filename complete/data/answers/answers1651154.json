[[{"text": ["The alternative would be quite heavyweight -- storing \"default argument values\" in the function object as \"thunks\" of code to be executed over and over again every time the function is called without a specified value for that argument -- and would make it much harder to get early binding (binding at def time), which is often what you want.", "For example, in Python as it exists:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def ack(m, n, _memo={}):\n  key = m, n\n  if key not in _memo:\n    if m==0: v = n + 1\n    elif n==0: v = ack(m-1, 1)\n    else: v = ack(m-1, ack(m, n-1))\n    _memo[key] = v\n  return _memo[key]\n</code>\n</pre>\n", "senID": 1}, {"text": ["...writing a memoized function like the above is quite an elementary task.", "Similarly:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for i in range(len(buttons)):\n  buttons[i].onclick(lambda i=i: say('button %s', i))\n</code>\n</pre>\n", "senID": 3}, {"text": ["...the simple i=i, relying on the early-binding (definition time) of default arg values, is a trivially simple way to get early binding.", "So, the current rule is simple, straightforward, and lets you do all you want in a way that's extremely easy to explain and understand: if you want late binding of an expression's value, evaluate that expression in the function body; if you want early binding, evaluate it as the default value of an arg."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "i=i", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The alternative, forcing late binding for both situation, would not offer this flexibility, and would force you to go through hoops (such as wrapping your function into a closure factory) every time you needed early binding, as in the above examples -- yet more heavy-weight boilerplate forced on the programmer by this hypothetical design decision (beyond the \"invisible\" ones of generating and repeatedly evaluating thunks all over the place)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["In other words, \"There should be one, and preferably only one, obvious way to do it [1]\": when you want late binding, there's already a perfectly obvious way to achieve it (since all of the function's code is only executed at call time, obviously everything evaluated there is late-bound); having default-arg evaluation produce early binding gives you an obvious way to achieve early binding as well (a plus!-) rather than giving TWO obvious ways to get late binding and no obvious way to get early binding (a minus!-)."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "there", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["[1]: \"Although that way may not be obvious at first unless you're Dutch."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["The issue is this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's too expensive to evaluate a function as an initializer every time the function is called."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "every time the function is called", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": ["0 is a simple literal.", "Evaluate it once, use it forever."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["int is a function (like list) that would have to be evaluated each time it's required as an initializer."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "int", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}, {"text": ["The construct [] is literal, like 0, that means \"this exact object\"."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "[]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The problem is that some people hope that it to means list as in \"evaluate this function for me, please, to get the object that is the initializer\"."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["It would be a crushing burden to add the necessary if statement to do this evaluation all the time.", "It's better to take all arguments as literals and not do any additional function evaluation as part of trying to do a function evaluation."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Also, more fundamentally, it's technically impossible to implement argument defaults as function evaluations."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "impossible", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Consider, for a moment the recursive horror of this kind of circularity.", "Let's say that instead of default values being literals, we allow them to be functions which are evaluated each time a parameter's default values are required."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["[This would parallel the way collections.defaultdict works."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "collections.defaultdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def aFunc( a=another_func ):\n    return a*2\n\ndef another_func( b=aFunc ):\n    return b*3\n</code>\n</pre>\n", "senID": 10}, {"text": ["What is the value of another_func()?", "To get the default for b, it must evaluate aFunc, which requires an eval of another_func.", "Oops."], "childNum": 4, "tag": "p", "senID": 11, "childList": [{"text": "another_func()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "aFunc", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "another_func", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["The workaround for this, discussed here (and very solid), is:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "discussed here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.network-theory.co.uk/docs/pytut/DefaultArgumentValues.html"}]}, {"code": "<pre>\n<code>\n class Node(object):\n    def __init__(self, children = None):\n        self.children = [] if children is None else children\n</code>\n</pre>\n", "senID": 1}, {"text": ["As for why look for an answer from von L\u00f6wis, but it's likely because the function definition makes a code object due to the architecture of Python, and there might not be a facility for working with reference types like this in default arguments."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Of course in your situation it is difficult to understand.", "But you must see, that evaluating default args every time would lay a heavy runtime burden on the system."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also you should know, that in case of container types this problem may occur -- but you could circumvent it by making the thing explicit:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def __init__(self, children = None):\n    if children is None:\n       children = []\n    self.children = children\n</code>\n</pre>\n", "senID": 2}], [{"text": ["This comes from python's emphasis on syntax and execution simplicity.", "a def statement occurs at a certain point during execution.", "When the python interpreter reaches that point, it evaluates the code in that line, and then creates a code object from the body of the function, which will be run later, when you call the function.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's a simple split between function declaration and function body.", "The declaration is executed when it is reached in the code.", "The body is executed at call time.", "Note that the declaration is executed every time it is reached, so you can create multiple functions by looping."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n funcs = []\nfor x in xrange(5):\n    def foo(x=x, lst=[]):\n        lst.append(x)\n        return lst\n    funcs.append(foo)\nfor func in funcs:\n    print \"1: \", func()\n    print \"2: \", func()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Five separate functions have been created, with a separate list created each time the function declaration was executed.", "On each loop through funcs, the same function is executed twice on each pass through, using the same list each time.", "This gives the results:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "funcs", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n 1:  [0]\n2:  [0, 0]\n1:  [1]\n2:  [1, 1]\n1:  [2]\n2:  [2, 2]\n1:  [3]\n2:  [3, 3]\n1:  [4]\n2:  [4, 4]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Others have given you the workaround, of using param=None, and assigning a list in the body if the value is None, which is fully idiomatic python.", "It's a little ugly, but the simplicity is powerful, and the workaround is not too painful."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Edited to add: For more discussion on this, see effbot's article here: http://effbot.org/zone/default-values.htm, and the language reference, here: http://docs.python.org/reference/compound%5Fstmts.html#function"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "http://effbot.org/zone/default-values.htm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/default-values.htm"}, {"href": "http://docs.python.org/reference/compound%5Fstmts.html#function", "text": "http://docs.python.org/reference/compound%5Fstmts.html#function", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I thought this was counterintuitive too, until I learned how Python implements default arguments."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A function's an object.", "At load time, Python creates the function object, evaluates the defaults in the def statement, puts them into a tuple, and adds that tuple as an attribute of the function named func_defaults.", "Then, when a function is called, if the call doesn't provide a value, Python grabs the default value out of func_defaults."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "def", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "func_defaults", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "func_defaults", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For instance:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class C():\n        pass\n\n&gt;&gt;&gt; def f(x=C()):\n        pass\n\n&gt;&gt;&gt; f.func_defaults\n(&lt;__main__.C instance at 0x0298D4B8&gt;,)\n</code>\n</pre>\n", "senID": 3}, {"text": ["So all calls to f that don't provide an argument will use the same instance of C, because that's the default value."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "f", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "C", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["As far as why Python does it this way:  well, that tuple could contain functions that would get called every time a default argument value was needed.", "Apart from the immediately obvious problem of performance, you start getting into a universe of special cases, like storing literal values instead of functions for non-mutable types to avoid unnecessary function calls.", "And of course there are performance implications galore."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "could", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["The actual behavior is really simple.", "And there's a trivial workaround, in the case where you want a default value to be produced by a function call at runtime:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "want", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def f(x = None):\n   if x == None:\n      x = g()\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Python function definitions are just code, like all the other code; they're not \"magical\" in the way that some languages are.", "For example, in Java you could refer \"now\" to something defined \"later\":"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n public static void foo() { bar(); }\npublic static void main(String[] args) { foo(); }\npublic static void bar() {}\n</code>\n</pre>\n", "senID": 1}, {"text": ["but in Python"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def foo(): bar()\nfoo()   # boom! \"bar\" has no binding yet\ndef bar(): pass\nfoo()   # ok\n</code>\n</pre>\n", "senID": 3}, {"text": ["So, the default argument is evaluated at the moment that that line of code is evaluated!"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Because if they had, then someone would post a question asking why it wasn't the other way around :-p"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Suppose now that they had.", "How would you implement the current behaviour if needed?", "It's easy to create new objects inside a function, but you cannot \"uncreate\" them (you can delete them, but it's not the same)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]