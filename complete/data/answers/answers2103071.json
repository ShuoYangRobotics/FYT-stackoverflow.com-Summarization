[[{"text": ["You could do something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from datetime import datetime\n\ntests = [\n    # (Type, Test)\n    (int, int),\n    (float, float),\n    (datetime, lambda value: datetime.strptime(value, \"%Y/%m/%d\"))\n]\n\ndef getType(value):\n     for typ, test in tests:\n         try:\n             test(value)\n             return typ\n         except ValueError:\n             continue\n     # No match\n     return str\n\n&gt;&gt;&gt; getType('2010/1/12')\n&lt;type 'datetime.datetime'&gt;\n&gt;&gt;&gt; getType('2010.2')\n&lt;type 'float'&gt;\n&gt;&gt;&gt; getType('2010')\n&lt;type 'int'&gt;\n&gt;&gt;&gt; getType('2013test')\n&lt;type 'str'&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["The key is in the tests order, for example the int test should be before the float test.", "And for dates you can add more tests for formats you want to support, but obviously you can't cover all possible cases."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["There's no real answer to this as far as I can tell since these are just strings.", "They're not integers or floats or whatever.", "Those are roles you decide.", "eg.", "Is 1 an integer or a float? "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "real", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"text": ["A couple of things come to mind though.", "One is to do some kind of pattern matching (eg.", "If it contains a decimal point, it's a float etc.).", "For parsing/guessing dates, you can try this or this. "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "this", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://labix.org/python-dateutil"}, {"href": "http://code-bear.com/code/parsedatetime/", "text": "this", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["You could also try 'casting' the element into whatever you want and catch exceptions to try the others.", "You can do something like try int, if it fails, try float and if that fails, try date etc."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This cannot be done in a reliable manner and that is not due to limitations in Python or any other programming language for that matter.", "A human being could not do this in a predictable manner without guessing and following a few rules (usually called Heuristics when used in this context). "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "A human being could not do this in a predictable manner without guessing and following a few rules", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"href": "http://en.wikipedia.org/wiki/Heuristic", "text": "Heuristics", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["So lets first design a few heuristics then encode them in Python.", "Things to consider are:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "All the values are valid strings we know that because that is the basis of our problem so there is no point in checking for this at all. We should check everything else we can whatever falls through we can just leave as a string.", "tag": "none", "senID": 2}, {"text": "Dates are the most obvious thing to check first if they are formatted in predictable manner such as ", "tag": "none", "senID": 3}, {"text": "We will do integers next because all integers are valid floats but not all floats are valid integers. We could just check if the text contains on digits (or digits and the letters A-F if hexadecimal numbers are possible) in this case treat the value as an integer.", "tag": "none", "senID": 4}, {"text": "Floats would be next as they are numbers with some formatting (the decimal point). It is easy to recognise ", "tag": "none", "senID": 5}, {"text": "Any values that are left unconverted can be treated as strings.", "tag": "none", "senID": 6}]}, {"text": ["Due to the possible overlaps I have mentioned above such a scheme can never be 100% reliable.", "Also any new data type that you need to support (complex number perhaps) would need its own set of heuristics and would have to placed in the most appropriate place in the chain of checks.", "The more likely a check is to match only the data type desired the higher up the chain it should be."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "such a scheme can never be 100% reliable", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Now lets make this real in Python, most of the heuristics I mentioned above are taken care of for us by Python we just need to decide on the order in which to apply them:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n from datetime import datetime\n\nheuristics = (lambda value: datetime.strptime(value, \"%Y-%m-%d\"),\n              int, float)\n\ndef convert(value):\n    for type in heuristics:\n        try:\n            return type(value)\n        except ValueError:\n            continue\n    # All other heuristics failed it is a string\n    return value\n\nvalues = ['3.14159265', '2010-01-20', '16', 'some words']\n\nfor value in values:\n    converted_value = convert(value)\n    print converted_value, type(converted_value)\n</code>\n</pre>\n", "senID": 9}, {"text": ["This outputs the following:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n 3.14159265 &lt;type 'float'&gt;\n2010-01-20 00:00:00 &lt;type 'datetime.datetime'&gt;\n16 &lt;type 'int'&gt;\nsome words &lt;type 'str'&gt;\n</code>\n</pre>\n", "senID": 11}], [{"text": ["What you want to acheive is difficult because the types are ambiguous: \"1\" could either be a string, or an int for example.", "At any rate, you could try something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": ["Dates: presumably they are in a known format: if so, you can try instantiating a datetime from the timestamp string (datetime.strptime()) and if it fails you know its not a datetime."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "datetime.strptime()", "tag": "a", "pos": 0, "childList": [{"text": "datetime.strptime()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/datetime.html#datetime.datetime.strptime"}, {"text": "datetime.strptime()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Floats: ensure all characters are either a digit and there is at least one \".", "\" in the string.", "Then convert to float (float(value))"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "float(value)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Integers: regex the string and match digits.", "Ensure the string is the same lenght as the source string then convert (int(value))"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "int(value)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If none of the above worked, it's a string."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]}], [{"text": ["Well..you can't."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["How would you decide if \"5\" is meant as a string or an integer?", "How would you decide if \"20100120\" is meant as an integer or a date?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can of course make educated guesses, and implement some kind of parse order.", "First try it as a date, then as a float, then as an int, and lastly as a string."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["From the manual:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "manual", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/csv.html"}]}, {"text": ["The interface requires that a string be returned each time next() is called."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The date is a bit harder.", "It depends on the format and how regular it is.", "Here is a clue to get you started on the rest."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; int('a')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: invalid literal for int() with base 10: 'a'\n&gt;&gt;&gt; int('1')\n1\n&gt;&gt;&gt; float('1')\n1.0\n&gt;&gt;&gt; float('1.0')\n1.0\n</code>\n</pre>\n", "senID": 1}, {"text": ["But notice:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; int(1.0)\n1\n</code>\n</pre>\n", "senID": 3}]]