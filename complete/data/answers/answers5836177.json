[[{"text": ["You can check if an element is a sequence by using isinstance(element, collections.Sequence)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "isinstance(element, collections.Sequence)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["\"sum\" functions takes an iterable, so I would check the element implements the __iter__ method or not,using \"hasattr\" builtin function."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__iter__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def recursive_sum(nested_num_list):\n    sum = 0\n    for element in nested_num_list:\n        if hasattr(element, '__iter__'):\n            sum = sum + recursive_sum(element)\n        else:\n            sum = sum + element\n    return sum\n</code>\n</pre>\n", "senID": 2}], [{"text": ["For the flattening of an aribtrarily nested list, you will always need some kind of check to test if an element is itself an iterable or a leaf node.", "I wouldn't combine the flattening with computing the sum in one function, but rather define a generator function that only does the flattening:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def flatten(x):\n    try:\n        it = iter(x)\n    except TypeError:\n        yield x\n    else:\n        for i in it:\n            for j in flatten(i):\n                yield j\n</code>\n</pre>\n", "senID": 1}, {"text": ["This way, you will have all the ugly bits contained in a single function.", "For a nested sequence x, you can now do"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n sum(flatten(x))\n</code>\n</pre>\n", "senID": 3}, {"text": ["to get the recursive sum."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Things that are true of a list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import collections\n&gt;&gt;&gt; hasattr(element, '__getitem__')\nTrue\n&gt;&gt;&gt; not hasattr(element, 'keys')\nTrue\n&gt;&gt;&gt; isinstance(element, collections.Sequence)\nTrue\n&gt;&gt;&gt; hasattr(element, '__iter__')\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["Things that are true of a string:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; string = '1234'\n&gt;&gt;&gt; hasattr(string, '__getitem__')\nTrue\n&gt;&gt;&gt; not hasattr(string, 'keys')\nTrue\n&gt;&gt;&gt; isinstance(string, collections.Sequence)\nTrue\n&gt;&gt;&gt; hasattr(string, '__iter__')\nFalse\n</code>\n</pre>\n", "senID": 3}], [{"text": ["What you see here isn't polymorphism in any language I know.", "+= for lists means one thing, for numbers another thing.", "You'd like += for lists to mean something unusual (sum up all elements and return the sum) - but this is only meaningful for your specific example.", "For other (most, I'd say) uses of lists, the original meaning of += is much more convenient."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "+=", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["To make this behave truly polymorphically, you can derive from list and make += mean what you want - then you won't need these hacks."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["BTW:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if type(element) == type([]):\n</code>\n</pre>\n", "senID": 3}, {"text": ["Should be rewritten to:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n if isinstance(element, list):\n</code>\n</pre>\n", "senID": 5}], [{"text": ["You were checking if the element can be added to a int, which is not what you wanted."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The try is not bad though: Try to use it as a iterable - if it works then it is a iterable:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "try", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def recursive_sum(nested_sum_list):\n    sum = 0\n    # this raises TypeError if element is not a sequence\n    for element in nested_num_list: \n        try:\n            sum += recursive_sum(element)\n        except TypeError:\n            sum += element\n    return sum\n</code>\n</pre>\n", "senID": 2}, {"text": ["There is also a typeclass for iterables:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "typeclass", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html#abcs-abstract-base-classes"}]}, {"code": "<pre>\n<code>\n import collections\nprint isinstance(element, collections.Iterable)\n</code>\n</pre>\n", "senID": 4}, {"text": ["which basically just searches for a __iter__ method."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "__iter__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The purpose of this function is not to be universally applicable for adding nested structures, it was simply created to illustrate recursion."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Adding more complex sequence type checking, try and except, or the ability to add something other than numbers would make the function less useful as a learning tool for recursion."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "less", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["That being said, isinstance(element, (list, tuple)) would probably be more appropriate here, and it wouldn't add any complexity."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "isinstance(element, (list, tuple))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]