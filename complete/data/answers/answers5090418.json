[[{"text": ["The glob module Python from 2.5 onwards has an iglob method which returns an iterator.", "An iterator is exactly for the purposes of not storing huge values in memory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n glob.iglob(pathname)\nReturn an iterator which yields the same values as glob() without\nactually storing them all simultaneously.\n</code>\n</pre>\n", "senID": 1}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import glob\nfor eachfile in glob.iglob('*'):\n    # act upon eachfile\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Since you are using Linux, you might want to look at pyinotify.", "It would allow you to write a Python script which monitors a directory for filesystem changes -- such as the creation, modification or deletion of files."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pyinotify", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyinotify.sourceforge.net/"}]}, {"text": ["Every time such a filesystem event occurs, you can arrange for the Python script to call a function.", "This would be roughly like yielding each filename once, while being able to react to modifications and deletions."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It sounds like you already have a million files sitting in a directory.", "In this case, if you were to move all those files to a new, pyinotify-monitored directory, then the filesystem events generated by the creation of new files would yield the filenames as desired. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["No method will reveal a filename which \"changed\".", "It's not even clear what you mean by this \"filenames change, new files are added, and files are deleted\"?", "What is your use case?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Let's say you have three files: a.a, b.b, c.c."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "a.a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b.b", "childNum": 0, "tag": "code", "childList": []}, {"text": "c.c", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Your magical \"iterator\" starts with a.a.   You process it."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "a.a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The magical \"iterator\" moves to b.b.", "You're processing it."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "b.b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Meanwhile a.a is copied to a1.a1, a.a is deleted.", "What now?", "What does your magical iterator do with these?", "It's already passed a.a.", "Since a1.a1 is before b.b, it will never see it.", "What's supposed to happen for \"filenames change, new files are added, and files are deleted\"?"], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": "a.a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a1.a1", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "a.a", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a.a", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a1.a1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "b.b", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The magical \"iterator\" moves to c.c.", "What was supposed to happen to the other files?", "And how were you supposed to find out about the deletion?"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "c.c", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Don't use the naked file system for coordination.  "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Use a queue."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Process A writes files and enqueues the add/change/delete memento onto a queue."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Process B reads the memento from queue and then does the follow-on processing on the file named in the memento."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["As I've written earlier, since \"iglob\" is just a facade for a real iterator, you will have to call low level system functions in order to get one at a time like you want.", "Fortyuantelly, that is doable from Python.", "If have not told wether you are on a Posix (Linux/mac OS X/other Unix) or Windows system.", "On the later case, you should check if win32api has any call to read \"the next entry from a dir\" or how to proceed otherwise."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["On the former case, you can proceed to call libc functions straight through ctypes and get a file-dir entry icnluding naming information) a time."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The documentation on teh C functions is here:\nhttp://www.gnu.org/s/libc/manual/html_node/Opening-a-Directory.html#Opening-a-Directory"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.gnu.org/s/libc/manual/html_node/Opening-a-Directory.html#Opening-a-Directory", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.gnu.org/s/libc/manual/html_node/Opening-a-Directory.html#Opening-a-Directory"}]}, {"text": ["http://www.gnu.org/s/libc/manual/html_node/Reading_002fClosing-Directory.html#Reading_002fClosing-Directory"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://www.gnu.org/s/libc/manual/html_node/Reading_002fClosing-Directory.html#Reading_002fClosing-Directory", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.gnu.org/s/libc/manual/html_node/Reading_002fClosing-Directory.html#Reading_002fClosing-Directory"}]}, {"text": ["Unfortunatelly, the \"dirent64\" C structure is determined at C compile time for each system - I had figured that on my system, and on most, it will be like I put it in Python on the snippet bellow - but you might want to checj your \"dirent.h\" and other fiels it includes under /usr/includes."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Here is the snippet using ctypes and libC  I've put together that allow you to get each filename, and perform actions on it.", "Note that ctypes automaticaly gives you a Python string when you do str(...) on the char array defined on the structure.", "(I am using the print statement, which implicitly calls Python's str)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from ctypes import *\nlibc = cdll.LoadLibrary( \"libc.so.6\")\n dir_ = c_voidp( libc.opendir(\"/home/jsbueno\"))\n\nclass Dirent(Structure):\n    _fields_ = [(\"d_ino\",  c_voidp),\n                (\"off_t\", c_int64),\n                (\"d_reclen\", c_ushort),\n                (\"d_type\", c_ubyte),\n                (\"d_name\", c_char * 2048)\n            ]\n\nwhile True:\n    p  = libc.readdir64(dir_)\n    if not p:\n        break\n    entry = Dirent.from_address( p)\n    print entry.d_name\n</code>\n</pre>\n", "senID": 6}], [{"text": ["@jsbueno's post is really useful, but is still kind of slow on slow disks since libc readdir() only ready 32K of disk entries at a time.", "I am not an expert on making system calls directly in python, but I outlined how to write code in C that will list a directory with millions of files, in a blog post at: http://www.olark.com/spw/2011/08/you-can-list-a-directory-with-8-million-files-but-not-with-ls/."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.olark.com/spw/2011/08/you-can-list-a-directory-with-8-million-files-but-not-with-ls/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.olark.com/spw/2011/08/you-can-list-a-directory-with-8-million-files-but-not-with-ls/"}]}, {"text": ["The ideal case would be to call getdents() directly in python (http://www.kernel.org/doc/man-pages/online/pages/man2/getdents.2.html) so you can specify a read buffer size when loading directory entries from disk."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.kernel.org/doc/man-pages/online/pages/man2/getdents.2.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.kernel.org/doc/man-pages/online/pages/man2/getdents.2.html"}]}, {"text": ["Rather than calling readdir() which as far as I can tell has a buffer size defined at compile time."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I think what you are asking is impossible due to the nature of file IO.", "Once python has retrieved the listing of a directory it cannot maintain a view of the actual directory on disk, nor is there any way for python to insist that the OS inform it of any modifications to the directory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["All python can do is ask for periodic listings and diff the results to see if there have been any changes."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The best you can do is create a semaphore file in the directory which lets other processes know that your python process desires that no other process modify the directory.", "Of course they will only observe the semaphore if you have explicitly programmed them to."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]