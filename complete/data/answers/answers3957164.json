[[{"code": "<pre>\n<code>\n (^A.*B$)|(^A.*$)|(^.*B$)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["^A|B$ or ^A|.", "*B$ (depending whether the match function is matching from the beginning)"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "^A|B$", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "^A|.*B$", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["it's difficult to write single regexp for this.."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["a possibility is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n match = re.match(r'^(?:A(\\S+))|(?:(\\S+)B)$', string)\nif match:\n    capture = max(match.groups())\n# because match.groups() is either (capture, None) or (None, capture)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Is this the desired behavior?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n var rx = /^((?:A)?)(.*?)((?:B)?)$/;\n\"Aanything\".match(rx)\n&gt; [\"Aanything\", \"A\", \"anything\", \"\"]\n\"anythingB\".match(rx)\n&gt; [\"anythingB\", \"\", \"anything\", \"B\"]\n\"AanythingB\".match(rx)\n&gt; [\"AanythingB\", \"A\", \"anything\", \"B\"]\n\"anything\".match(rx)\n&gt; [\"anything\", \"\", \"anything\", \"\"]\n\"AanythingB\".replace(rx, '$1nothing$3');\n&gt; \"AnothingB\"\n\"AanythingB\".replace(rx, '$2');\n&gt; \"anything\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n /(^A|B$)/\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Problem solved. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Problem solved.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I use this regex in python, I found this in the Python manual:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So my final answer is:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "So my final answer is:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n r'(?P&lt;prefix&gt;A)?(?P&lt;key&gt;\\S+)(?(prefix)|B)'\n</code>\n</pre>\n", "senID": 3}, {"text": ["Commands:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;re.sub(r'(?P&lt;prefix&gt;A)?(?P&lt;key&gt;\\S+)(?(prefix)|B)','\\g&lt;key&gt;',\"Aanything\")\n</code>\n</pre>\n", "senID": 5}, {"text": ["'anything'"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;re.sub(r'(?P&lt;prefix&gt;A)?(?P&lt;key&gt;\\S+)(?(prefix)|B)','\\g&lt;key&gt;',\"anythingB\")\n</code>\n</pre>\n", "senID": 7}, {"text": ["'anything'"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["While AanythingB give me anythingB back, but I don't care anyway."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "AanythingB", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "anythingB", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;re.sub(r'(?P&lt;prefix&gt;A)?(?P&lt;key&gt;\\S+)(?(prefix)|B)','\\g&lt;key&gt;',\"AanythingB\")\n</code>\n</pre>\n", "senID": 10}, {"text": ["'anythingB'"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["If you don't mind the extra weight in the case where both prefix \"A\" and suffix \"B\" exist, you can use a shorter regex:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n reMatcher= re.compile(r\"(?&lt;=\\AA).*|.*(?=B\\Z)\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["(using \\A for ^ and \\Z for $)"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "\\A", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "^", "childNum": 0, "tag": "code", "childList": []}, {"text": "\\Z", "childNum": 0, "tag": "code", "childList": []}, {"text": "$", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This one keeps the \"A\" prefix (instead of the \"B\" prefix of your solution) when both \"A\" and \"B\" are at their respective corners:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n 'A text here' matches ' text here'\n'more text hereB' matches 'more text here'\n'AYES!B' matched 'AYES!'\n'neither' doesn't match\n</code>\n</pre>\n", "senID": 4}, {"text": ["Otherwise, a non-regex solution (some would say a more \u201cPythonic\u201d one) is:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def strip_prefix_suffix(text, prefix, suffix):\n    left =  len(prefix) if text.startswith(prefix) else 0\n    right= -len(suffix) if text.endswith(suffix) else None\n    return text[left:right] if left or right else None\n</code>\n</pre>\n", "senID": 6}, {"text": ["If there is no match, the function returns None to differentiate from a possible '' (e.g.", "when called as strip_prefix_suffix('AB', 'A', 'B'))."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "''", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "strip_prefix_suffix('AB', 'A', 'B')", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["PS I should also say that this regex:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n (?&lt;=\\AA).*(?=B\\Z)|(?&lt;=\\AA).*|.*(?=B\\Z)\n</code>\n</pre>\n", "senID": 9}, {"text": ["should work, but it doesn't; it works just like the one I suggested, and I can't understand why.", "Breaking down the regex into parts, we can see something weird:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "should", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; text= 'AYES!B'\n&gt;&gt;&gt; re.compile('(?&lt;=\\\\AA).*(?=B\\\\Z)').search(text).group(0)\n'YES!'\n&gt;&gt;&gt; re.compile('(?&lt;=\\\\AA).*').search(text).group(0)\n'YES!B'\n&gt;&gt;&gt; re.compile('.*(?=B\\\\Z)').search(text).group(0)\n'AYES!'\n&gt;&gt;&gt; re.compile('(?&lt;=\\\\AA).*(?=B\\\\Z)|(?&lt;=\\\\AA).*').search(text).group(0)\n'YES!'\n&gt;&gt;&gt; re.compile('(?&lt;=\\\\AA).*(?=B\\\\Z)|.*(?=B\\\\Z)').search(text).group(0)\n'AYES!'\n&gt;&gt;&gt; re.compile('(?&lt;=\\\\AA).*|.*(?=B\\\\Z)').search(text).group(0)\n'AYES!'\n&gt;&gt;&gt; re.compile('(?&lt;=\\\\AA).*(?=B\\\\Z)|(?&lt;=\\\\AA).*|.*(?=B\\\\Z)').search(text).group(0)\n'AYES!'\n</code>\n</pre>\n", "senID": 11}, {"text": ["For some strange reason, the .", "*(?=B\\\\Z) subexpression takes precedence, even though it's the last alternative."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": ".*(?=B\\\\Z)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}]]