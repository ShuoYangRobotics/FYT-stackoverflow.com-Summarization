[[{"text": ["Python definitely supports properties:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Foo(object):\n\n    def get_length_inches(self):\n        return self.length_meters * 39.0\n\n    def set_length_inches(self, val):\n        self.length_meters = val/39.0\n\n    length_inches = property(get_length_inches, set_length_inches)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Starting in Python 2.5, syntactic sugar exists for read-only properties, and in 2.6, writable ones as well:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Foo(object):\n\n    # 2.5 or later\n    @property\n    def length_inches(self):\n        return self.length_meters * 39.0\n\n    # 2.6 or later\n    @length_inches.setter\n    def length_inches(self, val):\n        self.length_meters = val/39.0\n</code>\n</pre>\n", "senID": 3}], [{"text": ["In JavaScript:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "JavaScript", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://developer.mozilla.org/En/Core%5FJavaScript%5F1.5%5FGuide:Creating%5FNew%5FObjects:Defining%5FGetters%5Fand%5FSetters"}]}, {"code": "<pre>\n<code>\n var object = {\n  // .. other property definitions ...\n  get length_inches(){ return this.length_metres * 39.0; },\n  set length_inches(value){ this.length_metres = value/39.0; }\n};\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In C# properties are mostly just a compiler feature.", "The compiler generates special methods get_PropertyName and set_PropertyName and works out the calls and so forth.", "It also set the specialname IL property of the methods."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "get_PropertyName", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "set_PropertyName", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "specialname", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["If your language of choice supports some kind of preprocessor, you can implement something similar but otherwise you're pretty much stuck with what you got. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["And of course, if you're implementing your own .NET language you can do what the C# compiler does as well. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Due to the implementation details, there are actually subtle differences between fields and properties.", "See this question for details."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "this question", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/653536/difference-between-property-and-field-in-c/653799#653799"}]}], [{"text": ["Delphi, from which C# is derived, has had properties from the word go.", "And the word go was about 15 years ago."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Most dynamic languages support something like that.", "In Smalltalk and Ruby, fields are not directly exposed - The only way to get at them is through a method.", "In other words - All variables are private.", "Ruby has some macros (class methods really), to make it simpler to type:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Thing\n  attr_accessor :length_inches\nend\n</code>\n</pre>\n", "senID": 1}, {"text": ["will make a getter and a setter for length_inches.", "Behind the scenes, it's simply generating this:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "length_inches", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Thing\n  def length_inches\n    @length_inches\n  end\n  def length_inches=(value)\n    @length_inches = value\n  end\nend\n</code>\n</pre>\n", "senID": 3}, {"text": ["(Ruby crash-course: The @ prefix means it's an instance variable.", "return is implicit in Ruby.", "t.length_inches = 42 will automatically invoke length_inches=(42), if t is a Thingy."], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": "@", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "t.length_inches = 42", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "length_inches=(42)", "childNum": 0, "tag": "code", "childList": []}, {"text": "t", "childNum": 0, "tag": "code", "childList": []}, {"text": "Thingy", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you later on want to put some logic in the getters/setters, you can simply manually implement the same methods:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class Thing\n  def length_inches\n    @length_metres * 39.0\n  end\n  def length_inches=(value)\n    @length_metres = value / 39.0\n  end\nend\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Delphi has a property pattern (with Setter and Getter methods), which also can be used in interfaces.", "Properties with \"published\" visibility also will be displayed in the IDE object inspector."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A class definition with a property would look like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n TFoo = class\nprivate\n  FBar: string;\n  procedure SetBar(Value: string);\n  function GetBar: string;\n\npublic\n  property Bar: string read GetBar write SetBar;\n\nend;\n</code>\n</pre>\n", "senID": 2}, {"text": ["or (without Setter / Getter):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n TFoo = class\nprivate\n  FBar: string;\n\npublic\n  property Bar: string read FBar write FBar;\n\nend;\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I think this is the Python equivalent"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Length( object ):\n    conversion = 39.0\n    def __init__( self, value ):\n        self.set(value)\n    def get( self ):\n        return self.length_metres\n    def set( self, value ):\n        self.length_metres= value\n    metres= property( get, set )\n    def get_inches( self ):\n        return self.length_metres*self.conversion\n    def set_inches( self, value ):\n        self.length_metres= value/self.conversion\n    inches = property( get_inches, set_inches )\n</code>\n</pre>\n", "senID": 1}, {"text": ["It works like this."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l=Length(2)\n&gt;&gt;&gt; l.metres\n2\n&gt;&gt;&gt; l.inches\n78.0\n&gt;&gt;&gt; l.inches=47\n&gt;&gt;&gt; l.metres\n1.2051282051282051\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Out of the box in VB (that's VB 6.0, not VB.net) and VBScript!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Public Property Get LengthInches() As Double\n  LengthInches = LengthMetres * 39\nEnd Property\n\nPublic Property Let LengthInches(Value As Double)\n  LengthMetres = Value / 39\nEnd Property\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also possible to fake quite nicely in PHP creating a class that you extend in combination with naming guidelines, protected members and magic functions.", "Yuch."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["In Objective-C 2.0 / Cocoa:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n @interface MyClass : NSObject\n{\n    int myInt;\n    NSString *myString;\n}\n\n@property int myInt;\n@property (nonatomic, copy) NSString *myString;\n\n@end\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then in the implementation, simply specify:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n @synthesize myInt, myString;\n</code>\n</pre>\n", "senID": 3}, {"text": ["This generates the accessors for that member variable with key-value-coding compliant naming conventions like:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n - (void)setMyString:(NSString *)newString\n{\n    [myString autorelease];\n    myString = [newString copy];\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["Saves a lot of work typing out your accessors."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["It's definitely possible to implement properties in other languages.", "VB and F# for example have explicit property support.", "But these both target the CLR which has property support. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["VB."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n Public Property Name As String \n  Get \n    return \"someName\"\n  End Get\n  Set\n    ...\n  End Set\nEnd Property\n</code>\n</pre>\n", "senID": 2}, {"text": ["I do not believe javascript or PHP supports property syntax but I'm not very familiar with those languages.", "It is possible to create field get/set accessor methods in pretty much any language which simulate properties.  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Under the hood, .Net properties really just result down to get/set methods.", "They just have a really nice wrapper :)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Sadly, I haven't tried it myself yet, but I read that it was possible to implement properties in PHP through __set and __get magic methods.", "Here's a blog post on this subject."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "blog post", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://blog.dougalmatthews.com/2008/07/php-%5F%5Fset-and-%5F%5Fget-magic-methods/"}]}], [{"text": ["ActionScript 3 (javascript on steroids) has get/set syntax also"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can make something like it with PHP5 magic functions."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PHP5 magic functions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://php.net/manual/en/language.oop5.overloading.php#language.oop5.overloading.members"}]}, {"code": "<pre>\n<code>\n class Length {\n    public $metres;\n    public function __get($name) {\n    \tif ($name == 'inches')\n    \t\treturn $this-&gt;metres * 39;\n    }\n    public function __set($name, $value) {\n        if ($name == 'inches')\n    \t\t$this-&gt;metres = $value/39.0;\n    }\n}\n\n$l = new Length;\n$l-&gt;metres = 3;\necho $l-&gt;inches;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could do it in all sorts of languages, with varying degrees of syntactic sugar and magic.", "Python, as already mentioned, provides support for this (and, using decorators you could definitely clean it up even more).", "PHP could provide a reasonable facsimile with appropriate __get() and __set() methods (probably some indirection to .", "If you're working with Perl, you could use some source filters to replicate the behavior.", "Ruby already requires everything to go through "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["When I first played with Visual Basic (like, version 1 or something) the first thing I did was try to recreate properties in C++.", "Probably before templates were available to me at the time, but now it would be something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n template &lt;class TValue, class TOwner, class TKey&gt;\nclass property\n{\n    TOwner *owner_;\n\npublic:\n    property(TOwner *owner)\n        : owner_(owner) {}\n\n    TValue value() const\n    {\n        return owner_-&gt;get_property(TKey());\n    }\n\n    operator TValue() const\n    {\n        return value();\n    }\n\n    TValue operator=(const TValue &amp;value)\n    {\n        owner_-&gt;set_property(TKey(), value);\n        return value;\n    }\n};\n\nclass my_class\n{\npublic:\n    my_class()\n        : first_name(this), limbs(this) {}\n\n    struct limbs_k {};\n    struct first_name_k {};\n\n    property&lt;std::string, my_class, first_name_k&gt; first_name;\n    property&lt;int, my_class, limbs_k&gt; limbs;\n\n    std::string get_property(const first_name_k &amp;);\n    void set_property(const first_name_k &amp;, const std::string &amp;value);\n\n    int get_property(const limbs_k &amp;);\n    void set_property(const limbs_k &amp;, int value);\n};\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that the \"key\" parameter is ignored in the implementations of get_property/set_property - it's only there to effectively act as part of the name of the function, via overload resolution."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "get_property", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set_property", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Now the user of my_class would be able to refer to the public members first_name and limbs in many situations as if they were raw fields, but they merely provide an alternative syntax for calling the corresponding get_property/set_property member functions."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "my_class", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "first_name", "childNum": 0, "tag": "code", "childList": []}, {"text": "limbs", "childNum": 0, "tag": "code", "childList": []}, {"text": "get_property", "childNum": 0, "tag": "code", "childList": []}, {"text": "set_property", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It's not perfect, because there are some situations where you'd have to call value() on a property to get the value, whenever the compiler is unable to infer the required type conversion.", "Also you might get a warning from the passing of this to members in the constructor, but you could silence that in this case."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "this", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Boo is a .NET language very similar to Python, but with static typing.", "It can implement properties: "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Boo", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://boo.codehaus.org/Fields%2BAnd%2BProperties"}]}, {"code": "<pre>\n<code>\n class MyClass:\n    //a field, initialized to the value 1\n    regularfield as int = 1 //default access level: protected\n\n    //a string field\n    mystringfield as string = \"hello\"\n\n    //a private field\n    private _privatefield as int\n\n    //a public field\n    public publicfield as int = 3\n\n    //a static field: the value is stored in one place and shared by all\n    //instances of this class\n    static public staticfield as int = 4\n\n    //a property (default access level: public)\n    RegularProperty as int:\n        get: //getter: called when you retrieve property\n            return regularfield\n        set: //setter: notice the special \"value\" variable\n            regularfield = value\n\n    ReadOnlyProperty as int:\n        get:\n            return publicfield\n\n    SetOnlyProperty as int:\n        set:\n            publicfield = value\n\n    //a field with an automatically generated property\n    [Property(MyAutoProperty)]\n    _mypropertyfield as int = 5\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The convention is to implement a get_PropertyName() and a set_PropertyName() method (that's all it is in the CLR as well.", "Properties are just syntactic sugar in VB.NET/C# - which is why a change from field to property or vice-versa is breaking and requires client code to recompile."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "get_PropertyName()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set_PropertyName()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n public int get_SomeValue() { return someValue; }\npublic void set_SomeValue(int value) { someValue = value; }\nprivate int someValue = 10;\n\n// client\nint someValue = someClass.get_SomeValue();\nsomeClass.set_SomeValue(12);\n</code>\n</pre>\n", "senID": 1}]]