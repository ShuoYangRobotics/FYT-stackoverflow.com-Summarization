[[{"text": ["Sure, the difference between the following two:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [f(x) for x in list]\n</code>\n</pre>\n", "senID": 1}, {"text": ["and this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n (f(x) for x in list)\n</code>\n</pre>\n", "senID": 3}, {"text": ["is that the first will generate the list in memory, whereas the second is a new generator, with lazy evaluation."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["So, simply write the \"unfiltered\" list as a generator instead.", "Here's your code, with the generator inline:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def myFunction(x):\n    print(\"called for: \" + str(x))\n    return x * x\n\noriginalList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nlimit = 10\nresult =   [C2 for C2 in ((myFunction(C), C) for C in originalList) if C2[0] &lt; limit]\n# result = [C2 for C2 in [(myFunction(C), C) for C in originalList] if C2[0] &lt; limit]\n</code>\n</pre>\n", "senID": 6}, {"text": ["Note that you will not see a difference in the printout from the two, but if you were to look at memory usage, the second statement which is commented out, will use more memory."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["To do a simple change to your code in your question, rewrite unfiltered as this:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n unfiltered = [ (myFunction(C),C) for C in originalList ]\n             ^                                         ^\n             +---------- change these to (..) ---------+\n                                 |\n                                 v\nunfiltered = ( (myFunction(C),C) for C in originalList )\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Don't use a list comprehension; a normal for loop is fine here."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Just compute the distances beforehand and then filter the results:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n with_distances = ((myFunction(C), C) for C in originalList)\nresult = [C for C in with_distances if C[0] &lt; limit]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note: instead of building a new list, I use a generator expression to build the distance/element pairs."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Lasse V. Karlsen has an excellent reply to your question."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If your distance computation is slow, I guess your elements are polylines, or something like that, right ?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There are lots of ways to make it faster :"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["If the distance between bounding boxes of objects is > X, then it follows that the distance between those objects is > X.", "So you only need to compute distance between bounding boxes."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If you want all objects that are at a distance less than X from object A, only objects whose bounding box intersect A's bounding box enlarged by X are potential matches."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]}, {"text": ["Using the second point you can probably drop lots of candidate matches and only do the slow computation when needed."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Bounding boxes must be cached beforehand."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["If you really have a lot of objects you could also use space partitioning..."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Or convex enclosing polys if you are in 3D"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Rather than using a global variable as in your option 2, you could rely on the fact that in Python parameters are passed by object - that is, the object that is passed into your myFunction function is the same object as the one in the list (this isn't exactly the same thing as call by reference, but it's close enough)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "myFunction", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "same", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["So, if your myFunction set an attribute on the object - say, _result - you could filter by that attribute:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "_result", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n result = [(_result, C) for C in originalList if myFunction(C) &lt; limit]\n</code>\n</pre>\n", "senID": 2}, {"text": ["and your myFunction might look like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def myFunction(obj):\n    obj._result = ... calculation ....\n    return obj._result\n</code>\n</pre>\n", "senID": 4}], [{"text": ["What's wrong with option 1?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\"duplicate my originalList and waste some memory (the list could be quite big - more than 10,000 elements)\""], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["10,000 elements is only 10,000 pointers to tuples that point to existing objects.", "Think 160K or so of memory.", "Hardly worth talking about."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Some options:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Use ", "tag": "none", "senID": 1}, {"text": "Use a normal for loop", "tag": "none", "senID": 2}, {"text": "Create an unfiltered list, then filter it (your option 1). The 'wasted' memory will be reclaimed by the GC very quickly - it's not something you need to worry about.", "tag": "none", "senID": 3}]}]]