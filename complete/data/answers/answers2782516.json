[[{"text": ["Of course I wouldn't recommend doing this in real code, but yes, sure, you can reach inside of classes and use its methods as functions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    def my_method(self):\n        # Some complicated processing is done here\n        return 'Hi'\n\nprint(A.__dict__['my_method'](7))\n# Hi\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can't.", "The restriction has actually been lifted in Python 3000, but I presume you are not using that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, why can't you do something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def method_implementation(self, x,y):\n   # do whatever\n\nclass A():\n   def method(self, x, y):\n        return method_implementation(self, x, y)\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you are really in the mood for python abuse, write a descriptor class that implements the behavior.", "Something like"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Hack:\n   def __init__(self, fn):\n       self.fn = fn\n   def __get__(self, obj, cls):\n       if obj is None: # called staticly\n            return self.fn\n       else:\n            def inner(*args, **kwargs):\n                 return self.fn(obj, *args, **kwargs)\n            return inner\n</code>\n</pre>\n", "senID": 4}, {"text": ["Note that this is completely untested, will probably break some corner cases, and is all around evil."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"code": "<pre>\n<code>\n def some_method(self):\n    # Some complicated processing is done here\n    return self\n\nclass A(object):\n    my_method = some_method\na = A()\n\nprint some_method\nprint a.my_method\nprint A.my_method\nprint A.my_method.im_func\nprint A.__dict__['my_method']\n</code>\n</pre>\n", "senID": 0}, {"text": ["prints:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &lt;function some_method at 0x719f0&gt;\n&lt;bound method A.some_method of &lt;__main__.A object at 0x757b0&gt;&gt;\n&lt;unbound method A.some_method&gt;\n&lt;function some_method at 0x719f0&gt;\n&lt;function some_method at 0x719f0&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["It sounds like you're looking up a method on a class and getting an unbound method.", "An unbound method expects a object of the appropriate type as the first argument."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "unbound method", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "unbound method", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If you want to apply the function as a function, you've got to get a handle to the function version of it instead."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["That's what's called a staticmethod:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "staticmethod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class A(object):\n    @staticmethod\n    def my_method(a, b, c):\n        return a, b, c\n</code>\n</pre>\n", "senID": 1}, {"text": ["However in staticmethods, you do not get a reference to self."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you'd like a reference to the class not the instance (instance implies reference to self), you can use a classmethod:"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "class", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "instance", "childNum": 0, "tag": "code", "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class A(object):\n    classvar = \"var\"\n\n    @classmethod\n    def my_method(cls, a, b, c):\n        print cls.classvar\n        return a, b, c\n</code>\n</pre>\n", "senID": 4}, {"text": ["But you'll only get access to class variables, not to instance variables (those typically created/defined inside the __init__ constructor)."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If that's not good enough, then you will need to somehow pass a \"bound\" method or pass \"self\" into the method like so:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    def my_method(self):\n        # use self and manipulate the object\n\ninst = A()\nA.my_method(inst)\n</code>\n</pre>\n", "senID": 7}, {"text": ["As some people have already said, it's not a bad idea to just inherit one class from the other:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    ... methods ...\n\nclass B(A):\n    def my_method(self):\n        ... use self\n\nnewA = B()\n</code>\n</pre>\n", "senID": 9}], [{"text": ["You could just put that method into a superclass of the two objects that need to call it, couldn't you?", "If its so critical that you can't copy it, nor can you change it to not use self, thats the only other option I can see. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; class A():\n...     me = 'i am A'\n... \n&gt;&gt;&gt; class B():\n...     me = 'i am B'\n... \n&gt;&gt;&gt; def get_name(self):\n...     print self.me\n... \n&gt;&gt;&gt; A.name = get_name\n&gt;&gt;&gt; a=A()\n&gt;&gt;&gt; a.name()\ni am A\n&gt;&gt;&gt; \n&gt;&gt;&gt; B.name = get_name\n&gt;&gt;&gt; b=B()\n&gt;&gt;&gt; b.name()\ni am B\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Why cant you do this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class A(object):\n    def my_method(self,arg=None):\n        if (arg!=None):\n           #Do Some Complicated Processing with both objects and return something \n        else:\n               # Some complicated processing is done here\n        return self\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In Python  functions arenotrequired to be enclosed in classes.", "It sounds like what you need is utility function, so just define it as such:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "functions arenotrequired to be enclosed in classes", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "not", "tag": "em"}]}, {"text": "not", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def my_function(object):\n    # Some complicated processing is done here\n    return object\n\nmy_function(7)\nmy_function(\"Seven\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["As long as your processing is using methods and attribute available on all objects that you pass to my_function through the magic of duck typing everything will work fine."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "my_function", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "duck typing", "childNum": 1, "tag": "strong", "childList": [{"text": "duck typing", "tag": "a"}]}, {"href": "http://en.wikipedia.org/wiki/Duck_typing#In_Python", "text": "duck typing", "childNum": 0, "tag": "a", "childList": []}]}]]