[[{"text": ["Here's a few different approaches you could use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Compare lengths"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Compare lengths", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "Find the length of the original string.", "tag": "none", "senID": 2}, {"text": "Sum the length of the matched strings. ", "tag": "none", "senID": 3}, {"text": "If the two numbers differ there were unused characters.", "tag": "none", "senID": 4}]}, {"text": ["Note that you can also combine this method with your existing code rather than doing it as an extra step if you want to avoid parsing the string twice."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Regular expression for entire string"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Regular expression for entire string", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You can check if this regular expression matches the entire string:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n ^([A-Z][a-z]{0,2}\\d*)*$\n</code>\n</pre>\n", "senID": 8}, {"text": ["(Rubular)"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "(Rubular)", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://rubular.com/r/lqX10VSmeo"}]}, {"text": ["Tokenize"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Tokenize", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You can use the following regular expression to tokenize the original string:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n [A-Z][^A-Z]*\n</code>\n</pre>\n", "senID": 12}, {"text": ["Then check each token to see if it matches your original regular expression."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["Ok then."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n /^([A-Z][a-z]{0,2}\\d*)+$/\n</code>\n</pre>\n", "senID": 1}, {"text": ["Difference here being the extra grouping (foo)+ within the ^$ allowing you to capture pattern foo N times."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "(foo)+", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "^$", "childNum": 0, "tag": "code", "childList": []}, {"text": "foo", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["No global flag?", "Guess you'll have to split the result of that regex on the pattern again then."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You need slightly different regex:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ^([A-Z][a-z]{0,2})(\\d*)$\n</code>\n</pre>\n", "senID": 1}, {"text": ["which won't match any of your example strings, however.", "You need to provide better description of why those strings supposed to match."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Just to  test whether the whole string match you could use:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; re.match(r'(([A-Z][a-z]{,2})(\\d*))+$', 'H2TeO4')\n&lt;_sre.SRE_Match object at 0x920f520&gt;\n&gt;&gt;&gt; re.match(r'(([A-Z][a-z]{,2})(\\d*))+$', 'H3PoooO5')\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 4}, {"text": ["I didn't find pure regex solution, but here is how to test and collect matches:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; res = re.findall(r'([A-Z][a-z]{,2})(\\d*)(?=(?:[A-Z][a-z]{,2}\\d*|$))', s)\n&gt;&gt;&gt; res\n[('C', '6'), ('H', '5'), ('Fe', '2'), ('I', '')]\n&gt;&gt;&gt; ''.join(''.join(i) for i in res) == s\nTrue\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Do you need to extract each individual part to process, or simply match for input validation?", "If you just need to match for validation, try ^([A-Z][a-z]{0,2}\\d*)+$."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "^([A-Z][a-z]{0,2}\\d*)+$", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; reMatch = re.compile( '([A-Z][a-z]{0,2})(\\d*)' )\n&gt;&gt;&gt; def matchText ( text ):\n        matches, i = [], 0\n        for m in reMatch.finditer( text ):\n            if m.start() &gt; i:\n                break\n            matches.append( m )\n            i = m.end()\n        else:\n            if i == len( text ):\n                return matches\n        raise ValueError( 'invalid text' )\n\n&gt;&gt;&gt; matchText( 'C6H5Fe2I' )\n[&lt;_sre.SRE_Match object at 0x021E2800&gt;, &lt;_sre.SRE_Match object at 0x021E28D8&gt;, &lt;_sre.SRE_Match object at 0x021E2920&gt;, &lt;_sre.SRE_Match object at 0x021E2968&gt;]\n&gt;&gt;&gt; matchText( 'H2TeO4' )\n[&lt;_sre.SRE_Match object at 0x021E2890&gt;, &lt;_sre.SRE_Match object at 0x021E29F8&gt;, &lt;_sre.SRE_Match object at 0x021E2A40&gt;]\n&gt;&gt;&gt; matchText( 'H3PoooO5' )\nTraceback (most recent call last):\n  File \"&lt;pyshell#6&gt;\", line 1, in &lt;module&gt;\n    matchText( 'H3PoooO5' )\n  File \"&lt;pyshell#3&gt;\", line 11, in matchText\n    raise ValueError( 'invalid text' )\nValueError: invalid text\n&gt;&gt;&gt; matchText( 'C2tH6' )\nTraceback (most recent call last):\n  File \"&lt;pyshell#7&gt;\", line 1, in &lt;module&gt;\n    matchText( 'C2tH6' )\n  File \"&lt;pyshell#3&gt;\", line 11, in matchText\n    raise ValueError( 'invalid text' )\nValueError: invalid text\n</code>\n</pre>\n", "senID": 0}, {"text": ["To answer your second question a bit more clearly than with the code above: A ValueError is used in cases where a parameter was of the correct type but the value was not right.", "So for a function that uses a regex, it is obviously the best you can choose."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "ValueError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Use this pattern"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (([A-Z][a-z]{0,2})(\\d*))+\n</code>\n</pre>\n", "senID": 1}, {"text": ["If it matches, great!", "If not, then handle it.", "I see no reason to raise an exception if it doesn't match.", "You'll have to provide more info."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["for the Validation please to try \nif you are using .NET Framework  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ([A-Z][a-b]??[0-9]??)*\n</code>\n</pre>\n", "senID": 1}, {"text": ["other wise"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ([A-Z][a-b]?[a-b]?[0-9]?[0-9]?)*\n</code>\n</pre>\n", "senID": 3}], [{"text": ["My go without regexp:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n tests= (\n'C6H5Fe2I',   # this string should be matched successfully. Result: C6 H5 Fe2 I\n'H2TeO4',     # this string should be matched successfully Result: H2 Te O4\n'H3PoooO5',   # exception should be raised\n'C2tH6')      # exception should be raised\n\ndef splitter(case):\n    case, original = list(case), case\n    while case:\n        if case[0].isupper():\n            result = case.pop(0)\n        else:\n            raise ValueError('%r is not capital letter in %s position %i.' %\n                             (case[0], original, len(original)-len(case)))\n        for count in range(2):\n            if case and case[0].islower():\n                result += case.pop(0)\n            else:\n                break\n        for count in range(2):\n            if case and case[0].isdigit():\n                result += case.pop(0)\n            else:\n                break\n        yield result\n\nfor testcase in tests:\n    try:\n        print tuple(splitter(testcase))\n    except ValueError as e:\n        print(e)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can do this in not much code with re.split -- yes, that's correct, re.split."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "re.split", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "re.split", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Here are the docs:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "the docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html#re.split"}]}, {"text": ["Invert your problem: split your input with a delimiter pattern that matches a valid atom+count.", "Have a capturing group so that the delimiter strings are kept.", "If the input string is valid, the non-delimiters in the result will all be empty strings. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; tests= (\n... 'C6H5Fe2I',\n... 'H2TeO4',\n... 'H3PoooO5',\n... 'C2tH6',\n... 'Bad\\n')\n&gt;&gt;&gt; import re\n&gt;&gt;&gt; pattern = r'([A-Z][a-z]{0,2}\\d*)'\n&gt;&gt;&gt; for test in tests:\n...     pieces = re.split(pattern, test)\n...     print \"\\ntest=%r pieces=%r\" % (test, pieces)\n...     data = pieces[1::2]\n...     rubbish = filter(None, pieces[0::2])\n...     print \"rubbish=%r data=%r\" % (rubbish, data)\n...\n\ntest='C6H5Fe2I' pieces=['', 'C6', '', 'H5', '', 'Fe2', '', 'I', '']\nrubbish=[] data=['C6', 'H5', 'Fe2', 'I']\n\ntest='H2TeO4' pieces=['', 'H2', '', 'Te', '', 'O4', '']\nrubbish=[] data=['H2', 'Te', 'O4']\n\ntest='H3PoooO5' pieces=['', 'H3', '', 'Poo', 'o', 'O5', '']\nrubbish=['o'] data=['H3', 'Poo', 'O5']\n\ntest='C2tH6' pieces=['', 'C2', 't', 'H6', '']\nrubbish=['t'] data=['C2', 'H6']\n\ntest='Bad\\n' pieces=['', 'Bad', '\\n']\nrubbish=['\\n'] data=['Bad']\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}]]