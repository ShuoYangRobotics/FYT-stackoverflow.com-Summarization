[[{"text": ["You don't need to.", "By definition a dict can only have one entry for a given key."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["To clarify, you have multiple dictionaries, but you want a unique data['key']?", "E.g., if data1['key'] = 'hello' you want to make sure that data2['key'] = 'hello' isn't allowed?", "Do you want it just raise an error?", "This is a way to validate that its fine.", "(Also its not good to name your list 'list' as list is a datatype in python)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n datalist = [datadict1, datadict2, datadict3]\nbig_key_list = []\nfor datadict in datalist:\n    curkey = datadict.get('key')\n    if curkey not in big_key_list:\n        big_key_list.append(curkey)\n    else:\n        raise Exception(\"Key %s in two data dicts\" % curkey)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now a better way of doing this would be to create a new class inheriting from dict that contains subdictionaries, but doesn't allow multiple keys to have the same value.", "This way errors get thrown upon assignment rather than you can just check if things are fine (and not know what to do if things aren't fine, other than raise an error)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT:\nActually, looking at what you likely want to do, you have the data setup incorrectly.", "I say this as it seems you want to have a separate dictionary for each entry.", "This is almost certainly an inelegant way of doing it.  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["First create a class:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class MyDataObject(object):\n    def __init__(self, **kwargs):\n        for k,v in kwargs:\n            self.__dict__[k] = v\n</code>\n</pre>\n", "senID": 5}, {"text": ["or if they always will have all 4 fixed parameters:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n class MyDataObject(object):\n    def __init__(self, timestamp, action, obj_type, obj_id):\n        self.timestamp = timestamp\n        self.action = action\n        self.type = obj_type\n        self.id = obj_id\n</code>\n</pre>\n", "senID": 7}, {"text": ["Then just define your datatypes."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n data = {}\ndata['key1'] = MyDataObject(timestamp='some timestamp', action='some action', type='some type', id = 1234)\ndata['key2'] = MyDataObject(timestamp='some timestamp2', action='some action2', type='some type2', id = 1235)\n</code>\n</pre>\n", "senID": 9}, {"text": ["You would access your data like:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n data['key1'].timestamp # returns 'some timestamp'\ndata['key2'].action # returns 'some action2'\n</code>\n</pre>\n", "senID": 11}, {"text": ["or you can even access using dict() (e.g., this is helpful if you have a variable x='action' and you want to access it)."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "dict", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n data['key1'].__dict__('action') # returns 'some action'\ndata['key2'].__dict__('timestamp') # returns 'some timestamp2'\n</code>\n</pre>\n", "senID": 13}, {"text": ["Now you just have a dictionary of objects, where the key is unique and the data associated with the key is kept as one object (of type MyDataObject)."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}], [{"text": ["I think that you mean is that every 'key' field should be unique over all the datas."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "'key'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Well, lets start with what you probably should do: Use a database, they love to solve these problem."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can do the job by hand too, for example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def unique_keys( items):\n    seen = set()\n    for item in items:\n        key = item['key']\n        if key not in seen:\n             seen.add(key)\n             yield item\n        else:\n             # its a duplicate key, do what?\n             pass # drops it\n\nprint list(unique_keys(data_list))\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or maybe you want a data structure that stores existing keys and prevents you from creating new datas for keys that already exist ... ?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You could also use a dictionary of lists, with each list position representing a specific value.", "data = {}\ndata[pointer_key] = [timestamp, action, type, id]\nif new_pointer_key in data:\n    if this_timestamp > data[new_pointer_key][0]:   ## first element of list=timestamp\n        data[new_pointer_key] = [new_timestamp,  new_action, new_type, new_id]"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "data = {}\ndata[pointer_key] = [timestamp, action, type, id]\nif new_pointer_key in data:\n    if this_timestamp > data[new_pointer_key][0]:   ## first element of list=timestamp\n        data[new_pointer_key] = [new_timestamp,  new_action, new_type, new_id]", "childNum": 1, "tag": "pre", "pos": 1, "childList": [{"text": "data = {}\ndata[pointer_key] = [timestamp, action, type, id]\nif new_pointer_key in data:\n    if this_timestamp > data[new_pointer_key][0]:   ## first element of list=timestamp\n        data[new_pointer_key] = [new_timestamp,  new_action, new_type, new_id]", "tag": "code"}]}, {"text": "data = {}\ndata[pointer_key] = [timestamp, action, type, id]\nif new_pointer_key in data:\n    if this_timestamp > data[new_pointer_key][0]:   ## first element of list=timestamp\n        data[new_pointer_key] = [new_timestamp,  new_action, new_type, new_id]", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; d = {'a': 1, 'b': 2, 'a': 3}\n&gt;&gt;&gt; d\n{'a': 3, 'b': 2}\n</code>\n</pre>\n", "senID": 0}, {"text": ["So in a dict, there is uniqueness of key."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Update: (On the basis of your comment)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In case you are looking for one key, multiple values, you subclass dict like:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class custom_dict(dict):\n      def __setitem__(self, key, value):\n        self.setdefault(key, []).append(value)\n\n&gt;&gt;&gt; m = custom_dict()\n&gt;&gt;&gt; m['key'] = 1\n&gt;&gt;&gt; m['key'] = 2\n&gt;&gt;&gt; m\n{'key': [1, 2]}\n</code>\n</pre>\n", "senID": 4}, {"text": ["That should do it."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["When you do things like these, it's usually a good sign that there's a mistake in design somewhere.", "But it can be done:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from operator import itemgetter\n\ndef unique(list_of_dicts):\n    _sorted = sorted(list_of_dicts, key=itemgetter('timestamp'), reverse=True)\n    known_keys = set()\n    result = []\n    for d in _sorted:\n        key = d['key']\n        if key in known_keys: continue\n        known_keys.add(key)\n        result.append(d)\n    return result\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output (note: it changes ordering):"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "note: it changes ordering", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n [{'action': 'like', 'timestamp': 3456789012, 'type': 'photo', 'id': 212, 'key': 1},\n{'action': 'like', 'timestamp': 2345678901, 'type': 'photo', 'id': 252, 'key': 2}]\n</code>\n</pre>\n", "senID": 3}, {"text": ["And now that keys are unique (with recent timestamps kept, as desired), it's good idea to convert it to something that reflects your data better, as suggested by jimbob:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "as suggested by jimbob", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4370660/unique-list-of-dicts-based-on-keys/4370749#4370749"}]}, {"code": "<pre>\n<code>\n class MyDataObject(object):\n    def __init__(self, timestamp, action, obj_type, obj_id):\n        self.timestamp = timestamp\n        self.action = action\n        self.type = obj_type\n        self.id = obj_id\n\ndata = {}\nfor action in unique(_list):\n    key = action['key']\n    data[key] = MyDataObject(action['timestamp'], action['action'],\n        action['type'], action['id'])\n</code>\n</pre>\n", "senID": 5}]]