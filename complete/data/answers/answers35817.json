[[{"text": ["Perhaps you have a specific reason for using os.system().", "But if not you should probably be using the subprocess module.", "You can specify the pipes directly and avoid using the shell."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "subprocess module", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-subprocess.html"}]}, {"text": ["The following is from PEP324"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "PEP324", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0324/"}]}], [{"text": ["pipes.quote() (available since python 1.6) does what you want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["This is what I use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def shellquote(s):\n    return \"'\" + s.replace(\"'\", \"'\\\\''\") + \"'\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["The shell will always accept a quoted filename and remove the surrounding quotes before passing it to the program in question.", "Notably, this avoids problems with filenames that contain spaces or any other kind of nasty shell metacharacter."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["thanks, pixelbeat!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from pipes import quote\n&gt;&gt;&gt; args=['a a',r'b&lt;\\\"&gt;B', '''c\"''C''']\n&gt;&gt;&gt; print ' '.join( quote( arg ) for arg in args )\n'a a' 'b&lt;\\\"&gt;B' \"c\\\"''C\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Beware of the security issue!", "For instance if out_filename is "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n foo.txt; rm -rf /\n</code>\n</pre>\n", "senID": 1}, {"text": ["The malicious user can add more command directly interpreted by the shell."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I believe that os.system just invokes whatever command shell is configured for the user, so I don't think you can do it in a platform independent way.", "My command shell could be anything from bash, emacs, ruby, or even quake3.", "Some of these programs aren't expecting the kind of arguments you are passing to them and even if they did there is no guarantee they do their escaping the same way."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Note that pipes.quote is actually broken and not safe to use--It doesn't handle zero-length arguments."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from pipes import quote\n&gt;&gt;&gt; args = ['arg1', '', 'arg3']\n&gt;&gt;&gt; print 'mycommand %s' % (' '.join(quote(arg) for arg in args))\nmycommand arg1  arg3\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The function I use is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def quote_argument(argument):\n    return '\"%s\"' % (\n        argument\n        .replace('\\\\', '\\\\\\\\')\n        .replace('\"', '\\\"')\n        .replace('$', '\\$')\n        .replace('`', '\\`')\n    )\n</code>\n</pre>\n", "senID": 1}, {"text": ["that is: I always enclose the argument in double quotes, and then backslash-quote the only characters special inside double quotes."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you do use the system command, I would try and whitelist what goes into the os.system() call.. For example.."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n clean_user_input re.sub(\"[^a-zA-Z]\", \"\", user_input)\nos.system(\"ls %s\" % (clean_user_input))\n</code>\n</pre>\n", "senID": 1}, {"text": ["The subprocess module is a better option, and I would recommend trying to avoid using anything like os.system/subprocess wherever possible."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]