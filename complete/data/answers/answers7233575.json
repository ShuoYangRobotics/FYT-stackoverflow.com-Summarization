[[{"code": "<pre>\n<code>\n for index, entry in enumerate(longList):\n    if entry == 'foo':\n        print index\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Use the enumerate() built-in function."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "enumerate()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for index, entry in enumerate(longList):\n    if entry == 'foo':\n        print index\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, in your specific case, you can simply do index = longList.index(\"foo\")"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "index = longList.index(\"foo\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["EDIT: If you want to find the indices of multiple matches pretty much as fast as is possible in pure Python, the following code should do the trick:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n indices = tuple(index for index, element in enumerate(longList) if element=='foo')\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I like list comprehension :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n [index for (index,entry) in enumerate(longList) if entry == 'foo']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Yes, the best way is to do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n longList.index('foo')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using enumerate would be a better idea."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for ind,item in enumerate(longList):\n    if item == 'foo':\n        print ind\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If your list is really long and static, you should consider using a lookup table (actually, a dictionary of index lists with the entry as the key).", "It will almost pay for itself after the first search, since you currently always iterate over all the elements."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\n# Create and fill the table (only once or whenever the list changes)\nlookupTable = defaultdict(list)\nfor index, entry in enumerate(longList):\n    lookupTable[entry].append(index)\n\n# Search the list (as many times as you want)\nindexes = lookupTable.get('foo')\n# and you get either 'None' or a list of indexes '[1,10,20]'\n</code>\n</pre>\n", "senID": 1}]]