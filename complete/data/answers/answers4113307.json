[[{"text": ["Weights define a probability distribution function (pdf).", "Random numbers from any such pdf can be generated by applying its associated inverse cumulative distribution function to uniform random numbers between 0 and 1."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "applying its associated inverse cumulative distribution function", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Pseudorandom_number_generator#Non-uniform_generators"}]}, {"text": ["See also this SO explanation, or, as explained by Wikipedia:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "SO explanation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/977354/generating-non-uniform-random-numbers/977508#977508"}, {"href": "http://en.wikipedia.org/wiki/Cumulative%5Fdistribution%5Ffunction#Inverse", "text": "Wikipedia", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n import random\nimport bisect\nimport collections\n\ndef cdf(weights):\n    total=sum(weights)\n    result=[]\n    cumsum=0\n    for w in weights:\n        cumsum+=w\n        result.append(cumsum/total)\n    return result\n\ndef choice(population,weights):\n    assert len(population) == len(weights)\n    cdf_vals=cdf(weights)\n    x=random.random()\n    idx=bisect.bisect(cdf_vals,x)\n    return population[idx]\n\nweights=[0.3,0.4,0.3]\npopulation='ABC'\ncounts=collections.defaultdict(int)\nfor i in range(10000):\n    counts[choice(population,weights)]+=1\nprint(counts)\n\n# % test.py\n# defaultdict(&lt;type 'int'&gt;, {'A': 3066, 'C': 2964, 'B': 3970})\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Not... so much..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n pos = ['A'] * 3 + ['B'] * 4 + ['C'] * 3\nprint random.choice(pos)\n</code>\n</pre>\n", "senID": 1}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n pos = {'A': 3, 'B': 4, 'C': 3}\nprint random.choice([x for x in pos for y in range(pos[x])])\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here's a class to expose a bunch of items with relative probabilities, without actually expanding the list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import bisect\nclass WeightedTuple(object):\n    \"\"\"\n    &gt;&gt;&gt; p = WeightedTuple({'A': 2, 'B': 1, 'C': 3})\n    &gt;&gt;&gt; len(p)\n    6\n    &gt;&gt;&gt; p[0], p[1], p[2], p[3], p[4], p[5]\n    ('A', 'A', 'B', 'C', 'C', 'C')\n    &gt;&gt;&gt; p[-1], p[-2], p[-3], p[-4], p[-5], p[-6]\n    ('C', 'C', 'C', 'B', 'A', 'A')\n    &gt;&gt;&gt; p[6]\n    Traceback (most recent call last):\n    ...\n    IndexError\n    &gt;&gt;&gt; p[-7]\n    Traceback (most recent call last):\n    ...\n    IndexError\n    \"\"\"\n    def __init__(self, items):\n        self.indexes = []\n        self.items = []\n        next_index = 0\n        for key in sorted(items.keys()):\n            val = items[key]\n            self.indexes.append(next_index)\n            self.items.append(key)\n            next_index += val\n\n        self.len = next_index\n\n    def __getitem__(self, n):\n        if n &lt; 0:\n            n = self.len + n\n        if n &lt; 0 or n &gt;= self.len:\n            raise IndexError\n\n        idx = bisect.bisect_right(self.indexes, n)\n        return self.items[idx-1]\n\n    def __len__(self):\n        return self.len\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now, just say:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n data = WeightedTuple({'A': 30, 'B': 40, 'C': 30})\nrandom.choice(data)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You can also make use this form, which does not create a list arbitrarily big (and can work with either integral or decimal probabilities):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n pos = [(\"A\", 30), (\"B\", 40), (\"C\", 30)]\n\n\nfrom random import uniform\ndef w_choice(seq):\n    total_prob = sum(item[1] for item in seq)\n    chosen = random.uniform(0, total_prob)\n    cumulative = 0\n    for item, probality in seq:\n        cumulative += probality\n        if cumulative &gt; chosen:\n            return item\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There are some good solutions offered here, but I would suggest that you look at Eli Bendersky's thorough discussion of this issue, which compares various algorithms to achieve this (with implementations in Python) before choosing one."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Eli Bendersky's thorough discussion", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://eli.thegreenplace.net/2010/01/22/weighted-random-generation-in-python/"}]}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random\nfrom decimal import Decimal\n\npos = {'A': Decimal(\"0.3\"), 'B': Decimal(\"0.4\"), 'C': Decimal(\"0.3\")}\nchoice = random.random()\nF_x = 0\nfor k, p in pos.iteritems():\n    F_x += p\n    if choice &lt;= F_x:\n        x = k\n        break\n</code>\n</pre>\n", "senID": 1}]]