[[{"text": ["Since all you seem to want is some sort of feedback for a long running function, why not just pass in a reference to a callback procedure that will be called at regular intervals?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["It's not completely clear what you want to happen if you switch between generator and function modes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But as a first try: perhaps wrap the generator version in a new method which explicitly throws away the intermediate steps?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def gen():\n    for i in range(100):\n        yield i\n\ndef wrap():\n    for x in gen():\n        pass\n    return x\n\nprint \"wrap=\", wrap()\n</code>\n</pre>\n", "senID": 2}, {"text": ["With this version you could step into gen() by looping over smaller numbers of the range, make adjustments, and then use wrap() only when you want to finish up."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "gen()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "wrap()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["An edit to my answer, why not just always yeild?", "You can have a function which yields a single value.", "If you don't want that then just choose to have your function either return a generator itself or the value:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def stuff(x, want_gen):\n     if want_gen:\n         def my_gen(x):\n             #code with yield\n         return my_gen\n     else:\n         return x\n</code>\n</pre>\n", "senID": 1}, {"text": ["That way you are always returning a value.", "In Python, functions are objects."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "are", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Kind of messy, but I think this does the same as your original code was asking:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def optimize(x, want_gen):\n    def optimize_gen(x):\n        # ... declaration and validation code\n        for i in range(100):\n            # estimate foo, bar, baz\n            # ... some code here\n\n            x = calculate_next_x(x, foo, bar, baz)\n\n            if want_gen:\n               yield x\n    if want_gen:\n        return optimize_gen(x)\n\n    for x in optimize_gen(x):\n        pass\n    return x\n</code>\n</pre>\n", "senID": 1}, {"text": ["Alternatively the for loop at the end could be written:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n return list(optimize_gen(x))[-1]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now ask yourself if you really want to do this.", "Why do you sometimes want the whole sequence and sometimes only want the last element?", "Smells a bit fishy to me."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Simplest is to write two methods, one the generator and the other calling the generator and just returning the value.", "If you really want one function with both possibilities, you can always use the want_gen flag to test what sort of return value, returning the iterator produced by the generator function when True and just the value otherwise."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "want_gen", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Well...we can always remember that yield wa simplemented in thelanguage as way to facilitate the existence of generator objects, but one can always implet them either from scratch, or getting the best of both worlds:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class  Optimize(object):\n    def __init__(self, x):\n        self.x = x\n    def __iter__(self):\n        x = self.x\n        # ... declaration and validation code\n        for i in range(100):\n            # estimate foo, bar, baz\n            # ... some code here\n\n            x = calculate_next_x(x, foo, bar, baz)\n            yield x\n    def __call__(self):\n        gen = iter(self)\n        return gen.next()\n\ndef optimize(x, wantgen):\n    if wantgen:\n        return iter(Optimize(x))\n    else:\n        return Optimize(x)()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Not that you dont even need the \"optimize\" function wrapper -  I just put it in there so it becomes a drop-in replacement for your example (would it work)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The way the class is declared, you can do simply:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for y in Optimize(x):\n    #code\n</code>\n</pre>\n", "senID": 4}, {"text": ["to use it as a generator, or:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n k = Optimize(x)()\n</code>\n</pre>\n", "senID": 6}, {"text": ["to use it as a function."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["How about this pattern.", "Make your 3 line of changes to convert the function to a generator.", "Rename it to NewFunctionName.", "Replace the existing function with one that either returns the generator if want_gen is True, or exhausts the generator and returns the final value."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]