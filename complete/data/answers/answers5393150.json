[[{"text": ["These solutions do not rely on file1 being ordered, however they do load file2 into memory, which could be costly if file2 is large.", "you will notice however that wanted_lines and lines_out are generators in the first example, which should save a small amount of memory. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This example has no error handling, but is basically what you need.", "I'll knock together a better one in a sec."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n wanted_lines = (int(line) for line in open(file1).readlines())\nall_lines = [line.strip() for line in open(file1).readlines()]\nlines_out = (all_lines[index] for index in wanted_lines)\nopen(file3, 'w').writelines(lines_out)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Better:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n all_lines = [line.strip() for line in open(file2).readlines()]\nlines_out = []\nfor line in open(file1).readlines():\n  try:\n    index = int(line)\n    lines_out.append(all_lines[index] + '\\n')\n  except IndexError:\n    print file1, \"is only\", len(file1), \"lines long, therefore has no\", index+1, \"th line.\"\n  except:\n    print \"could not coerce\", line.strip(), \"to an int\"\nopen(file3, 'w').writelines(lines_out)\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n fname = file1.readlines()\nfname = [ int(i) for i in fname]\nf = open(\"file2\")\nfor number,line in enumerate(f):\n    if number in fname :\n         print line.rstrip()\nf.close()\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n def copyLines(infname, outfname, lines, firstLine=0):\n    lines = list(set(lines))   # remove duplicates\n    lines.sort(reverse=True)   # sort in descending order\n    with open(infname, 'r') as inf, open(outfname, 'w') as outf:\n        try:\n            i = firstLine\n            while lines:\n                seek = lines.pop()\n                while i&lt;seek:\n                    inf.next()\n                    i += 1\n                outf.write(inf.next())\n                i += 1\n        except StopIteration:  # hit end of file\n            pass\n\ndef main():\n    with open('file1') as inf:\n        linesToRead = [int(ln) for ln in inf]\n\n    copyLines('file2', 'Values.txt', linesToRead)        \n\nif __name__==\"__main__\":\n    main()\n</code>\n</pre>\n", "senID": 0}, {"text": ["Note that this will quit early if all desired lines have been found (ie if you only want lines 3-9 of a 1000-line file, it will only read to line 9)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If you only want to do that, you can use a oneliner bash"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n join file1 &lt;(grep -v '^$' file2 | cat -n ) | cut -d ' ' -f 2- &gt; Values.txt\n</code>\n</pre>\n", "senID": 1}, {"text": ["but here, indices starts at 1 instead of 0.", "To start at 0: "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n join &lt;(awk '{print $1+1}' &lt; file1)  &lt;(grep -v '^$' file2 | cat -n) | cut -d ' ' -f 2- &gt; Values.txt\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If file2's lines don't have to be written in the order they appear in file1, and if file1's contents are small enough to fit in RAM, this should do it efficiently:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n outfile = open('Values.txt','w')\ndesired = set(int(line) for line in open('file1').readlines())\nfor index, line in enumerate(open('file2')):\n    if index in desired:\n        outfile.write(line)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This differs from kurumi's answer mainly in that it uses a set to hold the line numbers from file1 (O(1) instead of O(n) for checking whether to emit a line), and it uses file.write so no whitespace is altered from the original lines in file2."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This version does not assume that indices in file1 are sorted."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n indices = [int(x) for x in file(\"file1\").readlines()]\ndata = file(\"file2\").readlines()\n\nfor i in indices:\n    print data[i]\n</code>\n</pre>\n", "senID": 1}]]