[[{"text": ["The given code is not very efficient.", "Alternative solution (just as inefficient):&dagger;"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "&dagger;", "childNum": 0, "tag": "sup", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from math import sqrt\n&gt;&gt;&gt; def is_prime(n):\n...     return all(n % d for d in range(2, int(sqrt(n)) + 1))\n... \n&gt;&gt;&gt; def primes_up_to(n):\n...     return filter(is_prime, range(2, n))\n... \n&gt;&gt;&gt; list(primes_up_to(20))\n[2, 3, 5, 7, 11, 13, 17, 19]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This code uses all, range, int, math.sqrt, filter and list.", "It is not completely identical to your code, as it prints primes up to a certain number, not exactly n primes.", "For that, you can do:"], "childNum": 14, "tag": "p", "senID": 2, "childList": [{"text": "all", "tag": "a", "pos": 0, "childList": [{"text": "all", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/functions.html#all"}, {"text": "all", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "range", "tag": "a", "pos": -1, "childList": [{"text": "range", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/functions.html#range"}, {"text": "range", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "int", "tag": "a", "pos": 1, "childList": [{"text": "int", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/functions.html#int"}, {"text": "int", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "math.sqrt", "tag": "a", "pos": -1, "childList": [{"text": "math.sqrt", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/math.html#math.sqrt"}, {"text": "math.sqrt", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "filter", "tag": "a", "pos": -1, "childList": [{"text": "filter", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/functions.html#filter"}, {"text": "filter", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "list", "tag": "a", "pos": -1, "childList": [{"text": "list", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/functions.html#list"}, {"text": "list", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "up to", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "n", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import count, islice\n&gt;&gt;&gt; def n_primes(n):\n...     return islice(filter(is_prime, count(2)), n)\n... \n&gt;&gt;&gt; list(n_primes(10))\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n</code>\n</pre>\n", "senID": 3}, {"text": ["That introduces another two functions, namely itertools.count and itertools.islice.", "(That last piece of code works only in Python 3.x; in Python 2.x, use itertools.ifilter instead of filter."], "childNum": 7, "tag": "p", "senID": 4, "childList": [{"text": "itertools.count", "tag": "a", "pos": 0, "childList": [{"text": "itertools.count", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/itertools.html#itertools.count"}, {"text": "itertools.count", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "itertools.islice", "tag": "a", "pos": -1, "childList": [{"text": "itertools.islice", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/itertools.html#itertools.islice"}, {"text": "itertools.islice", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "itertools.ifilter", "tag": "a", "pos": 1, "childList": [{"text": "itertools.ifilter", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.ifilter"}, {"text": "itertools.ifilter", "childNum": 0, "tag": "code", "childList": []}, {"text": "filter", "childNum": 0, "tag": "code", "childList": []}]}, {"tag": "hr", "senID": 5}, {"text": ["&nbsp;&nbsp;&dagger;: A more efficient method is to use the Sieve of Eratosthenes."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "&dagger;", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}, {"href": "http://en.wikipedia.org/wiki/Sieve%5Fof%5FEratosthenes", "text": "Sieve of Eratosthenes", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Your algorithm itself may be implemented pythonically, but it's often useful to re-write algorithms in a functional way - You might end up with a completely different but more readable solution at all (which is even more pythonic)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def primes(upper):\n    n = 2; found = []\n    while n &lt; upper:\n        # If a number is not divisble through all preceding primes, it's prime\n        if all(n % div != 0 for div in found):\n            yield n\n            found.append( n )\n        n += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for pr in primes(1000):\n    print pr\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or, with Alasdair's comment taken into account, a more efficient version:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from math import sqrt\nfrom itertools import takewhile\n\ndef primes(upper):\n    n = 2; foundPrimes = []\n    while n &lt; upper:\n        sqrtN = int(sqrt(n))\n        # If a number n is not divisble through all preceding primes up to sqrt(n), it's prime\n        if all(n % div != 0 for div in takewhile(lambda div: div &lt;= sqrtN, foundPrimes)):\n            yield n\n            foundPrimes.append(n)\n        n += 1\n</code>\n</pre>\n", "senID": 5}], [{"text": ["A few minor things from the style guide."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "style guide", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0008/"}]}, {"text": ["\nUses four spaces, not two.", "(Personally I prefer tabs, but that's not the Pythonic way.", ")Fewer blank lines.Consistent whitespace:n ==2:=>n == 2:Use underscores in your variables names:currentnumber=>current_number"], "childNum": 8, "tag": "p", "senID": 1, "childList": [{"text": "Uses four spaces, not two. (Personally I prefer tabs, but that's not the Pythonic way.)Fewer blank lines.Consistent whitespace:n ==2:=>n == 2:Use underscores in your variables names:currentnumber=>current_number", "childNum": 7, "tag": "li", "pos": -1, "childList": [{"text": "Fewer blank lines.Consistent whitespace:n ==2:=>n == 2:Use underscores in your variables names:currentnumber=>current_number", "tag": "li"}, {"text": "Consistent whitespace:n ==2:=>n == 2:Use underscores in your variables names:currentnumber=>current_number", "tag": "li"}, {"text": "n ==2:", "tag": "code"}, {"text": "n == 2:", "tag": "code"}, {"text": "Use underscores in your variables names:currentnumber=>current_number", "tag": "li"}, {"text": "currentnumber", "tag": "code"}, {"text": "current_number", "tag": "code"}]}, {"text": "Fewer blank lines.Consistent whitespace:n ==2:=>n == 2:Use underscores in your variables names:currentnumber=>current_number", "childNum": 6, "tag": "li", "pos": 2, "childList": [{"text": "Consistent whitespace:n ==2:=>n == 2:Use underscores in your variables names:currentnumber=>current_number", "tag": "li"}, {"text": "n ==2:", "tag": "code"}, {"text": "n == 2:", "tag": "code"}, {"text": "Use underscores in your variables names:currentnumber=>current_number", "tag": "li"}, {"text": "currentnumber", "tag": "code"}, {"text": "current_number", "tag": "code"}]}, {"text": "Consistent whitespace:n ==2:=>n == 2:Use underscores in your variables names:currentnumber=>current_number", "childNum": 5, "tag": "li", "childList": [{"text": "n ==2:", "tag": "code"}, {"text": "n == 2:", "tag": "code"}, {"text": "Use underscores in your variables names:currentnumber=>current_number", "tag": "li"}, {"text": "currentnumber", "tag": "code"}, {"text": "current_number", "tag": "code"}]}, {"text": "n ==2:", "childNum": 0, "tag": "code", "childList": []}, {"text": "n == 2:", "childNum": 0, "tag": "code", "childList": []}, {"text": "Use underscores in your variables names:currentnumber=>current_number", "childNum": 2, "tag": "li", "childList": [{"text": "currentnumber", "tag": "code"}, {"text": "current_number", "tag": "code"}]}, {"text": "currentnumber", "childNum": 0, "tag": "code", "childList": []}, {"text": "current_number", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Firstly, you should not assign max to a variable as it is an inbuilt function used to find the maximum value from an iterable.", "Also, that entire section of code can instead be written as"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i in xrange(3, int(sqrt(n))+1, 2):\n    if n%i==0: return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also, instead of defining a new variable result and putting the value returned by isprime into it, you can just directly do"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if isprime(currentnumber):\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I recently found Project Euler solutions in functional python and it has some really nice examples of working with primes like this.", "Number 7 is pretty close to your problem:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Project Euler solutions in functional python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyeuler.wikidot.com/start"}, {"text": "Number 7", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pyeuler.wikidot.com/problems-1-10"}]}, {"code": "<pre>\n<code>\n def isprime(n):\n    \"\"\"Return True if n is a prime number\"\"\"\n    if n &lt; 3:\n        return (n == 2)\n    elif n % 2 == 0:\n        return False\n    elif any(((n % x) == 0) for x in xrange(3, int(sqrt(n))+1, 2)):\n        return False\n    return True\n\ndef primes(start=2):\n    \"\"\"Generate prime numbers from 'start'\"\"\"\n    return ifilter(isprime, count(start))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Usually you don't use while loops for simple things like this.", "You rather create a range object and get the elements from there.", "So you could rewrite the first loop to this for example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\nfor i in range( 3, int( sqrt( n ) ) + 1, 2 ):\n    if n % i == 0:\n        return False\n</pre>\n", "senID": 1}, {"text": ["And it would be a lot better if you would cache your prime numbers and only check the previous prime numbers when checking a new number.", "You can save a lot time by that (and easily calculate larger prime numbers this way).", "Here is some code I wrote before to get all prime numbers up to n easily:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\ndef primeNumbers ( end ):\n    primes = []\n    primes.append( 2 )\n\n    for i in range( 3, end, 2 ):\n    \tisPrime = True\n\n    \tfor j in primes:\n    \t\tif i % j == 0:\n    \t\t\tisPrime = False\n    \t\t\tbreak\n\n    \tif isPrime:\n    \t\tprimes.append( i )\n\n    return primes\n\nprint primeNumbers( 20 )\n</pre>\n", "senID": 3}], [{"text": ["You can make it more pythonic with sieve algorithm (all primes small than 100):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def primes(n):\n    sieved = set()\n    for i in range(2, n):\n        if not(i in sieved):\n            for j in range(i + i, n, i):\n                sieved.add(j)\n    return set(range(2, n)) - sieved\n\nprint primes(100)\n</code>\n</pre>\n", "senID": 1}, {"text": ["A very small trick will turn it to your goal."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Translated from the brilliant guys at stacktrace.it (Daniele Varrazzo, specifically), this version takes advantage of a binary min-heap to solve this problem:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "stacktrace.it", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stacktrace.it/2008/01/progetto-eulero-problema-3/"}, {"href": "http://en.wikipedia.org/wiki/Binary%5Fheap", "text": "a binary min-heap", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n from heapq import heappush, heapreplace\n\ndef yield_primes():\n    \"\"\"Endless prime number generator.\"\"\"\n\n    # Yield 2, so we don't have to handle the empty heap special case\n    yield 2\n\n    # Heap of (non-prime, prime factor) tuples.\n    todel = [ (4, 2) ]\n\n    n = 3\n    while True:\n        if todel[0][0] != n:\n            # This number is not on the head of the heap: prime!\n            yield n\n            heappush(todel, (n*n, n))   # add to heap\n\n        else:\n            # Not prime: add to heap\n            while todel[0][0] == n:\n                p = todel[0][1]\n                heapreplace(todel, (n+p, p))\n                # heapreplace pops the minimum value then pushes: \n                # heap size is unchanged\n\n        n += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["This code isn't mine and I don't understand it fully (but the explaination is here:) ), so I'm marking this answer as community wiki."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "This code isn't mine and I don't understand it fully (but the explaination is here:) ), so I'm marking this answer as community wiki.", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "but the explaination is here", "tag": "a"}]}, {"href": "http://stacktrace.it/2008/01/progetto-eulero-problema-3/", "text": "but the explaination is here", "childNum": 0, "tag": "a", "childList": []}]}]]