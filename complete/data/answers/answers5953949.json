[[{"text": ["If they are all within the same line, that is there are no line breaks between \"1.", "\" and \"2.", "\" then you can iterate over the lines of the file like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for line in open(\"myfile.txt\"):\n    #do stuff\n</code>\n</pre>\n", "senID": 1}, {"text": ["The line will be disposed of and overwritten at each iteration meaning you can handle large file sizes with ease.", "If they're not on the same line:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for line in open(\"myfile.txt\"):\n    if #regex to match start of new string\n       parsed_line = line\n    else:\n       parsed_line += line\n</code>\n</pre>\n", "senID": 3}, {"text": ["and the rest of your code."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Why don't you just read the file char by char using file.read(1)? "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "file.read(1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Then, you could - in each iteration - check whether you arrived at the char 1.", "Then you have to make sure that storing the string is fast."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If the \"N \" can only start a line, then why not use use the \"simple\" solution?", "(It sounds like this already being done, I am trying to reinforce/support it ;-))"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "It sounds like this already being done, I am trying to reinforce/support it ;-", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["That is, just reading a line at a time, and build up the data representing the current N object.", "After say N=0, and N=1 are loaded, process them together, then move onto the next pair (N=2, N=3).", "The only thing that is even remotely tricky is making sure not to throw out a read line.", "(The line read that determined the end condition -- e.g.", "\"N \" -- also contain the data for the next N)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Unless seeking is required (or IO caching is disabled or there is an absurd amount of data per item), there is really no reason not to use readline AFAIK."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Happy coding."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Here is some off-the-cuff code, which likely contains multiple errors.", "In any case, it shows the general idea using a minimized side-effect approach."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n # given an input and previous item data, return either\n# [item_number, data, next_overflow] if another item is read\n# or None if there are no more items\ndef read_item (inp, overflow):\n  data = overflow or \"\"\n\n  # this can be replaced with any method to \"read the header\"\n  # the regex is just \"the easiest\". the contract is just:\n  # given \"N ....\", return N. given anything else, return None\n  def get_num(d):\n    m = re.match(r\"(\\d+) \", d)\n    return int(m.groups(1)) if m else None\n\n  for line in inp:\n    if data and get_num(line) ne None:\n      # already in an item (have data); current line \"overflows\".\n      # item number is still at start of current data\n      return [get_num(data), data, line]\n\n    # not in item, or new item not found yet\n    data += line\n\n  # and end of input, with data. only returns above\n  # if a \"new\" item was encountered; this covers case of\n  # no more items (or no items at all)\n  if data:\n    return [get_num(data), data, None]\n  else\n    return None\n</code>\n</pre>\n", "senID": 5}, {"text": ["And usage might be akin to the following, where f represents an open file:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "f", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # check for error conditions (e.g. None returned)\n# note feed-through of \"overflow\"\nnum1, data1, overflow = read_item(f, None)\nnum2, data2, overflow = read_item(f, overflow)\n</code>\n</pre>\n", "senID": 7}], [{"text": ["If the format is fixed, why not just read 3 lines at a time with readline()"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If the file is small, you could read the whole file in and split() on number digits (might want to use strip() to get rid of whitespace and newlines), then fold over the list to process each string in the list.", "You'll probably have to check that the resultant string you are processing on is not initially empty in case two digits were next to each other."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "split()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#str.split"}, {"text": "strip()", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#str.strip"}]}], [{"text": ["If the file's content can be loaded in memory, and that's what you answered, then the following code (needs to have filename defined) may be a solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nregx = re.compile('^((\\d+).*?)(?=^\\d|\\Z)',re.DOTALL|re.MULTILINE)\n\nwith open(filename) as f:\n    text = f.read()\n\ndef treat(inp,regx=regx):\n    m1  = regx.search(inp)\n    numb,chunk = m1.group(2,1)\n    li = [chunk]\n    for mat in regx.finditer(inp,m1.end()):\n        n,ch = mat.group(2,1)\n        if int(n) == int(numb) + 1:\n            yield ''.join(li)\n            numb = n\n            li = []\n        li.append(ch)\n        chunk = ch\n    yield ''.join(li)\n\nfor y in treat(text):\n    print repr(y)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This code, run on a file containing :"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 1 mountain\norange 2\napple\nproduce\n2 gas\nsolemn\nenlightment\nprotectorate\n3 grimace\nsong\n4 snow\nwheat\n51 guludururu\nkelemekinonoto\n52asabi dabada\n5 yellow\n6 pink \nmusic\nair\n7 guitar\nblank 8\n8 Canada\n9 Rimini\n</code>\n</pre>\n", "senID": 3}, {"text": ["produces:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n '1 mountain\\norange 2\\napple\\nproduce\\n'\n'2 gas\\nsolemn\\nenlightment\\nprotectorate\\n'\n'3 grimace\\nsong\\n'\n'4 snow\\nwheat\\n51 guludururu\\nkelemekinonoto\\n52asabi dabada\\n'\n'5 yellow\\n'\n'6 pink \\nmusic\\nair\\n'\n'7 guitar\\nblank 8\\n'\n'8 Canada\\n'\n'9 Rimini'\n</code>\n</pre>\n", "senID": 5}]]