[[{"text": ["If you are interested in asymptotic time, then counting sort or radix sort provide good performance."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "asymptotic time", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["However, if you are interested in wall clock time you will need to compare performance between different algorithms using your particular data sets, as different algorithms perform differently with different datasets.", "In that case, its always worth trying quicksort:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "wall clock time", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "your particular data sets", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def qsort(inlist):\n    if inlist == []: \n        return []\n    else:\n        pivot = inlist[0]\n        lesser = qsort([x for x in inlist[1:] if x &lt; pivot])\n        greater = qsort([x for x in inlist[1:] if x &gt;= pivot])\n        return lesser + [pivot] + greater\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Since you know the range of numbers, you can use Counting Sort which will be linear in time."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Counting Sort", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Counting_sort"}]}], [{"text": ["Early versions of Python used a hybrid of samplesort (a variant of quicksort with large sample size) and binary insertion sort as the built-in sorting algorithm.", "This proved to be somewhat unstable.", "S0, from python 2.3 onward uses adaptive mergesort algorithm. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "samplesort", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "adaptive mergesort", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Order of mergesort (average) = O(nlogn).", "Order of mergesort (worst) = O(nlogn).", "But Order of quick sort (worst) = n*2"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "O(nlogn)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "O(nlogn)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["if you uses list=[ .............. ]"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "list=[ .............. ]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["list.sort() uses mergesort algorithm."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "list.sort()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "mergesort algorithm.", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For comparison between sorting algorithm you can read wiki"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "wiki", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Sorting_algorithm"}]}, {"text": ["For detail comparison comp"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "comp", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.daniweb.com/code/snippet216689.html"}]}], [{"text": ["Radix sort theoretically runs in linear time (sort time grows roughly in direct proportion to array size ), but in practice Quicksort is probably more suited, unless you're sorting absolutely massive arrays."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want to make quicksort a bit faster, you can use insertion sort] when the array size becomes small."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It would probably be helpful to understand the concepts of algorithmic complexity and Big-O notation too."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["We can use count sort using a dictionary to minimize the additional space usage, and keep the running time low as well.", "The count sort is much slower for small sizes of the input array because of the python vs C implementation overhead.", "The count sort starts to overtake the regular sort when the size of the array (COUNT) is about 1 million."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you really want huge speedups for smaller size inputs, implement the count sort in C and call it from Python."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(Fixed a bug which Aaron (+1) helped catch ...)\nThe python only implementation below compares the 2 approaches..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import random\nimport time\n\nCOUNT = 3000000\n\narray = [random.randint(1,100000) for i in range(COUNT)]\nrandom.shuffle(array)\n\narray1 = array[:]\n\nstart = time.time()\narray1.sort()\nend = time.time()\ntime1 = (end-start)\nprint 'Time to sort = ', time1*1000, 'ms'\n\narray2 = array[:]\n\nstart = time.time()\nardict = {}\nfor a in array2:\n    try:\n        ardict[a] += 1\n    except:\n        ardict[a] = 1\n\nindx = 0\nfor a in sorted(ardict.keys()):\n    b = ardict[a]\n    array2[indx:indx+b] = [a for i in xrange(b)]\n    indx += b\n\nend = time.time()\ntime2 = (end-start)\nprint 'Time to count sort = ', time2*1000, 'ms'\n\nprint 'Ratio =', time2/time1\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The built in functions are best, but since you can't use them have a look at this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://en.wikipedia.org/wiki/Quicksort"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://en.wikipedia.org/wiki/Quicksort", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Quicksort"}]}]]