[[{"text": ["Make on unix systems is usually used to track by date what needs rebuilding when files have changed.", "I normally use a rather good makefile for this job.", "There seems to be another alternative around on google code too"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "rather good makefile", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.acoustics.hut.fi/u/mairas/UltimateLatexMakefile/"}, {"text": "alternative", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://code.google.com/p/latex-makefile/"}]}], [{"text": ["You not only need to check for changes, but need to know that all changes are complete before running LaTeX.", "For example, if you start LaTeX after the first file has been modified and while more changes are still pending, you'll be using partial data and have to re-run later."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "all", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Wait for your first program to  complete:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #!/bin/bash\nfirst-program &amp;&amp;\n  run-after-changes-complete\n</code>\n</pre>\n", "senID": 2}, {"text": ["Using &amp;&amp; means the second command is only executed if the first completes successfully (a zero exit code).", "Because this simple script will always run the second command even if the first doesn't change any files, you can incorporate this into whatever build system you are already familiar with, such as make."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Is dnotify what you need?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dnotify", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://linux.die.net/man/1/dnotify"}]}], [{"text": ["Python FAM is a Python interface for FAM (File Alteration Monitor) "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Python FAM", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://python-fam.sourceforge.net/"}, {"href": "http://oss.sgi.com/projects/fam/", "text": "FAM", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["You can also have a look at Pyinotify, which is a module for monitoring file system changes."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Pyinotify", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyinotify.sourceforge.net/"}]}], [{"text": ["inotify replaces dnotify."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "inotify", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dnotify", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Why?"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Why?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.developertutorials.com/tutorials/linux/monitor-linux-inotify-050531-1133/"}]}, {"text": ["...and more."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["More Why?"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "More Why?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://inotify.aiken.cz/?section=inotify&page=why&lang=en"}]}, {"text": ["Reference"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Reference", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Inotify"}]}], [{"text": ["Not much of a python man myself.", "But in a pinch, assuming you're on linux, you could periodically shell out and \"ls -lrt /path/to/directory\" (get the directory contents and sort by last modified), and compare the results of the last two calls for a difference.", "If so, then there was a change.", "Not very detailed, but gets the job done."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can use native python module hashlib which implements MD5 algorithm:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "hashlib", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; m = hashlib.md5()\n&gt;&gt;&gt; for root, dirs, files in os.walk(path):\n    for file_read in files:\n        full_path = os.path.join(root, file_read)\n        for line in open(full_path).readlines():\n            m.update(line)\n\n\n&gt;&gt;&gt; m.digest()\n'pQ\\x1b\\xb9oC\\x9bl\\xea\\xbf\\x1d\\xda\\x16\\xfe8\\xcf'\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can save this result in a file or a variable, and compare it to the result of the next run.", "This will detect changes in any files, in any sub-directory."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This does not take into account file permission changes; if you need to monitor these change as well, this could be addressed via appending a string representing the permissions (accessible via os.stat for instance, attributes depend on your system) to the mvariable."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "os.stat", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "m", "childNum": 0, "tag": "code", "childList": []}]}]]