[[{"text": ["If you generate permutations in lexicographical order, then you don't need to store anything to work out whether the reverse of a given permutation has already been seen.", "You just have to lexicographically compare it to its reverse - if it's smaller then return it, if it's larger then skip it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There's probably a more efficient way to do it, but this is simple and has the properties you require (implementable as a generator, uses O(n) working memory)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I have a marvelous followup to SilentGhost's proposal - posting a separate answer since the margins of a comment would be too narrow to contain code :-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["itertools.permutations is built in (since 2.6) and fast.", "We just need a filtering condition that for every (perm, perm[::-1]) would accept exactly one of them.", "Since the OP says items are always distinct, we can just compare any 2 elements:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "itertools.permutations", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for p in itertools.permutations(range(3)):\n    if p[0] &lt; p[-1]:\n        print p\n</code>\n</pre>\n", "senID": 2}, {"text": ["which prints:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n (0, 1, 2)\n(0, 2, 1)\n(1, 0, 2)\n</code>\n</pre>\n", "senID": 4}, {"text": ["This works because reversing the permutation would always flip the relation!", "p[0] &lt; p[1] or any other pair would also work, so you also have some control over which half of permutations you get."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "p[0] &lt; p[1]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I'm not sure if there is any more effecient way to filter.", "itertools.permutations guarantees lexicographic order, but the lexicographic position p and p[::-1] are related in a quite complex way.", "In particular, just stopping at the middle doesn't work."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "itertools.permutations", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "p", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "p[::-1]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["But I suspect (didn't check) that the built-in iterator with 2:1 filtering would outperform any custom implementation.", "And of course it wins on simplicity!"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["EDIT: changed completely to keep everything as a generator (never the whole list in memory).", "Should fulfill the requirements (only calculates half of the possible permutations (not the reverse ones).", "EDIT2: added shorter (and simpler) factorial function from here."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "EDIT2", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"href": "http://importantshock.wordpress.com/2006/11/03/one-line-factorial-function-in-python/", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["EDIT3:: (see comments) - a version with improvements can be found in bwopah's version."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "EDIT3:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/960557/how-to-generate-permutations-of-a-list-without-reverse-duplicates-in-python-usi/962134#962134", "text": "bwopah's version", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n def fac(x): \n    return (1 if x==0 else x * fac(x-1))\n\ndef all_permutations(plist):\n    global counter\n\n    if len(plist) &lt;=1:\n        yield plist\n    else:\n        for perm in all_permutations(plist[1:]):\n            for i in xrange(len(perm)+1):\n                if len(perm[:i] + plist[0:1] + perm[i:]) == lenplist:\n                        if counter == limit:\n                             raise StopIteration\n                        else:\n                             counter = counter + 1\n                yield perm[:i] + plist[0:1] + perm[i:]\n\ncounter = 0\nplist = ['a','b','c']\nlenplist = len(plist)\nlimit = fac(lenplist) / 2\n\nall_permutations_gen = all_permutations(plist)\nprint all_permutations_gen\nprint list(all_permutations_gen)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["This is a more concise and faster version of ChristopheD's accepted answer, which I liked a lot.", "Recursion is great.", "I made it enforce uniquenss of the incoming list by removing duplicates, however maybe it should just raise an exception instead."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fac(x): \n    return (1 if x==0 else x * fac(x-1))\n\ndef permz(plist):\n    plist = sorted(set(plist))\n    plen = len(plist)\n    limit = fac(plen) / 2\n    counter = 0\n    if plen==1:\n        yield plist\n    else:\n        for perm in permz(plist[1:]):\n            for i in xrange(plen):\n                if counter == limit:\n                     raise StopIteration\n                counter += 1\n                yield perm[:i] + plist[0:1] + perm[i:]\n\n# ---- testing ----\nplists = [\n    list('love'),\n    range(5),\n    [1,4,2,3,9],\n    ['a',2,2.1],\n    range(8)]               \n\nfor plist in plists:\n    perms = list(permz(plist))\n    print plist, True in [(list(reversed(i)) in foo) for i in perms]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import permutations\n\ndef rev_generator(plist):\n    reversed_elements = set()\n    for i in permutations(plist):\n        if i not in reversed_elements:\n            reversed_i = tuple(reversed(i))\n            reversed_elements.add(reversed_i)\n            yield i\n\n&gt;&gt;&gt; list(rev_generator([1,2,3]))\n[(1, 2, 3), (1, 3, 2), (2, 1, 3)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also, if the return value must be a list, you could just change the yield i to yield list(i), but for iteration purposes, the tuples will work just fine."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here is code that does the trick.", "To get rid of the dups I noticed that for your list if the value of the first location is greater than the value of the last location then it will be a dup.", "I create a map to keep track of where each item was in the list to start with and then use that map to do the test.", "The code also does not use recursion so it keeps its memory footprint small.", "Also the list can be of any type items not just numbers see the last two test cases."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is the code."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Permutation:\n    def __init__(self, justalist):\n        self._data = justalist[:]\n        self._len=len(self._data)\n        self._s=[]\n        self._nfact=1\n        self._map ={}\n        i=0\n        for elem in self._data:\n            self._s.append(elem)\n            self._map[str(elem)]=i\n            i+=1\n            self._nfact*=i\n        if i != 0:\n            self._nfact2=self._nfact//i\n\n    def __iter__(self):\n        for k in range(self._nfact):\n            for i in range(self._len):\n                self._s[i]=self._data[i]\n            s=self._s\n            factorial=self._nfact2\n            for i in range(self._len-1):\n                tempi = (k // factorial) % (self._len - i)\n                temp = s[i + tempi]\n                for j in range(i + tempi,i,-1):\n                    s[j] = s[j-1]\n                s[i] = temp\n                factorial //= (self._len - (i + 1))\n\n            if self._map[str(s[0])] &lt; self._map[str(s[-1])]:\n                yield s\n\n\n\n\ns=[1,2]\nprint(\"_\"*25)\nprint(\"input list:\",s)\nfor sx in Permutation(s):\n    print(sx)\n\ns=[1,2,3]\nprint(\"_\"*25)\nprint(\"input list:\",s)\nfor sx in Permutation(s):\n    print(sx)\n\ns=[1,2,3,4]\nprint(\"_\"*25)\nprint(\"input list:\",s)\nfor sx in Permutation(s):\n    print(sx)\n\ns=[3,2,1]\nprint(\"_\"*25)\nprint(\"input list:\",s)\nfor sx in Permutation(s):\n    print(sx)\n\ns=[\"Apple\",\"Pear\",\"Orange\"]\nprint(\"_\"*25)\nprint(\"input list:\",s)\nfor sx in Permutation(s):\n    print(sx)\n\ns=[[1,4,5],\"Pear\",(1,6,9),Permutation([])]\nprint(\"_\"*25)\nprint(\"input list:\",s)\nfor sx in Permutation(s):\n    print(sx)\n</code>\n</pre>\n", "senID": 2}, {"text": ["and here is the output for my test cases."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n _________________________\ninput list: [1, 2]\n[1, 2]\n_________________________\ninput list: [1, 2, 3]\n[1, 2, 3]\n[1, 3, 2]\n[2, 1, 3]\n_________________________\ninput list: [1, 2, 3, 4]\n[1, 2, 3, 4]\n[1, 2, 4, 3]\n[1, 3, 2, 4]\n[1, 3, 4, 2]\n[1, 4, 2, 3]\n[1, 4, 3, 2]\n[2, 1, 3, 4]\n[2, 1, 4, 3]\n[2, 3, 1, 4]\n[2, 4, 1, 3]\n[3, 1, 2, 4]\n[3, 2, 1, 4]\n_________________________\ninput list: [3, 2, 1]\n[3, 2, 1]\n[3, 1, 2]\n[2, 3, 1]\n_________________________\ninput list: ['Apple', 'Pear', 'Orange']\n['Apple', 'Pear', 'Orange']\n['Apple', 'Orange', 'Pear']\n['Pear', 'Apple', 'Orange']\n_________________________\ninput list: [[1, 4, 5], 'Pear', (1, 6, 9), &lt;__main__.Permutation object at 0x0142DEF0&gt;]\n[[1, 4, 5], 'Pear', (1, 6, 9), &lt;__main__.Permutation object at 0x0142DEF0&gt;]\n[[1, 4, 5], 'Pear', &lt;__main__.Permutation object at 0x0142DEF0&gt;, (1, 6, 9)]\n[[1, 4, 5], (1, 6, 9), 'Pear', &lt;__main__.Permutation object at 0x0142DEF0&gt;]\n[[1, 4, 5], (1, 6, 9), &lt;__main__.Permutation object at 0x0142DEF0&gt;, 'Pear']\n[[1, 4, 5], &lt;__main__.Permutation object at 0x0142DEF0&gt;, 'Pear', (1, 6, 9)]\n[[1, 4, 5], &lt;__main__.Permutation object at 0x0142DEF0&gt;, (1, 6, 9), 'Pear']\n['Pear', [1, 4, 5], (1, 6, 9), &lt;__main__.Permutation object at 0x0142DEF0&gt;]\n['Pear', [1, 4, 5], &lt;__main__.Permutation object at 0x0142DEF0&gt;, (1, 6, 9)]\n['Pear', (1, 6, 9), [1, 4, 5], &lt;__main__.Permutation object at 0x0142DEF0&gt;]\n['Pear', &lt;__main__.Permutation object at 0x0142DEF0&gt;, [1, 4, 5], (1, 6, 9)]\n[(1, 6, 9), [1, 4, 5], 'Pear', &lt;__main__.Permutation object at 0x0142DEF0&gt;]\n[(1, 6, 9), 'Pear', [1, 4, 5], &lt;__main__.Permutation object at 0x0142DEF0&gt;]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Here is my implementation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = [1,2,3,4]\n\ndef p(l):\n  if len(l) &lt;= 1:\n    yield l\n  else:\n    for i in range(len(l)):\n      for q in p([l[j] for j in range(len(l)) if j != i]):\n        yield [l[i]] + q\n\nout = (i for i in p(a) if i &lt; i[::-1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["P function is a regular permu function, yields all possibilities.", "The filter is done when iterates the result.", "Simply, it has two possible results, the smaller half of the all permus and the bigger half of the permus.", "In this example, the out contains the smaller half of the list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["this is an implementation of onebyone's suggestion"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["from http://en.wikipedia.org/wiki/Permutation#Lexicographical_order_generation\nThe following algorithm generates the next permutation lexicographically after a given permutation.", "It changes the given permutation in-place."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://en.wikipedia.org/wiki/Permutation#Lexicographical_order_generation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Permutation#Lexicographical_order_generation"}]}, {"text": ["the function:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def perms(items):\n    items.sort()\n    yield items[:]\n    m = [len(items)-2]  # step 1\n    while m:\n        i = m[-1]\n        j = [ j for j in range(i+1,len(items)) if items[j]&gt;items[i] ][-1] # step 2\n        items[i], items[j] = items[j], items[i] # step 3\n        items[i+1:] = list(reversed(items[i+1:])) # step 4\n        if items&lt;list(reversed(items)):\n            yield items[:]\n        m = [ i for i in range(len(items)-1) if items[i]&lt;items[i+1] ]  # step 1\n</code>\n</pre>\n", "senID": 3}, {"text": ["checking our work:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; foo=list(perms([1,3,2,4,5]))\n&gt;&gt;&gt; True in [(list(reversed(i)) in foo) for i in foo]\nFalse\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Some setup code first:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    from itertools import permutations\nexcept ImportError:\n    # straight from http://docs.python.org/library/itertools.html#itertools.permutations\n    def permutations(iterable, r=None):\n        # permutations('ABCD', 2) --&gt; AB AC AD BA BC BD CA CB CD DA DB DC\n        # permutations(range(3)) --&gt; 012 021 102 120 201 210\n        pool = tuple(iterable)\n        n = len(pool)\n        r = n if r is None else r\n        if r &gt; n:\n            return\n        indices = range(n)\n        cycles = range(n, n-r, -1)\n        yield tuple(pool[i] for i in indices[:r])\n        while n:\n            for i in reversed(range(r)):\n                cycles[i] -= 1\n                if cycles[i] == 0:\n                    indices[i:] = indices[i+1:] + indices[i:i+1]\n                    cycles[i] = n - i\n                else:\n                    j = cycles[i]\n                    indices[i], indices[-j] = indices[-j], indices[i]\n                    yield tuple(pool[i] for i in indices[:r])\n                    break\n            else:\n                return\n\ndef non_reversed_permutations(iterable):\n    \"Return non-reversed permutations for an iterable with unique items\"\n    for permutation in permutations(iterable):\n        if permutation[0] &lt; permutation[-1]:\n            yield permutation\n</code>\n</pre>\n", "senID": 1}], [{"text": ["itertools.permutations does exactly what you want.", "you might make of use of reversedbuilt-in as well"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "itertools.permutations", "tag": "a", "pos": 0, "childList": [{"text": "itertools.permutations", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html?highlight=itertools#itertools.permutations"}, {"text": "itertools.permutations", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "reversedbuilt-in", "tag": "a", "pos": 1, "childList": [{"text": "reversed", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html?highlight=reversed#reversed"}, {"text": "reversed", "childNum": 0, "tag": "code", "childList": []}]}]]