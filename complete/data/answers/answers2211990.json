[[{"text": ["I still like what I wrote up here (a Cookbook recipe with many other authors) -- it shows how a Sieve of Eratosthenes has no intrinsic limits, and the comments and discussion, I believe, make it quite clear.", "This was recently discussed on Stack Overflow (search for the authors' names, I guess) and somebody proposed a substantially faster (but IMHO less clear) version;-)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://macdevcenter.com/pub/a/python/excerpt/pythonckbk_chap1/index1.html?page=2"}]}], [{"text": ["The erat2 function from the cookbook can be further sped up (by about 20-25%):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "erat2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["erat2a"], "childNum": 0, "tag": "h2", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import itertools as it\ndef erat2a( ):\n    D = {  }\n    yield 2\n    for q in it.islice(it.count(3), 0, None, 2):\n        p = D.pop(q, None)\n        if p is None:\n            D[q*q] = q\n            yield q\n        else:\n            # old code here:\n            # x = p + q\n            # while x in D or not (x&amp;1):\n            #     x += p\n            # changed into:\n            x = q + 2*p\n            while x in D:\n                x += 2*p\n            D[x] = p\n</code>\n</pre>\n", "senID": 2}, {"text": ["The not (x&amp;1) check verifies that x is odd.", "However, since both q and p are odd, by adding 2*p half of the steps are avoided along with the test for oddity."], "childNum": 6, "tag": "p", "senID": 3, "childList": [{"text": "not (x&amp;1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "both", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "q", "childNum": 0, "tag": "code", "childList": []}, {"text": "p", "childNum": 0, "tag": "code", "childList": []}, {"text": "2*p", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["erat3"], "childNum": 0, "tag": "h2", "senID": 4, "childList": []}, {"text": ["If one doesn't mind a little extra fanciness, erat2 can be sped up by 35-40% with the following changes (NB: needs Python 2.7+ or Python 3+ because of the itertools.compress function):"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "erat2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools.compress", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import itertools as it\ndef erat3( ):\n    D = { 9: 3, 25: 5 }\n    yield 2\n    yield 3\n    yield 5\n    MASK= 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0,\n    MODULOS= frozenset( (1, 7, 11, 13, 17, 19, 23, 29) )\n\n    for q in it.compress(\n            it.islice(it.count(7), 0, None, 2),\n            it.cycle(MASK)):\n        p = D.pop(q, None)\n        if p is None:\n            D[q*q] = q\n            yield q\n        else:\n            x = q + 2*p\n            while x in D or (x%30) not in MODULOS:\n                x += 2*p\n            D[x] = p\n</code>\n</pre>\n", "senID": 6}, {"text": ["The erat3 function takes advantage of the fact that all primes (except for  2, 3, 5) modulo 30 result to only eight numbers: the ones included in the MODULOS frozenset.", "Thus, after yielding the initial three primes, we start from 7 and work only with the candidates.", "The candidate filtering uses the itertools.compress function; the \u201cmagic\u201d is in the MASK sequence; MASK has 15 elements (there are 15 odd numbers in every 30 numbers, as chosen by the itertools.islice function) with a 1 for every possible candidate, starting from 7.", "The cycle repeats as specified by the itertools.cycle function.", "The introduction of the candidate filtering needs another modification: the or (x%30) not in MODULOS check.", "The erat2 algorithm processed all odd numbers; now that the erat3 algorithm processes only r30 candidates, we need to make sure that all D.keys() can only be such \u2014false\u2014 candidates."], "childNum": 15, "tag": "p", "senID": 7, "childList": [{"text": "erat3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "MODULOS", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "only", "childNum": 0, "tag": "em", "pos": 5, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "itertools.compress", "childNum": 0, "tag": "code", "childList": []}, {"text": "MASK", "childNum": 0, "tag": "code", "childList": []}, {"text": "MASK", "childNum": 0, "tag": "code", "childList": []}, {"text": "itertools.islice", "childNum": 0, "tag": "code", "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}, {"text": "itertools.cycle", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "or (x%30) not in MODULOS", "childNum": 0, "tag": "code", "childList": []}, {"text": "erat2", "childNum": 0, "tag": "code", "childList": []}, {"text": "erat3", "childNum": 0, "tag": "code", "childList": []}, {"text": "D.keys()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Benchmarks"], "childNum": 0, "tag": "h2", "senID": 8, "childList": []}, {"text": ["On an Atom 330 Ubuntu 9.10 server, versions 2.6.4 and 3.1.1+:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n $ testit\nup to 8192\n==== python2 erat2 ====\n100 loops, best of 3: 18.6 msec per loop\n==== python2 erat2a ====\n100 loops, best of 3: 14.5 msec per loop\n==== python2 erat3 ====\nTraceback (most recent call last):\n\u2026\nAttributeError: 'module' object has no attribute 'compress'\n==== python3 erat2 ====\n100 loops, best of 3: 19.2 msec per loop\n==== python3 erat2a ====\n100 loops, best of 3: 14.1 msec per loop\n==== python3 erat3 ====\n100 loops, best of 3: 11.7 msec per loop\n</code>\n</pre>\n", "senID": 10}, {"text": ["On an AMD Geode LX Gentoo home server, Python 2.6.5 and 3.1.2:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n $ testit\nup to 8192\n==== python2 erat2 ====\n10 loops, best of 3: 104 msec per loop\n==== python2 erat2a ====\n10 loops, best of 3: 81 msec per loop\n==== python2 erat3 ====\nTraceback (most recent call last):\n\u2026\nAttributeError: 'module' object has no attribute 'compress'\n==== python3 erat2 ====\n10 loops, best of 3: 116 msec per loop\n==== python3 erat2a ====\n10 loops, best of 3: 82 msec per loop\n==== python3 erat3 ====\n10 loops, best of 3: 66 msec per loop\n</code>\n</pre>\n", "senID": 12}, {"text": ["A primegen.py module contains the erat2, erat2a and erat3 functions.", "Here follows the testing script:"], "childNum": 4, "tag": "p", "senID": 13, "childList": [{"text": "primegen.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "erat2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "erat2a", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "erat3", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n #!/bin/sh\nmax_num=${1:-8192}\necho up to $max_num\nfor python_version in python2 python3\ndo\n    for function in erat2 erat2a erat3\n    do\n        echo \"==== $python_version $function ====\"\n        $python_version -O -m timeit -c \\\n        -s  \"import itertools as it, functools as ft, operator as op, primegen; cmp= ft.partial(op.ge, $max_num)\" \\\n            \"next(it.dropwhile(cmp, primegen.$function()))\"\n    done\ndone\n</code>\n</pre>\n", "senID": 14}], [{"text": ["This isn't originally my code, however, it's worth posting.", "The original can be found here: http://code.activestate.com/recipes/117119/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://code.activestate.com/recipes/117119/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/117119/"}]}, {"code": "<pre>\n<code>\n def gen_primes():\n  D = {}\n  q = 2  # first integer to test for primality.\n\n  while True:\n    if q not in D:\n      # not marked composite, must be prime  \n      yield q \n\n      #first multiple of q not already marked\n      D[q * q] = [q] \n    else:\n      for p in D[q]:\n        D.setdefault(p + q, []).append(p)\n      # no longer need D[q], free memory\n      del D[q]\n\n    q += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's a generator, so use it like any other."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n primes = gen_primes()\nfor p in primes:\n  print p\n</code>\n</pre>\n", "senID": 3}, {"text": ["It takes 1.62s to generate and put into a set, 1 million primes, on my desktop."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Do a sliced sieve, where the size of a slice is determined by available memory or the maximal size of a bitset."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sliced", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["For each slice represent the numbers in some interval [n; n + slice_size) as a bit set and sieve with all prime numbers below the square root of the upper bound."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Using a bit set uses less memory than a hash table or tree data structure, because you are working with dense sets of numbers."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's a generator that's a little truer to how it's done in Haskell: filtering against composites of known primes, then adding the remaining primes to the list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def gen_primes():\n    primes = []\n    i = 2\n    while True:\n        prime = True\n        for p in primes:\n            if not (i % p):\n                prime = False\n                break\n        if prime:\n            yield i\n            primes.append(i)\n        i += 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I wrote an article about an infinite primes generator some times ago: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://stacktrace.it/2008/01/progetto-eulero-problema-3/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://stacktrace.it/2008/01/progetto-eulero-problema-3/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stacktrace.it/2008/01/progetto-eulero-problema-3/"}]}, {"text": ["It's in Italian but you may have a pesky translation using Google: http://tinyurl.com/yzpyeom"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://tinyurl.com/yzpyeom", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://tinyurl.com/yzpyeom"}]}], [{"text": ["And another answer, more memory-efficient than my erat3 answer here:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "erat3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import heapq\n\ndef heapprimegen():\n    hp= []\n    yield 2\n    cn= 3\n    nn, inc= 3, 6\n    while 1:\n        while cn &lt; nn:\n            yield cn\n            heapq.heappush(hp, (3*cn, 2*cn))\n            cn+= 2\n        cn= nn+2\n        nn, inc= heapq.heappushpop(hp, (nn+inc, inc))\n</code>\n</pre>\n", "senID": 1}, {"text": ["It maintains a heap (a list) of prime multiples rather than a dictionary.", "It loses some speed, obviously."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Another way to do it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\ndef primeseq():\n    prime = [2]\n    num = 0\n    yield 2\n    for i in itertools.count(3, 2):\n        is_prime = True\n        for num in prime:\n            if i % num == 0:\n                is_prime = False\n                break\n            elif num ** 2 &gt; i: \n                break\n        if is_prime:\n            prime.append(i)\n            yield i\n</code>\n</pre>\n", "senID": 1}]]