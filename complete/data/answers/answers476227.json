[[{"text": ["The exact same question that people at the old AudioScrobbler and currently at MusicBrainz have worked on since long ago.", "For the time being, the Python project that can aid in your quest, is Picard, which will tag audio files (not only MPEG 1 Layer 3 files) with a GUID (actually, several of them), and from then on, matching the tags is quite simple."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "MusicBrainz", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://musicbrainz.org/"}, {"text": "Picard", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://musicbrainz.org/doc/PicardDownload"}]}, {"text": ["If you prefer to do it as a project of your own, libofa might be of help."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "libofa", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/musicip-libofa/"}]}], [{"text": ["I don't think simple checksums will ever work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I think you'll have to compare ID3 tags, song length, and filenames."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Like the others said, simple checksums won't detect duplicates with different bitrates or ID3 tags.", "What you need is an audio fingerprint algorithm.", "The Python Audioprocessing Suite has such an an algorithm, but I can't say anything about how reliable it is."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://rudd-o.com/new-projects/python-audioprocessing"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://rudd-o.com/new-projects/python-audioprocessing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://rudd-o.com/new-projects/python-audioprocessing"}]}], [{"text": ["For tag issues, Picard may indeed be a very good bet.", "If, having identified two potentially duplicate files, what you want is to extract bitrate information from them, have a look at mp3guessenc."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Picard", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://musicbrainz.org/doc/PicardTagger"}, {"text": "mp3guessenc", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://shibatch.sourceforge.net/"}]}], [{"text": ["Re-encoding at the same bit rate won't work, in fact it may make things worse as transcoding (that is what re-encoding at different bitrates is called) is going to change the nature of the compression, you are recompressing an already compressed file is going to lead to a significantly different file."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is a little out of my league but I would approach the problem by looking at the wave pattern of the MP3.", "Either by converting the MP3 to an uncompressd .wav or maybe by just running the analysis on the MP3 file itself.", "There should be a library out there for this.", "Just a word of warning, this is an expensive operation. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Another idea, use ReplayGain to scan the files.", "If they are the same song, they should be be tagged with the same gain.", "This will only work on the exact same song from the exact same album.", "I know of several cases were reissues are remastered at a higher volume, thus changing the replaygain."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT:\nYou might want to check out http://www.speech.kth.se/snack/, which apparently can do spectrogram visualization.", "I imagine any library that can visual spectrogram can help you compare them."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "http://www.speech.kth.se/snack/", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.speech.kth.se/snack/"}]}, {"text": ["This link from the official python page may also be helpful."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "link", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/PythonInMusic"}]}], [{"text": ["I'm looking for something similar and I found this:\nhttp://www.lastfm.es/user/nova77LF/journal/2007/10/12/4kaf_fingerprint_(command_line)_client"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"href": "http://www.lastfm.es/user/nova77LF/journal/2007/10/12/4kaf_fingerprint_(command_line)_client", "text": "http://www.lastfm.es/user/nova77LF/journal/2007/10/12/4kaf_fingerprint_(command_line)_client", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Hope it helps."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I'd use length as my primary heuristic.", "That's what iTunes does when it's trying to identify a CD using the Gracenote database.", "Measure the lengths in milliseconds rather than seconds.", "Remember, this is only a heuristic: you should definitely listen to any detected duplicates before deleting them."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Gracenote database", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Gracenote"}, {"text": "Measure the lengths in milliseconds", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/993971/mp3-length-in-milliseconds"}]}]]