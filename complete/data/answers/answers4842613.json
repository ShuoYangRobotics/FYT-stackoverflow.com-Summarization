[[{"text": ["Algorithm:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So you might want to use sets instead of list.", "The following program should do it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n l = [['a', 'b', 'c'], ['b', 'd', 'e'], ['k'], ['o', 'p'], ['e', 'f'], ['p', 'a'], ['d', 'g']]\n\nout = []\nwhile len(l)&gt;0:\n    first, *rest = l\n    first = set(first)\n\n    lf = -1\n    while len(first)&gt;lf:\n        lf = len(first)\n\n        rest2 = []\n        for r in rest:\n            if len(first.intersection(set(r)))&gt;0:\n                first |= set(r)\n            else:\n                rest2.append(r)     \n        rest = rest2\n\n    out.append(first)\n    l = rest\n\nprint(out)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I think this can be solved by modelling the problem as a graph.", "Each sublist is a node and shares an edge with another node only if the two sublists have some element in common.", "Thus, a merged sublist is basically a connected component in the graph.", "Merging all of them is simply a matter of finding all connected components and listing them."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "graph", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Graph_%28mathematics%29"}, {"text": "connected component", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29"}]}, {"text": ["This can be done by a simple traversal over the graph.", "Both BFS and DFS can be used, but I'm using DFS here since it is somewhat shorter for me."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "BFS", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Breadth-first_search"}, {"href": "http://en.wikipedia.org/wiki/Depth-first_search", "text": "DFS", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n l = [['a','b','c'],['b','d','e'],['k'],['o','p'],['e','f'],['p','a'],['d','g']]\ntaken=[False]*len(l)\nl=map(set,l)\n\ndef dfs(node,index):\n    taken[index]=True\n    ret=node\n    for i,item in enumerate(l):\n        if not taken[i] and not ret.isdisjoint(item):\n            ret.update(dfs(item,i))\n    return ret\n\ndef merge_all():\n    ret=[]\n    for i,node in enumerate(l):\n        if not taken[i]:\n            ret.append(list(dfs(node,i)))\n    return ret\n\nprint merge_all()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You can see your list as a notation for a Graph, ie ['a','b','c'] is a graph with 3 nodes connected to each other.", "The problem you are trying to solve is finding connected components in this graph."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "['a','b','c']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "connected components in this graph", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Connectivity_%28graph_theory%29"}]}, {"text": ["You can use NetworkX for this, which has the advantage that it's pretty much guaranteed to be correct:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "NetworkX", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://networkx.lanl.gov/index.html"}]}, {"code": "<pre>\n<code>\n l = [['a','b','c'],['b','d','e'],['k'],['o','p'],['e','f'],['p','a'],['d','g']]\n\nimport networkx \nfrom networkx.algorithms.components.connected import connected_components\n\n\ndef to_graph( l ):\n    G = networkx.Graph()\n    for part in l:\n        # each sublist is a bunch of nodes\n        G.add_nodes_from(part)\n        # it also imlies a number of edges:\n        G.add_edges_from(to_edges(part))\n    return G\n\ndef to_edges( l ):\n    \"\"\" sees `l` as a Graph and returns it's edges \n        to_edges(['a','b','c','d']) -&gt; [(a,b), (b,c),(c,d)]\n    \"\"\"\n\n    it = iter(l)\n    last = next(it)\n\n    # keep the last item, yield it with the current\n    for current in it:\n        yield last, current\n        last = current\n\n\nG = to_graph(l)\nprint connected_components(G)\n# prints [['a', 'c', 'b', 'e', 'd', 'g', 'f', 'o', 'p'], ['k']]\n</code>\n</pre>\n", "senID": 2}, {"text": ["To solve this efficiently yourself you have to convert the list into something graph-ish anyways, so you might as well use networkX from the start."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["My attempt.", "Has functional look to it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\nfrom collections import defaultdict\nl = [['a','b','c'],['b','d','e'],['k'],['o','p'],['e','f'],['p','a'],['d','g']]\nhashdict = defaultdict(int)\n\ndef hashit(x, y):\n    for i in y: x[i] += 1\n    return x\n\ndef merge(x, y):\n    sums = sum([hashdict[i] for i in y])\n    if sums &gt; len(y):\n        x[0] = x[0].union(y)\n    else:\n        x[1] = x[1].union(y)\n    return x\n\n\nhashdict = reduce(hashit, l, hashdict)\nsets = reduce(merge, l, [set(),set()])\nprint [list(sets[0]), list(sets[1])]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Without knowing quite what you want, I decided to just guess you meant: I want to find every element just once."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n\n\ndef clink(l, acc):\n  for sub in l:\n    if sub.__class__ == list:\n      clink(sub, acc)\n    else:\n      acc[sub]=1\n\ndef clunk(l):\n  acc = {}\n  clink(l, acc)\n  print acc.keys()\n\nl = [['a', 'b', 'c'], ['b', 'd', 'e'], ['k'], ['o', 'p'], ['e', 'f'], ['p', 'a'], ['d', 'g']]\n\nclunk(l)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output looks like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ['a', 'c', 'b', 'e', 'd', 'g', 'f', 'k', 'o', 'p']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I came across the same issue of trying to merge down lists with common values.", "This example may be what you are looking for.", "It only loops over lists once and updates resultset as it goes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n lists = [['a','b','c'],['b','d','e'],['k'],['o','p'],['e','f'],['p','a'],['d','g']]\nlists = sorted([sorted(x) for x in lists]) #Sorts lists in place so you dont miss things. Trust me, needs to be done.\n\nresultslist = [] #Create the empty result list.\n\nif len(lists) &gt;= 1: # If your list is empty then you dont need to do anything.\n    resultlist = [lists[0]] #Add the first item to your resultset\n    if len(lists) &gt; 1: #If there is only one list in your list then you dont need to do anything.\n        for l in lists[1:]: #Loop through lists starting at list 1\n            listset = set(l) #Turn you list into a set\n            merged = False #Trigger\n            for index in range(len(resultlist)): #Use indexes of the list for speed.\n                rset = set(resultlist[index]) #Get list from you resultset as a set\n                if len(listset &amp; rset) != 0: #If listset and rset have a common value then the len will be greater than 1\n                    resultlist[index] = list(listset | rset) #Update the resultlist with the updated union of listset and rset\n                    merged = True #Turn trigger to True\n                    break #Because you found a match there is no need to continue the for loop.\n            if not merged: #If there was no match then add the list to the resultset, so it doesnt get left out.\n                resultlist.append(l)\nprint resultlist\n</code>\n</pre>\n", "senID": 1}, {"text": ["resultset = [['a', 'b', 'c', 'd', 'e', 'g', 'f', 'o', 'p'], ['k']]"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]