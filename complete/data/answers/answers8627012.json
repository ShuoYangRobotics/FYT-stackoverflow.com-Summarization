[[{"text": ["I suspect that your spending a huge amount of time in your isprime function.", "Perhaps using some extra memory, and using a prime sieve to store a in a list whether each number is prime at the beginning would help a little."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You may even be able to optimize further, by generating a list of prime numbers, and divisors at the same time, using an algorithm very similar to a sieve."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I claim that you are spending a lot of time in your isprime method.", "Here are two possibilities that come to mind to improve on that front:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["Generate a (sorted) list of primes (using eratosthenes sieve or something) and lookup numbers instead of executing that loop to test whether a number is prime."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Build a cache for isprime lookups: whenever you determine whether a number is prime or not, save the result in a list/dict/whatever.", "Before calling isprime, check if you already tested that number by looking in your list/dict/whatever."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]}, {"text": ["The second suggestion is not quite as efficient as the first, but is very easy to patch into your current solution."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You spend much too much time collecting the divisors."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To find the divisors, you check every number not exceeding n**0.5 whether it divides n. So that's sum([int(n**0.5) for n in range(1,maximum)]), approximately 6.7*10**11, divisions.", "That takes a lot of time.", "The slow isprime function is a relatively minor problem, since most of the time it will quickly find the candidate to be composite."], "childNum": 6, "tag": "p", "senID": 1, "childList": [{"text": "n**0.5", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "sum([int(n**0.5) for n in range(1,maximum)])", "childNum": 0, "tag": "code", "childList": []}, {"text": "6.7*10**11", "childNum": 0, "tag": "code", "childList": []}, {"text": "lot", "childNum": 0, "tag": "em", "childList": []}, {"text": "isprime", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["A Haskell solution using what looks like the same algorithm can be much faster because Haskell is lazy.", "The list of divisors is only computed as far as required, so most numbers will be eliminated after having calculated only very few divisors, which is done quickly.", "In Python, you can achieve that with generators (yield)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "very few", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["To get a speedier programme, the suggestion of JeffS to simultaneously sieve primes and divisors (sieve only divisors, the primes/primality test follows automatically from that) is a good first step.", "More can be gained by doing a bit of mathematical analysis of the problem.", "Find a few relatively easy necessary conditions for the numbers.", "You will find that there aren't too many numbers to test."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "necessary conditions", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}], [{"code": "<pre>\n<code>\n #!/usr/bin/env python                                                       \n\ndef primes(ubound):\n    ubound = ubound + 1\n    a = [False] * ubound\n    p = 2\n    primes = []\n    while p &lt; ubound:\n        primes.append(p)\n        for n in range(p, ubound, p):\n            a[n] = True\n        p = p + 1\n        while p &lt; ubound and a[p]:\n            p = p + 1\n    return primes\n\nprint primes(100000000)\n\n\n$ time erastothenes.py &gt; results.txt\nreal    1m32.441s\nuser    1m14.866s\nsys     0m4.588s\n</code>\n</pre>\n", "senID": 0}, {"text": ["It's still somewhat sluggish, and it probably could be improved further; I'm no expert in Python.", "Maybe with native arrays.", "I don't know how to make one without first making a list, which is a waste of time."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(Yeah, I know I'm wasting the first two array positions.", ":p )"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT With algorithmic optimisations @DanielFisher talked about (and not wasting space):"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python                                                       \n\ndef primes(ubound):\n    size = (ubound - 3) / 2\n    a = [False] * size\n    s = 0\n    primes = []\n    while s &lt; size:\n        t = 2 * s\n        p = t + 3\n        primes.append(p)\n        print p\n        for n in range(t * (s + 3) + 3, size, p):\n            a[n] = True\n        s = s + 1\n        while s &lt; size and a[s]:\n            s = s + 1\n    return primes\n\nprimes(100000000)\n\n$ time erastothenes.py &gt; results.txt\nreal    0m36.737s\nuser    0m35.725s\nsys     0m0.864s\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You can speed up your isPrime function significantly with a change like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import count\n\ndef isPrime(n):\n  # eliminate multiples of 2 and 3.\n  if n % 2 == 0 or n % 3 == 0:\n    return False\n\n  limit = n ** 0.5\n\n  for i in count(1):\n    # all other primes take the form 6k +- 1.\n    # though not all values of k produce a prime.\n    high, low = 6*i + 1, 6*i - 1\n\n    # we'll never find a factor greater than the square\n    # root isn't composite and which would be ruled out\n    # by earlier tests.\n    if low &gt; limit:\n      return True\n\n    # if we find a factor, it's obviously not prime.\n    if n % low == 0:\n      return False\n    if n % high == 0:\n      return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["That can be further improved by caching the list of primes.", "The sieve is actually quicker (I believe) but this is straight forward and easy to work with."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Don't build up a list of divisors and then test them all.", "Test each as you find them, and skip the number as soon as you find an invalid one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Another way to phrase the problem: \"the sum of integers n not exceeding 100000000 such that there are no divisors d where n/d + d is composite\".", "We can express this much more simply in Python, by first creating a function that tests for a divisor with a composite some, and then using built-in functional-programming tools.", "This is generally a bit more efficient than iterating over the lists directly, and will also automatically implement \"early-out\" logic (i.e.", "stop testing a number as soon as we find a divisor with a composite sum)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import time\nmaximum = 100000000\n\ndef isprime(n):\n    # We can use those same tools in the prime tester...\n    return not any(n % x == 0 for x in range(2, int(n**0.5)+1))\n\ndef divisor_with_composite_sum(n, d):\n    return n % d == 0 and not isprime(d + n / d)\n\nstart = time.time()\nresult = sum(\n    n for n in range(1, maximum)\n    if not any(\n        divisor_with_composite_sum(n, d)\n        for d in range(1, int(n**0.5) + 1)\n    )\n)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now it just remains to optimize how we find the prime numbers and the divisors :)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT: Upon further thought.", "This is an Euler problem; you're supposed to have something more clever in mind than brute force."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Every number that qualifies will have each prime to the power 1 in its prime factorization.", "Proof by contradiction: suppose for some prime p, n is divisible by p^2 (or a higher power of p).", "Then p is trivially divisible by p, and n/p is divisible by p (by the assumption), so the sum is divisible by p and therefore composite.", "Further, every number that qualifies is 1 less than a prime, because 1 is always a divisor."], "childNum": 10, "tag": "p", "senID": 5, "childList": [{"text": "p", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "p^2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "p", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "p", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "p", "childNum": 0, "tag": "code", "childList": []}, {"text": "n/p", "childNum": 0, "tag": "code", "childList": []}, {"text": "p", "childNum": 0, "tag": "code", "childList": []}, {"text": "p", "childNum": 0, "tag": "code", "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So: build a list of primes up to 100000000 (see Amadan's answer for example, and see if you can apply the above techniques too ;) ).", "For each of these, subtract 1, and check if the result has a duplicated prime factor.", "If not, then you can do a more detailed test."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]