[[{"text": ["Your overall approach is sound.", "I'm pretty sure the problem lies with your make_canonical function.", "You can try printing out the hands with num_cards set to 3 or 4 and look for equivalencies that you've missed."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "make_canonical", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I found one, but there may be more:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # The inputs are equivalent and should return the same value\nprint make_canonical([8, 12 | 1]) # returns [8, 13]\nprint make_canonical([12, 8 | 1]) # returns [12, 9]\n</code>\n</pre>\n", "senID": 2}, {"text": ["For reference, below is my solution (developed prior to looking at your solution).", "I used a depth-first search instead of a breadth-first search.", "Also, instead of writing a function to transform a hand to canonical form, I wrote a function to check if a hand is canonical.", "If it's not canonical, I skip it.", "I defined rank = card % 13 and suit = card / 13.", "None of those differences are important."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import collections\n\ndef canonical(cards):\n    \"\"\"\n    Rules for a canonical hand:\n    1. The cards are in sorted order\n\n    2. The i-th suit must have at least many cards as all later suits.  If a\n       suit isn't present, it counts as having 0 cards.\n\n    3. If two suits have the same number of cards, the ranks in the first suit\n       must be lower or equal lexicographically (e.g., [1, 3] &lt;= [2, 4]).\n\n    4. Must be a valid hand (no duplicate cards)\n    \"\"\"\n\n    if sorted(cards) != cards:\n        return False\n    by_suits = collections.defaultdict(list)\n    for suit in range(0, 52, 13):\n        by_suits[suit] = [card%13 for card in cards if suit &lt;= card &lt; suit+13]\n        if len(set(by_suits[suit])) != len(by_suits[suit]):\n            return False\n    for suit in range(13, 52, 13):\n        suit1 = by_suits[suit-13]\n        suit2 = by_suits[suit]\n        if not suit2: continue\n        if len(suit1) &lt; len(suit2):\n            return False\n        if len(suit1) == len(suit2) and suit1 &gt; suit2:\n            return False\n    return True\n\ndef deal_cards(permutations, n, cards):\n    if len(cards) == n:\n        permutations.append(list(cards))\n        return\n    start = 0\n    if cards:\n        start = max(cards) + 1\n    for card in range(start, 52):\n        cards.append(card)\n        if canonical(cards):\n            deal_cards(permutations, n, cards)\n        del cards[-1]\n\ndef generate_permutations(n):\n    permutations = []\n    deal_cards(permutations, n, [])\n    return permutations\n\nfor cards in generate_permutations(5):\n    print cards\n</code>\n</pre>\n", "senID": 4}, {"text": ["It generates the correct number of permutations:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n Cashew:~/$ python2.6 /tmp/cards.py | wc\n134459\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Your problem sounded interesting, so i simple tried to implements it by just looping over all possible hands in a sorted way.", "I've not looked at your code in details, but it seems my implementation is quite different from yours.", "Guess what count of hands my script found: 160537"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "My hands are always sorted, e.g. 2 3 4 4 D", "tag": "none", "senID": 1}, {"text": "If there are 2 equal cards, the color is also sorted (colors are just called 0,1,2,3)", "tag": "none", "senID": 2}, {"text": "the first card has always color 0, the second color 0 or 1", "tag": "none", "senID": 3}, {"text": "A card can only have the color of an previous card or the next bigger number, e.g. if card 1+2 have color 0, card three can only have the colors 0 or 1", "tag": "none", "senID": 4}]}, {"text": ["Are you sure, the number on wikipedia is correct?"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n count = 0\nfor a1 in range(13):\n    c1 = 0\n    for a2 in range(a1, 13):\n        for c2 in range(2):\n            if a1==a2 and c1==c2:\n                continue\n            nc3 = 2 if c1==c2 else 3\n            for a3 in range(a2, 13):\n                for c3 in range(nc3):\n                    if (a1==a3 and c1&gt;=c3) or (a2==a3 and c2&gt;=c3):\n                        continue\n                    nc4 = nc3+1 if c3==nc3-1 else nc3\n                    for a4 in range(a3, 13):\n                        for c4 in range(nc4):\n                            if (a1==a4 and c1&gt;=c4) or (a2==a4 and c2&gt;=c4) or (a3==a4 and c3&gt;=c4):\n                                continue\n                            nc5 = nc4+1 if (c4==nc4-1 and nc4!=4) else nc4\n                            for a5 in range(a4, 13):\n                                for c5 in range(nc5):\n                                    if (a1==a5 and c1&gt;=c5) or (a2&gt;=a5 and c2&gt;=c5) or (a3==a5 and c3&gt;=c5) or (a4==a5 and c4&gt;=c5):\n                                        continue\n                                    #print([(a1,c1),(a2,c2),(a3,c3),(a4,c4),(a5,c5)])\n                                    count += 1\nprint(\"result: \",count)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["I'm not a poker player, so the details of hand precedence are beyond me.", "But it seems like the problem is that you are traversing the space of \"sets of 5 cards\" by generating sets from the deck, when you should be traversing the space of \"distinct poker hands\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The space of distinct hands will require a new grammar.", "The important thing is to capture exactly the information that is relevant to hand precedence.", "For example, there are only 4 hands that are royal flushes, so those hands can be described as the symbol \"RF\" plus a suit designator, like \"RFC\" for royal flush in clubs.", "A 10-high heart flush could be \"FLH10\" (not sure if there are other precedence characteristics of flushes, but I think that's all you need to know).", "A hand that is \"2C 2S AH 10C 5D\" would be a longer expression, something like \"PR2 A 10 5\" if I undestand your initial problem statement. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Once you have defined the grammar of distinct hands, you can express it as regular expressions and that will tell you how to generate the entire space of distinct hands.", "Sounds like fun!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could simply give all hands a canonical ordering of values (A to K), then assign abstract suit letters according to their order of first appearance in that order."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Example:  JH 4C QD 9C 3D would convert to 3a 4b 9b Jc Qa."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Generation should work best as dynamic programming:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "start with a set of a single hand that is empty,", "tag": "none", "senID": 3}, {"text": "make a new set:\n", "tag": "none", "senID": 4}]}], [{"text": ["Look at Pokersource.", "The problem gets even worse when you're considering completing hands given some cards already drawn."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Pokersource", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.pokersource.info/"}]}, {"text": ["The guy behind PokerStove did a great job in this direction, but the source is disclosed."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Generating equivalence classes for 5 card hands is not an easy task.", "When I need this I usually use the http://www.vpgenius.com/ webpage.", "At http://www.vpgenius.com/video-poker/games/ you can choose which variety of poker game you need, and in the \"Programming tab\" you have an section on \"Unique Suit Patterns\".", "So just copying that and loading into program might be easier than trying to generate your own."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "http://www.vpgenius.com/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.vpgenius.com/"}, {"text": "http://www.vpgenius.com/video-poker/games/", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.vpgenius.com/video-poker/games/"}]}], [{"text": ["Initial input:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n H 0 0 0 0 0 0 0 0 0 0 0 0 0\nC 1 0 0 0 0 0 0 0 0 0 0 0 0\nD 1 0 0 0 0 0 0 0 0 0 0 0 0\nS 1 1 0 0 0 0 0 0 0 0 0 0 0\n+ A 2 3 4 5 6 7 8 9 T J Q K\n</code>\n</pre>\n", "senID": 1}, {"text": ["Step 1: for each rank greater than or equal the highest rank used, set all suits in that rank to 0.  you can get away with only checking higher cards because lower combinations will be checked by the lower starting points."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n H 0 0 0 0 0 0 0 0 0 0 0 0 0\nC 1 0 0 0 0 0 0 0 0 0 0 0 0\nD 1 0 0 0 0 0 0 0 0 0 0 0 0\nS 1 0 0 0 0 0 0 0 0 0 0 0 0\n+ A 2 3 4 5 6 7 8 9 T J Q K\n</code>\n</pre>\n", "senID": 3}, {"text": ["Step 2: Collapse to distinct rows"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n 0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 0 0 0 0 0 0 0\nA 2 3 4 5 6 7 8 9 T J Q K\n</code>\n</pre>\n", "senID": 5}, {"text": ["Step 3: Climb back up determining first suit that match each distinct row, and choose the suits which match the distinct rows (identified by a *)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n H 0 * 0 0 0 0 0 0 0 0 0 0 0\nC 1 0 0 0 0 0 0 0 0 0 0 0 0\nD 1 * 0 0 0 0 0 0 0 0 0 0 0\nS 1 1 0 0 0 0 0 0 0 0 0 0 0\n+ A 2 3 4 5 6 7 8 9 T J Q K\n</code>\n</pre>\n", "senID": 7}, {"text": ["Now showing the repeat for rank 3"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n H 0 0 0 0 0 0 0 0 0 0 0 0 0\nC 1 0 0 0 0 0 0 0 0 0 0 0 0\nD 1 0 0 0 0 0 0 0 0 0 0 0 0\nS 1 1 0 0 0 0 0 0 0 0 0 0 0\n+ A 2 3 4 5 6 7 8 9 T J Q K\n\n0 0 0 0 0 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 0 0 0 0 0 0 0\n1 1 0 0 0 0 0 0 0 0 0 0 0\nA 2 3 4 5 6 7 8 9 T J Q K\n\nH 0 0 * 0 0 0 0 0 0 0 0 0 0\nC 1 0 0 0 0 0 0 0 0 0 0 0 0\nD 1 0 * 0 0 0 0 0 0 0 0 0 0\nS 1 1 * 0 0 0 0 0 0 0 0 0 0\n+ A 2 3 4 5 6 7 8 9 T J Q K\n</code>\n</pre>\n", "senID": 9}, {"text": ["Step 4: Once there are 5 cells set to 1, increment the total possible suit abstracted hands count by 1 and recurse up."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["The total number of suit abstracted hands possible is 134,459.", "This is the code I wrote to test it out:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ConsoleApplication20\n{\n \u00a0 \u00a0struct Card\n \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0public int Suit { get; set; }\n \u00a0 \u00a0 \u00a0 \u00a0public int Rank { get; set; }\n \u00a0 \u00a0}\n\u00a0\u00a0 \u00a0\n \u00a0 \u00a0class Program\n \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0static int ranks = 13;\n \u00a0 \u00a0 \u00a0 \u00a0static int suits = 4;\n \u00a0 \u00a0 \u00a0 \u00a0static int cardsInHand = 5;\n\n \u00a0 \u00a0 \u00a0 \u00a0static void Main(string[] args)\n \u00a0 \u00a0 \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0List&lt;Card&gt; cards = new List&lt;Card&gt;();\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0//cards.Add(new Card() { Rank = 0, Suit = 0 });\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int numHands = GenerateAllHands(cards);\n\u00a0\u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0Console.WriteLine(numHands);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0Console.ReadLine();\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0static int GenerateAllHands(List&lt;Card&gt; cards)\n \u00a0 \u00a0 \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (cards.Count == cardsInHand) return 1;\n\u00a0\u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0List&lt;Card&gt; possibleNextCards = GetPossibleNextCards(cards);\n\u00a0\u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int numSubHands = 0;\n\u00a0\u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0foreach (Card card in possibleNextCards)\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0List&lt;Card&gt; possibleNextHand = cards.ToList(); // copy list\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0possibleNextHand.Add(card);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0numSubHands += GenerateAllHands(possibleNextHand);\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n\u00a0\u00a0 \u00a0\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return numSubHands;\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0}\n\u00a0\u00a0 \u00a0\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0static List&lt;Card&gt; GetPossibleNextCards(List&lt;Card&gt; hand)\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0{\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int maxRank = hand.Max(x =&gt; x.Rank);\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0List&lt;Card&gt; result = new List&lt;Card&gt;();\n\u00a0\u00a0 \u00a0\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// only use ranks &gt;= max\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int rank = maxRank; rank &lt; ranks; rank++)\n\u00a0  \u00a0 \u00a0 \u00a0 \u00a0 \u00a0{\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0List&lt;int&gt; suits = GetPossibleSuitsForRank(hand, rank);\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0var possibleNextCards = suits.Select(x =&gt; new Card { Rank = rank, Suit = x });\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0result.AddRange(possibleNextCards);\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n\u00a0\u00a0 \u00a0\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return result;\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0}\n\u00a0\u00a0 \u00a0\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0static List&lt;int&gt; GetPossibleSuitsForRank(List&lt;Card&gt; hand, int rank)\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0{\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int maxSuit = hand.Max(x =&gt; x.Suit);\n\u00a0\u00a0 \u00a0\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// select number of ranks of different suits\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int[][] card = GetArray(hand, rank);\n\u00a0\u00a0 \u00a0\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int i = 0; i &lt; suits; i++)\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0{\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0card[i][rank] = 0;\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n\u00a0\u00a0 \u00a0\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int[][] handRep = GetArray(hand, rank);\n\u00a0\u00a0 \u00a0\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0// get distinct rank sets, then find which ranks they correspond to\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0IEnumerable&lt;int[]&gt; distincts = card.Distinct(new IntArrayComparer());\n\u00a0\u00a0 \u00a0\n\u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0List&lt;int&gt; possibleSuits = new List&lt;int&gt;();\n\u00a0\u00a0 \u00a0\n\u00a0  \u00a0 \u00a0 \u00a0 \u00a0 \u00a0foreach (int[] row in distincts)\n\u00a0  \u00a0 \u00a0 \u00a0 \u00a0 \u00a0{\n\u00a0 \u00a0  \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int i = 0; i &lt; suits; i++)\n\u00a0 \u00a0  \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (IntArrayComparer.Compare(row, handRep[i]))\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0possibleSuits.Add(i);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0break;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n\u00a0\u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return possibleSuits;\n \u00a0 \u00a0 \u00a0 \u00a0}\n\u00a0\u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0class IntArrayComparer : IEqualityComparer&lt;int[]&gt;\n \u00a0 \u00a0 \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0#region IEqualityComparer&lt;int[]&gt; Members\n\u00a0\u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0public static bool Compare(int[] x, int[] y)\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int i = 0; i &lt; x.Length; i++)\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0if (x[i] != y[i]) return false;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n\u00a0\u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return true;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n\u00a0\u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0public bool Equals(int[] x, int[] y)\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return Compare(x, y);\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n\u00a0\u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0public int GetHashCode(int[] obj)\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return 0;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0#endregion\n \u00a0 \u00a0 \u00a0 \u00a0}\n\n \u00a0 \u00a0 \u00a0 \u00a0static int[][] GetArray(List&lt;Card&gt; hand, int rank)\n \u00a0 \u00a0 \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0int[][] cards = new int[suits][];\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0for (int i = 0; i &lt; suits; i++)\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0cards[i] = new int[ranks];\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0foreach (Card card in hand)\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0{\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0cards[card.Suit][card.Rank] = 1;\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}\n\u00a0\u00a0 \u00a0\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0return cards;\n \u00a0 \u00a0 \u00a0 \u00a0}\n \u00a0 \u00a0}\n}\n</code>\n</pre>\n", "senID": 12}, {"text": ["Hopefully it is broken up enough to be easily understandable."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["Take a look here:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://specialk-coding.blogspot.com/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://specialk-coding.blogspot.com/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://specialk-coding.blogspot.com/"}]}, {"text": ["http://code.google.com/p/specialkpokereval/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://code.google.com/p/specialkpokereval/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/specialkpokereval/"}]}, {"text": ["These regard a 5-card hand (and a 7-card hand) as an integer, the sum the individual cards, which is independent of the suit.", "Exactly what you need."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["This is part of a scheme for quickly ranking 7- and 5-card hands, written in Objective-C and Java."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If you are just interested in hands that result in different hand rankings, there are actually only 7462 distinct hand classes that have to be considered (see Wikipedia)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Wikipedia", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Poker_hand#General_rules"}]}, {"text": ["By creating a table with an example for each class and their accompanying multiplicity you can check all relevant hands weighted with their probability quite fast.", "That is, assuming that no cards are known and therefore fixed beforehand already."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]