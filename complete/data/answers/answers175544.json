[[{"text": ["The basic Algorithm"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["I'd sort the players by their rank, as the high ranked ones always push away the low ranked ones.", "Then you start with the player with the highest rank, give him what he asked for (if he really is the highest, he will always win, thus you can as well give him whatever he requested).", "Then I would start with the second highest one.", "If he requested something already taken by the highest, try to find a slot nearby and assign this slot to him.", "Now comes the third highest one.", "If he requested something already taken by the highest one, move him to a slot nearby.", "If this slot is already taken by the second highest one, move him to a slot some further away.", "Continue with all other players."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If multiple players can have the same rank, you may need to implement some \"fairness\".", "All players with equal rank will have a random order to each other if you sort them e.g.", "using QuickSort.", "You can get some some fairness, if you don't do it player for player, but rank for rank.", "You start with highest rank and the first player of this rank.", "Process his first request.", "However, before you process his second request, process the first request of the next player having highest rank and then of the third player having highest rank.", "The algorithm is the same as above, but assuming you have 10 players and player 1-4 are highest rank and players 5-7 are low and players 8-10 are very low, and every player made 3 requests, you process them as"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Player 1 - Request 1\nPlayer 2 - Request 1\nPlayer 3 - Request 1\nPlayer 4 - Request 1\nPlayer 1 - Request 2\nPlayer 2 - Request 2\n:\n</code>\n</pre>\n", "senID": 3}, {"text": ["That way you have some fairness.", "You could also choose randomly within a ranking class each time, this could also provide some fairness."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You could implement fairness even across ranks.", "E.g.", "if you have 4 ranks, you could say"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n Rank 1 - 50%\nRank 2 - 25%\nRank 3 - 12,5%\nRank 4 - 6,25%\n</code>\n</pre>\n", "senID": 6}, {"text": ["(Just example values, you may use a different key than always multiplying by 0.5, e.g.", "multiplying by 0.8, causing the numbers to decrease slower)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Now you can say, you start processing with Rank 1, however once 50% of all Rank 1 requests have been fulfilled, you move on to Rank 2 and make sure 25% of their requests are fulfilled and so on.", "This way even a Rank 4 user can win over a Rank 1 user, somewhat defeating the initial algorithm, however you offer some fairness.", "Even a Rank 4 player can sometimes gets his request, he won't \"run dry\".", "Otherwise a Rank 1 player scheduling every request on the same time as a Rank 4 player will make sure a Rank 4 player has no chance to ever get a single request.", "This way there is at least a small chance he may get one."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["After you made sure everyone had their minimal percentage processed (and the higher the rank, the more this is), you go back to top, starting with Rank 1 again and process the rest of their requests, then the rest of the Rank 2 requests and so on."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Last but not least: You may want to define a maximum slot offset.", "If a slot is taken, the application should search for the nearest slot still free.", "However, what if this nearest slot is very far away?", "If I request a slot Monday at 4 PM and the application finds the next free one to be Wednesday on 9 AM, that's not really helpful for me, is it?", "I might have no time on Wednesday at all.", "So you may limit slot search to the same day and saying the slot might be at most 3 hours off.", "If no slot is found within that range, cancel the request.", "In that case you need to inform the player \"We are sorry, but we could not find any nearby slot for you; please request a slot on another date/time and we will see if we can find a suitable slot there for you\"."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Last but not least:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["This is an NP-complete problem, I think, so it'll be impossible to have a very fast algorithm for any large data sets. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There's also the problem where you might have a schedule that is impossible to make.", "Given that that's not the case, something like this pseudocode is probably your best bet:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n sort players by priority, highest to lowest\nstart with empty schedule\nfor player in players:\n    for timeslot in player.preferences():\n        if timeslot is free:\n            schedule.fillslot(timeslot, player)\n            break\n    else:\n        #if we get here, it means this player couldn't be accomodated at all.\n        #you'll have to go through the slots that were filled and move another (higher-priority) player's time slot\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You are describing a matching problem.", "Possible references are the Stony Brook algorithm repository and Algorithm Design by Kleinberg and Tardos.", "If the number of players is equal to the number of courts you can reach a stable matching - The Stable Marriage Problem.", "Other formulations become harder."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "the Stony Brook algorithm repository", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.cs.sunysb.edu/~algorith/files/matching.shtml"}, {"text": "Algorithm Design by Kleinberg and Tardos", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://rads.stackoverflow.com/amzn/click/0321295358"}, {"text": "The Stable Marriage Problem", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Stable_marriage_problem"}]}], [{"text": ["There are several questions I'd ask before answering this queston:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "what happens if there is a conflict, i.e. a worse player books first, then a better player books the same court? Who wins? what happens for the loser?", "tag": "none", "senID": 1}, {"text": "do you let the best players play as long as the match runs, or do you have fixed time slots?", "tag": "none", "senID": 2}, {"text": "how often is the scheduling run - is it run interactively - so potentially someone could be told they can play, only to be told they can't; or is it run in a more batch manner - you put in requests, then get told later if you can have your slot. Or do users ", "tag": "none", "senID": 3}]}, {"text": ["As an aside, you can make it slightly less complex by re-writing the times as integer indexes (so you're dealing with integers rather than times)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I would advise using a scoring algorithm.", "Basically construct a formula that pulls all the values you described into a single number.", "Who ever has the highest final score wins that slot.", "For example a simple formula might be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n FinalScore = ( PlayerRanking * N1 ) + ( PlayerPreference * N2 )\n</code>\n</pre>\n", "senID": 1}, {"text": ["Where N1, N2 are weights to control the formula."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This will allow you to get good (not perfect) results very quickly.", "We use this approach on a much more complex system with very good results."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You can add more variety to this by adding in factors for how many times the player has won or lost slots, or (as someone suggested) how much the player paid."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Also, you can use multiple passes to assign slots in the day.", "Use one strategy where it goes chronologically, one reverse chronologically, one that does the morning first, one that does the afternoon first, etc.", "Then sum the scores of the players that got the spots, and then you can decide strategy provided the best results."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Basically, you have the advantage that players have priorities; therefore, you sort the players by descending priority, and then you start allocating slots to them.", "The first gets their preferred slot, then the next takes his preferred among the free ones and so on.", "It's a O(N) algorithm."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I think you should use genetic algorithm because:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "It is best suited for large problem instances.", "tag": "none", "senID": 1}, {"text": "It yields reduced time complexity on the price of inaccurate answer(Not the ultimate best)", "tag": "none", "senID": 2}, {"text": "You can specify constraints &amp; preferences easily by adjusting fitness punishments for not met ones.", "tag": "none", "senID": 3}, {"text": "You can specify time limit for program execution.", "tag": "none", "senID": 4}, {"text": ["The quality of solution depends on how much time you intend to spend solving the program.."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]}, {"text": ["Also take a look at :a similar question and another one"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "a similar question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2746309/best-fit-scheduling-algorithm/2749869#2749869"}, {"href": "http://stackoverflow.com/questions/573670/which-algorithm-for-assigning-shifts-discrete-optimization-problem/4594818#4594818", "text": "another one", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Money.", "Allocate time slots based on who pays the most.", "In case of a draw don't let any of them have the slot."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]