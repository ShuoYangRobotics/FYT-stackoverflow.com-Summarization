[[{"text": ["Nucular\nhas full text search, but it doesn't support misspelled matches\nout-of-the box.", "You could try adding an additional field to each entry\nwhich indexes the\nSOUNDEX translation of the terms and then search using the soundex translation\nof the user input.", "I really don't know how well this would work..."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Nucular", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://nucular.sourceforge.net"}, {"text": "SOUNDEX", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/52213/"}]}, {"text": ["Take a look at advas http://advas.sourceforge.net/news.php which has a nice demo comparing various soundex-alike methods:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://advas.sourceforge.net/news.php", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://advas.sourceforge.net/news.php"}]}, {"code": "<pre>\n<code>\n advas/examples Aaron$ python phonetic_algorithms.py \n                    soundex       metaphone           nyiis      caverphone \n====================================================================================================\n schmidt :             S253           sxmtt          sssnad      SKMT111111\n  schmid :             S253            sxmt          sssnad      SKMT111111\n schmitt :             S253            sxmt         sssnatt      SKMT111111\n   smith :             S530            sm0h           snatt      SMT1111111\n  smythe :             S530           smy0h           snatt      SMT1111111\n schmied :             S253            sxmt         sssnaad      SKMT111111\n   mayer :             M600             myr           naaar      MA11111111\n   meier :             M600              mr           naaar      MA11111111\n....\n</code>\n</pre>\n", "senID": 2}, {"text": ["I don't know if any of them is good for your unnamed language..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You will get too many false positives with the SOUNDEX implementation.", "There are only 26,000 (at most) possible SOUNDEX codes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Though the Metaphone algorithim was designed for English surnames, it works pretty well for misspellings; I used it once in a branch locator and it was quite successful. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Add a field with the Metaphone translation and match against it if no exact match is found.", "You will still get false positives, but fewer that with other algorithims."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The usual way of computing the edit-distance between two strings is a rather expensive algorithm (if I remember correctly, its time complexity is quadratic).", "Maybe if you used a different string similarity metric then your problem would go away."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One of my favorite methods for fuzzy string matching is [trigrams matching].", "Comparing two strings using this method has a linear time complexity, which is much better than the mentioned edit-distance.", "You can find my Python implementation on [Github].", "There's also a PostgreSQL [contrib module] exactly for that.", "It shouldn't be too difficult to adapt it to work with SQLite3."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Apparently the only way to make fuzzy comparisons fast is to do less of them ;)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Instead of writing another n-gram search or improving the one in Whoosh we now keep a word index, retrieve all entries that have at least one (correctly spelled) word in common with the query, and use difflib to rank those.", "Works well enough in this case."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Go to www.matchlogics.com. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Sybase SQL Anywhere has a free Web edition/Developer Edition and comes with full text indexing/search and a FUZZY operator (and some implementation constraints). "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Sybase SQL Anywhere", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sybase.com/products/databasemanagement/sqlanywhere"}]}, {"text": ["To quote from the documentation:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n Specifying 'FUZZY \"500 main street\"' is equivalent to \n'500 OR mai OR ain OR str OR tre OR ree OR eet'.\n</code>\n</pre>\n", "senID": 2}, {"text": ["An other approach would be to use scoring on full-text searches."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["sqlite3 supports python callback functions.", "Matthew Barnett's regex (http://code.google.com/p/mrab-regex-hg/) now supports approximate matching."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So, like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n try:\n    import regex\nexcept ImportError:\n    sys.stderr.write(\"Can't import mrab-regex; see http://pypi.python.org/pypi/regex\\n\")\n    sys.exit(1)\n\ndef _sqlite3_regex(expr, item):\n    return (not (not regex.search(expr, item)))\n\ndef main():\n    ...\n    database = sqlite3.connect(dbfile)\n    database.create_function(\"regexp\", 2, _sqlite3_regex)\n    pattern = '(?:%s){e&lt;=%d}' % (queriedname, distance)\n    print [x for x in database.cursor().execute(\n         \"SELECT * FROM products WHERE (productname regexp '%s')\" % pattern)]\n</code>\n</pre>\n", "senID": 2}]]