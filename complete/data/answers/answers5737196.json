[[{"code": "<pre>\n<code>\n for x in iter(int, 1): pass\n</code>\n</pre>\n", "senID": 0}, {"tag": "ul", "num": 2, "lis": [{"text": "Two-argument ", "tag": "none", "senID": 1}, {"text": ["int()"], "childNum": 0, "tag": "code", "senID": 2, "childList": []}]}, {"text": ["Therefore, iter(int, 1) is an infinite iterator.", "There are obviously a huge number of variations on this particular theme (especially once you add lambda into the mix).", "One variant of particular note is iter(f, object()), as using a freshly created object as the sentinel value almost guarantees an infinite iterator regardless of the callable used as the first argument."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "iter(int, 1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "iter(f, object())", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["None that doesn't internally use another infinite iterator defined as a class/function/generator (not -expression, a function with yield).", "A generator expression always draws from anoter iterable and does nothing but filtering and mapping its items.", "You can't go from finite items to infinite ones with only map and filter, you need while (or a for that doesn't terminate, which is exactly what we can't have using only for and finite iterators)."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "filter", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "while", "childNum": 0, "tag": "code", "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Trivia: PEP 3142 is superficially similar, but upon closer inspection it seems that it still requires the for clause (so no (0 while True) for you), i.e.", "only provides a shortcut for itertools.takewhile."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "PEP 3142", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3142/"}, {"text": "for", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "(0 while True)", "childNum": 0, "tag": "code", "childList": []}, {"text": "itertools.takewhile", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["itertools provides three infinite generators:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": ["count : 1, 2, 3, 4, ..."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "count", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["cycle(p): p[0], p[1], ..., p[-1], p[0], ..."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "cycle(p)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["repeat(x): x, x, x, x, ..."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "repeat(x)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}, {"text": ["I don't know of any others in the standard library. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Since you asked for a one-liner:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n __import__(\"itertools\").count()\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Maybe you could use decorators like this for example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def generator(first):\n    def wrap(func):\n        def seq():\n            x = first\n            while True:\n                yield x\n                x = func(x)\n        return seq\n    return wrap\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage (1):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n @generator(0)\ndef blah(x):\n    return x + 1\n\nfor i in blah():\n    print i\n</code>\n</pre>\n", "senID": 3}, {"text": ["Usage (2)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n for i in generator(0)(lambda x: x + 1)():\n    print i\n</code>\n</pre>\n", "senID": 5}, {"text": ["I think it could be further improved to get rid of those ugly ().", "However it depends on the complexity of the sequence that you wish to be able to create.", "Generally speaking if your sequence can be expressed using functions, than all the complexity and syntactic sugar of generators can be hidden inside a decorator or a decorator-like function."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Your OS may provide something that can be used as an infinite generator.", "Eg on linux"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i in (0 for x in open('/dev/urandom')):\n    print i\n</code>\n</pre>\n", "senID": 1}, {"text": ["obviously this is not as efficient as "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for i in __import__('itertools').repeat(0)\n    print i\n</code>\n</pre>\n", "senID": 3}], [{"text": ["you can iterate over a callable returning a constant always different than iter()'s sentinel"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n g1=iter(lambda:0,1)\n</code>\n</pre>\n", "senID": 1}]]