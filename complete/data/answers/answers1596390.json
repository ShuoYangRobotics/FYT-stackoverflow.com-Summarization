[[{"text": ["list(set(foo)) if you are using Python 2.5 or greater, but that doesn't maintain order."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "list(", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/stdtypes.html#set", "text": "set", "childNum": 1, "tag": "a", "childList": [{"text": "set", "tag": "code"}]}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}, {"text": "(foo))", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Cast foo to a set, if you don't care about element order. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "set", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#set"}]}], [{"text": ["If you care about order a readable way is the following"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def filter_unique(a_list):\n    characters = set()\n    result = []\n    for c in a_list:\n        if not c in characters:\n            characters.add(c)\n            result.append(c)\n    return result\n</code>\n</pre>\n", "senID": 1}, {"text": ["Depending on your requirements of speed, maintanability, space consumption, you could find the above unfitting.", "In that case, specify your requirements and we can try to do better :-)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; bar = []\n&gt;&gt;&gt; for i in foo:\n    if i not in bar:\n    \tbar.append(i)\n\n&gt;&gt;&gt; bar\n['a', 'b', 'c', 'd']\n</code>\n</pre>\n", "senID": 0}, {"text": ["this would be the most straightforward way of removing duplicates from the list and preserving the order as much as possible (even though \"order\" here is inherently wrong concept)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Since there isn't an order-preserving answer with a list comprehension, I propose the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; temp = set()\n&gt;&gt;&gt; [c for c in foo if c not in temp and (temp.add(c) or True)]\n['a', 'b', 'c', 'd']\n</code>\n</pre>\n", "senID": 1}, {"text": ["which could also be written as"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; temp = set()\n&gt;&gt;&gt; filter(lambda c: c not in temp and (temp.add(c) or True), foo)\n['a', 'b', 'c', 'd']\n</code>\n</pre>\n", "senID": 3}, {"text": ["Depending on how many elements are in foo, you might have faster results through repeated hash lookups instead of repeated iterative searches through a temporary list."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["c not in temp verifies that temp does not have an item c; and the or True part forces c to be emitted to the output list when the item is added to the set."], "childNum": 5, "tag": "p", "senID": 5, "childList": [{"text": "c not in temp", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "temp", "childNum": 0, "tag": "code", "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}, {"text": "or True", "childNum": 0, "tag": "code", "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If you write a function to do this i would use a generator, it just wants to be used in this case."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\ndef unique(iterable):\n    yielded = set()\n    for item in iterable:\n        if item not in yielded:\n            yield item\n            yielded.add(item)\n</pre>\n", "senID": 1}], [{"text": ["Inspired by Francesco's answer, rather than making our own filter()-type function, let's make the builtin do some work for us:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Francesco's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1596390/filtering-lists-in-python/1596435#1596435"}, {"text": "filter()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def unique(a, s=set()):\n    if a not in s:\n        s.add(a)\n        return True\n    return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n uniq = filter(unique, orig)\n</code>\n</pre>\n", "senID": 3}, {"text": ["This may or may not perform faster or slower than an answer that implements all of the work in pure Python.", "Benchmark and see.", "Of course, this only works once, but it demonstrates the concept.", "The ideal solution is, of course, to use a class:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class Unique(set):\n    def __call__(self, a):\n        if a not in self:\n            self.add(a)\n            return True\n        return False\n</code>\n</pre>\n", "senID": 5}, {"text": ["Now we can use it as much as we want:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n uniq = filter(Unique(), orig)\n</code>\n</pre>\n", "senID": 7}, {"text": ["Once again, we may (or may not) have thrown performance out the window - the gains of using a built-in function may be offset by the overhead of a class.", "I just though it was an interesting idea."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["This is what you want if you need a sorted list at the end:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; foo = ['a','b','c','a','b','d','a','d']\n&gt;&gt;&gt; bar = sorted(set(foo))\n&gt;&gt;&gt; bar\n['a', 'b', 'c', 'd']\n</code>\n</pre>\n", "senID": 1}]]