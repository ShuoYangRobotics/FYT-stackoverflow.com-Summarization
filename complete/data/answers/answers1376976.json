[[{"text": ["1., sure"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["2., see e.g.", "here"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["3., yep, same basic concept as 2"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["4., nah, C# is flexible enough to allow you to port your architecture over"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Also consider studying this book as the best intro to .NET for Python programmers AND vice versa (I'm biased, having been a tech editor and being a friend of the author, but I think this is objectively defensible;-)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "this book", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.manning.com/foord/"}]}], [], [{"text": ["Sorry this is not a specific answer, but could you use IronPython to convert your scripts to run under the CLR and then step to C#?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you really want to learn C#, you should demand only references and not full answers, like this one (RegEx class), but I'm sure you can find much more information with a quick Google search too."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this one (RegEx class)", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://msdn.microsoft.com/en-us/library/30wbz966%28VS.71%29.aspx"}]}], [{"text": ["What you're looking for sounds do-able.", "Of course you'll want to look at System.Text.RegularExpressions, specifically the Regex type there.  "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "System.Text.RegularExpressions", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Regex", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Additionally, I'm really fond of the iterator pattern for reading lines from a file:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n public static IEnumerable&lt;string&gt; ReadLines(string path)\n{\n    using(var sr = new StreamReader(path))\n    {\n       string line;\n       while ( (line = sr.ReadLine()) != null)\n       {\n           yield return line;\n       }\n    }\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["You start with that base code (which you can re-use almost everywhere) and call it in this method:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n public static IEnumerable&lt;Record&gt; ReadRecords(string path)\n{\n    IEnumerable&lt;Regex&gt; expresssions = new List&lt;Regex&gt;\n    {\n        new Regex( @\"No.(?P&lt;Number&gt;[\\d]{9}) +((?P&lt;Date&gt;[\\d]{2}/[\\d]{2}/[\\d]{4}) +)?(?P&lt;Code&gt;.*)\" ),\n        new Regex( @\"NCL\\([\\d]{1}\\) (?P&lt;Ncl&gt;[\\d]{2})( (?P&lt;Especification&gt;\"), \n        new Regex( @\"C.N.P.J./C.I.C./N\u00baINPI : (?P&lt;Document&gt;.*)\")\n    };\n\n    foreach ( MatchCollection matches \n        in ReadLines(path)\n          .Select(s =&gt; expressions.First(e =&gt; e.IsMatch(s)).Matches(s)))\n          .Where(m =&gt; m.Count &gt; 0) \n    )                       \n    {\n        yield return Record.FromExpressionMatches(matches);\n    }\n}\n</code>\n</pre>\n", "senID": 4}, {"text": ["Finish it up by adding a static factory method to your Record class that accepts a MatchCollection parameter.", "The one thing it looks like you're missing here is that you expect to hit each of the expressions once before completing a single record.", "That will work a little differently.", "But hopefully this gives you enough to get you really going."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"code": "<pre>\n<code>\n dictionary&lt;string,string&gt; dic_test = new dictionary&lt;string,string&gt;();\n\ndic_test.add(key,value);\n</code>\n</pre>\n", "senID": 0}]]