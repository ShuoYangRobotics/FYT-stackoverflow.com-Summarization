[[{"text": ["There is an easy way to make python properties from methods while using swig.", "Suppose one has a C++ code Example.h:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["C++ header"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "C++ header", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Example{\n    public:\n      void SetX(int x);\n      int  GetX() const;\n    };\n</code>\n</pre>\n", "senID": 2}, {"text": ["The trick is in the swig interface.", "We add some \"swiggy\" inline python code (with %pythoncode) that will be inserted inside a body of a resulting python class (in the auto-generated python code)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Swig wrapping Example.i"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Swig wrapping Example.i", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n %module example\n%{\n     #include \"example.h\"\n%}\n\nclass Example{\n    public:\n      void SetX(int x);\n      int  GetX() const;\n\n      %pythoncode %{\n         __swig_getmethods__[\"x\"] = GetX\n         __swig_setmethods__[\"x\"] = SetX\n         if _newclass: x = property(GetX, SetX)\n      %}\n    };\n</code>\n</pre>\n", "senID": 5}, {"text": ["Check the python code:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["python test code"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "python test code", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import example\n\ntest = example.Example()\ntest.x = 5\nprint \"Ha ha ha! It works! X = \", repr(test.x)\n</code>\n</pre>\n", "senID": 8}, {"text": ["That is it!"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Make it simplier!"], "childNum": 0, "tag": "h2", "senID": 10, "childList": []}, {"text": ["There is no need to rewrite a class definition.", "Thanks to Joshua advice, one could use %extend ClassName { }  - SWIG directive. "], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Swig wrapping Example.i"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "Swig wrapping Example.i", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n %module example\n%{\n     #include \"example.h\"\n%}\n\n%extend Example{\n      %pythoncode %{\n         __swig_getmethods__[\"x\"] = GetX\n         __swig_setmethods__[\"x\"] = SetX\n         if _newclass: x = property(GetX, SetX)\n      %}\n    };\n</code>\n</pre>\n", "senID": 13}, {"text": ["Hiding setter and getter functions"], "childNum": 0, "tag": "h2", "senID": 14, "childList": []}, {"text": ["As one may see in the example, the wrapping methods test.GetX() and test.SetX() are still in place after conversion.", "One can hide them by:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["a) Rename functions by unsing %rename to make property methods \"private\" for python.", "One can do it just in the a SWIG interface .i\nExample.i"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n ...\nclass Example{\n   %rename(_SetX) SetX(int);\n   %rename(_GetX) GetX();\n...\n</code>\n</pre>\n", "senID": 17}, {"text": ["or %rename may be placed somewhere else to not to brake the possibility to use the .i file to convert this class to other languages. "], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["b) or one can play with %feature(\"shadow\")"], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["Why is it so?"], "childNum": 0, "tag": "h2", "senID": 20, "childList": []}, {"text": ["Why do we have to use such things to convert methods to a property by using SWIG?", "As it was said, SWIG selfishly overrides _setattr_, so one have to use _swig_getmethods_ and          _swig_setmethods_ to register functions and stay in the swig way. "], "childNum": 4, "tag": "p", "senID": 21, "childList": [{"text": "_setattr_", "childNum": 1, "tag": "strong", "pos": 1, "childList": [{"text": "setattr", "tag": "em"}]}, {"text": "setattr", "childNum": 0, "tag": "em", "childList": []}, {"text": "_swig_getmethods_", "childNum": 0, "tag": "strong", "childList": []}, {"text": "_swig_setmethods_", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Why may one prefer this way?"], "childNum": 0, "tag": "h2", "senID": 22, "childList": []}, {"text": ["The methods listed above, especially with PropertyVoodoo are...", "It is like burning the house to fry an egg.", "Also it breaks the classes layout since one have to have inherited classes to make python properties from C++ methods.", "I mean if Cow returns Milk and the inherited class is MilkWithProperties(Milk), how to make Cow to produce MilkWithProperties."], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"text": ["This approach allows one to:"], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"text": ["Update \nIn a newer version SWIG abandoned _swig_property so just use property.", "It works with old version of swig the same.", "I've changed the post. "], "childNum": 3, "tag": "p", "senID": 25, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "_swig_property", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "property", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}], [{"text": ["Ooh, this is tricky (and fun).", "SWIG doesn't recognize this as an opportunity to generate @property: I imagine it'd be all too easy to slip up and recognize lots of false positives if it weren't done really carefully.", "However, since SWIG won't do it in generating C++, it's still entirely possible to do this in Python using a small metaclass."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "doesn't", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["So, below, let's say we have a Math class that lets us set and get an integer variable named \"pi\".", "Then we can use this code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["example.h"], "childNum": 0, "tag": "h2", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n #ifndef EXAMPLE_H\n#define EXAMPLE_H\n\nclass Math {\n public:\n    int pi() const {\n        return this-&gt;_pi;\n    }\n\n    void pi(int pi) {\n        this-&gt;_pi = pi;\n    }\n\n private:\n    int _pi;\n};\n\n#endif\n</code>\n</pre>\n", "senID": 3}, {"text": ["example.i"], "childNum": 0, "tag": "h2", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n %module example\n\n%{\n    #define SWIG_FILE_WITH_INIT\n    #include \"example.h\"\n%}\n\n[essentially example.h repeated again]\n</code>\n</pre>\n", "senID": 5}, {"text": ["example.cpp"], "childNum": 0, "tag": "h2", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n #include \"example.h\"\n</code>\n</pre>\n", "senID": 7}, {"text": ["util.py"], "childNum": 0, "tag": "h2", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n class PropertyVoodoo(type):\n    \"\"\"A metaclass. Initializes when the *class* is initialized, not\n    the object. Therefore, we are free to muck around the class\n    methods and, specifically, descriptors.\"\"\"\n\n    def __init__(cls, *a):\n        # OK, so the list of C++ properties using the style described\n        # in the OP is stored in a __properties__ magic variable on\n        # the class.\n        for prop in cls.__properties__:\n\n            # Get accessor.\n            def fget(self):\n                # Get the SWIG class using super. We have to use super\n                # because the only information we're working off of is\n                # the class object itself (cls). This is not the most\n                # robust way of doing things but works when the SWIG\n                # class is the only superclass.\n                s = super(cls, self)\n\n                # Now get the C++ method and call its operator().\n                return getattr(s, prop)()\n\n            # Set accessor.\n            def fset(self, value):\n                # Same as above.\n                s = super(cls, self)\n\n                # Call its overloaded operator(int value) to set it.\n                return getattr(s, prop)(value)\n\n            # Properties in Python are descriptors, which are in turn\n            # static variables on the class. So, here we create the\n            # static variable and set it to the property.\n            setattr(cls, prop, property(fget=fget, fset=fset))\n\n        # type() needs the additional arguments we didn't use to do\n        # inheritance. (Parent classes are passed in as arguments as\n        # part of the metaclass protocol.) Usually a = [&lt;some swig\n        # class&gt;] right now.\n        super(PropertyVoodoo, cls).__init__(*a)\n\n        # One more piece of work: SWIG selfishly overrides\n        # __setattr__. Normal Python classes use object.__setattr__,\n        # so that's what we use here. It's not really important whose\n        # __setattr__ we use as long as we skip the SWIG class in the\n        # inheritance chain because SWIG's __setattr__ will skip the\n        # property we just created.\n        def __setattr__(self, name, value):\n            # Only do this for the properties listed.\n            if name in cls.__properties__:\n                object.__setattr__(self, name, value)\n            else:\n                # Same as above.\n                s = super(cls, self)\n\n                s.__setattr__(name, value)\n\n        # Note that __setattr__ is supposed to be an instance method,\n        # hence the self. Simply assigning it to the class attribute\n        # will ensure it's an instance method; that is, it will *not*\n        # turn into a static/classmethod magically.\n        cls.__setattr__ = __setattr__\n</code>\n</pre>\n", "senID": 9}, {"text": ["somefile.py"], "childNum": 0, "tag": "h2", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n import example\nfrom util import PropertyVoodoo\n\nclass Math(example.Math):\n    __properties__ = ['pi']\n    __metaclass__  = PropertyVoodoo\n\nm = Math()\nprint m.pi\nm.pi = 1024\nprint m.pi\nm.pi = 10000\nprint m.pi\n</code>\n</pre>\n", "senID": 11}, {"text": ["So the end result is just that you have to create a wrapper class for every SWIG Python class and then type two lines: one to mark which methods should be converted in properties and one to bring in the metaclass."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["Hao Lian's answer is excellent but the specific PropertyVoodoo code seems to fail if there is more than one entry in the properties list.", "I've inserted that code directly into %pythoncode blocks in my SWIG input file and seem to be close to getting past this very annoying problem."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "properties", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["I had the same problem and the advice to use %pythoncode worked for me.", "Here is what I did:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Foo {\n  // ...\n  std::string get_name();\n  bool set_name(const std::string &amp; name);\n};\n</code>\n</pre>\n", "senID": 1}, {"text": ["In the wrapper:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n %include \"foo.h\"\n%pythoncode %{\ndef RaiseExceptionOnFailure(mutator):\n  def mutator(self, v):\n    if not mutator(self, v):\n     raise ValueError(\"cannot set property\")\n  return wrapper\nFoo.name = property(Foo.get_name, RaiseExceptionOnFailure(Foo.set_name))\n%}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The problem with Hao's ProperyVoodoo metaclass is that when there are multiple properties in the properties list, all the properties behave the same as the last one in the list.", "For example, if I had a list or property names [\"x\", \"y\", \"z\"], then the properties generated for all three would use the same accessors as \"z\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["After a little experimentation I believe I've determined that this problem is caused by the way Python handles closures (ie.", "names within nested functions that refer to variables in the containing scope).", "To solve the problem, you need to get local copies of the property name variable into the fget and fset methods.", "It's easy enough to sneak them in using default arguments:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # (NOTE: Hao's comments removed for brevity)\nclass PropertyVoodoo(type):\n\ndef __init__(cls, *a):\n\n    for prop in cls.__properties__:\n\n        def fget(self, _prop = str(prop)):\n            s = super(cls, self)\n            return getattr(s, _prop)()\n\n\n        def fset(self, value, _prop = str(prop)):\n            s = super(cls, self)\n            return getattr(s, _prop)(value)\n\n        setattr(cls, prop, property(fget=fget, fset=fset))\n\n    super(PropertyVoodoo, cls).__init__(*a)\n\n    def __setattr__(self, name, value):\n        if name in cls.__properties__:\n            object.__setattr__(self, name, value)\n        else:\n            s = super(cls, self)\n            s.__setattr__(name, value)\n\n    cls.__setattr__ = __setattr__\n</code>\n</pre>\n", "senID": 2}, {"text": ["Note that it is, in fact, completely safe to give fget and fset the extra _prop parameters because the property() class will never explicitly pass values to them, which means they will always be the default value (that being a copy of the string referenced by prop at the time each fget and fset method was created)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I don't know what I'm talking about, at all, but you can take a look at Boost.Python - it seems pretty easy..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.boost.org/doc/libs/1_39_0/libs/python/doc/index.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.boost.org/doc/libs/1_39_0/libs/python/doc/index.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.boost.org/doc/libs/1_39_0/libs/python/doc/index.html"}]}]]