[[{"text": ["Drop a pidfile somewhere (e.g.", "/tmp).", "Then you can check to see if the process is running by checking to see if the PID in the file exists.", "Don't forget to delete the file when you shut down cleanly, and check for it when you start up."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #/usr/bin/env python\n\nimport os\nimport sys\n\npid = str(os.getpid())\npidfile = \"/tmp/mydaemon.pid\"\n\nif os.path.isfile(pidfile):\n    print \"%s already exists, exiting\" % pidfile\n    sys.exit()\nelse:\n    file(pidfile, 'w').write(pid)\n\n# Do some actual work here\n\nos.unlink(pidfile)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you can check to see if the process is running by checking to see if the contents of /tmp/mydaemon.pid are an existing process.", "Monit (mentioned above) can do this for you, or you can write a simple shell script to check it for you using the return code from ps."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ps up `cat /tmp/mydaemon.pid ` &gt;/dev/null &amp;&amp; echo \"Running\" || echo \"Not running\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["For extra credit, you can use the atexit module to ensure that your program cleans up its pidfile under any circumstances (when killed, exceptions raised, etc.", ")."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Of course the example from Dan will not work as it should be."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Indeed, if the script crash, rise an exception, or does not clean pid file, the script will be run multiple times."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I suggest the following based from another website: "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This is to check if there is already a lock file existing\n#/usr/bin/env python\nimport os\nimport sys\nif os.access(os.path.expanduser(\"~/.lockfile.vestibular.lock\"), os.F_OK):\n        #if the lockfile is already there then check the PID number\n        #in the lock file\n        pidfile = open(os.path.expanduser(\"~/.lockfile.vestibular.lock\"), \"r\")\n        pidfile.seek(0)\n        old_pid = pidfile.readline()\n        # Now we check the PID from lock file matches to the current\n        # process PID\n        if os.path.exists(\"/proc/%s\" % old_pid):\n                print \"You already have an instance of the program running\"\n                print \"It is running as process %s,\" % old_pid\n                sys.exit(1)\n        else:\n                print \"File is there but the program is not running\"\n                print \"Removing lock file for the: %s as it can be there                 because of the program last time it was run\" % old_pid\n                os.remove(os.path.expanduser(\"~/.lockfile.vestibular.lock\")) "], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "#/usr/bin/env python\nimport os\nimport sys\nif os.access(os.path.expanduser(\"~/.lockfile.vestibular.lock\"), os.F_OK):\n        #if the lockfile is already there then check the PID number\n        #in the lock file\n        pidfile = open(os.path.expanduser(\"~/.lockfile.vestibular.lock\"), \"r\")\n        pidfile.seek(0)\n        old_pid = pidfile.readline()\n        # Now we check the PID from lock file matches to the current\n        # process PID\n        if os.path.exists(\"/proc/%s\" % old_pid):\n                print \"You already have an instance of the program running\"\n                print \"It is running as process %s,\" % old_pid\n                sys.exit(1)\n        else:\n                print \"File is there but the program is not running\"\n                print \"Removing lock file for the: %s as it can be there                 because of the program last time it was run\" % old_pid\n                os.remove(os.path.expanduser(\"~/.lockfile.vestibular.lock\"))", "childNum": 1, "tag": "pre", "pos": 0, "childList": [{"text": "#/usr/bin/env python\nimport os\nimport sys\nif os.access(os.path.expanduser(\"~/.lockfile.vestibular.lock\"), os.F_OK):\n        #if the lockfile is already there then check the PID number\n        #in the lock file\n        pidfile = open(os.path.expanduser(\"~/.lockfile.vestibular.lock\"), \"r\")\n        pidfile.seek(0)\n        old_pid = pidfile.readline()\n        # Now we check the PID from lock file matches to the current\n        # process PID\n        if os.path.exists(\"/proc/%s\" % old_pid):\n                print \"You already have an instance of the program running\"\n                print \"It is running as process %s,\" % old_pid\n                sys.exit(1)\n        else:\n                print \"File is there but the program is not running\"\n                print \"Removing lock file for the: %s as it can be there                 because of the program last time it was run\" % old_pid\n                os.remove(os.path.expanduser(\"~/.lockfile.vestibular.lock\"))", "tag": "code"}]}, {"text": "#/usr/bin/env python\nimport os\nimport sys\nif os.access(os.path.expanduser(\"~/.lockfile.vestibular.lock\"), os.F_OK):\n        #if the lockfile is already there then check the PID number\n        #in the lock file\n        pidfile = open(os.path.expanduser(\"~/.lockfile.vestibular.lock\"), \"r\")\n        pidfile.seek(0)\n        old_pid = pidfile.readline()\n        # Now we check the PID from lock file matches to the current\n        # process PID\n        if os.path.exists(\"/proc/%s\" % old_pid):\n                print \"You already have an instance of the program running\"\n                print \"It is running as process %s,\" % old_pid\n                sys.exit(1)\n        else:\n                print \"File is there but the program is not running\"\n                print \"Removing lock file for the: %s as it can be there                 because of the program last time it was run\" % old_pid\n                os.remove(os.path.expanduser(\"~/.lockfile.vestibular.lock\"))", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This is part of code where we put a PID file in the lock file\npidfile = open(os.path.expanduser(\"~/.lockfile.vestibular.lock\"), \"w\")\npidfile.write(\"%s\" % os.getpid())\npidfile.close"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "pidfile = open(os.path.expanduser(\"~/.lockfile.vestibular.lock\"), \"w\")\npidfile.write(\"%s\" % os.getpid())\npidfile.close", "childNum": 1, "tag": "pre", "pos": 0, "childList": [{"text": "pidfile = open(os.path.expanduser(\"~/.lockfile.vestibular.lock\"), \"w\")\npidfile.write(\"%s\" % os.getpid())\npidfile.close", "tag": "code"}]}, {"text": "pidfile = open(os.path.expanduser(\"~/.lockfile.vestibular.lock\"), \"w\")\npidfile.write(\"%s\" % os.getpid())\npidfile.close", "childNum": 0, "tag": "code", "childList": []}]}, {"senID": 5}, {"text": ["This code will check the value of pid compared to existing running process., avoiding double execution."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I hope it will help."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["There are very good packages for restarting processes on UNIX.", "One that has a great tutorial about building and configuring it is monit.", "With some tweaking you can have a rock solid proven technology keeping up your daemon."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "monit", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.cyberciti.biz/tips/howto-monitor-and-restart-linux-unix-service.html"}]}], [{"text": ["A technique that is handy on Posix system is using domain sockets:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import socket\nimport sys\nimport time\n\ndef get_lock(process_name):\n    global lock_socket\n    lock_socket = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)\n    try:\n        lock_socket.bind('\\0' + process_name)\n        print 'I got the lock'\n    except socket.error:\n        print 'lock exists'\n        sys.exit()\n\n\nget_lock('running_test')\nwhile True:\n    time.sleep(3)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It is atomic and avoids the problem of having lock files lying around if your process gets sent a SIGKILL"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I'm a big fan of Supervisor for managing daemons.", "It's written in Python, so there are plenty of examples of how to interact with or extend it from Python.", "For your purposes the XML-RPC process control API should work nicely."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Supervisor", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://supervisord.org"}, {"text": "XML-RPC process control API", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://supervisord.org/manual/current/api.process-control.html"}]}], [{"text": ["There are a myriad of options.", "One method is using system calls or python libraries that perform such calls for you.", "The other is simply to spawn out a process like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ps ax | grep processName\n</code>\n</pre>\n", "senID": 1}, {"text": ["and parse the output.", "Many people choose this approach, it isn't necessarily a bad approach in my view."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]