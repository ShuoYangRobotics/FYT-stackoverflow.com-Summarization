[[{"text": ["Two gross options, but they don't requiring copying the whole set:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for e in s:\n    break\n# e is now an element from s\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n e = iter(s).next() # was s.__iter__(s).next() \n                   # - thanks to J.F. Sebastian for better syntax!\n</code>\n</pre>\n", "senID": 3}, {"text": ["But in general, sets don't support indexing or slicing."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Since you want a random element, this will also work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import random\n&gt;&gt;&gt; s = set([1,2,3])\n&gt;&gt;&gt; random.sample(s, 1)\n[2]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The documentation doesn't seem to mention performance of random.sample.", "From a really quick empirical test with a huge list and a huge set, it seems to be constant time for a list but not for the set.", "Also, iteration over a set isn't random; the order is undefined but predictable:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "random.sample", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(set(range(10))) == range(10)\nTrue\n</code>\n</pre>\n", "senID": 3}, {"text": ["If randomness is important and you need a bunch of elements in constant time (large sets), I'd use random.sample and convert to a list first:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "random.sample", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; lst = list(s) # once, O(len(s))?\n...\n&gt;&gt;&gt; e = random.sample(lst, 1)[0] # constant time\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Another option is to use a dictionary with values you don't care about.", "E.g.,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n poor_man_set = {}\npoor_man_set[1] = None\npoor_man_set[2] = None\npoor_man_set[3] = None\n...\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can treat the keys as a set except that they're just an array:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n keys = poor_man_set.keys()\nprint \"Some key = %s\" % keys[0]\n</code>\n</pre>\n", "senID": 3}, {"text": ["A side effect of this choice is that your code will be backwards compatible with older, pre-set versions of Python.", "It's maybe not the best answer but it's another option."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit: You can even do something like this to hide the fact that you used a dict instead of an array or set:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n poor_man_set = {}\npoor_man_set[1] = None\npoor_man_set[2] = None\npoor_man_set[3] = None\npoor_man_set = poor_man_set.keys()\n</code>\n</pre>\n", "senID": 6}], [{"text": ["To provide some timing figures behind the different approaches, consider the following code.", "The get() is my custom addition to Python's setobject.c, being just a pop() without removing the element."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "The get() is my custom addition to Python's setobject.c, being just a pop() without removing the element.", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from timeit import *\n\nstats = [\"for i in xrange(1000): iter(s).next()   \",\n         \"for i in xrange(1000): \\n\\tfor x in s: \\n\\t\\tbreak\",\n         \"for i in xrange(1000): s.add(s.pop())   \",\n         \"for i in xrange(1000): s.get()          \"]\n\nfor stat in stats:\n    t = Timer(stat, setup=\"s=set(range(100))\")\n    try:\n        print \"Time for %s:\\t %f\"%(stat, t.timeit(number=1000))\n    except:\n        t.print_exc()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The output is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ ./test_get.py\nTime for for i in xrange(1000): iter(s).next()   :       0.433080\nTime for for i in xrange(1000):\n        for x in s:\n                break:   0.148695\nTime for for i in xrange(1000): s.add(s.pop())   :       0.317418\nTime for for i in xrange(1000): s.get()          :       0.146673\n</code>\n</pre>\n", "senID": 3}, {"text": ["This means that the for/break solution is the fastest (sometimes faster than the custom get() solution)."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "for/break", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "for/break", "tag": "em"}]}, {"text": "for/break", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["Why not just iterate over the set in a regular for loop and make the call back from the asynchronous call remove from the set if successful"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i in fooSet:\n    asyncCall(callback, fooSet, i)\n\ndef callback(successful, fooSet, i):\n    if successful:\n        fooSet.remove(i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or, if the majority of the time the call is successful, just pop() the stack anyway and make the call back re-add the element if it fails."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n try:\n    i = fooSet.pop():\n    asyncCall(callback, fooSet, i)\ncatch KeyError:\n    # no more elements\n\ndef callback(successful, fooSet, i):\n    if not successful:\n        fooSet.add(i)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Least code would be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = set([1, 2, 3])\n&gt;&gt;&gt; list(s)[0]\n1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Obviously this would create a new list which contains each member of the set, so not great if your set is very large."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I use a utility function I wrote.", "Its name is somewhat misleading because it kind of implies it might be a random item or something like that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def anyitem(iterable):\n    try:\n        return iter(iterable).next()\n    except StopIteration:\n        return None\n</code>\n</pre>\n", "senID": 1}]]