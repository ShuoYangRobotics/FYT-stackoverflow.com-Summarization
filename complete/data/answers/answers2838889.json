[[{"text": ["Here's my take on the code cleanup:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Edit: I've taken David's code into my answer to make it even more compact (and faster execution time)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import product\n&gt;&gt;&gt;\n&gt;&gt;&gt; def fringe8((px, py), (x1, y1, x2, y2)):\n...     f = [(px+dx, py+dy) for (dx, dy) in product((-1,0,1),(-1,0,1)) if (dx, dy) != (0, 0)]\n...     f_inrange = [(fx, fy) for (fx, fy) in f if x1 &lt;= fx &lt; x2 and y1 &lt;= fy &lt; y2]\n...     return f_inrange\n...   \n&gt;&gt;&gt; fringe8((2, 2), (1, 1, 3, 3))\n[(1, 1), (1, 2), (2, 1)]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Edit: If you're not too comfortable with list comprehensions, feel free to break it down to a for loop.", "The conditions proposed here, and others' answers, are all much more concise for you to use."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["After all, one the goals of list comprehesion is to make it easier to read, and not verbose."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Edit again: Please also look at Ryan Ginstrom's answer."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "Edit again:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/2838889/how-can-this-verbose-unpythonic-routine-be-improved/2839022#2839022", "text": "Ryan Ginstrom's answer", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["This is a reworking of Xavier Ho's answer.", "I think that it's made a little more clear by using intermediate steps."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import product\n\ndef fringe8((px, py), (x1, y1, x2, y2)):\n\n    nonzero = (pair for pair in product((-1,0,1),(-1,0,1)) if pair != (0, 0))\n    f = ((px+dx, py+dy) for (dx,dy) in nonzero)\n\n    def in_range((fx, fy)):\n        return x1 &lt;= fx &lt; x2 and y1 &lt;= fy &lt; y2\n    return [pair for pair in f if in_range(pair)]\n\nprint fringe8((2, 2), (1, 1, 3, 3))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's a thought:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fringe8((px, py), (x1, y1, x2, y2)):\n    f = [(px + dx, py + dy) for (dx, dy) in itertools.product((-1,0,1),repeat=2) if not (dx == dy == 0)]\n    f_inrange = [(fx, fy) for (fx, fy) in f if x1 &lt;= fx &lt; x2 and y1 &lt;= fy &lt; y2]\n    return f_inrange\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This list comprehension should work"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f_inrange = [(px+i,py+j) for i in (-1,0,1) for j in (-1,0,1) \\\n             if (i != j or i != 0) and x1 &lt;= px+i &lt; x2 and \\\n             y2 &gt; py+j &gt;= y1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["though it is kind of lengthy."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's my effort.", "It constructs the interesting ranges directly, so doesn't test redundant points (except for the pesky center point).", "I added an extra argument r than can return a larger square around the point too."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fringe((px, py), (x1, y1, x2, y2), r=1):\n    return [(x, y)\n            for x in xrange(max(px - r, x1), min(px + r + 1, x2))\n            for y in xrange(max(py - r, y1), min(py + r + 1, y2))\n            if x != px or y != py]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def fringe8((px, py), (x1, y1, x2, y2)):\n    return [(x, y) for x,y \n            in itertools.product(   [xi+px for xi in [-1,0,1]],\n                                    [yi+py for yi in [-1,0,1]] )\n            if (x1&lt;=x&lt;x2) and (y1&lt;=y&lt;y2) and not ((x==px) and (y==py))]\n</code>\n</pre>\n", "senID": 0}, {"text": ["I don't know if that's more pythonic, but it's certainly another way to do it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n def fringe8((px, py), (x1, y1, x2, y2)):\n  return [(fx, fy) for fx in [px - x for x in [-1, 0, 1]] if (fx &gt;= x1 and fx &lt; x2) \n  for fy in [py - y for y in [-1, 0, 1]]  if fy &gt;= y1 and fy &lt; y2 \n  and not(fx == px and fy == py)]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I don't know from pythonicness, but I see that this function is doing two things: a) finding adjacent points; and b) restricting a list of points to those that are in range.", "So I would split it up, because a) it's clearer; b) sometimes I might want one of those behaviors without the other; c) it's easier to test; and d) it's easier to name.", "I won't attempt to convert this advice into python - I'm sure my attempt wouldn't be pretty - but that would be my starting point."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I like Carl's suggestion.", "Also you can avoid repeated construction of the neighbor offsets."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import product\n\nNEIGHBOR_OFFSETS = [pair for pair in product((-1,0,1), (-1,0,1))\n    if pair != (0, 0)]\n\ndef clip(points, (x1, y1, x2, y2)):\n    return [(px, py) for px, py in points if \n        x1 &lt;= px &lt; x2 and y1 &lt;= py &lt; y2]\n\ndef neighbors(px, py):\n    return [(px+dx, py+dy) for dx, dy in NEIGHBOR_OFFSETS]\n\ndef fringe8(point, rect):\n    return clip(neighbors(*point), rect)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["here is my recycle :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fringe8((px, py), (x1, y1, x2, y2)):\n    return [(x, y) for x,y in itertools.product((px-1, px , px+1),\n                                                (py-1, py , py+1))\n            if (x1&lt;=x&lt;x2) and (y1&lt;=y&lt;y2) and (x,y) != (px,py)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The name of the function could be more informative.", "I know what the code does, but I have no idea what it is intended for."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]