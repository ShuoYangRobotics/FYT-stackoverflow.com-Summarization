[[{"text": ["A very wild guess and probably totally non-sense, but I knew that syntax from Modula-2 (man, that was twenty years ago, I feel old)... maybe Python was inspired by it ?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Modula-2", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.modula2.org/reference/modules.php"}]}], [{"text": ["No idea why it was actually done that way but it's the way I'd do it, simply because, being an engineering type, it seems more natural to me to start from a general category and drill down to specifics."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "actually", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["It would also mean the parser would have to store less stuff if processing sequentially.", "With:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import x,y,z from a\n</code>\n</pre>\n", "senID": 2}, {"text": ["you have to remember x, y and z.", "With:"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "z", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n from a import x,y,z\n</code>\n</pre>\n", "senID": 4}, {"text": ["you only have to remember a :-)"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["That's why I had so much trouble when I first encountered Perl's post-if variant:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n $x = $y if $y &gt; 40;\n</code>\n</pre>\n", "senID": 7}, {"text": [":-)"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["I don't know the complete heritage of this syntax, as it dates from Python 1.x days.", "But I find it useful to be able to scan down the left side of the source, and quickly find the module names that a script depends on.", "If a statement read \"import a,b,c,d,e,really_long_name, alsdf,lsdf from blah\", it would take me a while to find that this script depended on blah."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Apart from asking Guido directly, I don't think your going to find any explanation of this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The syntax has been around from the very beginning.", "The earliest version of python sources I could find was python 1.0.1.", "Looking at the changelog in the Grammar file we find references to even earlier versions.", "In version 2 of Python (I think we're talking 2nd release after 0.9.0) we have this note:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #   added 'from' NAME option on import clause, and '*' to import all;\n</code>\n</pre>\n", "senID": 2}, {"text": ["This was added at the same time as "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n #   added class definition.\n</code>\n</pre>\n", "senID": 4}, {"text": ["So the import statement sprang forth at the same time as classes were added to Python.", "This comes from when Python was Guido van Rossum's solo project.", "In other words, the answer you are looking for is lost in the sands of time."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Now, here's my speculation why the import statement reads from x import y rather than import y from x."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "from x import y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "import y from x", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The documentation for the import statement provides the basic algorithm for implementing import:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "documentation for the import statement", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/simple_stmts.html#import"}]}, {"text": ["In both versions of the import statement the first step of this algorithm are leftmost.", "I assume that this was the most obvious ordering for a language implementer, even though English might read more naturally if the order were reversed."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["In fact, it's not that strange.", "Look at how we \"import\", \"include\" or \"require\" in other languages.", "We always specify the namespace first.", "include \"inc/config.php\" in PHP for example.", "So in a way, it keeps our usual way of including files or modules."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["It might make more sense in english to say import x, y, z from module but in programming it makes much more sense to bring the more general Item first and then bring the details.", "It might not be the reason but it makes things easier for the compiler or interpreter.", "Try writing a compiler and you'll know what I mean :D"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "import x, y, z from module", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["It depends on the programming language syntax you use.", "It is easier for me to read a such import. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\u0130s it easier to read and understand "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n From Grocery buy apple and orange\n</code>\n</pre>\n", "senID": 2}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n Buy apple and orange from grocery.\nBuy apple and orange from supermarket\n</code>\n</pre>\n", "senID": 4}, {"text": ["First one suits me better..."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]