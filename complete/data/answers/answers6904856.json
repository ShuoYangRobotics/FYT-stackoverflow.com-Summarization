[[{"text": ["Because it's modified in-place."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python lists have reference semantics, meaning that when you assign a list to another variable, they're actually pointing at the same list."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you want to make a copy, do this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n x = [2,1,3]\ny = x[:]\ny.sort()\nprint y\nprint x\n</code>\n</pre>\n", "senID": 3}, {"text": ["The slice notation does cause the list (in this case, the entire list, though you can make a small modification to ask for a particular sublist) to be copied."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "slice", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["You are dealing with references in Python.", "The statement y = x makes y point to the same thing as x, so changes to y are reflected in x (because they point to the same underlying list)."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "references", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "y = x", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You can change a copy by doing:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n y = list(x) # make a copy of the list so we can change y without disturbing x\ny.sort()\n</code>\n</pre>\n", "senID": 2}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n y = sorted(x) # return a new sorted copy of what is in x\n</code>\n</pre>\n", "senID": 4}], [{"text": ["x is the name of (\"reference to\") the list (object).", "The line"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n y=x\n</code>\n</pre>\n", "senID": 1}, {"text": ["merely makes y another name for the same list.", "If you want to copy the list, use one of"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n y = x[:]\ny = list(x)\n</code>\n</pre>\n", "senID": 3}, {"text": ["(The first syntax is just an ordinary list slice, but with both the start and the end values left out, meaning that it takes the entire list."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Note that a list is a list of objects, and copying the list will not copy the objects.", "If you want that behaviour \u2014 a deep copy \u2014 you must do so explicitly with"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "deep", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import copy\ny = copy.deepcopy(x)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Naturally, this will be slower."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Assigning a list to another variable in Python creates a reference, so any changes you make to the reference will show up in the original.", "If you want a copy that will not alter the original, do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n y = x[:]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Because you only copy the reference."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For instruction on how to clone the list ('deep copy'),see:\nHow to clone a list in python?"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "How to clone a list in python?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2612802/how-to-clone-a-list-in-python"}]}], [{"text": ["When you say y = x, you're really just assigning another name (y) to the contents of x.", "If x is a mutable value and you do something to change it, you change the one-and-only copy that has 2 different names."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "y = x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["A common way to prevent this is to assign to a slice, which is always a copy of the original list."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n y = x[:]\n</code>\n</pre>\n", "senID": 2}]]