[[{"text": ["without regexp:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def insert_newlines(string, every=64):\n    lines = []\n    for i in xrange(0, len(string), every):\n        lines.append(string[i:i+every])\n    return '\\n'.join(lines)\n</code>\n</pre>\n", "senID": 1}, {"text": ["shorter but less readable (imo):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def insert_newlines(string, every=64):\n    return '\\n'.join(string[i:i+every] for i in xrange(0, len(string), every))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Same as in Perl, but with a backslash instead of the dollar for accessing groups:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s = \"0123456789\"*100 # test string\nimport re\nprint re.sub(\"(.{64})\", \"\\\\1\\n\", s, re.DOTALL)\n</code>\n</pre>\n", "senID": 1}, {"text": ["re.DOTALL is the equivalent to Perl's s/ option."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "re.DOTALL", "tag": "a", "pos": 0, "childList": [{"text": "re.DOTALL", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/re.html#re.DOTALL"}, {"text": "re.DOTALL", "childNum": 0, "tag": "code", "childList": []}, {"text": "s/", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I'd go with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import textwrap\ns = \"0123456789\"*100\nprint '\\n'.join(textwrap.wrap(s, 64))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Tiny, not nice:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \"\".join(s[i:i+64] + \"\\n\" for i in xrange(0,len(s),64))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I suggest the following method:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \"\\n\".join(re.findall(\"(?s).{,64}\", s))[:-1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is, more-or-less, the non-RE method taking advantage of the RE engine for the loop."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["On a very slow computer I have as a home server, this gives:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n $ python -m timeit -s 's=\"0123456789\"*100; import re' '\"\\n\".join(re.findall(\"(?s).{,64}\", s))[:-1]'\n10000 loops, best of 3: 130 usec per loop\n</code>\n</pre>\n", "senID": 4}, {"text": ["AndiDog's method:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n $ python -m timeit -s \"s='0123456789'*100; import re\" 're.sub(\"(?s)(.{64})\", r\"\\1\\n\", s)'\n1000 loops, best of 3: 800 usec per loop\n</code>\n</pre>\n", "senID": 6}, {"text": ["gurney alex's 2nd/Michael's method:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n $ python -m timeit -s \"s='0123456789'*100\" '\"\\n\".join(s[i:i+64] for i in xrange(0, len(s), 64))'\n10000 loops, best of 3: 148 usec per loop\n</code>\n</pre>\n", "senID": 8}, {"text": ["I don't consider the textwrap method to be correct for the specification of the question, so I won't time it."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "textwrap", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Changed answer because it was incorrect (shame on me!"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Just for the fun of it, the RE-free method using itertools.", "It rates third in speed, and it's not Pythonic (too lispy):"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n \"\\n\".join(\n   it.imap(\n     s.__getitem__,\n     it.imap(\n       slice,\n       xrange(0, len(s), 64),\n       xrange(64, len(s)+1, 64)\n     )\n   )\n )\n\n$ python -m timeit -s 's=\"0123456789\"*100; import itertools as it' '\"\\n\".join(it.imap(s.__getitem__, it.imap(slice, xrange(0, len(s), 64), xrange(64, len(s)+1, 64))))'\n10000 loops, best of 3: 182 usec per loop\n</code>\n</pre>\n", "senID": 12}], [{"text": ["taking @J.F.", "Sebastian's solution one step further, and this is nearly criminal :-)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "nearly", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import textwrap\ns = \"0123456789\"*100\nprint textwrap.fill(s, 64)\n</code>\n</pre>\n", "senID": 1}, {"text": ["look ma... no regexes!", "because as you know... http://regex.info/blog/2006-09-15/247"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://regex.info/blog/2006-09-15/247", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://regex.info/blog/2006-09-15/247"}]}, {"text": ["thanks for introducing us to textwrap module... although it's been in Python since 2.3, i've never been aware of it until now (yes, i'll admit that publically)!"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "textwrap", "tag": "a", "pos": 0, "childList": [{"text": "textwrap", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/textwrap.html"}, {"text": "textwrap", "childNum": 0, "tag": "code", "childList": []}]}]]