[[{"text": ["Do you really need to hash at all?", "Twitter messages are short enough (and disk space cheap enough) that it may be better to just store the whole message, rather than eating up clock cycles to hash it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I am not familiar with Python (sorry, Ruby guy typing here) however you could try a few things. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Assumptions: \nYou will likely be storing hundreds of thousands of Tweets over time, so comparing one hash against \"every record\" in the table will be inefficient.", "Also, RTs are not always carbon copies of the original tweet.", "After all, the original author's name is usually included and takes up some of the 140 character limit.", "So perhaps you could use a solution that matches more accurately than a \"dumb\" hash?"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Assumptions:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Now let me warmly welcome you to the world of text mining. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "text mining", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Good luck!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I echo Chris' comment about not using a hash at all (your database engine can hopefully index 140-character fields efficiently)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you did want to use a hash, MD5 would be my first choice as well (16 bytes), followed by SHA-1 (20 bytes)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Whatever you do, don't use sum-of-characters.", "I can't immediately come up with a  function that would have more collisions (all anagrams hash the same), plus it's slower!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ python -m timeit -s 'from hashlib import md5' 'd=md5(\"There once was a man named Michael Finnegan.\").digest()'\n100000 loops, best of 3: 2.47 usec per loop\n$ python -m timeit 'd=sum(ord(c) for c in \"There once was a man named Michael Finnegan.\")'\n100000 loops, best of 3: 13.9 usec per loop\n</code>\n</pre>\n", "senID": 3}], [{"text": ["There are a few issues here.", "First, RT's are not always identical.", "Some people add a comment.", "Others change the URL for tracking.", "Others add in the person that they are RT'ing (which may or may not be the originator)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So if you are going to hash the tweet, you need to boil it down to the meat of the tweet, and only hash that.", "Good luck."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Above, someone mentioned that with 32-bits, you will start having collisions at about 65K tweets.", "Of course, you could have collisions on tweet #2.", "But I think the author of that comment was confused, since 2^16 = ~65K, but 2^32 = ~4 Trillion.", "So you have a little more room there."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["A better algorithm might be to try to derive the \"unique\" parts of the tweet,  and fingerprint it.", "It's not a hash, it's a fingerprint of a few key words that define uniqueness."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Well, tweets are only 140 characters long, so you could even store the entire tweet in the database..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["but if you really want to \"hash\" them somehow, a simple way would be to just take the sum of the ASCII values of all the characters in the tweet:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n sum(ord(c) for c in tweet)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Of course, whenever you have a match of hashes, you should check the tweets themselves for sameness, because the probability of finding two tweets that give the same \"sum-hash\" is probably non-negligible."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Python's shelve module?", "http://docs.python.org/library/shelve.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/shelve.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/shelve.html"}]}], [{"text": ["You are trying to hash a string right?", "Builtin types can be hashed right away, just do hash(\"some string\") and you get some int.", "Its the same function python uses for dictonarys, so it is probably the best choice."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "hash(\"some string\")", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]