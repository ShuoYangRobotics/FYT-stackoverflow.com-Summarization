[[{"text": ["Taking various ideas from various other answers, here's another way to do it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sum(1&lt;&lt;i for i, b in enumerate(x) if b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It is quite fast in my tests - right up with the numpy method for large number of bits even though it overflows like crazy.", "I used liori's testing module for testing.", "Steve's method, with the change I suggested, is just barely faster.", "However, if a lot of these sorts of conversions need to be done at a time (and with not too many bits), I'm betting that numpy will be faster."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Most Pythonic might be this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sum(2**i*b for i, b in enumerate(x))\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's hard to tell if it is also the fastest."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In numpy I would use"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n numpy.sum(2**numpy.arange(len(x))*x)\n</code>\n</pre>\n", "senID": 4}, {"text": ["but this won't be faster for small arrays x, and it won't work for big arrays x since machine size integers are used instead of Pythons arbitrary precision ints."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n reduce(lambda a,b:2*a+b, reversed(x))\n</code>\n</pre>\n", "senID": 0}, {"text": ["You could get rid of reversed() if you had least significant bit at the end of array.", "This works with numpy.array too, and doesn't need enumerate().", "From my tests seem to be faster too: no need to use exponentiation."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["An elegant, pythonic, always-working way is this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def powers(x):\n    \"\"\"yield powers of x, starting from x**0 forever\"\"\"\n    power = 1\n    while True:\n        yield power\n        power *= x\n\ndef bools_to_int(bools):\n    # in Python 2, use itertools.izip!\n    return sum(int(place) * place_weight for place_weight, place in \n               zip(powers(2), bools))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that you can get rid of powers (by enumerate and squaring in the comprehension, as other answers do) - but maybe it's clearer this way."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "can", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "powers", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Something like this? "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = [False, False, True, True]\n&gt;&gt;&gt; sum([int(y[1])*2**y[0] for y in enumerate(x)])\n12\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can convert a numpy array to a regular list using a list() cast."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "list()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = numpy.array([1,2,3,4])\n&gt;&gt;&gt; a\narray([1, 2, 3, 4])\n&gt;&gt;&gt; list(a)\n[1, 2, 3, 4]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["My initial attempt, just for reference:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def bool2int(x):\n    y = 0\n    for i,j in enumerate(x):\n        if j: y += int(j)&lt;&lt;i\n    return y\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you're willing to add another extension to the mix, I added pack() and unpack() to the development branch of gmpy.", "My tests show it may be 2x or 3x faster."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import gmpy2\n&gt;&gt;&gt; gmpy2.pack([0,0,1,1],1)\nmpz(12)\n&gt;&gt;&gt; gmpy2.unpack(12,1)\n[mpz(0), mpz(0), mpz(1), mpz(1)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Disclaimer: The development version is called gmpy2 and can co-exist with the stable version.", "It is still in alpha phase but will hopefully become beta in a few weeks.", "You need to have both GMP and MPFR libraries installed.", "The source is available at http://code.google.com/p/gmpy/source/checkout"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://code.google.com/p/gmpy/source/checkout", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://code.google.com/p/gmpy/source/checkout"}]}], [{"text": ["If you have a matrix, you probably want to do it like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #precompute powers of two\nvals = 2.**np.arange(20)\n\nB = ....\ncompressed = np.dot(B, vals) # matrix multiplication.\n</code>\n</pre>\n", "senID": 1}, {"text": ["np.dot should be faster than any loop in Python.", "Much faster."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]