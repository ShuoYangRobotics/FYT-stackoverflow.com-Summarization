[[{"text": ["you can combine them with zipfunction, like so:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "zipfunction", "tag": "a", "pos": 0, "childList": [{"text": "zip", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html?highlight=zip#zip"}, {"text": "zip", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n for sim, datapoint, x, y, z in zip(simnum, npts, *xyz):\n    # do your thing\n</code>\n</pre>\n", "senID": 1}, {"text": ["or you could avoid list comprehensions altogether and just iterate over the lines of the file:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for line in open(fname):\n    lst = line.split('\\t')\n    sim, datapoint = int(lst[0]), int(lst[1])\n    x, y, z = [float(i) for i in lst[2:]]\n    # do your thing\n</code>\n</pre>\n", "senID": 3}, {"text": ["to parse a single line you could (and should) do the following:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n coords = [x.split('\\t') for x in open(fname)]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["According to the zen of python, flat is better than nested.", "I'd just use a dict."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import csv\nf = csv.reader(open('thefile.csv'), delimiter='\\t',\n               quoting=csv.QUOTE_NONNUMERIC)\n\nresult = {}\nfor simn, dpoint, c1, c2, c3 in f:\n    result[simn, dpoint] = c1, c2, c3\n\n# pretty-prints the result:\nfrom pprint import pprint\npprint(result)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This seems like a good opportunity to use itertools.groupby."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\nimport csv\nfile = open(\"data.txt\")\nreader = csv.reader(file, delimiter='\\t')\nresult = []\nfor simnumberStr, rows in itertools.groupby(reader, key=lambda t: t[0]):\n    simData = []\n    for row in rows:\n        simData.append([float(v) for v in row[2:]])\n    result.append(simData)\nfile.close()\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will create a 3 dimensional list named 'result'.", "The first index is the simulation number, and the second index is the data index within that simulation.", "The value is a list of integers containing the x, y, and z coordinate."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note that this assumes the data is already sorted on simulation number and data number."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["essentially the difficulty is what happens if different simulations have different numbers of points."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You will therefore need to dimension an array to the appropriate sizes first.", "t should be an array of at least max(simnum) x max(npts) x 3.", "To eliminate confusion you should initialise with not-a-number,\nthis will allow you to see missing points."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "max(simnum) x max(npts) x 3", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["then use something like"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for x in coords:\n  t[int(x[0])][int(x[1])][0]=float(x[3])\n  t[int(x[0])][int(x[1])][1]=float(x[4])\n  t[int(x[0])][int(x[1])][2]=float(x[5])\n</code>\n</pre>\n", "senID": 3}, {"text": ["is this what you meant?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You could be using many different kinds of containers for your purposes, but none of them has array as an unqualified name -- Python has a module array which you can import from the standard library, but the array.array type is too limited for your purposes (1-D only and with elementary types as contents); there's a popular third-party extension known as numpy, which does have a powerful numpy.array type, which you could use if you has downloaded and installed the extension -- but as you never even once mention numpy I doubt that's what you mean; the relevant builtin types are list and dict.", "I'll assume you want any container whatsoever -- but if you could learn to use precise terminology in the future, that will substantially help you AND anybody who's trying to help you (say list when you mean list, array only when you DO mean array, \"container\" when you're uncertain about what container to use, and so forth)."], "childNum": 8, "tag": "p", "senID": 0, "childList": [{"text": "array", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "array", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "array.array", "childNum": 0, "tag": "code", "childList": []}, {"text": "numpy", "childNum": 0, "tag": "code", "childList": []}, {"text": "numpy.array", "childNum": 0, "tag": "code", "childList": []}, {"text": "numpy", "childNum": 0, "tag": "code", "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I suggest you look at the csv module in the standard library for a more robust way to reading your data, but that's a separate issue.", "Let's start from when you have the coords list of lists of 5 strings each, each sublist with strings representing two ints followed by three floats.", "Two more key aspects need to be specified..."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "csv", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "coords", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["One key aspect you don't tell us about: is the list sorted in some significant way?", "is there, in particular, some significant order you want to keep?", "As you don't even mention either issue, I will have to assume one way or another, and I'll assume that there isn't any guaranteed nor meaningful order; but, no repetition (each pair of simulation/datapoint numbers is not allowed to occur more than once)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Second key aspect: are there the same number of datapoints per simulation, in increasing order (0, 1, 2, ...), or is that not necessarily the case (and btw, are the simulation themselves numbered 0, 1, 2, ...)?", "Again, no clue from you on this indispensable part of the specs -- note how many assumptions you're forcing would-be helpers to make by just not telling us about such obviously crucial aspects.", "Don't let people who want to help you stumble in the dark: rather, learn to ask questions the smart way -- this will save untold amounts of time to yourself AND would-be helpers, and give you higher-quality and more relevant help, so, why not do it?", "Anyway, forced to make yet another assumption, I'll have to assume nothing at all is known about the simulation numbers nor about the numers of datapoints in each simulation."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "not telling us", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "ask questions the smart way", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://catb.org/~esr/faqs/smart-questions.html"}, {"text": "and", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["With these assumptions dict emerges as the only sensible structure to use for the outer container: a dictionary whose key is a tuple with two items, simulation number then datapoint number within the simulation.", "The values may as well be tuple, too (with three floats each), since it does appear that you have exactly 3 coordinates per line."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["With all of these assumptions...:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def make_container(coords):\n  result = dict()\n  for s, d, x, y, z in coords:\n    key = int(s), int(d)\n    value = float(x), float(y), float(z)\n    result[key] = value\n  return result\n</code>\n</pre>\n", "senID": 6}, {"text": ["It's always best, and fastest, to have all significant code within def statements (i.e.", "as functions to be called, possibly with appropriate arguments), so I'm presenting it this way.", "make_container returns a dictionary which you can address with the simulation number and datapoint number; for example,"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "def", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "make_container", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n d = make_container(coords)\nprint d[0, 0]\n</code>\n</pre>\n", "senID": 8}, {"text": ["will print the x, y, z for dp 0 of sim 0, assuming one exists (you would get an error if such a sim/dp combination did not exist).", "dicts have many useful methods, e.g.", "changing the print statement above to"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n print d.get((0, 0))\n</code>\n</pre>\n", "senID": 10}, {"text": ["(yes, you do need double parentheses here -- inner ones to make a tuple, outer ones to call get with that tuple as its single argument), you'd see None, rather than get an exception, if there was no such sim/dp combinarion as (0, 0)."], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "do", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "get", "childNum": 0, "tag": "code", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you can edit your question to make your specs more precise (perhaps including some indication of ways you plan to use the resulting container, as well as the various key aspects I've listed above), I might well be able to fine-tune this advice to match your need and circumstances much better (and so might ever other responder, regarding their own advice!", "), so I strongly recommend you do so -- thanks in advance for helping us help you!-)"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["First I'd point out that your first data point appears to be an index, and wonder if the data is therefore important or not, but whichever :-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def parse(line):\n    mch = re.compile('^(\\d+)\\s+(\\d+)\\s+([-\\d\\.]+)\\s+([-\\d\\.]+)\\s+([-\\d\\.]+)$')\n    m = mch.match(line)\n    if m:\n        l = m.groups()\n        (idx,data,xyz) = (int(l[0]),int(l[1]), map(float, l[2:]))\n        return (idx, data, xyz)\n    return None\n\nfinaldata = []\nfile = open(\"data.txt\",'r')\nfor line in file:\n    r = parse(line)\n    if r is not None:\n        finaldata.append(r)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Final data should have output along the lines of:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [(0, 0, [-11.007001000000001, -14.222319000000001, 2.3367689999999999]),\n (1, 0, [-11.007001000000001, -14.222319000000001, 2.3367689999999999]),\n (2, 0, [-11.007001000000001, -14.222319000000001, 2.3367689999999999]),\n (3, 0, [-11.007001000000001, -14.222319000000001, 2.3367689999999999]),\n (4, 0, [-11.007001000000001, -14.222319000000001, 2.3367689999999999])]\n</code>\n</pre>\n", "senID": 3}, {"text": ["This should be pretty robust about dealing w/ the whitespace issues (tabs spaces whatnot)... "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I also wonder how big your data files are, mine are usually large so being able to process them in chunks or groups become more important...", "Anyway this will work in python 2.6."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Are you sure a 3d array is what you want?", "It seems more likely that you want a 2d array, where the simulation number is one dimension, the data point is the second, and then the value stored at that location is the coordinates."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This code will give you that."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n data = []\nfor coord in coords:\n    if coord[0] not in data:\n        data[coord[0]] = []\n    data[coord[0]][coord[1]] = (coord[2], coord[3], coord[4])\n</code>\n</pre>\n", "senID": 2}, {"text": ["To get the coordinates at simulation 7, data point 13, just do data[7][13]"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]