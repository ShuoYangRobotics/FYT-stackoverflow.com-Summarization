[[{"text": ["Collision detection for arbitrary shapes is usually quite tricky since you have to figure out if any pixel collides."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is actually easier with circles.", "If you have two circles of radius r1 and r2, a collision has occurred if the distance between the centers is less than r1+r2."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The distance between the two centers (x1,y1) and (x2,y2) can be calculated and compared as:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n d = sqrt((y2-y1) * (y2-y1) + (x2-x1) * (x2-x1));\nif (d &lt; r1 + r2) { ... bang ... }\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or, as jfclavette points out, square roots are expensive so it may be better to calculate using just simple operations:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n dsqrd = (y2-y1) * (y2-y1) + (x2-x1) * (x2-x1);\nif (dsqrd &lt; (r1+r2)*(r1+r2)) { ... bang ... }\n</code>\n</pre>\n", "senID": 5}, {"text": ["The tricky bit comes in calculating the new movement vectors (the rate at which (x,y) changes over time for a given object) since you need to take into account the current movement vectors and the point of contact."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I think as a first cut, you should just reverse the movement vectors to test if the collision detection works first."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Then ask another question - it's better to keep individual questions specific so answers can be targeted."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["Detecting a collision is only the first step.", "Let's break that down."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The fastest thing to do is calculate their square bounding boxes and see if those collide.", "Two of the sides need to cross (top of 1 and bottom or 2, and left of 1 and right of 2, or vice versa) in order for the bounding boxes to overlap.", "No overlap, no collision."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Now, when they do overlap, you need to calculate the distance between them.", "If this distance is more than the sums of the radii of the balls, then no collision."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "do", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Okay!", "We have two balls colliding.", "Now what?", "Well, they have to bounce off each other.", "Which way they bounce depends on a few factors."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Now", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["The first is their elasticity.", "Two rubber balls bouncing off each other rebound differently than two glass balls."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The second is their initial velocity.", "Inertia states that they'll want to keep going in mostly the same direction they started in."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The third is the mass of the balls.", "A ball with smaller mass will rebound off a much larger mass with a higher velocity."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Let's deal with the second and third factors first, since they are intertwined."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Two balls will rarely hit exactly dead on.", "Glancing blows are far more likely.", "In any case, the impact will happen along the normal of the tangent where the balls collide.", "You need to calculate the vector component of both along this normal given their initial velocities.", "This will result in a pair of normal velocities that both balls will bring to the collision.", "Add up the sum and store it somewhere handy."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Now we have to figure out what each ball will take away from it.", "The resulting normal velocity of each ball is inversely proportional to the given ball's mass.", "That is to say, take the reciprocal of each ball's mass, add both masses together, and then parcel out the resultant normal velocity away from the collision based on the ratio of the ball's mass to the sum of the reciprocal of both ball's masses.", "Then add the tangential velocity to this, and you get the resultant velocity of the ball."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Elasticity is mostly the same, except it requires some basic calculus due to the fact that the balls are still moving even as they compress.", "I'll leave it to you to find the relevant math."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["I asked a similar question awhile ago:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Ball to Ball collision detection and handling."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Ball to Ball collision detection and handling.", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/345838/ball-to-ball-collision-detection-and-handling"}]}, {"text": ["Got some good responses there too."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Detecting collisions was covered well by Pax's answer.", "With respect to having objects bounce off one another, I suggest checking out the following links concerning elastic collisions, inelastic collisions, and coefficients of restitution."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "Pax's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/780169/how-do-i-create-collision-detections-for-my-bouncing-balls/780201#780201"}, {"text": "elastic collisions", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Elastic%5Fcollision"}, {"href": "http://en.wikipedia.org/wiki/Inelastic%5Fcollision", "text": "inelastic collisions", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://en.wikipedia.org/wiki/Coefficient%5Fof%5Frestitution", "text": "coefficients of restitution", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["EDIT: I just noticed that this was covered in another SO question, albeit not specifically for Python.", "You should also check there for some good links."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "another SO question", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/345838/ball-to-ball-collision-detection-and-handling"}]}], [{"text": ["@Pax: Your d-squared version is still computing d.  It should read as follows:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Pax", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/780169/how-do-i-create-collision-detections-for-my-bouncing-balls/780201#780201"}]}, {"code": "<pre>\n<code>\n dsqrd = (y2-y1) * (y2-y1) + (x2-x1) * (x2-x1)\nif (dsqrd &lt; (r1+r2)*(r1+r2)) { ... bang ... }\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think there is somehthing simpler that you guys are missing espeically considering he's using pygame."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Calling the get_rect function can set probably boundraies for the images and Rect that is created, is used for calculating the position of the image and if there are more than one object in the animation, it can be used for detecting collisions.  "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "get_rect", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Rect", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["colliderect &amp; rect can be used, problem is i have no idea how you would implement it especially for an unkown number of balls. "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "colliderect", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "rect", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Keeping in mind it's python."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This doesn't answer you question but you could do the same thing in 3D via python with panda www.panda3d.org."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Like pygame it also has smart ways to do collision detection."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Back in the good old times when CPU cycles were a premium coders used a simple trick to detect collision: they used such colours that they could tell from the pixel colour if it was background or an object.", "This was done on at least some C64 games."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Don't know if you are willing to go this route, though.."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["First you need to check collision with rect.colliderect(other_rect)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "rect.colliderect(other_rect)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["after that if they are colliding, you can check pixel perfect collision.", "So you don't mess with object's radius or shape."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For pixel perfect collision checking, I use Masks:\nMake both mask objects with mask.from_surface, then put them to Mask.overlap function."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "mask.from_surface", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Mask.overlap", "childNum": 0, "tag": "code", "childList": []}]}]]