[[{"text": ["If you can refactor your code to read through the file linearly, then you can just say for line in file to iterate through each line of the file without reading it all into memory at once.", "But, since your file access looks more complicated, you could use a generator to replace readlines().", "One way to do this would be to use itertools.izip or itertools.izip_longest:"], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "for line in file", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "generator", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "readlines()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "itertools.izip", "tag": "a", "pos": 2, "childList": [{"text": "itertools.izip", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.izip"}, {"text": "itertools.izip", "childNum": 0, "tag": "code", "childList": []}, {"text": "itertools.izip_longest", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def four_at_a_time(iterable):\n    \"\"\"Returns an iterator that returns a 4-tuple of objects at a time from the\n       given iterable\"\"\"\n    args = [iter(iterable) * 4]\n    return itertools.izip(*args)\n...\nl1 = four_at_a_time(gzip.open(fastqfile1, 'r'))\nl2 = four_at_a_time(gzip.open(fastqfile2, 'r'))\nfor i, x in enumerate(itertools.izip(l1, l2))\n    # x is now a 2-tuple of 4-tuples of lines (one 4-tuple of lines from the first file,\n    # and one 4-tuple of lines from the second file).  Process accordingly.\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A simple way would be to,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(pseudocode, may contain errors, for illustrative purposes only)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a=gzip.open()\n    b=gzip.open()\n\n    last_four_a_lines=[]\n    last_four_b_lines=[]\n\n    idx=0\n\n    new_a=[]\n    new_b=[]\n\n    while True:\n      la=a.readline()\n      lb=b.readline()\n      if (not la) or (not lb):\n        break\n\n      if idx % 4==3:\n        a_calc=sum([ something ])/len(la)\n        b_calc=sum([ something ])/len(lb)\n        if a_calc and b_calc:\n          for line in last_four_a_lines:\n          new_a.append(line)\n          for line in last_four_b_lines:\n          new_b.append(line)\n\n      last_four_a_lines.append(la)\n      del(last_four_a_lines[0])\n      last_four_b_lines.append(lb)\n      del(last_four_b_lines[0])\n      idx+=1\na.close()\nb.close()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You could use enumerate to iterate over the lines in the file, which would return a count and a line each iteration:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "enumerate", "tag": "a", "pos": 0, "childList": [{"text": "enumerate", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#enumerate"}, {"text": "enumerate", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n with open(file_name) as f:\n    for i, line in enumerate(f):\n        if i % 4 == 3:\n            print i, line\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is how to print all lines containing foo and the previous 3 lines:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n f = open(...)\nprevlines = []\nfor line in f:\n  prevlines.append(line)\n  del prevlines[:-4]\n  if 'foo' in line:\n    print prevlines\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you are reading 2 files at a time (with an equal number of lines), do it like this: "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n f1 = open(...)\nf2 = open(...)\nprevlines1 = []\nfor line1 in f1:\n  prevlines1.append(line1)\n  del prevlines1[:-4]\n  line2 = f2.readline()\n  prevlines2.append(line2)\n  del prevlines2[:-4]\n  if 'foo' in line1 and 'bar' in line2:\n    print prevlines1, prevlines2\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Tricky, because you actually have two files you are processing simultaneously."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can use the fileinput module to efficiently parse a file one line at a time.", "It can be used to parse a list of files too, and you can use the fileinput.nextfile() method within the block to alternate through several files in parallel, consuming one line from each file at a time."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The fileinput.lineno() method will even give you the current line number in the current file.", "You could use temporary lists in the loop body to keep track of your 4-line blocks."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Totally untested ad-hoc code, possibly based on a misunderstanding of what your code does, follows:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n f1 = []\nf2 = []\nfor line in fileinput(filename1, filename2):\n    if fileinput.filename() = filename1:\n        f1.append(line)\n    else:\n        f2.append(line)\n        if fileinput.lineno() % 4 == 3:\n            doMyProcesing()\n            f1 = []; f2 = []\n    fileinput.nextfile()\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I think that improving the obtention of l1 and l2 isn't sufficient: you must improve your code globally"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I propose:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\n\nimport os\nimport sys\nimport gzip\n\npath= '/home/xxx/scratch/'\n\ndef gen(gfa,gfb):\n    try:\n        a = (gfa.readline(),gfa.readline(),gfa.readline(),gfa.readline())\n        b = (gfb.readline(),gfb.readline(),gfb.readline(),gfb.readline())\n        if sum(imap(ord,a[3]))/float(len(a[3])) &gt;= 20 \\\n           and sum(imap(ord,b[3]))/float(len(b[3])) &gt;= 20:\n            yield (a,b)\n    except:\n        break\n\nfor fastqfile1 in glob.glob(path + '*_1.recal.fastq.gz') :\n    pji = path + os.path.basename(fastqfile1).split('_')[0] # pji = path + job_id\n\n    gf1= gzip.open(fastqfile1,'r')\n    gf2= gzip.open(os.path.join(pji + '_2.recal.fastq.gz'),'r')\n\n    output1=gzip.open(os.path.join(pji + '_1.fastq.gz'),'w')\n    output2=gzip.open(os.path.join(pji + '_2.fastq.gz'),'w')\n\n    for lines1,lines2 in gen(gf1,gf2):\n        output1.writelines(lines1)\n        output2.writelines(lines2)\n\n    output1.close()\n    output2.close()\n</code>\n</pre>\n", "senID": 2}, {"text": ["It should diminish the execution's time by 30 %.", "Pure guess."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["PS:   "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["code  "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n if sum(imap(ord,a[3]))/float(len(a[3])) &gt;= 20 \\\n   and sum(imap(ord,b[3]))/float(len(b[3])) &gt;= 20:\n</code>\n</pre>\n", "senID": 6}, {"text": ["is executed more rapidly rather than "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n ave1 = sum(imap(ord,a[3]))/float(len(a[3])) \nave2 = sum(imap(ord,b[3]))/float(len(b[3]))\nif ave1 &gt;= 20 and ave2 &gt;=20:\n</code>\n</pre>\n", "senID": 8}, {"text": ["because if ave1 isn't greater than 20, the object ave2 isn't evaluated."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "ave1", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "ave2", "childNum": 0, "tag": "strong", "childList": []}]}]]