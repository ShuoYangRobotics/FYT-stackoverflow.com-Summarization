[[{"text": ["Java doesn't have first-class methods, so the command pattern is your friend..."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "command pattern", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Command%5Fpattern"}]}, {"text": ["disclamer: code not tested!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n public interface Command \n{\n    void invoke();\n}\n\nMap&lt;String, Command&gt; commands = new HashMap&lt;String, Command&gt;();\ncommands.put(\"function1\", new Command() \n{\n    public void invoke() { System.out.println(\"hello world\"); }\n});\n\ncommands.get(\"function1\").invoke();\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You could use a Map&lt;String,Method> or Map&lt;String,Callable> etc,and then use map.get(\"function1\").invoke(...).", "But usually these kinds of problems are tackled more cleanly by using polymorphism instead of a lookup."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["There are several ways to approach this problem.", "Most of these were posted already:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["Commands"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["Polymorphism"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}, {"text": "Finally there is Reflection - You can use reflection to get references to java.lang.Method objects.  For a set of known classes/methods, this works fairly well and there isn't too much overhead once you load the Method objects.  You could use this to, for example, allow a user to type java code into a command line, which you execute in real time.", "tag": "none", "senID": 3}]}, {"text": ["Personally I would use the Command approach.", "Commands combine well with Template Methods, allowing you to enforce certain patterns on all your command objects.", "Example:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Template Methods", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Template%5Fmethod%5Fpattern"}]}, {"code": "<pre>\n<code>\n public abstract class Command {\n  public final Object execute(Map&lt;String, Object&gt; args) {\n    // do permission checking here or transaction management\n    Object retval = doExecute(args);\n    // do logging, cleanup, caching, etc here\n    return retval;\n  }\n  // subclasses override this to do the real work\n  protected abstract Object doExecute(Map&lt;String, Object&gt; args);\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["I would resort to reflection only when you need to use this kind of mapping for classes whose design you don't control, and for which it's not practical to make commands.", "For example, you couldn't expose the Java API in a command-shell by making commands for each method."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Polymorphic example.."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n public interface Animal {public void speak();};\npublic class Dog implements Animal {public void speak(){System.out.println(\"treat? treat? treat?\");}}\npublic class Cat implements Animal {public void speak(){System.out.println(\"leave me alone\");}}\npublic class Hamster implements Animal {public void speak(){System.out.println(\"I run, run, run, but never get anywhere\");}}\n\nMap&lt;String,Animal&gt; animals = new HashMap&lt;String,Animal&gt;();\nanimals.put(\"dog\",new Dog());\nanimals.put(\"cat\",new Cat());\nanimals.put(\"hamster\",new Hamster());\nfor(Animal animal : animals){animal.speak();}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["As mentioned in other questions, a Map&lt;String,MyCommandType&gt; with anonymous inner classes is one verbose way to do it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Map&lt;String,MyCommandType&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["A variation is to use enums in place of the anonymous inner classes.", "Each constant of the enum can implement/override methods of the enum or implemented interface, much the same as the anonymous inner class technique but with a little less mess.", "I believe Effective Java 2nd Ed deals with how to initialise a map of enums.", "To map from the enum name merely requires calling MyEnumType.valueOf(name)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "MyEnumType.valueOf(name)", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["Unfortunately, Java does not have first-class functions, but consider the following interface:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n public interface F&lt;A, B&gt; {\n  public B f(A a);\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["This models the type for functions from type A to type B, as first-class values that you can pass around.", "What you want is a Map&lt;String, F&lt;A, B&gt;&gt;."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "A", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "B", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Map&lt;String, F&lt;A, B&gt;&gt;", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Functional Java is a fairly complete library centered around first-class functions."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Functional Java", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/functionaljava"}]}], [{"text": ["As everyone else said, Java doesn't support functions as first-level objects.", "To achieve this, you use a Functor, which is a class that wraps a function.", "Steve Yegge has a nice rant about that."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "nice rant", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html"}]}, {"text": ["To help you with this limitation, people write functor libraries: jga, Commons Functor"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "jga", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://jga.sourceforge.net/"}, {"href": "http://commons.apache.org/sandbox/functor/", "text": "Commons Functor", "childNum": 0, "tag": "a", "childList": []}]}]]