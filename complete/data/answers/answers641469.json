[[{"code": "<pre>\n<code>\n dispatch = {\n  'check': do_check,\n  'search': do_search,\n}\ncmd, _, arg = input.partition(' ')\nif cmd in dispatch:\n    dispatch[cmd](arg)\nelse:\n    do_default(cmd, arg)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Not really.", "You code is simple, clear, obvious and English-like."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Yes, you've seen them and they're not clear, obvious or English-like.", "They exist because some people like to wring their hands over the switch statement."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Correct.", "They work.", "They're simple, clear, ..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Your code is good.", "Leave it alone.", "Move on."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This lets you avoid giving each command name twice; function names are used almost directly as command names."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class CommandFunctions:\n    def c_check(self, arg):\n        print \"checking\", arg\n\n    def c_search(self, arg):\n        print \"searching for\", arg\n\n    def c_compare(self, arg1, arg2):\n        print \"comparing\", arg1, \"with\", arg2\n\n    def execute(self, line):\n        words = line.split(' ')\n        fn = getattr(self, 'c_' + words[0], None)\n        if fn is None:\n            import sys\n            sys.stderr.write('error: no such command \"%s\"\\n' % words[0])\n            return\n        fn(*words[1:])\n\ncf = CommandFunctions()\nimport sys\nfor line in sys.stdin:\n    cf.execute(line.strip())\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you're looking for a one liner 'pythonic' approach to this you can use this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def do_check(x): print 'checking for:', x\ndef do_search(x): print 'searching for:', x\n\ninput = 'check yahoo.com'\n{'check': do_check}.get(input.split()[0], do_search)(input.split()[1])\n# checking for: yahoo.com\n\ninput = 'search google.com'\n{'check': do_check}.get(input.split()[0], do_search)(input.split()[1])\n# searching for: google.com\n\ninput = 'foo bar.com'\n{'check': do_check}.get(input.split()[0], do_search)(input.split()[1])\n# searching for: bar.com\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Disregard, I just realized that my answer was similar to one of the other answers - and apparently there's no delete key :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Variation on @MizardX's answer:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@MizardX's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/641469/pythonic-equivalent-for-handling-switch-and-multiple-string-compares/641485#641485"}]}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\ndispatch = defaultdict(do_default, check=do_check, search=do_search)\ncmd, _, arg = input.partition(' ')\ndispatch[cmd](arg)\n</code>\n</pre>\n", "senID": 1}]]