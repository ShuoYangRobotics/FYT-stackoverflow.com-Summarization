[[{"code": "<pre>\n<code>\n import operator\nmin(apple.values(), key=operator.itemgetter('size'))\n</code>\n</pre>\n", "senID": 0}, {"text": ["will return you "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n {'color': 'green', 'size': 10}\n</code>\n</pre>\n", "senID": 2}, {"text": ["UPDATE: to get the index:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n min(apple, key=lambda k: apple[k]['size'])\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Python has a very nice parameter for the min function that allows using an arbitrary function to be minified instead of just using comparison on the elements:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "min", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n result = min(apple.values(), key=lambda x:x['size'])\n</code>\n</pre>\n", "senID": 1}, {"text": ["The key parameter replaced in most cases the older idiom of decorate-process-undecorate that could have been applied here:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "key", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n result = min((x['size'], x) for x in apple.values())[1]\n</code>\n</pre>\n", "senID": 3}, {"text": ["If instead you want to know the number (key) of the apple (it's not clear in the question) then:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n result = min(apple.keys(), key=lambda x:apples[x]['size'])\n</code>\n</pre>\n", "senID": 5}, {"text": ["or (old style)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n result = min((apples[x]['size'], x) for x in apple.keys())[1]\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Use min with a custom key function that returns the size of each item."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "min", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "key", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n apple = {1:{'size':12,'color':'red'},2:{'size':10,'color':'green'}}\nprint min(apple.keys(), key=lambda k, a=apple: a[k]['size'])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 2\n</code>\n</pre>\n", "senID": 3}, {"text": ["P.S.", "Since apple is a collection I would make it plural -- apples."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "apple", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "apples", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Don't know if it's the fastest way to do it, but anyway:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; apple = [ {'size':12, 'color': 'red' }, { 'size':10, 'color':'green'} ]\n&gt;&gt;&gt; a = dict(map(lambda apple: (apple['size'], apple), apple))\n&gt;&gt;&gt; a\n{10: {'color': 'green', 'size': 10}, 12: {'color': 'red', 'size': 12}}\n&gt;&gt;&gt; min = a[min(a.keys())]\n&gt;&gt;&gt; min\n{'color': 'green', 'size': 10}\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def get_min(apple):\n    L = apple.values()\n    m = L[0]\n    for item in L:\n        if item['size'] &lt; m['size']:\n            m = item\n    return m\n</code>\n</pre>\n", "senID": 0}, {"text": ["P.S.", "Not very pythonic but linear time"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["min(map(lambda a:[apple[a]['size'],a], apple))[1]"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "min(map(lambda a:[apple[a]['size'],a], apple))[1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]