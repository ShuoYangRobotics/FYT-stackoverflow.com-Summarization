[[{"text": ["If you have a really immutable dictionary (although it isn't clear to me why you don't use just a list of pairs: e. g. [('content-type': 'text/plain'), ('host', 'example.com')]), then you may convert your dict into:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "[('content-type': 'text/plain'), ('host', 'example.com')]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If I needed to use dictionaries as keys, I would flatten the dictionary into a tuple of tuples."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You might find this SO question useful: http://stackoverflow.com/questions/635483/what-is-the-best-way-to-implement-nested-dictionaries-in-python"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://stackoverflow.com/questions/635483/what-is-the-best-way-to-implement-nested-dictionaries-in-python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/635483/what-is-the-best-way-to-implement-nested-dictionaries-in-python"}]}, {"text": ["And here is an example of a flatten module that will flatten dictionaries: http://yawpycrypto.sourceforge.net/html/public/Flatten.Flatten-module.html"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://yawpycrypto.sourceforge.net/html/public/Flatten.Flatten-module.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://yawpycrypto.sourceforge.net/html/public/Flatten.Flatten-module.html"}]}, {"text": ["I don't fully understand your use case and I suspect that you are trying to prematurely optimize something that doesn't need optimization. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["One way to do this would be to subclass the dict and provide a hash method.", "ie:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class HashableDict(dict):\n    def __hash__(self):\n        return hash(tuple(sorted(self.iteritems())))\n\n&gt;&gt;&gt; d = HashableDict(a=1, b=2)\n&gt;&gt;&gt; d2 = { d : \"foo\"}\n&gt;&gt;&gt; d2[HashableDict(a=1, b=2)]\n\"foo\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, bear in mind the reasons why dicts (or any mutable types) don't do this: mutating the object after it has been added to a hashtable will change the hash, which means the dict will now have it in the wrong bucket, and so incorrect results will be returned."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you go this route, either be very sure that dicts will never change after they have been put in the other dictionary, or actively prevent them (eg.", "check that the hash never changes after the first call to __hash__, and throw an exception if not."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "very", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "__hash__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Hmm, isn't your use case just memoizing function calls?", "Using a decorator, you will have easy support for arbitrary functions.", "And yes, they often pickle the arguments, and using circular reasoning, this works for non-standard types as long as they can be pickled."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["See e.g.", "this memoization sample"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "this memoization sample", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.finalcog.com/python-memoise-memoize-function-type"}]}], [{"text": ["To turn a someDictionary into a key, do this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n key = tuple(sorted(someDictionary .items())\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can easily reverse this with dict( key )"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "dict( key )", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I don't see why you'd ever want to do this, but if you really really do need to, you could try pickling the dictionary:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n mydict = {\"a\":1, \"b\":{\"c\":10}}\nimport pickle\nkey = pickle.dumps(mydict)\n\nd[key] = value\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I don't know whether I understand your question correctly, but i'll give it a try"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d[repr(a)]=value\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can interate over the dictionary like this"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for el1 in d:\n        for el2 in eval(el1):\n                print el2,eval(el1)[el2]\n</code>\n</pre>\n", "senID": 3}]]