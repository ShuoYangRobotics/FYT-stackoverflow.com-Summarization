[[{"code": "<pre>\n<code>\n set(open(file1)) &amp; set(open(file2))\n</code>\n</pre>\n", "senID": 0}, {"text": ["which is equivalent to using intersection, is the most Pythonic way.", "You might be able to speed it up by doing"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "intersection", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n set(int(x) for x in open(file1)) &amp; set(int(x) for x in open(file2))\n</code>\n</pre>\n", "senID": 2}, {"text": ["since then you'll be storing and comparing integers rather than strings.", "This only works if all ids are numeric, of course."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If it's still not fast enough, you can turn to a slightly more imperative style:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n # heuristic: set smaller_file and larger_file by checking the file size\na = set(int(x) for x in open(smaller_file))\n# note: we're storing strings in r\nr = set(x for x in open(larger_file) if int(x) in a)\n</code>\n</pre>\n", "senID": 5}, {"text": ["If both files are guaranteed not to contain duplicates, you can also use a list to speed things up:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n a = set(int(x) for x in open(smaller_file))\nr = [x for x in open(larger_file) if int(x) in a]\n</code>\n</pre>\n", "senID": 7}, {"text": ["Be sure to measure various solutions, and check whether you're not actually waiting for disk or network input."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["So the algorithm is not necessarily tied to python, but rather generic if you cannot represent all ids in a set in memory.", "If the range of the integers is limited, an approach would be to use a large bitarray.", "Now you read the first file and set the integer in the bitarray to be present.", "Now you read the second file, and output all numbers that are also present in the bitarray."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "bitarray", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/bitarray/"}, {"text": "bitarray", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "bitarray", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["If even this is not sufficient, you can split the range using multiple sweeps.", "I.e.", "in the first pass, you only consider integers smaller than 0x200000000 (1GB bitarray).", "Then you reset the bitarray and read the files again only considering integers from 0x200000000 to 0x400000000 (and substract 0x200000000 before handling the integer)."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "bitarray", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "bitarray", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "0x200000000", "childNum": 0, "tag": "code", "childList": []}, {"text": "0x400000000", "childNum": 0, "tag": "code", "childList": []}, {"text": "0x200000000", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This way you can handle LARGE amounts of data, with reasonable runtime."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["A sample for single sweep would be:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import bitarray\nr = bitarray.bitarray(5000000000)\n\nfor line in open(file1):\n    r[int(line)] = True\n\nfor line in open(file2):\n    if r[int(line)]:\n        print line\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You need not create both s1 and s2.", "First read in the lines from the first file, convert each line to integer (saves memory), put it in s1.", "Then for each line in the second file, convert it to integer, and check if this value is in s1."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "both", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "s1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "s2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "s1", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "s1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["That way, you'll save memory from storing strings, and from having two sets."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["AFAIK there is no efficient way to do this with Python, especially if you are dealing with massive amounts of data."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I like rumpel's solution.", "But please note that bitarray is a C extension."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "rumpel", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/7331700/how-can-i-find-intersection-of-two-large-file-efficiently-using-python/7331979#7331979"}, {"text": "bitarray", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/bitarray/"}]}, {"text": ["I would use shell commands to handle this.", "You can pre-process files to save time &amp; space:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n sort -u file1 file1.sorted\nsort -u file2 file2.sorted\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then you can use diff to find out the similarities:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "diff", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n diff --changed-group-format='' --unchanged-group-format='%=' file1.sorted file2.sorted\n</code>\n</pre>\n", "senID": 5}, {"text": ["Of course it is possible to combine everything into a single command, without creating intermediary files."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["UPDATE"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "UPDATE", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["According to Can's recommendation, comm is the more appropriate command:"], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "Can", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/283032/can-burak-cilingir"}, {"href": "http://ss64.com/bash/comm.html", "text": "comm", "childNum": 1, "tag": "a", "childList": [{"text": "comm", "tag": "code"}]}, {"text": "comm", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n sort -u file1 file1.sorted\nsort -u file2 file2.sorted\ncomm -12 file1.sorted file2.sorted\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Others have shown the more idiomatic ways of doing this in\nPython, but if the size of the data really is too big, you can\nuse the system utilities to sort and eliminate duplicates, then\nuse the fact that a File is an iterator which returns one line\nat a time, doing something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\nos.system('sort -u -n s1.num &gt; s1.ns')\nos.system('sort -u -n s2.num &gt; s2.ns')\ni1 = open('s1.ns', 'r')\ni2 = open('s2.ns', 'r')\ntry:\n    d1 = i1.next()\n    d2 = i2.next()\n    while True:\n        if (d1 &lt; d2):\n            d1 = i1.next()\n        elif (d2 &lt; d1):\n            d2 = i2.next()\n        else:\n            print d1,\n            d1 = i1.next()\n            d2 = i2.next()\nexcept StopIteration:\n    pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["This avoids having more than one line at a time (for each file)\nin memory (and the system sort should be faster than anything\nPython can do, as it is optimized for this one task)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["for data larger then memory, you can split your data file into 10 files, which contain the same lowest digital."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["so all ids in s1.txt that ends with 0 will be saved in s1_0.txt."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Then use set() to find the intersection of s1_0.txt and s2_0.txt, s1_1.txt and s2_1.txt, ... "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]