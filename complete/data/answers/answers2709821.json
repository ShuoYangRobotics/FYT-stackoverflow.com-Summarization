[[{"text": ["The reason you need to use self.", "is because Python does not use the @ syntax to refer to instance attributes.", "Python decided to do methods in a way that makes the instance to which the method belongs be passed automatically, but not received automatically: the first parameter of methods is the instance the method is called on.", "That makes methods entirely the same as functions, and leaves the actual name to use up to you (although self is the convention, and people will generally frown at you when you use something else.", ") self is not special to the code, it's just another object."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "self.", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "@", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "passed", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "received", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"text": ["Python could have done something else to distinguish normal names from attributes -- special syntax like Ruby has, or requiring declarations like C++ and Java do, or perhaps something  yet more different -- but it didn't.", "Python's all for making things explicit, making it obvious what's what, and although it doesn't do it entirely everywhere, it does do it for instance attributes.", "That's why assigning to an instance attribute needs to know what instance to assign to, and that's why it needs self.."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "self.", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["I have been confused by this as well for quite a while and I don\u2019t believe that the reason for this has got much to do with the often-pronounced explicit is better than implicit but that it is just following a simple analogy there."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "explicit is better than implicit", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Let\u2019s take a simple vector class:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Vector(object):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now, we want to have a method which calculates the length.", "What would it look like if we wanted to define it inside the class?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def length(self):\n        return math.sqrt(self.x ** 2 + self.y ** 2)\n</code>\n</pre>\n", "senID": 4}, {"text": ["And, what should it look like when we were to define it as a global method/function?"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def length_global(vector):\n    return math.sqrt(vector.x ** 2 + vector.y ** 2)\n</code>\n</pre>\n", "senID": 6}, {"text": ["So, the whole structure stays the same.", "Now, how can me make use of this?", "If we assume for a moment that we hadn\u2019t written a length method for our Vector class, we could do this:"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "length", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "Vector", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n Vector.length_new = length_global\nv = Vector(3, 4)\nprint v.length_new() # 5.0\n</code>\n</pre>\n", "senID": 8}, {"text": ["This works, because the first parameter of length_global, can be re-used as the self parameter in length_new.", "This would not be possible without an explicit self."], "childNum": 4, "tag": "p", "senID": 9, "childList": [{"text": "length_global", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "length_new", "childNum": 0, "tag": "code", "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Another way of understanding the need for the explicit self is to see where Python adds some syntactical sugar.", "When you keep in mind, that basically, a call like"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n v_instance.length()\n</code>\n</pre>\n", "senID": 11}, {"text": ["is internally transformed to"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n Vector.length(v_instance)\n</code>\n</pre>\n", "senID": 13}, {"text": ["it is easy to see where the self fits in.", "You don\u2019t not actually write instance methods in Python; what you write is class methods which (must) take an instance as a first parameter.", "And therefore, you\u2019ll have to place the instance parameter somewhere explicitly."], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The following excerpts are from the Python documentation about self:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python documentation about self", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html"}]}, {"text": ["For more information, see the Python documentation tutorial on classes."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Python documentation tutorial on classes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html"}]}], [{"text": ["As well as all the other reasons already stated, it allows for easier access to overridden methods."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can call Class.some_method(inst)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["example of where it's useful:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class C1(object):\n    def __init__(self):\n         print \"C1 init\"\n\nclass C2(C1):\n    def __init__(self): #overrides C1.__init__\n        print \"C2 init\"\n        C1.__init__(self) #but we still want C1 to init the class too\n</code>\n</pre>\n", "senID": 3}, {"tag": "br", "senID": 4}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; C2()\n\"C2 init\"\n\"C1 init\"\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I will demonstrate with code that does not use classes:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "does not use classes", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def state_init(state):\n    state['field'] = 'init'\n\ndef state_add(state, x):\n    state['field'] += x\n\ndef state_mult(state, x):\n    state['field'] *= x\n\ndef state_getField(state):\n    return state['field']\n\nmyself = {}\nstate_init(myself)\nstate_add(myself, 'added')\nstate_mult(myself, 2)\n\nprint( state_getField(myself) )\n#--&gt; 'initaddedinitadded'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Classes are just a way to avoid passing in this \"state\" thing all the time (and other nice things like initializing, class composition, the rarely-needed metaclasses, and supporting custom methods to override operators)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Now let's demonstrate the above code using the built-in python class machinery, to show how it's basically the same thing."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class State(object):\n    def __init__(self):\n        self.field = 'init'\n    def add(self, x):\n        self.field += x\n    def mult(self, x):\n        self.field *= x\n\ns = State()\ns.add('added')    # self is implicitly passed in\ns.mult(2)         # self is implicitly passed in\nprint( s.field )\n</code>\n</pre>\n", "senID": 4}, {"text": ["[migrated my answer from duplicate closed question]"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["self is an object reference to the object itself, therefore, they are same.", "Python methods are not called in the context of the object itself.", "self in Python may be used to deal with custom object models or something."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I like this example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class A: \n    foo = []\na, b = A(), A()\na.foo.append(5)\nb.foo\nans: [5]\n\nclass A: \n    def __init__(self): \n        self.foo = []\na, b = A(), A()\na.foo.append(5)\nb.foo\nans: []\n</code>\n</pre>\n", "senID": 1}], [{"text": ["it's an explicit reference to the class instance object. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import this\n</code>\n</pre>\n", "senID": 0}]]