[[{"text": ["The list comprehension is the asymptotically optimal solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n somelist = [x for x in somelist if not determine(x)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["It only makes one pass over the list, so runs in O(n) time.", "Since you need to call determine() on each object, any algorithm will require at least O(n) operations.", "The list comprehension does have to do some copying, but it's only copying references to the objects not copying the objects themselves."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Removing items from a list in Python is O(n), so anything with a remove, pop, or del inside the loop will be O(n**2)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Also, in CPython list comprehensions are faster than for loops."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If you need to remove item in O(1) you can use HashMaps"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Since list.remove is equivalent to del list[list.index(x)], you could do:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "list.remove", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "del list[list.index(x)]", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n for idx, item in enumerate(somelist):\n    if determine(item):\n        del somelist[idx]\n</code>\n</pre>\n", "senID": 1}, {"text": ["But: you should not modify the list while iterating over it.", "It will bite you, sooner or later.", "Use filter or list comprehension first, and optimise later."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "filter", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["A deque is optimized for head and tail removal, not for arbitrary removal in the middle.", "The removal itself is fast, but you still have to traverse the list to the removal point.", "If you're iterating through the entire length, then the only difference between filtering a deque and filtering a list (using filter or a comprehension) is the overhead of copying, which at worst is a constant multiple; it's still a O(n) operation.", "Also, note that the objects in the list aren't being copied -- just the references to them.", "So it's not that much overhead."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "filter", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["It's possible that you could avoid copying like so, but I have no particular reason to believe this is faster than a straightforward list comprehension -- it's probably not: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n write_i = 0\nfor read_i in range(len(L)):\n    L[write_i] = L[read_i]\n    if L[read_i] not in ['a', 'c']:\n         write_i += 1\ndel L[write_i:]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["What about using filter?", "It retains or removes elements based on a predicate, which seems to be exactly what you're trying to do."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "filter", "tag": "a", "pos": 0, "childList": [{"text": "filter", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/tutorial/datastructures.html#functional-programming-tools"}, {"text": "filter", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "predicate", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Boolean-valued_function"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def f(x): return x % 2 != 0 and x % 3 != 0\n...\n&gt;&gt;&gt; filter(f, range(2, 25))\n[5, 7, 11, 13, 17, 19, 23]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I took a stab at this.", "My solution is slower, but requires less memory overhead (i.e.", "doesn't create a new array).", "It might even be faster in some circumstances!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This code has been edited since its first posting"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "This code has been edited since its first posting", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I had problems with timeit, I might be doing this wrong."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import timeit\nsetup = \"\"\"\n\nimport random\nrandom.seed(1)\nglobal b\nsetup_b = [(random.random(), random.random()) for i in xrange(1000)]\nc = []\ndef tokeep(x):\n        return (x[1]&gt;.45) and (x[1]&lt;.5)\n\n\n# define and call to turn into psyco bytecode (if using psyco)\nb = setup_b[:]\ndef listcomp():\n   c[:] = [x for x in b if tokeep(x)]\nlistcomp()\n\nb = setup_b[:]\ndef filt():\n   c = filter(tokeep, b)\nfilt()\n\nb = setup_b[:]\ndef forfilt():\n   marked = (i for i, x in enumerate(b) if tokeep(x))\n   shift = 0\n   for n in marked:\n      del b[n - shift]\n      shift += 1\nforfilt()\n\nb = setup_b[:]\ndef forfiltCheating():\n   marked = (i for i, x in enumerate(b) if (x[1] &gt; .45) and (x[1] &lt; .5))\n\n   shift = 0\n   for n in marked:\n      del b[n - shift]\n      shift += 1\nforfiltCheating()\n\n\"\"\"\n\nlistcomp = \"\"\"\nb = setup_b[:]\n\nlistcomp()\n\"\"\"\n\nfilt = \"\"\"\nb = setup_b[:]\n\nfilt()\n\"\"\"\n\nforfilt = \"\"\"\nb = setup_b[:]\n\nforfilt()\n\"\"\"\n\nforfiltCheating = '''\nb = setup_b[:]\n\nforfiltCheating()\n'''\n\npsycosetup = '''\n\nimport psyco\npsyco.full()\n\n\n'''\n\nprint \"list comp = \", timeit.timeit(listcomp, setup, number = 10000)\nprint \"filtering = \", timeit.timeit(filt, setup, number = 10000)\nprint 'forfilter = ', timeit.timeit(forfilt, setup, number = 10000)\nprint 'forfiltCheating = ', timeit.timeit(forfiltCheating, setup, number = 10000)\n\n\nprint '\\nnow with psyco \\n'\nprint \"list comp = \", timeit.timeit(listcomp, psycosetup + setup, number = 10000)\nprint \"filtering = \", timeit.timeit(filt, psycosetup + setup, number = 10000)\nprint 'forfilter = ', timeit.timeit(forfilt, psycosetup + setup, number = 10000)\nprint 'forfiltCheating = ', timeit.timeit(forfiltCheating, psycosetup + setup, number = 10000)\n</code>\n</pre>\n", "senID": 3}, {"text": ["And here are the results"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n list comp =  6.56407690048\nfiltering =  5.64738512039\nforfilter =  7.31555104256\nforfiltCheating =  4.8994679451\n\nnow with psyco \n\nlist comp =  8.0485959053\nfiltering =  7.79016900063\nforfilter =  9.00477004051\nforfiltCheating =  4.90830993652\n</code>\n</pre>\n", "senID": 5}, {"text": ["I must be doing something wrong with psyco, because it is actually running slower."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]