[[{"text": ["Take a look at the xmlstream module in jabberpy (also available from twisted):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "xmlstream", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://jabberpy.sourceforge.net/docs/xmlstream.html"}, {"href": "http://twistedmatrix.com/documents/current/words/examples/index.html", "text": "twisted", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["If the document never gets an close-tag for an element in the document, then it isn't correctly formed XML, which is going to play havoc with any XML parser."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That said, using the Python SAX2 API would seem to be the best approach, but you're going to have to determine what exception will be thrown by the missing close-tag, catch it, and handle it yourself."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Added"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Added", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Assume that you're receiving an XML document like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &lt;? xml version=\"1.0\" ?&gt;\n&lt;foo&gt;\n  &lt;bar&gt;...&lt;/bar&gt;\n  &lt;bar&gt;...&lt;/bar&gt;\n  &lt;bar&gt;...&lt;/bar&gt;\n  &lt;bar&gt;...&lt;/bar&gt;\n  ...\n</code>\n</pre>\n", "senID": 4}, {"text": ["And you never receive a closing &lt;/foo&gt;.", "In this case, a SAX parser that is reacting to the bar elements will issue a stream of events for startElement(bar) and endElement(bar).", "Presumably you'll gather up all of the data between the start and the end, and then process it all at one shot once you see the end event.  "], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "&lt;/foo&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "bar", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "startElement(bar)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "endElement(bar)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The only way to stop this loop is going to be through outside action:  define in advance the number of bar elements to process, or define in advance the amount of time you want to devote to receiving bar events.", "Run the SAX parser in a thread and then kill the thread when you hit your limit.", "You'll want to have your main process sleep while waiting on the sax-parser thread to finish."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "bar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "bar", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["I assume your XML is basically a list of identical XML elements gathered under one container element.", "Something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &lt;items&gt;\n  &lt;item&gt;\n    &lt;!-- content here --&gt;\n  &lt;/item&gt;\n  &lt;item&gt;\n    &lt;!-- content here --&gt;\n  &lt;/item&gt;\n  &lt;item&gt;\n    &lt;!-- content here --&gt;\n  &lt;/item&gt;\n&lt;/items&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["In SAX when your parser gets and end  event, you can parse the completed item, clear the stack, and pass the item on to whatever other code should be handling parsed items."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def process(item) :\n  # App logic goes here\n\nclass ItemsHandler(xml.sax.handler.ContentHandler) :\n  # Omitting __init__, startElement, and characters methods\n  # to store data on a stack during processing\n\n  def endElement(self, name) :\n    if name == \"item\" :\n      # create item from stored data on stack\n      parsed_item = self.parse_item_from_stack()\n      process(parsed_item)\n</code>\n</pre>\n", "senID": 3}, {"text": ["If the application logic is complicated enough, you'll want to put the SAX parsing in a separate thread so you don't miss events."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If the document is endless why not add end tag (of main element) manually before opening it in parser?", "I don't know Python but why not add &lt;/endtag&gt; to string?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "&lt;/endtag&gt;", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I can not provide a solution in Python right away, but will give you a hint."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That kind of XML parsing is handled by StAX parsers.", "The problem here is that a SAX-parser pushes events, but StAX provives interface for pulling events.", "StAX is mainly used for partial XML parsing (parsing only headers from a SOAP message), and this seems to be your case."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "StAX", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/StAX"}]}, {"text": ["I have not seen a StAX-like parsers in Python standard library, but there should definetely be  one."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["UPD: lxml (as a wrapper tp libxml2) seems to have similar functinality."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "similar functinality", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://codespeak.net/lxml/parsing.html#iterparse-and-iterwalk"}]}], [{"text": ["This is what I use for parsing an endless xml stream which I get from a remote computer (in my case I connect over a socket and use socket.makefile('r') to create the file object)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["19.12.2.", "IncrementalParser Objects"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "19.12.2. IncrementalParser Objects", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/xml.sax.reader.html#incrementalparser-objects"}]}, {"code": "<pre>\n<code>\n parser = xml.sax.make_parser(['xml.sax.IncrementalParser'])\nhandler = FooHandler()\nparser.setContentHandler(handler)\n\ndata = sockfile.readline()\nwhile ( len(data) != 0 ):\n    parser.feed(data)\n    data = sockfilefile.readline()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You can use the iterparse function from the xml.etree.ElementTree (or cElementTree for speed) in the stdlib.", "(you could also use lxml)"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "iterparse", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "xml.etree.ElementTree", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "cElementTree", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "lxml", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The trick is described here: http://effbot.org/zone/element-iterparse.htm#incremental-parsing"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://effbot.org/zone/element-iterparse.htm#incremental-parsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/element-iterparse.htm#incremental-parsing"}]}, {"text": ["The example describes exactly what you need.", "It doesn't mention anything about endless files, but it will work.", "(it will just keep on going).", "Most importantly: don't forget to clear the root element."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Easy and available in the stdlib ;-)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]