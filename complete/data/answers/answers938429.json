[[{"text": ["When a lambda is created, it doesn't make a copy of the variables in the enclosing scope that it uses.", "It maintains a reference to the environment so that it can look up the value of the variable later.", "There is just one m. It gets assigned to every time through the loop.", "After the loop, the variable m has value 'mi'.", "So when you actually run the function you created later, it will look up the value of m in the environment that created it, which will by then have value 'mi'."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "m", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "m", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "'mi'", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "m", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "'mi'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["One common and idiomatic solution to this problem is to capture the value of m at the time that the lambda is created by using it as the default argument of an optional parameter.", "You usually use a parameter of the same name so you don't have to change the body of the code:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "m", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for m in ('do', 're', 'mi'):\n    funcList.append(lambda m=m: callback(m))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The problem here is m variable (a reference) being taken from surrounding scope.", "Only parameters are hold in lambda scope."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "m", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["To solve this you have to create another scope for lambda:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def callback(msg):\n    print msg\n\ndef callback_factory(m):\n    return lambda: callback(m)\n\nfuncList=[]\nfor m in ('do', 're', 'mi'):\n    funcList.append(callback_factory(m))\nfor f in funcList:\n    f()\n</code>\n</pre>\n", "senID": 2}, {"text": ["In example above lambda also uses surounding scope to find m but this\ntime it's callback_factory scope created per every callback_factory\ncall."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "m", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "callback_factory", "childNum": 0, "tag": "code", "childList": []}, {"text": "callback_factory", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Or with functools:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "functools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functools.html#partial-objects"}]}, {"code": "<pre>\n<code>\n from functools import partial\n\ndef callback(msg):\n    print msg\n\nfuncList=[partial(callback, m) for m in ('do', 're', 'mi')]\nfor f in funcList:\n    f()\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Python does uses references of course, but it does not matter in this context."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When you define a lambda (or a function, since this is the exact same behavior), it does not evaluate the lambda expression before runtime:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # defining that function is perfectly fine\ndef broken():\n    print undefined_var\n\nbroken() # but calling it will raise a NameError\n</code>\n</pre>\n", "senID": 2}, {"text": ["Even more surprising than your lambda example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n i = 'bar'\ndef foo():\n    print i\n\nfoo() # bar\n\ni = 'banana'\n\nfoo() # you would expect 'bar' here? well it prints 'banana'\n</code>\n</pre>\n", "senID": 4}, {"text": ["In short, think dynamic: nothing is evaluated before interpretation, that's why your code uses the latest value of m."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["When it looks for m in the lambda execution, m is taken from the topmost scope, which means that, as others pointed out; you can circumvent that problem by adding another scope:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def factory(x):\n    return lambda: callback(x)\n\nfor m in ('do', 're', 'mi'):\n    funcList.append(factory(m))\n</code>\n</pre>\n", "senID": 7}, {"text": ["Here, when the lambda is called, it looks in the lambda' definition scope for a x.", "This x is a local variable defined in factory's body.", "Because of this, the value used on lambda execution will be the value that was passed as a parameter during the call to factory.", "And doremi!"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["As a note, I could have defined factory as factory(m) [replace x by m], the behavior is the same.", "I used a different name for clarity :)"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["You might find that Andrej Bauer got similar lambda problems.", "What's interesting on that blog is the comments, where you'll learn more about python closure :)"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Andrej Bauer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://math.andrej.com/2009/04/09/pythons-lambda-is-broken/"}]}], [{"text": ["First, what you are seeing is not a problem, and not related to call-by-reference or by-value."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The lambda syntax you defined has no parameters, and as such, the scope you are seeing with parameter m is external to the lambda function.", "This is why you are seeing these results."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "m", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Lambda syntax, in your example is not necessary, and you would rather be using a simple function call:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for m in ('do', 're', 'mi'):\n    callback(m)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Again, you should be very precise about what lambda parameters you are using and where exactly their scope begins and ends."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["As a side note, regarding parameter passing.", "Parameters in python are always references to objects.", "To quote Alex Martelli:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["The variable m is being captured, so your lambda expression always sees its \"current\" value."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "m", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you need to effectively capture the value at a moment in time, write a function takes the value you want as a parameter, and returns a lambda expression.", "At that point, the lambda will capture the parameter's value, which won't change when you call the function multiple times:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "parameter's", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def callback(msg):\n    print msg\n\ndef createCallback(msg):\n    return lambda: callback(msg)\n\n#creating a list of function handles with an iterator\nfuncList=[]\nfor m in ('do', 're', 'mi'):\n    funcList.append(createCallback(m))\nfor f in funcList:\n    f()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n do\nre\nmi\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Yes, that's a problem of scope, it binds to the outer m, whether you are using a lambda or a local function.", "Instead, use a functor:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Func1(object):\n            def __init__(self, callback, message):\n                    self.callback = callback\n                    self.message = message\n            def __call__(self):\n                    return self.callback(self.message)\n    funcList.append(Func1(callback, m))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["there are actually no variables in the classic sense in Python, just names that have been bound by references to the applicable object.", "Even functions are some sort of object in Python, and lambdas do not make an exception to the rule :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In this simple context, you can do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for m in ('do', 're', 'mi'):\n    funcList.append(eval('lambda: callback(\"'+m+'\")'))\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, in more complicated code this can get ugly."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Not directly related to the issue at hand, but an invaluable piece of wisdom nevertheless: Python Objects by Fredrik Lundh. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python Objects", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.effbot.org/zone/python-objects.htm"}]}]]