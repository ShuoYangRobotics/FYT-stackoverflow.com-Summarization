[[{"text": ["Pseudocode:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n For each string in the array:\n    Find the first '{'. If there is none, leave that string alone.\n    Init a counter to 0. \n    For each character in the string:  \n        If you see a '{', increment the counter.\n        If you see a '}', decrement the counter.\n        If the counter reaches 0, break.\n    Here, if your counter is not 0, you have invalid input (unbalanced brackets)\n    If it is, then take the string from the first '{' up to the '}' that put the\n     counter at 0, and that is a new element in your array.\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Or this pyparsing version:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from pyparsing import nestedExpr\n&gt;&gt;&gt; txt = \"{ { a } { b } { { { c } } } }\"\n&gt;&gt;&gt;\n&gt;&gt;&gt; nestedExpr('{','}').parseString(txt).asList()\n[[['a'], ['b'], [[['c']]]]]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm kind of new to Python, so go easy on me, but here is an implementation that works:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def balanced_braces(args):\n    parts = []\n    for arg in args:\n        if '{' not in arg:\n            continue\n        chars = []\n        n = 0\n        for c in arg:\n            if c == '{':\n                if n &gt; 0:\n                    chars.append(c)\n                n += 1\n            elif c == '}':\n                n -= 1\n                if n &gt; 0:\n                    chars.append(c)\n                elif n == 0:\n                    parts.append(''.join(chars).lstrip().rstrip())\n                    chars = []\n            elif n &gt; 0:\n                chars.append(c)\n    return parts\n\nt1 = balanced_braces([\"{{ a } { b } { { { c } } } }\"]);\nprint t1\nt2 = balanced_braces(t1)\nprint t2\nt3 = balanced_braces(t2)\nprint t3\nt4 = balanced_braces(t3)\nprint t4\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Output:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n ['{ a } { b } { { { c } } }']\n['a', 'b', '{ { c } }']\n['{ c }']\n['c']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Parse using lepl (installable via $ easy_install lepl):"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "lepl", "tag": "a", "pos": 0, "childList": [{"text": "lepl", "tag": "code"}], "childNum": 1, "href": "http://code.google.com/p/lepl/"}, {"text": "lepl", "childNum": 0, "tag": "code", "childList": []}, {"text": "$ easy_install lepl", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from lepl import Any, Delayed, Node, Space\n\nexpr = Delayed()\nexpr += '{' / (Any() | expr[1:,Space()[:]]) / '}' &gt; Node\n\nprint expr.parse(\"{{a}{b}{{{c}}}}\")[0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\nNode\n +- '{'\n +- Node\n |   +- '{'\n |   +- 'a'\n |   `- '}'\n +- Node\n |   +- '{'\n |   +- 'b'\n |   `- '}'\n +- Node\n |   +- '{'\n |   +- Node\n |   |   +- '{'\n |   |   +- Node\n |   |   |   +- '{'\n |   |   |   +- 'c'\n |   |   |   `- '}'\n |   |   `- '}'\n |   `- '}'\n `- '}'\n</pre>\n", "senID": 3}], [{"text": ["If you want to use a parser (lepl in this case), but still want the intermediate results rather than a final parsed list, then I think this is the kind of thing you were looking for:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; nested = Delayed()\n&gt;&gt;&gt; nested += \"{\" + (nested[1:,...]|Any()) + \"}\"\n&gt;&gt;&gt; split = (Drop(\"{\") &amp; (nested[:,...]|Any()) &amp; Drop(\"}\"))[:].parse\n&gt;&gt;&gt; split(\"{{a}{b}{{{c}}}}\")\n['{a}{b}{{{c}}}']\n&gt;&gt;&gt; split(\"{a}{b}{{{c}}}\")\n['a', 'b', '{{c}}']\n&gt;&gt;&gt; split(\"{{c}}\")\n['{c}']\n&gt;&gt;&gt; split(\"{c}\")\n['c']\n</code>\n</pre>\n", "senID": 1}, {"text": ["That might look opaque at first, but it's fairly simple really :o)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["nested is a recursive definition of a matcher for nested brackets (the \"+\" and [...] in the definition keep everything as a single string after it has been matched).", "Then split says match as many as possible (\"[:]\") of something that is surrounded by \"{\" ... \"}\" (which we discard with \"Drop\") and contains either a nested expression or any letter."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "nested", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "split", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Finally, here's a lepl version of the \"all in one\" parser that gives a result in the same format as the pyparsing example above, but which (I believe) is more flexible about how spaces appear in the input:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; with Separator(~Space()[:]):\n...     nested = Delayed()\n...     nested += Drop(\"{\") &amp; (nested[1:] | Any()) &amp; Drop(\"}\") &gt; list\n...\n&gt;&gt;&gt; nested.parse(\"{{ a }{ b}{{{c}}}}\")\n[[['a'], ['b'], [[['c']]]]]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["You could also parse them all at once, though I find the {a} to mean \"a\" rather than [\"a\"] slightly weird.", "If I've understood the format correctly:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "{a}", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\"a\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "[\"a\"]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import re\nimport sys\n\n\n_mbrack_rb = re.compile(\"([^{}]*)}\") # re.match doesn't have a pos parameter\ndef mbrack(s):\n  \"\"\"Parse matching brackets.\n\n  &gt;&gt;&gt; mbrack(\"{a}\")\n  'a'\n  &gt;&gt;&gt; mbrack(\"{{a}{b}}\")\n  ['a', 'b']\n  &gt;&gt;&gt; mbrack(\"{{a}{b}{{{c}}}}\")\n  ['a', 'b', [['c']]]\n\n  &gt;&gt;&gt; mbrack(\"a\")\n  Traceback (most recent call last):\n  ValueError: expected left bracket\n  &gt;&gt;&gt; mbrack(\"{a}{b}\")\n  Traceback (most recent call last):\n  ValueError: more than one root\n  &gt;&gt;&gt; mbrack(\"{a\")\n  Traceback (most recent call last):\n  ValueError: expected value then right bracket\n  &gt;&gt;&gt; mbrack(\"{a{}}\")\n  Traceback (most recent call last):\n  ValueError: expected value then right bracket\n  &gt;&gt;&gt; mbrack(\"{a}}\")\n  Traceback (most recent call last):\n  ValueError: unbalanced brackets (found right bracket)\n  &gt;&gt;&gt; mbrack(\"{{a}\")\n  Traceback (most recent call last):\n  ValueError: unbalanced brackets (not enough right brackets)\n  \"\"\"\n  stack = [[]]\n  i, end = 0, len(s)\n  while i &lt; end:\n    if s[i] != \"{\":\n      raise ValueError(\"expected left bracket\")\n    elif i != 0 and len(stack) == 1:\n      raise ValueError(\"more than one root\")\n    while i &lt; end and s[i] == \"{\":\n      L = []\n      stack[-1].append(L)\n      stack.append(L)\n      i += 1\n    stack.pop()\n    stack[-1].pop()\n    m = _mbrack_rb.match(s, i)\n    if m is None:\n      raise ValueError(\"expected value then right bracket\")\n    stack[-1].append(m.group(1))\n    i = m.end(0)\n    while i &lt; end and s[i] == \"}\":\n      if len(stack) == 1:\n        raise ValueError(\"unbalanced brackets (found right bracket)\")\n      stack.pop()\n      i += 1\n  if len(stack) != 1:\n    raise ValueError(\"unbalanced brackets (not enough right brackets)\")\n  return stack[0][0]\n\n\ndef main(args):\n  if args:\n    print &gt;&gt;sys.stderr, \"unexpected arguments: %r\" % args\n  import doctest\n  r = doctest.testmod()\n  print r\n  return r[0]\n\nif __name__ == \"__main__\":\n  sys.exit(main(sys.argv[1:]))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Cleaner solution.", "This will find return the string enclosed in the outermost bracket.", "If None is returned, there was no match."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def findBrackets( aString ):\n   if '{' in aString:\n      match = aString.split('{',1)[1]\n      open = 1\n      for index in xrange(len(match)):\n         if match[index] in '{}':\n            open = (open + 1) if match[index] == '{' else (open - 1)\n         if not open:\n            return match[:index]\n</code>\n</pre>\n", "senID": 1}]]