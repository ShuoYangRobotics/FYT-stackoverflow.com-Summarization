[[{"text": ["Python doesn't have a temporary namespace tool like let in Lisp or Scheme."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "let", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "let", "tag": "a"}]}, {"href": "http://www.gnu.org/software/emacs/emacs-lisp-intro/html_node/let.html", "text": "let", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["The usual technique in Python is to put names in the current namespace and then take them out when you're done with them.", "This technique is used heavily in the standard library:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n abspath = os.path.abspath\ndirname = os.path.dirname\n# 15 lines of heavy usage of those functions\na = abspath(somepath)\nd = dirname(somepath)\n...\ndel abspath, dirname\n</code>\n</pre>\n", "senID": 2}, {"text": ["An alternative technique to reduce typing effort is to shorten the recurring prefix:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import math as m\n&gt;&gt;&gt; m.sin(x / 2.0) + m.sin(x * m.pi)\n\n&gt;&gt;&gt; p = os.path\n...\n&gt;&gt;&gt; a = p.abspath(somepath)\n&gt;&gt;&gt; d = p.dirname(somepath)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Another technique commonly used in the standard library is to just not worry about contaminating the module namespace and just rely on __all__ to list which names you intend to make public.", "The effect of __all__ is discussed in the docs for the import statement."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "__all__", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "__all__", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"href": "http://docs.python.org/reference/simple_stmts.html?highlight=__all__#the-import-statement", "text": "docs for the import statement", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Of course, you can also create your own namespace by storing the names in a dictionary (though this solution isn't common):"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n d = dict(abspath = os.path.abspath,\n         dirname = os.path.dirname)\n...\na = d['abspath'](somepath)\nd = d['dirname'](somepath)\n</code>\n</pre>\n", "senID": 7}, {"text": ["Lastly, you can put all the code in a function (which has its own local namespace), but this has a number of disadvantages:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "the setup is awkward (an atypical and mysterious use of functions)", "tag": "none", "senID": 9}, {"text": "you need to declare as ", "tag": "none", "senID": 10}, {"text": "the code won't run until you call the function", "tag": "none", "senID": 11}]}], [{"text": ["This sort of does what you want, but you do have to repeat the names"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    abspath = os.path.abspath\n    dirname = os.path.dirname\n    # fifteen lines of code\nfinally:\n    del abspath\n    del dirname\n</code>\n</pre>\n", "senID": 1}, {"text": ["This avoids pollution the namespace if there is an exception in a situation as below"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n try:\n    ...\n    try:\n        abspath = os.path.abspath\n        dirname = os.path.dirname\n        # fifteen lines of code\n    finally:\n        del abspath\n        del dirname\n\n    ... # don't want abspath or dirname in scope here even if there was\n    ... # an exception in the above block\n\nexcept:\n    ...\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Just make a function?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def do_things_with_those_functions():\n    abspath = os.path.abspath\n    dirname = os.path.dirname\n    # etc.\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can do this in any scope:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def outer_function():\n    a = 5\n    def inner_function():\n        print(a)\n    inner_function()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You can define functions anywhere, call them, then delete them.", "But there is no way to have an anonymous function that can make use of statements."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The short answer is \"No.", "\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python has three scopes.", "It has function scope, global (aka module) scope, and the builtin scope.", "You can declare no other scopes."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["A class declaration looks sort of like a scope, but it isn't.", "It's basically shorthand for assigning a bunch of fields on an object.", "The functions in that class can't access those fields without going through the object they're defined on."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "class", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This sounds a bit more limiting than it is.", "In Python you can also nest function definitions.", "A nested function definition gets read-only access to the outer scope.", "This is 'dynamic'.", "The name does not have to be mentioned before the function is defined.", "Here is an example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def joe(x):\n    def bar():\n        return y\n    def baz(z):\n        y = x + 20\n        return x\n    y = x+5\n    return bar, baz\n\n&gt;&gt;&gt; a, b = joe(5)\n&gt;&gt;&gt; b(20)\n5\n&gt;&gt;&gt; a()\n10\n</code>\n</pre>\n", "senID": 4}, {"text": ["So, you can sort of get this effect without sacrificing too much locality by defining a nested function that creates the values you need, uses them, and returns a result."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I remember, when learning Python, that getting used to the rather strange scoping rules was one of the more difficult parts.", "When nested functions were introduced, in my opinion, they made the scoping rules even stranger because of the read-only semantics for outer scopes and dynamic scoping of closures."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Apparently, in Python3 there is a way of 'importing' a variable from the enclosing scope using the nonlocal keyword (analogous to the global keyword) so you can use it in a read/write context:"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "global", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def joe(x):\n    def bar():\n        return y\n    def baz(z):\n        nonlocal y\n        y = x + 20\n        return x\n    y = x+5\n    return bar, baz\n\n&gt;&gt;&gt; a, b = joe(5)\n&gt;&gt;&gt; b(20)\n5\n&gt;&gt;&gt; a()\n25\n</code>\n</pre>\n", "senID": 8}, {"text": ["Otherwise, whenever Python sees a variable on the left-hand side of an = sign, it assumes you're creating a new local variable.", "The global and nonlocal keywords are a way of stating that you intend to modify a variable that's not in the scope of the function."], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "=", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "global", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "nonlocal", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["It is not clear if you're more embarassed by the length of identification expressions to write, or by the trail of remaining identifiers in a namespace after their use."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["For the first, the technique of defining an alias for a long prefix, as described by Raymond Hettinger, is THE ONE to employ."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For the second, I'm surprised that nobody resorted to the importation of a module in which the instructions and lines you consider heavy and littering are consigned. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]}, {"text": ["By the way, if you access to functions by os.path.abspath and os.path.dirnames, it is incorrect to say that the functions (I suppose you mean their names)  litter the namespace.", "Since they are belonging to the module os or os.path (it depends which one has been imported) , there are only the name of the module 'os' or 'os.path' in the namespace, and the module object  in the memory, but not the functions's names directly in the namespace."], "childNum": 6, "tag": "p", "senID": 3, "childList": [{"text": "os.path.abspath", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "os.path.dirnames", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "os", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "os.path", "childNum": 0, "tag": "strong", "childList": []}, {"text": "'os'", "childNum": 0, "tag": "em", "childList": []}, {"text": "'os.path'", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["So, one can create a script of name \"heavy_code.py\" :"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def doing(x):\n    from os.path import abspath as a,dirname as d\n    ## Execute all the desired processes and creations\n    def fufu(s,t):\n        return s+t\n    dedex = d[x]\n    #.........\n    #...........\n    #........\n    #............\n    #..........\n\n    ## Return to the calling scope all that is needed there\n    return (dedex,fufu)\n</code>\n</pre>\n", "senID": 5}, {"text": ["And in the main module, taking acount of gnibbler's answer:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n one_path = 'I:/all/magala/zeru/kiol.py'\ntry:\n    from pp.bududu import doing\n    w,ff = doing(one_path)\nfinally:\n    del doing\n</code>\n</pre>\n", "senID": 7}, {"text": [], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["To see how it works: "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n one_path = 'I:/all/magala/zeru/kiol.py'\ntry:\n    from pp.bududu.heavy_code import doing\n    print \"in try : \"\n    print dir()\n    print \"executing doing()\"\n    w,ff = doing(one_path)\n    print dir()\nfinally:\n    del doing\n\nprint \"\\nafter finally : \"\nprint dir()\nprint '\\nw ==',w\nprint 'ff(10,12) ==',ff(10,12)\n</code>\n</pre>\n", "senID": 10}, {"text": ["produces as a result:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n in try :\n['__builtins__', '__doc__', '__name__', '__package__', 'doing', 'one_path']\nexecuting doing()\n['__builtins__', '__doc__', '__name__', '__package__', 'doing', 'ff', 'one_path', 'w']\n\nafter finally :\n['__builtins__', '__doc__', '__name__', '__package__', 'ff', 'one_path', 'w']\n\nw == I:/all/magala/zeru\nff(10,12) == 22\n</code>\n</pre>\n", "senID": 12}, {"text": ["After the execution of the snippet, the function doing() doesn't exist anymore in the main module, but objects created by the execution of doing() now lay in it without a clutter of names in the main module's namespace.", "Also, all the identifiers needed inside the function doing() are local to it ."], "childNum": 3, "tag": "p", "senID": 13, "childList": [{"text": "doing()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "doing()", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "doing()", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["The creation of all the desired and needed objects can be delegated to the module heavy_code, whatever how many they are, while importing and executing the function doing() takes only two lines in the main module, and function doing() in heavy_code plus its calling line can easily be modified."], "childNum": 4, "tag": "p", "senID": 14, "childList": [{"text": "heavy_code", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "doing()", "childNum": 0, "tag": "strong", "childList": []}, {"text": "doing()", "childNum": 0, "tag": "strong", "childList": []}, {"text": "heavy_code", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Isn't it what are the module designed for ?"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}], [{"text": ["In general, typing is not the hard part of writing software,  but if you insist:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class LocalNamespace(object):\n    def __enter__(self, *args, **kwargs):\n        pass\n    def __exit__(self, *args, **kwargs):\n        pass\n with LocalNamespace() as foo:\n     abspath = os.path.abspath\n     dirname = os.path.dirname\n     # etc.\n</code>\n</pre>\n", "senID": 1}, {"text": ["Hope this helps."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]