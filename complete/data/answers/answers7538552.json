[[{"text": ["You don't really need to set up an output data.frame but you can if you want.", "Here is how I would have coded it, and I guarantee it will be fast."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt; dat$incrmt &lt;- dat$V1 %/% 100\n&gt; dat\n     V1       V2 incrmt\n1  5380 30.07383     53\n2  5390 30.87000     53\n3  5393  0.07383     53\n4  5404  6.00000     54\n5  5428 30.07383     54\n6  5437  1.00000     54\n7  5440  9.00000     54\n8  5443 30.07383     54\n9  5459  6.00000     54\n10 5463 30.07383     54\n11 5480  7.00000     54\n12 5521 30.07383     55\n13 5538  0.00000     55\n14 5584 20.00000     55\n15 5673 30.07383     56\n16 5720 30.07383     57\n17 5841  3.00000     58\n18 5880 30.07383     58\n19 5913  4.00000     59\n20 5958 30.07383     59\n\n&gt; with(dat, tapply(V2, incrmt, mean, na.rm=TRUE))\n      53       54       55       56       57       58       59 \n20.33922 14.90269 16.69128 30.07383 30.07383 16.53692 17.03692\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could have done even less setup (skip the incrmt variable with this code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt; with(dat, tapply(V2, V1 %/% 100, mean, na.rm=TRUE))\n      53       54       55       56       57       58       59 \n20.33922 14.90269 16.69128 30.07383 30.07383 16.53692 17.03692\n</code>\n</pre>\n", "senID": 3}, {"text": ["And if you want the result to be available for something:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n by100MeanV2 &lt;- with(dat, tapply(V2, V1 %/% 100, mean, na.rm=TRUE))\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n use strict;\nuse warnings;\n\nmy $BIN_SIZE = 100;\nmy %freq;\n\nwhile (&lt;&gt;){\n    my ($k, $v) = split;\n    my $bin = $BIN_SIZE * int($k / $BIN_SIZE);\n    $freq{$bin}{n} ++;\n    $freq{$bin}{sum} += $v;\n}\n\nfor my $bin (sort { $a &lt;=&gt; $b  } keys %freq){\n    my ($n, $sum) = map $freq{$bin}{$_}, qw(n sum);\n    print join(\"\\t\", $bin, $n, $sum, $sum / $n), \"\\n\";\n}\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Given the size of your problem, you need to use data.table which is lightening fast."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "data.table", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n require(data.table)\nN = 10^6; M = 33132539\nmydt = data.table(V1 = runif(N, 1, M), V2 = rpois(N, lambda = 10))\nans  = mydt[,list(avg_V2 = mean(V2)),'V1 %/% 100']\n</code>\n</pre>\n", "senID": 1}, {"text": ["This took 20 seconds on my Macbook Pro with specs 2.53Ghz 4GB RAM.", "If you don't have any NA in your second column, you can obtain a 10x speedup by replacing mean with .Internal(mean)."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "NA", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "mean", "childNum": 0, "tag": "code", "childList": []}, {"text": ".Internal(mean)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Here is the speed comparison using rbenchmark and 5 replications.", "Note that data.table with .Internal(mean) is 10x faster."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "rbenchmark", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "data.table", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": ".Internal(mean)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n test        replications   elapsed   relative \nf_dt()            5         113.752   10.30736   \nf_tapply()        5         147.664   13.38021   \nf_dt_internal()   5          11.036    1.00000\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The first thing that comes in mind is a python generator, which is memory efficient."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def cat(data_file): # cat generator\n    f = open(data_file, \"r\")\n    for line in f:\n        yield line\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then put some logic in another function (and supposing that you save the results in a file)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def foo(data_file, output_file):\n    f = open(output_file, \"w\")\n    cnt = 0\n    suma = 0\n    for line in cat(data_file):\n        suma += line.split()[-1]\n        cnt += 1\n        if cnt%100 == 0:\n            f.write(\"%s\\t%s\\n\" %( cnt, suma/100.0)\n            suma = 0\n    f.close()\n</code>\n</pre>\n", "senID": 3}, {"text": ["EDIT : The above solution assumed that the numbers in the first column are ALL numbers from 1 to N. As your case does not follow this pattern ( from the extra details in the comments), here is the correct function:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def foo_for_your_case(data_file, output_file):\n    f = open(output_file, \"w\")\n    interval = 100\n    suma = 0.0\n    cnt = 0 # keep track of number of elements in the interval\n\n    for line in cat(data_file):\n        spl = line.split()\n\n        while int(spl[0]) &gt; interval:\n            if cnt &gt; 0 : f.write(\"%s\\t%s\\n\" %( interval, suma/cnt)\n            else: f.write(\"%s\\t0\\n\" %( interval )\n            interval += 100   \n            suma = 0.0\n            cnt = 0\n\n        suma += float(spl[-1])\n        cnt += 1\n\n    f.close()\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Based on your code, I would guess that this would work the full data set (depending on your system's memory): "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n chr1 &lt;- 33132539 \nwindow &lt;- 100 \n\npos &lt;- cut(1:chr1, seq(0, chr1, window))\n\nmeanrho.chr1 &lt;- tapply(spe$rho, INDEX = pos, FUN = mean)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think you want a factor that defines groups of intervals for every 100 within the first column (rho), and then you can use the standard apply family of functions to get means within groups. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "rho", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Here is the data you posted in reproducible form. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n spe &lt;- structure(list(pos = c(5380L, 5390L, 5393L, 5404L, 5428L, 5437L, \n5440L, 5443L, 5459L, 5463L, 5480L, 5521L, 5538L, 5584L, 5673L, \n5720L, 5841L, 5880L, 5913L, 5958L), rho = c(30.07383, 30.87, 0.07383, \n6, 30.07383, 1, 9, 30.07383, 6, 30.07383, 7, 30.07383, 0, 20, \n30.07383, 30.07383, 3, 30.07383, 4, 30.07383)), .Names = c(\"pos\", \n\"rho\"), row.names = c(NA, -20L), class = \"data.frame\")\n</code>\n</pre>\n", "senID": 4}, {"text": ["Define the intervals with cut, we just want every 100th value (but you might want the details tweaked as per your code for your real data set). "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "cut", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n pos.index &lt;- cut(spe$pos, seq(0, max(spe$pos), by = 100))\n</code>\n</pre>\n", "senID": 6}, {"text": ["Now pass the desired function (mean) over each group. "], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "mean", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n tapply(spe$rho, INDEX = pos.index, FUN = mean)\n</code>\n</pre>\n", "senID": 8}, {"text": ["(Lots of NAs since we didn't start at 0, then)"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n (5.2e+03,5.3e+03] (5.3e+03,5.4e+03] (5.4e+03,5.5e+03] (5.5e+03,5.6e+03] (5.6e+03,5.7e+03] (5.7e+03,5.8e+03] (5.8e+03,5.9e+03] \n   20.33922          14.90269          16.69128          30.07383          30.07383          16.53692\n</code>\n</pre>\n", "senID": 10}, {"text": ["(Add other arguments to FUN, such as na.rm as necessary, e.g:)"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n ## tapply(spe$rho, INDEX = pos.index, FUN = mean, na.rm = TRUE)\n</code>\n</pre>\n", "senID": 12}, {"text": ["See ?tapply applying over groups in a vector (ragged array), and ?cut for ways to generate grouping factors."], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "?tapply", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "?cut", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Here is a Perl program that does what I think you want.", "It assumes the rows are sorted by the first column."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/perl\nuse strict;\nuse warnings;\n\nmy $input_name       = \"t.dat\";\nmy $output_name      = \"t_out.dat\";\nmy $initial_interval = 1;\n\nmy $interval_size    = 100;\nmy $start_interval   = $initial_interval;\nmy $end_interval     = $start_interval + $interval_size;\n\nmy $interval_total   = 0;\nmy $interval_count   = 0;\n\nopen my $DATA, \"&lt;\", $input_name  or die \"$input_name: $!\";\nopen my $AVGS, \"&gt;\", $output_name or die \"$output_name: $!\";\n\nmy $rows_in  = 0;\nmy $rows_out = 0;\n$| = 1;\n\nfor (&lt;$DATA&gt;) {\n    $rows_in++;\n\n    # progress indicator, nice for big data\n    print \"*\" unless $rows_in % 1000;\n    print \"\\n\" unless $rows_in % 50000;\n\n    my ($key, $value) = split /\\t/;\n\n    # handle possible missing intervals\n    while ($key &gt;= $end_interval) {\n\n        # put your value for an empty interval here...\n        my $interval_avg = \"empty\";\n\n        if ($interval_count) {\n            $interval_avg = $interval_total/$interval_count;\n        }\n        print $AVGS $start_interval,\"\\t\", $interval_avg, \"\\n\";\n        $rows_out++;\n\n        $interval_count = 0;\n        $interval_total = 0;\n\n        $start_interval = $end_interval;\n        $end_interval   += $interval_size;\n    }\n\n    $interval_count++;\n    $interval_total += $value;\n}\n\n# handle the last interval\nif ($interval_count) {\n    my $interval_avg = $interval_total/$interval_count;\n    print $AVGS $start_interval,\"\\t\", $interval_avg, \"\\n\";\n    $rows_out++;\n}\n\nprint \"\\n\";\nprint \"Rows in:  $rows_in\\n\";\nprint \"Rows out: $rows_out\\n\";\n\nexit 0;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Oneliner in Perl is simple and efficient as usual:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n perl -F\\\\t -lane'BEGIN{$l=33132539;$i=100;$,=\", \"}sub p(){print$r*$i,$s/$n if$n;$r=int($F[0]/$i);$s=$n=0}last if$F[0]&gt;$l;p if int($F[0]/$i)!=$r;$s+=$F[1];$n++}{p'\n</code>\n</pre>\n", "senID": 1}]]