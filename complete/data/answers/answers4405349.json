[[{"text": ["Python makes more sense if you think of attaching name tags to objects, rather than stuffing objects into named boxes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def lala(a):\n    n = [0, 0 , 0]\n    a = n\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here's what's happening."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In other words, a is not a box into which you can put a new list.", "It is a name you gave a list you received.", "Later, you reassign that name to the list you have also named n."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Others have suggested a slice assignment, a[:] = n, which uses a reference to the items in the list rather than the list itself.", "When you do this, the name a still points to the same list; its contents have just been replaced.", "Since it is the same list that was passed into the function, any names by which it is known outside the function will \"see\" the new contents."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "a[:] = n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["kindall provided a great explanation in my opinion, but my preferred method for doing something like this is to have the function return the change instead of messing with references."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def lala():\n     n = [0, 0, 0]\n     return n\n\na = [0, 1, 2, 3]\n\na = lala()\n\nprint a # prints [0, 0, 0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["you can use a[:] = n inside the function.", "this is called a slice assignment"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "a[:] = n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["python does not have a call-by-reference feature.", "There's no general way to do this.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you know your argument is going to be a list, and you want it to take a different value, you can write it like so: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def lala(a):\n    a[:] = [0,0,0]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["That's because a function makes new label \"a\" for its scope.", "Then this \"a\" overshadows the \"a\" you defined outside the function.", "So the new label a is assigned to new object [0,0,0,0]\nIf you would write:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def lala(a):\n    a.pop()\n\na = [0,1,2,3,4]\nlala(a)\nprint(a)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You would see that a = [0,1,2,3] because pop() actually change the object which label 'a' points to.", "(while assignment just change to what object given label points to)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Note the difference between your function, and this one:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def lala(a):\n    a[0] = 7\n\na = [0,1,2,3]\nlala(a)\nprint a   # prints [7, 1, 2, 3]\n</code>\n</pre>\n", "senID": 1}]]