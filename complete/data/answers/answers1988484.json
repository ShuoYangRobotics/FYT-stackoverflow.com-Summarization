[[{"text": ["If I were you I would take the time to learn how to properly use the various data structures available in Python instead of looking for things that are similar to what you know from C++.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's not like you're looking for something fancy, just working with some data structures.", "In that case I would refer you to Python's documentation on the subject.  "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Python's documentation on the subject", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html"}]}, {"text": ["Doing this the 'Python' way would help you and more importantly future maintainers who will wonder why you try to program C++ in Python."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Just to whet your appetite, there's also no reason to prefer STL's style to Python (and for the record, I'm also a C++ programmer who knows STL throughly), consider the most trivial example of constructing a list and traversing it:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "prefer", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The Pythonic way:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n mylist = [1, 2, 3, 4]\n\nfor value in mylist:\n    # playaround with value\n</code>\n</pre>\n", "senID": 5}, {"text": ["The STL way (I made this up, to resemble STL) in Python:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n mylist = [1, 2, 3, 4]\nmylistiter = mylist.begin()\n\nwhile mylistiter != mylist.end():\n    value = mylistiter.item()\n    mylistiter.next()\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Python's \"lists\" are not linked lists -- they're like Java ArrayLists or C++'s std::vectors, i.e., in lower-level terms, a resizable compact array of pointers."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "linked", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"href": "http://java.sun.com/j2se/1.4.2/docs/api/java/util/ArrayList.html", "text": "ArrayList", "childNum": 0, "tag": "a", "childList": []}, {"text": "std::vector", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["A good \"advanced tutorial\" on such subjects is Hettinger's Core Python containers: under the hood presentation (the video at the URL is of the presentation at an Italian conference, but it's in English; another, shorter presentation of essentially the same talk is here)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Core Python containers: under the hood", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.viddler.com/explore/python-italia/videos/41/"}, {"href": "http://www.youtube.com/watch?v=hYUsssClE94", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["So the performance characteristics of Python lists are essentially those of C++'s std::vector: Python's .append, like C++'s push_back, is O(1), but insertion or removal \"in the middle\" is O(N).", "Consequently, keeping a list sorted (as can be easily done with the help of functions in Python's standard library module bisect) is costly (if items arrive and/or depart randomly, each insertion and removal is O(N), just like similarly maintaining order in an std::vector would be.", "For some purposes, such as priority queues, you may get away with a \"heap queue\", also easy to maintain with the help of functions in Python's standard library module heapq -- but of course that doesn't afford the same range of uses as a completely sorted list (or vector) would."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "std::vector", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".append", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "push_back", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "bisect", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/bisect.html?highlight=bisect#module-bisect"}, {"text": "std::vector", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "heapq", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/heapq.html?highlight=heapq#module-heapq"}]}, {"text": ["So for purposes for which in C++ you'd use a std::set (and rely on its being ordered, i.e., a hashset wouldn't do -- Python's sets are hash-based, not ordered) you may be better off avoiding Python builtin containers in favor of something like this module (if you need to keep things pure-Python), or this one (which offers AVL trees, not RB ones, but is coded as a C-implemented Python extension and so may offer better performance) if C-coded extensions are OK."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "std::set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://newcenturycomputers.net/projects/rbtree.html", "text": "this module", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://sourceforge.net/projects/pyavl/", "text": "this one", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["If you do end up using your own module (be it pure Python, or C-coded), you may, if you wish, give it an STL-like veneer/interface (with .begin, .end, iterator objects that are advanced by incrementing rather than, as per normal Python behavior, by calling their next methods, ...), although it will never perform as well as \"going with the grain\" of the language would (the for statement is optimized to use normal Python iterators, i.e., one with next methods, and it will be faster than wrapping a somewhat awkward while around non-Python-standard, STL-like iterators)."], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": ".begin", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".end", "childNum": 0, "tag": "code", "childList": []}, {"text": "next", "childNum": 0, "tag": "code", "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}, {"text": "next", "childNum": 0, "tag": "code", "childList": []}, {"text": "while", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["To give an STL-like veneer to any Python built-in container, you'll incur substantial wrapping overhead, so the performance hit may be considerable.", "If you, as you say, \"DO NEED TO HAVE TOTALLY OPTIMAL CODE\", using such a veneer just for \"syntax convenience\" purposes would therefore seem to be a very bad choice."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Boost Python, the Python extension package that wraps the powerful C++ Boost library, might perhaps serve your purposes best."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Boost Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.boost.org/doc/libs/1_41_0/libs/python/doc/index.html"}]}], [{"text": ["For linked-list-like operations people usually use collections.deque."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "collections.deque", "tag": "a", "pos": 0, "childList": [{"text": "collections.deque", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/dev/library/collections.html#deque-objects"}, {"text": "collections.deque", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["What operations do you need to perform fast?", "Bisection?", "Insertion?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I would say that your issues go beyond just STL porting.", "Since the list, dict, and set data structures, which are bolted on to C++ via the STL, are native to core Python, then their usage is incorporated into common Python code idioms.", "If you want to give Google another shot, try looking for references for \"Python for C++ Programmers\".", "One of your hits will be this presentation by Alex Martelli.", "It's a little dated, from way back in ought-three, but there is a side-by-side comparison of some basic Python code that reads through a text file, and how it would look using STL."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this presentation by Alex Martelli", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://www.aleax.it/Python/accu03_Python_Intro_alex.pdf"}]}, {"text": ["From there, I would recommend that you read up on these Python features:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "iterators", "tag": "none", "senID": 2}, {"text": "generators", "tag": "none", "senID": 3}, {"text": "list and generator comprehensions", "tag": "none", "senID": 4}]}, {"text": ["And these builtin functions:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "zip", "tag": "none", "senID": 6}, {"text": "map", "tag": "none", "senID": 7}]}, {"text": ["Once you are familiar with these, then you will be able to construct your own translation/mapping between STL usage and Python builtin data structures."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["As others have said, if you are looking for a \"plug-and-chug\" formula to convert STL C++ code to Python, you will just end up with bad Python.", "Such a brute force approach will never result in the power, elegance, and brevity of a single-line list comprehension.", "(I had this very experience when introducing Python to one of our managers, who was familiar with Java and C++ iterators.", "When I showed him this code:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n numParams = 1000\nparamRequests = [ (\"EqptEmulator/ProcChamberI/Sensors\", \n                   \"ChamberIData%d\"%(i%250)) for i in range(numParams) ]\nrecord.internalArray = [ParameterRequest(*pr) for pr in paramRequests]\n</code>\n</pre>\n", "senID": 10}, {"text": ["and I explained that these replaced this code (or something like it, this might be a mishmash of C++ and Java APIs, sorry):"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n std::vector&lt;ParameterRequest&gt; prs = new std::vector&lt;ParameterRequest&gt;();\nfor (int i = 0; i&lt;1000; ++i) {\n    string idstr;\n    strstream sstr(idstr);\n    sstr &lt;&lt; \"ChamberIData\" &lt;&lt; (i%250);\n    prs.add(new ParameterRequest(\"EqptEmulator/ProcChamberI/Sensors\", idstr));\n}\nrecord.internalArray = new ParameterRequest[prs.size];\nprs.toArray(record.internalArray);\n</code>\n</pre>\n", "senID": 12}, {"text": ["One of your instincts from working with C++ will be a reluctance to create new lists from old, but rather to update or filter a list in place.", "We even see this on many forums from Python developers asking about how to modify a list while iterating over it.", "In Python, you are much better off building a new list from the old with a list comprehension."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n allItems = [... some list of items, perhaps from a database query ...]\nvalidItems = [it for it in allItems if it.isValid()]\n</code>\n</pre>\n", "senID": 14}, {"text": ["As opposed to:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n validItems = []\nfor it in allItems:\n    if it.isValid():\n        validItems.add(it)\n</code>\n</pre>\n", "senID": 16}, {"text": ["or worse:"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n # get list of indexes of items to be removed\nremoveIndexes = []\nfor i in range(len(allItems)):\n    if not allItems[i].isValid():\n        removeIndexes.add(i)\n\n# don't forget to remove items in descending order, or later indexes\n# will be invalidated by earlier removals\nsort(removeIndexes,reverse=True)\n\n# copy list\nvalidItems = allItems[:]\n\n# now remove the items from allItems\nfor idx in removeIndexes:\n    del validItems[i]\n</code>\n</pre>\n", "senID": 18}], [{"text": ["Python STL (in hope of leveraging my years of STL experience) - Start with the collections ABC's to learn what Python has.", "http://docs.python.org/library/collections.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/collections.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html"}]}, {"text": ["Python linked lists.", "Python lists have all the features you would want from a linked list. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Python advanced list usage.", "What does this mean?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Python list optimization.", "What does this mean?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Python ordered sets.", "You have several choices here; you could invent your own \"ordered set\" as a list that discards duplicates.", "You can subclass the heapq and add methods that discard duplicates: http://docs.python.org/library/heapq.html."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://docs.python.org/library/heapq.html", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/heapq.html"}]}, {"text": ["In many cases, however, the cost of maintaing an ordered set is actually excessive because it must only be ordered once at the end of the algorithm.", "In other cases, the \"ordered set\" really is a heapq  -- you never needed the set-like features and only needed the ordering."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Non-Trivial.", "(I'm guessing at what you meant by \"non-trivial\").", "All Python objects are equivalent.", "There's no \"trivial\" vs. \"non-trivial\" objects.", "They're all first-class objects and can all have \"non-trivial\" complexity without any real work.", "This is not C++ where there are primitive (non-object) values floating around.", "Everything's an object in Python."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Non-Trivial", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Management Expectations.", "For the most part the C++ brain-cramping doesn't exist in Python.", "Use the obvious Python classes the obvious way and you'll have much less code.", "The reduction in code volume is the big win.", "Often, the management reason for converting C++ to Python is to get rid of the C++ complexity."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "Management Expectations", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "is", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Python code will be much simpler, making it much more reliable and much easier to maintain.  "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["While it's generally true that Python is slower than C++, it's also true that picking the right algorithm and data structure can have dramatic improvements on performance.", "In one benchmark, someone found that Python was actually faster than C because the C program had such a poorly chosen data structure. "], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "dramatic", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "faster", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["It's possible that your C++ has a really poor algorithm and you will see comparable performance from Python."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["It's also possible that your C++ program is I/O bound, or has other limitations that will leave the Python running at a comparable speed."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["The design of Python is quite intentionally \"you can use just a few data structures (arrays and hash tables) for whatever you want to do, and if that isn't fast enough there's always C\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python's standard library doesn't have a sorted-list data structure like std::set.", "You can download a red/black tree implementation or roll your own.", "(For small data sets, just using a list and periodically sorting it is a totally normal thing to do in Python."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "std::set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "download a red/black tree implementation", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/rbtree/0.8.0"}]}, {"text": ["Rolling your own linked list is very easy."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]