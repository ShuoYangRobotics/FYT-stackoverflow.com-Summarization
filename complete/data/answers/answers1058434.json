[[{"text": ["Your solution is fine if every single cell is going to have a flag.", "However if you are working with a sparse dataset where only a small subsection of your cells will have flags what you really want is a dictionary.", "You would want to set up the dictonary so the key is a tuple for the location of the cell and the value is a list of flags like you have in your solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n allFlags = {(1,1,1):[1,2,3], (250,250,30):[4,5,6]}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here we have the 1,1,1 cell have the flags 1,2, and 3 and the cell 250,250,30 have the flags 4,5, and 6"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["edit- fixed key tuples, thanks Andre, and dictionary syntax."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You can define some constants with different, power of two values as:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n FLAG1 = 0x01\nFLAG8 = 0x02\nFLAG12 = 0x04\n...\n</code>\n</pre>\n", "senID": 1}, {"text": ["And use them with boolean logic to store the flags in only one integer, p.e."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n flags = FLAG1 | FLAG8\n</code>\n</pre>\n", "senID": 3}, {"text": ["To check if a flag is enabled, you can use the &amp; operator:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "&amp;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n flag1_enabled = flags &amp; FLAG1\n</code>\n</pre>\n", "senID": 5}, {"text": ["If the flag is enabled, this expression will return a non-zero value, that will be evaluated as True in any boolean operation.", "If the flag is disabled, the expression will return 0, that is evaluated as False in boolean operations."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I would generally use a numpy array (presumably of short ints, 2 bytes each, since you may need more than 256 distinct values) -- that would take less than 4MB for the &lt;2 million cells."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org/"}]}, {"text": ["If for some reason I couldn't afford the numpy dependency (e.g on App Engine, which doesn't support numpy), I'd use the standard library array module - it only supports 1-dimensional arrays, but it's just as space-efficient as numpy for large homogeneous arrays, and the getter/setter routines you mention can perfectly well \"linearize\" a 3-items tuple that's your natural index into the single integer index into the 1-D array."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "array", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/array.html"}]}, {"text": ["In general, consider numpy (or array) any time you have large homogeneous, dense vectors or matrices of numbers -- Python built-in lists are highly wasteful of space in this use case (due to their generality which you're not using and don't need here!-), and saving memory indirectly translates to saving time too (better caching, fewer levels of indirection, etc, etc)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Consider using Flyweight pattern to share cell properties:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://en.wikipedia.org/wiki/Flyweight_pattern"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://en.wikipedia.org/wiki/Flyweight_pattern", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Flyweight%5Fpattern"}]}], [{"text": ["BitSet is what you want, since it allows you to store many flags at once using only an fixed size integer (Int type)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "BitSet", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Bit%5Farray"}]}], [{"text": ["Taking Robbie's suggestion one step further..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n flags = set()\nx, y, flag = 34, 201, 3\nflags.add((x, y, flag)) # set flag 3 at position (34, 201)\nif (3, 2, 1) in flags: # check if flag 1 is at position (3, 2)\n    # do something\nelse:\n    # do something else\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can also create a helper class."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Flags(object):\n    def __init__(self):\n        self.data = set()\n    def add(self, x, y, flag):\n        self.data.add((x, y, flag))\n    def remove(self, x, y, flag):\n        self.data.remove((x, y, flag))\n    def contains(self, x, y, flag):\n        return (x, y, flag) in self.data\n</code>\n</pre>\n", "senID": 3}, {"text": ["You could also implement Python's special methods like __contains__ to make it easier to work with."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "__contains__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]