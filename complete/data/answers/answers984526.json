[[{"text": ["Instead of using the try/except's else block, you could simply return when it errors:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def send_message(addr, to, msg):\n    ## Connect to host\n    try:\n        server = smtplib.SMTP(host) #can throw an exception\n    except smtplib.socket.gaierror:\n        return False\n\n    ## Login\n    try:\n        server.login(username, password)\n    except SMTPAuthenticationError:\n        server.quit()\n        return False\n\n    ## Send message\n    try:\n        server.sendmail(addr, [to], msg.as_string())\n        return True\n    except Exception: # try to avoid catching Exception unless you have too\n        return False\n    finally:\n        server.quit()\n</code>\n</pre>\n", "senID": 1}, {"text": ["That's perfectly readable and Pythonic.."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Another way of doing this is, rather than worry about the specific implementation, decide how you want your code to look, for example.."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n sender = MyMailer(\"username\", \"password\") # the except SocketError/AuthError could go here\ntry:\n    sender.message(\"addr..\", [\"to..\"], \"message...\")\nexcept SocketError:\n    print \"Couldn't connect to server\"\nexcept AuthError:\n    print \"Invalid username and/or password!\"\nelse:\n    print \"Message sent!\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["Then write the code for the message() method, catching any errors you expect, and raising your own custom one, and handle that where it's relevant.", "Your class may look something like.."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "message()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class ConnectionError(Exception): pass\nclass AuthError(Exception): pass\nclass SendError(Exception): pass\n\nclass MyMailer:\n    def __init__(self, host, username, password):\n        self.host = host\n        self.username = username\n        self.password = password\n\n    def connect(self):\n        try:\n            self.server = smtp.SMTP(self.host)\n        except smtplib.socket.gaierror:\n            raise ConnectionError(\"Error connecting to %s\" % (self.host))\n\n    def auth(self):\n        try:\n            self.server.login(self.username, self.password)\n        except SMTPAuthenticationError:\n            raise AuthError(\"Invalid username (%s) and/or password\" % (self.username))\n\n    def message(self, addr, to, msg):\n        try:\n            server.sendmail(addr, [to], msg.as_string())\n        except smtplib.something.senderror, errormsg:\n            raise SendError(\"Couldn't send message: %s\" % (errormsg))\n        except smtp.socket.timeout:\n            raise ConnectionError(\"Socket error while sending message\")\n</code>\n</pre>\n", "senID": 6}], [{"text": ["In general, you want to use as few try blocks as possible, distinguishing failure conditions by the kinds of exceptions they throw.", "For instance, here's my refactoring of the code you posted:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    server = smtplib.SMTP(host)\n    server.login(username, password) # Only runs if the previous line didn't throw\n    server.sendmail(addr, [to], msg.as_string())\n    return True\nexcept smtplib.socket.gaierror:\n    pass # Couldn't contact the host\nexcept SMTPAuthenticationError:\n    pass # Login failed\nexcept SomeSendMailError:\n    pass # Couldn't send mail\nfinally:\n    if server:\n        server.quit()\nreturn False\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here, we use the fact that smtplib.SMTP(), server.login(), and server.sendmail() all throw different exceptions to flatten the tree of try-catch blocks.", "In the finally block we test server explicitly to avoid invoking quit() on the nil object."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["We could also use three sequential try-catch blocks, returning False in the exception conditions, if there are overlapping exception cases that need to be handled separately:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "sequential", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n try:\n    server = smtplib.SMTP(host)\nexcept smtplib.socket.gaierror:\n    return False # Couldn't contact the host\n\ntry:\n    server.login(username, password)\nexcept SMTPAuthenticationError:\n    server.quit()\n    return False # Login failed\n\ntry:\n    server.sendmail(addr, [to], msg.as_string())\nexcept SomeSendMailError:\n    server.quit()\n    return False # Couldn't send mail\n\nreturn True\n</code>\n</pre>\n", "senID": 4}, {"text": ["This isn't quite as nice, as you have to kill the server in more than one place, but now we can handle specific exception types different ways in different places without maintaining any extra state."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["If it was me I would probably do something like the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    server = smtplib.SMTP(host)\n    try:\n        server.login(username, password)\n        server.sendmail(addr, [to], str(msg))\n    finally:\n        server.quit()\nexcept:\n    debug(\"sendmail\", traceback.format_exc().splitlines()[-1])\n    return True\n</code>\n</pre>\n", "senID": 1}, {"text": ["All errors are caught and debugged, the return value == True on success, and the server connection is properly cleaned up if the initial connection is made."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Just using one try-block is the way to go.", "This is exactly what they\nare designed for: only execute the next statement if the previous\nstatement did not throw an exception.", "As for the resource clean-ups,\nmaybe you can check the resource if it needs to be cleaned up\n(e.g.", "myfile.is_open(), ...) This does add some extra conditions, but\nthey will only be executed in the exceptional case.", "To handle the case\nthat the same Exception can be raised for different reasons, you\nshould be able to retrieve the reason from the Exception."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I suggest code like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n server = None\ntry:\n    server = smtplib.SMTP(host) #can throw an exception\n    server.login(username, password)\n    server.sendmail(addr, [to], msg.as_string())\n    server.quit()\n    return True\nexcept smtplib.socket.gaierror:\n    pass # do some stuff here\nexcept SMTPAuthenticationError:\n    pass # do some stuff here\nexcept Exception, msg:\n    # Exception can have several reasons\n    if msg=='xxx':\n        pass # do some stuff here\n    elif:\n        pass # do some other stuff here\n\nif server:\n    server.quit()\n\nreturn False\n</code>\n</pre>\n", "senID": 2}, {"text": ["It is no uncommon, that error handling code exceeds business code.", "Correct error handling can be complex.", "But to increase maintainability it helps to separate the business code from the error handling code."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I would try something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Mailer():\n\n    def send_message(self):\n        exception = None\n        for method in [self.connect, \n                       self.authenticate, \n                       self.send, \n                       self.quit]:\n            try:\n                if not method(): break\n            except Exception, ex:\n                exception = ex\n                break\n\n        if method == quit and exception == None:\n            return True\n\n        if exception:\n            self.handle_exception(method, exception)\n        else:\n            self.handle_failure(method)\n\n    def connect(self):\n        return True\n\n    def authenticate(self):\n        return True\n\n    def send(self):\n        return True\n\n    def quit(self):\n        return True\n\n    def handle_exception(self, method, exception):\n        print \"{name} ({msg}) in {method}.\".format(\n           name=exception.__class__.__name__, \n           msg=exception,\n           method=method.__name__)\n\n    def handle_failure(self, method):\n        print \"Failure in {0}.\".format(method.__name__)\n</code>\n</pre>\n", "senID": 1}, {"text": ["All of the methods (including send_message, really) follow the same protocol:  they return True if they succeeded, and unless they actually handle an exception, they don't trap it.", "This protocol also makes it possible to handle the case where a method needs to indicate that it failed without raising an exception.", "(If the only way your methods fail is by raising an exception, that simplifies the protocol.", "If you're having to deal with a lot of non-exception failure states outside of the method that failed, you probably have a design problem that you haven't worked out yet."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "send_message", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "handle", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["The downside of this approach is that all of the methods have to use the same arguments.", "I've opted for none, with the expectation that the methods I've stubbed out will end up manipulating class members."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The upside of this approach is considerable, though.", "First, you can add dozens of methods to the process without send_message getting any more complex.  "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "send_message", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You can also go crazy and do something like this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def handle_exception(self, method, exception):\n    custom_handler_name = \"handle_{0}_in_{1}\".format(\\\n                                             exception.__class__.__name__,\n                                             method.__name__)\n    try:\n        custom_handler = self.__dict__[custom_handler_name]\n    except KeyError:\n        print \"{name} ({msg}) in {method}.\".format(\n           name=exception.__class__.__name__, \n           msg=exception,\n           method=method.__name__)\n        return\n    custom_handler()\n\ndef handle_AuthenticationError_in_authenticate(self):\n   print \"Your login credentials are questionable.\"\n</code>\n</pre>\n", "senID": 6}, {"text": ["...though at that point, I might say to myself, \"self, you're working the Command pattern pretty hard without creating a Command class.", "Maybe now is the time."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Why not one big try: block?", "This way, if any exception is caught, you'll go all the way to the except.", "And as long as all the exceptions for the different steps are different, you can always tell which part it was that fired the exception."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I like David's answer but if you are stuck on the server exceptions you can also check for server if is None or states.", "I flattened out the method a bit bit it is still a but unpythonic looking but more readable in the logic at the bottom."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n server = None \n\ndef server_obtained(host):\n    try:\n        server = smtplib.SMTP(host) #can throw an exception\n        return True\n    except smtplib.socket.gaierror:\n        #actually it can throw a lot more, this is just an example\n        return False\n\ndef server_login(username, password):\n    loggedin = False\n    try:\n        server.login(username, password)\n        loggedin = True\n    except SMTPAuthenticationError:\n        pass # do some stuff here\n    finally:\n        #we can only run this when the first try...except was successful\n        #else this throws an exception itself!\n        if(server is not None):\n            server.quit()\n    return loggedin\n\ndef send_mail(addr, to, msg):\n    sent = False\n     try:\n        server.sendmail(addr, to, msg)\n        sent = True\n    except Exception:\n        return False\n    finally:\n        server.quit()\n    return sent\n\ndef do_msg_send():\n    if(server_obtained(host)):\n        if(server_login(username, password)):\n            if(send_mail(addr, [to], msg.as_string())):\n                return True\n    return False\n</code>\n</pre>\n", "senID": 1}]]