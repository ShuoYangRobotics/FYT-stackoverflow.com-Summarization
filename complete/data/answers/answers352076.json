[[{"text": ["You can easily do function composition in Python.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's a demonstrates of a way to create a new function which is a composition of existing functions."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def comp( a, b ):\n    def compose( args ):\n    \treturn a( b( args ) )\n    return compose\n\n&gt;&gt;&gt; def times2(x): return x*2\n\n&gt;&gt;&gt; def plus1(x): return x+1\n\n&gt;&gt;&gt; comp( times2, plus1 )(32)\n66\n</code>\n</pre>\n", "senID": 2}, {"text": ["Here's a more complete recipe for function composition.", "This should make it look less clunky."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "function composition", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/52902/"}]}], [{"text": ["Follow the style that most matches your tastes.", "I would not worry about performance; only in case you really see some issue you can try to move to a different style."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["Here some other possible suggestions, in addition to your proposals:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n result = [f(\n              g(\n                h(x)\n                )\n              )\n            for x in list]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Use progressive list comprehensions:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n result = [h(x) for x in list]\nresult = [g(x) for x in result]\nresult = [f(x) for x in result]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Again, that's only a matter of style and taste.", "Pick the one you prefer most, and stick with it :-)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["If this is something you're doing often and with several different statements you could write something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def seriesoffncs(fncs,x):\n    for f in fncs[::-1]:\n        x=f(x)\n    return x\n</code>\n</pre>\n", "senID": 1}, {"text": ["where fncs is a list of functions.", "so seriesoffncs((f,g,h),x) would return \nf(g(h(x))).", "This way if you later in your code need to workout h(q(g(f(x)))) you would simply do seriesoffncs((h,q,g,f),x) rather than make a new operations function for each combination of functions."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If your only concerned with the last result, your last answer is the best.", "It's clear for anyone looking at it what your doing.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I often take any code that starts to get complex and move it to a function.", "This basically serves as a comment for that block of code.", "(any complex code probably needs a re-write anyway, and putting it in a function I can go back and work on it later)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def operation(x):\n  x0 = h(x)\n  x1 = g(x0)\n  x2 = f(x1)\n  return x2\nresult = [ operation(x) for x in list]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["A variation of dagw.myopenid.com's function:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dagw.myopenid.com", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/352076/most-pythonic-form-for-mapping-a-series-of-statements#353147"}]}, {"code": "<pre>\n<code>\n def chained_apply(*args):\n    val = args[-1]\n    for f in fncs[:-1:-1]:\n        val=f(val)\n    return val\n</code>\n</pre>\n", "senID": 1}, {"text": ["Instead of seriesoffncs((h,q,g,f),x) now you can call:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n result = chained_apply(foo, bar, baz, x)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["As far as I know there's no built-in/native syntax for composition in Python, but you can write your own function to compose stuff without too much trouble."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def compose(*f):\n    return f[0] if len(f) == 1 else lambda *args: f[0](compose(*f[1:])(*args))\n\ndef f(x): \n    return 'o ' + str(x)\n\ndef g(x): \n    return 'hai ' + str(x)\n\ndef h(x, y): \n    return 'there ' + str(x) + str(y) + '\\n'\n\naction = compose(f, g, h)\nprint [action(\"Test \", item) for item in [1, 2, 3]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Composing outside the comprehension isn't required, of course."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n print [compose(f, g, h)(\"Test \", item) for item in [1, 2, 3]]\n</code>\n</pre>\n", "senID": 3}, {"text": ["This way of composing will work for any number of functions (well, up to the recursion limit) with any number of parameters for the inner function."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["There are cases where it's best to go back to the for-loop, yes, but more often I prefer one of these approaches:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Use appropriate line breaks and indentation to keep it readable:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n result = [blah(blah(blah(x)))\n          for x in list]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Or extract (enough of) the logic into another function, as you mention.", "But not necessarily local; Python programmers prefer flat to nested structure, if you can see a reasonable way of factoring the functionality out."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I came to Python from the functional-programming world, too, and share your prejudice."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]