[[{"text": ["Use regular expressions."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A test determines that the expensive part of the process is the call to str.split().", "Probably having to construct a list and a bunch of string objects for every line is expensive."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Firstly, you need to construct a regular expression to match against the line.", "Something like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n expression = re.compile(r'(\"[^\"]\")\\t(\"[^\"]\")\\t')\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you call expression.match(line).groups(), you'll get the first two columns extracted as two string objects and you can do logic with those directly."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Now this assumes that the two columns of interest are the first two columns.", "If not you'll just have to tweak the regular expression to match the correct columns.", "Your code checks the header to see where the columns are located.", "You can generate the regular expression based on that, but I'm gonna guess that the columns are really always located at the same place.", "Just verify that they are still there and use a regular expression on the lines."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["EDIT"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["from collections import defaultdict\nimport re"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def get_users(log):\n    f = open(log)\n    # Read header line\n    h = f.readline().strip().replace('\\'', '').split('\\t')\n    ix_profile = h.index('profile.type')\n    ix_user = h.index('profile.id')\n\n    assert ix_user &lt; ix_profile\n</code>\n</pre>\n", "senID": 8}, {"text": ["This code assumes that user is before profile"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n keep_field = r'\"([^\"]*)\"'\n</code>\n</pre>\n", "senID": 10}, {"text": ["This regular expression will capture a single column"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n skip_field = r'\"[^\"]*\"'\n</code>\n</pre>\n", "senID": 12}, {"text": ["This regular expression will match the column, but not capture the results.", "(Note the lack of parenthesis)"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n fields = [skip_field] * len(h)\n    fields[ix_profile] = keep_field\n    fields[ix_user] = keep_field\n</code>\n</pre>\n", "senID": 14}, {"text": ["Create a list for all the fields, and only the keep the ones we care about"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n del fields[max(ix_profile, ix_user)+1:]\n</code>\n</pre>\n", "senID": 16}, {"text": ["Eliminate all the fields after the ones we care about (they take time to match, and we don't care about them)"], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n regex = re.compile(r\"\\t\".join(fields))\n</code>\n</pre>\n", "senID": 18}, {"text": ["Actually produce the regex. "], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"code": "<pre>\n<code>\n users = defaultdict(int)\n    for line in f:\n        user, profile = regex.match(line).groups()\n</code>\n</pre>\n", "senID": 20}, {"text": ["Pull out the two values, and do the logic"], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"code": "<pre>\n<code>\n if profile != \"7\": # \"7\" indicates a bad value\n            # use list slicing to remove quotes\n            users[user] += 1 \n\n    f.close()\n    return users\n</code>\n</pre>\n", "senID": 22}], [{"text": ["If you're running unix or cygwin, the following little script would produce you the frequency  of user id's where profile != 7.", "Should be quick."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Updated with awk to count the user ids"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Updated with awk to count the user ids", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #!/bin/bash\n\nFILENAME=\"test.txt\"\n\nIX_PROFILE=`head -1 ${FILENAME} | sed -e 's/\\t/\\n/g' | nl -w 1 | grep profile.type | cut -f1`\nIX_USER=`head -1 ${FILENAME} | sed -e 's/\\t/\\n/g' | nl -w 1 | grep profile.id | cut -f1`\n# Just the userids\n# sed 1d ${FILENAME} | cut -f${IX_PROFILE},${IX_USER} | grep -v \\\"7\\\" | cut -f2\n\n# userids counted:\n# sed 1d ${FILENAME} | cut -f${IX_PROFILE},${IX_USER} | grep -v \\\"7\\\" | cut -f2 | sort | uniq -c\n\n# Count using awk..?\nsed 1d ${FILENAME} | cut -f${IX_PROFILE},${IX_USER} | grep -v \\\"7\\\" | cut -f2 | awk '{ count[$1]++; } END { for (x in count) { print x \"\\t\" count[x] } }'\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Seeing that your log file is tab-delimited, you can use the csv module - with a dialect='excel-tab' argument - for a nice performance and readability boost.", "That is, of course, if you have to use Python instead of the much faster console commands."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "csv", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dialect='excel-tab'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["If using regexes can speed it up so much by ignoring the tail of the line that doesn't need to be split, perhaps a more straightforward approach might help:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [snip)\nix_profile = h.index('profile.type')\nix_user = h.index('profile.id')\nmaxsplits = max(ix_profile, ix_user) + 1 #### new statement ####\n# If either ix_* is the last field in h, it will include a newline. \n# That's fine for now.\nfor (i, line) in enumerate(f): \n    if i % 1000000 == 0: print \"Line %d\" % i # progress notification\n    l = line.split('\\t', maxsplits) #### changed line ####\n[snip]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Please give that a whirl on your data."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Maybe you can do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n users[l[ix_user]] += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["instead of"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n users[l[ix_user][1:-1]] += 1\n</code>\n</pre>\n", "senID": 3}, {"text": ["and remove the quotes on the dict at the end.", "Should save some time."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["For the multi-threading approach: try reading a few thousand lines from the file each time and passing those thousand lines to a thread to process.", "Doing it line-by-line seems to be too much overhead. "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Or read on the solution in this article as he seems to be doing something very similar to what you're trying to do."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "this article", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/wide-finder.htm#a-multi-threaded-python-solution"}]}], [{"text": ["This may be slightly besides the point, but Python has some extremely strange behavior when dealing with multiple threads (particularly bad when the threads aren't IO bound).", "More specifically, it sometimes runs much slower than when single-threaded.", "This is due to the way that the Global Interpreter Lock (GIL) in Python gets used to ensure that no more than one thread can execute in the Python interpreter at any given time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Because of the constraint that only one thread can actually use the interpreter at any given time, the fact that you have multiple cores won't help you.", "In fact, it might actually make things much worse due to some pathological interactions between two threads trying to acquire the GIL.", "If you want to stick to Python you have one of two options:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you want more information on this wonderfully arcane bit of Python look up the talks related to the GIL on this page: http://www.dabeaz.com/talks.html."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.dabeaz.com/talks.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/talks.html"}]}], [{"text": ["I realize that I had nearly exactly the same idea than Winston Ewert: building a regex."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But my regex:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["is done to the cases in which ix_profile &lt; ix_user as well the cases in which ix_profile &gt; ix_user "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "ix_profile &lt; ix_user", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ix_profile &gt; ix_user", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["the regex captures only the user's column: the profile's column is matched with a sub-pattern '\"(?", "!7\")[^\\t\\r\\n\"]*\"' that doesn't match if \"7\" is present in this column; so we obtain only the correct user with the only group defined"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "'\"(?!7\")[^\\t\\r\\n\"]*\"'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\"7\"", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Additionally, I tested several algorithms of matching and extracting: "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["1) with re.finditer()"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "re.finditer()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["2) with re.match() and the regex matching 40 fields"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "re.match()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "40 fields", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["3) withe re.match() and the regex matching only max(ix_profile,ix_user) + 1 fields"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "re.match(", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "max(ix_profile,ix_user) + 1 fields", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["4) like 3 but with a simple dictionary instead of a defaultdict instance"], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "like 3", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "simple dictionary", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["To measure times, my code creates a file based on the information you gave concerning its content."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["I tested the 4 following functions in 4 codes:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": [], "childNum": 0, "tag": "h2", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n def get_users_short_1(log):\n    users_short = defaultdict(int)\n    f = open(log)\n    # Read header line\n    h = f.readline().strip().replace('\"', '').split('\\t')\n    ix_profile = h.index('profile.type')\n    ix_user = h.index('profile.id')\n    # If either ix_* is the last field in h, it will include a newline. \n    # That's fine for now.\n\n    glo = 40*['[^\\t]*']\n    glo[ix_profile] = '\"(?!7\")[^\\t\"]+\"'\n    glo[ix_user] = '\"([^\\t\"]*)\"'\n    glo[39] = '\"[^\\t\\r\\n]*\"'\n    regx = re.compile('^'+'\\t'.join(glo),re.MULTILINE)\n\n    content = f.read()\n    for mat in regx.finditer(content):\n        users_short[mat.group(1)] += 1\n\n    f.close()\n    return users_short\n</code>\n</pre>\n", "senID": 14}, {"text": [], "childNum": 0, "tag": "h2", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n def get_users_short_2(log):\n    users_short = defaultdict(int)\n    f = open(log)\n    # Read header line\n    h = f.readline().strip().replace('\"', '').split('\\t')\n    ix_profile = h.index('profile.type')\n    ix_user = h.index('profile.id')\n    # If either ix_* is the last field in h, it will include a newline. \n    # That's fine for now.\n\n    glo = 40*['[^\\t]*']\n    glo[ix_profile] = '\"(?!7\")[^\\t\"]*\"'\n    glo[ix_user] = '\"([^\\t\"]*)\"'\n    regx = re.compile('\\t'.join(glo))\n\n\n    for line in f:\n        gugu = regx.match(line)\n        if gugu:\n            users_short[gugu.group(1)] += 1\n    f.close()\n    return users_short\n</code>\n</pre>\n", "senID": 16}, {"text": [], "childNum": 0, "tag": "h2", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n def get_users_short_3(log):\n    users_short = defaultdict(int)\n    f = open(log)\n    # Read header line\n    h = f.readline().strip().replace('\"', '').split('\\t')\n    ix_profile = h.index('profile.type')\n    ix_user = h.index('profile.id')\n    # If either ix_* is the last field in h, it will include a newline. \n    # That's fine for now.\n\n    glo = (max(ix_profile,ix_user) + 1) * ['[^\\t]*']\n    glo[ix_profile] = '\"(?!7\")[^\\t\"]*\"'\n    glo[ix_user] = '\"([^\\t\"]*)\"'\n    regx = re.compile('\\t'.join(glo))\n\n    for line in f:\n        gugu = regx.match(line)\n        if gugu:\n            users_short[gugu.group(1)] += 1\n\n    f.close()\n    return users_short\n</code>\n</pre>\n", "senID": 18}, {"text": [], "childNum": 0, "tag": "h2", "senID": 19, "childList": []}, {"text": ["The full code 4, that seems to be the fastest:"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"code": "<pre>\n<code>\n import re\nfrom random import choice,randint,sample\nimport csv\nimport random\nfrom time import clock\n\nchoi = 1\nif choi:\n    ntot = 1000\n    chars = 'abcdefghijklmnopqrstuvwxyz0123456789'\n    def ry(a=30,b=80,chars=chars,nom='abcdefghijklmnopqrstuvwxyz'):\n        if a==30:\n            return ''.join(choice(chars) for i in xrange(randint(30,80)))\n        else:\n            return ''.join(choice(nom) for i in xrange(randint(8,12)))\n\n    num = sample(xrange(1000),200)\n    num.sort()\n    print 'num==',num\n    several = [e//3 for e in xrange(0,800,7) if e//3 not in num]\n    print\n    print 'several==',several\n\n    with open('biggy.txt','w') as f:\n        head = ('aaa','bbb','ccc','ddd','profile.id','fff','ggg','hhhh','profile.type','iiii',\n                'jjj','kkkk','lll','mmm','nnn','ooo','ppp','qq','rr','ss',\n                'tt','uu','vv','ww','xx','yy','zz','razr','fgh','ty',\n                'kfgh','zer','sdfs','fghf','dfdf','zerzre','jkljkl','vbcvb','kljlk','dhhdh')\n        f.write('\\t'.join(head)+'\\n')\n        for i in xrange(1000):\n            li = [ ry(a=8).join('\"\"') if n==4 else ry().join('\"\"')\n                   for n in xrange(40) ]\n            if i in num:\n                li[4] = '@#~&amp;=*;'\n                li[8] = '\"7\"'\n            if i in several:\n                li[4] = '\"BRAD\"'\n            f.write('\\t'.join(li)+'\\n')\n\n\n\nfrom collections import defaultdict\ndef get_users(log):\n    users = defaultdict(int)\n    f = open(log)\n    # Read header line\n    h = f.readline().strip().replace('\"', '').split('\\t')\n    ix_profile = h.index('profile.type')\n    ix_user = h.index('profile.id')\n    # If either ix_* is the last field in h, it will include a newline. \n    # That's fine for now.\n    for (i, line) in enumerate(f): \n        #if i % 1000000 == 0: print \"Line %d\" % i # progress notification\n\n        l = line.split('\\t')\n        if l[ix_profile] != '\"7\"': # \"7\" indicates a bad value\n            # use list slicing to remove quotes\n\n            users[l[ix_user][1:-1]] += 1 \n    f.close()\n    return users\n\n\n\n\ndef get_users_short_4(log):\n    users_short = {}\n    f = open(log)\n    # Read header line\n    h = f.readline().strip().replace('\"', '').split('\\t')\n    ix_profile = h.index('profile.type')\n    ix_user = h.index('profile.id')\n    # If either ix_* is the last field in h, it will include a newline. \n    # That's fine for now.\n\n    glo = (max(ix_profile,ix_user) + 1) * ['[^\\t]*']\n    glo[ix_profile] = '\"(?!7\")[^\\t\"]*\"'\n    glo[ix_user] = '\"([^\\t\"]*)\"'\n    regx = re.compile('\\t'.join(glo))\n\n    for line in f:\n        gugu = regx.match(line)\n        if gugu:\n            gugugroup = gugu.group(1)\n            if gugugroup in users_short:\n                users_short[gugugroup] += 1\n            else:\n                users_short[gugugroup] = 1\n\n    f.close()\n    return users_short\n\n\n\n\nprint '\\n\\n'\n\nte = clock()\nUSERS = get_users('biggy.txt')\nt1 = clock()-te\n\nte = clock()\nUSERS_short_4 = get_users_short_4('biggy.txt')\nt2 = clock()-te\n\n\n\nif choi:\n    print '\\nlen(num)==',len(num),' : number of lines with ix_profile==\\'\"7\"\\''\n    print \"USERS['BRAD']==\",USERS['BRAD']\n    print 'then :'\n    print str(ntot)+' lines - '+str(len(num))+' incorrect - '+str(len(several))+\\\n          ' identical + 1 user BRAD = '+str(ntot - len(num)-len(several)+1)    \nprint '\\nlen(USERS)==',len(USERS)\nprint 'len(USERS_short_4)==',len(USERS_short_4)\nprint 'USERS == USERS_short_4 is',USERS == USERS_short_4\n\nprint '\\n----------------------------------------'\nprint 'time of get_users() :\\n', t1,'\\n----------------------------------------'\nprint 'time of get_users_short_4 :\\n', t2,'\\n----------------------------------------'\nprint 'get_users_short_4() / get_users() = '+str(100*t2/t1)+ ' %'\nprint '----------------------------------------'\n</code>\n</pre>\n", "senID": 21}, {"text": ["One result of this code 4 is for exemple:"], "childNum": 0, "tag": "p", "senID": 22, "childList": []}, {"code": "<pre>\n<code>\n num== [2, 12, 16, 23, 26, 33, 38, 40, 43, 45, 51, 53, 84, 89, 93, 106, 116, 117, 123, 131, 132, 135, 136, 138, 146, 148, 152, 157, 164, 168, 173, 176, 179, 189, 191, 193, 195, 199, 200, 208, 216, 222, 224, 227, 233, 242, 244, 245, 247, 248, 251, 255, 256, 261, 262, 266, 276, 278, 291, 296, 298, 305, 307, 308, 310, 312, 314, 320, 324, 327, 335, 337, 340, 343, 350, 356, 362, 370, 375, 379, 382, 385, 387, 409, 413, 415, 419, 433, 441, 443, 444, 446, 459, 462, 474, 489, 492, 496, 505, 509, 511, 512, 518, 523, 541, 546, 548, 550, 552, 558, 565, 566, 572, 585, 586, 593, 595, 601, 609, 610, 615, 628, 632, 634, 638, 642, 645, 646, 651, 654, 657, 660, 662, 665, 670, 671, 680, 682, 687, 688, 690, 692, 695, 703, 708, 716, 717, 728, 729, 735, 739, 741, 742, 765, 769, 772, 778, 790, 792, 797, 801, 808, 815, 825, 828, 831, 839, 849, 858, 859, 862, 864, 872, 874, 890, 899, 904, 906, 913, 916, 920, 923, 928, 941, 946, 947, 953, 955, 958, 959, 961, 971, 975, 976, 979, 981, 985, 989, 990, 999]\n\nseveral== [0, 4, 7, 9, 11, 14, 18, 21, 25, 28, 30, 32, 35, 37, 39, 42, 44, 46, 49, 56, 58, 60, 63, 65, 67, 70, 72, 74, 77, 79, 81, 86, 88, 91, 95, 98, 100, 102, 105, 107, 109, 112, 114, 119, 121, 126, 128, 130, 133, 137, 140, 142, 144, 147, 149, 151, 154, 156, 158, 161, 163, 165, 170, 172, 175, 177, 182, 184, 186, 196, 198, 203, 205, 207, 210, 212, 214, 217, 219, 221, 226, 228, 231, 235, 238, 240, 249, 252, 254, 259, 263]\n\n\n\n\nlen(num)== 200  : number of lines with ix_profile=='\"7\"'\nUSERS['BRAD']== 91\nthen :\n1000 lines - 200 incorrect - 91 identical + 1 user BRAD = 710\n\nlen(USERS)== 710\nlen(USERS_short_4)== 710\nUSERS == USERS_short_4 is True\n\n----------------------------------------\ntime of get_users() :\n0.0788686830309 \n----------------------------------------\ntime of get_users_short_4 :\n0.0462885646081 \n----------------------------------------\nget_users_short_4() / get_users() = 58.690677756 %\n----------------------------------------\n</code>\n</pre>\n", "senID": 23}, {"text": ["But results are more or less variable.", "I obtained:"], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"code": "<pre>\n<code>\n get_users_short_1() / get_users() = 82.957476637 %\nget_users_short_1() / get_users() = 82.3987686867 %\nget_users_short_1() / get_users() = 90.2949842932 %\nget_users_short_1() / get_users() = 78.8063007461 %\nget_users_short_1() / get_users() = 90.4743181768 %\nget_users_short_1() / get_users() = 81.9635560003 %\nget_users_short_1() / get_users() = 83.9418269406 %\nget_users_short_1() / get_users() = 89.4344442255 %\n\n\nget_users_short_2() / get_users() = 80.4891442088 %\nget_users_short_2() / get_users() = 69.921943776 %\nget_users_short_2() / get_users() = 81.8006709304 %\nget_users_short_2() / get_users() = 83.6270772928 %\nget_users_short_2() / get_users() = 97.9821084403 %\nget_users_short_2() / get_users() = 84.9307558629 %\nget_users_short_2() / get_users() = 75.9384820018 %\nget_users_short_2() / get_users() = 86.2964748485 %\n\n\nget_users_short_3() / get_users() = 69.4332754744 %\nget_users_short_3() / get_users() = 58.5814726668 %\nget_users_short_3() / get_users() = 61.8011476831 %\nget_users_short_3() / get_users() = 67.6925083362 %\nget_users_short_3() / get_users() = 65.1208124156 %\nget_users_short_3() / get_users() = 72.2621727569 %\nget_users_short_3() / get_users() = 70.6957501222 %\nget_users_short_3() / get_users() = 68.5310031226 %\nget_users_short_3() / get_users() = 71.6529128259 %\nget_users_short_3() / get_users() = 71.6153554073 %\nget_users_short_3() / get_users() = 64.7899044975 %\nget_users_short_3() / get_users() = 72.947531363 %\nget_users_short_3() / get_users() = 65.6691965629 %\nget_users_short_3() / get_users() = 61.5194374401 %\nget_users_short_3() / get_users() = 61.8396133666 %\nget_users_short_3() / get_users() = 71.5447862466 %\nget_users_short_3() / get_users() = 74.6710538858 %\nget_users_short_3() / get_users() = 72.9651233485 %\n\n\n\nget_users_short_4() / get_users() = 65.5224210767 %\nget_users_short_4() / get_users() = 65.9023813161 %\nget_users_short_4() / get_users() = 62.8055210129 %\nget_users_short_4() / get_users() = 64.9690049062 %\nget_users_short_4() / get_users() = 61.9050866134 %\nget_users_short_4() / get_users() = 65.8127125992 %\nget_users_short_4() / get_users() = 66.8112344201 %\nget_users_short_4() / get_users() = 57.865635278 %\nget_users_short_4() / get_users() = 62.7937713964 %\nget_users_short_4() / get_users() = 66.3440149528 %\nget_users_short_4() / get_users() = 66.4429530201 %\nget_users_short_4() / get_users() = 66.8692388625 %\nget_users_short_4() / get_users() = 66.5949137537 %\nget_users_short_4() / get_users() = 69.1708488794 %\nget_users_short_4() / get_users() = 59.7129743801 %\nget_users_short_4() / get_users() = 59.755297387 %\nget_users_short_4() / get_users() = 60.6436352185 %\nget_users_short_4() / get_users() = 64.5023727945 %\nget_users_short_4() / get_users() = 64.0153937511 %\n</code>\n</pre>\n", "senID": 25}, {"text": [], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"text": ["I'd like to know what kind of result you would obtain with my code on your real file with a computer certainly more powerful than mine.", "Please, give me news."], "childNum": 0, "tag": "p", "senID": 27, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 28, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 29, "childList": []}, {"text": ["EDIT 1"], "childNum": 0, "tag": "h2", "senID": 30, "childList": []}, {"text": ["With"], "childNum": 0, "tag": "p", "senID": 31, "childList": []}, {"code": "<pre>\n<code>\n def get_users_short_Machin(log):\n    users_short = defaultdict(int)\n    f = open(log)\n    # Read header line\n    h = f.readline().strip().replace('\"', '').split('\\t')\n    ix_profile = h.index('profile.type')\n    ix_user = h.index('profile.id')\n    maxsplits = max(ix_profile, ix_user) + 1\n    # If either ix_* is the last field in h, it will include a newline. \n    # That's fine for now.\n    for line in f: \n        #if i % 1000000 == 0: print \"Line %d\" % i # progress notification\n        l = line.split('\\t', maxsplits)\n        if l[ix_profile] != '\"7\"': # \"7\" indicates a bad value\n            # use list slicing to remove quotes\n            users_short[l[ix_user][1:-1]] += 1 \n    f.close()\n    return users_short\n</code>\n</pre>\n", "senID": 32}, {"text": ["I've got"], "childNum": 0, "tag": "p", "senID": 33, "childList": []}, {"code": "<pre>\n<code>\n get_users_short_Machin() / get_users() = 60.6771821308 %\nget_users_short_Machin() / get_users() = 71.9300992989 %\nget_users_short_Machin() / get_users() = 85.1695214715 %\nget_users_short_Machin() / get_users() = 72.7722233685 %\nget_users_short_Machin() / get_users() = 73.6311173237 %\nget_users_short_Machin() / get_users() = 86.0848484053 %\nget_users_short_Machin() / get_users() = 75.1661981729 %\nget_users_short_Machin() / get_users() = 72.8888452474 %\nget_users_short_Machin() / get_users() = 76.7185685993 %\nget_users_short_Machin() / get_users() = 82.7007096958 %\nget_users_short_Machin() / get_users() = 71.1678957888 %\nget_users_short_Machin() / get_users() = 71.9845835126 %\n</code>\n</pre>\n", "senID": 34}, {"text": ["Using a simple dict:"], "childNum": 0, "tag": "p", "senID": 35, "childList": []}, {"code": "<pre>\n<code>\n users_short = {}\n.......\nfor line in f: \n    #if i % 1000000 == 0: print \"Line %d\" % i # progress notification\n    l = line.split('\\t', maxsplits)\n    if l[ix_profile] != '\"7\"': # \"7\" indicates a bad value\n        # use list slicing to remove quotes\n        us = l[ix_user][1:-1]\n        if us not in users_short:\n            users_short[us] = 1\n        else:\n            users_short[us] += 1\n</code>\n</pre>\n", "senID": 36}, {"text": ["improves a little the execution's time but it remains higher than my last code 4"], "childNum": 0, "tag": "p", "senID": 37, "childList": []}, {"code": "<pre>\n<code>\n get_users_short_Machin2() / get_users() = 71.5959919389 %\nget_users_short_Machin2() / get_users() = 71.6118864535 %\nget_users_short_Machin2() / get_users() = 66.3832514274 %\nget_users_short_Machin2() / get_users() = 68.0026407277 %\nget_users_short_Machin2() / get_users() = 67.9853921552 %\nget_users_short_Machin2() / get_users() = 69.8946203037 %\nget_users_short_Machin2() / get_users() = 71.8260030248 %\nget_users_short_Machin2() / get_users() = 78.4243267003 %\nget_users_short_Machin2() / get_users() = 65.7223734428 %\nget_users_short_Machin2() / get_users() = 69.5903935612 %\n</code>\n</pre>\n", "senID": 38}, {"text": [], "childNum": 0, "tag": "p", "senID": 39, "childList": []}, {"text": ["EDIT 2"], "childNum": 0, "tag": "h2", "senID": 40, "childList": []}, {"text": ["The fastest:"], "childNum": 0, "tag": "p", "senID": 41, "childList": []}, {"code": "<pre>\n<code>\n def get_users_short_CSV(log):\n    users_short = {}\n    f = open(log,'rb')\n    rid = csv.reader(f,delimiter='\\t')\n    # Read header line\n    h = rid.next()\n    ix_profile = h.index('profile.type')\n    ix_user = h.index('profile.id')\n    # If either ix_* is the last field in h, it will include a newline. \n    # That's fine for now.\n\n    glo = (max(ix_profile,ix_user) + 1) * ['[^\\t]*']\n    glo[ix_profile] = '\"(?!7\")[^\\t\\r\\n\"]*\"'\n    glo[ix_user] = '\"([^\\t\\r\\n\"]*)\"'\n    regx = re.compile('\\t'.join(glo))\n\n    for line in f:\n        gugu = regx.match(line)\n        if gugu:\n            gugugroup = gugu.group(1)\n            if gugugroup in users_short:\n                users_short[gugugroup] += 1\n            else:\n                users_short[gugugroup] = 1\n\n    f.close()\n    return users_short\n</code>\n</pre>\n", "senID": 42}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 43, "childList": []}, {"code": "<pre>\n<code>\n get_users_short_CSV() / get_users() = 31.6443901114 %\nget_users_short_CSV() / get_users() = 44.3536176134 %\nget_users_short_CSV() / get_users() = 47.2295100511 %\nget_users_short_CSV() / get_users() = 45.4912200716 %\nget_users_short_CSV() / get_users() = 63.7997241038 %\nget_users_short_CSV() / get_users() = 43.5020255488 %\nget_users_short_CSV() / get_users() = 40.9188320386 %\nget_users_short_CSV() / get_users() = 43.3105062139 %\nget_users_short_CSV() / get_users() = 59.9184895288 %\nget_users_short_CSV() / get_users() = 40.22047881 %\nget_users_short_CSV() / get_users() = 48.3615872543 %\nget_users_short_CSV() / get_users() = 47.0374831251 %\nget_users_short_CSV() / get_users() = 44.5268626789 %\nget_users_short_CSV() / get_users() = 53.1690205938 %\nget_users_short_CSV() / get_users() = 43.4022458372 %\n</code>\n</pre>\n", "senID": 44}, {"text": [], "childNum": 0, "tag": "p", "senID": 45, "childList": []}, {"text": ["EDIT 3"], "childNum": 0, "tag": "h2", "senID": 46, "childList": []}, {"text": ["I tested get_users_short_CSV() with 10000 lines in the file instead of only 1000:"], "childNum": 1, "tag": "p", "senID": 47, "childList": [{"text": "get_users_short_CSV()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n len(num)== 2000  : number of lines with ix_profile=='\"7\"'\nUSERS['BRAD']== 95\nthen :\n10000 lines - 2000 incorrect - 95 identical + 1 user BRAD = 7906\n\nlen(USERS)== 7906\nlen(USERS_short_CSV)== 7906\nUSERS == USERS_short_CSV is True\n\n----------------------------------------\ntime of get_users() :\n0.794919186656 \n----------------------------------------\ntime of get_users_short_CSV :\n0.358942826532 \n----------------------------------------\nget_users_short_CSV() / get_users() = 41.5618307521 %\n\nget_users_short_CSV() / get_users() = 42.2769300584 %\nget_users_short_CSV() / get_users() = 45.154631132 %\nget_users_short_CSV() / get_users() = 44.1596819482 %\nget_users_short_CSV() / get_users() = 30.3192350266 %\nget_users_short_CSV() / get_users() = 34.4856637748 %\nget_users_short_CSV() / get_users() = 43.7461535628 %\nget_users_short_CSV() / get_users() = 41.7577246935 %\nget_users_short_CSV() / get_users() = 41.9092878608 %\nget_users_short_CSV() / get_users() = 44.6772360665 %\nget_users_short_CSV() / get_users() = 42.6770989413 %\n</code>\n</pre>\n", "senID": 48}]]