[[{"text": ["Your interviewers must have had a \"functional background\" way back.", "It used to be common to write"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (or (some-condition) (some-side-effect))\n</code>\n</pre>\n", "senID": 1}, {"text": ["but in CL and in Scheme implementation that support it, it is much better written with unless.", "Same goes for and vs when."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "unless", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "and", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "when", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So, to be more concrete -- it's not more functional (and in fact the common use of these things was for one-sided conditionals, which are not functional to begin with); there is no advantage (which becomes very obvious in these languages when you know that things are implemented as macros anyway -- for example, most or and and implementations expand to an if); and any possible use cases should use when and unless if you have them in your implementation, otherwise it's better to define them as macros than to not use them."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "or", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "and", "childNum": 0, "tag": "code", "childList": []}, {"text": "if", "childNum": 0, "tag": "code", "childList": []}, {"text": "when", "childNum": 0, "tag": "code", "childList": []}, {"text": "unless", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Oh, and you could use a combination of them instead of a two sided if, but that would be obfuscatingly ugly."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I'm not aware of any issues with the way this code will execute, but it is confusing to read for the uninitiated.", "In fact, this kind of syntax is like a Python anti-pattern:  you can do it, but it is in no way Pythonic."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["condition and true_branch or false_branch works in all languages that have short circuting logical operators.", "On the other hand it's not really a good idea to use in a language where values have a boolean value."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "condition and true_branch or false_branch", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For example"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n zero = (1==0) and 0 or 1   # (1==0) -&gt; False \nzero = (False and 0) or 1  # (False and X) -&gt; X\nzero = 0 or 1              # 0 is False in most languages\nzero = False or 1 \nzero = 1\n</code>\n</pre>\n", "senID": 2}], [{"text": ["As Eli said; also, performing control flow purely with logical operators tends to be taught in introductory FP classes -- more as a mind exercise, really, not something that you necessarily want to use IRL.", "It's always good to be able to translate any control operator down to if."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Now, the big difference between FPs and other languages is that, in more functional languages, if is actually an expression, not a statement.", "An if block always has a value!", "The C family of languages has a macro version of this -- the test?", "consequent : alternative construct -- but it gets really unreadable if you nest more expressions."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "if", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "if", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "always", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "test? consequent : alternative", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Prior to Python 2.5, if you want to have a control-flow expression in Python you might have to use logical operators.", "In Python 2.5, though, there is an FP-like if-expression syntax, so you can do something like this:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "is", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n (42 if True else 7) + 35\n</code>\n</pre>\n", "senID": 3}, {"text": ["See PEP 308"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "PEP 308", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/whatsnew/2.5.html"}]}], [{"text": ["You only mention the case where there are exactly 2 expressions to evaluate.", "What happens if there are 5?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ;; returns first true value, evaluating only as many as needed\n(or (f x) (g x) (h x) (i x) (j x))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Would you nest if-statements?", "I'm not sure how I'd do this in Python.", "It's almost like this:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "almost", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n any(c(x) for c in [f, g, h, i, j])\n</code>\n</pre>\n", "senID": 3}, {"text": ["except Python's any throws away the value and just returns True.", "(There might be a way to do it with itertools.dropwhile, but it seems a little awkward to me.", "Or maybe I'm just missing the obvious way."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "any", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "itertools.dropwhile", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["(As an aside: I find that Lisp's builtins don't quite correspond to what their names are in other languages, which can be confusing.", "Lisp's IF is like C's ternary operator ?", ": or Python's conditional expressions, for example, not their if-statements.", "Likewise, Lisp's OR is in some ways more like (but not exactly like) Python's any(), which only takes 2 expressions.", "Since the normal IF returns a value already, there's no point in having a separate kind of \"if\" that can't be used like this, or a separate kind of \"or\" that only takes two values.", "It's already as flexible as the less common variant in other languages."], "childNum": 6, "tag": "p", "senID": 5, "childList": [{"text": "quite", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "IF", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "?:", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "OR", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "any()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "IF", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"text": ["I happen to be writing code like this right now, coincidentally, where some of the functions are \"go ask some server for an answer\", and I want to stop as soon as I get a positive response.", "I'd never use OR where I really want to say IF, but I'd rather say:"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "OR", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "IF", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n (setq did-we-pass (or (try-this x)\n                      (try-that x)\n                      (try-some-other-thing x)\n                      (heck-maybe-this-will-work x))\n</code>\n</pre>\n", "senID": 7}, {"text": ["than make a big tree of IFs.", "Does that qualify as \"flow control\" or \"functional\"?", "I guess it depends on your definitions."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["You could use bar if bar else [], but it's quite elaborate."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "bar if bar else []", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]