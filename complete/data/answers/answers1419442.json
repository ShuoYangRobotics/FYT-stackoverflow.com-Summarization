[[{"text": ["If you think the link app will always point to a single app then one approach would be to pass the name of the foreign model as a string containing the application label instead of a class reference (Django docs explanation)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Django docs explanation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev/ref/models/fields/#foreignkey"}]}, {"text": ["In other words, instead of:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Link(models.Model):\n    blog_post = models.ForeignKey(BlogPost)\n</code>\n</pre>\n", "senID": 2}, {"text": ["do:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from django.conf import setings\nclass Link(models.Model):\n    link_model = models.ForeignKey(settings.LINK_MODEL)\n</code>\n</pre>\n", "senID": 4}, {"text": ["and in your settings.py:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n LINK_MODEL = 'someproject.somemodel'\n</code>\n</pre>\n", "senID": 6}], [{"text": ["I think TokenMacGuy is on the right track.", "I would look at how django-tagging handles a similar generic relationship using the content type, generic object_id, and generic.py.", "From models.py"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "django-tagging", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.google.com/p/django-tagging/"}, {"text": "and generic.py", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://code.google.com/p/django-tagging/source/browse/trunk/tagging/generic.py"}, {"text": "models.py", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://code.google.com/p/django-tagging/source/browse/trunk/tagging/models.py"}]}, {"code": "<pre>\n<code>\n class TaggedItem(models.Model):\n    \"\"\"\n    Holds the relationship between a tag and the item being tagged.\n    \"\"\"\n    tag          = models.ForeignKey(Tag, verbose_name=_('tag'), related_name='items')\n    content_type = models.ForeignKey(ContentType, verbose_name=_('content type'))\n    object_id    = models.PositiveIntegerField(_('object id'), db_index=True)\n    object       = generic.GenericForeignKey('content_type', 'object_id')\n\n    objects = TaggedItemManager()\n\n    class Meta:\n        # Enforce unique tag association per object\n        unique_together = (('tag', 'content_type', 'object_id'),)\n        verbose_name = _('tagged item')\n        verbose_name_plural = _('tagged items')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Probably you need to use the content types app to link to a model.", "You might then arrange for your app to check the settings to do some additional checking to limit which content types it will accept or suggest."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I'd go with generic relations.", "You can do something like select_related, it just require some extra work.", "But I think it's worth it. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One possible solution for generic select_related-like functionality: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://bitbucket.org/kmike/django-generic-images/src/tip/generic_utils/managers.py"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://bitbucket.org/kmike/django-generic-images/src/tip/generic_utils/managers.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bitbucket.org/kmike/django-generic-images/src/tip/generic%5Futils/managers.py"}]}, {"text": ["(look at GenericInjector manager and it's inject_to method)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This question and Van Gale's answer lead me to the question, how it could be possible, to limit contenttypes for GFK without the need of defining it via Q objects in the model, so it could be completly reuseable"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1419442/how-to-model-a-foreign-key-in-a-reusable-django-app/1419704#1419704"}]}, {"text": ["the solution is based on"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "django.db.models.get_model", "tag": "none", "senID": 2}, {"text": "and the eval built-in, that evaluates a Q-Object from ", "tag": "none", "senID": 3}]}, {"text": ["My code is quite rough and not fully tested"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["settings.py"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n TAGGING_ALLOWED=('myapp.modela', 'myapp.modelb')\n</code>\n</pre>\n", "senID": 6}, {"text": ["models.py:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n from django.db import models\nfrom django.db.models import Q\nfrom django.contrib.contenttypes.models import ContentType\nfrom django.contrib.contenttypes import generic\nfrom django.db.models import get_model\nfrom django.conf import settings as s\nfrom django.db import IntegrityError\n\nTAGABLE = [get_model(i.split('.')[0],i.split('.')[1]) \n        for i in s.TAGGING_ALLOWED if type(i) is type('')]\nprint TAGABLE\n\nTAGABLE_Q = eval( '|'.join(\n    [\"Q(name='%s', app_label='%s')\"%(\n        i.split('.')[1],i.split('.')[0]) for i in s.TAGGING_ALLOWED\n    ]\n))\n\nclass TaggedItem(models.Model):\n    content_type = models.ForeignKey(ContentType, \n                    limit_choices_to = TAGABLE_Q)                               \n    object_id = models.PositiveIntegerField()\n    content_object = generic.GenericForeignKey('content_type', 'object_id')\n\n    def save(self, force_insert=False, force_update=False):\n        if self.content_object and not type(\n            self.content_object) in TAGABLE:\n            raise IntegrityError(\n               'ContentType %s not allowed'%(\n                type(kwargs['instance'].content_object)))\n        super(TaggedItem,self).save(force_insert, force_update)\n\nfrom django.db.models.signals import post_init\ndef post_init_action(sender, **kwargs):\n    if kwargs['instance'].content_object and not type(\n        kwargs['instance'].content_object) in TAGABLE:\n        raise IntegrityError(\n           'ContentType %s not allowed'%(\n            type(kwargs['instance'].content_object)))\n\npost_init.connect(post_init_action, sender= TaggedItem)\n</code>\n</pre>\n", "senID": 8}, {"text": ["Of course the limitations of the contenttype-framework affect this solution"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n # This will fail\n&gt;&gt;&gt; TaggedItem.objects.filter(content_object=a)\n# This will also fail\n&gt;&gt;&gt; TaggedItem.objects.get(content_object=a)\n</code>\n</pre>\n", "senID": 10}], [{"text": ["Anoher way to solve this is how django-mptt does this: define only an abstract model in a reusable app(MPTTModel), and require to inherit it with defining some fields (parent=ForeignKey to self, or whatever your app usecase will require)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "django-mptt", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://django-mptt.github.com/django-mptt/models.html"}]}]]