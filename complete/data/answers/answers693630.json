[[{"text": ["Another option is to use the built-in map function:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; my_list = [[1,2,3],[4,5,6],[7,8,9]]\n&gt;&gt;&gt; neg = lambda x: -x\n&gt;&gt;&gt; f = lambda x: map(neg, x)\n&gt;&gt;&gt; map(f, my_list)\n[[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It's possible to code a more general solution to this problem.", "The following works in Python 3.0, regardless of the level of nesting."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "regardless of the level of nesting", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Let's define recursive_map:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "recursive_map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import collections\n\ndef recursive_map(f, iterable):\n    for e in iterable:\n        if isinstance(e, collections.Iterable):\n            yield recursive_map(f, e)\n        else:\n            yield f(e)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now, the requested negation function can be coded as follows:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import functools\nimport operator\n\nnegate = functools.partial(recursive_map, operator.neg)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Thus, for some collection of arbitrarily nested iterables x, we calculate its negation y like this:"], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "iterables", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n y = negate(x)\n</code>\n</pre>\n", "senID": 6}, {"tag": "hr", "senID": 7}, {"text": ["Addendum:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Addendum:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["As noted by user chradcliffe, the above negate function yields a generator which may contain other generators which ..., etc.", "To expand/evaluate all these generators, we need to apply list() to all of them.", "So we define another general mapping function, this time one that works on the iterables themselves."], "childNum": 3, "tag": "p", "senID": 9, "childList": [{"text": "chradcliffe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/77028/chradcliffe"}, {"text": "negate", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "list()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def recursive_iter_map(f, iterable):\n    def rec(e):\n        if isinstance(e, collections.Iterable):\n            return recursive_iter_map(f, e)\n        else:\n            return e\n\n    return f(map(rec, iterable))\n</code>\n</pre>\n", "senID": 10}, {"text": ["Now,"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n all_lists = functools.partial(recursive_iter_map, list)\ny = all_lists(negate(x))\n</code>\n</pre>\n", "senID": 12}, {"text": ["will actually negate every element right away and return the complete list."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["Note that we can regard a nested collection of iterables as a tree.", "Each iterable is a subtree, while non-iterables are leaves.", "Hence the first function I defined works on leaves, and the second function works on non-leaves."], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "tree", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Many answers are about creating altered copy of list, but literal meaning of question is about in-place modification of list."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "copy", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Here is my version of best-of-breed in-place list altering solution:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def alter_elements(lst, func):\n  for i, item in enumerate(lst):\n    if isinstance(item, list):\n      alter_elements(item, func)\n    else:\n      lst[i] = func(item)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Test run:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sample = [[1,2,3],[4,5,6],[7,8,9]]\n&gt;&gt;&gt; alter_elements(sample, lambda x: -x)\n&gt;&gt;&gt; print sample\n&gt;&gt;&gt; [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]\n</code>\n</pre>\n", "senID": 4}, {"text": ["No list copies.", "No hardcoded bounds.", "No list comprehensions with side-effects."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["By \"alter\" I assume you mean \"negate\" (but you should have said that)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I notice that you're iterating over each element of a two-dimensional array (a list of lists) and treating each element as a list of three elements... but in fact each element is just a number, in your question as stated.", "So I would do something like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n my_list = [[-n for n in l] for l in my_list]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n my_list = [[-a, -b, -c] for [a, b, c] in my_list]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that this creates a new list, rather than altering the list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As others have noted, there are two \"levels\" of lists and one \"level\" of ints, so two loops gives you an int, not another list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For comparison, the loop version should be:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for x in range(0, 3):\n    for y in range(0, 3):\n        my_list[x][y] = -my_list[x][y]\n</code>\n</pre>\n", "senID": 2}, {"text": ["That also fixes the bounds for your range.", "The upper bound is exclusive, not inclusive."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Although Constantin's answer is correct, I would make two improvements:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So here's my alternative, which also modifies the list and all inner lists in-place:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def lst_apply(lst, func, lvl):\n    if lvl:\n        for x in lst:\n            lst_apply(x, func, lvl - 1)\n    else:\n        lst[:] = [func(x) for x in lst]\n\n&gt;&gt;&gt; lst_apply(my_list, lambda x: -x, 1)\n&gt;&gt;&gt; my_list\n[[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]\n</code>\n</pre>\n", "senID": 2}, {"text": ["I still believe, though, that the best approach here is:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def simple_apply(lst, func):\n    lst[:] = [[func(x) for x in y] for y in lst]\n</code>\n</pre>\n", "senID": 4}, {"text": ["timeit results:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "timeit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": ["simple_apply"], "childNum": 0, "tag": "code", "senID": 6, "childList": []}, {"text": ["lst_apply"], "childNum": 0, "tag": "code", "senID": 7, "childList": []}, {"text": ["alter_elements"], "childNum": 0, "tag": "code", "senID": 8, "childList": []}]}], [{"text": ["It is ugly but you can modify the list in-place with a list comprehension if you really want to."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; my_list = [[1,2,3],[4,5,6],[7,8,9]]\n&gt;&gt;&gt; [[slist.__setitem__(i, -n) for i, n in enumerate(slist)] for slist in my_list]\n[[None, None, None], [None, None, None], [None, None, None]]\n&gt;&gt;&gt; my_list\n[[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Using explicit for loops, as shown in other answers, is considered better style when side-effects are involved, however.", "I think a nice form for the for loop style is:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n for nested_list in my_list:\n    for i, x in enumerate(nested_list):\n        nested_list[i] = -x\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If you have a 3x3 array of numbers, and you want to perform a transformation on every element of it, I suspect you may be better served in the long run by using a numerical library like NumPy/SciPy, and using the matrix routines it provides.", "If you are in any way interested in high performance, then this would be a necessity.", "Much of python's flexibility can be foregone at the array element level in exchange for optimised numerical algorithm speed."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]