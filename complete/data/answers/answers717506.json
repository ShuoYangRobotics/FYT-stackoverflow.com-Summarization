[[{"text": ["It's a technique less practised in Python, in part because \"core\" classes in Python (those implemented in C) are not really modifiable.", "In Ruby, on the other hand, because of the way it's implemented internally (not better, just different) just about anything can be modified dynamically."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Philosophically, it's something that tends to be frowned on within the Python community, distinctly less so in the Ruby world.", "I don't know why you assert that it's more controversial (can you link to an authoritative reference?", ") - my experience has been that monkey-patching is an accepted technique if one where the user should be aware of possible consequences."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The languages might permit it, but neither community condones the practice.", "Monkeypatching isn't condoned in either language, but you hear about it more often in Ruby because the form of open class it uses makes it very, very easy to monkeypatch a class and because of this, it's more acceptable in the Ruby community, but still frowned upon.", "Monkeypatching simply isn't as prevalent or as easy in Python, which is why you won't hear the same arguments against it in that community.", "Python does nothing that Ruby doesn't do to prevent the practice."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "it's more acceptable in the Ruby community, but still frowned upon", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://avdi.org/devblog/2008/02/23/why-monkeypatching-is-destroying-ruby/"}]}, {"text": ["The reason you hear/read about it more often in Ruby is that this in Ruby:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class MyClass\n  def foo\n    puts \"foo\"\n  end\nend\n\nclass MyClass\n  def bar\n    puts \"bar\"\n  end\nend\n</code>\n</pre>\n", "senID": 2}, {"text": ["Will give you a class that contains two methods, foo and bar, whereas this in Python:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "bar", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class MyClass:\n    def foo(self):\n        print \"foo\"\n\nclass MyClass:\n    def bar(self):\n        print \"bar\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["Will leave you with a class that only contains the method bar as redefinition of a class clobbers the previous definition completely.", "That alone makes Ruby code much easier to monkeypatch than Python code."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "bar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["\"Does Python include different types of safeguards to minimize the risks of this feature?", "\"  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Yes.", "The community refuses to do it.", "The safeguard is entirely social."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["As a Python programmer who has had a taste of Ruby (and likes it), I think there is somewhat of an ironic parallel to when Python was beginning to become popular."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["C and Java programmers would 'bash' Python, stating that it wasn't a real language, and that the dynamic nature of its types would be dangerous, and allow people to create 'bad' code.", "As python became more popular, and the advantages of its rapid development time became apparent, not to mention the less verbose syntax:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n // Java\nPerson p = new Person();\n\n# Python\np = Person()\n</code>\n</pre>\n", "senID": 2}, {"text": ["we began to see some more dynamic features appear in later versions of Java.", "Autoboxing and -unboxing make it less troublesome to deal with primitives, and Generics allow us to code once and apply it to many types."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["It was with some amusement that I saw one of the key flexible features of Ruby - Monkey Patching, being touted as dangerous by the Python crowd.", "Having started teaching Ruby to students this year, being able to 'fix' the implementation of an existing class, even one that is part of the system is very powerful."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Sure, you can screw up badly and your program can crash.", "I can segfault in C pretty easily, too.", "And Java apps can die flaming death."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The truth is, I see Monkey Patching as the next step in dynamic and meta-programming.", "Funny, since it has been around since Smalltalk."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["In python, any literal (\"\",{}, 1.0, etc) creates an instance of the standard class, even if you tried to monkeypatch it and redefined the corresponding class in your namespace."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It just won't work how you intended:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class str():\n    # define your custom string type\n    ...\n\na = \"foo\"      # still a real python string\na = str(\"foo\") # only this uses your custom class\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Actually in Python it's a bit harder to modify basic types. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example imagine, that you redefine integer."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Ruby:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class Fixnum \n   def *(n)\n      5 \n   end \nend\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now 2*2 yields 5."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Python:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class int(int):\n    def __mul__(self, x):\n    \treturn 5\n\n\n&gt;&gt;&gt; 2*2\n4\n&gt;&gt;&gt; int(2)*int(2)\n5\n</code>\n</pre>\n", "senID": 6}], [{"text": ["I think that monkey patching should only be used as the last solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Normally Python programmers know how a class or a method behave.", "They know that class xxx is doing things in a certain way."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["When you monkey patch a class or a method, you are changing it's behavior.", "Other Python programmers using this class can be very surprised if that class is behaving differently."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The normal way of doing things is subclassing.", "That way, other programmers know that they are using a different object.", "They can use the original class or the subclass if they choose to."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you want to do some monkey patching in Python, it is relatively easy, as long as you are not modifying a built-in type (int, float, str)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class SomeClass:\n    def foo(self):\n        print \"foo\"\n\ndef tempfunc(self):\n    print \"bar\"\nSomeClass.bar = tempfunc\ndel tempfunc\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will add the bar method to SomeClass and even existing instances of that class can use that injected method."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]