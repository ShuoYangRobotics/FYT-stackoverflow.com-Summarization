[[{"text": ["Try using split."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s= \"| 'TOMATOES_PICKED'                                  |       914 |       1397 |\"\nprint map(lambda x:x.strip(\"' \"),s.split('|'))[1:-1]\n</code>\n</pre>\n", "senID": 1}, {"tag": "ul", "num": 3, "lis": [{"text": "Split : transform your string into a list of string", "tag": "none", "senID": 2}, {"text": "lambda function : removes spaces and ", "tag": "none", "senID": 3}, {"text": "Selector : take only expected parts", "tag": "none", "senID": 4}]}], [{"text": ["Not sure that i have correctly understood you but try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nprint re.findall(r'\\b\\w+\\b', yourtext)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would use a single regular expression to match the entire line, with the parts I want in named groups ((?P&lt;name&gt;exampl*e))."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "(?P&lt;name&gt;exampl*e)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import re\ndef extract_data2(s):\n    pattern = re.compile(r\"\"\"\\|\\s*                 # opening bar and whitespace\n                             '(?P&lt;name&gt;.*?)'       # quoted name\n                             \\s*\\|\\s*(?P&lt;n1&gt;.*?)   # whitespace, next bar, n1\n                             \\s*\\|\\s*(?P&lt;n2&gt;.*?)   # whitespace, next bar, n2\n                             \\s*\\|\"\"\", re.VERBOSE)\n    match = pattern.match(s)\n\n    name = match.group(\"name\")\n    n1 = float(match.group(\"n1\"))\n    n2 = float(match.group(\"n2\"))\n\n    return (name, n1, n2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["To convert n1 and n2 from strings to numbers, I use the float function.", "(If they were only integers, I would use the int function."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "n1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "n2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "float", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I used the re.VERBOSE flag and raw multiline strings (r\"\"\"...\"\"\") to make the regex easier to read."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "re.VERBOSE", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "r\"\"\"...\"\"\"", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Using regex:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #! /usr/bin/env python\n\nimport re\n\ntests = [\n\"| 'TOMATOES_PICKED'                                  |       914 |       1397 |\",\n\"| 'TOMATOES_FLICKED'                                 |     32914 |       1123 |\",\n\"| 'TOMATOES_RIGGED'                                  |        14 |       1343 |\",\n\"| 'TOMATOES_PICKELED'                                |         4 |         23 |\"]\n\ndef parse (s):\n    mo = re.match (\"\\\\|\\s*'([^']*)'\\s*\\\\|\\s*(\\d*)\\s*\\\\|\\s*(\\d*)\\s*\\\\|\", s)\n    if mo: return mo.groups ()\n\nfor test in tests: print parse (test)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I would have to agree with the other posters that said use the split() method on your strings.", "If your given string is,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt; s = \"| 'TOMATOES_PICKED'                          |       914 |       1397 |\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["You just split the string and voila, you now have a list with the name in the second position, and the two values in the following entries, i.e."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt; s_new = s.split()\n&gt;&gt; s_new\n['|', \"'TOMATOES_PICKED'\", '|', '914', '|', '1397', '|']\n</code>\n</pre>\n", "senID": 3}, {"text": ["Of course you do also have the \"|\" character but that seems to be consistent in your data set so it isn't a big problem to deal with.", "Just ignore them."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["With pyparsing, you can have the parser create a dict-like structure for you, using the first column values as the keys, and the subsequent values as an array of values for that key:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from pyparsing import *\n&gt;&gt;&gt; s = \"| 'TOMATOES_PICKED'                                  |       914 |       1397 |\"\n&gt;&gt;&gt; VERT = Suppress('|')\n&gt;&gt;&gt; title = quotedString.setParseAction(removeQuotes)\n&gt;&gt;&gt; integer = Word(nums).setParseAction(lambda tokens:int(tokens[0]))\n&gt;&gt;&gt; entry = Group(VERT + title + VERT + integer + VERT + integer + VERT)\n&gt;&gt;&gt; entries = Dict(OneOrMore(entry))\n&gt;&gt;&gt; data = entries.parseString(s)\n&gt;&gt;&gt; data.keys()\n['TOMATOES_PICKED']\n&gt;&gt;&gt; data['TOMATOES_PICKED']\n([914, 1397], {})\n&gt;&gt;&gt; data['TOMATOES_PICKED'].asList()\n[914, 1397]\n&gt;&gt;&gt; data['TOMATOES_PICKED'][0]\n914\n&gt;&gt;&gt; data['TOMATOES_PICKED'][1]\n1397\n</code>\n</pre>\n", "senID": 1}, {"text": ["This already comprehends multiple entries, so you can just pass it a single multiline string containing all of your data values, and a single keyed data structure will be built for you.", "(Processing this kind of pipe-delimited tabular data was one of the earliest applications I had for pyparsing."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]