[[{"code": "<pre>\n<code>\n import itertools\n\ndef merge_it(lot):\n    merged = [ set(x) for x in lot ] # operate on sets only\n    finished = False\n    while not finished:\n        finished = True\n        for a, b in itertools.combinations(merged, 2):\n            if a &amp; b:\n                # we merged in this iteration, we may have to do one more\n                finished = False\n                if a in merged: merged.remove(a)\n                if b in merged: merged.remove(b)    \n                merged.append(a.union(b))\n                break # don't inflate 'merged' with intermediate results\n    return merged\n\nif __name__ == '__main__':\n    print merge_it( [(3,4), (18,27), (4,14)] )\n    # =&gt; [set([18, 27]), set([3, 4, 14])]\n\n    print merge_it( [(1,3), (15,21), (1,10), (57,66), (76,85), (66,76)] )\n    # =&gt; [set([21, 15]), set([1, 10, 3]), set([57, 66, 76, 85])]\n\n    print merge_it( [(1,2), (2,3), (3,4), (4,5), (5,9)] )\n    # =&gt; [set([1, 2, 3, 4, 5, 9])]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Here's a snippet (including doctests): http://gist.github.com/586252"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://gist.github.com/586252", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://gist.github.com/586252"}]}], [{"text": ["I tried hard to figure this out, but only after I tried the approach Ian's answer (thanks!", ") suggested I realized what the theoretical problem is: The input is a list of edges and defines a graph.", "We are looking for the strongly connected components of this graph.", "It's simple as that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["While you can do this efficiently, there is actually no reason to implement this yourself!", "Just import a good graph library:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "do this efficiently", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm"}, {"text": "good graph library", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://networkx.lanl.gov/"}]}, {"code": "<pre>\n<code>\n import networkx as nx\n\n# one of your examples\ng1 = nx.Graph([(1,3), (15,21), (1,10), (57,66), (76,85), (66,76)])\nprint nx.connected_components(g1) # [[57, 66, 76, 85], [1, 10, 3], [21, 15]]\n\n# my own test case\ng2 =  nx.Graph([(1,2),(2,10), (20,3), (3,4), (4,10)])\nprint nx.connected_components(g2) # [[1, 2, 3, 4, 10, 20]]\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n def collapse(L):\n    \"\"\" The input L is a list that contains tuples of various sizes.\n        If any tuples have shared elements, \n        exactly one instance of the shared and unshared elements are merged into the first tuple with a shared element.\n        This function returns a new list that contain merged tuples and an int that represents how many merges were performed.\"\"\"\n    answer = []\n    merges = 0\n    seen = []   # a list of all the numbers that we've seen so far\n    for t in L:\n        tAdded = False\n        for num in t:\n            pleaseMerge = True\n            if num in seen and pleaseMerge:\n                answer += merge(t, answer)\n                merges += 1\n                pleaseMerge = False\n                tAdded= True\n            else:\n                seen.append(num)\n        if not tAdded:\n            answer.append(t)\n\n    return (answer, merges)\n\ndef merge(t, L):\n    \"\"\" The input L is a list that contains tuples of various sizes.\n        The input t is a tuple that contains an element that is contained in another tuple in L.\n        Return a new list that is similar to L but contains the new elements in t added to the tuple with which t has a common element.\"\"\"\n    answer = []\n    while L:\n        tup = L[0]\n        tupAdded = False\n        for i in tup:\n            if i in t:\n                try:\n                    L.remove(tup)\n                    newTup = set(tup)\n                    for i in t:\n                        newTup.add(i)\n                    answer.append(tuple(newTup))\n                    tupAdded = True\n                except ValueError:\n                    pass\n        if not tupAdded:\n            L.remove(tup)\n            answer.append(tup)\n    return answer\n\ndef sortByLength(L):\n    \"\"\" L is a list of n-tuples, where n&gt;0.\n        This function will return a list with the same contents as L \n        except that the tuples are sorted in non-ascending order by length\"\"\"\n\n    lengths = {}\n    for t in L:\n        if len(t) in lengths.keys():\n            lengths[len(t)].append(t)\n        else:\n            lengths[len(t)] = [(t)]\n\n    l = lengths.keys()[:]\n    l.sort(reverse=True)\n\n    answer = []\n    for i in l:\n        answer += lengths[i]\n    return answer\n\ndef MergeThat(L):\n    answer, merges = collapse(L)\n    while merges:\n        answer, merges = collapse(answer)\n    return sortByLength(answer)\n\nif __name__ == \"__main__\":\n    print 'starting'\n    print MergeThat([(3,4), (18,27), (4,14)])\n    # [(3, 4, 14), (18, 27)]\n    print MergeThat([(1,3), (15,21), (1,10), (57,66), (76,85), (66,76)])\n    # [(57, 66, 76, 85), (1, 10, 3), (15, 21)]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Here's another solution that doesn't use itertools and takes a different, slightly more verbose, approach.", "The tricky bit of this solution is the merging of cluster sets when t0 in index and t1 in index."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "t0 in index and t1 in index", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import doctest\n\ndef MergeThat(a):\n    \"\"\" http://stackoverflow.com/questions/3744048/python-how-to-merge-a-list-into-clusters\n\n    &gt;&gt;&gt; MergeThat([(3,4), (18,27), (4,14)])\n    [(3, 4, 14), (18, 27)]\n    &gt;&gt;&gt; MergeThat([(1,3), (15,21), (1,10), (57,66), (76,85), (66,76)])\n    [(57, 66, 76, 85), (1, 3, 10), (15, 21)]\n    \"\"\"\n    index = {}\n    for t0, t1 in a:\n        if t0 not in index and t1 not in index:\n            index[t0] = set()\n            index[t1] = index[t0]\n        elif t0 in index and t1 in index:\n            index[t0] |= index[t1]\n            oldt1 = index[t1]\n            for x in index.keys():\n                if index[x] is oldt1:\n                    index[x] = index[t0]\n        elif t0 not in index:\n            index[t0] = index[t1]\n        else:\n            index[t1] = index[t0]\n        assert index[t0] is index[t1]\n        index[t0].add(t0)\n        index[t0].add(t1)\n    return sorted([tuple(sorted(x)) for x in set(map(frozenset, index.values()))], key=len, reverse=True)\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The code others have written will surely work, but here's another option, maybe simpler to understand and maybe less algorithmic complexity."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Keep a dictionary from numbers to the cluster (implemented as a python set) they're a member of.", "Also include that number in the corresponding set.", "Process an input pair either as:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Afterward, simply collect the unique values from the dictionary and sort in descending order of size.", "This portion of the job is O(m log n) and thus will not dominate runtime."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This should work in a single pass.", "Writing the actual code is left as an exercise for the reader."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["This is not efficient for huge lists."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def merge_that(lot):\n   final_list = []\n   while len(lot) &gt;0 :\n      temp_set = set(lot[0])\n      deletable = [0]      #list of all tuples consumed by temp_set\n      for i, tup2 in enumerate(lot[1:]):\n         if tup2[0] in temp_set or tup2[1] in temp_set:\n            deletable.append(i)\n            temp_set = temp_set.union(tup2)\n      for d in deletable:\n         del lot[d]\n      deletable = []\n      # Some of the tuples consumed later might have missed their brothers\n      # So, looping again after deleting the consumed tuples\n      for i, tup2 in enumerate(lot):\n         if tup2[0] in temp_set or tup2[1] in temp_set:\n            deletable.append(i)\n            temp_set = temp_set.union(tup2)\n      for d in deletable:\n         del lot[d]\n      final_list.append(tuple(temp_set))\n   return final_list\n</code>\n</pre>\n", "senID": 1}, {"text": ["It looks ugly but works."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]