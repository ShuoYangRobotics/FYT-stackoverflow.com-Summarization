[[{"text": ["Python does support \"method overloading\" as you present it.", "In fact, what you just describe is trivial to implement in Python, in so many different ways, but I would go with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Character(object):\n    # your character __init__ and other methods go here\n\n    def add_bullet(self, sprite=default, start=default, \n                 direction=default, speed=default, accel=default, \n                  curve=default):\n        # do stuff with your arguments\n</code>\n</pre>\n", "senID": 1}, {"text": ["In the above code, default is a plausible default value for those arguments, or None.", "You can then call the method with only the arguments you are interested in, and Python will use the default values. "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "default", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["You could also do something like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Character(object):\n    # your character __init__ and other methods go here\n\n    def add_bullet(self, **kwargs):\n        # here you can unpack kwargs as (key, values) and\n        # do stuff with them, and use some global dictionary\n        # to provide default values and ensure that ``key``\n        # is a valid argument...\n\n        # do stuff with your arguments\n</code>\n</pre>\n", "senID": 4}, {"text": ["Another alternative is to directly hook the desired function directly to the class or instance:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def some_implementation(self, arg1, arg2, arg3):\n  # implementation\nmy_class.add_bullet = some_implementation_of_add_bullet\n</code>\n</pre>\n", "senID": 6}, {"text": ["Yet another way is to use an abstract factory pattern:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n class Character(object):\n   def __init__(self, bfactory, *args, **kwargs):\n       self.bfactory = bfactory\n   def add_bullet(self):\n       sprite = self.bfactory.sprite()\n       speed = self.bfactory.speed()\n       # do stuff with your sprite and speed\n\nclass pretty_and_fast_factory(object):\n    def sprite(self):\n       return pretty_sprite\n    def speed(self):\n       return 10000000000.0\n\nmy_character = Character(pretty_and_fast_factory(), a1, a2, kw1=v1, kw2=v2)\nmy_character.add_bullet() # uses pretty_and_fast_factory\n\n# now, if you have another factory called \"ugly_and_slow_factory\" \n# you can change it at runtime in python by issuing\nmy_character.bfactory = ugly_and_slow_factory()\n\n# In the last example you can see abstract factory and \"method\n# overloading\" (as you call it) in action\n</code>\n</pre>\n", "senID": 8}], [{"text": ["This type of behaviour is typically solved (in OOP languages) using Polymorphism.", "Each type of bullet would be responsible for knowing how it travels.", "For instance:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Bullet(object):\n    def __init__(self):\n        self.curve = None\n        self.speed = None\n        self.acceleration = None\n        self.sprite_image = None\n\nclass RegularBullet(Bullet):\n    def __init__(self):\n        super(RegularBullet, self).__init__()\n        self.speed = 10\n\nclass Grenade(Bullet):\n    def __init__(self):\n        super(Grenade, self).__init__()\n        self.speed = 4\n        self.curve = 3.5\n\nadd_bullet(Grendade())\n\ndef add_bullet(bullet):\n    c_function(bullet.speed, bullet.curve, bullet.acceleration, bullet.sprite, bullet.x, bullet.y) \n\n\nvoid c_function(double speed, double curve, double accel, char[] sprite, ...) {\n    if (speed != null &amp;&amp; ...) regular_bullet(...)\n    else if (...) curved_bullet(...)\n    //..etc..\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Pass as many arguments to the c_function that exist, then do the job of determining which c function to call based on the values in the initial c function.", "So, python should only ever be calling the one c function.", "That one c function looks at the arguments, and then can delegate to other c functions appropriately."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You're essentially just using each subclass as a different data container, but by defining all the potential arguments on the base class, the subclasses are free to ignore the ones they do nothing with."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["When a new type of bullet comes along, you can simply define one more property on the base, change the one python function so that it passes the extra property, and the one c_function that examines the arguments and delegates appropriately.", "Doesn't sound too bad I guess."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Either use multiple keyword arguments in the definition, or create a Bullet hierarchy whose instances are passed to the function."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Bullet", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can use \"roll-your-own\" solution for function overloading.", "This one is copied from Guido van Rossum's article about multimethods (because there is little difference between mm and overloading in python):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Guido van Rossum's article", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.artima.com/weblogs/viewpost.jsp?thread=101605"}]}, {"code": "<pre>\n<code>\n registry = {}\n\nclass MultiMethod(object):\n    def __init__(self, name):\n        self.name = name\n        self.typemap = {}\n    def __call__(self, *args):\n        types = tuple(arg.__class__ for arg in args) # a generator expression!\n        function = self.typemap.get(types)\n        if function is None:\n            raise TypeError(\"no match\")\n        return function(*args)\n    def register(self, types, function):\n        if types in self.typemap:\n            raise TypeError(\"duplicate registration\")\n        self.typemap[types] = function\n\n\ndef multimethod(*types):\n    def register(function):\n        name = function.__name__\n        mm = registry.get(name)\n        if mm is None:\n            mm = registry[name] = MultiMethod(name)\n        mm.register(types, function)\n        return mm\n    return register\n</code>\n</pre>\n", "senID": 1}, {"text": ["The usage would be"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from multimethods import multimethod\nimport unittest\n\n# 'overload' makes more sense in this case\noverload = multimethod\n\nclass Sprite(object):\n    pass\n\nclass Point(object):\n    pass\n\nclass Curve(object):\n    pass\n\n@overload(Sprite, Point, Direction, int)\ndef add_bullet(sprite, start, direction, speed):\n    # ...\n\n@overload(Sprite, Point, Point, int, int)\ndef add_bullet(sprite, start, headto, speed, acceleration):\n    # ...\n\n@overload(Sprite, str)\ndef add_bullet(sprite, script):\n    # ...\n\n@overload(Sprite, Curve, speed)\ndef add_bullet(sprite, curve, speed):\n    # ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["Most restrictive limitations at the moment are:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "at the moment", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 4, "lis": [{"text": "methods are not supported, only functions that are not class members;", "tag": "none", "senID": 5}, {"text": "inheritance is not handled;", "tag": "none", "senID": 6}, {"text": "kwargs are not supported;", "tag": "none", "senID": 7}, {"text": "registering new functions should be done at import time thing is not thread-safe", "tag": "none", "senID": 8}]}], [{"text": ["Use keyword arguments with defaults.", "E.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def add_bullet(sprite, start=default, direction=default, script=default, speed=default):\n</code>\n</pre>\n", "senID": 1}, {"text": ["In the case of a straight bullet versus a curved bullet, I'd add two functions: add_bullet_straight and add_bullet_curved."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "add_bullet_straight", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "add_bullet_curved", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["By passing keyword args, http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/"}]}, {"code": "<pre>\n<code>\n def add_bullet(**kwargs):\n    #check for the arguments listed above and do the proper things\n</code>\n</pre>\n", "senID": 1}], [{"text": ["yes, as @Ignacio Vazquez-Abrams sayd, bullet hierarchy with type switching or something would be nice.."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I think A Bullet class hierarchy with the associated polymorphism is the way to go.", "You can effectively overload the base class constructor by using a metaclass so that calling the base class results in the creation of the appropriate subclass object.", "Below is some sample code to illustrate the essence of what I mean."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Bullet", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Bullet(object):\n\n    class __metaclass__(type):\n        # create the class or subclass\n        def __new__(mcl, classname, bases, classdict):\n            classobj = super(mcl, mcl).__new__(mcl, classname, \n                                               bases, classdict)\n            if classname == 'Bullet':  # base class definition?\n                classobj.registry = {}  # initialize class registry\n            else:\n                try:\n                    alias = classdict['alias']\n                except KeyError:\n                    raise TypeError(\"Bullet subclass %s has no 'alias'\"\n                                    % classname)\n\n                if alias in Bullet.registry: # unique?\n                    raise TypeError(\"Bullet subclass %s's alias attribute \"\n                                    \"%r already in use\" % (classname, alias))\n\n                # register subclass under the specified alias\n                classobj.registry[alias] = classobj\n\n            return classobj\n\n        # instance factory for subclasses\n        # subclasses should only be instantiated by calls to the base class\n        # with their subclass's alias as the first arg\n        def __call__(cls, alias, *args, **kwargs):\n            if cls != Bullet:\n                raise TypeError, (\"Bullet subclass %r objects should not to \"\n                                  \"be explicitly constructed.\" % cls.__name__)\n            elif alias not in cls.registry: # Bullet subclass?\n                raise NotImplementedError, (\"Unknown Bullet subclass %r\" %\n                                            str(alias))\n\n            # create designated subclass object (call its __init__ method)\n            subclass = cls.registry[alias]\n            return type.__call__(subclass, *args, **kwargs)\n\n    # abstract base class's __init__ should never be called\n    # (if subclasses need to call super class's __init__(),\n    # then this could be implemented)\n    def __init__(self, *args, **kwargs):\n        raise NotImplementedError, \"Bullet is an abstract base class\"\n\nclass Bullet1(Bullet):\n    alias = 'B1'\n\n    def __init__(self, sprite, start, direction, speed):\n        print 'creating %s object' % self.__class__.__name__\n        pass\n\nclass Bullet2(Bullet):\n    alias = 'B2'\n\n    def __init__(self, sprite, start, headto, spead, acceleration):\n        print 'creating %s object' % self.__class__.__name__\n        pass\n\nclass Bullet3(Bullet):\n    alias = 'B3'\n\n    def __init__(self, sprite, script): # script controlled bullets\n        print 'creating %s object' % self.__class__.__name__\n        pass\n\nclass Bullet4(Bullet):\n    alias = 'B4'\n\n    def __init__(self, sprite, curve, speed): # for bullets with curved paths\n        print 'creating %s object' % self.__class__.__name__\n        pass\n\nclass Sprite:\n    pass\n\nclass Curve:\n    pass\n\nb1 = Bullet('B1', Sprite(), (10,20,30), 90, 600)\nb2 = Bullet('B2', Sprite(), (-30,17,94), (1,-1,-1), 600, 10)\nb3 = Bullet('B3', Sprite(), 'bullet42.script')\nb4 = Bullet('B4', Sprite(), Curve(), 720)\n</code>\n</pre>\n", "senID": 1}]]