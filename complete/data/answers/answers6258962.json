[[{"text": ["There is really nothing wrong with a list comprehension.", "This is exactly the sort of thing list comprehensions were designed for."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you're using NumPy (or SciPy), the syntax you're looking for actually does work:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from numpy import array\n\n...\n\nx = array([1,2,3,4,5,6,7,8,9])\nxlist = 4&lt;=x\n</code>\n</pre>\n", "senID": 2}, {"text": ["But if you don't already have a good reason to use NumPy, it's not worth bringing it in just for that syntax.", "In any case, come to think of it I'm not sure if NumPy works in Python 3 yet."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["One thing to consider would be whether you need the intermediate list or not.", "If not use a generator expression instead.", "For instance all(i &lt;= 4 for i in x) would be substantially faster and would use less memory than all([i &lt;= 4 for i in x])."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "generator expression", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/howto/functional.html#generator-expressions-and-list-comprehensions"}, {"text": "all(i &lt;= 4 for i in x)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "all([i &lt;= 4 for i in x])", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["For large lists, this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "large", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; (4&lt;=i for i in range(1,10))\n&lt;generator object &lt;genexpr&gt; at 0xb75beedc&gt;\n&gt;&gt;&gt; list(_)\n[False, False, False, True, True, True, True, True, True]\n# The list(_) is just to show what is inside the generator...\n</code>\n</pre>\n", "senID": 1}, {"text": ["is better than:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [4&lt;=i for i in range(1,10)]\n[False, False, False, True, True, True, True, True, True]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I think you are already doing it the right way."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You also can use the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n print map(lambda i: 4&lt;=i, xrange(1,10))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["the map approach is likely to be the faster but, please, profile them if you really want to  know.", "Also consider the array module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "please", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n In [2]: %timeit map(lambda i: 4&lt;=i, xrange(1,100))\n100000 loops, best of 3: 15.9 us per loop\n\nIn [7]: %timeit list(4&lt;=i for i in range(1,100))\n100000 loops, best of 3: 10.3 us per loop\n\nIn [8]: %timeit list(4&lt;=i for i in range(1,1000))\n10000 loops, best of 3: 80.6 us per loop\n\nIn [10]: %timeit map(lambda i: 4&lt;=i, xrange(1,1000))\n10000 loops, best of 3: 155 us per loop\n</code>\n</pre>\n", "senID": 1}]]