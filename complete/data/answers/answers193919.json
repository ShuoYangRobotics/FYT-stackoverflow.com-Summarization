[[{"text": ["In production code in our company, we try to follow the following rules."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["We place imports at the beginning of the file, right after the main file's docstring, e.g."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n \"\"\"\nRegistry related functionality.\n\"\"\"\nimport wx\n# ...\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now, if we import a class that is one of few in the imported module, we import the name directly, so that in the code we only have to use the last part, e.g."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from RegistryController import RegistryController\nfrom ui.windows.lists import ListCtrl, DynamicListCtrl\n</code>\n</pre>\n", "senID": 4}, {"text": ["There are modules, however, that contain dozens of classes, e.g.", "list of all possible exceptions.", "Then we import the module itself and reference to it in the code:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from main.core import Exceptions\n# ...\nraise Exceptions.FileNotFound()\n</code>\n</pre>\n", "senID": 6}, {"text": ["We use the import X as Y as rarely as possible, because it makes searching for usage of a particular module or class difficult.", "Sometimes, however, you have to use it if you wish to import two classes that have the same name, but exist in different modules, e.g."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "import X as Y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from Queue import Queue\nfrom main.core.MessageQueue import Queue as MessageQueue\n</code>\n</pre>\n", "senID": 8}, {"text": ["As a general rule, we don't do imports inside methods -- they simply make code slower and less readable.", "Some may find this a good way to easily resolve cyclic imports problem, but a better solution is code reorganization."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["I would normally use import X on module level.", "If you only need a single object from a module, use from X import Y. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "import X", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "from X import Y", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Only use import X as Y in case you're otherwise confronted with a name clash."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "import X as Y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I only use imports on function level to import stuff I need when the module is used as the main module, like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def main():\n  import sys\n  if len(sys.argv) &gt; 1:\n     pass\n</code>\n</pre>\n", "senID": 3}, {"text": ["HTH"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Let me just paste a part of conversation on django-dev mailing list started by Guido van Rossum:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\"\"\"\n[...]\nFor example, it's part of the Google Python style guides[1] that all\nimports must import a module, not a class or function from that\nmodule.", "There are way more classes and functions than there are\nmodules, so recalling where a particular thing comes from is much\neasier if it is prefixed with a module name.", "Often multiple modules\nhappen to define things with the same name -- so a reader of the code\ndoesn't have to go back to the top of the file to see from which\nmodule a given name is imported. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["\"\"\""], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["source: http://groups.google.com/group/django-developers/browse_thread/thread/78975372cdfb7d1a"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://groups.google.com/group/django-developers/browse_thread/thread/78975372cdfb7d1a", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://groups.google.com/group/django-developers/browse_thread/thread/78975372cdfb7d1a"}]}, {"text": ["1: http://code.google.com/p/soc/wiki/PythonStyleGuide#Module_and_package_imports"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://code.google.com/p/soc/wiki/PythonStyleGuide#Module_and_package_imports", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/soc/wiki/PythonStyleGuide#Module_and_package_imports"}]}], [{"text": ["I generally try to use the regular import modulename, unless the module name is long, or used often.."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "import modulename", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For example, I would do.."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from BeautifulSoup import BeautifulStoneSoup as BSS\n</code>\n</pre>\n", "senID": 2}, {"text": ["..so I can do soup = BSS(html) instead of BeautifulSoup.BeautifulStoneSoup(html)"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "soup = BSS(html)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "BeautifulSoup.BeautifulStoneSoup(html)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Or.."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from xmpp import XmppClientBase\n</code>\n</pre>\n", "senID": 5}, {"text": ["..instead of importing the entire of xmpp when I only use the XmppClientBase"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Using import x as y is handy if you want to import either very long method names , or to prevent clobbering an existing import/variable/class/method (something you should try to avoid completely, but it's not always possible)"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "import x as y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Say I want to run a main() function from another script, but I already have a main() function.."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n from my_other_module import main as other_module_main\n</code>\n</pre>\n", "senID": 9}, {"text": ["..wouldn't replace my main function with my_other_module's main"], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "main", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "main", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Oh, one thing - don't do from x import * - it makes your code very hard to understand, as you cannot easily see where a method came from (from x import *; from y import *; my_func() - where is my_func defined?"], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "from x import *", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "from x import *; from y import *; my_func()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In all cases, you could just do import modulename and then do modulename.subthing1.subthing2.method(\"test\")..."], "childNum": 3, "tag": "p", "senID": 12, "childList": [{"text": "could", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "import modulename", "childNum": 0, "tag": "code", "childList": []}, {"text": "modulename.subthing1.subthing2.method(\"test\")", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The from x import y as z stuff is purely for convenience - use it whenever it'll make  your code easier to read or write!"], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "from x import y as z", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Others have covered most of the ground here but I just wanted to add one case where I will use import X as Y (temporarily), when I'm trying out a new version of a class or module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "import X as Y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So if we were migrating to a new implementation of a module, but didn't want to cut the code base over all at one time, we might write a xyz_new module and do this in the source files that we had migrated:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "xyz_new", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import xyz_new as xyz\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then, once we cut over the entire code base, we'd just replace the xyz module with xyz_new and change all of the imports back to"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "xyz", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "xyz_new", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import xyz\n</code>\n</pre>\n", "senID": 4}], [{"text": ["DON'T do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from X import *\n</code>\n</pre>\n", "senID": 1}, {"text": ["unless you are absolutely sure that you will use each and every thing in that module.", "And even then, you should probably reconsider using a different approach."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Other than that, it's just a matter of style."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from X import Y\n</code>\n</pre>\n", "senID": 4}, {"text": ["is good and saves you lots of typing.", "I tend to use that when I'm using something in it fairly frequently  But if you're importing a lot from that module, you could end up with an import statement that looks like this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from X import A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P\n</code>\n</pre>\n", "senID": 6}, {"text": ["You get the idea.", "That's when imports like"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import X\n</code>\n</pre>\n", "senID": 8}, {"text": ["become useful.", "Either that or if I'm not really using anything in X very frequently."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["Maybe the (old) article Importing Python Modules by The Effbot will be of some help."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Importing Python Modules", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/import-confusion.htm"}, {"href": "http://effbot.org/", "text": "The Effbot", "childNum": 1, "tag": "a", "childList": [{"text": "The Effbot", "tag": "em"}]}, {"text": "The Effbot", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Nowadays a little more confusion is added by even more import options.", "See especially Absolute and Relative Imports in 2.5."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Absolute and Relative Imports", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/whatsnew/2.5.html#pep-328"}]}], [{"text": ["The import X as Y is useful if you have different implementations of the same module/class."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "import X as Y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["With some nested try..import..except ImportError..imports you can hide the implementation from your code.", "See lxml etree import example:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "try..import..except ImportError..import", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "lxml etree import example", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://codespeak.net/lxml/tutorial.html"}]}, {"code": "<pre>\n<code>\n try:\n  from lxml import etree\n  print(\"running with lxml.etree\")\nexcept ImportError:\n  try:\n    # Python 2.5\n    import xml.etree.cElementTree as etree\n    print(\"running with cElementTree on Python 2.5+\")\n  except ImportError:\n    try:\n      # Python 2.5\n      import xml.etree.ElementTree as etree\n      print(\"running with ElementTree on Python 2.5+\")\n    except ImportError:\n      try:\n        # normal cElementTree install\n        import cElementTree as etree\n        print(\"running with cElementTree\")\n      except ImportError:\n        try:\n          # normal ElementTree install\n          import elementtree.ElementTree as etree\n          print(\"running with ElementTree\")\n        except ImportError:\n          print(\"Failed to import ElementTree from any known place\")\n</code>\n</pre>\n", "senID": 2}], [{"text": ["When you have a well-written library, which is sometimes case in python, you ought just import it and use it as it.", "Well-written library tends to take life and language of its own, resulting in pleasant-to-read -code, where you rarely reference the library.", "When a library is well-written, you ought not need renaming or anything else too often."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import gat\n\nnode = gat.Node()\nchild = node.children()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Sometimes it's not possible to write it this way, or then you want to lift down things from library you imported."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from gat import Node, SubNode\n\nnode = Node()\nchild = SubNode(node)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Sometimes you do this for lot of things, if your import string overflows 80 columns, It's good idea to do this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from gat import (\n    Node, SubNode, TopNode, SuperNode, CoolNode,\n    PowerNode, UpNode\n)\n</code>\n</pre>\n", "senID": 5}, {"text": ["The best strategy is to keep all of these imports on the top of the file.", "Preferrably ordered alphabetically, import -statements first, then from import -statements."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Now I tell you why this is the best convention."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Python could perfectly have had an automatic import, which'd look from the main imports for the value when it can't be found from global namespace.", "But this is not a good idea.", "I explain shortly why.", "Aside it being more complicated to implement than simple import, programmers wouldn't be so much thinking about the depedencies and finding out from where you imported things ought be done some other way than just looking into imports."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Need to find out depedencies is one reason why people hate \"from ... import *\".", "Some bad examples where you need to do this exist though, for example opengl -wrappings."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["So the import definitions are actually valuable as defining the depedencies of the program.", "It is the way how you should exploit them.", "From them you can quickly just check where some weird function is imported from."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["I'm with Jason in the fact of not using"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from X import *\n</code>\n</pre>\n", "senID": 1}, {"text": ["But in my case (i'm not an expert programmer, so my code does not meet the coding style too well) I usually do in my programs a file with all the constants like program version, authors, error messages and all that stuff, so the file are just definitions, then I make the import"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from const import *\n</code>\n</pre>\n", "senID": 3}, {"text": ["That saves me a lot of time.", "But it's the only file that has that import, and it's because all inside that file are just variable declarations."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Doing that kind of import in a file with classes and definitions might be useful, but when you have to read that code you spend lots of time locating functions and classes."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]