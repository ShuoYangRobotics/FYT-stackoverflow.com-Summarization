[[{"text": ["Use a list comprehension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n data = ((1,), (3,))\nprint [x[0] for x in data]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n mySet = set(x[0] for x in TUPLES)\n</code>\n</pre>\n", "senID": 0}, {"text": ["or in python3:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n mySet = {x[0] for x in TUPLES}\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n from operator import itemgetter\nmap(itemgetter(0), ((1,), (3,)))\n</code>\n</pre>\n", "senID": 0}, {"text": ["While the list comprehensions are generally more readable, itemgetter is closest to what he asked for."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Timing information:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from timeit import Timer\n&gt;&gt;&gt; mapped = Timer(setup='from operator import itemgetter\\nlst=( (\"a\",), (\"b\",), (1,), (2,))', stmt='map(itemgetter(0), lst)')\n&gt;&gt;&gt; comprehended = Timer(setup='lst=( (\"a\",), (\"b\",), (1,), (2,))', stmt='[i[0] for i in lst]')\n&gt;&gt;&gt; comprehended.repeat()\n[0.5402599483924249, 0.47599876684973275, 0.48340872102501464]\n&gt;&gt;&gt; mapped.repeat()\n[0.4333492937609478, 0.31100689245737456, 0.3106918944053909]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Just another way to get it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n set(x for x, in data)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n data = ((1,), (3,))\ns = set(zip(*data)[0])\n</code>\n</pre>\n", "senID": 0}, {"text": ["If there are more items in your tuples you might save some memory and time using izip and islice."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Python supports the creation of anonymous function using the lambda keyword.", "This allows you to use a function without formally defining it.", "Given your example, you'd use the lambda like this:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "lambda", "tag": "a", "pos": 0, "childList": [{"text": "lambda", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/tutorial/controlflow.html#lambda-forms"}, {"text": "lambda", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n data = ((1,), (3,))\nset(map(lambda x: x[0], data))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is equivalent to:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def f(x):\n    return x[0]\n\nset(map(f, data))\n</code>\n</pre>\n", "senID": 3}, {"text": ["But as other people have said, list comprehensions are preferred over the use of map."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You can use a set comprehension in Python 2.7 and 3.x:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; t = ((1,), (3,))\n&gt;&gt;&gt; s = {x[0] for x in t}\n&gt;&gt;&gt; s\nset([1, 3])\n</code>\n</pre>\n", "senID": 1}, {"text": ["or in Python &lt; 2.7:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = set([x[0] for x in t])\n&gt;&gt;&gt; s\nset([1, 3])\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Go with @Winston.", "List comprehensions are great.", "If you really want to use map, use a lambda as previously suggested, or the logically equivalent..."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "really", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n from operator import itemgetter\ndata = ((1,), (3,))\nmap(itemgetter(0), data)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is just for info; You should use the list comp"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]