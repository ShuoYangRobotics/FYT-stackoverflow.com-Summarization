[[{"text": ["You're talking about testing too much at once.", "If you start trying to attack a testing problem by saying \"Let's verify that it modifies its environment correctly\", you're doomed to failure.", "Environments have dozens, maybe even millions of potential variations."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Instead, look at the pieces (\"units\") of your program.", "For example, are you going to have a function that determines where the files are that have to be written?", "What are the inputs to that function?", "Perhaps an environment variable, perhaps some values read from a config file?", "Test that function, and don't actually do anything that modifies the filesystem.", "Don't pass it \"realistic\" values, pass it values that are easy to verify against.", "Make a temporary directory, populate it with files in your test's setUp method."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "setUp", "childNum": 0, "tag": "code", "pos": 6, "childList": []}]}, {"text": ["Then test the code that writes the files.", "Just make sure it's writing the right contents file contents.", "Don't even write to a real filesystem!", "You don't need to make \"fake\" file objects for this, just use Python's handy StringIO modules; they're \"real\" implementations of the \"file\" interface, they're just not the ones that your program is actually going to be writing to."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "StringIO", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Ultimately you will have to test the final, everything-is-actually-hooked-up-for-real top-level function that passes the real environment variable and the real config file and puts everything together.", "But don't worry about that to get started.", "For one thing, you will start picking up tricks as you write individual tests for smaller functions and creating test mocks, fakes, and stubs will become second nature to you.", "For another: even if you can't quite figure out how to test that one function call, you will have a very high level of confidence that everything which it is calling works perfectly.", "Also, you'll notice that test-driven development forces you to make your APIs clearer and more flexible.", "For example: it's much easier to test something that calls an open() method on an object that came from somewhere abstract, than to test something that calls os.open on a string that you pass it.", "The open method is flexible; it can be faked, it can be implemented differently, but a string is a string and os.open doesn't give you any leeway to catch what methods are called on it."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "open()", "childNum": 0, "tag": "code", "pos": 5, "childList": []}, {"text": "os.open", "childNum": 0, "tag": "code", "pos": 6, "childList": []}, {"text": "open", "childNum": 0, "tag": "code", "childList": []}, {"text": "os.open", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You can also build testing tools to make repetitive tasks easy.", "For example, twisted provides facilities for creating temporary files for testing built right into its testing tool.", "It's not uncommon for testing tools or larger projects with their own test libraries to have functionality like this."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "built right into its testing tool", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://twistedmatrix.com/documents/8.1.0/api/twisted.trial.unittest.TestCase.html#mktemp"}]}], [{"text": ["You have two levels of testing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For this kind of testing, we often use a \"Mock\" object.", "You can design a \"FileSystemOperations\" class that embodies the various file system operations.", "You test this to be sure it does basic read, write, copy, rename, etc.", "There's no real logic in this.", "Just methods that invoke file system operations."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can then create a MockFileSystem which dummies out the various operations.", "You can use this Mock object to test your other classes."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In some cases, all of your file system operations are in the os module.", "If that's the case, you can create a MockOS module with mock version of the operations you actually use."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Put your MockOS module on the PYTHONPATH and you can conceal the real OS module."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "PYTHONPATH", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["For production operations you use your well-tested \"Logic\" classes plus your FileSystemOperations class (or the real OS module."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["When I touch files in my code, I tend to prefer to mock the actual reading and writing of the file... so then I can give my classes exact contents I want in the test, and then assert that the test is writing back the contents I expect."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I've done this in Java, and I imagine it is quite simple in Python... but it may require designing your classes/functions in such a way that it is EASY to mock the use of an actual file."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For this, you can try passing in streams and then just pass in a simple string input/output stream which won't write to a file, or have a function that does the actual \"write this string to a file\" or \"read this string from a file\", and then replace that function in your tests."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You might want to setup the test so that it runs inside a chroot jail, so you have all the environment the test needs, even if paths and file locations are hardcoded in the code [not really a good practice, but sometimes one gets the file locations from other places...] and then check the results via the exit code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I think you are on the right track.", "Depending on what you need to do chroot may help you set up an environment for your scrpits that 'looks' real, but isn't."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "chroot", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Chroot"}]}, {"text": ["If that doesn't work then you could write your scripts to take a 'root' path as an argument."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In a production run the root path is just /.", "For testing you create a shadow environment under /tmp/test and then run your scripts with a root path of /tmp/test. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["For later readers who just want a way to test that code writing to files is working correctly, here is a \"fake_open\" that patches the  open builtin of a module to use StringIO.", "fake_open returns a dict of opened files which can be examined in a unit test or doctest, all without needing a real file-system."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fake_open(module):\n    \"\"\"Patch module's `open` builtin so that it returns StringIOs instead of\n    creating real files, which is useful for testing. Returns a dict that maps\n    opened file names to StringIO objects.\"\"\"\n    from contextlib import closing\n    from StringIO import StringIO\n    streams = {}\n    def fakeopen(filename,mode):\n        stream = StringIO()\n        stream.close = lambda: None\n        streams[filename] = stream\n        return closing(stream)\n    module.open = fakeopen\n    return streams\n</code>\n</pre>\n", "senID": 1}]]