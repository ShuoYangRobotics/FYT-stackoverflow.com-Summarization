[[{"text": ["linecache"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "linecache", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/linecache.html"}]}], [{"text": ["You don't really have that many options if the lines are of different length... you sadly need to process the line ending characters to know when you've progressed to the next line."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can, however, dramatically speed this up AND reduce memory usage by changing the last parameter to \"open\" to something not 0."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["0 means the file reading operation is unbuffered, which is very slow and disk intensive.", "1 means the file is line buffered, which would be an improvement.", "Anything above 1 (say 8k.. ie: 8096, or higher) reads chunks of the file into memory.", "You still access it through for line in open(etc):, but python only goes a bit at a time, discarding each buffered chunk after its processed."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "for line in open(etc):", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["You can't jump ahead without reading in the file at least once, since you don't know where the line breaks are.", "You could do something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # Read in the file once and build a list of line offsets\nline_offset = []\noffset = 0\nfor line in file:\n    line_offset.append(offset)\n    offset += len(line)\nfile.seek(0)\n\n# Now, to skip to line n (with the first line being line 0), just do\nfile.seek(line_offset[n])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["i'm probably spoiled by abundant ram, but 15 Mb is not huge.", "reading into memory with readlines()  is what I usually do with files of this size.", "accessing a line after that is trivial."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "readlines()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["If you know in advance the position in the file (rather the line number), you can use file.seek() to go to that position."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "file.seek()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#file.seek"}]}, {"text": ["Edit: you can use the linecache.getline(filename, lineno) function, which will return the contents of the line lineno, but only after reading the entire file into memory.", "Good if you're randomly accessing lines from within the file (as python itself might want to do to print a traceback) but not good for a 15MB file."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "linecache.getline(filename, lineno)", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/linecache.html#linecache.getline"}]}], [{"text": ["Since there is no way to determine the lenght of all lines without reading them, you have no choice but to iterate over all lines before your starting line.", "All you can do is to make it look nice.", "If the file is really huge then you might want to use a generator based approach:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import dropwhile\n\ndef iterate_from_line(f, start_from_line):\n    return (l for i, l in dropwhile(lambda x: x[0] &lt; start_from_line, enumerate(f)))\n\nfor line in iterate_from_line(open(filename, \"r\", 0), 141978):\n    DoSomethingWithThisLine(line)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note: the index is zero based in this approach."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Do the lines themselves contain any index information?", "If the content of each line was something like \"&lt;line index&gt;:Data\", then the seek() approach could be used to do a binary search through the file, even if the amount of Data is variable.", "You'd seek to the midpoint of the file, read a line, check whether its index is higher or lower than the one you want, etc."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "&lt;line index&gt;:Data", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "seek()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Data", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Otherwise, the best you can do is just readlines().", "If you don't want to read all 15MB, you can use the sizehint argument to at least replace a lot of readline()s with a smaller number of calls to readlines()."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "readlines()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sizehint", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "readline()", "childNum": 0, "tag": "code", "childList": []}, {"text": "readlines()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["What generates the file you want to process?", "If it is something under your control, you could generate an index (which line is at which position.", ") at the time the file is appended to.", "The index file can be of fixed line size (space padded or 0 padded numbers) and will definitely be smaller.", "And thus can be read and processed qucikly. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Which line do you want?.  ", "tag": "none", "senID": 1}, {"text": "Calculate byte offset of corresponding line number in index file(possible because line size of index file is constant).", "tag": "none", "senID": 2}, {"text": "Use seek or whatever to directly jump to get the line from index file.", "tag": "none", "senID": 3}, {"text": "Parse to get byte offset for corresponding line of actual file.", "tag": "none", "senID": 4}]}], [{"text": ["If you don't want to read the entire file in memory .. you may need to come up with some format other than plain text."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["of course it all depends on what you're trying to do, and how often you will jump across the file."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For instance, if you're gonna be jumping to lines many times in the same file, and you know that the file does not change while working with it, you can do this:\nFirst, pass through the whole file, and record the \"seek-location\" of some key-line-numbers (such as, ever 1000 lines),\nThen if you want line 12005, jump to the position of 12000 (which you've recorded) then read 5 lines and you'll know you're in line 12005\nand so on"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "many times", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}], [{"text": ["Here's an example using 'readlines(sizehint)' to read a chunk of lines at a time.", "DNS pointed out that solution.", "I wrote this example because the other examples here are single-line oriented."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def getlineno(filename, lineno):\n    if lineno &lt; 1:\n        raise TypeError(\"First line is line 1\")\n    f = open(filename)\n    lines_read = 0\n    while 1:\n        lines = f.readlines(100000)\n        if not lines:\n            return None\n        if lines_read + len(lines) &gt;= lineno:\n            return lines[lineno-lines_read-1]\n        lines_read += len(lines)\n\nprint getlineno(\"nci_09425001_09450000.smi\", 12000)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["awk 'NR==141978'"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]