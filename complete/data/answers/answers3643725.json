[[{"text": ["Instead of a list of exponents, consider simply repeating each prime factor by the number of times it is a factor.", "After that, working on the resulting primefactors list-with-repetitions, itertools.combinations does just what you need -- you'll just require the combinations of length 2 to len(primefactors) - 1 items included (the combinations of just one are the prime factors, that of all of them will be the original number -- if you want those too, just use range(1, len(primefactors) + 1) instead of the range(2, len(primefactors)) which my main suggestion would use)."], "childNum": 7, "tag": "p", "senID": 0, "childList": [{"text": "repeating", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "is", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "primefactors", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/itertools.html#itertools.combinations", "text": "itertools.combinations", "childNum": 0, "tag": "a", "childList": []}, {"text": "len(primefactors) - 1", "childNum": 0, "tag": "code", "childList": []}, {"text": "range(1, len(primefactors) + 1)", "childNum": 0, "tag": "code", "childList": []}, {"text": "range(2, len(primefactors))", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["There will be repetitions in the results (e.g., 6 will appear twice as a factor of 12, since the latter's primefactors will be [2, 2, 3]) and they can of course be weeded out in the usual ways (i.e.", "sorted(set(results)) for example)."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "6", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "12", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "primefactors", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "[2, 2, 3]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sorted(set(results))", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["To compute primefactors given listOfAllPrimes, consider for example:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "primefactors", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "listOfAllPrimes", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def getprimefactors(n):\n    primefactors = []\n    primeind = 0\n    p = listOfAllPrimes[primeind]\n    while p &lt;= n:\n        if n % p == 0:\n            primefactors.append(p)\n            n //= p\n        else:\n            primeind += 1\n            p = listOfAllPrimes[primeind]\n    return primefactors\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Why do you begin your solution from the set of prime factors?", "when you factorize a number you can as easily get all its prime factors (repeated) and from them the exponents for each factor.", "With this in mind, you can write this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\nprime_factors = get_prime_factors(180) \n# 2, 2, 3, 3, 5 \nfactorization = [(f, len(list(fs))) for (f, fs) in itertools.groupby(prime_factors)]\n# [(2, 2), (3, 2), (5, 1)]\nvalues = [[(factor**e) for e in range(exp+1)] for (factor, exp) in factorization]\n# [[1, 2, 4], [1, 3, 9], [1, 5]]\nprint sorted(product(xs) for xs in itertools.product(*values))\n# [1, 2, 3, 4, 5, 6, 9, 10, 12, 15, 18, 20, 30, 36, 45, 60, 90, 180]\n</code>\n</pre>\n", "senID": 1}, {"text": ["get_prime_factors and product are not implemented here, but you get the idea (both are pretty simple to write)"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "get_prime_factors", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "product", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["IMHO, being mathematic problems, the Euler problems can be nicely solved using functional instead of imperative style (though I acknowledge that some solutions may not come out as pythonic as desired)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You could use itertools.combinations() to get all possible combinations of factors once you've gotten your list of repeated-primes, such as [2, 2, 3, 3, 5] for 180.", "Then, simply multiplying the components from each combination will get you a factor."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "itertools.combinations()", "tag": "a", "pos": 0, "childList": [{"text": "itertools.combinations()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.combinations"}, {"text": "itertools.combinations()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "[2, 2, 3, 3, 5]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "180", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["With a few cooler Python features:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def factors( num ):\n    for p in primes:\n        if num==1: break # stop when num is 1\n        while True: # these factors may be repeated \n            new, rest = divmod(num, p) # does div and mod at once\n            if rest==0: # its divisible\n                yield p # current prime is factor\n                num = new # continue with the div'd number\n            else:\n                break # no factor so break from the while\n\n\nprint list(factors(2*2*3*3*5*7*11*11*13)) # [2, 2, 3, 3, 5, 7, 11, 11, 13] ofc\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's a simple and efficient solution to the original problem:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def getDivisors(n):\n    divisors = []\n    d = 1\n    while d*d &lt; n:\n        if n % d == 0:\n            divisors.append(d)\n            divisors.append(n / d);\n        d += 1\n    if d*d == n:\n        divisors.append(d)\n    return divisors\n</code>\n</pre>\n", "senID": 1}, {"text": ["The output list is unsorted.", "You can make it more \"pythonic\" if you want, whatever that means."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["An all in one solution; i.e.", "no need for an existing list of the prime factors."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python3 -O\n\nfrom primegen import erat3 as generate_primes # see Note[1]\nimport operator as op, functools as ft, itertools as it\n\ndef all_factors(number):\n    prime_powers= []\n\n    for prime in generate_primes(): # for prime in listOfAllPrimes\n        if prime &gt; number: break\n\n        this_prime_powers= [1]\n        new_number, modulo= divmod(number, prime)\n\n        while not modulo:\n            number= new_number\n            this_prime_powers.append(this_prime_powers[-1] * prime)\n            new_number, modulo= divmod(number, prime)\n\n        if len(this_prime_powers) &gt; 1:\n            prime_powers.append(this_prime_powers)\n\n    # at this point:\n    # if number was 360, prime_powers is [[1, 2, 4, 8], [1, 3, 9], [1, 5]]\n    # if number was 210, prime_powers is [[1, 2], [1, 3], [1, 5], [1, 7]]\n\n    return sorted(\n        ft.reduce(op.mul, combination, 1)\n        for combination in it.product(*prime_powers))\n\nif __name__ == \"__main__\":\n    def num_result(number):\n        return number, all_factors(number)\n    print(num_result(360))\n    print(num_result(210))\n    print(num_result(7))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note[1]: As a prime number generator, you can choose one from How to implement an efficient infinite generator of prime numbers in Python?", "or use your own (e.g.", "your listOfAllPrimes)."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "Note[1]", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "How to implement an efficient infinite generator of prime numbers in Python?", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2211990/"}, {"text": "listOfAllPrimes", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["This produces a full factor list, i.e.", "including 1 and the number argument itself.", "If you want to omit these, you can use all_factors(number)[1:-1]."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "number", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "all_factors(number)[1:-1]", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n $ allfactors.py \n(360, [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 18, 20, 24, 30, 36, 40, 45, 60, 72, 90, 120, 180, 360])\n(210, [1, 2, 3, 5, 6, 7, 10, 14, 15, 21, 30, 35, 42, 70, 105, 210])\n(7, [1, 7])\n</code>\n</pre>\n", "senID": 4}]]