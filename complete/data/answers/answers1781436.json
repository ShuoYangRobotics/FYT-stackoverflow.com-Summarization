[[{"text": ["For Perl, just close and re-open STDERR to point to a file of your choice."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "STDERR", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n close STDERR;\nopen STDERR, '&gt;&gt;', '/path/to/your/log.txt' \n  or die \"Couldn't redirect STDERR: $!\";\n\nwarn \"this will go to log.txt\";\n</code>\n</pre>\n", "senID": 1}, {"text": ["Alternatively, you could look into a filehandle multiplexer like File::Tee."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "File::Tee", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/~salva/File-Tee/lib/File/Tee.pm"}]}], [{"text": ["Python: cgitb.", "At the top of your script, before other imports:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "cgitb", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/cgitb.html"}]}, {"code": "<pre>\n<code>\n import cgitb\ncgitb.enable(False, '/home/me/www/myapp/logs/errors')\n</code>\n</pre>\n", "senID": 1}, {"text": ["(\u2018errors\u2019 being a directory the web server user has write-access to."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["In Perl try CGI::Carp"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "CGI::Carp", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://perldoc.perl.org/CGI/Carp.html"}]}, {"code": "<pre>\n<code>\n BEGIN { \nuse CGI::Carp qw(carpout); \nuse diagnostics;\nopen(LOG, \"&gt;errors.txt\"); \ncarpout(LOG);\nclose(LOG);\n}\n\nuse CGI::Carp qw(fatalsToBrowser);\n</code>\n</pre>\n", "senID": 1}], [{"text": ["python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["import sys"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["sys.stderr = open('file_path_with_write_permission/filename', 'w')"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The solution I finally went with was similar to the following, near the top of all my scripts:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Perl:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n open(STDERR,\"&gt;&gt;\",\"/path/to/my/cgi-error.log\")\n    or die \"Could not redirect STDERR: $OS_ERROR\";\n</code>\n</pre>\n", "senID": 2}, {"text": ["Python:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n sys.stderr = open(\"/path/to/my/cgi-error.log\", \"a\")\n</code>\n</pre>\n", "senID": 4}, {"text": ["Apparently in Perl you don't need to close the STDERR handle before reopening it."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Normally I would close it anyway as a best practice, but as I said in the question, I have 269 scripts and I'm trying to minimize the changes.", "(Plus it seems more Perlish to just re-open the open filehandle, as awful as that sounds."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["In case anyone else has something similar in the future, here's what I'm going to do for updating all my scripts at once:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Perl:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n find . -type f -name \"*.pl\" -exec perl -pi.bak -e 's%/usr/bin/perl%/usr/bin/perl\\nopen(STDERR,\"&gt;&gt;\",\"/path/to/my/cgi-error.log\")\\n    or die \"Could not redirect STDERR: \\$OS_ERROR\";%' {} \\;\n</code>\n</pre>\n", "senID": 9}, {"text": ["Python:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n find . -type f -name \"*.py\" -exec perl -pi.bak -e 's%^(import os, sys.*)%$1\\nsys.stderr = open(\"/path/to/my/cgi-error.log\", \"a\")%' {} \\;\n</code>\n</pre>\n", "senID": 11}, {"text": ["The reason I'm posting these commands is that it took me quite a lot of syntactical massaging to get those commands to work (e.g., changing Couldn't to Could not, changing #!/usr/bin/perl to just /usr/bin/perl so the shell wouldn't interpret !", "as a history character, using $OS_ERROR instead of $!, etc."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Thanks to everyone who commented.", "Since no one answered for both Perl and Python I couldn't really \"accept\" any of the given answers, but I did give votes to the ones which led me in the right direction.", "Thanks again!"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["Python has the sys.stderr module that you might want to look into."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "stderr", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;help(sys.__stderr__.read)\nHelp on built-in function read:\n\nread(...)\n    read([size]) -&gt; read at most size bytes, returned as a string.\n\n    If the size argument is negative or omitted, read until EOF is reached.\n    Notice that when in non-blocking mode, less data than what was requested\n    may be returned, even if no size parameter was given.\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can store the output of this in a string and write that string to a file."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Hope this helps"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["In my Perl CGI programs, I usually have"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n BEGIN {\n  open(STDERR,'&gt;&gt;','stderr.log');\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["right after shebang line and \"use strict;use warnings;\".", "If you want, you may append $0 to file name.", "But this will not solve multiple programs problem, as several copies of one programs may be run simultaneously.", "I usually just have several output files, for every program group."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]