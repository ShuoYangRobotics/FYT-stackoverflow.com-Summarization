[[{"text": ["Well, since you know we're basically talking about a database, albeit a very simple one, you probably won't be surprised that I suggest you have a look at the sqlite3 module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sqlite3", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/sqlite3.html"}]}], [{"text": ["Any reason for the human readable requirement?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I would suggest looking at sqlite for a simple database solution, or at pickle for a simple way to serialise objects and write them to disk.", "Neither is particularly human readable though."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Other options are JSON, or XML as you hinted at - use the built in json module to serialize the objects then write that to disk.", "When you start up, check for the presence of that file and load the data if required."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["From the docs:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/json.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import json\n&gt;&gt;&gt; print json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4)\n{\n    \"4\": 5,\n    \"6\": 7\n}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I agree that you don't need a fully blown database, as it seems that all you want is atomic file writes.", "You need to solve this problem in two parts, serialisation/deserialisation, and the atomic writing."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "it seems that all you want is atomic file writes", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["For the first section, json, or pickle are probably suitable formats for you.", "JSON has the advantage of being human readable.", "It doesn't seem as though this the primary problem you are facing though."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "json", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "pickle", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Once you have serialised your object to a string, use the following procedure to write a file to disk atomically, assuming a single concurrent writer (at least on POSIX, see below):"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "use the following procedure to write a file to disk atomically, assuming a single concurrent writer", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import os, platform\nbackup_filename = \"output.back.json\"\nfilename = \"output.json\"\n\nserialised_str = json.dumps(...)\nwith open(backup_filename, 'wb') as f:\n     f.write(serialised_str)\nif platform.system() == 'Windows':\n     os.unlink(filename)\nos.rename(backup_filename, filename)\n</code>\n</pre>\n", "senID": 3}, {"text": ["While os.rename is will overwrite an existing file and is atomic on POSIX, this is sadly not the case on Windows.", "On Windows, there is the possibility that os.unlink will succeed but os.rename will fail, meaning that you have only backup_filename and no filename.", "If you are targeting Windows, you will need to consider this possibility when you are checking for the existence of filename."], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": "os.rename", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "os.unlink", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "os.rename", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "backup_filename", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "filename", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "filename", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If there is a possibility of more than one concurrent writer, you will have to consider a synchronisation construct."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Since you mentioned your data is small, I'd go with a simple solution and use the pickle module, which lets you dump a python object into a line very easily."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "pickle", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/pickle.html#module-pickle"}, {"href": "http://docs.python.org/library/pickle.html#example", "text": "very easily", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Then you just set up a Thread that saves your object to a file in defined time intervals."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Thread", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/threading.html"}]}, {"text": ["Not a \"libraried\" solution, but - if I understand your requirements - simple enough for you not to really need one."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: you mentioned you wanted to cover the case that a problem occurs during the write itself, effectively making it an atomic transaction.", "In this case, the traditional way to go is using \"Log-based recovery\".", "It is essentially writing a record to a log file saying that \"write transaction started\" and then writing \"write transaction comitted\" when you're done.", "If a \"started\" has no corresponding \"commit\", then you rollback."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["In this case, I agree that you might be better off with a simple database like SQLite.", "It might be a slight overkill, but on the other hand, implementing atomicity yourself might be reinventing the wheel a little (and I didn't find any obvious libraries that do it for you)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If you do decide to go the crafty way, this topic is covered on the Process Synchronization chapter of Silberschatz's Operating Systems book, under the section \"atomic transactions\"."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["A very simple (though maybe not \"transactionally perfect\") alternative would be just to record to a new file every time, so that if one corrupts you have a history.", "You can even add a checksum to each file to automatically determine if it's broken."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["You are asking how to implement a database which provides ACID guarantees, but you haven't provided a good reason why you can't use one off-the-shelf.", "SQLite is perfect for this sort of thing and gives you those guarantees."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ACID", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/ACID"}]}, {"text": ["However, there is KirbyBase.", "I've never used it and I don't think it makes ACID guarantees, but it does have some of the characteristics you're looking for."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "KirbyBase", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/KirbyBase/1.9"}]}], [{"text": ["How about Memcached or Redis?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]