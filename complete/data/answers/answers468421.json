[[{"text": ["As far as I know not exactly but you get somewhere with"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n object.methods.sort\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I like to have this in my .irbrc:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Object\n  def local_methods\n    (methods - Object.instance_methods).sort\n  end\nend\n</code>\n</pre>\n", "senID": 1}, {"text": ["So when I'm in irb:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt; Time.now.local_methods \n=&gt; [\"+\", \"-\", \"&lt;\", \"&lt;=\", \"&lt;=&gt;\", \"&gt;\", \"&gt;=\", \"_dump\", \"asctime\", \"between?\", \"ctime\", \"day\", \"dst?\", \"getgm\", \"getlocal\", \"getutc\", \"gmt?\", \"gmt_offset\", \"gmtime\", \"gmtoff\", \"hour\", \"isdst\", \"localtime\", \"mday\", \"min\", \"mon\", \"month\", \"sec\", \"strftime\", \"succ\", \"to_f\", \"to_i\", \"tv_sec\", \"tv_usec\", \"usec\", \"utc\", \"utc?\", \"utc_offset\", \"wday\", \"yday\", \"year\", \"zone\"]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or even cuter - with grep:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt; Time.now.local_methods.grep /str/\n=&gt; [\"strftime\"]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["You can take a module, such as Enumerable, and send the methods method which lists all the methods the module defines.", "Classes that include this module will respond to these methods."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Enumerable", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "methods", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt; Enumerable.methods\n=&gt; [\"inspect\", \"private_class_method\", \"const_missing\", \"clone\", \"method\", \"public_methods\", \"public_instance_methods\", \"instance_variable_defined?\", \"method_defined?\", \"equal?\", \"freeze\", \"included_modules\", \"const_get\", \"yaml_as\", \"methods\", \"respond_to?\", \"module_eval\", \"class_variables\", \"dup\", \"protected_instance_methods\", \"instance_variables\", \"public_method_defined?\", \"__id__\", \"object_id\", \"taguri\", \"yaml_tag_read_class\", \"eql?\", \"const_set\", \"id\", \"to_yaml\", \"taguri=\", \"singleton_methods\", \"send\", \"class_eval\", \"taint\", \"frozen?\", \"instance_variable_get\", \"include?\", \"private_instance_methods\", \"__send__\", \"instance_of?\", \"private_method_defined?\", \"to_a\", \"name\", \"to_yaml_style\", \"autoload\", \"type\", \"yaml_tag_class_name\", \"&lt;\", \"protected_methods\", \"instance_eval\", \"&lt;=&gt;\", \"==\", \"&gt;\", \"display\", \"===\", \"instance_method\", \"instance_variable_set\", \"to_yaml_properties\", \"kind_of?\", \"extend\", \"protected_method_defined?\", \"const_defined?\", \"&gt;=\", \"ancestors\", \"to_s\", \"&lt;=\", \"public_class_method\", \"hash\", \"class\", \"instance_methods\", \"tainted?\", \"=~\", \"private_methods\", \"class_variable_defined?\", \"nil?\", \"untaint\", \"constants\", \"autoload?\", \"is_a?\"]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Tip for \"searching\" for a method in irb: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \"something\".methods.select {|item| item =~ /query/ }\n</code>\n</pre>\n", "senID": 1}, {"text": ["Tip for trying out methods on a value for comparison:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n value = \"something\"\n[:upcase, :downcase, :capitalize].collect {|method| [method, value.send(method)] }\n</code>\n</pre>\n", "senID": 3}, {"text": ["Also, note that you won't get all the same information as Python's dir with object.methods.", "You have to use a combination of object.methods and class.constants, also class.singleton_methods to get the class methods."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I've asked a similar question previously here:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://stackoverflow.com/questions/228648/how-do-you-list-the-currently-available-objects-in-the-current-scope-in-ruby"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://stackoverflow.com/questions/228648/how-do-you-list-the-currently-available-objects-in-the-current-scope-in-ruby", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/228648/how-do-you-list-the-currently-available-objects-in-the-current-scope-in-ruby"}]}], [{"text": ["I'd go for something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n y String.methods.sort\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which will give you a yaml representation of the sorted array of methods.", "Note that this can be used to list the methods of both classes and objects."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Not really.", "Like the others said, you can get part of what you want by listing class instance methods (e.g.", "String.instance_methods) but that doesn't help you if a file you open reopens a class (unless you check before and after)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "String.instance_methods", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["If you don't need programmatic access to the list of methods, consider checking out the documentation for a class, module or method using the ri command line tool."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "ri", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I would have made this a comment to jonelf's answer, but apparently I don't have enough rep."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["some_object.methods.sort - Object.new.methods"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This isn't exactly what you were asking as others have said, but it gives you the info you are after."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If I stricly read your question, I must answer it that way: a file as specified by require in Ruby is just a container and does not have necessarely have any relation with a class.", "The content can be:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "require", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "a class", "tag": "none", "senID": 1}, {"text": "a module", "tag": "none", "senID": 2}, {"text": "plain code", "tag": "none", "senID": 3}]}, {"text": ["or any combination of the above, several times.", "So you can not directly ask for all methods in a given file."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If you meant to list all methods of a given module or class, then the other answers are what you seek (mainly using the #methods method on a module name or class)."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "#methods", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]