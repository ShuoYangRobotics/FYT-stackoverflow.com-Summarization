[[{"text": ["Yes.", "It's bad.", "It conflates the instance with the collection of instances."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Collections are one thing."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The instances which are collected are unrelated."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Also, class-level variables which get updated confuse some of us.", "Yes, we can eventually reason on what's going on, but the Standard Expectation\u2122 is that state change applies to objects, not classes."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Foobar_Collection( dict ):\n     def __init__( self, *arg, **kw ):\n         super( Foobar_Collection, self ).__init__( *arg, **kw ):\n     def foobar( self, *arg, **kw ):\n         fb= Foobar( *arg, **kw )\n         self[fb.name]= fb\n         return fb\n\n class Foobar( object ):\n     def __init__( self, name, something )\n         self.name= name\n         self.something= something\n\nfc= Foobar_Collection()\nfc.foobar( 'first', 42 )\nfc.foobar( 'second', 77 ) \n\nfor name in fc:\n    print name, fc[name]\n</code>\n</pre>\n", "senID": 4}, {"text": ["That's more typical."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["In your example, the wait_for_deps is simply a method of the task collection, not the individual task.", "You don't need globals."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "wait_for_deps", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You need to refactor."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I don't suppose that there's anything wrong with this, but I don't really see how this would be sensible.", "Why would you need to keep a global variable (in the class, of all places) that holds references to all the instances?", "The client could just as easily implement this himself if he just kept a list of his instances.", "All in all, it seems a little hackish and unnecessary, so I'd recommend that you don't do it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "wrong", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["If you're more specific about what you're trying to do, perhaps we can find a better solution."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This is NOT cohesive, as well as not very functional, you want to strive to get your objects as far from the 'data-bucket' mindset as possible.", "The static object collection is not going to really gain you anything, you need to think WHY do you need all the objects in the collection and think about creating a second class whose responsibility is to manage and be queried for all the Foobars in the system."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Why would you want to do this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There are several problems with this code.", "The first is that you have to take care of deleting instances -- there will always be a reference to each Foobar instance left in Foobar.foobars, so the garbage collector will never garbage collect them.", "The second problem is that it won't work with copy and pickle."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "Foobar", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Foobar.foobars", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "copy", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "pickle", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["But apart from the technical problems, it feels like a wrong design.", "The purpose of object instances is hiding state, and you make them see each other."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["From a OOP point of view there's nothing wrong with it.", "A class is an instance of a metaclass, and any instance can hold any kind of data in it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, from an efficiency point of view, if you don't eventualy clean up the foobars dict on a long running Python program, you are having potential memory leak."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "foobars", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["No one has mentioned the potential problem this might have if you later derive a subclass from Foobar which could happen if the base class __init__() function is called from the derived class's __init__().", "Specifically whether you want all the subclass instances to be sored in the same place as those of the base class -- which of course depend on why you're doing this."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Foobar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__init__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["It's a solvable problem but something to consider, and perhaps to code for, up front in the base class."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]