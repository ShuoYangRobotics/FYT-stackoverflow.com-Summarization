[[{"text": ["A regular expression will do the trick with very little code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\n...\n\nif re.match(\"^[A-Za-z0-9_-]*$\", my_little_string):\n    # do something here\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There are a variety of ways of achieving this goal, some are clearer than others.", "For each of my examples, 'True' means that the string passed is valid, 'False' means it contains invalid characters."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First of all, there's the naive approach:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import string\nallowed = string.letters + string.digits + '_' + '-'\n\ndef check_naive(mystring):\n    return all(c in allowed for c in mystring)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then there's use of a regular expression, you can do this with re.match().", "Note that '-' has to be at the end of the [] otherwise it will be used as a 'range' delimiter.", "Also note the $ which means 'end of string'.", "Other answers noted in this question use a special character class, '\\w', I always prefer using an explicit character class range using [] because it is easier to understand without having to look up a quick reference guide, and easier to special-case."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import re\nCHECK_RE = re.compile('[a-zA-Z0-9_-]+$')\ndef check_re(mystring):\n    return CHECK_RE.match(mystring)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Another solution noted that you can do an inverse match with regular expressions, I've included that here now.", "Note that [^...] inverts the character class because the ^ is used:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n CHECK_INV_RE = re.compile('[^a-zA-Z0-9_-]')\ndef check_inv_re(mystring):\n   return not CHECK_INV_RE.search(mystring)\n</code>\n</pre>\n", "senID": 6}, {"text": ["You can also do something tricky with the 'set' object.", "Have a look at this example, which removes from the original string all the characters that are allowed, leaving us with a set containing either a) nothing, or b) the offending characters from the string:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def check_set(mystring):\n    return not set(mystring) - set(allowed)\n</code>\n</pre>\n", "senID": 8}], [{"text": ["[Edit]  There's another solution not mentioned yet, and it seems to outperform the others given so far in most cases."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Use string.translate to replace all valid characters in the string, and see if we have any invalid ones left over.", "This is pretty fast as it uses the underlying C function to do the work, with very little python bytecode involved."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Obviously performance isn't everything - going for the most readable solutions is probably the best approach when not in a performance critical codepath, but just to see how the solutions stack up, here's a performance comparison of all the methods proposed so far.", "check_trans is the one using the string.translate method."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Test code:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import string, re, timeit\n\npat = re.compile('[\\w-]*$')\npat_inv = re.compile ('[^\\w-]')\nallowed_chars=string.ascii_letters + string.digits + '_-'\nallowed_set = set(allowed_chars)\ntrans_table = string.maketrans('','')\n\ndef check_set_diff(s):\n    return not set(s) - allowed_set\n\ndef check_set_all(s):\n    return all(x in allowed_set for x in s)\n\ndef check_set_subset(s):\n    return set(s).issubset(allowed_set)\n\ndef check_re_match(s):\n    return pat.match(s)\n\ndef check_re_inverse(s): # Search for non-matching character.\n    return not pat_inv.search(s)\n\ndef check_trans(s):\n    return not s.translate(trans_table,allowed_chars)\n\ntest_long_almost_valid='a_very_long_string_that_is_mostly_valid_except_for_last_char'*99 + '!'\ntest_long_valid='a_very_long_string_that_is_completely_valid_' * 99\ntest_short_valid='short_valid_string'\ntest_short_invalid='/$%$%&amp;'\ntest_long_invalid='/$%$%&amp;' * 99\ntest_empty=''\n\ndef main():\n    funcs = sorted(f for f in globals() if f.startswith('check_'))\n    tests = sorted(f for f in globals() if f.startswith('test_'))\n    for test in tests:\n        print \"Test %-15s (length = %d):\" % (test, len(globals()[test]))\n        for func in funcs:\n            print \"  %-20s : %.3f\" % (func, \n                   timeit.Timer('%s(%s)' % (func, test), 'from __main__ import pat,allowed_set,%s' % ','.join(funcs+tests)).timeit(10000))\n        print\n\nif __name__=='__main__': main()\n</code>\n</pre>\n", "senID": 4}, {"text": ["The results on my system are:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n Test test_empty      (length = 0):\n  check_re_inverse     : 0.042\n  check_re_match       : 0.030\n  check_set_all        : 0.027\n  check_set_diff       : 0.029\n  check_set_subset     : 0.029\n  check_trans          : 0.014\n\nTest test_long_almost_valid (length = 5941):\n  check_re_inverse     : 2.690\n  check_re_match       : 3.037\n  check_set_all        : 18.860\n  check_set_diff       : 2.905\n  check_set_subset     : 2.903\n  check_trans          : 0.182\n\nTest test_long_invalid (length = 594):\n  check_re_inverse     : 0.017\n  check_re_match       : 0.015\n  check_set_all        : 0.044\n  check_set_diff       : 0.311\n  check_set_subset     : 0.308\n  check_trans          : 0.034\n\nTest test_long_valid (length = 4356):\n  check_re_inverse     : 1.890\n  check_re_match       : 1.010\n  check_set_all        : 14.411\n  check_set_diff       : 2.101\n  check_set_subset     : 2.333\n  check_trans          : 0.140\n\nTest test_short_invalid (length = 6):\n  check_re_inverse     : 0.017\n  check_re_match       : 0.019\n  check_set_all        : 0.044\n  check_set_diff       : 0.032\n  check_set_subset     : 0.037\n  check_trans          : 0.015\n\nTest test_short_valid (length = 18):\n  check_re_inverse     : 0.125\n  check_re_match       : 0.066\n  check_set_all        : 0.104\n  check_set_diff       : 0.051\n  check_set_subset     : 0.046\n  check_trans          : 0.017\n</code>\n</pre>\n", "senID": 6}, {"text": ["The translate approach seems best in most cases, dramatically so with long valid strings, but is beaten out by regexes in test_long_invalid (Presumably because the regex can bail out immediately, but translate always has to scan the whole string).", "The set approaches are usually worst, beating regexes only for the empty string case."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Using all(x in allowed_set for x in s) performs well if it bails out early, but can be bad if it has to iterate through every character.", "isSubSet and set difference are comparable, and are consistently proportional to the length of the string regardless of the data."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["There's a similar difference between the regex methods matching all valid characters and searching for invalid characters.", "Matching performs a little better when checking for a long, but fully valid string, but worse for invalid characters near the end of the string."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"code": "<pre>\n<code>\n pat = re.compile ('[^\\w-]')\n\n def onlyallowed(s):\n    return not pat.search (s)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If it were not for the dashes and underscores, the easiest solution would be"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n my_little_string.isalnum()\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Section 3.6.1 of the Phython Library Reference)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "3.6.1", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/string-methods.html"}]}], [{"text": ["use a regex and see if it matches!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ([a-z][A-Z][0-9]\\_\\-)*\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could always use a list comprehension and check the results with all, it would be a little less resource intensive than using a regex: all([c in string.letters + string.digits + [\"_\", \"-\"] for c in mystring])"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "all([c in string.letters + string.digits + [\"_\", \"-\"] for c in mystring])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["um, you guys need to brush up on your regexp... just [\\w-]"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["As an alternative to using regex you could do it in Sets:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from sets import Set\n\nallowed_chars = Set('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-')\n\nif Set(my_little_sting).issubset(allowed_chars):\n    # your action\n    print True\n</code>\n</pre>\n", "senID": 1}]]