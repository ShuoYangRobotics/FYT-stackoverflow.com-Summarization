[[{"text": ["The reason it is slow is because it is O(N*N)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The maximum subsequence algorithm may help you improve this"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "maximum subsequence", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wordaligned.org/articles/the-maximum-subsequence-problem"}]}], [{"text": ["if topScore is called repeatedly for same seq you could memoize its value. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "topScore", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "seq", "childNum": 0, "tag": "code", "childList": []}, {"text": "memoize", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["E.g.", "http://code.activestate.com/recipes/52201/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://code.activestate.com/recipes/52201/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/52201/"}]}], [{"text": ["i don't have any idea what i'm doing but maybe this can help speed up your algo:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ret = -1e9999\nlogProbs = self.logProbs  # save indirection\nl = len(logProbs)\n\nscores = collections.defaultdict(int)\n\nfor j in xrange(l):\n    prob = logProbs[j]\n    for i in xrange(len(seq) - l + 1):\n        scores[i] += prob[seq[j + i]]\n\n\nret = max(ret, max(scores.values()))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["What about precomputing xrange(l) outside the for i loop?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "xrange(l)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Nothing jumps out as being slow.", "I might rewrite the inner loop like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n score = sum(logProbs[j][seq[j+i]] for j in xrange(l))\n</code>\n</pre>\n", "senID": 1}, {"text": ["or even:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n seqmatch = zip(seq[i:i+l], logProbs)\nscore = sum(posscores[base] for base, posscores in seqmatch)\n</code>\n</pre>\n", "senID": 3}, {"text": ["but I don't know that either would save much time."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["It might be marginally quicker to store DNA bases as integers 0-3, and look up the scores from a tuple instead of a dictionary.", "There'll be a performance hit on translating letters to numbers, but that only has to be done once."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Definitely use numpy and store logProbs as a 2D array instead of a list of dictionaries.", "Also store seq as a 1D array of (short) integers as suggested above.", "This will help if you don't have to do these conversions every time you call the function (doing these conversions inside the function won't save you much).", "You can them eliminate the second loop:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy as np\n...\nprint np.shape(self.logProbs) # (20, 4)\nprint np.shape(seq) # (1000,)\n...\ndef topScore(self, seq):\nret = -1e9999\nlogProbs = self.logProbs  # save indirection\nl = len(logProbs)\nfor i in xrange(len(seq) - l + 1):\n    score = np.sum(logProbs[:,seq[i:i+l]])\n    ret = max(ret, score)\n\nreturn ret\n</code>\n</pre>\n", "senID": 1}, {"text": ["What you do after that depends on which of these 2 data elements changes the most often:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If logProbs generally stays the same and you want to run many DNA sequences through it, then consider stacking your DNA sequences as a 2D array.", "numpy can loop through the 2D array very quickly so if you have 200 DNA sequences to process, it will only take a little longer than a single."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Finally, if you really need speed up, use scipy.weave.", "This is a very easy way to write a few lines of fast C to accelerate you loops.", "However, I recommend scipy >0.8."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You can try hoisting more than just self.logProbs outside the loops:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def topScore(self, seq):\n    ret = -1e9999\n    logProbs = self.logProbs  # save indirection\n    l = len(logProbs)\n    lrange = range(l)\n    for i in xrange(len(seq) - l + 1):\n        score = 0.0\n        for j in lrange:\n            score += logProbs[j][seq[j + i]]\n        if score &gt; ret: ret = score # avoid lookup and function call\n\n    return ret\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I doubt it will make a significant difference, but you could try changing:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for j in xrange(l):\n        score += logProbs[j][seq[j + i]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["to "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for j,lP in enumerate(logProbs):\n        score += lP[seq[j + i]]\n</code>\n</pre>\n", "senID": 3}, {"text": ["or even hoisting that enumeration outside the seq loop. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]