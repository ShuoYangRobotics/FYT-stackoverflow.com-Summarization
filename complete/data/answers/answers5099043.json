[[{"text": ["Here is my take on this problem.", "Requiring that the user scripts run inside vanilla CPython means you either need to write an interpreter for your mini language, or compile it to Python bytecode (or use Python as your source language) and then \"sanitize\" the bytecode before executing it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I've gone for a quick example based on the assumption that users can write \ntheir scripts in Python, and that the source and bytecode can be sufficiently\nsanitized through some combination of filtering unsafe syntax from the parse\ntree and/or removing unsafe opcodes from the bytecode."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The second part of the solution requires that the user script bytecode be \nperiodically interrupted by a watchdog task which will ensure that the user\nscript does not exceed some opcode limit, and for all of this to run on vanilla CPython."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Summary of my attempt, which mostly focuses on the 2nd part of the problem."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "User scripts are written in Python.", "tag": "none", "senID": 4}, {"text": "Use ", "tag": "none", "senID": 5}, {"text": "Instrument the user's bytecode to insert an opcode counter and calls to a function which context switches to the watchdog task.", "tag": "none", "senID": 6}, {"text": "Use ", "tag": "none", "senID": 7}, {"text": "The watchdog enforces a preset limit on the number of opcodes which can be\nexecuted before raising an error.", "tag": "none", "senID": 8}]}, {"text": ["Hopefully this at least goes in the right direction.", "I'm interested to hear\nmore about your solution when you arrive at it."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Source code for lowperf.py:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "lowperf.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # std\nimport ast\nimport dis\nimport sys\nfrom pprint import pprint\n\n# vendor\nimport byteplay\nimport greenlet\n\n# bytecode snippet to increment our global opcode counter\nINCREMENT = [\n    (byteplay.LOAD_GLOBAL, '__op_counter'),\n    (byteplay.LOAD_CONST, 1),\n    (byteplay.INPLACE_ADD, None),\n    (byteplay.STORE_GLOBAL, '__op_counter')\n    ]\n\n# bytecode snippet to perform a yield to our watchdog tasklet.\nYIELD = [\n    (byteplay.LOAD_GLOBAL, '__yield'),\n    (byteplay.LOAD_GLOBAL, '__op_counter'),\n    (byteplay.CALL_FUNCTION, 1),\n    (byteplay.POP_TOP, None)\n    ]\n\ndef instrument(orig):\n    \"\"\"\n    Instrument bytecode.  We place a call to our yield function before\n    jumps and returns.  You could choose alternate places depending on \n    your use case.\n    \"\"\"\n    line_count = 0\n    res = []\n    for op, arg in orig.code:\n        line_count += 1\n\n        # NOTE: you could put an advanced bytecode filter here.\n\n        # whenever a code block is loaded we must instrument it\n        if op == byteplay.LOAD_CONST and isinstance(arg, byteplay.Code):\n            code = instrument(arg)\n            res.append((op, code))\n            continue\n\n        # 'setlineno' opcode is a safe place to increment our global \n        # opcode counter.\n        if op == byteplay.SetLineno:\n            res += INCREMENT\n            line_count += 1\n\n        # append the opcode and its argument\n        res.append((op, arg))\n\n        # if we're at a jump or return, or we've processed 10 lines of\n        # source code, insert a call to our yield function.  you could \n        # choose other places to yield more appropriate for your app.\n        if op in (byteplay.JUMP_ABSOLUTE, byteplay.RETURN_VALUE) \\\n                or line_count &gt; 10:\n            res += YIELD\n            line_count = 0\n\n    # finally, build and return new code object\n    return byteplay.Code(res, orig.freevars, orig.args, orig.varargs,\n        orig.varkwargs, orig.newlocals, orig.name, orig.filename,\n        orig.firstlineno, orig.docstring)\n\ndef transform(path):\n    \"\"\"\n    Transform the Python source into a form safe to execute and return\n    the bytecode.\n    \"\"\"\n    # NOTE: you could call ast.parse(data, path) here to get an\n    # abstract syntax tree, then filter that tree down before compiling\n    # it into bytecode.  i've skipped that step as it is pretty verbose.\n    data = open(path, 'rb').read()\n    suite = compile(data, path, 'exec')\n    orig = byteplay.Code.from_code(suite)\n    return instrument(orig)\n\ndef execute(path, limit = 40):\n    \"\"\"\n    This transforms the user's source code into bytecode, instrumenting\n    it, then kicks off the watchdog and user script tasklets.\n    \"\"\"\n    code = transform(path)\n    target = greenlet.greenlet(run_task)\n\n    def watcher_task(op_count):\n        \"\"\"\n        Task which is yielded to by the user script, making sure it doesn't\n        use too many resources.\n        \"\"\"\n        while 1:\n            if op_count &gt; limit:\n                raise RuntimeError(\"script used too many resources\")\n            op_count = target.switch()\n\n    watcher = greenlet.greenlet(watcher_task)\n    target.switch(code, watcher.switch)\n\ndef run_task(code, yield_func):\n    \"This is the greenlet task which runs our user's script.\"\n    globals_ = {'__yield': yield_func, '__op_counter': 0}\n    eval(code.to_code(), globals_, globals_)\n\nexecute(sys.argv[1])\n</code>\n</pre>\n", "senID": 11}, {"text": ["Here is a sample user script user.py:"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "user.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def otherfunc(b):\n    return b * 7\n\ndef myfunc(a):\n    for i in range(0, 20):\n        print i, otherfunc(i + a + 3)\n\nmyfunc(2)\n</code>\n</pre>\n", "senID": 13}, {"text": ["Here is a sample run:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n % python lowperf.py user.py\n\n0 35\n1 42\n2 49\n3 56\n4 63\n5 70\n6 77\n7 84\n8 91\n9 98\n10 105\n11 112\nTraceback (most recent call last):\n  File \"lowperf.py\", line 114, in &lt;module&gt;\n    execute(sys.argv[1])\n  File \"lowperf.py\", line 105, in execute\n    target.switch(code, watcher.switch)\n  File \"lowperf.py\", line 101, in watcher_task\n    raise RuntimeError(\"script used too many resources\")\nRuntimeError: script used too many resources\n</code>\n</pre>\n", "senID": 15}], [{"text": ["Try Lua.", "The syntax you mentioned is almost identical to Lua's.", "See How could I embed Lua into Python 3.x?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "How could I embed Lua into Python 3.x?", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4527261/how-could-i-embed-lua-into-python-3-x"}]}], [{"text": ["I don't know of anything that really solves this problem yet."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I think the absolute simplest thing you could do would be to write your own version of the python virtual machine in python. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I've often thought of doing that in something like Cython so you could just import it as a module, and you could lean on the existing runtime for most of the hard bits."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You may already be able to generate a python-in-python interpreter with PyPy, but PyPy's output is a runtime that does EVERYTHING, including implementing the equivalent of the underlying PyObjects for built-in types and all that, and I think that's overkill for this kind of thing."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["All you really need is something that works like a Frame in the execution stack, and then a method for each opcode.", "I don't think you even have to implement it yourself.", "You could just write a module that exposed the existing frame objects to the runtime."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Anyway, then you just maintain your own stack of frame objects and handle the bytecodes, and you can throttle it with bytecodes per second or whatever."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Why not python code in pysandbox http://pypi.python.org/pypi/pysandbox/1.0.3 ?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://pypi.python.org/pypi/pysandbox/1.0.3", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/pysandbox/1.0.3"}]}], [{"text": ["Take a look at LimPy.", "It stands for Limited Python and was built for exactly this purpose."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "LimPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://bitbucket.org/yougov/limpy/src"}]}, {"text": ["There was an environment where users needed to write basic logic to control a user experience.", "I don't know how it'll interact with runtime limits, but I imagine you can do it if you're willing to write a little code."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I've used Python as a \"mini config language\" for an earlier project.", "My approach was to take the code, parse it using the parser module and then to walk the AST of the generated code and to kick out \"unallowed\" operations (e.g.", "defining classes, called __ methods etc.", "). "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "parser", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["After I do this, a created a synthetic environment with only the modules and variables that were \"allowed\" and evaluated the code within that to get something I could run. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It worked nicely for me.", "I don't know if it's bullet proof especially if you want to give your users more power than I did for a config language. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["As for the time limit, you could run your program in a separate thread or process and terminate it after a fixed amount of time."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The simplest way to make a real DSL is ANTLR, it has syntax templates for some popular languages."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]