[[{"text": ["Maybe your lists are too large and do not fit in memory, and you experience thrashing.", "If the sources are in files, you do not need the whole list in memory all at once.", "Try using itertools, e.g."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "thrashing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Thrash_(computer_science)"}, {"text": "itertools", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import ifilter\n\ndef is_important(s):\n   return len(s)&gt;10\n\nfiltered_list = ifilter(is_important, open('mylist.txt'))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that ifilter returns an iterator that is fast and memory efficient."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "ifilter", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "iterator", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Generator Tricks is a tutorial by David M. Beazley that teaches some interesting uses for generators."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Generator Tricks", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/generators/"}, {"text": "generators", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["If you can avoid creating the lists in the first place, you'll be happier."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Rather than"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n aBigList = someListMakingFunction()\nfilter( lambda x:x&gt;10, aBigList )\n</code>\n</pre>\n", "senID": 2}, {"text": ["You might want to look at your function that makes the list."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def someListMakingGenerator( ):\n    for x in some source:\n        yield x\n</code>\n</pre>\n", "senID": 4}, {"text": ["Then your filter doesn't involve a giant tract of memory"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def myFilter( aGenerator ):\n    for x in aGenerator:\n        if x &gt; 10: \n            yield x\n</code>\n</pre>\n", "senID": 6}, {"text": ["By using generators, you don't keep much stuff in memory."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I guess filter() is as fast as you can possibly get without having to code the filtering function in C (and in that case, you better code the whole filtering process in C)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Why don't you paste the function you are filtering on?", "That might lead to easier optimizations."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Read this about optimization in Python.", "And this about the Python/C API."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/essays/list2str.html"}, {"text": "this", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/api/api.html"}]}], [{"text": ["Before doing it in C, you could try numpy.", "Perhaps you can turn your filtering into number crunching."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org/"}]}], [{"text": ["Filter will create a new list, so if your original is very big, you could end up using up to twice as much memory.", "If you only need to process the results iteratively, rather than use it as a real random-access list, you are probably better off using\nifilter instead.", "ie."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for x in itertools.ifilter(condition_func, my_really_big_list):\n    do_something_with(x)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Other speed tips are to use a python builtin, rather than a function you write yourself.", "There's a itertools.ifilterfalse specifically for the\ncase where you would otherwise need to introduce a lambda to negate your check.", "(eg \"ifilter(lambda x: not x.isalpha(), l)\" should be written \"ifilterfalse(str.isalpha, l)\")"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It may be useful to know that generally a conditional list comprehension is much faster than the corresponding lambda:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import timeit\n&gt;&gt;&gt; timeit.Timer('[x for x in xrange(10) if (x**2 % 4) == 1]').timeit()\n2.0544309616088867\n&gt;&gt;&gt; timeit.f = lambda x: (x**2 % 4) == 1\ntimeit.Timer('[x for x in xrange(10) if f(x)]').timeit()\n&gt;&gt;&gt; \n3.4280929565429688\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Not sure why I needed to put f in the timeit namespace, there.", "Haven't really used the module much."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "timeit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]