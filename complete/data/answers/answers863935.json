[[{"text": ["Not really.", "Have you measured that?", "Since both dictionaries would use references to the same objects as keys and values, then the memory spent would be just the dictionary structure.", "That's a lot less than twice and is a fixed ammount regardless of your data size."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "same objects", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}, {"text": "twice", "childNum": 1, "tag": "strong", "pos": 3, "childList": [{"text": "twice", "tag": "em"}]}, {"text": "twice", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["What I mean is that the actual data wouldn't be copied.", "So you'd spend little extra memory."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a = \"some really really big text spending a lot of memory\"\n\nnumber_to_text = {1: a}\ntext_to_number = {a: 1}\n</code>\n</pre>\n", "senID": 3}, {"text": ["Only a single copy of the \"really big\" string exists, so you end up spending just a little more memory.", "That's generally affordable."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I can't imagine a solution where you'd have the key lookup speed when looking by value, if you don't spend at least enough memory to store a reverse lookup hash table (which is exactly what's being done in your \"unite two dicts\" solution)."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "at least", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Not really, since they would just be holding two references to the same data.", "In my mind, this is not a bad solution. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Have you considered an in-memory database lookup?", "I am not sure how it will compare in speed, but lookups in relational databases can be very fast."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "very", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["How about using sqlite?", "Just create a :memory: database with a two-column table.", "You can even add indexes, then query by either one.", "Wrap it in a class if it's something you're going to use a lot. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Assuming that you have a key with which you look up a more complex mutable object, just make the key a property of that object.", "It does seem you might be better off thinking about the data model a bit."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["\"We can guarantee that either the key or the value (or both) will be an integer\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That's weirdly written -- \"key or the value (or both)\" doesn't feel right.", "Either they're all integers, or they're not all integers.    "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It sounds like they're all integers."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Or, it sounds like you're thinking of replacing the target object with an integer value so you only have one copy referenced by an integer.", "This is a false economy.", "Just keep the target object.", "All Python objects are -- in effect -- references.", "Very little actual copying gets done."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Let's pretend that you simply have two integers and can do a lookup on either one of the pair.", "One way to do this is to use heap queues or the bisect module to maintain ordered lists of integer key-value tuples."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["See http://docs.python.org/library/heapq.html#module-heapq"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "http://docs.python.org/library/heapq.html#module-heapq", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/heapq.html#module-heapq"}]}, {"text": ["See http://docs.python.org/library/bisect.html#module-bisect"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "http://docs.python.org/library/bisect.html#module-bisect", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/bisect.html#module-bisect"}]}, {"text": ["You have one heapq (key,value) tuples.", "Or, if your underlying object is more complex, the (key,object) tuples."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "(key,value)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(key,object", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You have another heapq (value,key) tuples.", "Or, if your underlying object is more complex, (otherkey,object) tuples."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "(value,key)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(otherkey,object)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["An \"insert\" becomes two inserts, one to each heapq-structured list."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["A key lookup is in one queue; a value lookup is in the other queue.", "Do the lookups using bisect(list,item).  "], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "bisect(list,item)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"code": "<pre>\n<code>\n class TwoWay:\n    def __init__(self):\n       self.d = {}\n    def add(self, k, v):\n       self.d[k] = v\n       self.d[v] = k\n    def remove(self, k):\n       self.d.pop(self.d.pop(k))\n    def get(self, k):\n       return self.d[k]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Here is my own solution to this problem: http://github.com/spenthil/pymathmap/blob/master/pymathmap.py"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://github.com/spenthil/pymathmap/blob/master/pymathmap.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/spenthil/pymathmap/blob/master/pymathmap.py"}]}, {"text": ["The goal is to make it as transparent to the user as possible.", "The only introduced significant attribute is partner."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "partner", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["OneToOneDict subclasses from dict - I know that isn't generally recommended, but I think I have the common use cases covered.", "The backend is pretty simple, it (dict1) keeps a weakref to a 'partner' OneToOneDict (dict2) which is its inverse.", "When dict1 is modified dict2 is updated accordingly as well and vice versa."], "childNum": 8, "tag": "p", "senID": 2, "childList": [{"text": "OneToOneDict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "isn't generally recommended", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1392396/advantages-of-userdict-class-in-python/1394572#1394572"}, {"text": "dict1", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "OneToOneDict", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict2", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict1", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict2", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["From the docstring:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dict1 = OneToOneDict()\n&gt;&gt;&gt; dict2 = OneToOneDict()\n&gt;&gt;&gt; dict1.partner = dict2\n&gt;&gt;&gt; assert(dict1 is dict2.partner)\n&gt;&gt;&gt; assert(dict2 is dict1.partner)\n&gt;&gt;&gt; dict1['one'] = '1'\n&gt;&gt;&gt; dict2['2'] = '1'\n&gt;&gt;&gt; dict1['one'] = 'wow'\n&gt;&gt;&gt; assert(dict1 == dict((v,k) for k,v in dict2.items()))\n&gt;&gt;&gt; dict1['one'] = '1'\n&gt;&gt;&gt; assert(dict1 == dict((v,k) for k,v in dict2.items()))\n&gt;&gt;&gt; dict1.update({'three': '3', 'four': '4'})\n&gt;&gt;&gt; assert(dict1 == dict((v,k) for k,v in dict2.items()))\n&gt;&gt;&gt; dict3 = OneToOneDict({'4':'four'})\n&gt;&gt;&gt; assert(dict3.partner is None)\n&gt;&gt;&gt; assert(dict3 == {'4':'four'})\n&gt;&gt;&gt; dict1.partner = dict3\n&gt;&gt;&gt; assert(dict1.partner is not dict2)\n&gt;&gt;&gt; assert(dict2.partner is None)\n&gt;&gt;&gt; assert(dict1.partner is dict3)\n&gt;&gt;&gt; assert(dict3.partner is dict1)\n&gt;&gt;&gt; dict1.setdefault('five', '5')\n&gt;&gt;&gt; dict1['five']\n'5'\n&gt;&gt;&gt; dict1.setdefault('five', '0')\n&gt;&gt;&gt; dict1['five']\n'5'\n</code>\n</pre>\n", "senID": 4}, {"text": ["When I get some free time, I intend to make a version that doesn't store things twice.", "No clue when that'll be though :)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["It so happens that I find myself asking this question all the time (yesterday in particular).", "I agree with the approach of making two dictionaries.", "Do some benchmarking to see how much memory it's taking.", "I've never needed to make it mutable, but here's how I abstract it, if it's of any use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class BiDict(list):\n    def __init__(self,*pairs):\n    \tsuper(list,self).__init__(pairs)\n    \tself._first_access = {}\n    \tself._second_access = {}\n    \tfor pair in pairs:\n    \t\tself._first_access[pair[0]] = pair[1]\n    \t\tself._second_access[pair[1]] = pair[0]\n    \t\tself.append(pair)\n\n    def _get_by_first(self,key):\n    \treturn self._first_access[key]\n\n    def _get_by_second(self,key):\n    \treturn self._second_access[key]\n\n    # You'll have to do some overrides to make it mutable\n    # Methods such as append, __add__, __del__, __iadd__\n    # to name a few will have to maintain ._*_access\n\nclass Constants(BiDict):\n    # An implementation expecting an integer and a string\n    get_by_name = BiDict._get_by_second\n    get_by_number = BiDict._get_by_first\n\nt = Constants(\n    \t( 1, 'foo'),\n    \t( 5, 'bar'),\n    \t( 8, 'baz'),\n    )\n\n&gt;&gt;&gt; print t.get_by_number(5)\nbar\n&gt;&gt;&gt; print t.get_by_name('baz')\n8\n&gt;&gt;&gt; print t\n[(1, 'foo'), (5, 'bar'), (8, 'baz')]\n</code>\n</pre>\n", "senID": 1}]]