[[{"text": ["The interval package may provide all that you need."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "interval", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/interval/1.0.0"}]}, {"code": "<pre>\n<code>\n from interval import Interval, IntervalSet\nr1 = IntervalSet([Interval(1, 1000), Interval(1100, 1200)])\nr2 = IntervalSet([Interval(30, 50), Interval(60, 200), Interval(1150, 1300)])\nprint(r1 - r2)\n\n&gt;&gt;&gt; [1..30),(50..60),(200..1000],[1100..1150)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["One solution (in addition to all the other different solutions that have been presented here) is to use an interval/segment tree (they are really the same thing):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://en.wikipedia.org/wiki/Segment_tree"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://en.wikipedia.org/wiki/Segment_tree", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Segment_tree"}]}, {"text": ["http://en.wikipedia.org/wiki/Interval_tree"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://en.wikipedia.org/wiki/Interval_tree", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Interval_tree"}]}, {"text": ["One big advantage to doing it this way is that it is trivial to do arbitrary boolean operations (not just subtraction) using the same piece of code.", "There is a standard treatment of this data structure in de Berg.", "To perform any boolean operation on a pair of interval trees, (including subtraction) you just merge them together.", "Here is some (admittedly naive) Python code for doing this with unbalanced range trees.", "The fact that they are unbalanced has no effect on the time taken to merge the trees, however the tree construction here is the really dumb part which ends up being quadratic (unless the reduce is executed by partitioning, which I somehow doubt).", "Anyway here you go:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class IntervalTree:\n    def __init__(self, h, left, right):\n        self.h = h\n        self.left = left\n        self.right = right\n\ndef merge(A, B, op, l=-float(\"inf\"), u=float(\"inf\")):\n    if l &gt; u:\n        return None\n    if not isinstance(A, IntervalTree):\n        if isinstance(B, IntervalTree):\n            opT = op\n            A, B, op = B, A, (lambda x, y : opT(y,x))\n        else:\n            return op(A, B)\n    left = merge(A.left, B, op, l, min(A.h, u))\n    right = merge(A.right, B, op, max(A.h, l), u)\n    if left is None:\n        return right\n    elif right is None or left == right:\n        return left\n    return IntervalTree(A.h, left, right)\n\ndef to_range_list(T, l=-float(\"inf\"), u=float(\"inf\")):\n    if isinstance(T, IntervalTree):\n        return to_range_list(T.left, l, T.h) + to_range_list(T.right, T.h, u)\n    return [(l, u-1)] if T else []\n\ndef range_list_to_tree(L):\n    return reduce(lambda x, y : merge(x, y, lambda a, b: a or b), \n        [ IntervalTree(R[0], False, IntervalTree(R[1]+1, True, False)) for R in L ])\n</code>\n</pre>\n", "senID": 4}, {"text": ["I wrote this kind of quickly and didn't test it that much, so there could be bugs.", "Also note that this code will work with arbitrary boolean operations, not just differences (you simply pass them as the argument to op in merge).", "The time complexity of evaluating any of these is linear on the size of the output tree (which is also the same as the number of intervals in the result).", "As an example, I ran it on the case you provided:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n #Example:\nr1 = range_list_to_tree([ (1, 1000), (1100, 1200) ])\nr2 = range_list_to_tree([ (30, 50), (60, 200), (1150, 1300) ])\ndiff = merge(r1, r2, lambda a, b : a and not b)\nprint to_range_list(diff)\n</code>\n</pre>\n", "senID": 6}, {"text": ["And I got the following output:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Which seems to be in agreement with what you would expect.", "Now if you want to do some other boolean operations here is how it would work using the same function:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n #Intersection\nmerge(r1, r2, lambda a, b : a and b)\n\n#Union\nmerge(r1, r2, lambda a, b : a or b)\n\n#Xor\nmerge(r1, r2, lambda a, b : a != b)\n</code>\n</pre>\n", "senID": 9}], [{"text": ["I think I misunderstood the question, but this code works if r2 is a subset of r1"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "r2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "r1", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class RangeSet:\n    def __init__(self, elements):\n        self.ranges = list(elements)\n\n    def __iter__(self):\n        return iter(self.ranges)\n\n    def __repr__(self):\n        return 'RangeSet: %r' % self.ranges\n\n    def has(self, tup):\n        for pos, i in enumerate(self.ranges):\n            if i[0] &lt;= tup[0] and i[1] &gt;= tup[1]:\n                return pos, i\n        raise ValueError('Invalid range or overlapping range')\n\n    def minus(self, tup):\n        pos, (x,y) = self.has(tup)\n        out = []\n        if x &lt; tup[0]:\n            out.append((x, tup[0]-1))\n        if y &gt; tup[1]:\n            out.append((tup[1]+1, y))\n        self.ranges[pos:pos+1] = out\n\n    def __sub__(self, r):\n        r1 = RangeSet(self)\n        for i in r: r1.minus(i)\n        return r1\n\n    def sub(self, r): #inplace subtraction\n        for i in r:\n            self.minus(i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["then, you do:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Update: Note the last interval of r2 is different to work the way I meant."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "r2", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; r1 = RangeSet(((1, 1000), (1100, 1200)))\n&gt;&gt;&gt; r2 = RangeSet([(30, 50), (60, 200), (1150, 1200)])\n&gt;&gt;&gt; r1 - r2\nRangeSet: [(1, 29), (51, 59), (201, 1000), (1100, 1149)]\n&gt;&gt;&gt; r1.sub(r2)\n&gt;&gt;&gt; r1\nRangeSet: [(1, 29), (51, 59), (201, 1000), (1100, 1149)]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Here's a quick python function that does the subtraction, regardless of whether the initial lists are well-formed (i.e.", "turns the lists into the smallest list of equivalent ranges, sorted, before doing the subtraction):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def condense(l):\n    l = sorted(l)\n    temp = [l.pop(0)]\n    for t in l:\n        if t[0] &lt;= temp[-1][1]:\n            t2 = temp.pop()\n            temp.append((t2[0], max(t[1], t2[1])))\n        else:\n            temp.append(t)\n    return temp\n\ndef setSubtract(l1, l2):\n    l1 = condense(l1)\n    l2 = condense(l2)\n    i = 0\n    for t in l2:\n        while t[0] &gt; l1[i][1]:\n            i += 1\n            if i &gt;= len(l1):\n                break\n        if t[1] &lt; l1[i][1] and t[0] &gt; l1[i][0]:\n            #t cuts l1[i] in 2 pieces\n            l1 = l1[:i] + [(l1[i][0], t[0] - 1), (t[1] + 1, l1[i][1])] + l1[i + 1:]\n        elif t[1] &gt;= l1[i][1] and t[0] &lt;= l1[i][0]:\n            #t eliminates l1[i]\n            l1.pop(i)\n        elif t[1] &gt;= l1[i][1]:\n            #t cuts off the top end of l1[i]\n            l1[i] = (l1[i][0], t[0] - 1)\n        elif t[0] &lt;= l1[i][0]:\n            #t cuts off the bottom end of l1[i]\n            l1[i] = (t[1] + 1, l1[i][1])\n        else:\n            print \"This shouldn't happen...\"\n            exit()\n    return l1\n\nr1 = (1, 1000), (1100, 1200)\nr2 = (30, 50), (60, 200), (1150, 1300)\nsetSubtract(r1, r2) #yields [(1, 29), (51, 59), (201, 1000), (1100, 1149)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This was an interesting problem! "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I think this is right, and it's fairly compact.", "It should work with overlapping ranges of all kinds, but it assumes well-formed ranges (i.e.", "[x, y) where x &lt; y).", "It uses [x, y) style ranges for simplicity.", "It's based on the observation that there are really only six possible arrangements (with results in ()):"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "[x, y)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "x &lt; y", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "[x, y)", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Edit: I found a more compact representation:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n (s1 e1)  s2 e2\n(s1 s2)  e1 e2\n(s1 s2) (e2 e1)\n\n s2 e2  (s1 e1)\n s2 s1  (e2 e1)\n s2 s1   e1 e2 ()\n</code>\n</pre>\n", "senID": 3}, {"text": ["Given a sorted list of endpoints, if endpoints[0] == s1 then the first two endpoints should be in the result.", "If endpoints[3] == e1 then the last two endpoints should be in the result.", "If neither, then there should be no result. "], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "endpoints[0] == s1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "endpoints[3] == e1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I haven't tested it a great deal, so it's entirely possible that something is wrong.", "Please let me know if you find a mistake!"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\ndef range_diff(r1, r2):\n    s1, e1 = r1\n    s2, e2 = r2\n    endpoints = sorted((s1, s2, e1, e2))\n    result = []\n    if endpoints[0] == s1:\n        result.append((endpoints[0], endpoints[1]))\n    if endpoints[3] == e1:\n        result.append((endpoints[2], endpoints[3]))\n    return result\n\ndef multirange_diff(r1_list, r2_list):\n    for r2 in r2_list:\n        r1_list = list(itertools.chain(*[range_diff(r1, r2) for r1 in r1_list]))\n    return r1_list\n</code>\n</pre>\n", "senID": 6}, {"text": ["Tested:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; r1_list = [(1, 1001), (1100, 1201)]\n&gt;&gt;&gt; r2_list = [(30, 51), (60, 201), (1150, 1301)]\n&gt;&gt;&gt; print multirange_diff(r1_list, r2_list)\n[(1, 30), (51, 60), (201, 1001), (1100, 1150)]\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Fun question!", "Another implementation, though you already have plenty.", "It was interesting to do!", "Involves some extra 'decoration' to make what I'm doing more explicit."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\ndef flatten_range_to_labeled_points(input_range,label):\n    range_with_labels = [((start,'start_%s'%label),(end,'end_%s'%label)) for (start,end) in input_range]\n    flattened_range = list(reduce(itertools.chain,range_with_labels))\n    return flattened_range \n\ndef unflatten_range_remove_labels(input_range):\n    without_labels = [x for (x,y) in input_range]\n    grouped_into_pairs = itertools.izip(without_labels[::2], without_labels[1::2])\n    return grouped_into_pairs\n\ndef subtract_ranges(range1, range2):\n    range1_labeled = flatten_range_to_labeled_points(range1,1)\n    range2_labeled = flatten_range_to_labeled_points(range2,2)\n    all_starts_ends_together = sorted(range1_labeled + range2_labeled)\n    in_range1, in_range2 = False, False\n    new_starts_ends = []\n    for (position,label) in all_starts_ends_together:\n        if label=='start_1':\n            in_range1 = True\n            if not in_range2:\n                new_starts_ends.append((position,'start'))\n        elif label=='end_1':\n            in_range1 = False\n            if not in_range2:\n                new_starts_ends.append((position,'end'))\n        elif label=='start_2':\n            in_range2 = True\n            if in_range1:\n                new_starts_ends.append((position-1,'end'))\n        elif label=='end_2':\n            in_range2 = False\n            if in_range1:\n                new_starts_ends.append((position+1,'start'))\n    # strip the start/end labels, they're not used, I just appended them for clarity\n    return unflatten_range_remove_labels(new_starts_ends)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I get the right output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n r1 = (1, 1000), (1100, 1200)\nr2 = (30, 50), (60, 200), (1150, 1300)\n&gt;&gt;&gt; subtract_ranges(r1,r2)\n[(1, 29), (51, 59), (201, 1000), (1100, 1149)]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["this is rather ugly but it does work for the given example"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def minus1(a,b):\n    if (b[0] &lt; a[0] and b[1] &lt; a[0]) or (a[1] &lt; b[0] and a[1] &lt; b[1]):\n        return [a] # doesn't overlap\n    if a[0]==b[0] and a[1]==b[1]:\n        return [] # overlaps exactly\n    if b[0] &lt; a[0] and a[1] &lt; b[1]:\n        return [] # overlaps completely\n    if a[0]==b[0]:\n        return [(b[1]+1,a[1])] # overlaps exactly on the left\n    if a[1]==b[1]:\n        return [(a[0],b[0]-1)] # overlaps exactly on the right \n    if a[0] &lt; b[0] and b[0] &lt; a[1] and a[1] &lt; b[1]:\n        return [(a[0],b[0]-1)] # overlaps the end\n    if a[0] &lt; b[1] and b[1] &lt; a[1] and b[0] &lt; a[0]:\n        return [(b[1]+1,a[1])] # overlaps the start\n    else:\n        return [(a[0],b[0]-1),(b[1]+1,a[1])] # somewhere in the middle\n\ndef minus(r1, r2):\n    # assume r1 and r2 are already sorted\n    r1 = r1[:]\n    r2 = r2[:]\n    l = []\n    v = r1.pop(0)\n    b = r2.pop(0)\n    while True:\n        r = minus1(v,b)\n        if r:\n            if len(r)==1:\n                if r[0] == v:\n                    if v[1] &lt; b[0] and v[1] &lt; b[1]:\n                        l.append(r[0])\n                        if r1:\n                            v = r1.pop(0)\n                        else:\n                            break\n                    else:\n                        if r2:\n                            b = r2.pop(0)\n                        else:\n                            break\n                else:\n                    v = r[0]\n            else:\n                l.append(r[0])\n                v = r[1]\n                if r2:\n                    b = r2.pop(0)\n                else:\n                    l.append(v)\n                    break\n        else:\n            if r1:\n                v = r1.pop(0)\n            else:\n                break\n            if r2:\n                b = r2.pop(0)\n            else:\n                l.append(v)\n                l.extend(r1)\n                break\n    return l\n\nr1 = [(1, 1000), (1100, 1200)]\nr2 = [(30, 50), (60, 200), (1150, 1300)]\n\nprint minus(r1,r2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [(1, 29), (51, 59), (201, 1000), (1100, 1149)]\n</code>\n</pre>\n", "senID": 3}]]