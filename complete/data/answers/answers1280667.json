[[{"text": ["If you're frequently iterating over a Cartesian product like in your example, you might want to investigate Python 2.6's itertools.product -- or write your own if you're in an earlier Python."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python 2.6's itertools.product", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.product"}]}, {"code": "<pre>\n<code>\n from itertools import product\nfor y, x in product(range(3), repeat=2):\n  do_something()\n  for y1, x1 in product(range(3), repeat=2):\n    do_something_else()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["When faced with that sort of program logic, I would probably break up the sequence of loops into two or more separate functions."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Another technique in Python is to use list comprehensions where possible, instead of a loop."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "list comprehensions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions"}]}], [{"text": ["This is fairly common when looping over multidimensional spaces.", "My solution is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n xy_grid = [(x, y) for x in range(3) for y in range(3)]\n\nfor x, y in xy_grid:\n    # do something\n    for x1, y1 in xy_grid:\n        # do something else\n</code>\n</pre>\n", "senID": 1}], [{"text": ["My personal argument would be that you're likely doing something wrong if you have 6 nested loops..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That said, functional decomposition is what you're looking for.", "Refactor so some of the loops happen in seperate function calls, then call those functions."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Assuming each loop has some sort of independent meaning, break them out into named functions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def do_tigers():\n    for x in range(3):\n        print something\n\ndef do_lions():\n    do_lionesses()\n    for x in range(3):\n        do_tigers()\n\ndef do_penguins():\n    for x in range(3):\n        do_lions()\n\n..etc.\n</code>\n</pre>\n", "senID": 1}, {"text": ["I could perhaps have chosen better names.", "8-)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Technically, you could use itertools.product to get a cartesian product of N sequences, and iterate over that:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.product", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for y, x, y1, x1 in itertools.product(range(3), repeat=4):\n   do_something_else()\n</code>\n</pre>\n", "senID": 1}, {"text": ["But I don't think that actually wins you anything readability-wise."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Python iterators, and generators in particular, exist exactly to allow the nice refactoring of otherwise-complicated loops.", "Of course, it's hard to get an abstraction out from a simple example, but assuming the 3 needs to be a parameter (maybe the whole range(3) should be?", "), and the two functions you're calling need some parameters that are loop variables, you could refactor the code:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "3", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "range(3)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n for y in range(3):\n    for x in range(3):\n      do_something(x, y)\n      for y1 in range(3):\n        for x1 in range(3):\n          do_something_else(x, y, x1, y1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["into, e.g."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def nestloop(n, *funcs):\n  head = funcs[0]\n  tail = funcs[1:]\n  for y in range(n):\n    for x in range(n):\n      yield head, x, y\n      if tail:\n        for subtup in nestloop(n, *tail):\n           yield subtup[:1] + (x, y) + subtup[1:]\n\nfor funcandargs in nestloop(3, do_something, do_something_else):\n  funcandargs[0](*funcandargs[1:])\n</code>\n</pre>\n", "senID": 3}, {"text": ["The exact kind of refactoring will no doubt need to be tweaked for your exact purposes, but the general point that iterators (and usually in fact just simple generators) afford very nice refactorings of loops remains -- all the looping logic goes inside the generator, and the application-level code is left with simple for loops and actual application-relevant processing of the items yielded in the for loops."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Have you looked into List Comprehensions?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "List Comprehensions?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions"}]}, {"text": ["Something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n [do_something() for x in range(3) for y in range(3)]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["That way looks pretty straightforward and easy.", "Are you are saying you want to generalize to multiple layers of loops.... can you give a real-life example?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Another option I could think of would be to use a function to generate the parameters and then just apply them in a loop"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def generate_params(n):\n    return itertools.product(range(n), range(n))\n\nfor x,y in generate_params(3):\n    do_something()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["you can also use the map() function "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "map()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html"}, {"href": "http://en.wikipedia.org/wiki/Map%5F%28higher-order%5Ffunction%29", "text": "function", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["From your code it looks like you want to perform an operation with every possible pair of points where x and y are in the range 0..2."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To do that:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for x1,y1,x2,y2 in itertools.product(range(3), repeat=4):\n    do_something_with_two_points(x1,y1,2,y2)\n</code>\n</pre>\n", "senID": 2}, {"text": ["The operation do_something_with_two_points will be called 81 times - once for every possible combination of points.   "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "do_something_with_two_points", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]