[[{"text": ["Why not use python pickle?", "Python has a great serializing module called pickle it is very easy to use."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "python pickle", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/pickle.html"}]}, {"code": "<pre>\n<code>\n import cPickle\ncPickle.dump(obj, open('save.p', 'wb')) \nobj = cPickle.load(open('save.p', 'rb'))\n</code>\n</pre>\n", "senID": 1}, {"text": ["There are two disadvantages with pickle:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "It's not secure against erroneous or\nmaliciously constructed data. Never\nunpickle data received from an\nuntrusted or unauthenticated source.", "tag": "none", "senID": 3}, {"text": "The format is not human readable.", "tag": "none", "senID": 4}]}, {"text": ["If you are using python 2.6 there is a builtin module called json.", "It is as easy as pickle to use:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "json", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/json.html"}]}, {"code": "<pre>\n<code>\n import json\nencoded = json.dumps(obj)\nobj = json.loads(encoded)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Json format is human readable and is very similar to the dictionary string representation in python.", "And doesn't have any security issues like pickle.", "But might be slower than cPickle."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I'd use shelve, json, yaml, or whatever, as suggested by other answers. "], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "shelve", "tag": "a", "pos": 0, "childList": [{"text": "shelve", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/shelve.html"}, {"text": "shelve", "childNum": 0, "tag": "code", "childList": []}, {"text": "json", "childNum": 0, "tag": "code", "childList": []}, {"text": "yaml", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["shelve is specially cool because you can have the dict on disk and still use it.", "Values will be loaded on-demand."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "shelve", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["But if you really want to parse the text of the dict, and it contains only strings, ints and tuples like you've shown, you can use ast.literal_eval to parse it.", "It is a lot safer, since you can't eval full expressions with it - It only works with strings, numbers, tuples, lists, dicts, booleans, and None:"], "childNum": 12, "tag": "p", "senID": 2, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/ast.html#ast.literal%5Feval", "text": "ast.literal_eval", "childNum": 1, "tag": "a", "childList": [{"text": "ast.literal_eval", "tag": "code"}]}, {"text": "ast.literal_eval", "childNum": 0, "tag": "code", "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "bool", "childNum": 0, "tag": "code", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import ast\n&gt;&gt;&gt; print ast.literal_eval(\"{12: 'mydict', 14: (1, 2, 3)}\")\n{12: 'mydict', 14: (1, 2, 3)}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I would suggest that you use YAML for your file format so you can tinker with it on the disc"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "YAML", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.yaml.org/"}]}, {"code": "<pre>\n<code>\n How does it look:\n  - It is indent based\n  - It can represent dictionaries and lists\n  - It is easy for humans to understand\nAn example: This block of code is an example of YAML (a dict holding a list and a string)\nFull syntax: http://www.yaml.org/refcard.html\n</code>\n</pre>\n", "senID": 1}, {"text": ["To get it in python, just easy_install pyyaml.", "See http://pyyaml.org/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://pyyaml.org/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pyyaml.org/"}]}, {"text": ["It comes with easy file save / load functions, that I can't remember right this minute."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I would use ZODB if you need a dict too large to fit into memory to be persistent. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ZODB", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Zope%5FObject%5FDatabase"}]}], [{"text": ["Write it out in a serialized format, such as pickle (a python standard library module for serialization) or perhaps by using JSON (which is a representation that can be evaled to produce the memory representation again)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["This solution at SourceForge uses only standard Python modules:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["y_serial.py module :: warehouse Python objects with SQLite"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["\"Serialization + persistance :: in a few lines of code, compress and annotate Python objects into SQLite; then later retrieve them chronologically by keywords without any SQL.", "Most useful \"standard\" module for a database to store schema-less data."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://yserial.sourceforge.net"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://yserial.sourceforge.net", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://yserial.sourceforge.net"}]}, {"text": ["The compression bonus will probably reduce your 6GB dictionary to 1GB.", "If you do not want a store a series of dictionaries, the module also contains a file.gz solution which might be more suitable given your dictionary size."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You can also write simple data structures in human- and Python-readable form with repr.", "The inverse operation is eval:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "repr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "eval", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n x = {1: (2, 3, 'four')}\nprint repr(x)\nprint eval(repr(x), {})\n</code>\n</pre>\n", "senID": 1}, {"text": ["Some caveats:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "eval is vulnerable to code injection attacks, since it runs arbitrary Python code passed to it.", "tag": "none", "senID": 3}, {"text": "for some data types, repr emits a string, which eval cannot read.", "tag": "none", "senID": 4}]}]]