[[{"code": "<pre>\n<code>\n data = [1,2,3]\nresult = [ data[i:] for i in range(len(data)) ]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Return seqs:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n user&gt; (take-while seq (iterate rest [1 2 3]))\n([1 2 3] (2 3) (3))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Return vectors:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n user&gt; (take-while seq (iterate #(subvec % 1) [1 2 3]))\n([1 2 3] [2 3] [3])\n</code>\n</pre>\n", "senID": 3}, {"text": ["I've seen this pattern packaged up into an iterate-while function, which is pretty much the same as your nest function:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "iterate-while", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "nest", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n (defn iterate-while [pred f x]\n  (take-while pred (iterate f x)))\n</code>\n</pre>\n", "senID": 5}, {"text": ["Note that (seq x) is equivalent to, and preferred over, (not (empty?", "x))"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "(seq x)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(not (empty? x))", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Maybe something like this (the first thing that came to my mind, and I haven't been doing clojure recently, so it might not be the best solution):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (take-while identity (iterate next [1 2 3]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Update:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This solution Justin suggested is preferable (shorter, [] input, etc.", "):"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "[]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n (take-whil\u00ade seq (iter\u00adate rest ...))\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n user&gt; (reductions conj [] [1 2 3])\n([] [1] [1 2] [1 2 3])\n</code>\n</pre>\n", "senID": 0}, {"text": ["Gets you the empty version as well.", "If you want, you can instead do"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n user&gt; (take-while identity (iterate next [1 2 3]))\n([1 2 3] (2 3) (3))\n</code>\n</pre>\n", "senID": 2}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n user&gt; (rest (reductions conj [] [1 2 3]))\n([1] [1 2] [1 2 3])\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n (partition-all 3 1 [1 2 3])\n</code>\n</pre>\n", "senID": 0}, {"text": ["yields "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n ((1 2 3) (2 3) (3))\n</code>\n</pre>\n", "senID": 2}, {"text": ["if you want it in a vector format"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n (vec (map vec (partition-all 3 1 [1 2 3])))\n</code>\n</pre>\n", "senID": 4}, {"text": ["p.s.", "the 3 and the 1 in partition-all prior to the [1 2 3] define that the vector should be partitioned in groups of 3, with a stepsize of 1, and are not part of the input vector.", "I use partition-all instead of partition, because partition-all doesn't mind about groups being shorter than the specified length of 3."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f(l):\n    while l:\n        yield l[:]\n        l.pop(0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The copy ([:]) depends on whether you want a copy of the list or you are OK with modifying it in place.", "If you only need one of the sublists at a time, it may be faster to remove the copy and iterate over f."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "[:]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Note also that a list is not the best data structure for this."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]