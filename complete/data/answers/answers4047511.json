[[{"text": ["First, try to avoid code like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if Action():\n    lots of code\n    return True\nreturn False\n</code>\n</pre>\n", "senID": 1}, {"text": ["Flip it around, so the bulk of code isn't nested.", "This gives us:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def check(isbn):\n    check_digit = int(isbn[-1])\n    match = re.search(r'(\\d)-(\\d{3})-(\\d{5})', isbn[:-1])\n\n    if not match:\n        return False\n\n    digits = match.group(1) + match.group(2) + match.group(3)\n    result = 0\n\n    for i, digit in enumerate(digits):\n      result += (i + 1) * int(digit)\n\n    return True if (result % 11) == check_digit else False\n</code>\n</pre>\n", "senID": 3}, {"text": ["There are some bugs in the code:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "If the check digit isn't an integer, this will raise ValueError instead of returning False: \"0-123-12345-Q\".", "tag": "none", "senID": 5}, {"text": "If the check digit is 10 (\"X\"), this will raise ValueError instead of returning True.", "tag": "none", "senID": 6}, {"text": "This assumes that the ISBN is always grouped as \"1-123-12345-1\".  That's not the case; ISBNs are grouped arbitrarily.  For example, the grouping \"12-12345-12-1\" is valid.  See ", "tag": "none", "senID": 7}, {"text": "This assumes the ISBN is grouped by hyphens.  Spaces are also valid.", "tag": "none", "senID": 8}, {"text": "It doesn't check that there are no extra characters; '0-123-4567819' returns True, ignoring the extra 1 at the end.", "tag": "none", "senID": 9}]}, {"text": ["So, let's simplify this.", "First, remove all spaces and hyphens, and make sure the regex matches the whole line by bracing it in '^...$'.", "That makes sure it rejects strings which are too long."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n def check(isbn):\n    isbn = isbn.replace(\"-\", \"\").replace(\" \", \"\");\n    check_digit = int(isbn[-1])\n    match = re.search(r'^(\\d{9})$', isbn[:-1])\n    if not match:\n        return False\n\n    digits = match.group(1)\n\n    result = 0\n    for i, digit in enumerate(digits):\n      result += (i + 1) * int(digit)\n\n    return True if (result % 11) == check_digit else False\n</code>\n</pre>\n", "senID": 11}, {"text": ["Next, let's fix the \"X\" check digit problem.", "Match the check digit in the regex as well, so the entire string is validated by the regex, then convert the check digit correctly."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n def check(isbn):\n    isbn = isbn.replace(\"-\", \"\").replace(\" \", \"\").upper();\n    match = re.search(r'^(\\d{9})(\\d|X)$', isbn)\n    if not match:\n        return False\n\n    digits = match.group(1)\n    check_digit = 10 if match.group(2) == 'X' else int(match.group(2))\n\n    result = 0\n    for i, digit in enumerate(digits):\n      result += (i + 1) * int(digit)\n\n    return True if (result % 11) == check_digit else False\n</code>\n</pre>\n", "senID": 13}, {"text": ["Finally, using a generator expression and max is a more idiomatic way of doing the final calculation in Python, and the final conditional can be simplified."], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "max", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def check(isbn):\n    isbn = isbn.replace(\"-\", \"\").replace(\" \", \"\").upper();\n    match = re.search(r'^(\\d{9})(\\d|X)$', isbn)\n    if not match:\n        return False\n\n    digits = match.group(1)\n    check_digit = 10 if match.group(2) == 'X' else int(match.group(2))\n\n    result = sum((i + 1) * int(digit) for i, digit in enumerate(digits))\n    return (result % 11) == check_digit\n</code>\n</pre>\n", "senID": 15}], [{"text": ["Pointless improvement: replace return True if (result % 11) == check_digit else False with return (result % 11) == check_digit"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "return True if (result % 11) == check_digit else False", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return (result % 11) == check_digit", "childNum": 0, "tag": "code", "childList": []}]}], [{"tag": "ul", "num": 5, "lis": [{"text": "The ", "tag": "none", "senID": 0}, {"text": "Instead of search, you should probably use match, unless you want to allow arbitrary junk as the prefix. (Also, as a rule of thumb I'd anchor the end with ", "tag": "none", "senID": 1}, {"text": "Instead of manually listing the groups, you could just use ", "tag": "none", "senID": 2}, {"text": "your for loop could be replaced by a list/generator comprehension. Just use ", "tag": "none", "senID": 3}, {"text": ["True if (expression) else False"], "childNum": 0, "tag": "code", "senID": 4, "childList": []}]}, {"text": ["Putting that all together:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def check(isbn):\n    match = re.match(r'(\\d)-(\\d{3})-(\\d{5})-(\\d)$', isbn)\n    if match:\n        digits = [int(x) for x in ''.join(match.groups())]\n        check_digit = digits.pop()\n        return check_digit == sum([(i + 1) * digit\n                                  for i, digit in enumerate(digits)]) % 11\n    return False\n</code>\n</pre>\n", "senID": 6}, {"text": ["The last line is arguably unnecessary, as the default behavior would be to return None (which is falsy), but explicit returns from some paths and not from others looks like a bug to me, so I think it's more readable to leave it in."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["All that regex stuff is great if you belong to the isbn.org compliance inspectorate."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "All that regex stuff is great if you belong to the isbn.org compliance inspectorate.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["However, if you want to know if what the potential customers type into their browser is worth pushing into a query of your database of books for sale, you don't want all that nice red uniform caper.", "Simply throw away everything but 0-9 and X ... oh yeah nobody uses the shift key so we'd better allow x as well.", "Then if it's length 10 and passes the check-digit test, it's worth doing the query."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["From http://www.isbn.org/standards/home/isbn/international/html/usm4.htm"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.isbn.org/standards/home/isbn/international/html/usm4.htm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.isbn.org/standards/home/isbn/international/html/usm4.htm"}]}, {"text": ["which is a very long-winded way of saying \"each of all the digits is multiplied by a number ranging from 10 to 1 and that the resulting sum of the products must be divisible by 11 without a remainder\""], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def isbn10_ok(s):\n    data = [c for c in s if c in '0123456789Xx']\n    if len(data) != 10: return False\n    if data[-1] in 'Xx': data[-1] = 10\n    try:\n        return not sum((10 - i) * int(x) for i, x in enumerate(data)) % 11\n    except ValueError:\n        # rare case: 'X' or 'x' in first 9 \"digits\"\n        return False\n\n\ntests = \"\"\"\\\n    3-528-03851\n    3-528-16419-0\n    ISBN 0-8436-1072-7\n    0864425244\n    1864425244\n    0864X25244\n    1 904310 16 8\n    0-473-07480-x\n    0-473-07480-X\n    0-473-07480-9\n    0-473-07480-0\n    123456789\n    12345678901\n    1234567890\n    0000000000\n    \"\"\".splitlines()\n\nfor test in tests:\n    test = test.strip()\n    print repr(test), isbn10_ok(test)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n '3-528-03851' False\n'3-528-16419-0' True\n'ISBN 0-8436-1072-7' True\n'0864425244' True\n'1864425244' False\n'0864X25244' False\n'1 904310 16 8' True\n'0-473-07480-x' True\n'0-473-07480-X' True\n'0-473-07480-9' False\n'0-473-07480-0' False\n'123456789' False\n'12345678901' False\n'1234567890' False\n'0000000000' True\n'' False\n</code>\n</pre>\n", "senID": 6}, {"text": ["Aside: a large well-known bookselling site will accept 047307480x, 047307480X, and 0-473-07480-X but not 0-473-07480-x :-O"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": ":-O", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["check this after you have finished ok :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.staff.ncl.ac.uk/d.j.wilkinson/software/isbn.py"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.staff.ncl.ac.uk/d.j.wilkinson/software/isbn.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.staff.ncl.ac.uk/d.j.wilkinson/software/isbn.py"}]}, {"text": ["and"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://chrisrbennett.com/2006/11/isbn-check-methods.html"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://chrisrbennett.com/2006/11/isbn-check-methods.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://chrisrbennett.com/2006/11/isbn-check-methods.html"}]}, {"text": ["EDIT : Sorry about the confusing i didn't see the homework tag but maybe after finishing your homework you can see what other have done before, i think you can learn a lot from others code ; sorry again :("], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "EDIT :", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Your code is nice -- well done for writing idiomatic Python!", "Here are some minor things:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When you see the idiom"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n result = &lt;initiator&gt;\nfor elt in &lt;iterable&gt;:\n    result += elt\n</code>\n</pre>\n", "senID": 2}, {"text": ["you can replace it by a list comprehension.", "In this case:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n result = sum((i+1)*int(digit) for i, digit in enumerate(digits)\n</code>\n</pre>\n", "senID": 4}, {"text": ["or even more concisely:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n return sum((i+1)*int(digit) for i, digit in enumerate(digits) % 11 == check_digit\n</code>\n</pre>\n", "senID": 6}, {"text": ["Of course, it is a value judgement whether this is better than the original.", "I would personally consider the second of these to be best."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Also, the extra parentheses in (result % 11) == check_digit are extraneous and I don't really think you need them for clarity.", "That leaves you overall with:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "(result % 11) == check_digit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def validate(isbn):\n    check_digit = int(isbn[-1])\n    match = re.search(r'(\\d)-(\\d{3})-(\\d{5})', isbn[:-1])\n\n    if match:\n        digits = match.group(1) + match.group(2) + match.group(3)\n        parity = sum((i+1)*int(digit) for i, digit in enumerate(digits)\n        return parity % 11 == check_digit\n    else:\n        return False\n</code>\n</pre>\n", "senID": 9}, {"text": ["Note that you do still need the return False to catch the case that the ISBN is not even in the right format."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "return False", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Don't forget (though this may be outside of the scope of your assignment) to calculate the check digit of the ISBN (the final digit), to determine if the ISBN is valid and not just seemingly valid."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "valid", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "seemingly valid", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["There's some information about the implementation of the check digit on the ISBN.org website, and implementation should be fairly straightforward.", "Wikipedia offers one such example (presuming you've already converted any ASCII \"X\" to a decimal 10):"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "on the ISBN.org website", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.isbn.org/standards/home/isbn/international/html/usm4.htm"}, {"text": "Wikipedia", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/International_Standard_Book_Number"}]}, {"code": "<pre>\n<code>\n bool is_isbn_valid(char digits[10]) {\n    int i, a = 0, b = 0;\n    for (i = 0; i &lt; 10; i++) {\n        a += digits[i];  // Assumed already converted from ASCII to 0..10\n        b += a;\n    }\n    return b % 11 == 0;\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["Applying this for your assignment is left, well, as an exercise for you."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Your check digit can take on the values 0-10, based on the fact that it's modulo-11.", "There's a problem with the line:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n check_digit = int(isbn[-1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["as this works only for the digits 0-9.", "You'll need something for the case when the digit is 'X', and also for the error condition when it isn't any of the above - otherwise your program will crash."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]