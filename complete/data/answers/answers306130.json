[[{"text": ["Claudiu's answer is correct, but you can also cheat by getting the class name off of the self argument.", "This will give misleading log statements in cases of inheritance, but will tell you the class of the object whose method is being called.", "For example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from functools import wraps  # use this to preserve function signatures and docstrings\ndef logger(func):\n    @wraps(func)\n    def with_logging(*args, **kwargs):\n        print \"Entering %s.%s\" % (args[0].__class__.__name__, func.__name__)\n        return func(*args, **kwargs)\n    return with_logging\n\nclass C(object):\n    @logger\n    def f(self):\n        pass\n\nC().f()\n</code>\n</pre>\n", "senID": 1}, {"text": ["As I said, this won't work properly in cases where you've inherited a function from a parent class; in this case you might say"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class B(C):\n    pass\n\nb = B()\nb.f()\n</code>\n</pre>\n", "senID": 3}, {"text": ["and get the message Entering B.f where you actually want to get the message Entering C.f since that's the correct class.", "On the other hand, this might be acceptable, in which case I'd recommend this approach over Claudiu's suggestion."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "Entering B.f", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Entering C.f", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Functions only become methods at runtime.", "That is, when you get C.f you get a bound function (and C.f.im_class is C).", "At the time your function is defined it is just a plain function, it is not bound to any class.", "This unbound and disassociated function is what is decorated by logger."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "C.f", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "C.f.im_class is C", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["self.__class__.__name__ will give you the name of the class, but you can also use descriptors to accomplish this in a somewhat more general way.", "This pattern is described in a blog post on Decorators and Descriptors, and an implementation of your logger decorator in particular would look like:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "self.__class__.__name__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "in a blog post on Decorators and Descriptors", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://blog.ianbicking.org/2008/10/24/decorators-and-descriptors/"}]}, {"code": "<pre>\n<code>\n class logger(object):\n    def __init__(self, func):\n        self.func = func\n    def __get__(self, obj, type=None):\n        return self.__class__(self.func.__get__(obj, type))\n    def __call__(self, *args, **kw):\n        print 'Entering %s' % self.func\n        return self.func(*args, **kw)\n\nclass C(object):\n    @logger\n    def f(self, x, y):\n        return x+y\n\nC().f(1, 2)\n# =&gt; Entering &lt;bound method C.f of &lt;__main__.C object at 0x...&gt;&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["Obviously the output can be improved (by using, for example, getattr(self.func, 'im_class', None)), but this general pattern will work for both methods and functions.", "However it will not work for old-style classes (but just don't use those ;)"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "getattr(self.func, 'im_class', None)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["Class functions should always take self as their first argument, so you can use that instead of im_class."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def logger(myFunc):\n    def new(self, *args, **keyargs):\n        print 'Entering %s.%s' % (self.__class__.__name__, myFunc.__name__)\n        return myFunc(self, *args, **keyargs)\n\n    return new \n\nclass C(object):\n    @logger\n    def f(self):\n        pass\nC().f()\n</code>\n</pre>\n", "senID": 1}, {"text": ["at first I wanted to use self.__name__ but that doesn't work because the instance has no name.", "you must use self.__class__.__name__ to get the name of the class."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "self.__name__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self.__class__.__name__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["It seems that while the class is being created, Python creates regular function objects.", "They only get turned into unbound method objects afterwards.", "Knowing that, this is the only way I could find to do what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def logger(myFunc):\n    def new(*args, **keyargs):\n        print 'Entering %s.%s' % (myFunc.im_class.__name__, myFunc.__name__)\n        return myFunc(*args, **keyargs)\n\n    return new\n\nclass C(object):\n    def f(self):\n        pass\nC.f = logger(C.f)\nC().f()\n</code>\n</pre>\n", "senID": 1}, {"text": ["This outputs the desired result."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you want to wrap all the methods in a class, then you probably want to create a wrapClass function, which you could then use like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n C = wrapClass(C)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Ideas proposed here are excelent, but have some disadvantages:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So, I've combined some ideas from this page, links, docs and own head, and found a solution, that lacks all three disadvantages above."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Full module with self-tests can be downloaded from direct link: http://denis.ryzhkov.org/soft/python_lib/method_decorator.py"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://denis.ryzhkov.org/soft/python_lib/method_decorator.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://denis.ryzhkov.org/soft/python_lib/method_decorator.py"}]}, {"text": ["And here is just decorator class with docstring:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class method_decorator( object ):\n\n    '''\n    Abstract decorator that knows details about method, e.g. class where method is bound, that is None if method is plain function.\n    Also hides decorator traces by answering to system attributes more correctly than functools.wraps() does.\n    Tested with: instance-methods, class-methods, static-methods, and plain functions.\n    Inherit and override any behaviour.\n\n    Usage:\n        class my_dec( method_decorator ):\n            def __call__( self, *args, **kwargs ):\n\n                print( 'Calling %(method_type)s %(method_name)s from instance %(instance)s class %(class_name)s from module %(module_name)s with args %(args)s and kwargs %(kwargs)s.' % dict(\n                    method_type=self.method_type,\n                    method_name=self.__name__,\n                    instance=self.obj,\n                    class_name=( self.cls.__name__ if self.cls else None ),\n                    module_name=self.__module__,\n                    args=args,\n                    kwargs=kwargs,\n                ))\n\n                return method_decorator.__call__( self, *args, **kwargs )\n        @my_dec\n        def func_or_method( ...\n    '''\n\n    def __init__( self, func, obj=None, cls=None, method_type='function' ): # defaults are ok for plain functions, and will be changed by __get__ for methods\n        self.func, self.obj, self.cls, self.method_type = func, obj, cls, method_type\n\n    def __get__( self, obj=None, cls=None ): # is called as method: Cls.func or obj.func\n        if self.obj == obj and self.cls == cls: return self # use same instance, if it was already switched by previous __get__\n\n        if isinstance( self.func, staticmethod ): method_type = 'staticmethod' # later __get__ unwraps staticmethod object to plain function\n        elif isinstance( self.func, classmethod ): method_type = 'classmethod' # later Cls.classm is same as Cls.instancem( obj,..\n        else: method_type = 'instancemethod' # can't rely on obj in call like Cls.instancem( obj,..\n\n        return object.__getattribute__( self, '__class__' )( # use specialized decorator instance, don't change current instance attributes - it leads to conflicts\n            self.func.__get__( obj, cls ), obj, cls, method_type ) # use func's method version, [un]bound to [None-able] obj and cls.\n\n    def __call__( self, *args, **kwargs ):\n        return self.func( *args, **kwargs )\n\n    def __getattribute__( self, attr_name ): # hiding traces\n        if attr_name in ( '__init__', '__get__', '__call__', '__getattribute__', 'func', 'obj', 'cls', 'method_type' ): # our known names, our '__class__' is used only once with explicit object.__getattribute__\n            return object.__getattribute__( self, attr_name ) # stopping recursion\n        # all other attr_names, that can be auto-defined by system in self, and all others, are searched in self.func, e.g.: __module__, __class__, __name__, __doc__, im_*, func_*, etc.\n        return getattr( self.func, attr_name ) # raises AttributeError if name not found in self.func\n\n    def __repr__( self ): # ignores __getattribute__\n        return self.func.__repr__()\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I found another solution to a very similar problem using the inspect library.", "When the decorator is called, even though the function is not yet bound to the class, you can inspect the stack and discover which class is calling the decorator.", "You can at least get the string name of the class, if that is all you need (probably can't reference it yet since it is being created).", "Then you do not need to call anything after the class has been created."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "inspect", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import inspect\n\ndef logger(myFunc):\n    classname = inspect.getouterframes(inspect.currentframe())[1][3]\n    def new(*args, **keyargs):\n        print 'Entering %s.%s' % (classname, myFunc.__name__)\n        return myFunc(*args, **keyargs)\n    return new\n\nclass C(object):\n    @logger\n    def f(self):\n        pass\n\nC().f()\n</code>\n</pre>\n", "senID": 1}, {"text": ["While this is not necessarily better than the others, it is the only way I can figure out to discover the class name of the future method during the call to the decorator.", "Make note of not keeping references to frames around in the inspect library documentation."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "better", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "only", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "inspect", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You can also use new.instancemethod() to create an instance method (either bound or unbound) from a function."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "new.instancemethod()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]