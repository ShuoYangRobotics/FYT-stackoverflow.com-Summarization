[[{"text": ["One way to do things like this is to preprocess the source and modify it, translating your added statement to python.", "There are various problems this approach will bring, and I wouldn't recommend it for general usage, but for experimentation with language, or specific-purpose metaprogramming, it can occassionally be useful."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For instance, lets say we want to introduce a \"myprint\" statement, that instead of printing to the screen instead logs to a specific file.", "ie:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n myprint \"This gets logged to file\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["would be equivalent to"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n print &gt;&gt;open('/tmp/logfile.txt','a'), \"This gets logged to file\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["There are various options as to how to do the replacing, from regex substitution to generating an AST, to writing your own parser depending on how close your syntax matches existing python.", "A good intermediate approach is to use the tokenizer module.", "This should allow you to add new keywords, control structures etc while interpreting the source similarly to the python interpreter, thus avoiding the breakage crude regex solutions would cause.", "For the above \"myprint\", you could write the following transformation code:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import tokenize\n\nLOGFILE = '/tmp/log.txt'\ndef translate(readline):\n    for type, name,_,_,_ in tokenize.generate_tokens(readline):\n        if type ==tokenize.NAME and name =='myprint':\n            yield tokenize.NAME, 'print'\n            yield tokenize.OP, '&gt;&gt;'\n            yield tokenize.NAME, \"open\"\n            yield tokenize.OP, \"(\"\n            yield tokenize.STRING, repr(LOGFILE)\n            yield tokenize.OP, \",\"\n            yield tokenize.STRING, \"'a'\"\n            yield tokenize.OP, \")\"\n            yield tokenize.OP, \",\"\n        else:\n            yield type,name\n</code>\n</pre>\n", "senID": 6}, {"text": ["(This does make myprint effectively a keyword, so use as a variable elsewhere will likely cause problems)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["The problem then is how to use it so that your code is usable from python.", "One way would just be to write your own import function, and use it to load code written in your custom language.", "ie:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n import new\ndef myimport(filename):\n    mod = new.module(filename)\n    f=open(filename)\n    data = tokenize.untokenize(translate(f.readline))\n    exec data in mod.__dict__\n    return mod\n</code>\n</pre>\n", "senID": 9}, {"text": ["This requires you handle your customised code differently from normal python modules however.", "ie \"some_mod = myimport(\"some_mod.py\")\" rather than \"import some_mod\""], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "some_mod = myimport(\"some_mod.py\")", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "import some_mod", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Another fairly neat (albeit hacky) solution is to create a custom encoding (See PEP 263) as this recipe demonstrates.", "You could implement this as:"], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "PEP 263", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0263/"}, {"text": "this", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/546539/"}]}, {"code": "<pre>\n<code>\n import codecs, cStringIO, encodings\nfrom encodings import utf_8\n\nclass StreamReader(utf_8.StreamReader):\n    def __init__(self, *args, **kwargs):\n        codecs.StreamReader.__init__(self, *args, **kwargs)\n        data = tokenize.untokenize(translate(self.stream.readline))\n        self.stream = cStringIO.StringIO(data)\n\ndef search_function(s):\n    if s!='mylang': return None\n    utf8=encodings.search_function('utf8') # Assume utf8 encoding\n    return codecs.CodecInfo(\n        name='mylang',\n        encode = utf8.encode,\n        decode = utf8.decode,\n        incrementalencoder=utf8.incrementalencoder,\n        incrementaldecoder=utf8.incrementaldecoder,\n        streamreader=StreamReader,\n        streamwriter=utf8.streamwriter)\n\ncodecs.register(search_function)\n</code>\n</pre>\n", "senID": 12}, {"text": ["Now after this code gets run (eg.", "you could place it in your .pythonrc or site.py) any code starting with the comment \"# coding: mylang\" will automatically be translated through the above preprocessing step.", "eg."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n # coding: mylang\nmyprint \"this gets logged to file\"\nfor i in range(10):\n    myprint \"so does this : \", i, \"times\"\nmyprint (\"works fine\" \"with arbitrary\" + \" syntax\" \n  \"and line continuations\")\n</code>\n</pre>\n", "senID": 14}, {"text": ["Caveats:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["There are problems to the preprocessor approach, as you'll probably be familiar with if you've worked with the C preprocessor.", "The main one is debugging.", "All python sees is the preprocessed file which means that text printed in the stack trace etc will refer to that.", "If you've performed significant translation, this may be very different from your source text.", "The example above doesn't change line numbers etc, so won't be too different, but the more you change it, the harder it will be to figure out."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}], [{"text": ["Short of changing and recompiling the source code (which is possible with open source), changing the base language is not really possible."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "is", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Even if you do recompile the source, it wouldn't be python, just your hacked-up changed version which you need to be very careful not to introduce bugs into."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["However, I'm not sure why you'd want to.", "Python's object-oriented features makes it quite simple to achieve similar results with the language as it stands."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Yes, to some extent it is possible.", "There is a module out there that uses sys.settrace() to implement goto and comefrom \"keywords\":"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "module", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://entrian.com/goto/"}, {"text": "sys.settrace()", "childNum": 0, "tag": "code", "childList": []}, {"text": "goto", "childNum": 0, "tag": "code", "childList": []}, {"text": "comefrom", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from goto import goto, label\nfor i in range(1, 10):\n  for j in range(1, 20):\n    print i, j\n    if j == 3:\n      goto .end # breaking out from nested loop\nlabel .end\nprint \"Finished\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I've found a guide on adding new statements, converted from PDF to HTML by Google:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://209.85.173.104/search?q=cache:IjUb82taSq0J:www.troeger.eu/teaching/pythonvm08lab.pdf+python+add+statement&amp;hl=en&amp;ct=clnk&amp;cd=10"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://209.85.173.104/search?q=cache:IjUb82taSq0J:www.troeger.eu/teaching/pythonvm08lab.pdf+python+add+statement&amp;hl=en&amp;ct=clnk&amp;cd=10", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://209.85.173.104/search?q=cache:IjUb82taSq0J:www.troeger.eu/teaching/pythonvm08lab.pdf+python+add+statement&hl=en&ct=clnk&cd=10"}]}, {"text": ["Basically, to add new statements, you must edit Python/ast.c (among other things) and recompile the python binary."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Python/ast.c", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["While it's possible, don't.", "You can achieve almost everything via functions and classes (which wont require people to recompile python just to run your script..)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["General answer: you need to preprocess your source files. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["More specific answer: install EasyExtend, and go through following steps"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "EasyExtend", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/EasyExtend"}]}, {"text": ["i) Create a new langlet ( extension language )"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import EasyExtend\nEasyExtend.new_langlet(\"mystmts\", prompt = \"my&gt; \", source_ext = \"mypy\")\n</code>\n</pre>\n", "senID": 3}, {"text": ["Without additional specification a bunch of files shall be created under EasyExtend/langlets/mystmts/ ."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["ii) Open mystmts/parsedef/Grammar.ext and add following lines"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n small_stmt: (expr_stmt | print_stmt  | del_stmt | pass_stmt | flow_stmt |\n             import_stmt | global_stmt | exec_stmt | assert_stmt | my_stmt )\n\nmy_stmt: 'mystatement' expr\n</code>\n</pre>\n", "senID": 6}, {"text": ["This is sufficient to define the syntax of your new statement.", "The small_stmt non-terminal is part of the Python grammar and it's the place where the new statement is hooked in.", "The parser will now recognize the new statement i.e.", "a source file containing it will be parsed.", "The compiler will reject it though because it still has to be transformed into valid Python."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["iii) Now one has to add semantics of the statement.", "For this one has to edit\n msytmts/langlet.py and add a my_stmt node visitor."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def call_my_stmt(expression):\n     \"defines behaviour for my_stmt\"\n     print \"my stmt called with\", expression\n\n class LangletTransformer(Transformer):\n       @transform\n       def my_stmt(self, node):\n           _expr = find_node(node, symbol.expr)\n           return any_stmt(CST_CallFunc(\"call_my_stmt\", [_expr]))\n\n __publish__ = [\"call_my_stmt\"]\n</code>\n</pre>\n", "senID": 9}, {"text": ["iv) cd to langlets/mystmts and type"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n python run_mystmts.py\n</code>\n</pre>\n", "senID": 11}, {"text": ["Now a session shall be started and the newly defined statement can be used:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n __________________________________________________________________________________\n\n mystmts\n\n On Python 2.5.1 (r251:54863, Apr 18 2007, 08:51:08) [MSC v.1310 32 bit (Intel)]\n __________________________________________________________________________________\n\n my&gt; mystatement 40+2\n my stmt called with 42\n</code>\n</pre>\n", "senID": 13}, {"text": ["Quite a few steps to come to a trivial statement, right?", "There isn't an API yet that lets one define simple things without having to care about grammars.", "But EE is very reliable modulo some bugs.", "So it's just a matter of time that an API emerges that lets programmers define convenient stuff like infix operators or small statements using just convenient OO programming.", "For more complex things like embedding whole languages in Python by means of building a langlet there is no way of going around a full grammar approach."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}], [{"text": ["Not without modifying the interpreter.", "I know a lot of languages in the past several years have been described as \"extensible\", but not in the way you're describing.", "You extend Python by adding functions and classes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["It's possible to do this using EasyExtend:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "EasyExtend", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.fiber-space.de/EasyExtend/doc/EE.html"}]}], [{"text": ["There is a language based on python called Logix with which you CAN do such things.", "It hasn't been under development for a while, but the features that you asked for do work with the latest version. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Logix", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.livelogix.net/logix/"}, {"text": "do work", "childNum": 0, "tag": "b", "pos": 1, "childList": []}]}], [{"text": ["Here's a very simple but crappy way to add new statements, in interpretive mode only.", "I'm using it for little 1-letter commands for editing gene annotations using only sys.displayhook, but just so I could answer this question I added sys.excepthook for the syntax errors as well.", "The latter is really ugly, fetching the raw code from the readline buffer.", "The benefit is, it's trivially easy to add new statements this way."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "in interpretive mode only", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n jcomeau@intrepid:~/$ cat demo.py; ./demo.py\n#!/usr/bin/python -i\n'load everything needed under \"package\", such as package.common.normalize()'\nimport os, sys, readline, traceback\nif __name__ == '__main__':\n class t:\n  @staticmethod\n  def localfunction(*args):\n   print 'this is a test'\n   if args:\n    print 'ignoring %s' % repr(args)\n def displayhook(whatever):\n  if hasattr(whatever, 'localfunction'):\n   return whatever.localfunction()\n  else:\n   print whatever\n def excepthook(exctype, value, tb):\n  if exctype is SyntaxError:\n   index = readline.get_current_history_length()\n   item = readline.get_history_item(index)\n   command = item.split()\n   print 'command:', command\n   if len(command[0]) == 1:\n    try: eval(command[0]).localfunction(*command[1:])\n    except: traceback.print_exception(exctype, value, tb)\n  else:\n   traceback.print_exception(exctype, value, tb)\n sys.displayhook = displayhook\n sys.excepthook = excepthook\n>>> t\nthis is a test\n>>> t t\ncommand: ['t', 't']\nthis is a test\nignoring ('t',)\n>>> ^D\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You may find this useful - Python Internals - Adding a new statement to Python"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python Internals - Adding a new statement to Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://eli.thegreenplace.net/2010/06/30/python-internals-adding-a-new-statement-to-python/"}]}], [{"text": ["Ten years ago you couldn't, and I doubt that's changed.", "However, it wasn't that hard to modify the syntax back then if you were prepared to recompile python, and I doubt that's changed, either."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Some languages are exquisitely extensible, e.g.", "Forth and Smalltalk, but their language paradigms are different than that used by Python as well.", "With both of those any new words (Forth) or methods (Smalltalk) become an integral, indistiguishable part of the language for that installation.", "So each Forth or Smalltalk installation becomes a unique creation over time.", "Also Forth is RPN based.", "But thinking along the lines of DSLs, something like this should be accomplishable in Python.", "Though, as others have said here, why?", "Part of a modern programmer's toolkit includes using different languages with their various approaches.", "IBM tried a one-size-fits-all approach with PL/I back in the days before OOP, it was universally hated for its bloat."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]