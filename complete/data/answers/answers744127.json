[[{"text": ["Here's the code to select a single weighted value.", "You should be able to take it from here.", "It uses bisect and random to accomplish the work."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "bisect", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/bisect.html#bisect.bisect"}, {"href": "http://docs.python.org/library/random.html#random.random", "text": "random", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n from bisect import bisect\nfrom random import random\n\ndef WeightedABCD(*weights):\n  chars = 'ABCD'\n  breakpoints = [sum(weights[:x+1]) for x in range(4)]\n  return chars[bisect(breakpoints, random())]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Call it like this: WeightedABCD(.25, .34, .25, .25)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "WeightedABCD(.25, .34, .25, .25)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["EDIT: Here is a version that works even if the weights don't add up to 1.0:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "EDIT: Here is a version that works even if the weights don't add up to 1.0:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from bisect import bisect_left\nfrom random import uniform\n\ndef WeightedABCD(*weights):\n  chars = 'ABCD'\n  breakpoints = [sum(weights[:x+1]) for x in range(4)]\n  return chars[bisect_left(breakpoints, uniform(0.0,breakpoints[-1]))]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The random class is quite powerful in python.", "You can generate a list with the characters desired at the appropriate weights and then use random.choice to obtain a selection. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First, make sure you do an import random."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For example, let's say you wanted a truly random string from A,B,C, or D.\n1.", "Generate a list with the characters\nli = ['A','B','C','D']"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You could easily make that a function with n as a parameter."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["In the above case, you have an equal chance of getting A,B,C, or D. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You can use duplicate entries in the list to give characters higher probabilities.", "So, for example, let's say you wanted a 50% chance of A and 25% chances of B and C respectively.", "You could have an array like this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["li = ['A','A','B','C']"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["And so on."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["It would not be hard to parameterize the characters coming in with desired weights, to model that I'd use a dictionary. "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["characterbasis = {'A':25, 'B':25, 'C':25, 'D':25}"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Make that the first parameter, and the second being the length of the string and use the above code to generate your string."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["For four letters, here's something quick off the top of my head:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from random import random\n\ndef randABCD(n, pA, pB, pC, pD):\n    # assumes pA + pB + pC + pD == 1\n    cA = pA\n    cB = cA + pB\n    cC = cB + pC\n    def choose():\n        r = random()\n        if r &lt; cA:\n           return 'A'\n        elif r &lt; cB:\n           return 'B'\n        elif r &lt; cC:\n           return 'C'\n        else:\n           return 'D'\n    return ''.join([choose() for i in xrange(n)])\n</code>\n</pre>\n", "senID": 1}, {"text": ["I have no doubt that this can be made much cleaner/shorter, I'm just in a bit of a hurry right now."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The reason I wouldn't be content with David in Dakota's answer of using a list of duplicate characters is that depending on your probabilities, it may not be possible to create a list with duplicates in the right numbers to simulate the probabilities you want.", "(Well, I guess it might always be possible, but you might wind up needing a huge list - what if your probabilities were 0.11235442079, 0.4072777384, 0.2297927874, 0.25057505341?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT: here's a much cleaner generic version that works with any number of letters with any weights:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "EDIT", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from bisect import bisect\nfrom random import uniform\n\ndef rand_string(n, content):\n    ''' Creates a string of letters (or substrings) chosen independently\n        with specified probabilities. content is a dictionary mapping\n        a substring to its \"weight\" which is proportional to its probability,\n        and n is the desired number of elements in the string.\n\n        This does not assume the sum of the weights is 1.'''\n    l, cdf = zip(*[(l, w) for l, w in content.iteritems()])\n    cdf = list(cdf)\n    for i in xrange(1, len(cdf)):\n        cdf[i] += cdf[i - 1]\n    return ''.join([l[bisect(cdf, uniform(0, cdf[-1]))] for i in xrange(n)])\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Here is a rough idea of what might suit you"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random as r\n\ndef distributed_choice(probs):\n    r= r.random()\n    cum = 0.0\n\n    for pair in probs:\n    \tif (r &lt; cum + pair[1]):\n    \t\treturn pair[0]    \t\t\n    \tcum += pair[1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The parameter probs takes a list of pairs of the form (object, probability).", "It is assumed that the sum of probabilities is 1 (otherwise, its trivial to normalize)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "probs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["To use it just execute:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n ''.join([distributed_choice(probs)]*4)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Hmm, something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random\nclass RandomDistribution:\n    def __init__(self, kv):\n        self.entries = kv.keys()\n        self.where = []\n        cnt = 0\n        for x in self.entries:\n            self.where.append(cnt)\n            cnt += kv[x]\n        self.where.append(cnt)   \n\n    def find(self, key):\n        l, r = 0, len(self.where)-1\n        while l+1 &lt; r:\n           m = (l+r)/2\n           if self.where[m] &lt;= key:\n               l=m\n           else:\n               r=m\n        return self.entries[l]\n\n    def randomselect(self):\n        return self.find(random.random()*self.where[-1])\n\nrd = RandomDistribution( {\"foo\": 5.5, \"bar\": 3.14, \"baz\": 2.8 } )\nfor x in range(1000):\n    print rd.randomselect()\n</code>\n</pre>\n", "senID": 1}, {"text": ["should get you most of the way..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Thank you all for your help!!!", "I was able to figure something out, mostly with this info.", "For my particular need, i did somthing like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random\n#Create a funtion to randomize a given string\ndef makerandom(seq):\n    return ''.join(random.sample(seq, len(seq)))\ndef randomDNA(n, probA=0.25, probC=0.25, probG=0.25, probT=0.25):\n    notrandom=''\n    A=int(n*probA)\n    C=int(n*probC)\n    T=int(n*probT)\n    G=int(n*probG)\n\n#The remainder part here is used to make sure all n are used, as one cannot\n#have half an A for example.\n    remainder=''\n    for i in range(0, n-(A+G+C+T)):\n        ramainder+=random.choice(\"ATGC\")\n    notrandom=notrandom+ 'A'*A+ 'C'*C+ 'G'*G+ 'T'*T + remainder\n    return makerandom(notrandom)\n</code>\n</pre>\n", "senID": 1}]]