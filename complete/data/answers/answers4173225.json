[[{"text": ["Here's a generator approach.", "You've probably noticed that a whole lot of these \"generate lists\" can be done well as generator functions.", "They're very useful: they don't require you to generate the whole list before using data from it, to keep the whole list in memory, and you can use them to directly generate many data types, not just lists."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This works if passed any iterator, not just lists."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This approach also passes one of the more useful tests: it behaves well when passed an infinite or near-infinite iterator, eg.", "linear_merge(xrange(10**9), xrange(10**9))."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "linear_merge(xrange(10**9), xrange(10**9))", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The redundancy in the two cases could probably be reduced, which would be useful if you wanted to support merging more than two lists, but for clarity I didn't do that here."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def linear_merge(list1, list2):\n    \"\"\"\n    &gt;&gt;&gt; a = [1, 3, 5, 7]\n    &gt;&gt;&gt; b = [2, 4, 6, 8]\n    &gt;&gt;&gt; [i for i in linear_merge(a, b)]\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    &gt;&gt;&gt; [i for i in linear_merge(b, a)]\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    &gt;&gt;&gt; a = [1, 2, 2, 3]\n    &gt;&gt;&gt; b = [2, 2, 4, 4]\n    &gt;&gt;&gt; [i for i in linear_merge(a, b)]\n    [1, 2, 2, 2, 2, 3, 4, 4]\n    \"\"\"\n    list1 = iter(list1)\n    list2 = iter(list2)\n\n    value1 = next(list1)\n    value2 = next(list2)\n\n    # We'll normally exit this loop from a next() call raising StopIteration, which is\n    # how a generator function exits anyway.\n    while True:\n        if value1 &lt;= value2:\n            # Yield the lower value.\n            yield value1\n            try:\n                # Grab the next value from list1.\n                value1 = next(list1)\n            except StopIteration:\n                # list1 is empty.  Yield the last value we received from list2, then\n                # yield the rest of list2.\n                yield value2\n                while True:\n                    yield next(list2)\n        else:\n            yield value2\n            try:\n                value2 = next(list2)\n\n            except StopIteration:\n                # list2 is empty.\n                yield value1\n                while True:\n                    yield next(list1)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["This question covers this in more detail than you probably need.", ";) The chosen answer matches your requirement.", "If I needed to do this myself, I would do it in the way that dbr described in his or her answer (add the lists together, sort the new list) as it is very simple."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "This question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/q/464342/222959"}]}, {"text": ["EDIT:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I'm adding an implementation below.", "I actually saw this in another answer here which seems to have been deleted.", "I'm just hoping it wasn't deleted because it had an error which I'm not catching.", ";)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def mergeSortedLists(a, b):\n    l = []\n    while a and b:\n        if a[0] &lt; b[0]:\n            l.append(a.pop(0))\n        else:\n            l.append(b.pop(0))\n    return l + a + b\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I agree with other answers that extending and sorting is the most straightforward way, but if you must merge, this will be a little faster because it does not make two calls to len every iteration nor does it do a bounds check.", "The Python pattern, if you could call it that, is to avoid testing for a rare case and catch the exception instead."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "len", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def linear_merge(list1, list2):\n    merged_list = []\n    i = 0\n    j = 0\n\n    try:\n        while True:\n            if list1[i] &lt;= list2[j]:\n                merged_list.append(list1[i])\n                i += 1\n            else:\n                merged_list.append(list2[j])\n                j += 1\n    except IndexError:\n        if i == len(list1):\n            merged_list.extend(list2[j:])\n        if j == len(list2):\n            merged_list.extend(list1[i:])\n    return merged_list\n</code>\n</pre>\n", "senID": 1}, {"text": ["edit\nOptimized per John Machin's comment.", "Moved try outside of while True and extended merged_list upon exception."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "try", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "while True", "childNum": 0, "tag": "code", "childList": []}, {"text": "merged_list", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Here's my implementation from a previous question:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "previous question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1158128/merge-sorted-lists-in-python"}]}, {"code": "<pre>\n<code>\n def merge(*args):\n    import copy\n    def merge_lists(left, right):\n        result = []\n        while (len(left) and len(right)):\n            which_list = (left if left[0] &lt;= right[0] else right)\n            result.append(which_list.pop(0))\n        return result + left + right\n    lists = [arg for arg in args]\n    while len(lists) &gt; 1:\n        left, right = copy.copy(lists.pop(0)), copy.copy(lists.pop(0))\n        result = merge_lists(left, right)\n        lists.append(result)\n    return lists.pop(0)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Another generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def merge(xs, ys):\n    xs = iter(xs)\n    ys = iter(ys)\n    try:\n        y = next(ys)\n    except StopIteration:\n        for x in xs:\n            yield x\n        raise StopIteration\n    while True:\n        for x in xs:\n            if x &gt; y:\n                yield y\n                break\n            yield x\n        else:\n            yield y\n            for y in ys:\n                yield y\n            break\n        xs, ys, y = ys, xs, x\n</code>\n</pre>\n", "senID": 1}], [{"text": ["hi i just did this exercise and i was wondering why not use,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def linear_merge(list1, list2):\n  return sorted(list1 + list2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["pythons sorted function is linear isn't it?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]