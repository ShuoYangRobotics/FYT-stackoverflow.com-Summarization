[[{"text": ["In HTTP response headers are separated from body by two CRLF characters.", "So you can use string.find() method like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "string.find()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n p = http_reply.find('\\r\\n\\r\\n')\nif p &gt;= 0:\n    return http_reply[p:]\nreturn http_reply\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Based on Michal solution but this one includes and essential fix:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def strip_http_headers(http_reply):\n    p = http_reply.find('\\r\\n\\r\\n')\n    if p &gt;= 0:\n        return http_reply[p+4:]\n    return http_reply\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Short and sweet:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n body = response.split('\\r\\n\\r\\n', 1)[-1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["(it uses two argument version of split() and [-1] means last element of array)"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "split()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[-1]", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n resp = ('Content-Type: text/xml\\r\\n'\n        'Content-Length: 129\\r\\n'\n        \"&lt;?xml version='1.0'?&gt;\\r\\n\"\n        '\\r\\n'\n        '&lt;methodResponse&gt;\\r\\n'\n        '&lt;params&gt;\\r\\n'\n        '&lt;param&gt;\\r\\n'\n        '&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;\\r\\n'\n        '&lt;/param&gt;\\r\\n'\n        '&lt;/params&gt;\\r\\n'\n        '&lt;/methodResponse&gt;\\r\\n'\n        '&lt;/code&gt;')\n\nprint resp.partition('\\r\\n\\r\\n')[2]\n</code>\n</pre>\n", "senID": 0}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &lt;methodResponse&gt;\n&lt;params&gt;\n&lt;param&gt;\n&lt;value&gt;&lt;boolean&gt;0&lt;/boolean&gt;&lt;/value&gt;\n&lt;/param&gt;\n&lt;/params&gt;\n&lt;/methodResponse&gt;\n&lt;/code&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["On my display, the characters '\\r' appear as squares at the end of each line."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The advantage of partition() is that it returns ALWAYS a tuple of 3 elements:\nthen, if there is not the sequence '\\r\\n\\r\\n' in the text,\nresp.partition('\\r\\n\\r\\n')[2] will be \"\"\nwhile split('\\r\\n\\r\\n')[1] causes an error and split('\\r\\n\\r\\n')[-1] is the entire text."], "childNum": 8, "tag": "p", "senID": 4, "childList": [{"text": "partition()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "resp.partition('\\r\\n\\r\\n')[2]", "childNum": 0, "tag": "code", "childList": []}, {"text": "\"\"", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "split('\\r\\n\\r\\n')[1]", "childNum": 0, "tag": "code", "childList": []}, {"text": "split('\\r\\n\\r\\n')[-1]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If the double newline is variable, only a regex can hold the variability.", "It is necessary to know what is the span of variability to craft a regex pattern."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["Supposing that only \"\\n\\n\", \"\\r\\n\\n\", \"\\n\\r\\n\" and \"\\r\\n\\r\\n\" are possible , a solution would be to catch the body with help of the regex based on following  pattern :"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nregx = re.compile('(?:(?:\\r?\\n){2}|\\Z)(.+)?',re.DOTALL)\n\nfor ss in (('Content-Type: text/xml\\r\\n'\n            'Content-Length: 129\\r\\n'\n            \"&lt;?xml version='1.0'?&gt;\\n\"\n            '\\n'\n            'body1\\r\\n'\n            '&lt;params&gt;\\r\\n'\n            '&lt;param&gt;\\r\\n'\n            '&lt;/code&gt;') ,\n           ('Content-Type: text/xml\\r\\n'\n            'Content-Length: 129\\r\\n'\n            \"&lt;?xml version='1.0'?&gt;\\r\\n\"\n            '\\n'\n            'body2\\r\\n'\n            '&lt;params&gt;\\r\\n'\n            '&lt;param&gt;\\r\\n'\n            '&lt;/code&gt;') ,\n           ('Content-Type: text/xml\\r\\n'\n            'Content-Length: 129\\r\\n'\n            \"&lt;?xml version='1.0'?&gt;\\n\"\n            '\\r\\n'\n            'body3\\r\\n'\n            '&lt;params&gt;\\r\\n'\n            '&lt;param&gt;\\r\\n'\n            '&lt;/code&gt;') ,\n           ('Content-Type: text/xml\\r\\n'\n            'Content-Length: 129\\r\\n'\n            \"&lt;?xml version='1.0'?&gt;\\r\\n\"\n            '\\r\\n'\n            'body4\\r\\n'\n            '&lt;params&gt;\\r\\n'\n            '&lt;param&gt;\\r\\n'\n            '&lt;/code&gt;') ,\n           ('Content-Type: text/xml\\r\\n'\n            'Content-Length: 129\\r\\r'\n            \"&lt;?xml version='1.0'?&gt;\\r\\r\"\n            '\\r\\n'\n            'body4\\r\\n'\n            '&lt;params&gt;\\r\\n'\n            '&lt;param&gt;\\r\\n'\n            '&lt;/code&gt;') ,):\n    print ('splitting on sequence  :  %r\\n%r\\n') \\\n           % (re.search('(?:\\r?\\n)+(?=body)',ss).group(),\n              regx.search(ss).group(1))\n</code>\n</pre>\n", "senID": 7}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n splitting on sequence  :  '\\n\\n'\n'body1\\r\\n&lt;params&gt;\\r\\n&lt;param&gt;\\r\\n&lt;/code&gt;'\n\nsplitting on sequence  :  '\\r\\n\\n'\n'body2\\r\\n&lt;params&gt;\\r\\n&lt;param&gt;\\r\\n&lt;/code&gt;'\n\nsplitting on sequence  :  '\\n\\r\\n'\n'body3\\r\\n&lt;params&gt;\\r\\n&lt;param&gt;\\r\\n&lt;/code&gt;'\n\nsplitting on sequence  :  '\\r\\n\\r\\n'\n'body4\\r\\n&lt;params&gt;\\r\\n&lt;param&gt;\\r\\n&lt;/code&gt;'\n\nsplitting on sequence  :  '\\r\\n'\nNone\n</code>\n</pre>\n", "senID": 9}], [{"text": ["You can use standard urllib2:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "urllib2", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/urllib2.html"}]}, {"code": "<pre>\n<code>\n from urllib2 import urlopen\ndata = urlopen('http://url.here/').read()\n</code>\n</pre>\n", "senID": 1}, {"text": ["And if you want to parse xml:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "xml", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/xml.dom.minidom.html#xml.dom.minidom.parse"}]}, {"code": "<pre>\n<code>\n from urllib2 import urlopen\nfrom xml.dom.minidom import parse\n\nxml = parse(urlopen('http://url.here'))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Besides what Tito said, there's also the requests package"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "requests", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/requests"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import requests\n&gt;&gt;&gt; r = requests.get(\"http://yoururl\")\n&gt;&gt;&gt; r\n&lt;Response [200]&gt;\n&gt;&gt;&gt; r.content\n...\n</code>\n</pre>\n", "senID": 1}, {"text": ["And then parse it with minidom or whatever tool you choose for that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]