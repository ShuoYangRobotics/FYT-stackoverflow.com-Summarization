[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; import itertools\n&gt;&gt;&gt; a\n['1', '2', '3', '4', '5', '6']\n&gt;&gt;&gt; b\n['a', 'b', 'c', 'd', 'e', 'f']\n&gt;&gt;&gt; list(itertools.chain.from_iterable(zip(a,b)))\n['1', 'a', '2', 'b', '3', 'c', '4', 'd', '5', 'e', '6', 'f']\n</code>\n</pre>\n", "senID": 0}, {"text": ["zip() produces a iterable with the length of shortest argument.", "You can either append a[-1] to the result, or use itertools.zip_longest(izip_longest for Python 2.x) with a fill value and delete that value afterwards.  "], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "zip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a[-1]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "itertools.zip_longest", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["And you can use more than two input sequences with this solution."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For not appending the last value, you can try this dirty approach, but I don't really recommend it, it isn't clear:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a\n[1, 2, 3, 4, 5]\n&gt;&gt;&gt; b\n['a', 'b', 'c', 'd', 'e', 'f']\n&gt;&gt;&gt; [a[i//2] if i%2 else b[i//2] for i in range(len(a)*2+1)]\n['a', 1, 'b', 2, 'c', 3, 'd', 4, 'e', 5, 'f']\n</code>\n</pre>\n", "senID": 4}, {"text": ["(For Python 2.x, use single /)"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "/", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["mixing two lists is a job for zip:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n res = []\nfor a,b in zip(list_long, list_short):\n    res += [a,b]\n</code>\n</pre>\n", "senID": 1}, {"text": ["for lists of differing lengths, define your own function:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def mix(list_long, list_short):\n    result = []\n    i,j = iter(list_long), iter(list_short)\n    for a,b in zip(i,j):\n        res += [a,b]\n    for rest in i:\n        result += rest\n    for rest in j:\n        result += rest\n    return result\n</code>\n</pre>\n", "senID": 3}, {"text": ["using the answer given by Mihail, we can shorten this to:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "answer given by Mihail", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/7529376/pythonic-way-to-mix-two-lists/7529533#7529533"}]}, {"code": "<pre>\n<code>\n def mix(list_long, list_short):\n    i,j = iter(list_long), iter(list_short)\n    result = [item for sublist in zip(i,j) for item in sublist]\n    result += [item for item in i]\n    result += [item for item in j]\n    return result\n</code>\n</pre>\n", "senID": 5}], [{"text": ["IMHO the best way is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n result = [item for sublist in zip(a,b) for item in sublist]\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's also faster than sum and reduce ways."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["UPD Sorry missed that your second list is bigger by one element :)\nThere is another crazy way:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "UPD", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n result = [item for sublist in map(None, a, b) for item in sublist][:-1]\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; long = [1, 3, 5, 7]\n&gt;&gt;&gt; short = [2, 4, 6]\n&gt;&gt;&gt; mixed = []\n&gt;&gt;&gt; for i in range(len(long)):\n&gt;&gt;&gt;     mixed.append(long[i])\n&gt;&gt;&gt;     if i &lt; len(short)\n&gt;&gt;&gt;         mixed.append(short[i])\n&gt;&gt;&gt; mixed\n[1, 2, 3, 4, 5, 6, 7]\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n sum([[x,y] for x,y in zip(b,a)],[])+[b[-1]]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Note: This works only for your given list lengths, but can easily be extended to arbitrary length lists."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I would use a combination of the above answers:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = ['1', '2', '3', '4', '5', '6']\n\n&gt;&gt;&gt; b = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\n&gt;&gt;&gt; [i for l in izip_longest(a, b, fillvalue=object) for i in l if i is not object]\n&lt;&lt;&lt; ['1', 'a', '2', 'b', '3', 'c', '4', 'd', '5', 'e', '6', 'f', 'g']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could do something like the following (assuming len(list_long)==len(list_short)+1:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "len(list_long)==len(list_short)+1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def list_mixing(list_long,list_short):\n    return [(list_long[i/2] if i%2==0 else list_short[i/2]) for i in range(len(list_long)+len(list_short)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Where I am using / for integer division (exactly what the operator is for that depends on the language version)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "/", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Use zip.", "That will give you a list of tuples, like:\n[('a_1', 'b_1'), ('a_2', 'b_2'), ('a_3', 'b_3')]"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want to clean that up into a nice list, just iterate over the list of tuples with enumerate:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n alist = ['a_1', 'a_2', 'a_3']\nblist = ['b_1', 'b_2', 'b_3']\nclist = []\n\nfor i, (a, b) in enumerate(zip(alist, blist)):\n    clist.append(a)\n    clist.append(b)\nprint clist\n['a_1', 'b_1', 'a_2', 'b_2', 'a_3', 'b_3']\n</code>\n</pre>\n", "senID": 2}]]