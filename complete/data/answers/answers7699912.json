[[{"text": ["In Haskell, the idiom for this is just to go ahead and execute the next state:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n type StateMachine = IO ()\na, b, c :: StateMachine\na = print \"a()\" &gt;&gt; b\nb = print \"b()\" &gt;&gt; c\nc = print \"c()\" &gt;&gt; a\n</code>\n</pre>\n", "senID": 1}, {"text": ["You need not worry that this will overflow a stack or anything like that.", "If you insist on having states, then you should make the data type more explicit:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n data PossibleStates = A | B | C\ntype StateMachine = PossibleStates -&gt; IO PossibleStates\nmachine A = print \"a()\" &gt;&gt; return B\nmachine B = print \"b()\" &gt;&gt; return C\nmachine C = print \"c()\" &gt;&gt; return A\n</code>\n</pre>\n", "senID": 3}, {"text": ["You can then get compiler warnings about any StateMachine that forgot some states."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "StateMachine", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If you use newtype instead of data, you don't incur any overhead.", "Also, you can wrap each state's function at the point of definition, so the expressions that use them don't have to:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "newtype", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "data", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import Control.Monad\n\nnewtype State = State { runState :: IO State }\n\na :: State\na = State $ print \"a()\" &gt;&gt; return b\n\nb :: State\nb = State $ print \"b()\" &gt;&gt; return c\n\nc :: State\nc = State $ print \"c()\" &gt;&gt; return a\n\nrunMachine :: State -&gt; IO ()\nrunMachine s = runMachine =&lt;&lt; runState s\n\nmain = runMachine a\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: it struck me that runMachine has a more general form; a monadic version of iterate:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "runMachine", "childNum": 0, "tag": "code", "childList": []}, {"text": "iterate", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n iterateM :: Monad m =&gt; (a -&gt; m a) -&gt; a -&gt; m [a]\niterateM f a = do { b &lt;- f a\n                  ; as &lt;- iterateM f b\n                  ; return (a:as)\n                  }\n\nmain = iterateM runState a\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit: Hmm, iterateM causes a space-leak.", "Maybe iterateM_ would be better."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "iterateM", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "iterateM_", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n iterateM_ :: Monad m =&gt; (a -&gt; m a) -&gt; a -&gt; m ()\niterateM_ f a = f a &gt;&gt;= iterateM_ f\n\nmain = iterateM_ runState a\n</code>\n</pre>\n", "senID": 5}, {"text": ["Edit: If you want to thread some state through the state machine, you can use the same definition for State, but change the state functions to:"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "State", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n a :: Int -&gt; State\na i = State $ do{ print $ \"a(\" ++ show i ++ \")\"\n                ; return $ b (i+1)\n                }\n\nb :: Int -&gt; State\nb i = State $ do{ print $ \"b(\" ++ show i ++ \")\"\n                ; return $ c (i+1)\n                }\n\nc :: Int -&gt; State\nc i = State $ do{ print $ \"c(\" ++ show i ++ \")\"\n                ; return $ a (i+1)\n                }\n\nmain = iterateM_ runState $ a 1\n</code>\n</pre>\n", "senID": 7}], [{"text": ["In the C-like type systems functions are not first order citizens.", "There are certain restrictions on handling them.", "That was a decision for simplicity and speed of implementation/execution that stuck.", "To have functions behave like objects, one generally requires support for closures.", "Those however are not naturally supported by mosts processors' instruction sets.", "As C was designed to be close to the metal, there was no support for them."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When declaring recursive structures in C, the type must be fully expandable.", "A consequence of this is, that you can only have pointers as self-references in struct declarations:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n struct rec;\nstruct rec {\n    struct rec *next;\n};\n</code>\n</pre>\n", "senID": 2}, {"text": ["Also every identifier we use has to be declared.", "One of the restrictions of function-types is, that one can not forward declare them."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["A state machine in C usually works by making a mapping from integers to functions, either in a switch statement or in a jump table:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n typedef int (*func_t)();\n\nvoid run() {\n    func_t table[] = {a, b, c};\n\n    int state = 0;\n\n    while(True) {\n        state = table[state]();\n    }\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["Alternatively you could profile your Python code and try to find out why your code is slow.", "You can port the critical parts to C/C++ and keep using Python for the state machine."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "profile your Python code", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/profile.html"}]}], [{"text": ["The problem with your Haskell code is, that type only introduces a synonym, which is quite similar to what typedef in C does.", "One important restriction is, that the expansion of the type must be finite, you can't give a finite expansion of your state machine.", "A solution is using a newtype: A newtype is a wrapper that does only exist for the type checker; there is absolutely zero overhead (excluded stuff that occurs because of generalization that can't be removed).", "Here is your signature; it typechecks:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "typedef", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "newtype", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "newtype", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n newtype FN = FN { unFM :: (IO FN) }\n</code>\n</pre>\n", "senID": 1}, {"text": ["Please note, that whenever you want to use an FN, you have to unpack it first using unFN.", "Whenever you return a new function, use FN to pack it."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "FN", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "unFN", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "FN", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["As usual, despite the great answers already present, I couldn't resist trying it out for myself.", "One thing that bothered me about what is presented is that it ignores input.", "State machines--the ones that I am familiar with--choose between various possible transitions based on input."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n data State vocab = State { stateId :: String\n                         , possibleInputs :: [vocab]\n                         , _runTrans :: (vocab -&gt; State vocab)\n                         }\n                      | GoalState { stateId :: String }\n\ninstance Show (State a) where\n  show = stateId\n\nrunTransition :: Eq vocab =&gt; State vocab -&gt; vocab -&gt; Maybe (State vocab)\nrunTransition (GoalState id) _                   = Nothing\nrunTransition s x | x `notElem` possibleInputs s = Nothing\n                  | otherwise                    = Just (_runTrans s x)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here I define a type State, which is parameterized by a vocabulary type vocab.", "Now let's define a way that we can trace the execution of a state machine by feeding it inputs."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "State", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "vocab", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n traceMachine :: (Show vocab, Eq vocab) =&gt; State vocab -&gt; [vocab] -&gt; IO ()\ntraceMachine _ [] = putStrLn \"End of input\"\ntraceMachine s (x:xs) = do\n  putStrLn \"Current state: \"\n  print s\n  putStrLn \"Current input: \"\n  print x\n  putStrLn \"-----------------------\"\n  case runTransition s x of\n    Nothing -&gt; putStrLn \"Invalid transition\"\n    Just s' -&gt; case s' of\n      goal@(GoalState _) -&gt; do\n        putStrLn \"Goal state reached:\"\n        print s'\n        putStrLn \"Input remaining:\"\n        print xs\n      _ -&gt; traceMachine s' xs\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now let's try it out on a simple machine that ignores its inputs.", "Be warned: the format I have chosen is rather verbose.", "However, each function that follows can be viewed as a node in a state machine diagram, and I think you'll find the verbosity to be completely relevant to describing such a node.", "I've used stateId to encode in string format some visual information about how that state behaves."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "stateId", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n data SimpleVocab = A | B | C deriving (Eq, Ord, Show, Enum)\n\nsimpleMachine :: State SimpleVocab\nsimpleMachine = stateA\n\nstateA :: State SimpleVocab\nstateA = State { stateId = \"A state. * -&gt; B\"\n               , possibleInputs = [A,B,C]\n               , _runTrans = \\_ -&gt; stateB\n               }\n\nstateB :: State SimpleVocab\nstateB = State { stateId = \"B state. * -&gt; C\"\n               , possibleInputs = [A,B,C]\n               , _runTrans = \\_ -&gt; stateC\n               }\n\nstateC :: State SimpleVocab\nstateC = State { stateId = \"C state. * -&gt; A\"\n               , possibleInputs = [A,B,C]\n               , _runTrans = \\_ -&gt; stateA\n               }\n</code>\n</pre>\n", "senID": 5}, {"text": ["Since the inputs don't matter for this state machine, you can feed it anything."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n ghci&gt; traceMachine simpleMachine [A,A,A,A]\n</code>\n</pre>\n", "senID": 7}, {"text": ["I won't include the output, which is also very verbose, but you can see it clearly moves from stateA to stateB to stateC and back to stateA again.", "Now let's make a slightly more complicated machine:"], "childNum": 4, "tag": "p", "senID": 8, "childList": [{"text": "stateA", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "stateB", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "stateC", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "stateA", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n lessSimpleMachine :: State SimpleVocab\nlessSimpleMachine = startNode\n\nstartNode :: State SimpleVocab\nstartNode = State { stateId = \"Start node. A -&gt; 1, C -&gt; 2\"\n                  , possibleInputs = [A,C]\n                  , _runTrans = startNodeTrans\n                  }\n  where startNodeTrans C = node2\n        startNodeTrans A = node1\n\nnode1 :: State SimpleVocab\nnode1 = State { stateId = \"node1. B -&gt; start, A -&gt; goal\"\n              , possibleInputs = [B, A]\n              , _runTrans = node1trans\n              }\n  where node1trans B = startNode\n        node1trans A = goalNode\n\nnode2 :: State SimpleVocab\nnode2 = State { stateId = \"node2. C -&gt; goal, A -&gt; 1, B -&gt; 2\"\n              , possibleInputs = [A,B,C]\n              , _runTrans = node2trans\n              }\n  where node2trans A = node1\n        node2trans B = node2\n        node2trans C = goalNode\n\ngoalNode :: State SimpleVocab\ngoalNode = GoalState \"Goal. :)\"\n</code>\n</pre>\n", "senID": 9}, {"text": ["The possible inputs and transitions for each node should require no further explanation, as they are verbosely described in the code.", "I'll let you play with traceMachine lessSipmleMachine inputs for yourself.", "See what happens when inputs is invalid (does not adhere to the \"possible inputs\" restrictions), or when you hit a goal node before the end of input."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "traceMachine lessSipmleMachine inputs", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "inputs", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["I suppose the verbosity of my solution sort of fails what you were basically asking, which was to cut down on the cruft.", "But I think it also illustrates how descriptive Haskell code can be.", "Even though it is very verbose, it is also very straightforward in how it represents nodes of a state machine diagram."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["Your problem has been had before: Recursive declaration of function pointer in C"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Recursive declaration of function pointer in C", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/793449/recursive-declaration-of-function-pointer-in-c"}]}, {"text": ["C++ operator overloading can be used to hide the mechanics of what is essentially the same as your your C and Haskell solutions, as Herb Sutter describes in GotW #57: Recursive Declarations."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "GotW #57: Recursive Declarations", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.gotw.ca/gotw/057.htm"}]}, {"code": "<pre>\n<code>\n struct FuncPtr_;\ntypedef FuncPtr_ (*FuncPtr)();\n\nstruct FuncPtr_\n{\n  FuncPtr_( FuncPtr pp ) : p( pp ) { }\n  operator FuncPtr() { return p; }\n  FuncPtr p;\n};\n\nFuncPtr_ f() { return f; } // natural return syntax\n\nint main()\n{\n  FuncPtr p = f();  // natural usage syntax\n  p();\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["But this business with functions will, in all likelihood, perform worse than the equivalent with numeric states.", "You should use a switch statement or a state table, because what you really want in this situation is a structured semantic equivalent to goto."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "switch", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "goto", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You can get the same effect in C as in Python code,- just declare that functions returns (void*):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "(void*)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #include \"stdio.h\"\n\ntypedef void* (*myFunc)(void);\n\nvoid* a(void);\nvoid* b(void);\nvoid* c(void);\n\nvoid* a(void) {\n  printf(\"a()\\n\");\n  return b;\n}\n\nvoid* b(void) {\n  printf(\"b()\\n\");\n  return c;\n}\n\nvoid* c(void) {\n  printf(\"c()\\n\");\n  return a;\n}\n\nvoid main() {\n void* state = a;\n while (1) {\n   state = ((myFunc)state)();\n   sleep(1);\n }\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["HTH!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["What you want is a recursive type.", "Different languages have different ways of doing this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, in OCaml (a statically-typed language), there is an optional compiler/interpreter flag -rectypes that enables support for recursive types, allowing you to define stuff like this:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "-rectypes", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n let rec a () = print_endline \"a()\"; b\nand b () = print_endline \"b()\"; c\nand c () = print_endline \"c()\"; a\n;;\n</code>\n</pre>\n", "senID": 2}, {"text": ["Although this is not \"ugly\" as you complained about in your C example, what happens underneath is still the same.", "The compiler simply worries about that for you instead of forcing you to write it out."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "underneath", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["As others have pointed out, in Haskell you can use newtype and there won't be any \"overhead\".", "But you complain about having to explicitly wrap and unwrap the recursive type, which is \"ugly\".", "(Similarly with your C example; there is no \"overhead\" since at the machine level a 1-member struct is identical to its member, but it is \"ugly\"."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "newtype", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Another example I want to mention is Go (another statically-typed language).", "In Go, the type construct defines a new type.", "It is not a simple alias (like typedef in C or type in Haskell), but creates a full-fledged new type (like newtype in Haskell) because such a type has an independent \"method set\" of methods that you can define on it.", "Because of this, the type definition can be recursive:"], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "typedef", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "type", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "newtype", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n type Fn func () Fn\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Iit's not hard to make state machines in Haskell, once you realize that they are not monads!", "A state machine like the one you want is an arrow, an automaton arrow to be exact:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "not", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n newtype State a b = State (a -&gt; (b, State a b))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is a function, which takes an input value and produces an output value along with a new version of itself.", "This is not a monad, because you cannot write join or (&gt;&gt;=) for it.", "Equivalently once you have turned this into an arrow you will realize that it's impossible to write an ArrowApply instance for it."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "join", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "(&gt;&gt;=)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "ArrowApply", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Here are the instances:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import Control.Arrow\nimport Control.Category\nimport Prelude hiding ((.), id)\n\ninstance Category State where\n    id = State $ \\x -&gt; (x, id)\n\n    State f . State g =\n        State $ \\x -&gt;\n            let (y, s2) = g x\n                (z, s1) = f y\n            in (z, s1 . s2)\n\ninstance Arrow State where\n    arr f = let s = State $ \\x -&gt; (f x, s) in s\n    first (State f) =\n        State $ \\(x1, x2) -&gt;\n            let (y1, s) = f x1\n            in ((y1, x2), first s)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Have fun."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["An example in F#:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\ntype Cont = Cont of (unit -> Cont)\n\nlet rec a() =\n    printfn \"a()\"\n    Cont (fun () -> b 42)\n\nand b n =\n    printfn \"b(%d)\" n\n    Cont c\n\nand c() =\n    printfn \"c()\"\n    Cont a\n\nlet rec run (Cont f) =\n    let f = f()\n    run f\n\nrun (Cont a)\n</pre>\n", "senID": 1}, {"text": ["Regarding the question \"why is it so hard to implement state machines using functions in statically typed languages?", "\": That's because the type of of a and friends is a little bit weird: a function that when returns a function that returns a function that returns a function..."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If I remove Cont from my example the F# compiler complains and says:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\nExpecting 'a but given unit -> 'a. The resulting type would be infinite when unifying 'a and unit -> 'a.\n</pre>\n", "senID": 4}, {"text": ["Another answer shows a solution in OCaml whose type inference is strong enough to remove the need for declaring Cont, which shows static typing is not to blame, rather the lack of powerful type inference in many statically typed languages."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I don't know why F# doesn't do it, I would guess maybe this would make the type inference algorithm more complicated, slower, or \"too powerful\" (it could manage to infer the type of incorrectly typed expressions, failing at a later point giving error messages that are hard to understand)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Note that the Python example you gave isn't really safe.", "In my example, b represents a family of states parameterized by an integer.", "In an untyped language, it's easy to make a mistake and return b or b 42 instead of the correct lambda and miss that mistake until the code is executed."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "b", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "b 42", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The Python code you posted will be transformed into a recursive function, but it will not be tail call optimized because Python has no tail call optimization, so it will stack overflow at some point.", "So the Python code is actually broken, and would take more work to get it as good as the Haskell or C versions."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is an example of what I mean:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["so.py:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import threading\nstack_size_bytes = 10**5\nthreading.stack_size(10**5)\nmachine_word_size = 4\n\ndef t1():\n    print \"start t1\"\n    n = stack_size_bytes/machine_word_size\n    while n:\n        n -= 1\n    print \"done t1\"\n\ndef t2():\n    print \"start t2\"\n    n = stack_size_bytes/machine_word_size+1\n    while n:\n        n -= 1\n    print \"done t2\"\n\nif __name__ == \"__main__\":\n    t = threading.Thread(target=t1)\n    t.start()\n    t.join()\n    t = threading.Thread(target=t2)\n    t.start()\n    t.join()\n</code>\n</pre>\n", "senID": 3}, {"text": ["shell:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n $ python so.py\nstart t1\ndone t1\nstart t2\nException in thread Thread-2:\nTraceback (most recent call last):\n  File \"/usr/lib/python2.7/threading.py\", line 530, in __bootstrap_inner\n    self.run()\n  File \"/usr/lib/python2.7/threading.py\", line 483, in run\n    self.__target(*self.__args, **self.__kwargs)\n  File \"so.py\", line 18, in t2\n    print \"done t2\"\nRuntimeError: maximum recursion depth exceeded\n</code>\n</pre>\n", "senID": 5}]]