[[{"text": ["Here's a relevant example from the itertools module docs:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#recipes"}]}, {"code": "<pre>\n<code>\n def pairwise(iterable):\n    \"s -&gt; (s0,s1), (s1,s2), (s2, s3), ...\"\n    a, b = tee(iterable)\n    next(b, None)\n    return izip(a, b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["How this works:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["First, two parallel iterators, a and b are created (the tee() call), both pointing to the first element of the original iterable.", "The second iterator, b is moved 1 step  forward (the next(b, None)) call).", "At this point a points to s0 and b points to s1.", "Both a and b can traverse the original iterator independently - the izip function takes the two iterators and makes pairs of the returned elements, advancing both iterators at the same pace."], "childNum": 9, "tag": "p", "senID": 3, "childList": [{"text": "a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "tee()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "next(b, None)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["One caveat: the tee() function produces two iterators that can advance independently of each other, but it comes at a cost.", "If one of the iterators advances further than the other,  then tee()  needs to keep the consumed elements in memory until the second iterator comsumes them too (it cannot 'rewind' the original iterator).", "Here it doesn't matter because one iterator is only 1 step ahead of the other, but in general it's easy to use a lot of memory this way."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "tee()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tee()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Since the_list[1:] actually creates a copy of the whole list (excluding its first element), and zip() creates a list of tuples immediately when called,  in total three copies of your list are created.", "If your list is very large, you might prefer"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "the_list[1:]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "zip()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import izip, islice\nfor current, next in izip(the_list, islice(the_list, 1, None)):\n    # whatever\n</code>\n</pre>\n", "senID": 1}, {"text": ["which does not copy the list at all."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This should do the same thing:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\nthe_list = [1,2,3,4]\nfor i in range(1, len(the_list)):\n    current, next = the_list[i-1], the_list[i]\n    print current, next\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Check MizardX answer for this question.", "But i don't think this solution is more idiomatic than yours."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/323750/how-to-access-previous-next-element-while-for-looping"}]}], [{"text": ["A basic solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def neighbors( list ):\n  i = 0\n  while i + 1 &lt; len( list ):\n    yield ( list[ i ], list[ i + 1 ] )\n    i += 1\n\nfor ( x, y ) in neighbors( list ):\n  print( x, y )\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n code = '0016364ee0942aa7cc04a8189ef3'\n# Getting the current and next item\nprint  [code[idx]+code[idx+1] for idx in range(len(code)-1)]\n# Getting the pair\nprint  [code[idx*2]+code[idx*2+1] for idx in range(len(code)/2)]\n</code>\n</pre>\n", "senID": 0}]]