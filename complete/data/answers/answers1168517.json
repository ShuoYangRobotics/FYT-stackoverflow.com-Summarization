[[{"text": ["A closure would be a quick solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n paragraph = \"I eat bananas and a banana\"\n\ndef tester(s): \n    def f(x):\n        return len(re.findall(x,s))\n    return f\n\nprint map(tester(paragraph), ['banana', 'loganberry', 'passion fruit'])\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n targets = ['banana', 'loganberry', 'passion fruit']\nparagraph = \"I eat bananas and a banana\"\n\nprint [paragraph.count(target) for target in targets]\n</code>\n</pre>\n", "senID": 0}, {"text": ["No idea why you would use map() here."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I know you didn't ask for list comprehension, but here it is anyway:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n paragraph = \"I eat bananas and a banana\"\nwords = ['banana', 'loganberry', 'passion fruit']\n[len(re.findall(word, paragraph)) for word in words]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This returns\n    [2, 0, 0]\nas well."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This is basically just going out of your way to avoid a list comprehension, but if you like functional style programming, then you'll like functools.partial."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "functools.partial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functools.html#functools.partial"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from functools import partial\n&gt;&gt;&gt; def counter(text, paragraph):\n    return len(re.findall(text, paragraph))\n\n&gt;&gt;&gt; tester = partial(counter, paragraph=\"I eat bananas and a banana\")\n&gt;&gt;&gt; map(tester, ['banana', 'loganberry', 'passion fruit'])\n[2, 0, 0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["For Q query words of average length L bytes on large texts of size T bytes, you need something that's NOT O(QLT).", "You need a DFA-style approach which can give you O(T) ... after setup costs.", "If your query set is rather static, then the setup cost can be ignored."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["E.g.", "http://en.wikipedia.org/wiki/Aho-Corasick_algorithm\nwhich points to a C-extension for Python:\nhttp://hkn.eecs.berkeley.edu/~dyoo/python/ahocorasick/"], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "http://en.wikipedia.org/wiki/Aho-Corasick_algorithm", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "http://hkn.eecs.berkeley.edu/~dyoo/python/ahocorasick/", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Here's a response to the movement of the goalposts (\"I probably need the regex because I'll need word delimiters in the near future\"):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This method parses the text once to obtain a list of all the \"words\".", "Each word is looked up in a dictionary of the target words, and if it is a target word it is counted.", "The time taken is O(P) + O(T) where P is the size of the paragraph and T is the number of target words.", "All other solutions to date (including the currently accepted solution) except my Aho-Corasick solution are O(PT)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def counts_all(targets, paragraph, word_regex=r\"\\w+\"):\n    tally = dict((target, 0) for target in targets)\n    for word in re.findall(word_regex, paragraph):\n        if word in tally:\n            tally[word] += 1\n    return [tally[target] for target in targets]\n\ndef counts_iter(targets, paragraph, word_regex=r\"\\w+\"):\n    tally = dict((target, 0) for target in targets)\n    for matchobj in re.finditer(word_regex, paragraph):\n        word = matchobj.group()\n        if word in tally:\n            tally[word] += 1\n    return [tally[target] for target in targets]\n</code>\n</pre>\n", "senID": 2}, {"text": ["The finditer version is a strawman -- it's much slower than the findall version."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Here's the currently accepted solution expressed in a standardised form and augmented with word delimiters:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def currently_accepted_solution_augmented(targets, paragraph):\n    def tester(s): \n        def f(x):\n            return len(re.findall(r\"\\b\" + x + r\"\\b\", s))\n        return f\n    return map(tester(paragraph), targets)\n</code>\n</pre>\n", "senID": 5}, {"text": ["which goes overboard on closures and could be reduced to:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n # acknowledgement:\n# this is structurally the same as one of hughdbrown's benchmark functions\ndef currently_accepted_solution_augmented_without_extra_closure(targets, paragraph):\n    def tester(x):\n        return len(re.findall(r\"\\b\" + x + r\"\\b\", paragraph))\n    return map(tester, targets)\n</code>\n</pre>\n", "senID": 7}, {"text": ["All variations on the currently accepted solution are O(PT).", "Unlike the currently accepted solution, the regex search with word delimiters is not equivalent to a simple paragraph.find(target).", "Because the re engine doesn't use the \"fast search\" in this case, adding the word delimiters changes it fron slow to very slow."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "paragraph.find(target)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "very", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}], [{"text": ["Here's my version.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n paragraph = \"I eat bananas and a banana\"\n\ndef tester(paragraph, x): return len(re.findall(x,paragraph))\n\nprint lambda paragraph: map(\n    lambda x: tester(paragraph, x) , ['banana', 'loganberry', 'passion fruit']\n        )(paragraph)\n</code>\n</pre>\n", "senID": 1}]]