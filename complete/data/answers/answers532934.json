[[{"text": ["Take a look at json, at least the generated dumps are readable with many other languages."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "json", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/json.html"}, {"text": "dumps", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Maybe you're not using the right protocol:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import pickle\n&gt;&gt;&gt; a = range(1, 100)\n&gt;&gt;&gt; len(pickle.dumps(a))\n492\n&gt;&gt;&gt; len(pickle.dumps(a, pickle.HIGHEST_PROTOCOL))\n206\n</code>\n</pre>\n", "senID": 1}, {"text": ["See the documentation for pickle data formats."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "pickle data formats", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/pickle.html#data-stream-format"}]}], [{"text": ["personally i would use yaml.", "it's on par with json for encoding size, but it can represent some more complex things (e.g.", "classes, recursive structures) when necessary. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "yaml", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyyaml.org/wiki/PyYAML"}]}, {"code": "<pre>\n<code>\n In [1]: import yaml\nIn [2]: x = [1, 2, 3, 'pants']\nIn [3]: print(yaml.dump(x))\n[1, 2, 3, pants]\n\nIn [4]: y = yaml.load('[1, 2, 3, pants]')\nIn [5]: y\nOut[5]: [1, 2, 3, 'pants']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you need a space efficient solution you can use Google Protocol buffers."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Protocol buffers - Encoding"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Protocol buffers - Encoding", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/apis/protocolbuffers/docs/encoding.html"}]}, {"text": ["Protocol buffers - Python Tutorial"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Protocol buffers - Python Tutorial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/apis/protocolbuffers/docs/pythontutorial.html"}]}], [{"text": ["\"the byte overhead is significant\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Why does this matter?", "It does the job.", "If you're running low on disk space, I'd be glad to sell you a 1Tb for $500.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Have you run it?", "Is performance a problem?", "Can you demonstrate that the performance of serialization is the problem?"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "the", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}, {"text": ["\"I thought of just using repr() and eval(), but is there a simple way I could accomplish this without using eval()?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Nothing simpler than repr and eval."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["What's wrong with eval?"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Is is the \"someone could insert malicious code into the file where I serialized my lists\" issue?"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Who -- specifically -- is going to find and edit this file to put in malicious code?", "Anything you do to secure this (i.e., encryption) removes \"simple\" from it.  "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["There are some persistence builtins mentioned in the python documentation but I don't think any of these is remarkable smaller in the produced filesize."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "python documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/persistence.html"}]}, {"text": ["You could alway use the configparser but there you only get string, int, float, bool."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "configparser", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/configparser.html"}]}], [{"text": ["Luckily there is solution which uses COMPRESSION, and solves \nthe general problem involving any arbitrary Python object \nincluding new classes.", "Rather than micro-manage mere \ntuples sometimes it's better to use a DRY tool.", "Your code will be more crisp and readily refactored \nin similar future situations. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["y_serial.py module :: warehouse Python objects with SQLite"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["\"Serialization + persistance :: in a few lines of code, compress and annotate Python objects into SQLite; then later retrieve them chronologically by keywords without any SQL.", "Most useful \"standard\" module for a database to store schema-less data."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://yserial.sourceforge.net"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://yserial.sourceforge.net", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://yserial.sourceforge.net"}]}, {"text": ["[If you are still concerned, why not stick those tuples in \na dictionary, then apply y_serial to the dictionary.", "Probably any overhead will vanish due to the transparent \ncompression in the background by zlib."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["As to readability, the documentation also gives details on \nwhy cPickle was selected over json."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]