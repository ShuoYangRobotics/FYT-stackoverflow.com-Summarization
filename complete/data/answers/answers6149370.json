[[{"text": ["List comprehension are very pythonic and the recommended way of doing this.", "Your code is fine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you want to have it in a single line you could do something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n first_list, second_list = [i for i in a if i[1] == 1], [i for i in a if i[1] == 0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Remember that, \"Explicit is better than implicit."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Your code is fine"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You can use sorted() and itertools.groupby() to do this, but I don't know that it would qualify as Pythonic per se:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sorted()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools.groupby()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dict((k, list(v)) for (k, v) in itertools.groupby(sorted(a, key=operator.itemgetter(1)), operator.itemgetter(1)))\n{0: [[3, 0]], 1: [[1, 1], [2, 1]]}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["what about this,  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In [1]: a = [[1, 1], [2, 1], [3, 0]]\n\nIn [2]: first_list = []\n\nIn [3]: second_list = []\n\nIn [4]: [first_list.append(i) if i[1] == 1 else second_list.append(i) for i in a]\nOut[4]: [None, None, None]\n\nIn [5]: first_list, second_list\nOut[5]: ([[1, 1], [2, 1]], [[3, 0]])\n</code>\n</pre>\n", "senID": 1}, {"text": ["instead of two sublist, I prefer dict (or defaultdict, OrderedDict, Counter, etc."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n In [6]: from collections import defaultdict\n\nIn [7]: d = defaultdict(list)\n\nIn [8]: [d[i[1]].append(i) for i in a]\nOut[8]: [None, None, None]\n\nIn [9]: d\nOut[9]: {0: [[3, 0]], 1: [[1, 1], [2, 1]]}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If the lists are reasonably short then two list comprehensions will do fine: you shouldn't be worried about performance until your code is all working and you know it is too slow."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If your lists are long or the code runs often and you have demonstrated that it is a bottleneck then all you have to do is switch from list comprehensions to a for loop:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "and", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n first_list, second_list = [], []\nfor element in a:\n    if element[1] == 1:\n        first_list.append(element)\n    else:\n        second_list.append(element)\n</code>\n</pre>\n", "senID": 2}, {"text": ["which is both clear and easily extended to more cases."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["list comprehensions are great.", "If you want slightly more simple code (but slightly longer) then just use a for loop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Yet another option would be filters and maps:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a = [[1, 1], [2, 1], [3, 0]]\ng1=filter(lambda i: i[1]==1,a)\ng1=map(lambda i: i[0],g1)\ng2=filter(lambda i: i[1]==0,a)\ng2=map(lambda i: i[0],g2)\nprint g1\nprint g2\n</code>\n</pre>\n", "senID": 2}]]