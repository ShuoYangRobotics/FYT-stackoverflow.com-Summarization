[[{"text": ["Try reading up on it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "reading", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Garbage%5Fcollection%5F%28computer%5Fscience%29"}]}], [{"text": ["That means that python user doesn't need to clean his dynamic created objects, like you're obligated to do it in C/C++."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Example in C++:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n char *ch = new char[100];\nch[0]='a';\nch[1]='b';\n//....\n// somewhere else in your program you need to release the alocated memory.\ndelete [] ch; \n// use *delete ch;* if you've initialized *ch with new char;\n</code>\n</pre>\n", "senID": 2}, {"text": ["in python:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def fun():\n    a=[1, 2] #dynamic allocation\n    a.append(3)\n    return a[0]\n</code>\n</pre>\n", "senID": 4}, {"text": ["python takes care about \"a\" object by itself."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["From Wikipedia http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Garbage%5Fcollection%5F%28computer%5Fscience%29"}]}, {"text": ["..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Garbage collection frees the programmer from manually dealing with memory allocation and deallocation.", "As a result, certain categories of bugs are eliminated or substantially reduced:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Garbage collection frees the programmer from manually dealing with memory allocation and deallocation. As a result, certain categories of bugs are eliminated or substantially reduced:", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": ["Dangling pointer bugs, which occur\nwhen a piece of memory is freed while\nthere are still pointers to it, and\none of those pointers is used."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Dangling pointer bugs, which occur\nwhen a piece of memory is freed while\nthere are still pointers to it, and\none of those pointers is used.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Double free bugs, which occur when\nthe program attempts to free aregion of memory that is alreadyfree."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "Double free bugs, which occur when\nthe program attempts to free aregion of memory that is alreadyfree.", "childNum": 2, "tag": "em", "pos": 0, "childList": [{"text": "", "tag": "br"}, {"text": "", "tag": "br"}]}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["Certain kinds of memory leaks, in\nwhich a program fails to freememory that is no longer referencedby any variable, leading, over time,\nto memory exhaustion."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "Certain kinds of memory leaks, in\nwhich a program fails to freememory that is no longer referencedby any variable, leading, over time,", "childNum": 2, "tag": "em", "pos": 0, "childList": [{"text": "", "tag": "br"}, {"text": "", "tag": "br"}]}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}]}, {"text": ["..."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["The basic principles of garbage collection are:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "The basic principles of garbage collection are:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Others already answered the main question, but I'd like to add that garbage collection is possible in C++.", "It's not that automatic like Python's, but it's doable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Smart pointers are probably the simplest form of C++ garbage collecting - std::auto_ptr, boost::scoped_ptr, boost::scoped_array that release memory after being destroyed.", "There's an example in one of the earlier answers, that could be rewritten as:"], "childNum": 6, "tag": "p", "senID": 1, "childList": [{"text": "std::auto_ptr", "tag": "a", "pos": 0, "childList": [{"text": "std::auto_ptr", "tag": "code"}], "childNum": 1, "href": "http://www.cplusplus.com/reference/std/memory/auto%5Fptr/"}, {"text": "std::auto_ptr", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "boost::scoped_ptr", "tag": "a", "pos": -1, "childList": [{"text": "boost::scoped_ptr", "tag": "code"}], "childNum": 1, "href": "http://www.boost.org/doc/libs/1%5F40%5F0/libs/smart%5Fptr/scoped%5Fptr.htm"}, {"text": "boost::scoped_ptr", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "boost::scoped_array", "tag": "a", "pos": -1, "childList": [{"text": "boost::scoped_array", "tag": "code"}], "childNum": 1, "href": "http://www.boost.org/doc/libs/1%5F40%5F0/libs/smart%5Fptr/scoped%5Farray.htm"}, {"text": "boost::scoped_array", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n boost::scoped_array&lt;char&gt; ch(new char[100]);\nch[0] = 'a';\nch[1] = 'b';\n// ...\n// boost::scoped_array will be destroyed when out of scope, or during unwind\n// (i.e. when exception is thrown), releasing the array's memory\n</code>\n</pre>\n", "senID": 2}, {"text": ["There are also boost::shared_ptr, boost::shared_array that implement reference counting (like Python).", "And there are full-blown garbage collectors that are meant to replace standard memory allocators, e.g.", "Boehm gc."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "boost::shared_ptr", "tag": "a", "pos": 0, "childList": [{"text": "boost::shared_ptr", "tag": "code"}], "childNum": 1, "href": "http://www.boost.org/doc/libs/1%5F40%5F0/libs/smart%5Fptr/shared%5Fptr.htm"}, {"text": "boost::shared_ptr", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "boost::shared_array", "tag": "a", "pos": -1, "childList": [{"text": "boost::shared_array", "tag": "code"}], "childNum": 1, "href": "http://www.boost.org/doc/libs/1%5F40%5F0/libs/smart%5Fptr/shared%5Farray.htm"}, {"text": "boost::shared_array", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Boehm gc", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.hpl.hp.com/personal/Hans%5FBoehm/gc/"}]}], [{"text": ["It basically means the way they handle memory resources.", "When you need memory you usually ask for it to the OS and then return it back."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["With python you don't need to worry about returning it, with C++ you need to track what you asked and return it back, one is easier, the other performant, you choose your tool."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["As you have got your answer, now it's better to know the cons of automated garbage collection:\nit requires large amounts of extra memory and not suitable for hard real-time deadline applications."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]