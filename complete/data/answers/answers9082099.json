[[{"text": ["Change line 14 to:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n words = re.findall('\\w+', open(os.path.join(root, file)).read().lower())\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also, if you replace the input line with"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n path = raw_input(\"Enter file and path\")\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then you won't need to include ' before and after the path"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["When iterating the results of os.walk, file will contain just the filename without the directory containing it.", "You need to join the directory name with the filename:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "os.walk", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "file", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n for root, dirs, files in os.walk(path):\n    for name in files:\n        file_path = os.path.join(root, name)\n        #do processing on file_path here\n</code>\n</pre>\n", "senID": 1}, {"text": ["I recommend moving the code that processes a file to its own function - this way you won't need to write it twice, and it will be easier to debug problems."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It looks like the parameter for the function definition is wrong.", "It should be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def search(path):\n</code>\n</pre>\n", "senID": 1}, {"text": ["The ignore is correct but can be made faster by using a set instead of a list:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "ignore", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n ignore = set(['the','a','if','in','it','of','or','on','and','to'])\n</code>\n</pre>\n", "senID": 3}, {"text": ["Otherwise, this is nice looking code :-)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Change to:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for file in files:\n    fullPath=\"%s/%s\"%(path,file)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It's because the \"files\" list only contains the file names, not the full paths.", "You have to use :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["import os.path "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["and replace \"open(file)\" by \"open(os.path.join(root,file))\"."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I suggest looking at generator tricks for system programmers by David M. Beazley.", "it shows how to create little generator loops to do everything you have here.", "Basically, using the gengrep example, but replacing grep with word counting:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "generator tricks for system programmers by David M. Beazley", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/generators-uk/index.html"}, {"text": "gengrep", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/generators-uk/gengrep.py"}]}, {"code": "<pre>\n<code>\n # gencount.py\n#\n# Count the words in  a sequence of lines\n\nimport re, collections\ndef gen_count(lines):\n    patc = re.compile('\\w+')\n    ignore = ['the','a','if','in','it','of','or','on','and','to']\n    for line in lines:\n        words = patc.findall(line)\n        counter=collections.Counter(x for x in words if x not in ignore)\n        for count in counter.most_common(10):\n            yield count\n\n# Example use\n\nif __name__ == '__main__':\n    from genfind import  gen_find\n    from genopen import  gen_open\n    from gencat  import  gen_cat\n    path = raw_input(\"Enter file and path, place ' before and after the file path: \")\n\n    findnames = gen_find(\"*.txt\",path)\n    openfiles = gen_open(findnames)\n    alllines = gen_cat(openfiles)\n\n    currcount = gen_count(alllines)\n    for c in currcount:\n        print c\n</code>\n</pre>\n", "senID": 1}], [{"tag": "ul", "num": 4, "lis": [{"text": "You should have two functions: one that goes through a file and counts the words, and another that goes through the files in a directory and recursively calls itself when it finds directories. The per-file function should take a full path to the file and open the file itself.", "tag": "none", "senID": 0}, {"text": "Reading the whole file in at once might run you out of memory. A line-by-line approach is better. Even better than that would be to write a generator function that reads, say, 4K at a time and outputs individual words, but that might be going overboard for this assignment.", "tag": "none", "senID": 1}, {"text": "Look at ", "tag": "none", "senID": 2}, {"text": "Use ", "tag": "none", "senID": 3}]}]]