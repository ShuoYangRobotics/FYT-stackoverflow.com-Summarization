[[{"text": ["You want a native python dictionary."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(and you probably also want your values to start from\"0\" not from \"1\" , so you can void adding a +1 on all your mappings, as bellow)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Build one with this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import string\nvalues = dict()\nfor index, letter in enumerate(string.ascii_lowercase):\n   values[letter] = index + 1\n</code>\n</pre>\n", "senID": 3}, {"text": ["This give syou things like:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n print values[\"a\"]\n-&gt; 1\n</code>\n</pre>\n", "senID": 5}, {"text": ["Of course,  you probably could use the \"ord\"  built-in function and skip this dictionary altogether, as in the other answers:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n print ord(\"c\") - (ord(\"a\")) + 1\n</code>\n</pre>\n", "senID": 7}, {"text": ["Or in python 3.x or 2.7, you can create the dicionary in a single pass with a dict generator expression:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n values = {chr(i): i + 1 for i in range(ord(\"a\"), ord(\"a\") + 26)}\n</code>\n</pre>\n", "senID": 9}], [{"text": ["If you just want to map characters of the ASCII alphabet to numbers, you can use ord() and then adjust the result:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ord()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; ord('a') - 96\n1\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want this to work for uppercase letters too:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; ord('A'.lower()) - 96\n1\n</code>\n</pre>\n", "senID": 3}, {"text": ["Also, you might want to validate that the argument is indeed a single ASCII character:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; char = 'a'\n&gt;&gt;&gt; len(char) == 1 and char.isalpha() and 'a' &lt;= char &lt;= 'z'\nTrue\n</code>\n</pre>\n", "senID": 5}, {"text": ["Or:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import string\n&gt;&gt;&gt; len(char) == 1 and char in string.ascii_lowercase\nTrue\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Use a dictionary for key:value pairs.", "Although for a simple mapping like this there are probably some clever ways of doing this. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dictionary", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#dictionaries"}]}], [{"code": "<pre>\n<code>\n def value(letter):\n    return ord(letter) - ord('a') + 1\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n from itertools import count\nfrom string import lowercase\nvalue = dict(zip(lowercase, count(1))).get\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You should exploit the fact that 'a', 'b', etc.", "have ASCII values behind them."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ord('a') # this returns int 97\nord('b') # this returns int 98\n</code>\n</pre>\n", "senID": 1}, {"text": ["Therefore, you could do something like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ord(letter) - ord('a') + 1 # e.g., a: 97 - 97 + 1 = 1\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Why not just make a list of each letter in the alphabet and then use the index values as the return value"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["How about this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import string\nvalue = lambda x: string.ascii_lowercase.index(x) + 1\n\nIn [1]: value(\"a\")\nOut[1]: 1\n</code>\n</pre>\n", "senID": 1}]]