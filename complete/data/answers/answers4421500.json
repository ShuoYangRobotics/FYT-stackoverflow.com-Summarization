[[{"text": ["Use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n L = [x for x in L if x not in removal_list]\n</code>\n</pre>\n", "senID": 1}, {"text": ["removal_list can be any container, but if you use a set() or a frozenset() you will achieve O(n) (with n = len(L))."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This sounds like a job for filter():"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "filter()", "tag": "a", "pos": 0, "childList": [{"text": "filter()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#filter"}, {"text": "filter()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; filter(lambda x: not x in (4, 5, 7), xrange(10))\n[0, 1, 2, 3, 6, 8, 9]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Update: one more example where I construct a list using list comprehension:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://docs.python.org/howto/functional.html", "text": "list comprehension", "childNum": 1, "tag": "a", "childList": [{"text": "list comprehension", "tag": "em"}]}, {"text": "list comprehension", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; filter(lambda x: not x[0] in (4, 5, 7), [[a] for a in xrange(10)])\n[[0], [1], [2], [3], [6], [8], [9]]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Slice replacement:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a[:] = ( l for l in a if l not in set(list_of_removable))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Pythons not my area, but some things spring to mind.", "First, how big is the list, because you are going to iterate over it a number of times.", "If it's large it might be a better idea to flip things around so you only iterate over it once. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Second, if Python is like Java, then there is a rule for good code - Do not use exceptions for process flow.", "This rules out your second suggestion.", "It's also likely that it will perform badly."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Like Giovanni Bajo suggests, list comprehension is cool, but assuming you'll use the result only once, generators are even better:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = [1,23,2,24,3,26,1]\n(x for x in l if x not in xrange(10))\n</code>\n</pre>\n", "senID": 1}, {"text": ["xrange() is a generator as well and is faster than range()\nIf you want to use the result more than once I'd go for:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "xrange()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "range()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n [x for x in l if x not in xrange(10)]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["To answer the original question: There is no getting around the fact that you will have to compare each element of the list-to-remove-elements-from to each element of the list-containing-removable-elements.", "So in that sense, every version of this code is O(N^2) (assuming we can have arbitrarily many elements in each list).", "You can hide the loops by using a variety of constructs (and in many cases it will be faster, because the looping can be done \"internally\" in the C code of the interpreter rather than by interpreting more bytecode), but the loops are still there (and remember that constant factors are ignored by big-O analysis)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]