[[{"text": ["Hmmm, seems weird, but possible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Sounds like you need a class which records the time when __init__ is called.", "Then, implement __getitem__ to check the time when it is called, and only return the item if it's not too late.", "(It's probably easier to do this than to have a process \"running in the background\" which actively deletes items even when you don't ask for them."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__getitem__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I actually had to do this for dictionaries.", "Maybe you'll find the code useful:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \"\"\"Cache which has data that expires after a given period of time.\"\"\"\nfrom datetime import datetime, timedelta\n\nclass KeyExpiredError(KeyError): pass \n\ndef __hax():\n    class NoArg: pass\n    return NoArg()\nNoArg = __hax()\n\nclass DataCache(object):\n    def __init__(self, defaultExpireTime=timedelta(1, 0, 0), dbg=True):\n        self.defaultExpireTime = defaultExpireTime\n\n        self.cache = {}\n        self.dbg = dbg\n\n        self.processExpires = True\n\n    def setProcessExpires(self, b):\n        self.processExpires = b\n\n    def __getitem__(self, key):\n        c = self.cache[key]\n\n        n = datetime.now()\n        if (n - c['timestamp']) &lt; c['expireTime'] or not self.processExpires:\n            return c['data']\n\n        del self.cache[key]\n\n        if self.dbg:\n            print \"DataCache: Key %s expired\" % repr(key)\n\n        raise KeyExpiredError(key)\n\n    def __contains__(self, key):\n        try:\n            self[key]\n            return True\n        except KeyError:\n            return False\n\n    def __setitem__(self, key, val):\n        self.cache[key] = {\n            'data': val,\n            'timestamp': datetime.now(),\n            'expireTime': self.defaultExpireTime,\n            }\n\n    def items(self):\n        keys = list(self.cache)\n        for k in keys:\n            try:\n                val = self[k]\n                yield (k, val)                                             \n            except:\n                pass\n\n    def get(self, key, default=NoArg, expired=NoArg):\n        try:\n            return self[key]\n        except KeyExpiredError:\n            if expired is NoArg and default is not NoArg:\n                return default\n            if expired is NoArg: return None\n            return expired\n        except KeyError:\n            if default is NoArg: return None\n            return default\n\n    def set(self, key, val, expireTime=None):\n        if expireTime is None:\n            expireTime = self.defaultExpireTime\n\n        self.cache[key] = {\n            'data': val,\n            'timestamp': datetime.now(),\n            'expireTime': expireTime,\n            }\n\n    def tryremove(self, key):\n        if key in self.cache:\n            del self.cache[key]\n            return True\n        return False\n\n    #the following you can call without triggering any expirations\n    def getTotalExpireTime(self, key):\n        \"\"\"Get the total amount of time the key will be in the cache for\"\"\"\n        c = self.cache[key]\n        return c['expireTime']\n\n    def getExpirationTime(self, key):\n        \"\"\"Return the datetime when the given key will expire\"\"\"\n        c = self.cache[key]\n        return c['timestamp'] + c['expireTime']\n\n    def getTimeRemaining(self, key):\n        \"\"\"Get the time left until the item will expire\"\"\"\n        return self.getExpirationTime(key) - datetime.now()\n\n    def getTimestamp(self, key):\n        return self.cache[key]['timestamp']\n\n    def __len__(self):\n        return len(self.cache)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dc = DataCache(timedelta(0, 5, 0)) #expire in 5 seconds\n&gt;&gt;&gt; dc[4] = 3\n&gt;&gt;&gt; dc[4]\n3\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; time.sleep(5)\n&gt;&gt;&gt; dc[4]\nDataCache: Key 4 expired\nTraceback (most recent call last):\n  File \"&lt;pyshell#5&gt;\", line 1, in &lt;module&gt;\n    dc[4]\n  File \"datacache.py\", line 35, in __getitem__\n    raise KeyExpiredError(key)\nKeyExpiredError: 4\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}], [{"text": ["It sounds like the items in your array know about each other, because otherwise they'll all expire at the same time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I think you want to create a subclass of list which deletes its contents after a certain time."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["you can create a background process that check how much time it's passed, and del the right item... or if you want to create a subclass of list wich deletes it's contens after a certain time you can do the same thing, just calling it in init "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "init", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def __init__(self, time):\n    #run subprocess to chek_espired elements\n</code>\n</pre>\n", "senID": 1}, {"text": ["edit:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["i wrote an example, but it can be done much better!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class MyList(list):\n    def __init__(self,elems,  expires_time):\n        list.__init__(self, elems)\n        self.created = time.time()\n        self.expires_time = expires_time\n    def __getitem__(self, index):\n        t = time.time()\n        print t -  self.created\n        if t - self.created &gt; self.expires_time:\n            self.created += self.expires_time\n            self.pop(index)\n            self.__getitem__(index)\n        return list.__getitem__(self, index)\n</code>\n</pre>\n", "senID": 4}, {"text": ["ps of course you can easily raise a personal error if the program try to get the index from an empty list"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"code": "<pre>\n<code>\n import sched\nimport time\nimport threading\n\na = [1, 2, 3, 4, 5, 6]\n\nscheduler = sched.scheduler(time.time, time.sleep)\n\ndef delete(_list):\n    del _list[0]\n\nfor i in range(len(a)):\n    scheduler.enter(60*10*i, 1, delete, (a,))\n\nt = threading.Thread(target=scheduler.run)\n\nt.start()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You can use the time module to clear the \"array\" every 10 minutes, by checking the time interval from when the script starts. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "time", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The last example on http://effbot.org/librarybook/time.htm point you in the right direction."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://effbot.org/librarybook/time.htm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://effbot.org/librarybook/time.htm"}]}]]