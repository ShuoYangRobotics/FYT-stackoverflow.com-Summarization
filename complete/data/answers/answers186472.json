[[{"text": ["With the existence of the following syntax:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import some_other_module as some_module\n</code>\n</pre>\n", "senID": 1}, {"text": ["the maintainability argument of style 2 is no longer relevant."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I tend to use style 1.", "Normally, I find that I explicitly reference the imported package name only a few times in a typical Python program.", "Everything else is methods on the object, which of course don't need to reference the imported package."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["There are uses for both cases, so I don't think this is an either-or issue.", "I'd consider using from module import x,y,z when:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "import x,y,z", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": ["There are a fairly small number of things to import"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The purpose of the functions imported is obvious when divorced from the module name.", "If the names are fairly generic, they may clash with others and tell you little.", "eg.", "seeing remove tells you little, but os.remove will probably hint that you're dealing with files."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "remove", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "os.remove", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The names don't clash.", "Similar to the above, but more important.", "Never do something like:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Never", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}]}, {"text": ["import module [as renamed_module] has the advantage that it gives a bit more context about what is being called when you use it.", "It has the disadvantage that this is a bit more cluttered when the module isn't really giving more information, and is slightly less performant (2 lookups instead of 1)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "import module [as renamed_module]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["It also has advantages when testing however (eg.", "replacing os.open with a mock object, without having to change every module), and should be used when using mutable modules, e.g."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import config\nconfig.dburl = 'sqlite:///test.db'\n</code>\n</pre>\n", "senID": 6}, {"text": ["If in doubt, I'd always go with the import module style."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "import module", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I usually use a threshold to decide this.", "If I want to use a lot of things within some_module, I'll use:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "some_module", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import some_module as sm\nx = sm.whatever\n</code>\n</pre>\n", "senID": 1}, {"text": ["If there's only one or two things I need:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from some_module import whatever\nx = whatever\n</code>\n</pre>\n", "senID": 3}, {"text": ["That's assuming I don't need a whatever from some_other_module, of course."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "whatever", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "some_other_module", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I tend to use the as clause on the imports so that I can reduce my typing and substitue another module quite easily in the future."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "as", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "and", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["I find that the notation"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from some_module import some_symbol\n</code>\n</pre>\n", "senID": 1}, {"text": ["works best in most cases.", "Also, in case of name clash for the symbol, you can use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from some_module import some_symbol as other_symbol\n</code>\n</pre>\n", "senID": 3}, {"text": ["As the question states, it avoids rewriting the module name all the time, each time with a risk of mistyping it.", "I use the syntax:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import  module [as other_module]\n</code>\n</pre>\n", "senID": 5}, {"text": ["Only in two cases:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I prefer to import X and then use X.a as much as possible."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "import X", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "X.a", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["My exception centers on the deeply nested modules in a big framework like Django.", "Their module names tend to get lengthy, and their examples all say from django.conf import settings to save you typing django.conf.settings.DEBUG everywhere."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "from django.conf import settings", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "django.conf.settings.DEBUG", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If the module name is deeply nested, then the exception is to use from X.Y.Z import a."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "from X.Y.Z import a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I believe in newer pythons (2.5+?", "must check my facts...) you can even do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import some_other_module as some_module\n</code>\n</pre>\n", "senID": 1}, {"text": ["So you could still go with style 1 and swap in a different module later on."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I think it generally maps to how much you want to clutter up your namespace.", "Will you just be using one or two names in the module?", "Or all of them (from x import * is not allways bad, just generally)? "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "from x import *", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["I personally try not to mess too much with my namespace, so in most situations I just do  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import module\n</code>\n</pre>\n", "senID": 1}, {"text": ["or \n    import module as mod"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Only real diffrence is when I have a module with a single class that's used a lot.", "If I had sublclassed a list type to add some funcionality there, I'd use"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from SuperImprovedListOverloadedWithFeatures import NewLIst\nnl = NewList()\n</code>\n</pre>\n", "senID": 4}, {"text": ["etc."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I tend to use only a few members of each module, so there's a lot of"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from john import cleese\nfrom terry import jones, gilliam\n</code>\n</pre>\n", "senID": 1}, {"text": ["in my code.", "I'll import whole modules (such as os or wx) if I expect to be using most of the module and the module name is short.", "I'll also import whole modules if there is a name conflict or I want to remind the reader what that function is associated with."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "os", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "wx", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import michael\nimport sarah\n\nimport wave\n\ngov_speech = wave.open(sarah.palin.speechfile)\nparrot_sketch = wave.open(michael.palin.justresting)\n</code>\n</pre>\n", "senID": 3}, {"text": ["(I could use from wave import open as wave_open, but I figure that wave.open will be more familiar to the reader."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "from wave import open as wave_open", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "wave.open", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You mey be interested in this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Why &#39;import x;x.y&#39; behaves different from &#39;from x import y&#39;, and 1st one fails when package x.__init__ is not completed?"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Why &#39;import x;x.y&#39; behaves different from &#39;from x import y&#39;, and 1st one fails when package x.__init__ is not completed?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/6386061/why-import-xx-y-behaves-different-from-from-x-import-y-and-1st-one-fails-wh"}]}]]