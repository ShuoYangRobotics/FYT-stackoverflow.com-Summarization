[[{"text": ["If I understand your problem correctly then the following should work assuming that your points are also 2-tuples."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def in_bin(point, lower_corner, upper_corner):\n    \"\"\"\n    lower_corner is a 2-tuple - the coords of the lower left hand corner of the\n    bin.\n    upper_corner is a 2-tuple - the coords of the upper right hand corner of the\n    bin.\n    \"\"\"\n    return lower_corner &lt;= point &lt;= upper_corner\n\nif __name__ == '__main__':\n    p_min = (1, 1) # lower left corner of bin\n    p_max = (5, 5) # upper right corner of bin\n\n    p1 = (3, 3) # inside\n    p2 = (1, 0) # outside\n    p3 = (5, 6) # outside\n    p4 = (1, 5) # inside\n\n    points = [p1, p2, p3, p4]\n\n    for p in points:\n        print '%s in bin: %s' % (p, in_bin(p, x_min, x_max))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This code shows that you can compare tuples directly - there is some information in the documentation about this: http://docs.python.org/tutorial/datastructures.html#comparing-sequences-and-other-types"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://docs.python.org/tutorial/datastructures.html#comparing-sequences-and-other-types", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#comparing-sequences-and-other-types"}]}], [{"text": ["Without too much change, your code can be compacted down to:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def isInside(self, point, x0, x1, y0, y1):\n    return getProduct(point, (x0, y0), (x1, y0)) &gt;= 0 and\n           getProduct(point, (x1, y0), (x1, y1)) &gt;= 0 and\n           getProduct(point, (x1, y1), (x0, y1)) &gt;= 0 and\n           getProduct(point, (x0, y1), (x0, y0)) &gt;= 0\n\ndef getProduct(origin, pointA, pointB):\n    product = (pointA[0] - origin[0])*(pointB[1] - origin[1]) - (pointB[0] - origin[0])*(pointA[1] - origin[1])\n    return product\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Your solution is O(N) where N is number of points.", "If N is large enough and you are running the query isInside a lot of times, you might considering sorting the points and then using binary search in order to find the relevant points."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "O(N)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "isInside", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["As always, first profile whether you really need this optimisation."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Are you sure you need such a complicated check to begin with?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def isInside(self, point, x0, y0, x1, y1):\n  x,y = point\n  if x0 &gt; x1: x0,x1 = x1,x0 #these cause no\n  if y0 &gt; y1: y0,y1 = y1,y0 #side effect.\n\n  return x0 &lt;= x &lt;= x1 and y0 &lt;= y &lt;= y1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I used a similar routine to do colourmapped density plots:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #calculate densities\nrho = zeros((nx,ny));\nfor i in range(N):\n    x_sample = int(round(ix[i]))\n    y_sample = int(round(iy[i]))\n\n    if (x_sample &gt; 0) and (y_sample &gt; 0) and (x_sample&lt;nx) and (y_sample&lt;ny):\n        rho[y_sample,x_sample] = rho[y_sample,x_sample] + 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Instead of counting density you can store the x and y samples."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you really do need to use getProduct... packing, unpacking and good variable names ftw!"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "getProduct", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def isInside(self, point, x0, x1, y0, y1):\n    A = x0,y0\n    B = x1,y0\n    C = x1,y1\n    D = x0,y1\n\n    return getProduct(point, A, B) and\n           getProduct(point, B, C) and\n           getProduct(point, C, D) and\n           getProduct(point, D, A)\n\ndef getProduct(origin, pointA, pointB):\n    xA,yA = pointA\n    xB,yB = pointB\n    x,y = point\n\n    return (xA - x)*(yB - y) - (xB - x)*(yB - y)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Are these boxes axis aligned?", "i.e.", "are the edges parallel to the coordinate axes?", "If so this can be done quite efficiently with vectorized comparisons on NumPy arrays. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def in_box(X, B):\n    \"\"\"\n    Takes an Nx2 NumPy array of points and a 4x2 NumPy array of corners that \n    form an axis aligned box.\n    \"\"\"\n    xmin = B[:,0].min(); xmax = B[:,0].max()\n    ymin = X[:,1].min(); ymax = X[:,1].max()\n    return X[X[:,0] &gt; xmin &amp; X[:,0] &lt; xmax &amp; X[:,1] &gt; ymin &amp; X[:,1] &lt; ymax]\n</code>\n</pre>\n", "senID": 1}, {"text": ["amending to >= and &lt;= if you prefer them to be inclusive. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you need it for an arbitrary quadrilateral, matplotlib actually has a routine matplotlib.nxutils.points_inside_poly that you could use (if you have it installed) or else copy it (it's BSD-licensed).", "See this page for a discussion of the algorithms used and other algorithms for inside-a-polygon tests."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "matplotlib", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "matplotlib.nxutils.points_inside_poly", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "this page", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html"}]}], [{"text": ["Assuming that your boxes are rectangular, do not overlap, and have no gaps, then why don't you just call numpy.histogram2d?", "See the numpy docs."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "numpy.histogram2d", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "the numpy docs", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram2d.html"}]}]]