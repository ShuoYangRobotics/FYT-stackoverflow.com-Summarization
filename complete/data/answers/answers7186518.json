[[{"text": ["Recursion will be your best bet.", "Consider what it should do in the base case and in the recursive case."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Code left out, as per request."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This problem can be solved by recursion.", "I am just writing an algorithm here, since I believe this can be a general problem. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n function Recurse (y, number) \n   if (number &gt; 1)\n      Recurse ( y, number - 1 )\n   else\n      for x in range (y)\n      whatever()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["this can be done without recursion using itertools.product"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.product", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\ndef function(n):\n    for x in itertools.product(range(n),repeat=n):\n        whatever()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm not clear why you can't use the product of the bounds and do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for x in range(y exp n)\n</code>\n</pre>\n", "senID": 1}, {"text": ["where n is the # of loops.... You say y exp n will be huge, but I'm sure python can handle it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["However, that being said, what about some sort of recursive algorithm?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def loop_rec(y, n):\n    if n &gt;= 1:\n        for x in range(y):\n            loop_rec(y, n - 1)\n    else:\n       whatever()\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Here you go.", "Let ranges be your ranges, operate on result when you need to."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ranges=((1,4),(0,3),(3,6))\nfrom operator import mul\noperations=reduce(mul,(p[1]-p[0] for p in ranges))-1\nresult=[i[0] for i in ranges]\npos=len(ranges)-1\nincrements=0\nprint result\nwhile increments &lt; operations:\n    if result[pos]==ranges[pos][1]-1:\n        result[pos]=ranges[pos][0]\n        pos-=1\n    else:\n        result[pos]+=1\n        increments+=1\n        pos=len(ranges)-1 #increment the innermost loop\n        print result\n\n[1, 0, 3]\n[1, 0, 4]\n[1, 0, 5]\n[1, 1, 3]\n[1, 1, 4]\n[1, 1, 5]\n[1, 2, 3]\n[1, 2, 4]\n[1, 2, 5]\n[2, 0, 3]\n[2, 0, 4]\n[2, 0, 5]\n[2, 1, 3]\n[2, 1, 4]\n[2, 1, 5]\n[2, 2, 3]\n[2, 2, 4]\n[2, 2, 5]\n[3, 0, 3]\n[3, 0, 4]\n[3, 0, 5]\n[3, 1, 3]\n[3, 1, 4]\n[3, 1, 5]\n[3, 2, 3]\n[3, 2, 4]\n[3, 2, 5]\n[1, 0, 4]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Testing with the following would give the same result:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for x in range(*ranges[0]):\n    for y in range(*ranges[1]):\n        for z in range(*ranges[2]):\n            print [x,y,z]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Have you considered xrange ?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for x in xrange(y ** n):\n    whatever()\n</code>\n</pre>\n", "senID": 1}, {"text": ["And if you overshoot even xrange limit, you can use itertool"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import itertools\nfor x in itertools.product(xrange(y), repeat=n):\n   whatever()\n</code>\n</pre>\n", "senID": 3}, {"text": ["(previous itertool answer incorrectly used n for the range instead of y)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]