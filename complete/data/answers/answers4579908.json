[[{"text": ["Someone said \"use os.path.split\".", "This got deleted unfortunately, but it is the right answer."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "os.path.split", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So it's not just splitting the dirname and filename.", "You can apply it several times to get the full path in a portable and correct way."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Please credit the original author if that answer gets undeleted."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Use the functionality provided in os.path, e.g."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "os.path", "tag": "a", "pos": 0, "childList": [{"text": "os.path", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/os.path.html"}, {"text": "os.path", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n os.path.split(path)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Like written elsewhere you can call it multiple times to split longer paths."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The OP specified \"will work with Windows paths too\".", "There are a few wrinkles with Windows paths."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Firstly, Windows has the concept of multiple drives, each with its own current working directory, and 'c:foo' and 'c:\\\\foo' are often not the same.", "Consequently it is a very good idea to separate out any drive designator first, using os.path.splitdrive().", "Then reassembling the path (if required) can be done correctly by\ndrive + os.path.join(*other_pieces)"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "'c:foo'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'c:\\\\foo'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "drive + os.path.join(*other_pieces)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Secondly, Windows paths can contain slashes or backslashes or a mixture.", "Consequently, using os.sep when parsing an unnormalised path is not useful."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "os.sep", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["More generally:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The results produced for 'foo' and 'foo/' should not be identical."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "'foo'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'foo/'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The loop termination condition seems to be best expressed as \"os.path.split() treated its input as unsplittable\"."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Here's a suggested solution, with tests, including a comparison with @Spacedman's solution"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import os.path\n\ndef os_path_split_asunder(path, debug=False):\n    parts = []\n    while True:\n        newpath, tail = os.path.split(path)\n        if debug: print repr(path), (newpath, tail)\n        if newpath == path:\n            assert not tail\n            if path: parts.append(path)\n            break\n        parts.append(tail)\n        path = newpath\n    parts.reverse()\n    return parts\n\ndef spacedman_parts(path):\n    components = [] \n    while True:\n        (path,tail) = os.path.split(path)\n        if tail == \"\":\n            components.reverse()\n            return components\n        components.append(tail)\n\nif __name__ == \"__main__\":\n    tests = [\n        '',\n        'foo',\n        'foo/',\n        'foo\\\\',\n        '/foo',\n        '\\\\foo',\n        'foo/bar',\n        '/',\n        'c:',\n        'c:/',\n        'c:foo',\n        'c:/foo',\n        'c:/users/john/foo.txt',\n        '/users/john/foo.txt',\n        'foo/bar/baz/loop',\n        'foo/bar/baz/',\n        '//hostname/foo/bar.txt',\n        ]\n    for i, test in enumerate(tests):\n        print \"\\nTest %d: %r\" % (i, test)\n        drive, path = os.path.splitdrive(test)\n        print 'drive, path', repr(drive), repr(path)\n        a = os_path_split_asunder(path)\n        b = spacedman_parts(path)\n        print \"a ... %r\" % a\n        print \"b ... %r\" % b\n        print a == b\n</code>\n</pre>\n", "senID": 7}, {"text": ["and here's the output (Python 2.7.1, Windows 7 Pro):"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n Test 0: ''\ndrive, path '' ''\na ... []\nb ... []\nTrue\n\nTest 1: 'foo'\ndrive, path '' 'foo'\na ... ['foo']\nb ... ['foo']\nTrue\n\nTest 2: 'foo/'\ndrive, path '' 'foo/'\na ... ['foo', '']\nb ... []\nFalse\n\nTest 3: 'foo\\\\'\ndrive, path '' 'foo\\\\'\na ... ['foo', '']\nb ... []\nFalse\n\nTest 4: '/foo'\ndrive, path '' '/foo'\na ... ['/', 'foo']\nb ... ['foo']\nFalse\n\nTest 5: '\\\\foo'\ndrive, path '' '\\\\foo'\na ... ['\\\\', 'foo']\nb ... ['foo']\nFalse\n\nTest 6: 'foo/bar'\ndrive, path '' 'foo/bar'\na ... ['foo', 'bar']\nb ... ['foo', 'bar']\nTrue\n\nTest 7: '/'\ndrive, path '' '/'\na ... ['/']\nb ... []\nFalse\n\nTest 8: 'c:'\ndrive, path 'c:' ''\na ... []\nb ... []\nTrue\n\nTest 9: 'c:/'\ndrive, path 'c:' '/'\na ... ['/']\nb ... []\nFalse\n\nTest 10: 'c:foo'\ndrive, path 'c:' 'foo'\na ... ['foo']\nb ... ['foo']\nTrue\n\nTest 11: 'c:/foo'\ndrive, path 'c:' '/foo'\na ... ['/', 'foo']\nb ... ['foo']\nFalse\n\nTest 12: 'c:/users/john/foo.txt'\ndrive, path 'c:' '/users/john/foo.txt'\na ... ['/', 'users', 'john', 'foo.txt']\nb ... ['users', 'john', 'foo.txt']\nFalse\n\nTest 13: '/users/john/foo.txt'\ndrive, path '' '/users/john/foo.txt'\na ... ['/', 'users', 'john', 'foo.txt']\nb ... ['users', 'john', 'foo.txt']\nFalse\n\nTest 14: 'foo/bar/baz/loop'\ndrive, path '' 'foo/bar/baz/loop'\na ... ['foo', 'bar', 'baz', 'loop']\nb ... ['foo', 'bar', 'baz', 'loop']\nTrue\n\nTest 15: 'foo/bar/baz/'\ndrive, path '' 'foo/bar/baz/'\na ... ['foo', 'bar', 'baz', '']\nb ... []\nFalse\n\nTest 16: '//hostname/foo/bar.txt'\ndrive, path '' '//hostname/foo/bar.txt'\na ... ['//', 'hostname', 'foo', 'bar.txt']\nb ... ['hostname', 'foo', 'bar.txt']\nFalse\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Use the functionality provided in os.path, e.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n os.path.split(path)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(This answer was by someone else and was mysteriously and incorrectly deleted, since it's a working answer; if you want to split each part of the path apart, you can call it multiple times, and each call will pull a component off of the end."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["So keep using os.path.split until you get to what you want.", "Here's an ugly implementation using an infinite loop:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os.path\ndef parts(path):\n    components = [] \n    while True:\n        (path,tail) = os.path.split(path)\n        if tail == \"\":\n            components.reverse()\n            return components\n        components.append(tail)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Stick that in parts.py, import parts, and voila:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; parts.parts(\"foo/bar/baz/loop\")\n['foo', 'bar', 'baz', 'loop']\n</code>\n</pre>\n", "senID": 3}, {"text": ["Probably a nicer implementation using generators or recursion out there..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The os.path module offers a constant sep that that you can use with your algorithm:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "os.path", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sep", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import os.path\n&gt;&gt;&gt; path = \"/foo/bar/baz/file\"\n&gt;&gt;&gt; path_split = path.rsplit(os.path.sep)[1:]\n&gt;&gt;&gt; path_split\n['foo', 'bar', 'baz', 'file']\n</code>\n</pre>\n", "senID": 1}, {"text": ["In case you want to anticipate irregular paths (double seperators and such), you should use os.path.split multiple times as the other answers suggest."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "os.path.split", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]