[[{"text": ["Python can automatically detect what newline convention is used in a file, and you can access Python's guess through the newlines attribute of file objects:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "automatically detect what newline convention is used in a file", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "newlines", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n f = open('myfile.txt', 'U')\nf.readline()  # Reads a line\n# The following now contains the newline ending of the first line:\n# It can be \"\\r\\n\" (Windows), \"\\n\" (Unix), \"\\r\" (old Mac OS).\n# If no newline is found, it contains None.\nprint repr(f.newlines)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This gives the newline ending of the first line (Unix, DOS, etc.", "), if any.", "As John M. pointed out, if by any chance you have a pathological file that uses more than one newline coding, f.newlines is a tuple with all the newline codings found so far, after reading many lines."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "f.newlines", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["If you just want to convert all files, you can simply do:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n text = open('myfile.txt', 'U').read()  # Automatic (\"Universal read\") conversion of newlines to \"\\n\"\nopen('myfile.txt', 'w').write(text)  # Writes newlines for your platform\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You could search the string for \\r\\n.", "That's DOS style line ending."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\\r\\n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["EDIT: Take a look at this"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/66434-change-line-endings/"}]}], [{"text": ["If you just want to read text files, either DOS or Unix-formatted, this works:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n print open('myfile.txt', 'U').read()\n</code>\n</pre>\n", "senID": 1}, {"text": ["That is, Python's \"universal\" file reader will automatically use all the different end of line markers, translating them to \"\\n\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://docs.python.org/library/functions.html#open"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://docs.python.org/library/functions.html#open", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#open"}]}], [{"text": ["As a complete Python newbie &amp; just for fun, I tried to find some minimalistic way of checking this for one file.", "This seems to work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if \"\\r\\n\" in open(\"/path/file.txt\",\"rb\").read():\n    print \"DOS line endings found\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: simplified as per John Machin's comment (no need to use regular expressions)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["dos linebreaks are \\r\\n, unix only \\n.", "So just search for \\r\\n."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "\\r\\n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\n", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\\r\\n", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Using grep &amp; bash:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n grep -c -m 1 $'\\r$' file\n\necho $'\\r\\n\\r\\n' | grep -c $'\\r$'     # test\n\necho $'\\r\\n\\r\\n' | grep -c -m 1 $'\\r$'\n</code>\n</pre>\n", "senID": 1}]]