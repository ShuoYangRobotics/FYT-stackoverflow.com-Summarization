[[{"code": "<pre>\n<code>\n [str(wi) for wi in wordids]\n</code>\n</pre>\n", "senID": 0}, {"text": ["is a list comprehension."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "list comprehension", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "list comprehension", "tag": "a"}]}, {"href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions", "text": "list comprehension", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n a = [str(wi) for wi in wordids]\n</code>\n</pre>\n", "senID": 2}, {"text": ["is the same as"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n a = []\nfor wi in wordids:\n    a.append(str(wi))\n</code>\n</pre>\n", "senID": 4}, {"text": ["So "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n createkey='_'.join(sorted([str(wi) for wi in wordids]))\n</code>\n</pre>\n", "senID": 6}, {"text": ["creates a list of strings from each item in wordids, then sorts that list and joins it into a big string using _ as a separator."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "wordids", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "_", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["As agf rightly noted, you can also use a generator expression, which looks just like a list comprehension but with parentheses instead of brackets.", "This avoids construction of a list if you don't need it later (except for iterating over it).", "And if you already have parentheses there like in this case with sorted(...) you can simply remove the brackets. "], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "sorted(...)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["However, in this special case you won't be getting a performance benefit (in fact, it'll be about 10 % slower; I timed it) because sorted() will need to build a list anyway, but it looks a bit nicer:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "sorted()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n createkey='_'.join(sorted(str(wi) for wi in wordids))\n</code>\n</pre>\n", "senID": 10}, {"code": "<pre>\n<code>\n normalizedscores = dict([(u,float(l)/maxscore) for (u,l) in linkscores.items()])\n</code>\n</pre>\n", "senID": 11}, {"text": ["iterates through the items of the dictionary linkscores, where each item is a key/value pair.", "It creates a list of key/l/maxscore tuples and then turns that list back into a dictionary."], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "linkscores", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "l/maxscore", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["However, since Python 2.7, you could also use dict comprehensions:"], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "dict comprehensions", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "dict comprehensions", "tag": "a"}]}, {"href": "http://docs.python.org/py3k/whatsnew/3.0.html#new-syntax", "text": "dict comprehensions", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n normalizedscores = {u:float(l)/maxscore for (u,l) in linkscores.items()}\n</code>\n</pre>\n", "senID": 14}, {"text": ["Here's some timing data:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["Python 3.2.2"], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "Python 3.2.2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import timeit\n&gt;&gt;&gt; timeit.timeit(stmt=\"a = '_'.join(sorted([str(x) for x in n]))\", setup=\"import random; n = [random.randint(0,1000) for i in range(100)]\")\n61.37724242267409\n&gt;&gt;&gt; timeit.timeit(stmt=\"a = '_'.join(sorted(str(x) for x in n))\", setup=\"import random; n = [random.randint(0,1000) for i in range(100)]\")\n66.01814811313774\n</code>\n</pre>\n", "senID": 17}, {"text": ["Python 2.7.2"], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "Python 2.7.2", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import timeit\n&gt;&gt;&gt; timeit.timeit(stmt=\"a = '_'.join(sorted([str(x) for x in n]))\", setup=\"import random; n = [random.randint(0,1000) for i in range(100)]\")\n58.01728623923137\n&gt;&gt;&gt; timeit.timeit(stmt=\"a = '_'.join(sorted(str(x) for x in n))\", setup=\"import random; n = [random.randint(0,1000) for i in range(100)]\")\n60.58927580777687\n</code>\n</pre>\n", "senID": 19}], [{"text": ["Let's take the first one:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Now the second one:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n normalizedscores = dict([(u,float(1)/maxscore) for (u,l) in linkscores.items()])\n</code>\n</pre>\n", "senID": 2}, {"text": ["In short, it makes a copy of the dictionary, preserving the keys and dividing each value by maxscore."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "maxscore", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The latter is equivalent to:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n normalizedscores = {}\nfor u, l in linkscores.items():\n    normalizedscores[u] = float(l) / maxscore\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n [(u,float(1)/maxscore) for (u,l) in linkscores.items()]\n</code>\n</pre>\n", "senID": 0}, {"text": ["This creates a list by iterating over the tuples in linkscores.items() and computing (u, float(l)/maxscore) for each tuple."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "linkscores.items()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(u, float(l)/maxscore)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n dict([this list])\n</code>\n</pre>\n", "senID": 2}, {"text": ["creates a dict with entries from the result of the list comprehension - (u, float(l)/maxscore) for each item in linkscores."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(u, float(l)/maxscore)", "childNum": 0, "tag": "code", "childList": []}, {"text": "linkscores", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["As another example of creating a dict from a list of tuples:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l = [(1,2), (3,4), (5,6)]\n&gt;&gt;&gt; d = dict(l)\n&gt;&gt;&gt; d\n{1: 2, 3: 4, 5: 6}\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Here is an example of the first...example"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; wordids = [1,2,4,3,10,7]\n&gt;&gt;&gt; createkey='_'.join(sorted([str(wi) for wi in wordids]))\n&gt;&gt;&gt; print createkey\n1_10_2_3_4_7\n</code>\n</pre>\n", "senID": 1}, {"text": ["What it is doing is iterating through the list with a for loop, sorting the list, then joins all of the sorted values into a string, separating values with '_' "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The weird-looking business happening inside the [] brackets is called a list comprehension, and it is basically a really concise way of building a list.", "myList = [str(wi) for wi in wordids] is equivalent to:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "[]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "myList = [str(wi) for wi in wordids]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n myList = []\n\nfor wi in wordids:\n  myList.append(str(wi))\n</code>\n</pre>\n", "senID": 1}, {"text": ["sorted() then sorts that list, and join() gives a string with those list items separated by underscores, like this: item1_item2_item3_...."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "sorted()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "join()", "childNum": 0, "tag": "code", "childList": []}, {"text": "item1_item2_item3_...", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The second assignment is more complicated/concise, but here's what's going on:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["linkscores"], "childNum": 0, "tag": "code", "senID": 4, "childList": []}, {"text": "For each of those tuples, we create a new tuple containing ", "tag": "none", "senID": 5}, {"text": "The ", "tag": "none", "senID": 6}]}, {"text": ["The overall result of this is to take all the values in the dict and normalize them.", "There may be an easier/more verbose way to do this, but this way has the benefit of looking cool.", "I prefer to not do crazy stuff with list comprehensions because it hurts readability, so don't feel bad at all if you don't feel like writing this kind of thing yourself!"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}]]