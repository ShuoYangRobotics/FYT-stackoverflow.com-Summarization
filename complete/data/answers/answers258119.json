[[{"text": ["Here is the solution I and my colleagues came up with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from types import MethodType\n\nclass PrePostCaller:\n    def __init__(self, other):\n        self.other = other\n\n    def pre(self): print 'pre'\n    def post(self): print 'post'\n\n    def __getattr__(self, name):\n        if hasattr(self.other, name):\n            func = getattr(self.other, name)\n            return lambda *args, **kwargs: self._wrap(func, args, kwargs)\n        raise AttributeError(name)\n\n    def _wrap(self, func, args, kwargs):\n        self.pre()\n        if type(func) == MethodType:\n            result = func( *args, **kwargs)\n        else:\n            result = func(self.other, *args, **kwargs)\n        self.post()\n        return result\n\n#Examples of use\nclass Foo:\n    def stuff(self):\n        print 'stuff'\n\na = PrePostCaller(Foo())\na.stuff()\n\na = PrePostCaller([1,2,3])\nprint a.count()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Gives:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n pre\nstuff\npost\npre\npost\n0\n</code>\n</pre>\n", "senID": 3}, {"text": ["So when creating an instance of your object, wrap it with the PrePostCaller object.", "After that you continue using the object as if it was an instance of the wrapped object.", "With this solution you can do the wrapping on a per instance basis."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["The no-whistles-or-bells solution would be to write a wrapper class for class A that does just that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["As others have mentioned, the wrapper/decorator solution is probably be the easiest one.", "I don't recommend modifyng the wrapped class itself, for the same reasons that you point out."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you have many external classes you can write a code generator to generate the wrapper classes for you.", "Since you are doing this in Python you can probably even implement the generator as a part of the program, generating the wrappers at startup, or something."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You could just modify the A instance and replace the p1 function with a wrapper function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def wrapped(pre, post, f):\n    def wrapper(*args, **kwargs):\n        pre()\n        retval = f(*args, **kwargs)\n        post()\n        return retval\n    return wrapper\n\nclass Y:\n    def __init__(self):\n        self.a=A()\n        self.a.p1 = wrapped(self.pre, self.post, self.a.p1)\n\n    def pre(self): print 'X.pre'\n    def post(self): print 'X.post'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I've just recently read about decorators in python, I'm not understanding them yet but it seems to me that they can be a solution to your problem.", "see Bruce Eckel intro to decorators at:\nhttp://www.artima.com/weblogs/viewpost.jsp?thread=240808"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.artima.com/weblogs/viewpost.jsp?thread=240808", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.artima.com/weblogs/viewpost.jsp?thread=240808"}]}, {"text": ["He has a few more posts on that topic there."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit: Three days later I stumble upon this article, which shows how to do a similar task without decorators, what's the problems with it and then introduces decorators and develop a quite full solution:\nhttp://wordaligned.org/articles/echo"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://wordaligned.org/articles/echo", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wordaligned.org/articles/echo"}]}], [{"text": ["Here's what I've received from Steven D'Aprano on comp.lang.python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # Define two decorator factories.\ndef precall(pre):\n    def decorator(f):\n        def newf(*args, **kwargs):\n            pre()\n            return f(*args, **kwargs)\n        return newf\n    return decorator\n\ndef postcall(post):\n    def decorator(f):\n        def newf(*args, **kwargs):\n            x = f(*args, **kwargs)\n            post()\n            return x\n        return newf\n    return decorator\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now you can monkey patch class A if you want.", "It's probably not a great\nidea to do this in production code, as it will effect class A everywhere.", "[this is ok for my application, as it is basically a protocol converter and there's exactly one instance of each class being processed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class A:\n    # in my real application, this is an imported class\n    # that I cannot modify\n    def p1(self): print 'A.p1'\n\nclass X:\n    def __init__(self):\n        self.a=A()\n        A.p1 = precall(self.pre)(postcall(self.post)(A.p1))\n    def pre(self): print 'X.pre'\n    def post(self): print 'X.post'\n\n\nx=X()\nx.a.p1()\n</code>\n</pre>\n", "senID": 3}, {"text": ["Gives the desired result."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n X.pre\nA.p1\nX.post\n</code>\n</pre>\n", "senID": 5}]]