[[{"text": ["Just use the built-in function zip - "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["like in"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for letters in zip('hello', 'apple', 'green', 'paint', 'sting'):\n     print letters\n</code>\n</pre>\n", "senID": 2}, {"text": ["zip is a built-in that does just that: combine one element of each iterable in a tuple, for each iteration."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Running the above example, you have:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; for letters in zip('hello', 'apple', 'green', 'paint', 'sting'):\n...   print letters\n... \n('h', 'a', 'g', 'p', 's')\n('e', 'p', 'r', 'a', 't')\n('l', 'p', 'e', 'i', 'i')\n('l', 'l', 'e', 'n', 'n')\n('o', 'e', 'n', 't', 'g')\n</code>\n</pre>\n", "senID": 5}], [{"text": ["izip does exactly what you want:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "izip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import izip\nfor letters in izip(*string_list):\n    print letters\n</code>\n</pre>\n", "senID": 1}, {"text": ["The * operator unpacks your string_list so that izip sees it as five sequences of characters, instead of just a single list of strings.", "Output:"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "*", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "string_list", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "izip", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n ('h', 'a', 'g', 'p', 's')\n('e', 'p', 'r', 'a', 't')\n('l', 'p', 'e', 'i', 'i')\n('l', 'l', 'e', 'n', 'n')\n('o', 'e', 'n', 't', 'g')\n</code>\n</pre>\n", "senID": 3}, {"text": ["The built-in zip function works too, but it's not lazy (i.e.", "it immediately returns a list of all the tuples, instead of generating them one at a time)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The following recipe comes from the itertools documentation:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#recipes"}]}, {"code": "<pre>\n<code>\n from itertools import islice, cycle\n\ndef roundrobin(*iterables):\n    \"roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C\"\n    # Recipe credited to George Sakkis\n    pending = len(iterables)\n    nexts = cycle(iter(it).next for it in iterables)\n    while pending:\n        try:\n            for next in nexts:\n                yield next()\n        except StopIteration:\n            pending -= 1\n            nexts = cycle(islice(nexts, pending))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Besides being very fast, one advantage of this approach is that it works well if the input iterables are of different lengths."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Use the zip function that takes several lists (iterables) and yields tuples of corresponding items:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n zip(*string_list)\n</code>\n</pre>\n", "senID": 1}, {"text": ["yields (successively)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [('h', 'a', 'g', 'p', 's'),\n ('e', 'p', 'r', 'a', 't'),\n ('l', 'p', 'e', 'i', 'i'),\n ('l', 'l', 'e', 'n', 'n'),\n ('o', 'e', 'n', 't', 'g')]\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n val = zip('hello','apple','green','paint','sting')\n</code>\n</pre>\n", "senID": 0}, {"text": ["or  zip(*string_list) "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "zip(*string_list)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n print val[0]\n</code>\n</pre>\n", "senID": 2}, {"text": ["output = ('h', 'a', 'g', 'p', 's')"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "('h', 'a', 'g', 'p', 's')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n print val[1]\n</code>\n</pre>\n", "senID": 4}, {"text": ["output = ('e', 'p', 'r', 'a', 't')"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "('e', 'p', 'r', 'a', 't')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n def foo(string_list):\n    for i in xrange(len(string_list)):\n        yield (a_string[i] for a_string in string_list)\nstring_list = ['hello', 'apple', 'green', 'paint', 'sting']\nfor nth_string_list in foo(string_list):\n    for ch in nth_string_list:\n        print ch\n</code>\n</pre>\n", "senID": 0}]]