[[{"text": ["Actually, the example works just fine ... to a small details.", "I would write:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; p = re.compile('b*(abb*)*a?')\n&gt;&gt;&gt; m = p.match('aa')\n&gt;&gt;&gt; print m.group(0)\n'a'\n&gt;&gt;&gt; m = p.match('abbabbabababbabbbbbaaaaa')\n&gt;&gt;&gt; print m.group(0)\nabbabbabababbabbbbba\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that the group 0 returns the part of the string matched by the regular expression."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["As you can see, the expression matches a succession of a and b without repetition of a.", "If indeed, you want to check the whole string, you need to changed slightly:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; p = re.compile('^b*(abb*)*a?$')\n&gt;&gt;&gt; m = p.match('aa')\n&gt;&gt;&gt; print m\nNone\n</code>\n</pre>\n", "senID": 4}, {"text": ["the ^ and $ force recognition of the beginning and end of the string."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "^", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "$", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["At last, you can combine both methods by using the first regular expression, but testing at the end:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; len(m.group(0)) == len('aa')\n</code>\n</pre>\n", "senID": 7}, {"text": ["Added: For the second part of the OT, it seems to me there is no discrepancy between the standard regex and the python implementation.", "Of course, the notation is slightly different, and the python implementation suggest some extensions (as most other packages)."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Added:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Thanks for the answers.", "I feel each answer had part of the answer.", "Here is what I was looking for."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": [], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["Use bool(p.match('aa')) to check if the regexp matches or not"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "bool(p.match('aa'))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["p = re.compile('b*(abb*)*a?$')"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "p = re.compile('b*(abb*)*a?$')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["\\b matches border of string; place between \\w and \\W (word characters and non-word characters)"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "\\b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\w", "childNum": 0, "tag": "code", "childList": []}, {"text": "\\W", "childNum": 0, "tag": "code", "childList": []}]}]}, {"text": ["2 "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Regexp is quite standard in python.", "Yet every language has some flavour of them, they are not 100% portable.", "There are minor differences which you're expected to lookup prior to using regexp in any specific language."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Addition"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Addition", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["\\epsilon does not have special symbol in python.", "It is an empty character set. "], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "\\epsilon", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In your example a|\\epsilon is equivalent to (a|) or just a?.", "After which $ is obligatory to match end of string."], "childNum": 4, "tag": "p", "senID": 8, "childList": [{"text": "a|\\epsilon", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(a|)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a?", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "$", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I'm not exactly sure how match works in python, but I think you might need to add ^....$ to your RE.", "RegExp matching usually matches sub-strings, and it finds the largest match, in the case of p.match('aa') that's \"a\" (probably the first one).", "^...$ makes sure that you're matching the ENTIRE string, which is I believe what you want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Theoretical/standard reg exps assume that you're always matching the whole string, because you're using it to define a language of strings that match, not find a substring in  an input string."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You're matching because your regex matches any zero-width segment of any specimen text.", "You need to anchor your regex.", "Here's one way of doing it, using a zero-width lookahead assertion:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "anchor", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n re.compile(r'^(a(?!a)|b)*$')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Your second re should be an appropriate replacement for epsilon, as best as I understand it, though I've never seen epsilon in a regex before.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For what it's worth, your pattern is matching 'a'.", "That is to say, it is matching:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "zero or more \"", "tag": "none", "senID": 2}, {"text": "zero or more \"", "tag": "none", "senID": 3}, {"text": "one \"", "tag": "none", "senID": 4}]}, {"text": ["As Jonathan Feinberg pointed out, if you want to ensure the whole string matches, you have to anchor the beginning ('^') and end ('$') of your regex.", "You should also use a raw string whenever constructing regexes in python: r'my regex'.", "That will prevent excessive backslash escaping confusion."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "'^'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'$'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["the problem with your expression is that it matches the empty string, meaning that if you do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; p = re.compile('b*(abb*)*(a|)')\n&gt;&gt;&gt; p.match('c').group(0)\n''\n</code>\n</pre>\n", "senID": 1}, {"text": ["and since re.match attempts to match the start of the string, you have to tell it to match it until the end of the string.", "just use $ for that"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "$", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; p = re.compile(r'b*(abb*)*(a|)$')\n&gt;&gt;&gt; print p.match('c')\nNone\n&gt;&gt;&gt; p.match('ababababab').group(0)\n'ababababab'\n</code>\n</pre>\n", "senID": 3}, {"text": ["ps- you may have noted that i used r'pattern' instead of 'pattern' more on that here (first paragraphs)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html"}]}]]