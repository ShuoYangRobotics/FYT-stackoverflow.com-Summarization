[[{"text": ["This can be done explicitly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class ref:\n    def __init__(self, obj): self.obj = obj\n    def get(self):    return self.obj\n    def set(self, obj):      self.obj = obj\n\na = ref([1, 2])\nb = a\nprint a.get()  # =&gt; [1, 2]\nprint b.get()  # =&gt; [1, 2]\n\nb.set(2)\nprint a.get()  # =&gt; 2\nprint b.get()  # =&gt; 2\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You may want to read Semantics of Python variable names from a C++ perspective.", "The bottom line: All variables are references."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Semantics of Python variable names from a C++ perspective", "tag": "a", "pos": 0, "childList": [{"text": "Semantics of Python variable names from a C++ perspective", "tag": "em"}], "childNum": 1, "href": "http://rg03.wordpress.com/2007/04/21/semantics-of-python-variable-names-from-a-c-perspective/"}, {"text": "Semantics of Python variable names from a C++ perspective", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "All variables are references", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["More to the point, don't think in terms of variables, but in terms of objects which can be named."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "named", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["If you're compiling a C-like language, say:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n func()\n{\n    var a = 1;\n    var *b = &amp;a;\n    *b = 2;\n    assert(a == 2);\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["into Python, then all of the \"everything in Python is a reference\" stuff is a misnomer."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It's true that everything in Python is a reference, but the fact that many core types (ints, strings) are immutable effectively undoes this for many cases.", "There's no direct way to implement the above in Python."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "direct", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Now, you can do it indirectly: for any immutable type, wrap it in a mutable type.", "Ephemient's solution works, but I often just do this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n a = [1]\nb = a\nb[0] = 2\nassert a[0] == 2\n</code>\n</pre>\n", "senID": 5}, {"text": ["(I've done this to work around Python's lack of \"nonlocal\" in 2.x a few times."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["This implies a lot more overhead: every immutable type (or every type, if you don't try to distinguish) suddenly creates a list (or another container object), so you're increasing the overhead for variables significantly.", "Individually, it's not a lot, but it'll add up when applied to a whole codebase."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["You could reduce this by only wrapping immutable types, but then you'll need to keep track of which variables in the output are wrapped and which aren't, so you can access the value with \"a\" or \"a[0]\" appropriately.", "It'll probably get hairy."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["As to whether this is a good idea or not--that depends on why you're doing it.", "If you just want something to run a VM, I'd tend to say no.", "If you want to be able to call to your existing language from Python, I'd suggest taking your existing VM and creating Python bindings for it, so you can access and call into it from Python."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["Everything in Python is pointers already, but it's called \"references\" in Python.", "This is the translation of your code to Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = [1,2]  // a has an array \nb = a     // b points to a\na = 2      // store 2 in a.\nprint(a)   // outputs 2\nprint(b)  // outputs [1,2]\n</code>\n</pre>\n", "senID": 1}, {"text": ["\"Dereferencing\" makes no sense, as it's all references.", "There isn't anything else, so nothing to dereference to."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "all", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["As others here have said, all Python variables are essentially pointers."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The key to understanding this from a C perspective is to use the unknown by many id() function.", "It tells you what address the variable points to."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [1,2]\n&gt;&gt;&gt; id(a)\n28354600\n\n&gt;&gt;&gt; b = a\n&gt;&gt;&gt; id(a)\n28354600\n\n&gt;&gt;&gt; id(b)\n28354600\n</code>\n</pre>\n", "senID": 2}], [{"text": ["This is goofy, but a thought..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # Change operations like:\nb = &amp;a\n\n# To:\nb = \"a\"\n\n# And change operations like:\n*b = 2\n\n# To:\nlocals()[b] = 2\n\n\n&gt;&gt;&gt; a = [1,2]\n&gt;&gt;&gt; b = \"a\"\n&gt;&gt;&gt; locals()[b] = 2\n&gt;&gt;&gt; print(a)\n2\n&gt;&gt;&gt; print(locals()[b])\n2\n</code>\n</pre>\n", "senID": 1}, {"text": ["But there would be no pointer arithmetic or such, and no telling what other problems you might run into..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Negative, no pointers.", "You should not need them with the way the language is designed.", "However, I heard a nasty rumor that you could use the: ctypes module to use them.", "I haven't used it, but it smells messy to me."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ctypes", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://starship.python.net/crew/theller/ctypes/"}]}]]