[[{"text": ["Perhaps I'm misunderstanding your question, but as it's a serial line, you'll have to read everything sent from the Arduino sequentially - it'll be buffered up in the Arduino until you read it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want to have a status display which shows the latest thing sent - use a thread which incorporates the code in your question (minus the sleep), and keep the last complete line read as the latest line from the Arduino."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Update: mtasic's example code is quite good, but if the Arduino has sent a partial line when inWaiting() is called, you'll get a truncated line.", "Instead, what you want to do is to put the last complete line into last_received, and keep the partial line in buffer so that it can be appended to the next time round the loop.", "Something like this:"], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "mtasic", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "inWaiting()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "complete", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "last_received", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "buffer", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def receiving(ser):\n    global last_received\n\n    buffer = ''\n    while True:\n        buffer = buffer + ser.read(ser.inWaiting())\n        if '\\n' in buffer:\n            lines = buffer.split('\\n') # Guaranteed to have at least 2 entries\n            last_received = lines[-2]\n            #If the Arduino sends lots of empty lines, you'll lose the\n            #last filled line, so you could make the above statement conditional\n            #like so: if lines[-2]: last_received = lines[-2]\n            buffer = lines[-1]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Regarding use of readline(): Here's what the Pyserial documentation has to say (slightly edited for clarity):"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "readline()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["which seems quite reasonable to me!"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["These solutions will hog the CPU while waiting for characters."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You should do at least one blocking call to read(1)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n while True:\n    if '\\n' in buffer: \n        pass # skip if a line already in buffer\n    else:\n        buffer += ser.read(1)  # this will block until one more char or timeout\n    buffer += ser.read(ser.inWaiting()) # get remaining buffered chars\n</code>\n</pre>\n", "senID": 2}, {"text": ["...and do the split thing as before."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n from serial import *\nfrom threading import Thread\n\nlast_received = ''\n\ndef receiving(ser):\n    global last_received\n    buffer = ''\n\n    while True:\n        # last_received = ser.readline()\n        buffer += ser.read(ser.inWaiting())\n        if '\\n' in buffer:\n            last_received, buffer = buffer.split('\\n')[-2:]\n\nif __name__ ==  '__main__':\n    ser = Serial(\n        port=None,\n        baudrate=9600,\n        bytesize=EIGHTBITS,\n        parity=PARITY_NONE,\n        stopbits=STOPBITS_ONE,\n        timeout=0.1,\n        xonxoff=0,\n        rtscts=0,\n        interCharTimeout=None\n    )\n\n    Thread(target=receiving, args=(ser,)).start()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You will need a loop to read everything sent, with the last call to readline() blocking until the timeout.", "So:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def readLastLine(ser):\n    last_data=''\n    while True:\n        data=ser.readline()\n        if data!='':\n            last_data=data\n        else:\n            return last_data\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Slight modification to mtasic &amp; Vinay Sajip's code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["While I found this code quite helpful to me for a similar application, I needed all the lines coming back from a serial device that would send information periodically."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "all", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I opted to pop the first element off the top, record it, and then rejoin the remaining elements as the new buffer and continue from there."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I realize that this is not what Greg was asking for, but I thought it was worth sharing as a side note."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "not", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def receiving(ser):\n    global last_received\n\n    buffer = ''\n    while True:\n        buffer = buffer + ser.read(ser.inWaiting())\n        if '\\n' in buffer:\n            lines = buffer.split('\\n')\n            last_received = lines.pop(0)\n\n            buffer = '\\n'.join(lines)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["For the benefit of people looking for answers to this: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Using .inWaiting() inside an infinite loop may be problematic.", "Its may hog up the entire cpu depending on the implementation.", "Instead I would recommend using a specific size of data to be read.", "So in this case the following should be done for example: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n ser.read(1024)\n</code>\n</pre>\n", "senID": 2}]]