[[{"text": ["In C++ at least, there is nothing wrong with putting failure-prone code in the constructor - you simply throw an exception if an error occurs.", "If the code is needed to properly construct the object, there reallyb is no alternative (although you can abstract the code into subfunctions, or better into the constructors of subobjects).", "Worst practice is to half-construct the object and then expect the user to call other functions to complete the construction somehow."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["There is a difference between constructor in C++ and __init__ method\nin Python.", "Task of the constructor is to construct object and if it fails\nno destructor is called.", "Therefore if any resources where acquired before\nexception was thrown the cleanup shall be done before exiting constructor.", "Thus some prefer two-phase construction with most of construction done\noutside constructor (ugh)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Python have much more clean two-phase construction (construct than\ninitialize) but many people confuse __init__ method (initializer)\nwith constructor.", "The actual constructor in Python is called __new__.", "Contrary to C++ it does not take an (half-constructed) instance but\nreturns one.", "The __init__ task is to initialize the created instance.", "When exception is raised in __init__ the destructor (__del__)\nis called as expected because object was already created (not properly\ninitialized but still) when __init__ was called."], "childNum": 6, "tag": "p", "senID": 1, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "__del__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Answering your question:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["That's not precise.", "If exception is raised __init__ the object is\ncreated but not initialized properly (e.g.", "some attributes are not\nassigned).", "But when it does you probably don't have any reference to\nthis object.", "Only destructor (if any) needs to check whether attribute\nactualy exist."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In Python initialize objects in __init__ and fear not about exceptions.", "In C++ use RAII."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "RAII", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Resource%5FAcquisition%5FIs%5FInitialization"}]}, {"tag": "hr", "senID": 5}, {"text": ["Update [about resource management]:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["In garbage collected languages if you are dealing with resources, especially limited ones such as database connections, it's better not to release them in destructor.", "This is because objects are destroyed in non deterministic way and if you happen\nto have a loop of references, which is not always easy to tell, and at least one of objects in loop have destructor defined they will never be destroyed.", "Garbage collected languages have other means of dealing with resources.", "In Python it's with statement."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "with statement", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0343/"}]}], [{"text": ["I'm not a Python developer, but in general, it's best to avoid complex/error-prone operations in your constructor.", "One way around this would be to put a \"LoadFromFile\" or \"Init\" method in your class to populate the object from an external source.", "This load/init method must then be called separately after constructing the object."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["One common pattern is two-phase construction, also suggested by Andy White."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First phase: Regular constructor."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Second phase: Operations that can fail."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Integration of the two: Add a factory method to do both phases and make the constructor protected/private to prevent instantation outside the factory method."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Oh, and I'm neither a Python developer."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["It is not bad practice per se."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But I think you may be after a something different here.", "In your example the doSomething() method will not be called when the MyClass constructor fails.", "Try the following code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class MyClass:\ndef __init__(self, s):\n    print s\n    raise Exception(\"Exception\")\n\ndef doSomething(self):\n    print \"doSomething\"\n\ntry:\n    someInstance = MyClass(\"test123\")\n    someInstance.doSomething()\nexcept:\n    print \"except\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["It should print:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n test123\nexcept\n</code>\n</pre>\n", "senID": 4}, {"text": ["For your software design you could ask the following questions:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": ["What should the scope of the someInstance variable be?", "Who are its users?", "What are their requirements?"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Where and how should the error be handled for the case that one of your 10 values is not available?"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Should all 10 values be cached at construction time or cached one-by-one when they are needed the first time?"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Can the I/O code be refactored into a helper method, so that doing something similiar 10 times does not result in code repetition?"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["..."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}]}], [{"text": ["If the code to initialise the various values is really extensive enough that copying it is undesirable (which it sounds like it is in your case) I would personally opt for putting the required initialisation into a private method, adding a flag to indicate whether the initialisation has taken place, and making all accessors call the initialisation method if it has not initialised yet."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In threaded scenarios you may have to add extra protection in case initialisation is only allowed to occur once for valid semantics (which may or may not be the case since you are dealing with a file)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Again, I've got little experience with Python, however in C# its better to try and avoid having a constructor that throws an exception.", "An example of why that springs to mind is if you want to place your constructor at a point where its not possible to surround it with a try {} catch {} block, for example initialisation of a field in a class:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MyClass\n{\n    MySecondClass = new MySecondClass();\n    // Rest of class\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["If the constructor of MySecondClass throws an exception that you wish to handle inside MyClass then you need to refactor the above - its certainly not the end of the world, but a nice-to-have."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In this case my approach would probably be to move the failure-prone initialisation logic into an initialisation method, and have the getters call that initialisation method before returning any values."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["As an optimisation you should have the getter (or the initialisation method) set some sort of \"IsInitialised\" boolean to true, to indicate that the (potentially costly) initialisation does not need to be done again."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In pseudo-code (C# because I'll just mess up the syntax of Python):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class MyClass\n{\n    private bool IsInitialised = false;\n\n    private string myString;\n\n    public void Init()\n    {\n        // Put initialisation code here\n        this.IsInitialised = true;\n    }\n\n    public string MyString\n    {\n        get\n        {\n            if (!this.IsInitialised)\n            {\n                this.Init();\n            }\n\n            return myString;\n        }\n    }\n}\n</code>\n</pre>\n", "senID": 6}, {"text": ["This is of course not thread-safe, but I don't think multithreading is used that commonly in python so this is probably a non-issue for you."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["seems Neil had a good point: my friend just pointed me to this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"}]}, {"text": ["which is basically what Neil said..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]