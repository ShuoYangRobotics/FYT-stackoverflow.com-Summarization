[[{"text": ["Strange way to split strings you have there:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def splitter( s, points ):\n    c = 0\n    for x,y in points:\n        yield s[c:x]\n        yield \"(%s)\" % s[x:y+1]\n        c=y+1\n    yield s[c:]\n\nprint list(splitter(str, split_points))\n# =&gt; ['M', '(SEP)', 'AGD', '(VRQN)', 'P', '(CG)', 'SKAC']\n\n# if some start and endpoints are the same remove empty strings.\nprint list(x for x in splitter(str, split_points) if x != '')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is a simple solution for you.", "to grab each of the sets specified by the point.    "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In[4]:  str[p[0]:p[1]+1] for p in split_points]\nOut[4]: ['SEP', 'VRQN', 'CG']\n</code>\n</pre>\n", "senID": 1}, {"text": ["To get the parenthesis:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n In[5]:  ['(' + str[p[0]:p[1]+1] + ')' for p in split_points]\nOut[5]: ['(SEP)', '(VRQN)', '(CG)']\n</code>\n</pre>\n", "senID": 3}, {"text": ["Here is the cleaner way of doing it to do the whole deal:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n results = []\n\nfor i in range(len(split_points)):\n    start, stop = split_points[i]\n    stop += 1\n\n    last_stop = split_points[i-1][1] + 1 if i &gt; 0 else 0\n\n    results.append(string[last_stop:start])        \n    results.append('(' + string[start:stop] + ')')\n\nresults.append(string[split_points[-1][1]+1:])\n</code>\n</pre>\n", "senID": 5}, {"text": ["All of the below solutions are bad, and more for fun than anything else, do not use them!"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "All of the below solutions are bad, and more for fun than anything else, do not use them!", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This more of a WTF solution, but I figured I'd post it since it was asked for in comments:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n split_points = [(x, y+1) for x, y in split_points]\nsplit_points = [((split_points[i-1][1] if i &gt; 0 else 0, p[0]), p) for i, p in zip(range(len(split_points)), split_points)]\nresults = [string[n[0]:n[1]] + '\\n(' + string[m[0]:m[1]] + ')' for n, m in split_points] + [string[split_points[-1][1][1]:]]\nresults = '\\n'.join(results).split()\n</code>\n</pre>\n", "senID": 8}, {"text": ["still trying to figure out the one liner, here's a two:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n split_points = [((split_points[i-1][1]+1 if i &gt; 0 else 0, p[0]), (p[0], p[1]+1)) for i, p in zip(range(len(split_points)), split_points)]\nprint '\\n'.join([string[n[0]:n[1]] + '\\n(' + string[m[0]:m[1]] + ')' for n, m in split_points] + [string[split_points[-1][1][1]:]]).split()\n</code>\n</pre>\n", "senID": 10}, {"text": ["And the one liner that should never be used:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n print '\\n'.join([string[n[0]:n[1]] + '\\n(' + string[m[0]:m[1]] + ')' for n, m in (((split_points[i-1][1]+1 if i &gt; 0 else 0, p[0]), (p[0], p[1]+1)) for i, p in zip(range(len(split_points)), split_points))] + [string[split_points[-1][1]:]]).split()\n</code>\n</pre>\n", "senID": 12}], [{"text": ["Here's some code that will work."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n result = []\nlast_end = 0\nfor sp in split_points:\n  result.append(str[last_end:sp[0]])\n  result.append('(' + str[sp[0]:sp[1]+1] + ')')\n  last_end = sp[1]+1\nresult.append(str[last_end:])\n\nprint result\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you just want the parts in the parenthesis it becomes a little simpler:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n result = [str[sp[0]:sp[1]+1] for sp in split_points]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Probably not for elegance, but just because I can do it in a oneliner :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; reduce(lambda a,ij:a[:-1]+[str[a[-1]:ij[0]],'('+str[ij[0]:ij[1]+1]+')',\n            ij[1]], split_points, [0])[:-1] + [str[split_points[-1][-1]+1:]]\n\n['M', '(SEP)', 'PAGD', '(VRQN)', 'NP', '(CG)', 'SKAC']\n</code>\n</pre>\n", "senID": 1}, {"text": ["Maybe you like it.", "Here some explanation:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In your question you pass one set of slices, and implicitly you want to have the complement set of slices as well (to generate the un-parenthesized [is that English?", "] slices).", "So basically, each slice [i,j] lacks the previous j. e.g.", "[7,10] lacks the 3 and [1,3] lacks the 0."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["reduce processes lists and at each step passes the output so far (a) plus the next input element (ij).", "The trick is that apart from producing the plain output, we add each time an extra variable --- a sort of memory --- which is in the next step retrieved in a[-1].", "In this particular example we store the last j value, and hence at all times we have the full information to provide both the unparenthesized and the parenthesized substring."], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": "reduce", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "the output so far", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "next input element", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "ij", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a[-1]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Finally, the memory is stripped with [:-1] and replaced by the remainder of the original str in [str[split_points[-1][-1]+1:]]."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "[str[split_points[-1][-1]+1:]]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Here's a solution that converts your split_points to regular string slices and then prints out the appropriate slices:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n str = \"MSEPAGDVRQNPCGSKAC\"\nsplit_points = [[1, 3], [7, 10], [12, 13]]\n\nadjust = [s for sp in [[x, y + 1] for x, y in split_points] for s in sp]\nzipped = zip([None] + adjust, adjust + [None])\n\nout = [('(%s)' if i % 2 else '%s') % str[x:y] for i, (x, y) in\n       enumerate(zipped)]\n\nprint out\n\n&gt;&gt;&gt; ['M', '(SEP)', 'AGD', '(VRQN)', 'P', '(CG)', 'SKAC']\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n>>> str = \"MSEPAGDVRQNPCGSKAC\"\n>>> split_points = [[1,3], [7,10], [12,13]]\n>>>\n>>> all_points = sum(split_points, [0]) + [len(str)-1]\n>>> map(lambda i,j: str[i:j+1], all_points[:-1], all_points[1:])\n['MS', 'SEP', 'PAGDV', 'VRQN', 'NPC', 'CG', 'GSKAC']\n>>>\n>>> str_out = map(lambda i,j: str[i:j+1], all_points[:-1:2], all_points[1::2])\n>>> str_in = map(lambda i,j: str[i:j+1], all_points[1:-1:2], all_points[2::2])\n>>> sum(map(list, zip(['(%s)' % s for s in str_in], str_out[1:])), [str_out[0]])\n['MS', '(SEP)', 'PAGDV', '(VRQN)', 'NPC', '(CG)', 'GSKAC']\n</pre>\n", "senID": 0}]]