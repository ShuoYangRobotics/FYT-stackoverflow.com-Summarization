[[{"code": "<pre>\n<code>\n l = ['a', 'b', 'c', 'd', 'e']\nsubarraysize = 3\nfor i in range(len(l)-subarraysize+1):\n    print l[i:i+subarraysize]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n ['a', 'b', 'c']\n['b', 'c', 'd']\n['c', 'd', 'e']\n</code>\n</pre>\n", "senID": 2}, {"text": ["Not very Pythonic I know, but in its favour it does actually work."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You can use zip and slicing:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = range(5)\nfor grp in zip(*[l[i:] for i in range(3)]):\n    print grp \n\n(0, 1, 2)\n(1, 2, 3)\n(2, 3, 4)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edited to work properly, and with length of groups as one number.", ":)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["What this does is call zip(l[0:], l[1:], l[2:]), since * converts a list into separate arguments for function calls."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "zip(l[0:], l[1:], l[2:])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["One refinement I might suggest would be modifying David Heffernan's suggestion to make it more pythonic, i.e."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = ['a', 'b', 'c', 'd', 'e']\nn = 3\nm = [l[i:i+n] for i in range(len(l)-n+1)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n m = [['a', 'b', 'c'], ['b', 'c', 'd'], ['c', 'd', 'e']]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If you want the first and third element of subsequences, using zip is probably the simplest way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = range(10)\n\nfor grp in zip(l[0:], l[2:]):\n   print grp\n\n(0, 2)\n(1, 3)\n(2, 4)\n...\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or, use step if you want to jump further:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for grp in zip(l[0::3], l[2::3]):\n   print grp \n\n(0, 2)\n(3, 5)\n(6, 8)\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n l = ['a', 'b', 'c', 'd', 'e'] \n\n&gt;&gt;&gt; zip(l,l[1:],l[2:])\n\n[('a', 'b', 'c'), ('b', 'c', 'd'), ('c', 'd', 'e')]\n\n&gt;&gt;&gt; l = [chr(x+65) for x in xrange(26)]\n\n&gt;&gt;&gt; zip(l,l[1:],l[2:])\n\n[('A', 'B', 'C'), ('B', 'C', 'D'), ('C', 'D', 'E'), ('D', 'E', 'F'), ('E', 'F', 'G'), ('F', 'G', 'H'), ('G', 'H', 'I'), \n ('H', 'I', 'J'), ('I', 'J', 'K'), ('J', 'K', 'L'), ('K', 'L', 'M'), ('L', 'M', 'N'), ('M', 'N', 'O'), ('N', 'O', 'P'),\n ('O', 'P', 'Q'), ('P', 'Q', 'R'), ('Q', 'R', 'S'), ('R', 'S', 'T'), ('S', 'T', 'U'), ('T', 'U', 'V'), ('U', 'V', 'W'), \n ('V', 'W', 'X'), ('W', 'X', 'Y'), ('X', 'Y', 'Z')]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Another version (similar to David's) is to use slicing in a generator expression:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n size = 3\nfor grp in (l[i:i+size] for i in range(len(l)-size+1)):\n    print grp\n\n[0, 1, 2]\n[1, 2, 3]\n[2, 3, 4]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This version yields lists instead of tuples, if that matters."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This is my solution to avoid the use of range as required by OP in a comment."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "range", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; items = ['a', 'b', 'c', 'd', 'e']\n&gt;&gt;&gt; n = 3\n&gt;&gt;&gt; [item for item in map(lambda x: items[items.index(x):items.index(x) + n], it\nems) if len(item) == n]\n[['a', 'b', 'c'], ['b', 'c', 'd'], ['c', 'd', 'e']]\n</code>\n</pre>\n", "senID": 1}]]