[[{"text": ["If the calculations are already nicely bundled into functions, how about using filter and map?"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "filter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n result = filter (None, map (expensive, mylist))\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can use itertools.imap if the list is very large."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "itertools.imap", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Came up with my own answer after a minute of thought.", "It can be done with nested comprehensions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n result = [y for y in (expensive(x) for x in mylist) if y]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I guess that works, though I find nested comprehensions are only marginally readable "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n result = [x for x in map(expensive,mylist) if x]\n</code>\n</pre>\n", "senID": 0}, {"text": ["map() will return a list of the values of each object in mylist passed to expensive().", "Then you can list-comprehend that, and discard unnecessary values."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This is somewhat like a nested comprehension, but should be faster (since the python interpreter can optimize it fairly easily)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The most obvious (and I would argue most readable) answer is to not use a list comprehension or generator expression, but rather a real generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def gen_expensive(mylist):\n    for item in mylist:\n        result = expensive(item)\n        if result:\n            yield result\n</code>\n</pre>\n", "senID": 1}, {"text": ["It takes more horizontal space, but it's much easier to see what it does at a glance, and you end up not repeating yourself."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could always memoize the expensive() function so that calling it the second time around is merely a lookup for the computed value of x."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "memoize", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Memoization"}, {"text": "expensive()", "childNum": 0, "tag": "code", "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Here's just one of many implementations of memoize as a decorator."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Here's just one of many implementations of memoize as a decorator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/PythonDecoratorLibrary#head-11870a08b0fa59a8622201abfac735ea47ffade5"}]}], [{"text": ["You could memoize expensive(x) (and if you are calling expensive(x) frequently, you probably should memoize it any way.", "This page gives an implementation of memoize for python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://code.activestate.com/recipes/52201/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://code.activestate.com/recipes/52201/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/52201/"}]}, {"text": ["This has the added benefit that expensive(x) may be run less than N times, since any duplicate entries will make use of the memo from the previous execution."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "less", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Note that this assumes expensive(x) is a true function, and does not depend on external state that may change.", "If expensive(x) does depend on external state, and you can detect when that state changes, or you know it wont change during your list comprehension, then you can reset the memos before the comprehension."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "wont", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["This is exactly what generators are suited to handle:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n result = (expensive(x) for x in mylist)\nresult = (do_something(x) for x in result if some_condition(x))\n...\nresult = [x for x in result if x]  # finally, a list\n</code>\n</pre>\n", "senID": 1}, {"text": ["cf:  'Generator Tricks for System Programmers' by David Beazley"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "'Generator Tricks for System Programmers' by David Beazley", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/generators/"}]}], [{"text": ["I will have a preference for:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n itertools.ifilter(bool, (expensive(x) for x in mylist))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This has the advantage to :\n- avoid None as the function (will be eliminate in py 3): http://bugs.python.org/issue2186\n- use only iterators."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://bugs.python.org/issue2186", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bugs.python.org/issue2186"}]}], [{"text": ["There is the plain old use of a for loop to append to a list too:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"senID": 1}, {"code": "<pre>\n<code>\n result = []\nfor x in mylist:\n    expense = expensive(x)\n    if expense:\n        result.append(expense)\n</code>\n</pre>\n", "senID": 2}, {"senID": 3}]]