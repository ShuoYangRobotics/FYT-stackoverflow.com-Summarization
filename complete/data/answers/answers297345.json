[[{"text": ["The only solution is to rewrite the method it uses for zipping files to read from a buffer.", "It would be trivial to add this to the standard libraries; I'm kind of amazed it hasn't been done yet.", "I gather there's a lot of agreement the entire interface needs to be overhauled, and that seems to be blocking any incremental improvements."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import zipfile, zlib, binascii, struct\nclass BufferedZipFile(zipfile.ZipFile):\n    def writebuffered(self, zipinfo, buffer):\n        zinfo = zipinfo\n\n        zinfo.file_size = file_size = 0\n        zinfo.flag_bits = 0x00\n        zinfo.header_offset = self.fp.tell()\n\n        self._writecheck(zinfo)\n        self._didModify = True\n\n        zinfo.CRC = CRC = 0\n        zinfo.compress_size = compress_size = 0\n        self.fp.write(zinfo.FileHeader())\n        if zinfo.compress_type == zipfile.ZIP_DEFLATED:\n            cmpr = zlib.compressobj(zlib.Z_DEFAULT_COMPRESSION, zlib.DEFLATED, -15)\n        else:\n            cmpr = None\n\n        while True:\n            buf = buffer.read(1024 * 8)\n            if not buf:\n                break\n\n            file_size = file_size + len(buf)\n            CRC = binascii.crc32(buf, CRC)\n            if cmpr:\n                buf = cmpr.compress(buf)\n                compress_size = compress_size + len(buf)\n\n            self.fp.write(buf)\n\n        if cmpr:\n            buf = cmpr.flush()\n            compress_size = compress_size + len(buf)\n            self.fp.write(buf)\n            zinfo.compress_size = compress_size\n        else:\n            zinfo.compress_size = file_size\n\n        zinfo.CRC = CRC\n        zinfo.file_size = file_size\n\n        position = self.fp.tell()\n        self.fp.seek(zinfo.header_offset + 14, 0)\n        self.fp.write(struct.pack(\"&lt;lLL\", zinfo.CRC, zinfo.compress_size, zinfo.file_size))\n        self.fp.seek(position, 0)\n        self.filelist.append(zinfo)\n        self.NameToInfo[zinfo.filename] = zinfo\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I took Chris B.", "'s answer and created a complete solution.", "Here it is in case anyone else is interested:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Chris B.'s answer", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/297345/create-a-zip-file-from-a-generator-in-python/299830#299830"}]}, {"code": "<pre>\n<code>\n import os\nimport threading\nfrom zipfile import *\nimport zlib, binascii, struct\n\nclass ZipEntryWriter(threading.Thread):\n    def __init__(self, zf, zinfo, fileobj):\n        self.zf = zf\n        self.zinfo = zinfo\n        self.fileobj = fileobj\n\n        zinfo.file_size = 0\n        zinfo.flag_bits = 0x00\n        zinfo.header_offset = zf.fp.tell()\n\n        zf._writecheck(zinfo)\n        zf._didModify = True\n\n        zinfo.CRC = 0\n        zinfo.compress_size = compress_size = 0\n        zf.fp.write(zinfo.FileHeader())\n\n        super(ZipEntryWriter, self).__init__()\n\n    def run(self):\n        zinfo = self.zinfo\n        zf = self.zf\n        file_size = 0\n        CRC = 0\n\n        if zinfo.compress_type == ZIP_DEFLATED:\n            cmpr = zlib.compressobj(zlib.Z_DEFAULT_COMPRESSION, zlib.DEFLATED, -15)\n        else:\n            cmpr = None\n        while True:\n            buf = self.fileobj.read(1024 * 8)\n            if not buf:\n                self.fileobj.close()\n                break\n\n            file_size = file_size + len(buf)\n            CRC = binascii.crc32(buf, CRC)\n            if cmpr:\n                buf = cmpr.compress(buf)\n                compress_size = compress_size + len(buf)\n\n            zf.fp.write(buf)\n\n        if cmpr:\n            buf = cmpr.flush()\n            compress_size = compress_size + len(buf)\n            zf.fp.write(buf)\n            zinfo.compress_size = compress_size\n        else:\n            zinfo.compress_size = file_size\n\n        zinfo.CRC = CRC\n        zinfo.file_size = file_size\n\n        position = zf.fp.tell()\n        zf.fp.seek(zinfo.header_offset + 14, 0)\n        zf.fp.write(struct.pack(\"&lt;lLL\", zinfo.CRC, zinfo.compress_size, zinfo.file_size))\n        zf.fp.seek(position, 0)\n        zf.filelist.append(zinfo)\n        zf.NameToInfo[zinfo.filename] = zinfo\n\nclass EnhZipFile(ZipFile, object):\n\n    def _current_writer(self):\n        return hasattr(self, 'cur_writer') and self.cur_writer or None\n\n    def assert_no_current_writer(self):\n        cur_writer = self._current_writer()\n        if cur_writer and cur_writer.isAlive():\n            raise ValueError('An entry is already started for name: %s' % cur_write.zinfo.filename)\n\n    def write(self, filename, arcname=None, compress_type=None):\n        self.assert_no_current_writer()\n        super(EnhZipFile, self).write(filename, arcname, compress_type)\n\n    def writestr(self, zinfo_or_arcname, bytes):\n        self.assert_no_current_writer()\n        super(EnhZipFile, self).writestr(zinfo_or_arcname, bytes)\n\n    def close(self):\n        self.finish_entry()\n        super(EnhZipFile, self).close()\n\n    def start_entry(self, zipinfo):\n        \"\"\"\n        Start writing a new entry with the specified ZipInfo and return a\n        file like object. Any data written to the file like object is\n        read by a background thread and written directly to the zip file.\n        Make sure to close the returned file object, before closing the\n        zipfile, or the close() would end up hanging indefinitely.\n\n        Only one entry can be open at any time. If multiple entries need to\n        be written, make sure to call finish_entry() before calling any of\n        these methods:\n        - start_entry\n        - write\n        - writestr\n        It is not necessary to explicitly call finish_entry() before closing\n        zipfile.\n\n        Example:\n            zf = EnhZipFile('tmp.zip', 'w')\n            w = zf.start_entry(ZipInfo('t.txt'))\n            w.write(\"some text\")\n            w.close()\n            zf.close()\n        \"\"\"\n        self.assert_no_current_writer()\n        r, w = os.pipe()\n        self.cur_writer = ZipEntryWriter(self, zipinfo, os.fdopen(r, 'r'))\n        self.cur_writer.start()\n        return os.fdopen(w, 'w')\n\n    def finish_entry(self, timeout=None):\n        \"\"\"\n        Ensure that the ZipEntry that is currently being written is finished.\n        Joins on any background thread to exit. It is safe to call this method\n        multiple times.\n        \"\"\"\n        cur_writer = self._current_writer()\n        if not cur_writer or not cur_writer.isAlive():\n            return\n        cur_writer.join(timeout)\n\nif __name__ == \"__main__\":\n    zf = EnhZipFile('c:/tmp/t.zip', 'w')\n    import time\n    w = zf.start_entry(ZipInfo('t.txt', time.localtime()[:6]))\n    w.write(\"Line1\\n\")\n    w.write(\"Line2\\n\")\n    w.close()\n    zf.finish_entry()\n    w = zf.start_entry(ZipInfo('p.txt', time.localtime()[:6]))\n    w.write(\"Some text\\n\")\n    w.close()\n    zf.close()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["gzip.GzipFile writes the data in gzipped chunks , which you can set the size of your chunks according to the numbers of lines read from the files."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["an example: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n file = gzip.GzipFile('blah.gz', 'wb')\nsourcefile = open('source', 'rb')\nchunks = []\nfor line in sourcefile:\n  chunks.append(line)\n  if len(chunks) &gt;= X: \n      file.write(\"\".join(chunks))\n      file.flush()\n      chunks = []\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The essential compression is done by zlib.compressobj.", "ZipFile (under Python 2.5 on MacOSX appears to be compiled).", "The Python 2.3 version is as follows."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can see that it builds the compressed file in 8k chunks.", "Taking out the source file information is complex because a lot of source file attributes (like uncompressed size) is recorded in the zip file header.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def write(self, filename, arcname=None, compress_type=None):\n    \"\"\"Put the bytes from filename into the archive under the name\n    arcname.\"\"\"\n\n    st = os.stat(filename)\n    mtime = time.localtime(st.st_mtime)\n    date_time = mtime[0:6]\n    # Create ZipInfo instance to store file information\n    if arcname is None:\n        zinfo = ZipInfo(filename, date_time)\n    else:\n        zinfo = ZipInfo(arcname, date_time)\n    zinfo.external_attr = st[0] &lt;&lt; 16L      # Unix attributes\n    if compress_type is None:\n        zinfo.compress_type = self.compression\n    else:\n        zinfo.compress_type = compress_type\n    self._writecheck(zinfo)\n    fp = open(filename, \"rb\")\n\n    zinfo.flag_bits = 0x00\n    zinfo.header_offset = self.fp.tell()    # Start of header bytes\n    # Must overwrite CRC and sizes with correct data later\n    zinfo.CRC = CRC = 0\n    zinfo.compress_size = compress_size = 0\n    zinfo.file_size = file_size = 0\n    self.fp.write(zinfo.FileHeader())\n    zinfo.file_offset = self.fp.tell()      # Start of file bytes\n    if zinfo.compress_type == ZIP_DEFLATED:\n        cmpr = zlib.compressobj(zlib.Z_DEFAULT_COMPRESSION,\n             zlib.DEFLATED, -15)\n    else:\n        cmpr = None\n    while 1:\n        buf = fp.read(1024 * 8)\n        if not buf:\n            break\n        file_size = file_size + len(buf)\n        CRC = binascii.crc32(buf, CRC)\n        if cmpr:\n            buf = cmpr.compress(buf)\n            compress_size = compress_size + len(buf)\n        self.fp.write(buf)\n    fp.close()\n    if cmpr:\n        buf = cmpr.flush()\n        compress_size = compress_size + len(buf)\n        self.fp.write(buf)\n        zinfo.compress_size = compress_size\n    else:\n        zinfo.compress_size = file_size\n    zinfo.CRC = CRC\n    zinfo.file_size = file_size\n    # Seek backwards and write CRC and file sizes\n    position = self.fp.tell()       # Preserve current position in file\n    self.fp.seek(zinfo.header_offset + 14, 0)\n    self.fp.write(struct.pack(\"&lt;lLL\", zinfo.CRC, zinfo.compress_size,\n          zinfo.file_size))\n    self.fp.seek(position, 0)\n    self.filelist.append(zinfo)\n    self.NameToInfo[zinfo.filename] = zinfo\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Some (many?", "most?", ") compression algorithms are based on looking at redundancies across the entire  file."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "entire", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Some compression libraries will choose between several compression algorithms based on which works best on the file."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I believe the ZipFile module does this, so it wants to see the entire file, not just pieces at a time."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Hence, it won't work with generators or files to big to load in memory.", "That would explain the limitation of the Zipfile library."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The gzip library will take a file-like object for compression."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class GzipFile([filename [,mode [,compresslevel [,fileobj]]]])\n</code>\n</pre>\n", "senID": 1}, {"text": ["You still need to provide a nominal filename for inclusion in the zip file, but you can pass your data-source to the fileobj."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["(This answer differs from that of Damnsweet, in that the focus should be on the data-source being incrementally read, not the compressed file being incrementally written."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "(This answer differs from that of Damnsweet, in that the focus should be on the data-source being incrementally read, not the compressed file being incrementally written.)", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["And I see now the original questioner won't accept Gzip :-("], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "And I see now the original questioner won't accept Gzip :-(", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}]]