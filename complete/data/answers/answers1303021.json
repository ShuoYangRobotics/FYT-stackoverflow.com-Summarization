[[{"text": ["The builtin hash function of strings is fairly collision free, and also fairly short.", "It has 2**32 values, so it is fairly unlikely that you encounter collisions (if you use its abs value, it will have only 2**31 values)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "2**32", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "2**31", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You have been asking for the shortest hash function.", "That would certainly be"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def hash(s):\n  return 0\n</code>\n</pre>\n", "senID": 2}, {"text": ["but I guess you didn't really mean it that way..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The birthday paradox applies: given a good hash function, the expected number of hashes before a collision occurs is about sqrt(N), where N is the number of different values that the hash function can take.", "(The wikipedia entry I've pointed to gives the exact formula).", "So, for example, if you want to use no more than 32 bits, your collision worries are serious for around 64K objects (i.e., 2**16 objects -- the square root of the 2**32 different values your hash function can take).", "How many objects do you expect to have, as an order of magnitude?"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "birthday paradox", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Birthday%5Fparadox#Cast%5Fas%5Fa%5Fcollision%5Fproblem"}, {"text": "2**16", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "2**32", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Since you mention that a collision is a minor annoyance, I recommend you aim for a hash length that's roughly the square of the number of objects you'll have, or a bit less but not MUCH less than that."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You want to make a filename - is that on a case-sensitive filesystem, as typical on Unix, or do you have to cater for case-insensitive systems too?", "This matters because you aim for short filenames, but the number of bits per character you can use to represent your hash as a filename changes dramatically on case-sensive vs insensitive systems."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["On a case-sensitive system, you can use the standard library's base64 module (I recommend the \"urlsafe\" version of the encoding, i.e.", "this function, as avoiding '/' characters that could be present in plain base64 is important in Unix filenames).", "This gives you 6 usable bits per character, much better than the 4 bits/char in hex."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "base64", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "this", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/base64.html#base64.urlsafe%5Fb64encode"}]}, {"text": ["Even on a case-insensitive system, you can still do better than hex -- use base64.b32encode and get 5 bits per character."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["These functions take and return strings; use the struct module to turn numbers into strings if your chosen hash function generates numbers."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "struct", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you do have a few tens of thousands of objects I think you'll be fine with builtin hash (32 bits, so 6-7 characters depending on your chosen encoding).", "For a million objects you'd want 40 bits or so (7 or 8 characters) -- you can fold (xor, don't truncate;-) a sha256 down to a long with a reasonable number of bits, say 128 or so, and use the % operator to cut it further to your desired length before encoding."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "%", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You can make any hash you like shorter by simply truncating it.", "md5 is always 32 hex digits, but an arbitrary substring of it (or any other hash) has the proper qualities of a hash: equal values produce equal hashes, and the values are spread around a bunch."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I'm sure that there's a CRC32 implementation in Python, but that may be too short (8 hex digits).", "On the upside, it's very quick."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Found it, binascii.crc32"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "binascii.crc32", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/binascii.html#binascii.crc32"}]}], [{"text": ["If you do have a collision, how are you going to tell that it actually happened?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If I were you, I would use hashlib to sha1() the repr(), and then just get a limited substring of it (first 16 characters, for example)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "sha1()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "repr()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Unless you are talking about huge numbers of these objects, I would suggest that you just use the full hash.", "Then the opportunity for collision is so, so, so, so small, that you will never live to see it happen (likely)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Also, if you are dealing with that many files, I'm guessing that your caching technique should be adjusted to accommodate it."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "that", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["We use hashlib.sha1.hexdigest(), which produces even longer strings, for cache objects with good success.", "Nobody is actually looking at cache files anyway."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Condsidering your use case, if you don't have your heart set on using separate cache files and you are not too far down that development path, you might consider using the shelve module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "shelve", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This will give you a persistent dictionary (stored in a single dbm file) in which you store your objects.", "Pickling/unpickling is performed transparently, and you don't have to concern yourself with hashing, collisions, file I/O, etc."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For the shelve dictionary keys, you would just use repr(obj) and let shelve deal with stashing your objects for you.", "A simple example:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "shelve", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import shelve\ncache = shelve.open('cache')\nt = (1,2,3)\ni = 10\ncache[repr(t)] = t\ncache[repr(i)] = i\nprint cache\n# {'(1, 2, 3)': (1, 2, 3), '10': 10}\ncache.close()\n\ncache = shelve.open('cache')\nprint cache\n#&gt;&gt;&gt; {'(1, 2, 3)': (1, 2, 3), '10': 10}\nprint cache[repr(10)]\n#&gt;&gt;&gt; 10\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Short hashes mean you may have same hash for two different files.", "Same may happen for big hashes too, but its way more rare.", "Maybe these file names should vary based on other references, like microtime (unless these files may be created too quickly)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You might also want to look at Ascii85 for even shorter filenames."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://en.wikipedia.org/wiki/Ascii85"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://en.wikipedia.org/wiki/Ascii85", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Ascii85"}]}, {"text": ["Hash with whatever, then encode the hash to a valid filename."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]