[[{"text": ["Don't reinvent the wheel.", "In Python 2.7+ you can use the Counter class:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "the Counter class", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/collections.html#collections.Counter"}]}, {"code": "<pre>\n<code>\n import collections\nfruit=['apple', 'orange', 'apple', 'banana', 'banana', 'orange', 'apple', 'apple']\nc=collections.Counter(fruit)\nprint(c.most_common(1))\n# [('apple', 4)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you are using an older version of Python, then you can download Counter here. "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Counter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://code.activestate.com/recipes/576611/", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["While it's good to know how to implement something like this yourself, it's also a good idea to get used to using Counter, since it is (or going to be) part of the standard library."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If the objects are hashable then you can use a dict to store the counts:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n results = {}\nfor item in somelist:\n  if item not in results:\n    results[item] = 1\n  else\n    results[item] += 1\n\nprint max(results.iteritems(), key=operator.itemgetter(1))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Keep a dictionary of how often each object appears."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Walk through the list once, building this table.", "As you go, keep track of which object has appeared the most often so far."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This code is untested."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\ndef mode(objects):\n    h = defaultdict(int)\n    max_f = 0\n    max_obj = None\n    for o in objects:\n        f = h[o] = h[o] + 1\n        if f &gt; max_f:\n            max_f = f\n            max_obj = o\n    return max_obj\n</code>\n</pre>\n", "senID": 3}, {"text": ["If the objects are not hashable, you can instead hash some unique feature of them, such as id(o)."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "id(o)", "tag": "a", "pos": 0, "childList": [{"text": "id(o)", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#id"}, {"text": "id(o)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You want an efficient method.", "Clearly it's possible in O(n) time, so any method that requires sorting the list is out as that would be O(n log(n)).", "It's not possible to do it faster than O(n) because even if you check the first n/2-1 elements, and they are all \"apple\", you don't know that the rest of the elements won't be bananas."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So given that we're looking for O(n), you must iterate over the list and keep a count of how many items of each type you've seen."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["A defaultdict would be a simple way to implement this in practice."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import defaultdict\n&gt;&gt;&gt; d = defaultdict(int)\n&gt;&gt;&gt; for i in ['apple', 'banana', 'apple']:\n...    d[i] += 1\n...\n&gt;&gt;&gt; d\ndefaultdict(&lt;type 'int'&gt;, {'apple': 2, 'banana': 1})\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The best time you can hope to achieve here is O(n) - you'll always need to walk the entire array at least once.", "The easiest way will certainly be to build a histogram.", "If your dictionary structure (map of some kind) offers O(1) insert and retrieve then this is as easy as (groovy-ish pseudocode):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "easiest", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def histogram = new HashMap()\ndef maxObj = null\ndef maxObjCount = 0\nobjectList.each {\n    if(histogram.contains(it)) histogram.put(it, histogram.get(it)+1)\n    else histogram.put(it, 1)\n\n    if(histogram.get(it) &gt; maxObjCount) {\n        maxObj = it\n        maxObjCount = histogram.get(it)\n    }\n}\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def count_reps(item, agg):\n  k = hash(item)\n  try:\n    agg[k] += 1\n  except KeyError:\n    agg[k] = 1\n  return agg\n\nitem_dict = reduce(your_array, {})\n</code>\n</pre>\n", "senID": 0}, {"text": ["item_dict will contain the counts, then you can rate the popularity of each object."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Heres a different approach which essentially sorts the list and then processes it in a sorted order."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fruits = ['apple', 'orange', 'apple', 'banana', 'banana', 'orange', 'apple', 'apple']\n\nmax_fruit_count = 0\nmax_fruit = ''\ncurrent_fruit_count = 0\ncurrent_fruit = ''\nfor fruit in sorted(fruits) :\n    if fruit != current_fruit :\n        if current_fruit != max_fruit :\n            if current_fruit_count &gt; max_fruit_count :\n                max_fruit = current_fruit\n                max_fruit_count = current_fruit_count\n        current_fruit = fruit\n        current_fruit_count = 1\n    else :\n        current_fruit_count += 1\n\nif current_fruit_count &gt; max_fruit_count :\n    max_fruit = current_fruit\n    max_fruit_count = current_fruit_count\n\nprint max_fruit, max_fruit_count\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is not O(n), but O(n^2), so it not may fit your bill as \"most efficient way\", but it's compact and avoids for loops, which are rather slow in Python.", "It will be faster than the O(n) option up to 11 unique items."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def most_common(items):\n    s = set(items)\n    return max([(items.count(i), i) for i in s])[1]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["As ~unutbu says:  use collections.Counter\nFailing that, time your code.", "Here is my (likely inefficient) approach:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n python -m timeit -s \"fruit = ['apple']*4 + ['banana'] + ['orange']*2\" \\\n\"kL = set(fruit);  L = [fruit.count(f) for f in kL];  D = dict(zip(kL,L)); \\\nsorted(D,key = lambda k: D[k],reverse=True)\" \n100000 loops, best of 3: 10.1 usec per loop\n</code>\n</pre>\n", "senID": 1}]]