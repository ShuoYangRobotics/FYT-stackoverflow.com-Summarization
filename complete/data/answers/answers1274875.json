[[{"text": ["I don't see what is wrong with returning (None,None).", "It is much cleaner than the solutions suggested here which involve far more changes in your code. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It also doesn't make sense that you want None to automagically be split into 2 variables."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Well, you could do..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n first,second = foo(True) or (None,None)\nfirst,second = foo(False) or (None,None)\n</code>\n</pre>\n", "senID": 1}, {"text": ["but as far as I know there's no simpler way to expand None to fill in the entirety of a tuple."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I don't think there's a trick.", "You can simplify your calling code to:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n values = foo(False)\nif values:\n    first, second = values\n</code>\n</pre>\n", "senID": 1}, {"text": ["or even:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n values = foo(False)\nfirst, second = values or (first_default, second_default)\n</code>\n</pre>\n", "senID": 3}, {"text": ["where first_default and second_default are values you'd give to first and second as defaults."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I think there is a problem of abstraction.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "abstraction", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["A function should maintain some level of abstraction, that helps in reducing complexity of the code.", "In this case, either the function is not maintaining the right abstraction, either the caller is not respecting it."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["The function could have been something like get_point2d(); in this case, the level of the abstraction is on the tuple, and therefore returning None would be a good way to signal some particular case (e.g.", "non-existing entity).", "The error in this case would be to expect two items, while actually the only thing you know is that the function returns one object (with information related to a 2d point).  "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "get_point2d()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["But it could also have been something like get_two_values_from_db(); in this case the abstraction would be broken by returning None, because the function (as the name suggest) should return two values and not one!"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "get_two_values_from_db()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "should return two values and not one", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Either way, the main goal of using a function - reducing complexity - is, at least partially, lost. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Note that this issue would not appear clearly with the original name; that's also why it is always important to give good names to function and methods."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["You should be careful with the x or y style of solution.", "They work, but they're a bit broader than your original specification.", "Essentially, what if foo(True) returns an empty tuple ()?", "As long as you know that it's OK to treat that as (None, None), you're good with the solutions provided."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "x or y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo(True)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "(None, None)", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["If this were a common scenario, I'd probably write a utility function like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # needs a better name! :)\ndef to_tup(t):\n    return t if t is not None else (None, None)\n\nfirst, second = to_tup(foo(True))\nfirst, second = to_tup(foo(False))\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n def foo(flag):\n    return ((1,2) if flag else (None, None))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["OK, I would just return (None, None), but as long as we are in whacko-land (heh), here is a way using a subclass of tuple.", "In the else case, you don't return None, but instead return an empty container, which seems to be in the spirit of things.", "The container's \"iterator\" unpacks None values when empty.", "Demonstrates the iterator protocol anyway..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Tested using v2.5.2:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Tuple(tuple):\n    def __iter__(self):\n        if self:\n            # If Tuple has contents, return normal tuple iterator...\n            return super(Tuple, self).__iter__()\n        else:\n            # Else return a bogus iterator that returns None twice...\n            class Nonerizer(object):\n                def __init__(self):\n                    self.x=0\n                def __iter__(self):\n                    return self\n                def next(self):\n                    if self.x &lt; 2:\n                        self.x += 1\n                        return None\n                    else:\n                        raise StopIteration\n            return Nonerizer()\n\n\ndef foo(flag):\n    if flag:\n        return Tuple((1,2))\n    else:\n        return Tuple()  # It's not None, but it's an empty container.\n\nfirst, second = foo(True)\nprint first, second\nfirst, second = foo(False)\nprint first, second\n</code>\n</pre>\n", "senID": 2}, {"text": ["Output is the desired:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n 1 2\nNone None\n</code>\n</pre>\n", "senID": 4}], [{"text": ["How about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ cat foo.py \ndef foo(flag):\n    if flag:\n        return (1,2)\n    else:\n        return (None,)*2\n\nfirst, second = foo(True)\nfirst, second = foo(False)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: Just to be clear, the only change is to replace return None with return (None,)*2.", "I am extremely surprised that no one else has thought of this.", "(Or if they have, I would like to know why they didn't use it."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "return None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "return (None,)*2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}]]