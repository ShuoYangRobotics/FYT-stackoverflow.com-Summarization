[[{"text": ["I guess you want to link some attribute \"data\" to foo:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Bar:\n    data = property(lambda self: foo())\n\n\nbar = Bar()\nbar.data # calls foo()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You're basically asking for a way to hijack a variable (how would you reassign it?", ") in the module namespace, which is not possible in Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You'll have to use attribute accessors of a class if you want the described behavior:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class MyClass(object):\n    def __getattr__(self, attr):\n        if attr == 'bar':\n            print 'getting bar... call the foo()!'\n        else:\n            return object.__getattribute__(self, attr)\n\n    def __setattr__(self, attr, val):\n        if attr == 'bar':\n            print 'bar was set to', val\n        else:\n            object.__setattr__(self, attr, val)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["\"any time bar is accessed\"... What kinds of accesses are your callers going to be making?", "(E.g.", "are they doing \"1+bar\", are they doing \"bar[5:]\", are they doing \"bar.func()\", etc).", "Will they call the Bar() constructor each time?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Right now, your question is so fuzzy and general that I think it's impossible.", "But if you're a bit more specific then we might be able to help."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Is this what you're looking for?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo(): print('foo() was called');\n...\n&gt;&gt;&gt; class Bar:\n...     pass;\n...\n&gt;&gt;&gt; bar = Bar();\n&gt;&gt;&gt; bar.data = foo;\n&gt;&gt;&gt; bar.data()\nfoo() was called\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Thanks for the clarification!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This just can't work!", "A variable is a variable in most languages, not a function-call.", "You can do much in Python, but you just can't do that."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The reason is, that you have always some intrinsic language rules.", "One rule in Python is, that variables are variables.", "When you read a variable (not modifying it or anything else) you can rely, that it will be the same in the next code-line."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Monkeypatching it to be a function call would just change this rule."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["What you want, could only be done by a still more dynamic language.", "Something like a macro-processing system or a language that do not have variables but something like labels that can be attached to anything.", "But this would also make compiler-creation for it much more difficult -- hence fully dynamic.", "The compiler would have to take all coding in the program into account."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You can override Bar's __new__ method to execute arbitrary code and return a new instance.", "See: http://docs.python.org/reference/datamodel.html#object.__new__"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/reference/datamodel.html#object.__new__", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html#object.__new__"}]}, {"text": ["Here's a contrived example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class Bar(object):\n...     def __new__(cls):\n...             print \"Calling Bar.__new__\"\n...             return super(Bar, cls).__new__(cls)\n...\n&gt;&gt;&gt; bar = Bar()\nCalling Bar.__new__\n&gt;&gt;&gt; bar\n&lt;__main__.Bar object at 0x0222B3D0&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["EDIT: I misunderstood what you wanted, your clarification cleared that up.", "I don't think what you want is possible."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you want the results of foo(), the easiest way is to do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n foo()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Anything else is just unnecessary complication.", "I suspect that you have oversimplified your example until it doens't make sense."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: OK, so you are trying to change somebody elses code.", "No, it's not possible to transform a variable to a method in a generic way.", "You could replace it with an object that will return different variables of it's used in a way that consistently will cause some sort of python method to be called. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["barrio.py:\n    bar = \"Some sort of string\""], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["fool.py:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import random\n\nclass Foo:\n    def __str__(self):\n        return str(random.random())\n\nimport barrio\nbarrio.bar = Foo()\n</code>\n</pre>\n", "senID": 6}, {"text": ["Now run python:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import fool\n&gt;&gt;&gt; import barrio\n\n&gt;&gt;&gt; print barrio.bar\n0.783394625457\n&gt;&gt;&gt; print barrio.bar\n0.662363816543\n&gt;&gt;&gt; print barrio.bar\n0.342930701226\n&gt;&gt;&gt; print barrio.bar\n0.781452467433\n</code>\n</pre>\n", "senID": 8}, {"text": ["This works because print will call str on the object, since it's not a string.", "But in general, no, it's not possible."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "str", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}]]