[[{"text": ["Keeping your data lying around in a header makes it trickier to get at using other programs like Perl.", "Another approach you might consider is to keep this data in a database or another file and regenerate your header file as-needed, maybe even as part of your build system.", "The reason for this is that generating C is much easier than parsing C, it's trivial to write a script that parses a text file and makes a header for you, and such a script could even be invoked from your build system. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Assuming that you want to keep your data in a C header file, you will need one of two things to solve this problem:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "a quick one-off script to parse exactly (or close to exactly) the input you describe. ", "tag": "none", "senID": 2}, {"text": "a general, well-written script that can parse arbitrary C and work generally on to lots of different headers. ", "tag": "none", "senID": 3}]}, {"text": ["The first case seems more common than the second to me, but it's hard to tell from your question if this is better solved by a script that needs to parse arbitrary C or a script that needs to parse this specific file.", "For code that works on your specific case, the following works for me on your input:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/perl -w\n\nuse strict;\n\nopen FILE, \"&lt;header.h\" or die $!;\nmy @file = &lt;FILE&gt;;\nclose FILE or die $!;\n\nmy $in_block = 0;\nmy $regex = 'Some_Idx\\[\\]';\nmy $byte_line = '';\nmy @byte_entries;\nforeach my $line (@file) {\n    chomp $line;\n\n    if ( $line =~ /$regex.*\\{(.*)/ ) {\n    \t$in_block = 1;\n    \tmy @digits = @{ match_digits($1) };\n    \tpush @digits, @byte_entries;\n    \tnext;\n    }\n\n    if ( $in_block ) {\n    \tmy @digits = @{ match_digits($line) };\n    \tpush @byte_entries, @digits;\n    }\n\n    if ( $line =~ /\\}/ ) {\n    \t$in_block = 0;\n    }\n}\n\nprint \"const BYTE Some_Idx_Mod_mul_2[] = {\\n\";\nprint join \",\", map { $_ * 2 } @byte_entries;\nprint \"};\\n\";\n\nsub match_digits {\n    my $text = shift;\n    my @digits;\n    while ( $text =~ /(\\d+),*/g ) {\n    \tpush @digits, $1;\n    }\n\n    return \\@digits;\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["Parsing arbitrary C is a little tricky and not worth it for many applications, but maybe you need to actually do this.", "One trick is to let GCC do the parsing for you and read in GCC's parse tree using a CPAN module named GCC::TranslationUnit.", "Here's the GCC command to compile the code, assuming you have a single file named test.c:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "GCC::TranslationUnit", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://search.cpan.org/~awin/GCC-TranslationUnit-1.00/TranslationUnit.pm"}]}, {"text": ["gcc -fdump-translation-unit -c test.c "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Here's the Perl code to read in the parse tree:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n use GCC::TranslationUnit;\n\n  # echo '#include &lt;stdio.h&gt;' &gt; stdio.c\n  # gcc -fdump-translation-unit -c stdio.c\n  $node = GCC::TranslationUnit::Parser-&gt;parsefile('stdio.c.tu')-&gt;root;\n\n  # list every function/variable name\n  while($node) {\n    if($node-&gt;isa('GCC::Node::function_decl') or\n       $node-&gt;isa('GCC::Node::var_decl')) {\n      printf \"%s declared in %s\\n\",\n        $node-&gt;name-&gt;identifier, $node-&gt;source;\n    }\n  } continue {\n    $node = $node-&gt;chain;\n  }\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Sorry if this is a stupid question, but why worry about parsing the file at all?", "Why not write a C program that #includes the header, processes it as required and then spits out the source for the modified header.", "I'm sure this would be simpler than the Perl/Python solutions, and it would be much more reliable because the header would be being parsed by the C compilers parser."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You don't really provide much information about how what is to be modified should be determined, but to address your specific example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ perl -pi.bak -we'if ( /const BYTE Some_Idx/ .. /;/ ) { s/Some_Idx/Some_Idx_Mod_mul_2/g; s/(\\d+)/$1 * 2/ge; }' header.h\n</code>\n</pre>\n", "senID": 1}, {"text": ["Breaking that down, -p says loop through input files, putting each line in $_, running the supplied code, then printing $_.", "-i.bak enables in-place editing, renaming each original file with a .bak suffix and printing to a new file named whatever the original was.", "-w enables warnings.", "-e'....' supplies the code to be run for each input line.", "header.h is the only input file."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "$_", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "$_", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["In the perl code, if ( /const BYTE Some_Idx/ .. /;/ ) checks that we are in a range of lines beginning with a line matching /const BYTE Some_Idx/ and ending with a line matching /;/.", "s/.../.../g does a substitution as many times as possible.", "/(\\d+)/ matches a series of digits.", "The /e flag says the result ($1 * 2) is code that should be evaluated to produce a replacement string, instead of simply a replacement string.", "$1 is the digits that should be replaced."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "if ( /const BYTE Some_Idx/ .. /;/ )", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "/const BYTE Some_Idx/", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "/;/", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "/(\\d+)/", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "$1 * 2", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["If all you need to do is to modify structs, you can directly use regex to split and apply changes to each value in the struct, looking for the declaration and the ending }; to know when to stop."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you really need a more general solution you could use a parser generator, like PyParsing"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "PyParsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}]}], [{"text": ["There is a Perl module called Parse::RecDescent which is a very powerful recursive descent parser generator.", "It comes with a bunch of examples.", "One of them is a grammar that can parse C."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Parse::RecDescent", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/dist/Parse-RecDescent"}, {"text": "grammar that can parse C", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://cpansearch.perl.org/src/DCONWAY/Parse-RecDescent-1.96.0/demo/demo%5FCgrammar%5Fv2.pl"}]}, {"text": ["Now, I don't think this matters in your case, but the recursive descent parsers using Parse::RecDescent are algorithmically slower (O(n^2), I think) than tools like Parse::Yapp or Parse::EYapp.", "I haven't checked whether Parse::EYapp comes with such a C-parser example, but if so, that's the tool I'd recommend learning."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Parse::Yapp", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/dist/Parse-Yapp"}, {"text": "Parse::EYapp", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://search.cpan.org/dist/Parse-EYapp"}]}], [{"text": ["Python solution (not full, just a hint ;)) Sorry if any mistakes - not tested"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\ntext = open('your file.c').read()\npatt = r'(?is)(.*?{)(.*?)(}\\s*;)'\nm = re.search(patt, text)\ng1, g2, g3 = m.group(1), m.group(2), m.group(3)\ng2 = [int(i) * 2 for i in g2.split(',')\nout = open('your file 2.c', 'w')\nout.write(g1, ','.join(g2), g3)\nout.close()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There is a really useful Perl module called Convert::Binary::C that parses C header files and converts structs from/to Perl data structures."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Convert::Binary::C", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/dist/Convert-Binary-C/lib/Convert/Binary/C.pm"}]}], [{"text": ["You could always use pack / unpack, to read, and write the data."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "pack", "tag": "a", "pos": 0, "childList": [{"text": "pack", "tag": "code"}], "childNum": 1, "href": "http://perldoc.perl.org/functions/pack.html"}, {"text": "pack", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://perldoc.perl.org/functions/unpack.html", "text": "unpack", "childNum": 1, "tag": "a", "childList": [{"text": "unpack", "tag": "code"}]}, {"text": "unpack", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n #! /usr/bin/env perl\nuse strict;\nuse warnings;\nuse autodie;\n\nmy @data;\n{\n  open( my $file, '&lt;', 'Some_Idx.bin' );\n\n  local $/ = \\1; # read one byte at a time\n\n  while( my $byte = &lt;$file&gt; ){\n    push @data, unpack('C',$byte);\n  }\n  close( $file );\n}\n\nprint join(',', @data), \"\\n\";\n\n{\n  open( my $file, '&gt;', 'Some_Idx_Mod_mul_2.bin' );\n\n  # You have two options\n  for my $byte( @data ){\n    print $file pack 'C', $byte * 2;\n  }\n  # or\n  print $file pack 'C*', map { $_ * 2 } @data;\n\n  close( $file );\n}\n</code>\n</pre>\n", "senID": 1}], [{"text": ["For the GCC::TranslationUnit example see hparse.pl from http://gist.github.com/395160\nwhich will make it into C::DynaLib, and the not yet written Ctypes also.", "This parses functions for FFI's, and not bare structs contrary to Convert::Binary::C. \nhparse will only add structs if used as func args."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://gist.github.com/395160", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://gist.github.com/395160"}]}]]