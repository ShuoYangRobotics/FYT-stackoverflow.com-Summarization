[[{"text": ["You can add attribute dynamically to objects using setattr"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "setattr", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for x in buttons:\n    name = str(x)\n    button = QtGui.QPushButton(Frame)\n    button.setText(name)\n    button.clicked.connect(self.changeProject(name))\n    setattr(self, \"btn_%s\" % name, button)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["What the error message is telling you is that self.changeProject(\"%s\") for one of the values you're substituting for that %s returns None.", "Presumably you meant for that method to return something different?"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "self.changeProject(\"%s\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "%s", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["It's impossible to help you much with the task of debugging changeProject further without seeing the code for it, of course.", "However, you could for example split the call into something like (once you've gotten rid of that ton of execs as per lazy1's suggestion):"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "changeProject", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n cp_result = self.changeProject(name)\nif cp_result is None:\n    logging.error('changeProject(%s) is None!', name)\nelse:\n    logging.info('changeProject(%s) is OK (%r)', name, cp_result)\n    button.clicked.connect(cp_result)\n</code>\n</pre>\n", "senID": 2}, {"text": ["This way instead of uselessly trying to \"connect to None\", you'll see all the names causing that to-you-surprising return value in your error log, and can then continue debugging based on that information.", "However, more likely than not, your bug might in fact become obvious by looking at the source of changeProject."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "changeProject", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Edit: the argument to connect is of course coming from changeProject (not from another connect!-) -- fixed the snippet accordingly."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "connect", "childNum": 0, "tag": "code", "childList": []}, {"text": "changeProject", "childNum": 0, "tag": "code", "childList": []}, {"text": "connect", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I think you running 'exec' is too much, IMO.", "Your problem is that you are trying to connect to the QPushButton's .clicked(), which is really a signal.", "Do you really need to pass the argument here\n\nexec 'self.btn_%s.clicked.connect(self.changeProject(\"%s\"))' % (x, x)\nBecause if you don't you can connect it like this:\nself.connect(self.btn_%s, SIGNAL('clicked()'), self.changeProject)\nIf you need to know which button is clicked you can iterate through the list to find which button is clicked:\nfor x in buttons:if x.isDown(): (function)"], "childNum": 16, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "exec 'self.btn_%s.clicked.connect(self.changeProject(\"%s\"))' % (x, x)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "self.connect(self.btn_%s, SIGNAL('clicked()'), self.changeProject)", "childNum": 0, "tag": "code", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "for x in buttons:if x.isDown(): (function)", "childNum": 1, "tag": "code", "childList": [{"text": "", "tag": "br"}]}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["You can also use pyqtSignal."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Thanks for the assistance.", "I stumbled QSignalMapper, and this turned out to be exactly what I needed. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://pysnippet.blogspot.com/2010/06/qsignalmapper-at-your-service.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://pysnippet.blogspot.com/2010/06/qsignalmapper-at-your-service.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pysnippet.blogspot.com/2010/06/qsignalmapper-at-your-service.html"}]}], [{"text": ["QSignalMapper is the accepted way to accomplish this with Qt, but I have found it to be somewhat cumbersome with PyQt since there are some simpler options available.", "The easiest is probably to 1) tag each button with a unique id so you can tell them apart (or just use the button's text), then 2) use QObject.sender() to determine which button emitted the signal.", "For example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for x in self.buttons:\n    name = str(x)\n    button = QtGui.QPushButton(Frame)\n    button.setText(name)\n    button.uniqueId = name  ## make this whatever you want..\n    button.clicked.connect(buttonClicked)\n\ndef buttonClicked():\n    button = QObject.sender()\n    uid = button.uniqueId  ## got your ID back\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'd like to necro this and mention another strategy/hack I just employed to solve this strategy.", "This is a somewhat specific strategy that wouldn't always work, but what I opted to do for a more recent implementation of this kind of setup was set the buttons as checkable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This wound up being the path of least-resistance since I was then able to iterate through the layout and simply check which button held true for .isChecked().", "No SignalMapping or extra attributes necessary."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]