[[{"text": ["You could do it using a recursive generator function.", "I assume that the root node in the tree always comes before all its children in the original list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n tree = [[0, 1], [1, 2], [2, 3], [2, 4], [2, 5], [5, 6], [4, 6], [3, 6],\n        [0, 7], [7, 6], [8, 9], [9, 6]]\n\npaths = {}\nfor t in tree:\n    if t[0] not in paths: paths[t[0]] = []\n    paths[t[0]].append(tuple(t))\n\nused = set()\n\ndef get_paths(node):\n    if node[1] in paths:\n        for next_node in paths[node[1]]:\n            used.add(next_node)\n            for path in get_paths(next_node):\n                yield [node[0]] + path\n    else:\n        yield [node[0], node[1]]\n\nfor node in tree:\n    if tuple(node) in used: continue\n    for path in get_paths(node):\n        print path\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [0, 1, 2, 3, 6]\n[0, 1, 2, 4, 6]\n[0, 1, 2, 5, 6]\n[0, 7, 6]\n[8, 9, 6]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Explanation: First I construct a list of all possible paths from each node.", "Then for each node that I haven't used yet I assume it is a root node and recursively find which paths lead from it.", "If no paths are found from any node, it is a leaf node and I stop the recursion and return the path found."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If the assumption about the order of the nodes does not hold then you would first have to find the set of all root nodes.", "This can be done by finding all nodes that do not appear as the second node in any connection."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["From what I understand of your question, it looks like you have a set of parent-child relationships as a list of pairs that describes a tree.", "You seem to be running into trouble by thinking that it has a structure like a linked list.", "Unlike a linked list, a tree is a more general form, it can have multiple nodes that 'follow' a given node that are called its children."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "tree", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Tree_%28data_structure%29"}]}, {"text": ["The easiest way is to simply build the tree first and then traverse it from the root.", "Define a Node class that has two fields, one for the value of the node and the other a list of children.", "Then you iterate over the items of your list adding the second element of each pair to the children list of node corresponding to the first element of the pair.", "After the tree is built, you use a recursive print function that prints the current node and calls itself on its children (if there are any).", "Calling the function on the root node should print the whole tree."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I would post some code, but this looks a lot like homework.", "The above explanation should be enough for a start. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The easiest way I can think of, would be to construct a dictionary that contains all possible children for a given parent, like so:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d = {}\n\nfor parent, child in tree:\n    try:\n        d[parent].append(child)\n    except KeyError:\n        d[parent] = [child]\n</code>\n</pre>\n", "senID": 1}, {"text": ["with tree = [[0, 1], [1, 2], [2, 3], [2, 4], [2, 5], [5, 6], [4, 6], [3, 6], [0, 7], [7, 6], [8, 9], [9, 6]],\nthis would produce:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {0: [1, 7],\n 1: [2],\n 2: [3, 4, 5],\n 3: [6],\n 4: [6],\n 5: [6],\n 7: [6],\n 8: [9],\n 9: [6]}\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now it's possible to recursively traverse the tree like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def printPaths(d, currentPath):\n    if currentPath[-1] not in d:\n        print currentPath # last node can't possibly be a parent, so stop\n    else:\n        for child in d[currentPath[-1]]:\n            printPaths(d, currentPath + [child])\n\n\nfor root in d:\n    printPaths(d, [root])\n</code>\n</pre>\n", "senID": 5}, {"text": ["I haven't tested the recursion, but it should give you an idea :)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Looking at the problem, it seems the best approach might be to build the arrays backwards over several iterations.", "My idea is this, but note we have to assume that this is a tree and so the leaves can only be used once:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Obviously you'll have to do some work to turn that into code, but that's a rough idea."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You could use the find_all_paths function from the following page:\nhttp://www.python.org/doc/essays/graphs/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.python.org/doc/essays/graphs/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/essays/graphs/"}]}, {"text": ["In order to use this you need to make two minor tweeks to your graph.", "First, loop through your list of edges and create a new representation of the graph like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["graph = {0: [1, 7],\n             1: [2],\n             2: [3, 4, 5],\n             ...}\nSecondly create a supersink (in your example case you could call it 10) and attach all vertices with no edges leading from them to this new node."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "graph = {0: [1, 7],\n             1: [2],\n             2: [3, 4, 5],\n             ...}", "childNum": 1, "tag": "pre", "pos": 0, "childList": [{"text": "graph = {0: [1, 7],\n             1: [2],\n             2: [3, 4, 5],\n             ...}", "tag": "code"}]}, {"text": "graph = {0: [1, 7],\n             1: [2],\n             2: [3, 4, 5],\n             ...}", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Then you can call the function find_all_paths(graph, 0, 10) to find all such paths."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "find_all_paths(graph, 0, 10)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Produce all longest pathes from all possible starting nodes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n tree = [[0, 1], [1, 2], [2, 3], ...]\n\ndtree = {}\nfor (k, v) in tree:\n   dtree.setdefault(k, []).append(v)\n\nparts = [[root] for root in range(10)]\n\nwhile parts:\n   path = parts.pop(0)\n   if path[-1] in dtree:\n      for n in dtree[path[-1]]:\n         parts.append(path + [n])\n   else:\n      print path\n</code>\n</pre>\n", "senID": 1}, {"text": ["If it should only produce paths that are not part of a different, longer path starting at some other node, parts would need to be initialized to all nodes not contained in [p[1] for p in tree].", "And if you want all paths instead, not just the longest ones, there should be a print in every iteration of the while-loop."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "parts", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[p[1] for p in tree]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "all", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["Here you go.", "Not the nicest code on earth but it works:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n inputValues = [[0, 1], [1, 2], [2, 3], [2, 4], [2, 5], [5, 6], [4, 6], [3, 6], [0, 7], [7, 6], [8, 9], [9, 6]]\n\ntree = {}\nnumberOfChildren = {}\nfor (f, t) in inputValues:\n  if not tree.has_key(f):\n    tree[f] = []\n  tree[f].append(t)\n  if not numberOfChildren.has_key(t):\n    numberOfChildren[t] = 0\n  numberOfChildren[t] += 1\n\nroots = [c for c in tree if c not in numberOfChildren]\npermutations = []\n\ndef findPermutations(node, currentList):\n  global tree\n  global permutations\n  if not tree.has_key(node):\n    permutations.append(currentList)\n    return\n  for child in tree[node]:\n    l = list()\n    l.extend(currentList)\n    l.append(child)\n    findPermutations(child, l)\n\nfor r in roots:\n  findPermutations(r, [r])\n\nprint permutations\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The following works - generate the trees starting from root.", "The roots are considered the nodes that do not have a parent."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\ndef genpaths(data):\n    # Initialize dictionary\n    ddata = {}\n    for item in data:\n        ddata.setdefault(item[0], []).append(item[1])\n    def genpath(root):\n        \"Generate paths starting with root\"\n        if root not in ddata:\n            yield (root, )\n        else:\n            for child in ddata[root]:\n                for path in genpath(child):\n                    yield (root, ) + path\n\n    for root in set(ddata.keys()) - set(reduce(operator.add, ddata.values())):\n        for path in genpath(root):\n            print path\n</code>\n</pre>\n", "senID": 1}]]