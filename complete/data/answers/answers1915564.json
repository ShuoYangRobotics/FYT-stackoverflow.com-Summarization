[[{"text": ["To get the dictionary sorted:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from operator import itemgetter\n\nsorted(adict.iteritems(), key=itemgetter(1), reverse=True)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A dict's keys, reverse-sorted by the corresponding values, can best be gotten as"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sorted(adict, key=adict.get, reverse=True)\n</code>\n</pre>\n", "senID": 1}, {"text": ["since you want key/value pairs, you could work on the items as all other answers suggest, or (to use the nifty adict.get bound method instead of itemgetters or weird lambdas;-),"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "adict.get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n [(k, adict[k]) for k in sorted(adict, key=adict.get, reverse=True)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit: in terms of performance, there isn't much into it either way:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'adict=dict((x,x**2) for x in range(-5,6))' '[(k, adict[k]) for k in sorted(adict, key=adict.get, reverse=True)]'\n100000 loops, best of 3: 10.8 usec per loop\n$ python -mtimeit -s'adict=dict((x,x**2) for x in range(-5,6)); from operator import itemgetter' 'sorted(adict.iteritems(), key=itemgetter(1), reverse=True)'\n100000 loops, best of 3: 9.66 usec per loop\n$ python -mtimeit -s'adict=dict((x,x**2) for x in range(-5,6))' 'sorted(adict.iteritems(), key=lambda (k,v): v, reverse=True)'\n100000 loops, best of 3: 11.5 usec per loop\n</code>\n</pre>\n", "senID": 5}, {"text": ["So, the .get-based solution is smack midway in performance between the two items-based ones -- slightly slower than the itemgetter, slightly faster than the lambda.", "In \"bottleneck\" cases, where those microsecond fractions are crucial to you, by all means do focus on that.", "In normal cases, where this operation is only one step within some bigger task and a microsecond more or less matters little, focusing on the simplicity of the get idiom is, however, also a reasonable alternative."], "childNum": 5, "tag": "p", "senID": 6, "childList": [{"text": ".get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "items", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "itemgetter", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "get", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["Just sort the resulting dict by values:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for k, v in sorted(adict.items(), key=lambda kv: kv[1], reverse=True):\n    print(\"%s =&gt; %s\" % (k,v))\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n from collections import defaultdict\nadict = defaultdict(int)\n\nadict['a'] += 1\nadict['b'] += 3\nadict['c'] += 5\nadict['d'] += 2\n\nfor key, value in sorted(adict.items(), lambda a, b: cmp(a[1], b[1]), reverse=True):\n    print \"%r =&gt; %r\" % (key, value)\n\n&gt;&gt;&gt; \n'c' =&gt; 5\n'b' =&gt; 3\n'd' =&gt; 2\n'a' =&gt; 1\n</code>\n</pre>\n", "senID": 0}, {"text": ["&nbsp;"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If you're using the newest python 2.7 alpha, then you can use the Counter class in collections module:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Counter", "tag": "a", "pos": 0, "childList": [{"text": "Counter", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/dev/library/collections.html#collections.Counter"}, {"text": "Counter", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n c = Counter()\n\nc['someval'] += 1\nc['anotherval'] += 1\nc['someval'] += 1\n\nprint c.most_common()\n</code>\n</pre>\n", "senID": 1}, {"text": ["prints in the correct order:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [('someval', 2), ('anotherval', 1)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["The code used on 2.7 is available already and there's a version adapted to 2.5.", "Perhaps you want to use it to stay forward compatible with the native stdlib version that is about to be released."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "available already", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Lib/collections.py?view=markup"}, {"text": "adapted to 2.5", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/576611/"}]}], [{"text": ["\"Invert\" a dictionary."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import defaultdict\ninv_dict = defaultdict( list )\nfor key, value in adict:\n    inv_dict[value].append( key )\nmax_value= max( inv_dict.keys() )\n</code>\n</pre>\n", "senID": 1}, {"text": ["The set of keys with the maximum occurrence -- "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n inv_dict[max_value]\n</code>\n</pre>\n", "senID": 3}, {"text": ["The set of keys in descending order by occurrence --"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n for value, key_list in sorted( inv_dict ):\n    print key_list, value\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Note: I'm putting this in as an answer so that it gets seen.", "I don't want upvotes.", "If you want to upvote anyone, upvote Nadia."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Note: I'm putting this in as an answer so that it gets seen. I don't want upvotes. If you want to upvote anyone, upvote Nadia.", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["Thecurrentlyaccepted answer gives timing results which are based on a trivially small dataset (size == 6 - (-5) == 11).", "The differences in cost of the various methods are masked by the overhead.", "A use case like what are the most frequent words in a text or most frequent names in a membership list or census involves much larger datasets."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Thecurrentlyaccepted answer gives timing results which are based on a trivially small dataset", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "currently", "tag": "em"}]}, {"text": "currently", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["Repeating the experiment with range(-n,n+1) (Windows box, Python 2.6.4, all times in microseconds):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["n=5: 11.5, 9.34, 11.3\nn=50: 65.5, 46.2, 68.1\nn=500: 612, 423, 614  "], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["These results are NOT \"slightly\" different.", "The itemgetter answer is a clear winner on speed."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "These results are NOT \"slightly\" different.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "The itemgetter answer is a clear winner on speed.", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["There was also mention of \"the simplicity of thegetidiom\".", "Putting them close together for ease of comparison:"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "the simplicity of thegetidiom", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "get", "tag": "code"}]}, {"text": "get", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["[(k, adict[k]) for k in sorted(adict, key=adict.get, reverse=True)]\nsorted(adict.iteritems(), key=itemgetter(1), reverse=True)"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "[(k, adict[k]) for k in sorted(adict, key=adict.get, reverse=True)]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sorted(adict.iteritems(), key=itemgetter(1), reverse=True)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The get idiom not only looks up the dict twice (as J. F. Sebastian has pointed out), it makes one list (result of sorted()) then iterates over that list to create a result list.", "I'd call that baroque, not simple.", "YMMV."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sorted()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "baroque, not simple", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}]]