[[{"text": ["The difference is that if you replace factors[units_to ] with 1.0 / 2.54, you're doing:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "factors[units_to ]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "1.0 / 2.54", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n (base_value * 1.0) / 2.54\n</code>\n</pre>\n", "senID": 1}, {"text": ["With the dictionary, you're doing:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n base_value * (1.0 / 2.54)\n</code>\n</pre>\n", "senID": 3}, {"text": ["The order of rounding matters.", "This is easier to see if you do:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print (((25.4 / 10.0) * 1.0) / 2.54).__repr__()\n1.0\n&gt;&gt;&gt; print ((25.4 / 10.0) * (1.0 / 2.54)).__repr__()\n0.99999999999999989\n</code>\n</pre>\n", "senID": 5}, {"text": ["Note that there is no non-deterministic or undefined behavior.", "There is a standard, IEEE-754, which implementations must conform to (not to claim they always do)."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "do", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["I don't think there should be an automatic close enough replacement.", "That is often an effective way to deal with the problem, but it should be up to the programmer to decide if and how to use it."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "automatic", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Finally, there are of course options for arbitrary-precision arithmetic, including python-gmp and decimal.", "Think whether you actually need these, because they do have a significant performance impact."], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "python-gmp", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/python-gmp/"}, {"text": "decimal", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/decimal.html"}, {"text": "need", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["There is no issue with moving between regular registers and cache.", "You may be thinking of the x86's 80-bit extended precision."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "extended precision", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Extended_precision"}]}], [{"text": ["Let me first answer by saying that you should read David Goldberg's classic What Every Computer Scientist Should Know About Floating-Point Arithmetic."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "What Every Computer Scientist Should Know About Floating-Point Arithmetic", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.102.244&rep=rep1&type=pdf"}]}, {"text": ["As some other commentators already said, the discrepancy you notice is intrinsically due to the floating-point model and has nothing to do with registers, cache or memory. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["According to the floating-point model, 2.54 is actually represented as "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 2859785763380265 * 2 ** -50\n2.54\n</code>\n</pre>\n", "senID": 3}, {"text": ["This representation, however is not exact:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; float(Fraction(2859785763380265, 2 ** 50) - Fraction(254, 100))\n3.552713678800501e-17\n</code>\n</pre>\n", "senID": 5}, {"text": ["Now, the expression you are evaluating actually is:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 25.4 / 10 * (1/2.54)\n0.99999999999999989\n</code>\n</pre>\n", "senID": 7}, {"text": ["The problem lies in the 1/2.54:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; Fraction.from_float(1/2.54)\nFraction(1773070719437203, 4503599627370496)\n</code>\n</pre>\n", "senID": 9}, {"text": ["But what you would expect is "], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 1/Fraction.from_float(2.54)\nFraction(1125899906842624, 2859785763380265)\n</code>\n</pre>\n", "senID": 11}, {"text": ["To answer your questions:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "It ", "tag": "none", "senID": 13}, {"text": "You cannot automatically replace equality with a ", "tag": "none", "senID": 14}]}], [{"text": ["As has been shown comparing two floats (or doubles etc) can be problematic.", "Generally, instead of comparing for exact equality they should be checked against an error bound.", "If they are within the error bound, they are considered equal."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That is much easier said than done.", "The nature of floating point make a fixed error bound worthless.", "A small error bound (like 2*float_epsilon) works well when the values are near 0.0, but will fail if the value are near 1000.", "An error bound for values as large as 1,000,000.0 will be far too lax for values near 0.0."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The best solution is know the domain of your math and pick an approriate err bound on a case by case basis."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["When this is impractical or you're being lazy, Units in the Last Place (ULPs) is a very novel and robust solution.", "The full details are quite involved, you can read more here, more specifically this section."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "Units in the Last Place", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"}, {"href": "http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm", "text": "this section", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["The basic idea is this, a floating point number has two pieces, mantissa and exponent.", "Generally rounding errors only change the mantissa by a few steps.", "When the value is near 0.0 those steps are exactly float_epsilon.", "When the floating point value is nearer to 1,000,000, the steps will be nearly as large as 1."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "steps", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "steps", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Google test uses ULP to compare floating point numbers.", "They chose a default of 4 ULPs for a two floating point numbers to be compared equal.", "You could also use their code as reference to build your own ULP style float comparator."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "Google test", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/googletest/"}, {"text": "compare floating point numbers", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://code.google.com/p/googletest/wiki/GoogleTestAdvancedGuide#Floating-Point_Comparison"}]}], [{"text": ["Thanks for your responses.", "Most were very good and provided good links so I'll just say that and answer my own question."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Caspin posted this link..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"}]}, {"text": ["He also mentioned that Google Tests used ULP comparison and when I looked at the google code I saw that they mentioned the same exact link to cygnus-software."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I wound up implementing some of the algorithms in C as a Python extension and then later found that I could do it in pure Python as well.", "The code is posted below."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In the end, I will probably just wind up adding ULP differences to my bag of tricks."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["It was interesting to see how many floating points are between what should be two equal numbers that never left memory.", "One of the articles or the google code I read said that 4 was a good number... but here I was able to hit 10."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; f1 = 25.4\n&gt;&gt;&gt; f2 = f1\n&gt;&gt;&gt; \n&gt;&gt;&gt; for i in xrange(1, 11):\n...     f2 /= 10.0          # to cm\n...     f2 *= (1.0 / 2.54)  # to in\n...     f2 *= 25.4          # back to mm\n...     print 'after %2d loops there are %2d doubles between them' % (i, dulpdiff(f1, f2))\n... \nafter  1 loops there are  1 doubles between them\nafter  2 loops there are  2 doubles between them\nafter  3 loops there are  3 doubles between them\nafter  4 loops there are  4 doubles between them\nafter  5 loops there are  6 doubles between them\nafter  6 loops there are  7 doubles between them\nafter  7 loops there are  8 doubles between them\nafter  8 loops there are 10 doubles between them\nafter  9 loops there are 10 doubles between them\nafter 10 loops there are 10 doubles between them\n</code>\n</pre>\n", "senID": 7}, {"text": ["Also interesting is how many floating points there are between equal numbers when one of them is written out as a string and read back in."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; # 0 degrees Fahrenheit is -32 / 1.8 degrees Celsius\n... f = -32 / 1.8\n&gt;&gt;&gt; s = str(f)\n&gt;&gt;&gt; s\n'-17.7777777778'\n&gt;&gt;&gt; # floats between them...\n... fulpdiff(f, float(s))\n0\n&gt;&gt;&gt; # doubles between them...\n... dulpdiff(f, float(s))\n6255L\n</code>\n</pre>\n", "senID": 9}, {"code": "<pre>\n<code>\n import struct\nfrom functools import partial\n\n# (c) 2010 Eric L. Frederich\n#\n# Python implementation of algorithms detailed here...\n# from http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\n\ndef c_mem_cast(x, f=None, t=None):\n    '''\n    do a c-style memory cast\n\n    In Python...\n\n    x = 12.34\n    y = c_mem_cast(x, 'd', 'l')\n\n    ... should be equivilent to the following in c...\n\n    double x = 12.34;\n    long   y = *(long*)&amp;x;\n    '''\n    return struct.unpack(t, struct.pack(f, x))[0]\n\ndbl_to_lng = partial(c_mem_cast, f='d', t='l')\nlng_to_dbl = partial(c_mem_cast, f='l', t='d')\nflt_to_int = partial(c_mem_cast, f='f', t='i')\nint_to_flt = partial(c_mem_cast, f='i', t='f')\n\ndef ulp_diff_maker(converter, negative_zero):\n    '''\n    Getting the ulp difference of floats and doubles is similar.\n    Only difference if the offset and converter.\n    '''\n    def the_diff(a, b):\n\n        # Make a integer lexicographically ordered as a twos-complement int\n        ai = converter(a)\n        if ai &lt; 0:\n            ai = negative_zero - ai\n\n        # Make b integer lexicographically ordered as a twos-complement int\n        bi = converter(b)\n        if bi &lt; 0:\n            bi = negative_zero - bi\n\n        return abs(ai - bi)\n\n    return the_diff\n\n# double ULP difference\ndulpdiff = ulp_diff_maker(dbl_to_lng, 0x8000000000000000)\n# float  ULP difference\nfulpdiff = ulp_diff_maker(flt_to_int, 0x80000000        )\n\n# default to double ULP difference\nulpdiff = dulpdiff\nulpdiff.__doc__ = '''\nGet the number of doubles between two doubles.\n'''\n</code>\n</pre>\n", "senID": 10}], [{"text": ["In order to compare floats in general compare the absolute value of the difference of the floats to a chosen delta that is small enough to fit your needs. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Rhetorical Questions"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "This *", "tag": "none", "senID": 2}, {"text": "Modern C/C++ compilers warn for comparison of floats for equality", "tag": "none", "senID": 3}, {"text": "All static code checkers I know will output errors for the languages I use", "tag": "none", "senID": 4}]}, {"text": ["I suppose it is the same for python, as the delta to use for comparison may vary it must be up to the implementer to choose it.", "What means that no good default transformation can be provided fully automatically."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["What problem?", "You're working with physical measurements.", "Unless you have some really sophisticated equipment, the error in your measurements is going to be several orders of magnitude higher than floating-point epsilon.", "So why write code that depends on numbers being exact to 16 significant digits?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "really", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["If it did, you'd get some strange results:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; float.tolerance = 1e-8    # hypothetical \"close enough\" definition\n&gt;&gt;&gt; a = 1.23456789\n&gt;&gt;&gt; b = 1.23456790\n&gt;&gt;&gt; c = 1.23456791\n&gt;&gt;&gt; a == b\nTrue\n&gt;&gt;&gt; b == c\nTrue\n&gt;&gt;&gt; a == c\nFalse\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you think it's hard enough to store floats in a dictionary now, try it with a non-transitive == operator!", "And performance would suck, because the only way to guarantee x == y \u2192 hash(x) == hash(y) would be for every float to have the same hash code.", "And that'd be inconsistent with ints."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "==", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x == y", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "hash(x) == hash(y)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}]]