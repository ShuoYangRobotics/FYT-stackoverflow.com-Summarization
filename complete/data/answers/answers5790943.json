[[{"text": ["Not sure if that will be enough for your needs, but lxml has support for regular expressions in xpath (meaning: you can use xpath 1.0 plus the EXSLT extension functions for regular expressions)"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "lxml", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://lxml.de"}, {"href": "http://lxml.de/xpathxslt.html#regular-expressions-in-xpath", "text": "regular expressions in xpath", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://www.exslt.org/regexp/index.html", "text": "EXSLT extension functions for regular expressions", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Compared to the feature list that was added later:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 7, "lis": [{"text": "search nested elements (infinite depth): yes", "tag": "none", "senID": 2}, {"text": "search attributes: yes", "tag": "none", "senID": 3}, {"text": "search for sentences and paragraphs: no. Assuming that \"paragraphs\" are actual xml elements, then yes. But \"sentences\" as such, no.", "tag": "none", "senID": 4}, {"text": "search using wildcards: yes (regular expressions)", "tag": "none", "senID": 5}, {"text": "search using fuzzy matching: no (assuming stemming, synonyms and so on...)", "tag": "none", "senID": 6}, {"text": "return precise matching info: yes", "tag": "none", "senID": 7}, {"text": "good search speed for large XML files: yes, except when your files are so extremely large that you would actually need a fulltext index to get good speed anyway.", "tag": "none", "senID": 8}]}, {"text": ["The only way to satisfy all your request that I see, would be to load your files into a native xml database that supports \"real\" fulltext search (via XQuery Fulltext probably) and use that.", "(can't help you much further with that, maybe Sedna, which seems to have a python API and seems to supports fulltext search?"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Sedna", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://modis.ispras.ru/sedna/index.html"}]}], [{"code": "<pre>\n<code>\n select=\"/elements/elem//[contains(.,'other')]\"\n</code>\n</pre>\n", "senID": 0}, {"text": ["see also xpath: find a node that has a given attribute whose value contains a string"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "xpath: find a node that has a given attribute whose value contains a string", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/614797/xpath-find-a-node-that-has-a-given-attribute-whose-value-contains-a-string/614826#614826"}]}], [{"text": ["I think you would be best served using a full text search engine like Solr: http://lucene.apache.org/solr/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://lucene.apache.org/solr/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://lucene.apache.org/solr/"}]}, {"text": ["What you can do is store a \"document\" in solr for each &lt;elem /&gt; in your xml.", "You can store any data you like in the document.", "Then you can search against the index and grab the id field stored in the matching documents.", "This will be very fast for a large set of documents."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "&lt;elem /&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "id", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["I'd recommend the following two:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Use XPath 2.0.", "It supports regular expressions."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "Use XPath 2.0", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "supports regular expressions", "childNum": 1, "tag": "strong", "pos": 1, "childList": [{"text": "supports regular expressions", "tag": "a"}]}, {"href": "http://www.w3.org/TR/xpath-functions/#string.match", "text": "supports regular expressions", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Or, "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["UseXQuery and XPath (2.0) Full Text, which has even more powerful features."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "UseXQuery and XPath (2.0) Full Text", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "XQuery and XPath (2.0) Full Text", "tag": "a"}]}, {"href": "http://www.w3.org/TR/xpath-full-text-10/", "text": "XQuery and XPath (2.0) Full Text", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["So, recently I had to create a XML to JSON converter.", "It doesn't conform exactly to the JSON standard, but it comes pretty close.", "The xml2json function returns a dictionary representation of the xml object.", "All element attributes are included in a dictionary with a key of attributes and element text are included in the text key."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, your xml object would look like this after its conversion:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n json = {'elements': \n    {'elem': [\n        {'attributes': {'id', '1'}, 'text': 'some element'},\n        {'attributes': {'id', '2'}, 'text': 'some other element'},\n        {'attributes': {'id', '3'}, 'text': 'some element', 'nested': {\n            'attributes': {'id', '1'}, 'text': 'other nested element'}},\n    ]}\n</code>\n</pre>\n", "senID": 2}, {"text": ["Here is the xml2json function."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def xml2json(x):\n    def get_attributes(atts):\n        atts = dict(atts)\n        d = {}\n        for k, v in atts.items():\n            d[k] = v.value\n        return d\n\n    def get_children(n, d):\n        tmp = {}\n        d.setdefault(n.nodeName, {})\n        if n.attributes:\n            tmp['attributes'] = get_attributes(n.attributes)\n        if n.hasChildNodes():\n            for c in n.childNodes:\n                if c.nodeType == c.TEXT_NODE or c.nodeName == '#cdata-section':\n                    tmp['text'] = c.data\n                else:\n                    children = get_children(c, {})\n                    for ck, cv in children.items():\n                        if ck in d[n.nodeName]:\n                            if not isinstance(d[n.nodeName][ck], list):\n                                tmpv = d[n.nodeName][ck]\n                                d[n.nodeName][ck] = []\n                                d[n.nodeName][ck].append(tmpv)\n                            d[n.nodeName][ck].append(cv)\n                        else:\n                            d[n.nodeName][ck] = cv\n\n        for tk, tv in tmp.items():\n            d[n.nodeName][tk] = tv\n\n        return d\n\n    return get_children(x.firstChild, {})\n</code>\n</pre>\n", "senID": 4}, {"text": ["Here is the searchjson function."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def searchjson(sobj, reg):\n    import re\n    results = []\n    if isinstance(sobj, basestring):\n        # search the string and return the output\n        if re.search(reg, sobj):\n            results.append(sobj)\n    else:\n        # dictionary\n        for k, v in sobj.items():\n            newv = v\n            if not isinstance(newv, list):\n                newv = [newv]\n\n            for elem in newv:\n                has_attributes = False\n                if isinstance(elem, dict):\n                    has_attributes = bool(elem.get('attributes', False))\n                res = searchjson(elem, reg)\n                res = [] if not res else res\n                for r in res:\n                    r_is_dict = isinstance(r, dict)\n                    r_no_attributes = r_is_dict and 'attributes' not in r.keys()\n                    if has_attributes and r_no_attributes :\n                        r.update({'attributes': elem.get('attributes', {})})\n\n                    results.append({k: r})\n\n    return results\n</code>\n</pre>\n", "senID": 6}, {"text": ["The search function I created after reading your question.", "It hasn't been 100% tested and probably has a few bugs, but I think it would be a good start for you.", "As for what you're looking for, it searches nested elements, attributes, using wildcards.", "It also returns the id of the elements."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["You can use the function like so, where xml is the xml object to search and reg is a regex pattern string to search for, ex: 'other', 'oth.", "*', '.the.", "' will all find the elements with \"other\" in them."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "the.", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n json = xml2json(xml)\nresults = searchjson(json, reg='other')\n</code>\n</pre>\n", "senID": 9}, {"text": ["results will be a list of dictionaries."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Hope it helps."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["For single large files accessed by a Python script, you should look at Xapian it is a full featured full text indexing and search engine, that is mature and robust and has wonderful first class Python bindings.", "It works with Python like it was written in Python, no external servers to run or any silliness like that."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Xapian", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://xapian.org/"}, {"text": "wonderful", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["If you don't need to persist the indexes, and can use the in memory database it will be extremely fast.", "It is faster than Lucene based solutions and uses a tiny fraction of the resources."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]