[[{"text": ["Django now has support for multiple databases."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "support for multiple databases", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.djangoproject.com/wiki/MultipleDatabaseSupport"}]}], [{"text": ["The database isn't your bottleneck."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Check your browser carefully."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For each page of HTML you're sending (on average) 8 other files, some of which may be quite large.", "These are your JS, CSS, graphics, etc."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The actual performance bottleneck is the browser requesting those files and accepting the bytes s... l... o... w... l... y..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["To scale, then, do this."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You'll find that this scales nicely.", "You'll find that the load is shared nicely between squid, apache, the Django daemons and the actual database.", "You'll also find that each part of the load (from the boring static parts to the interesting database query) happens separately and concurrently."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Finally, buy Schlossnagle's book.", "http://www.amazon.com/Scalable-Internet-Architectures-Theo-Schlossnagle/dp/067232699X"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "http://www.amazon.com/Scalable-Internet-Architectures-Theo-Schlossnagle/dp/067232699X", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://rads.stackoverflow.com/amzn/click/067232699X"}]}], [{"text": ["Read scaling to millions of users is not a database problem, but is fixed with load balancing and caching, etc, see S. Lott above."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Write scaling can indeed be a database problem.", "\"Sharding\" and having multiple databases can be one solution, but that's hard with SQL while still retaining the relationality of the database.", "Popular solutions there are the new types of \"nosql\" databases.", "But if you really have those problems, then you need serious expert help, not just answers from dudes Stackoverflow.", ":)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Some great answers already (S. Lott for example), however I thought I should pipe in with some more things:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Make sure not to use the database for logical operations"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Make sure not to use the database for logical operations", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I understand the attractiveness of Order By or SQL Procedures however you only have one database but you have multiple django servers, let the servers handle this if you can."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Order By", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "SQL Procedures", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Of course, if you only want the last ten rows according to a certain criterion (date), then by all means do precise it in the request ;) Just make sure not to overload your database with operations that could be handled elsewhere."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Throw more hardware to the problem"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Throw more hardware to the problem", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["MySQL and Oracle scale quite well with hardware, if you have a small problem of performance you could begin by adding more hardware."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Split your database"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Split your database", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I know that for relationships and all you have to manage some tables together, however if you ever have a load problem, try to group your tables, for example if you have a \"history\" group of tables, perhaps that it could work without the others and be on a separate server."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Do consider tuning, and watch out for your requests/index"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Do consider tuning, and watch out for your requests/index", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["You would need experts advises here, but I can tell from experience that even a single badly tuned request can wreak havoc... and it's quite difficult to find out.", "You can consider the Ask Tom website for example of diagnosis / fine tuning."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Ask Tom website", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://asktom.oracle.com/pls/apex/f?p=100:1:0"}]}, {"text": ["Don't decide on your tables architecture in isolation, but do consider the requests"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Don't decide on your tables architecture in isolation, but do consider the requests", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Hierarchical requests and multiple joins can be really costly.", "You don't have to build a fully normalized relations schema and may consider some denormalization in order to better accomodate the type of requests the database will face."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Just a couple of thoughts :)"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["A few miscellaneous pieces of advice:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["I'm surprised no one's mentioned this yet.", "Use memcached.", "If you're getting a lot of repetitive types of queries (which most webapps do), this can make a huge difference."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Consider using Oracle's failover and load balancing.", "It allows you to add support for multiple databases on a single db connection."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "failover and load balancing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.orafaq.com/node/1840"}]}, {"text": ["Another thing to consider is using a system similar to FriendFeed's.", "This solves the problem of \"how do we make changes to the database without halting the world?", "\" more than anything else."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "system similar to FriendFeed's", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bret.appspot.com/entry/how-friendfeed-uses-mysql"}]}]}], [{"text": ["If you find out that the DB is the bottlenck of your app, and their is now way around it (like using caching) then you should scale your DB as well.", "Django has nothing to do with this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]