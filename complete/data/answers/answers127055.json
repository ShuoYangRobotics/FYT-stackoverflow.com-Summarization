[[{"code": "<pre>\n<code>\n def num_groups(regex):\n    pattern = re.compile(r\"(?&lt;!\\\\)(?:\\\\\\\\)*(?:\\[(?:\\\\.|[^\\\\\\]])*\\]|(\\()(?!\\?(?!P&lt;)))\")\n    return len([ 1 for x in re.finditer(pattern, regex) if x.group(1) ])\n</code>\n</pre>\n", "senID": 0}, {"text": ["It looks for unescaped '[' or '('.", "For '[' it looks for the next unescaped ']'.", "The '(' can't be followed by a '?", "', unless that is followed by 'P&lt;'.", "(Named groups.", ")\nIt then filters for the capturing groups, and counts them."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Also looking for character classes is necessary, because '(' can appear unescaped inside them.", "Using look-arounds to detect them is not possible, since look-behinds need to be of fixed length."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "hr", "senID": 3}, {"text": ["EDIT: (4 months later)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Too simple!"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def num_groups(regex):\n    return re.compile(regex).groups\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Something from inside sre_parse might help."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["At first glance, maybe something along the lines of:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import sre_parse\n&gt;&gt;&gt; sre_parse.parse('(\\d)\\d(\\d)')\n[('subpattern', (1, [('in', [('category', 'category_digit')])])), \n('in', [('category', 'category_digit')]), \n('subpattern', (2, [('in', [('category', 'category_digit')])]))]\n</code>\n</pre>\n", "senID": 2}, {"text": ["I.e.", "count the items of type 'subpattern':"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import sre_parse\n\ndef count_patterns(regex):\n    \"\"\"\n    &gt;&gt;&gt; count_patterns('foo: \\d')\n    0\n    &gt;&gt;&gt; count_patterns('foo: (\\d)')\n    1\n    &gt;&gt;&gt; count_patterns('foo: (\\d(\\s))')\n    1\n    \"\"\"\n    parsed = sre_parse.parse(regex)\n    return len([token for token in parsed if token[0] == 'subpattern'])\n</code>\n</pre>\n", "senID": 4}, {"text": ["Note that we're only counting root level patterns here, so the last example only returns 1.", "To change this, tokens would need to searched recursively."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "tokens", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["First of all if you only need the first result of re.findall it's better to just use re.search that returns a match or None."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For the groups number you could count the number of open parenthesis '(' except those that are escaped by '\\'.", "You could use another regex for that:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def num_of_groups(regexp):\n    rg = re.compile(r'(?&lt;!\\\\)\\(')\n    return len(rg.findall(regexp))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Note that this doesn't work if the regex contains non-capturing groups and also if '(' is escaped by using it as '[(]'.", "So this is not very reliable.", "But depending on the regexes that you use it might help."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The lastindex property of the match object should be what you are looking for.", "See the re module docs."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "lastindex", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "re module docs", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/match-objects.html"}]}], [{"text": ["Might be wrong, but I don't think there is a way to find the number of groups that would have been returned had the regex matched.", "The only way I can think of to make this work the way you want it to is to pass the number of matches your particular regex expects as an argument."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To clarify though: When findall succeeds, you only want the first match to be returned, but when it fails you want a list of empty strings?", "Because the comment seems to show all matches being returned as a list."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Using your code as a basis:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def groups(regexp, s):\n    \"\"\" Returns the first result of re.findall, or an empty default\n\n    &gt;&gt;&gt; groups(r'(\\d)(\\d)(\\d)', '123')\n    ('1', '2', '3')\n    &gt;&gt;&gt; groups(r'(\\d)(\\d)(\\d)', 'abc')\n    ('', '', '')\n    \"\"\"\n    import re\n    m = re.search(regexp, s)\n    if m:\n        return m.groups()\n    return ('',) * len(m.groups())\n</code>\n</pre>\n", "senID": 1}]]