[[{"text": ["If you're using Python 2.6, try the standard library namedtuple class."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "namedtuple", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html#collections.namedtuple"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; Person = namedtuple('Person', ('forename', 'surname'))\n&gt;&gt;&gt; person1 = Person('John', 'Doe')\n&gt;&gt;&gt; person2 = Person(forename='Adam', surname='Monroe')\n&gt;&gt;&gt; person1.forename\n'John'\n&gt;&gt;&gt; person2.surname\n'Monroe'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: As per comments, there is a backport for earlier versions of Python"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://code.activestate.com/recipes/500261/", "text": "backport for earlier versions of Python", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["If you're running python &lt;2.6 or would like to extend your class to do more stuff, I would suggest using the type() builtin.", "This has the advantage over your solution in that the setting up of __dict__ happens at class creation rather than instantiation.", "It also doesn't define an __init__ method and thus doesn't lead to strange behavior if the class calls __init__ again for some reason.", "For example:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "type()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__dict__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def Struct(*args, **kwargs):\n    name = kwargs.pop(\"name\", \"MyStruct\")\n    kwargs.update(dict((k, None) for k in args))\n    return type(name, (object,), kwargs)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Used like so:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; MyStruct = Struct(\"forename\", \"lastname\")\n</code>\n</pre>\n", "senID": 3}, {"text": ["Equivalent to:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class MyStruct(object):\n    forename = None\n    lastname = None\n</code>\n</pre>\n", "senID": 5}, {"text": ["While this:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; TestStruct = Struct(\"forename\", age=18, name=\"TestStruct\")\n</code>\n</pre>\n", "senID": 7}, {"text": ["Is equivalent to:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n class TestStruct(object):\n    forename = None\n    age = 18\n</code>\n</pre>\n", "senID": 9}, {"text": ["Update"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Additionally, you can edit this code to very easily prevent assignment of other variables than the ones specificed.", "Just change the Struct() factory to assign __slots__."], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "__slots__", "tag": "a", "pos": 1, "childList": [{"text": "__slots__", "tag": "code"}], "childNum": 1, "href": "http://www.python.org/doc/2.5.2/ref/slots.html"}, {"text": "__slots__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def Struct(*args, **kwargs):\n    name = kwargs.pop(\"name\", \"MyStruct\")\n    kwargs.update(dict((k, None) for k in args))\n    kwargs['__slots__'] = kwargs.keys()\n    return type(name, (object,), kwargs)\n</code>\n</pre>\n", "senID": 12}], [{"text": ["As others have said, named tuples in Python 2.6/3.x.", "With older versions, I usually use the Stuff class:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Stuff(object):\n    def __init__(self, **kwargs):\n        self.__dict__.update(kwargs)\n\njohn = Stuff(forename='John', surname='Doe')\n</code>\n</pre>\n", "senID": 1}, {"text": ["This doesn't protect you from mispellings though.", "There's also a recipe for named tuples on ActiveState:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://code.activestate.com/recipes/500261/"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://code.activestate.com/recipes/500261/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/500261/"}]}], [{"text": ["An update of ThomasH's variant:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def Struct(*args, **kwargs):\n    def init(self, *iargs, **ikwargs):\n        for k,v in kwargs.items():\n            setattr(self, k, v)\n        for i in range(len(iargs)):\n            setattr(self, args[i], iargs[i])\n        for k,v in ikwargs.items():\n            setattr(self, k, v)\n\n    name = kwargs.pop(\"name\", \"MyStruct\")\n    kwargs.update(dict((k, None) for k in args))\n    return type(name, (object,), {'__init__': init, '__slots__': kwargs.keys()})\n</code>\n</pre>\n", "senID": 1}, {"text": ["This allows parameters (and named parameters) passed into __init__() (without any validation - seems crude):"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "__init__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; Person = Struct('fname', 'age')\n&gt;&gt;&gt; person1 = Person('Kevin', 25)\n&gt;&gt;&gt; person2 = Person(age=42, fname='Terry')\n&gt;&gt;&gt; person1.age += 10\n&gt;&gt;&gt; person2.age -= 10\n&gt;&gt;&gt; person1.fname, person1.age, person2.fname, person2.age\n('Kevin', 35, 'Terry', 32)\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["Update"], "childNum": 0, "tag": "h2", "senID": 4, "childList": []}, {"text": ["Having a look into how namedtuple() does this in collections.py.", "The class is created and expanded as a string and evaluated.", "Also has support for pickling and so on, etc."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "namedtuple()", "tag": "a", "pos": 0, "childList": [{"text": "namedtuple()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/collections.html#collections.namedtuple"}, {"text": "namedtuple()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "collections.py", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Lib/collections.py?view=markup"}]}], [{"text": ["There is namedtuple"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "namedtuple", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/collections.html#collections.namedtuple"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from collections import namedtuple\n&gt;&gt;&gt; Person = namedtuple(\"Person\", (\"forename\", \"surname\"))\n&gt;&gt;&gt; john = Person(\"John\", \"Doe\")\n&gt;&gt;&gt; john.forename \n'John'\n&gt;&gt;&gt; john.surname \n'Doe'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is following up on Cide's answer (and probably only interesting for people who want to dig deeper)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I experienced a problem using Cide's updated definition of Struct(), the one using __slots__.", "The problem is that instances of returned classes have read-only attributes:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; MS = Struct('forename','lastname')\n&gt;&gt;&gt; m=MS()\n&gt;&gt;&gt; m.forename='Jack'\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'MyStruct' object attribute 'forename' is read-only\n</code>\n</pre>\n", "senID": 2}, {"text": ["Seems that __slots__ is blocking instance-level attributes when there are class attributes of same names.", "I've tried to overcome this by providing an __init__ method, so instance attributes can be set at object creation time:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def Struct1(*args, **kwargs):\n    def init(self):\n        for k,v in kwargs.items():\n            setattr(self, k, v)\n    name = kwargs.pop(\"name\", \"MyStruct\")\n    kwargs.update(dict((k, None) for k in args))\n    return type(name, (object,), {'__init__': init, '__slots__': kwargs.keys()})\n</code>\n</pre>\n", "senID": 4}, {"text": ["As a net effect the constructed class only sees the __init__ method and the __slots__ member, which is working as desired:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; MS1 = Struct1('forename','lastname')\n&gt;&gt;&gt; m=MS1()\n&gt;&gt;&gt; m.forename='Jack'\n&gt;&gt;&gt; m.forename\n'Jack'\n</code>\n</pre>\n", "senID": 6}]]