[[{"text": ["The python Set is what you should try."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Set", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#set-types-set-frozenset"}]}], [{"text": ["Sample Python code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n L = ['foo', 'bar', 'baz'] # Your list\ns = set(L)  # Converted to Set\n\nprint 'foo'  in s # True\nprint 'blah' in s # False\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A Trie structure would suit your purposes.", "There are undoubtedly Python implementations to be found out there..."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Trie", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Trie"}]}], [{"text": ["Two things: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The Python 'mutable set' type has an 'add' method ( s.add(item) ), so you could go right from reading (a line) from your big file straight into a set without using a list as an intermediate data structure.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Python lets you 'pickle' a data structure, so you could save your big set to a file and save the time of reinitiating the set."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Second, I've been looking for a list of all the single-syllable words in English for my own amusement, but the ones I've found mentioned seem to be proprietary.", "If it isn't being intrusive, could I ask whether your list of English words can be obtained by others?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Others have given you the in-memory way using set(), and this is generally going to be the fastest way, and should not tax your memory for a 60k word dataset (a few MiBs at most).", "You should be able to construct your set with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f=open('words.txt')\ns = set(word.strip() for word in f)\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, it does require some time to load the set into memory.", "If you are checking lots of words, this is no problem - the lookup time will more than make up for it.", "However if you're only going to be checking one word per command execution (eg.", "this is a commandline app like \"checkenglish [word]\" ) the startup time will be longer than it would have taken you just to search through the file line by line."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If this is your situation, or you have a much bigger dataset, using an on-disk format may be better.", "The simplest way would be using the dbm module.", "Create such a database from a wordlist with:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "dbm", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/dbm.html"}]}, {"code": "<pre>\n<code>\n import dbm\nf=open('wordlist.txt')\ndb = dbm.open('words.db','c')\nfor word in f:\n    db[word] = '1'\nf.close()\ndb.close()\n</code>\n</pre>\n", "senID": 4}, {"text": ["Then your program can check membership with:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n db = dbm.open('words.db','r')\nif db.has_key(word):\n    print \"%s is english\" % word\nelse:\n    print \"%s is not english\" % word\n</code>\n</pre>\n", "senID": 6}, {"text": ["This will be slower than a set lookup, since there will be disk access, but will be faster than searching, have low memory use and no significant initialisation time."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["There are also other alternatives, such as using a SQL database (eg sqlite)."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["You're basically testing whether a member is in a set or not, right?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If so, and because you said you have lots of memory, why not just load all the words as keys in memcache, and then for every word, just check if it is present in memcache or not."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Or use that data structure that is used by bash to autocomplete command names - this is fast and highly efficient in memory (can't remember the name)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If memory consumption isn't an issue and the words won't change, the fastest way to do this is put everything in a hash and search that way.", "In Python, this is the Set.", "You'll have constant-time lookup."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Set", "tag": "a", "pos": 1, "childList": [{"text": "Set", "tag": "strong"}, {"text": "Set", "tag": "code"}], "childNum": 2, "href": "http://www.python.org/doc/2.5.2/tut/node7.html#SECTION007400000000000000000"}, {"text": "Set", "childNum": 1, "tag": "strong", "pos": -1, "childList": [{"text": "Set", "tag": "code"}]}, {"text": "Set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["500k character is not a large list.", "if items in your list are unique and you need to do this search repeatedly use set which would lower the complexity to O(1) in the best case."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "set", "tag": "a", "pos": 1, "childList": [{"text": "set", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#set-types-set-frozenset"}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}, {"text": "O(1)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Converting the list to a set will only be helpful if you repeatedly run this kind of query against the data, as will sorting the list and doing a binary search.", "If you're only going to pull data out of the list once, a plain old linear search is your best bet:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if 'foo' in some_list:\n    do_something()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Otherwise, your best bet is to use either a set as has been mentioned or a binary search.", "Which one you should choose depends largely on how big the data is and how much memory you can spare.", "I'm told that really large lists tend to benefit more from hashing, although the amount of memory that's taken up can be prohibitively expensive."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Finally, a third option is that you can import the data into a sqlite database and read directly from it.", "Sqlite is very fast and it may save you the trouble of loading the whole list from file.", "Python has a very good built-in sqlite library."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "whole", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "sqlite library", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/sqlite3.html"}]}]]