[[{"text": ["There is an excellent primer by David Goodger called \"Code Like a Pythonista\" here.", "A couple of things from that text re naming (quoting):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html"}]}, {"tag": "ul", "num": 4, "lis": [{"text": ["joined_lower for functions, methods,\nattributes"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "joined_lower", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["joined_lower or ALL_CAPS for\nconstants"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "joined_lower", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["StudlyCaps for classes"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "StudlyCaps", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["camelCase only to conform to\npre-existing conventions"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "camelCase", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}], [{"text": ["Just use 'import math' and 'math.sqrt()' instead of 'from math import sqrt' and 'sqrt()'; you don't win anything by just importing 'sqrt', and code quickly gets unwieldy with too many from-imports.", "Also, things like reload() and mocking out for tests break a lot faster when you use from-import a lot."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The divmod() function is a convenient way to perform both division and modulo.", "You can use for/else instead of the separate check on numleft.", "Your factors function is a natural candidate for a generator.", "xrange() was already mentioned in another answer.", "Here's it all done that way:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import math\n\n# recursively computes the factors of a number as a generator\ndef factors(num):\n    numroot = int(math.sqrt(num)) + 1\n    # brute force divide the number until you find a factor\n    for i in xrange(2, numroot):\n        divider, remainder = divmod(num, i)\n        if not remainder:\n            # if we found a factor, add it to the list and compute the\n            # remainder\n            yield i\n            break\n    else:\n    # if we didn't find a factor, get out of here!\n        yield num\n        return\n    # now recursively find the rest of the factors\n    for factor in factors(divider):\n        yield factor\n</code>\n</pre>\n", "senID": 2}, {"text": ["Using a generator does mean you can only iterate over the result once; if you simply want a list (like you do in translateFactorsList) you will have to wrap the call to factors() in list()."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["One other thing you might want to look at is the docstring.", "For example, the comment for this function:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # recursively computes the factors of a number\ndef factors(num):\n</code>\n</pre>\n", "senID": 1}, {"text": ["Could be converted into this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def factors(num):\n    \"\"\" recursively computes the factors of a number\"\"\"\n</code>\n</pre>\n", "senID": 3}, {"text": ["It's not really 100% necessary to do it this way, but it's a good habit to get into in case you ever start using something along the lines of pydoc."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["You can also do this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n \"\"\"This is a docstring\"\"\"\n</code>\n</pre>\n", "senID": 6}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import docstring\n&gt;&gt;&gt; help(docstring)\n</code>\n</pre>\n", "senID": 7}, {"code": "<pre>\n<code>\n Help on module docstring:\n\nNAME\n    docstring - This is a docstring\n\nFILE\n    /Users/jason/docstring.py\n</code>\n</pre>\n", "senID": 8}], [{"text": ["A few comments:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n factorList.insert(0, '2 ^ ' + str(num2s))\n</code>\n</pre>\n", "senID": 2}, {"text": ["could be changed to "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n factorlist.insert(0, '2 ^ %s' % num2s)\n</code>\n</pre>\n", "senID": 4}, {"text": ["All in all, I don't find your code to be extensively un-pythonic.", "Just make sure you want to use floor division, because that's what tends to happen by default with integer values.", "Otherwise, you'll need to fix up the division operator:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "floor division", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.2.3/whatsnew/node7.html"}]}, {"code": "<pre>\n<code>\n from __future__ import division\n</code>\n</pre>\n", "senID": 6}, {"text": ["A sometimes-frustrating caveat of the language."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"code": "<pre>\n<code>\n from itertools import takewhile\n\ndef transform_factor_list(factor_list):\n    num_2s = len(list(takewhile(lambda e: e == 2, factor_list)))\n    if num_2s &gt; 1:\n        factor_list[:num_2s] = [\"2 ^ %i\" % (num_2s, )]\n    return factor_list\n</code>\n</pre>\n", "senID": 0}, {"text": ["That's what I would make out of the second function. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Most pythonic changes:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": ["PEP-8"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}, {"text": "slicing (and assigning to slices)", "tag": "none", "senID": 4}, {"text": "iterators", "tag": "none", "senID": 5}, {"text": "string formatting", "tag": "none", "senID": 6}]}, {"text": ["The function assumes that the input is ordered, which is fulfilled by factors."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Edit: removed special cases for some lists, more compact this way"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Based on chris's answer, slightly simplified:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "for instead of external while", "tag": "none", "senID": 1}, {"text": "internal while to preserve ability to use same divisor repeatedly", "tag": "none", "senID": 2}, {"text": "use itertools.groupby simplifies compress() by much", "tag": "none", "senID": 3}, {"text": "fix a small bug in tostring()", "tag": "none", "senID": 4}]}, {"text": ["HTH:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\ndef factorize(n):\n    # ideally an iterator of prime numbers\n    # this'll work though\n    divisors = itertools.count(2)\n\n    for divisor in divisors:\n        # This condition is very clever!\n        # Note that `n` is decreasing, while `divisor` is increasing.\n        # And we know that `n` is not divisible by anything smaller,\n        # so this stops as soon as the remaining `n` is obviously prime.\n        if divisor**2 &gt; n:\n            yield n\n            break\n\n        while n % divisor == 0:\n            yield divisor\n            n //= divisor\n\ndef compress(factors):\n    for (factor, copies) in itertools.groupby(factors):\n        # The second object yielded by groupby is a generator of equal factors.\n        # Using list() to count its length.\n        power = len(list(copies))\n        yield (factor, power)\n\ndef tostring(compressed):\n    return ' * '.join(\"%d**%d\" % (factor, power) for (factor, power) in compressed)\n\n# test\nassert tostring(compress(factorize(12))) == '2**2 * 3**1'\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Don't be afraid of list comprehensions.", "Switching from Java to Python and discovering them was a good day."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For the factors function, maybe something like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def factors(num):\n    return [i for i in xrange(1, num+1) if num % i == 0]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Probably not the best code but it's short and easy to understand."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Good luck with Python, it's a great language. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["this is how I'd do this..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\nimport collections\n\ndef factorize(n):\n\t# ideally an iterator of prime numbers\n\t# this'll work though\n\tdivisors = itertools.count(2)\n\n\tdivisor = divisors.next()\n\twhile True:\n\t\tif divisor**2 &gt; n:\n\t\t\tyield n\n\t\t\tbreak\n\n\t\ta,b = divmod(n, divisor)\n\n\t\tif b == 0:\n\t\t\tyield divisor\n\t\t\tn = a\n\t\telse:\n\t\t\tdivisor = divisors.next()\n\ndef compress(factors):\n\tsummands = collections.defaultdict(lambda: 0)\n\n\tfor factor in factors:\n\t\tsummands[factor] += 1\n\n\treturn [(base, summands[base]) for base in sorted(summands)]\n\ndef tostring(compressed):\n\treturn ' * '.join(\"%d**%d\" % factor for factor in compressed)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's what jumps out at me:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def transformFactorList(factorList):\n    oldsize = len(factorList)\n    factorList = [f for f in factorList if f != 2]\n    num2s = oldsize - len(factorList)\n    if num2s == 0:\n        return []\n    if num2s == 1:\n        return [2]+factorList\n     return ['2 ^ %s' % num2s] + [factorList]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The form [f for f in factorList if f != 2] is called a list-comprehension."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[f for f in factorList if f != 2]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Since this post seems to be resurrected by Casey (lol), I'll add in my 2 cents."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Go over everything in PEP-8.", "It helped me out substantially when I had code formatting issues."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "PEP-8", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "PEP-8", "tag": "a"}]}, {"text": "PEP-8", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0008/"}]}], [{"text": ["Using recursion (where not necessary) is not pythonic.", "Python doesn't have tail recursion elimination and flat is better than nested."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "flat is better than nested", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["When in doubt, try import this"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "import this", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["update: by popular request, here goes the iterative factorization (sigh):"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n \"\"\"returns an iterator of tuples (factor, power) such that \nreduce(operator.mul, (factor**power for factor, power in factors(n))) == n \"\"\"\ndef factors(n):\n    i = 2\n    while n &gt; 1:\n        p = 0\n        while n &gt; 1 and n % i == 0:\n            p += 1\n            n /= i\n        if p:\n            yield (i, p)\n        i += 1\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I'd use a list comprehension to get the twos out:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def transformFactorList(factorList):\n    twos = [x for x in factorList if x == 2]\n    rest = [x for x in factorList if x != 2]\n    rest.insert(0, \"2 ^ %d\" % len(twos))\n    return rest\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that this will give you 2^0 and 2^1, which your code didn't.", "What you're doing with the twos seems arbitraty (sometimes you get a string, sometimes a number, sometimes nothing), so I figured that would be fine.", "You can change that easily if you want:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "2^0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "2^1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def transformFactorList(factorList):\n    twos = [x for x in factorList if x == 2]\n    rest = [x for x in factorList if x != 2]\n    if twos:\n        rest.insert(0, 2 if len(twos)==1 else \"2 ^ %d\" % len(twos))\n    return rest\n</code>\n</pre>\n", "senID": 3}]]