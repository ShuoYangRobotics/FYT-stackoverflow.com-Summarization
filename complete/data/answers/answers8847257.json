[[{"text": ["[edited to justify no RE after OP comment on comparing objects]"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It appears you are not using strings, but rather comparing objects.", "I am therefore giving an explicit algorithm \u2014 regular expressions provide a good solution tailored for strings, don't get me wrong, but from what you say as a comment to your questions, it seems an explicit, simple algorithm may make things easier for you."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It turns out that this can be solved with a much simpler algorithm than this previous answer:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "this previous answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/a/8848082/47978"}]}, {"code": "<pre>\n<code>\n def matcher (l1, l2):\n    if (l1 == []):\n        return (l2 == [] or l2 == ['*'])\n    if (l2 == [] or l2[0] == '*'):\n        return matcher(l2, l1)\n    if (l1[0] == '*'):\n        return (matcher(l1, l2[1:]) or matcher(l1[1:], l2))\n    if (l1[0] == l2[0]):\n        return matcher(l1[1:], l2[1:])\n    else:\n        return False\n</code>\n</pre>\n", "senID": 3}, {"text": ["The key idea is that when you encounter a wildcard, you can explore two options : "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "either advance in the list that contains the wildcard (and consider the wildcard matched whatever there was until now) ", "tag": "none", "senID": 5}, {"text": "or advance in the list that doesn't contain the wildcard (and consider that whatever is at the head of the list has to be matched by the wildcard).", "tag": "none", "senID": 6}]}], [{"text": ["How about the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef match(pat, lst):\n  regex = ''.join(term if term != '*' else '.*' for term in pat) + '$'\n  s = ''.join(lst)\n  return re.match(regex, s) is not None\n\nprint match( ['A', 'B', '*', 'D'], ['A', 'B', 'C', 'C', 'C', 'D'] )\n</code>\n</pre>\n", "senID": 1}, {"text": ["It uses regular expressions.", "Wildcards (*) are changed to .", "* and all other search terms are kept as-is."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "*", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": ".*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["One caveat is that if your search terms could contain things that have special meaning in the regex language, those would need to be properly escaped.", "It's pretty easy to handle this in the match function, I just wasn't sure if this was something you required."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "match", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I'd recommend converting ['A', 'B', '*', 'D'] to '^AB.", "*D$', ['A', 'B', 'C', 'C', 'C', 'D'] to 'ABCCCD', and then using the re module (regular expressions) to do the match."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "['A', 'B', '*', 'D']", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'^AB.*D$'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "['A', 'B', 'C', 'C', 'C', 'D']", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "'ABCCCD'", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/re.html", "text": "re", "childNum": 1, "tag": "a", "childList": [{"text": "re", "tag": "code"}]}, {"text": "re", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["This will be valid if the elements of your lists are only one character each, and if they're strings."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["something like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import(re)\ndef myMatch( patternList, stringList ):\n    # convert pattern to flat string with wildcards\n    # convert AB*D to valid regex ^AB.*D$\n    pattern = ''.join(patternList) \n    regexPattern = '^' + pattern.replace('*','.*') + '$' \n    # perform matching\n    against = ''.join(stringList) # convert ['A','B','C','C','D'] to ABCCCD\n    # return whether there is a match\n    return (re.match(regexPattern,against) is not None)\n</code>\n</pre>\n", "senID": 3}, {"text": ["If the lists contain numbers, or words, choose a character that you wouldn't expect to be in either, for example #.", "Then ['Aa','Bs','Ce','Cc','CC','Dd'] can be converted to Aa#Bs#Ce#Cc#CC#Dd, the wildcard pattern ['Aa','Bs','*','Dd'] could be converted to ^Aa#Bs#.", "*#Dd$, and the match performed."], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "#", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "['Aa','Bs','Ce','Cc','CC','Dd']", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Aa#Bs#Ce#Cc#CC#Dd", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "['Aa','Bs','*','Dd']", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "^Aa#Bs#.*#Dd$", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Practically speaking this just means all the ''.join(...) becomes '#'.join(...) in myMatch."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "''.join(...)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'#'.join(...)", "childNum": 0, "tag": "code", "childList": []}, {"text": "myMatch", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I agree with the comment regarding this could be done with regular expressions.", "For example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nlst = ['A', 'B', 'C', 'C', 'C', 'D']\npattern = ['A', 'B', 'C+', 'D']\n\nprint re.match(''.join(pattern), ''.join(lst)) # Will successfully match\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: As pointed out by a comment, it might be known in advance just that some character has to be matched, but not which one.", "In that case, regular expressions are useful still:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nlst = ['A', 'B', 'C', 'C', 'C', 'D']\npattern = r'AB(\\w)\\1*D'\n\nprint re.match(pattern, ''.join(lst)).groups()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I agree, regular expressions are usually the way to go with this sort of thing.", "This algorithm works, but it just looks convoluted to me.", "It was fun to write though."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def match(listx, listy):\n    listx, listy = map(iter, (listx, listy))\n    while 1:\n        try:\n            x = next(listx)\n        except StopIteration:\n            # This means there are values left in listx that are not in listy.\n            try:\n                y = next(listy)\n            except StopIteration:\n                # This means there are no more values to be compared in either\n                # listx or listy; since no exception was raied elsewhere, the\n                # lists match.\n                return True\n            else:\n                # This means that there are values in listy that are not in\n                # listx.\n                return False\n        else:\n            try:\n                y = next(listy)\n            except StopIteration:\n                # Similarly, there are values in listy that aren't in listx.\n                return False\n        if x == y:\n            pass\n        elif x == '*':\n            try:\n                # Get the value in listx after '*'.\n                x = next(listx)\n            except StopIteration:\n                # This means that listx terminates with '*'. If there are any\n                # remaining values of listy, they will, by definition, match.\n                return True\n            while 1:\n                if x == y:\n                    # I didn't shift to the next value in listy because I\n                    # assume that a '*' matches the empty string and well as\n                    # any other.\n                    break\n                else:\n                    try:\n                        y = next(listy)\n                    except StopIteration:\n                        # This means there is at least one remaining value in\n                        # listx that is not in listy, because listy has no\n                        # more values.\n                        return False\n                    else:\n                        pass\n        # Same algorithm as above, given there is a '*' in listy.\n        elif y == '*':\n            try:\n                y = next(listy)\n            except StopIteration:\n                return True\n            while 1:\n                if x == y:\n                    break\n                else:\n                    try:\n                        x = next(listx)\n                    except StopIteration:\n                        return False\n                    else:\n                        pass\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I had this c++ piece of code which seems to be doing what you are trying to do (inputs are strings instead of arrays of characters but you'll have to adapt stuff anyway)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n bool Utils::stringMatchWithWildcards (const std::string str, const std::string strWithWildcards)\n    PRINT(\"Starting in stringMatchWithWildcards('\" &lt;&lt; str &lt;&lt; \"','\" &lt;&lt; strWithWildcards &lt;&lt; \"')\");\n    const std::string wildcard=\"*\";\n\n    const bool startWithWildcard=(strWithWildcards.find(wildcard)==0);\n    int pos=strWithWildcards.rfind(wildcard);\n    const bool endWithWildcard = (pos!=std::string::npos) &amp;&amp; (pos+wildcard.size()==strWithWildcards.size());\n\n    // Basically, the point is to split the string with wildcards in strings with no wildcard.\n    // Then search in the first string for the different chunks of the second in the correct order\n    std::vector&lt;std::string&gt; vectStr;\n    boost::split(vectStr, strWithWildcards, boost::is_any_of(wildcard));\n    // I expected all the chunks in vectStr to be non-empty. It doesn't seem the be the case so let's remove them.\n    vectStr.erase(std::remove_if(vectStr.begin(), vectStr.end(), std::mem_fun_ref(&amp;std::string::empty)), vectStr.end());\n\n    // Check if at least one element (to have first and last element)\n    if (vectStr.empty())\n    {\n        const bool matchEmptyCase = (startWithWildcard || endWithWildcard || str.empty());\n        PRINT(\"Match \" &lt;&lt; (matchEmptyCase?\"\":\"un\") &lt;&lt; \"successful (empty case) : '\" &lt;&lt; str &lt;&lt; \"' and '\" &lt;&lt; strWithWildcards &lt;&lt; \"'\");\n        return matchEmptyCase;\n    }\n\n    // First Element\n    std::vector&lt;std::string&gt;::const_iterator vectStrIt = vectStr.begin();\n    std::string aStr=*vectStrIt;\n    if (!startWithWildcard &amp;&amp; str.find(aStr, 0)!=0) {\n        PRINT(\"Match unsuccessful (beginning) : '\" &lt;&lt; str &lt;&lt; \"' and '\" &lt;&lt; strWithWildcards &lt;&lt; \"'\");\n        return false;\n    }\n\n    // \"Normal\" Elements\n    bool found(true);\n    pos=0;\n    std::vector&lt;std::string&gt;::const_iterator vectStrEnd = vectStr.end();\n    for ( ; vectStrIt!=vectStrEnd ; vectStrIt++)\n    {\n        aStr=*vectStrIt;\n        PRINT( \"Searching '\" &lt;&lt; aStr &lt;&lt; \"' in '\" &lt;&lt; str &lt;&lt; \"' from  \" &lt;&lt; pos);\n        pos=str.find(aStr, pos);\n        if (pos==std::string::npos)\n        {\n            PRINT(\"Match unsuccessful ('\" &lt;&lt; aStr &lt;&lt; \"' not found) : '\" &lt;&lt; str &lt;&lt; \"' and '\" &lt;&lt; strWithWildcards &lt;&lt; \"'\");\n            return false;\n        } else\n        {\n            PRINT( \"Found at position \" &lt;&lt; pos);\n            pos+=aStr.size();\n        }\n    }\n\n    // Last Element\n    const bool matchEnd = (endWithWildcard || str.rfind(aStr)+aStr.size()==str.size());\n    PRINT(\"Match \" &lt;&lt; (matchEnd?\"\":\"un\") &lt;&lt; \"successful (usual case) : '\" &lt;&lt; str &lt;&lt; \"' and '\" &lt;&lt; strWithWildcards);\n    return matchEnd;\n}\n\n   /* Tested on these values :\n   assert( stringMatchWithWildcards(\"ABC\",\"ABC\"));\n   assert( stringMatchWithWildcards(\"ABC\",\"*\"));\n   assert( stringMatchWithWildcards(\"ABC\",\"*****\"));\n   assert( stringMatchWithWildcards(\"ABC\",\"*BC\"));\n   assert( stringMatchWithWildcards(\"ABC\",\"AB*\"));\n   assert( stringMatchWithWildcards(\"ABC\",\"A*C\"));\n   assert( stringMatchWithWildcards(\"ABC\",\"*C\"));\n   assert( stringMatchWithWildcards(\"ABC\",\"A*\"));\n\n   assert(!stringMatchWithWildcards(\"ABC\",\"BC\"));\n   assert(!stringMatchWithWildcards(\"ABC\",\"AB\"));\n   assert(!stringMatchWithWildcards(\"ABC\",\"AB*D\"));\n   assert(!stringMatchWithWildcards(\"ABC\",\"\"));\n\n   assert( stringMatchWithWildcards(\"\",\"\"));\n   assert( stringMatchWithWildcards(\"\",\"*\"));\n   assert(!stringMatchWithWildcards(\"\",\"ABC\"));\n   */\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's not something I'm really proud of but it seems to be working so far.", "I hope you can find it useful."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]