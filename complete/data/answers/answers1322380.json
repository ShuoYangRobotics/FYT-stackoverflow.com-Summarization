[[{"text": ["NaN is not a singleton like None, so you can't really use the is check on it.", "What makes it a bit tricky is that NaN == NaN is False as IEEE-754 requires.", "That's why you need to use the numpy.isnan() function to check if a float is not a number.", "Or the standard library math.isnan() if you're using Python 2.6+."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "NaN", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "NaN == NaN", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "numpy.isnan()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "math.isnan()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["I think this one is funny:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import numpy as n\n&gt;&gt;&gt; a = n.array([[1,2],[3,4]])\n&gt;&gt;&gt; a[1], a[0] = a[0], a[1]\n&gt;&gt;&gt; a\narray([[1, 2],\n       [1, 2]])\n</code>\n</pre>\n", "senID": 1}, {"text": ["For Python lists on the other hand this works as intended:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; b = [[1,2],[3,4]]\n&gt;&gt;&gt; b[1], b[0] = b[0], b[1]\n&gt;&gt;&gt; b\n[[3, 4], [1, 2]]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Funny side note: numpy itself had a bug in the shuffle function, because it used that notation :-) (see here)."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "shuffle", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://mail.scipy.org/pipermail/numpy-discussion/2006-November/024783.html", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["The reason is that in the first case we are dealing with views of the array, so the values are overwritten in-place."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "views", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["The biggest gotcha for me was that almost every standard operator is overloaded to distribute across the array."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Define a list and an array"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l = range(10)\n&gt;&gt;&gt; l\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; a = numpy.array(l)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n</code>\n</pre>\n", "senID": 2}, {"text": ["Multiplication duplicates the python list, but distributes over the numpy array"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l * 2\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; a * 2\narray([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])\n</code>\n</pre>\n", "senID": 4}, {"text": ["Addition and division are not defined on python lists"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l + 2\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: can only concatenate list (not \"int\") to list\n&gt;&gt;&gt; a + 2\narray([ 2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\n&gt;&gt;&gt; l / 2.0\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for /: 'list' and 'float'\n&gt;&gt;&gt; a / 2.0\narray([ 0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ,  3.5,  4. ,  4.5])\n</code>\n</pre>\n", "senID": 6}, {"text": ["Numpy overloads to treat lists like arrays sometimes"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a + a\narray([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])\n&gt;&gt;&gt; a + l\narray([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Because __eq__ does not return a bool, using numpy arrays in any kind of containers prevents equality testing without a container-specific work around."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__eq__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import numpy\n&gt;&gt;&gt; a = numpy.array(range(3))\n&gt;&gt;&gt; b = numpy.array(range(3))\n&gt;&gt;&gt; a == b\narray([ True,  True,  True], dtype=bool)\n&gt;&gt;&gt; x = (a, 'banana')\n&gt;&gt;&gt; y = (b, 'banana')\n&gt;&gt;&gt; x == y\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()\n</code>\n</pre>\n", "senID": 2}, {"text": ["This is a horrible problem.", "For example, you cannot write unittests for containers which use TestCase.assertEqual() and must instead write custom comparison functions.", "Suppose we write a work-around function special_eq_for_numpy_and_tuples.", "Now we can do this in a unittest:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "TestCase.assertEqual()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "special_eq_for_numpy_and_tuples", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n x = (array1, 'deserialized')\ny = (array2, 'deserialized')\nself.failUnless( special_eq_for_numpy_and_tuples(x, y) )\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now we must do this for every container type we might use to store numpy arrays.", "Furthermore, __eq__ might return a bool rather than an array of bools:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "__eq__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = numpy.array(range(3))\n&gt;&gt;&gt; b = numpy.array(range(5))\n&gt;&gt;&gt; a == b\nFalse\n</code>\n</pre>\n", "senID": 6}, {"text": ["Now each of our container-specific equality comparison functions must also handle that special case."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Maybe we can patch over this wart with a subclass?"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class SaneEqualityArray (numpy.ndarray):\n...   def __eq__(self, other):\n...     return isinstance(other, SaneEqualityArray) and self.shape == other.shape and (numpy.ndarray.__eq__(self, other)).all()\n... \n&gt;&gt;&gt; a = SaneEqualityArray( (2, 3) )\n&gt;&gt;&gt; a.fill(7)\n&gt;&gt;&gt; b = SaneEqualityArray( (2, 3) )\n&gt;&gt;&gt; b.fill(7)\n&gt;&gt;&gt; a == b\nTrue\n&gt;&gt;&gt; x = (a, 'banana')\n&gt;&gt;&gt; y = (b, 'banana')\n&gt;&gt;&gt; x == y\nTrue\n&gt;&gt;&gt; c = SaneEqualityArray( (7, 7) )\n&gt;&gt;&gt; c.fill(7)\n&gt;&gt;&gt; a == c\nFalse\n</code>\n</pre>\n", "senID": 9}, {"text": ["That seems to do the right thing.", "The class should also explicitly export elementwise comparison, since that is often useful."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["The truth value of a Numpy array differs from that of a python sequence type, where any non-empty sequence is true."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; l = [0,1,2,3]\n&gt;&gt;&gt; a = np.arange(4)\n&gt;&gt;&gt; if l: print \"Im true\"\n... \nIm true\n&gt;&gt;&gt; if a: print \"Im true\"\n... \nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: The truth value of an array with more than one element is ambiguous. Use\na.any() or a.all()\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["The numerical types are true when they are non-zero and as a collection of numbers, the Nupy array inherits this definition.", "But with a collection of numbers, truth could reasonably mean \"all elements are non-zero\" or \"at least one element is non-zero\".", "Numpy refuses to guess which definition is meant and raises the above exception.", "Using the .any() and .all() methods allows one to specify which meaning of true is meant."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; if a.any(): print \"Im true\"\n... \nIm true\n&gt;&gt;&gt; if a.all(): print \"Im true\"\n... \n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n print pynan is pynan, pynan is NaN, NaN is NaN\n</code>\n</pre>\n", "senID": 0}, {"text": ["This tests identity, that is if it is the same object.", "The result should therefore obviously be True, False, True, because when you do float(whatever) you are creating a new float object."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a = (0, pynan)\nprint a, a[1] is pynan, any([aa is pynan for aa in a])\n</code>\n</pre>\n", "senID": 2}, {"text": ["I don't know what it is that you find surprising with this."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n a = array(( 0, NaN ))\nprint a, a[1] is NaN, isnan( a[1] )\n</code>\n</pre>\n", "senID": 4}, {"text": ["This I did have to run.", ":-) When you stick NaN into an array it's converted into a numpy.float64 object, which is why a[1] is NaN fails."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["This all seems fairly unsurprising to me.", "But then I don't really know anything much about NumPy.", ":-)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Slicing creates views, not copies."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l = [1, 2, 3, 4]\n&gt;&gt;&gt; s = l[2:3]\n&gt;&gt;&gt; s[0] = 5\n&gt;&gt;&gt; l\n[1, 2, 3, 4]\n\n&gt;&gt;&gt; a = array([1, 2, 3, 4])\n&gt;&gt;&gt; s = a[2:3]\n&gt;&gt;&gt; s[0] = 5\n&gt;&gt;&gt; a\narray([1, 2, 5, 4])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["from Neil Martinsen-Burrell in numpy-discussion 7 Sept  --"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy-discussion", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.scipy.org/pipermail/numpy-discussion/2009-September/045041.html"}]}], [{"text": ["I found the fact that multiplying up lists of elements just creates view of elements caught me out."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a=[0]*5\n&gt;&gt;&gt;a\n[0,0,0,0,0]\n&gt;&gt;&gt;a[2] = 1\n&gt;&gt;&gt;a\n[0,0,1,0,0]\n&gt;&gt;&gt;b = [np.ones(3)]*5\n&gt;&gt;&gt;b\n[array([ 1.,  1.,  1.]), array([ 1.,  1.,  1.]), array([ 1.,  1.,  1.]), array([ 1.,  1.,  1.]), array([ 1.,  1.,  1.])]\n&gt;&gt;&gt;b[2][1] = 2\n&gt;&gt;&gt;b\n[array([ 1.,  2.,  1.]), array([ 1.,  2.,  1.]), array([ 1.,  2.,  1.]), array([ 1.,  2.,  1.]), array([ 1.,  2.,  1.])]\n</code>\n</pre>\n", "senID": 1}, {"text": ["So if you create a list of elements like this and intend to do different operations on them you are scuppered ..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["A straightforward solution is to iteratively create each of the arrays (using a 'for loop' or list comprehension) or use a higher dimensional array (where e.g.", "each of these 1D arrays is a row in your 2D array, which is generally faster)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["(Related, but a NumPy vs. SciPy gotcha, rather than NumPy vs Python)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Slicing beyond an array's real size works differently:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import numpy, scipy.sparse\n\n&gt;&gt;&gt; m = numpy.random.rand(2, 5) # create a 2x5 dense matrix\n&gt;&gt;&gt; print m[:3, :] # works like list slicing in Python: clips to real size\n[[ 0.12245393  0.20642799  0.98128601  0.06102106  0.74091038]\n[ 0.0527411   0.9131837   0.6475907   0.27900378  0.22396443]]\n\n&gt;&gt;&gt; s = scipy.sparse.lil_matrix(m) # same for csr_matrix and other sparse formats\n&gt;&gt;&gt; print s[:3, :] # doesn't clip!\nIndexError: row index out of bounds\n</code>\n</pre>\n", "senID": 2}, {"text": ["So when slicing scipy.sparse arrays, you must make manually sure your slice bounds are within range.", "This differs from how both NumPy and plain Python work."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "scipy.sparse", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Not such a big gotcha:   With boolean slicing, I sometimes wish I could do "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["like the python double comparison.", "Instead, I have to write "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(Unless you know something better?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Also, np.logical_and and np.logical_or only take two arguments each, I would like them to take a variable number, or a list, so I could feed in more than just two logical clauses."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["(numpy 1.3, maybe this has all changed in later versions."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]