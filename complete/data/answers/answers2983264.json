[[{"text": ["No this won't screw up.", "This is perfectly acceptable in any ACID compliant DB.", "The I stands for Isolation.", "Each one of these queries will lock all rows in the visit table.", "The A (in ACID) stands for Atomicity and means the transaction must run in full or not at all."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "I", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Isolation", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "visit", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}, {"text": "A", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "Atomicity", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["You have two potential problems:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The right answer depends upon whether two users could compute (visit + 1) on the same value of visit.", "We can imagine that the database needs to do these actions: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n Read visit count\n  Add one to visit count\n  Write visit count\n</code>\n</pre>\n", "senID": 2}, {"text": ["So if two users are working at the same time could they both read the same old value?", "That's where the isolation level of the transaction comes into play.", "As observed by Artefacto the default isolation level is repeatable read, and hence we get:  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n Grab a lock\n Read, increment, Write\n Release lock\n</code>\n</pre>\n", "senID": 4}, {"text": ["Rather than"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n Read  (two users same old value)\n Increment\n First user Grab Lock, second waits\n Write  \n Release, second user grabs lock\n Write (same value!)\n Release\n</code>\n</pre>\n", "senID": 6}, {"text": ["However the level of contention could be quite high, and very much depends on the scope of your transaction.", "Suppose you have:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n Begin transaction\n\n  Do the visit increment stuff\n\n  Do some serious business work\n\n  End transaction   &lt;==== visit lock is held until here\n</code>\n</pre>\n", "senID": 8}, {"text": ["Then you will get a lot of folks waiting for that visit lock.", "We don't know the overall structure of your app, whether you are using large transaction scopes like this.", "Very likely you are getting a default behaviour of a single transaction per SQL statement, and in which case you're contention is just for the duration of the SQL statement, pretty much as you would be hoping."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Other folks might not be so fortunate: there are environments (eg.", "JEE Servlets) where implicit transaction scopes can be created by the infrastructure and then the longer lived transactions I show above happen by default.", "Worse is the possibility that your code is not written consistently (with the visit increment always first, or always last) you can get:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n Begin transaction\n  Do the visit increment stuff\n  Do some serious business work\n  End transaction   &lt;==== visit lock and business locks held until here\n</code>\n</pre>\n", "senID": 11}, {"text": ["and"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n Begin transaction\n  Do some other serious business work\n  Do the visit increment stuff      \n  End transaction   &lt;==== visit lock and maybesame business locks held until here\n</code>\n</pre>\n", "senID": 13}, {"text": ["And  bingo: Deadlock"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "Deadlock", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["For high volume sites you bcould consider writing a \"Visit\" event to a queue, and having a daemon listening for those events and maintaining the count.", "More complex, but possibly fewer contention issues."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}], [{"text": ["For MySQL, the manual says:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "manual", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://dev.mysql.com/doc/refman/5.1/en/set-transaction.html#isolevel_repeatable-read"}]}, {"text": ["So I'd say yes, you're fine, though that particular query may well lock the entire table.", "It would probably be better:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n UPDATE stats SET value = value + 1 WHERE key = 'visits'\n</code>\n</pre>\n", "senID": 2}, {"text": ["with an index on \"key\"."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["All the answers so far appear to assume an InnoDB table, which does support transactions; with MyISAM tables, you get \"atomic transactions\" instead, which should be fine for your specific use case (though they fall well short of full ACID for the general case)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "InnoDB", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "MyISAM", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In the MySQL docs on transactions (e.g.", "here) it gives your UPDATE form as a good practice typical case, specifically, and I quote...:"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://dev.mysql.com/doc/refman/5.0/en/ansi-diff-transactions.html"}, {"text": "UPDATE", "childNum": 0, "tag": "code", "childList": []}, {"text": "good practice", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n UPDATE tablename SET pay_back=pay_back+125;\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Make sure you have SET autocommit so this is treated as a transaction, and the count will be fine.", "The only concern is performance (e.g.", "having a table hot spot)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "SET autocommit", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This will work if you:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Be especially careful with the second point.", "It's not a no-brainer because MySQL allows you to relax locking constraints to a point where this will indeed screw up. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["On the other hand (when locking is set up correctly) if you hit some (very) heavy traffic this might become your bottle neck (as it can only execute in a single thread).", "If you keep the transaction open longer than just to update the number this becomes more likely, and it can even cause a deadlock if you're not careful as djna explains in detail."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As everyone has said this will lock the row if you're using InnoDB.", "Now if you're just using just one row and that row stores stats about all accesses then locking this row may slow things down as queries wait to acquire the lock.", "This slow down may be imperceptible under your loads.", "If it is significant you could get around it by writing to multiple different rows, say 0-255.", "This will still lock each row, but the chance of lock contention is now 1/256 of what it originally was.", "When you want the total you can just sum all rows. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n UPDATE stats SET value=value+1 WHERE id=X\n</code>\n</pre>\n", "senID": 1}, {"text": ["where X is a random id 0-255"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["then"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n SELECT SUM(value) FROM stats\n</code>\n</pre>\n", "senID": 4}, {"text": ["will give you the real total."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["It's fine.", "all that \"table locking/row locking\" is the crap databases were invented to take care for.   "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["There can be other issues when \"thousand users load the page at same time\", like index updating.", "But that's another story and noobily MySQL setup isn't a case anyway."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]