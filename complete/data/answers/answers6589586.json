[[{"text": ["Kerrek SB's comment is a good one: just put the names in a comment.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["BTW, Python also supports a named unicode literal:  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; u\"\\N{NO-BREAK SPACE}\"\nu'\\xa0'\n</code>\n</pre>\n", "senID": 2}, {"text": ["But it uses the same unicode name database, and the control characters are not in it."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You could roll your own \"database\" for the control characters by parsing a few lines of the UCD files in the Unicode public directory.", "In particular, see the UnicodeData-6.1.0d3 file (or see the parent directory for earlier versions).  "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "public directory", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.unicode.org/Public/6.1.0/ucd/"}, {"text": "UnicodeData-6.1.0d3", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.unicode.org/Public/6.1.0/ucd/UnicodeData-6.1.0d3.txt"}]}], [{"text": ["I don't think it can be done in standard Python.", "The unicodedata module uses the UnicodeData.txt v5.2.0 Unicode database.", "Notice that the control characters are all assigned the name &lt;control&gt; (the second field, semicolon-delimited)."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "unicodedata", "tag": "a", "pos": 1, "childList": [{"text": "unicodedata", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/unicodedata.html"}, {"text": "unicodedata", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "UnicodeData.txt v5.2.0", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "ftp://ftp.unicode.org/Public/5.2.0/ucd/UnicodeData.txt"}, {"text": "&lt;control&gt;", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["The script Tools/unicode/makeunicodedata.py in the Python source distribution is used to generate the table used by the Python runtime.", "The makeunicodename function looks like this:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Tools/unicode/makeunicodedata.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "makeunicodename", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def makeunicodename(unicode, trace):\n\n    FILE = \"Modules/unicodename_db.h\"\n\n    print \"--- Preparing\", FILE, \"...\"\n\n    # collect names\n    names = [None] * len(unicode.chars)\n\n    for char in unicode.chars:\n        record = unicode.table[char]\n        if record:\n            name = record[1].strip()\n            if name and name[0] != \"&lt;\":\n                names[char] = name + chr(0)\n    ...\n</code>\n</pre>\n", "senID": 2}, {"text": ["Notice that it skips over entries whose name begins with \"&lt;\".", "Hence, there is no name that can be passed to unicodedata.lookup that will give you back one of those control characters."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "\"&lt;\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "unicodedata.lookup", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Just hardcode the code points for horizontal tab, line feed, and carriage return, and leave a descriptive comment.", "As the Zen of Python goes, \"practicality beats purity\"."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Zen of Python", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0020/"}]}], [{"text": ["A few points:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["(1) \"BOM\" is not a character.", "BOM is a byte sequence that appears at the start of a file to indicate the byte order of a file that is encoded in UTF-nn.", "BOM is u'\\uFEFF'.encode('UTF-nn').", "Reading a file with the appropriate codec will slurp up the BOM; you don't see it as a Unicode character.", "A BOM is not data.", "If you do see u'\\uFEFF' in your data, treat it as a (deprecated) ZERO-WIDTH NO-BREAK SPACE."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(2) \"minus the Unicode-white-space code points, which I address separately\"??", "Isn't NO-BREAK SPACE a \"Unicode-white-space\" code point?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["(3) Your Python appears to be broken; mine does this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; ord(unicodedata.lookup(\"NO-BREAK SPACE\"))\n160\n</code>\n</pre>\n", "senID": 4}, {"text": ["(4) You could use escape sequences for the first three. "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; map(hex, map(ord, \"\\t\\v\\f\"))\n['0x9', '0xb', '0xc']\n</code>\n</pre>\n", "senID": 6}, {"text": ["(5) You could use \" \" for the fourth one."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "\" \"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["(6) Even if you could use names, the readers of your code would still be applying blind faith that e.g.", "\"FORM FEED\" is a whitespace character."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["(7) What happened to to \\r and \\n?"], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "\\r", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\n", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Assuming you're working with Unicode strings, the first five items in your list, plus all other Unicode space characters, will be matched by the \\s option when using a regular expression.", "Using Python 3.1.2:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "\\s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; s = '\\u0009,\\u000b,\\u000c,\\u0020,\\u00a0,\\ufeff'\n&gt;&gt;&gt; s\n'\\t,\\x0b,\\x0c, ,\\xa0,\\ufeff'\n&gt;&gt;&gt; re.findall(r'\\s', s)\n['\\t', '\\x0b', '\\x0c', ' ', '\\xa0']\n</code>\n</pre>\n", "senID": 1}, {"text": ["And as for the byte-order mark, the one given can be referred to as codecs.BOM_BE or codecs.BOM_UTF16_BE (though in Python 3+, it's returned as a bytes object rather than str)."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "codecs.BOM_BE", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "codecs.BOM_UTF16_BE", "childNum": 0, "tag": "code", "childList": []}, {"text": "bytes", "childNum": 0, "tag": "code", "childList": []}, {"text": "str", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The official Unicode recommendation for newlines may or may not be at odds with the way the Python codecs module handles newlines.", "Since u'\\n' is often said to mean \"new line\", one might expect based on this recommendation for the Python string u'\\n' to represent character U+2028 LINE SEPARATOR and to be encoded as such, rather than as the semantic-less control character U+000A.", "But I can only imagine the confusion that would result if the codecs module actually implemented that policy, and there are valid counter-arguments besides.", "Ditto for horizontal/vertical tab and form feed, which are probably not really characters but controls anyway.", "(I would certainly consider backspace to be a control, not a character."], "childNum": 7, "tag": "p", "senID": 0, "childList": [{"text": "official Unicode recommendation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://unicode.org/standard/reports/tr13/tr13-5.html"}, {"text": "codecs", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "u'\\n'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "u'\\n'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "U+2028 LINE SEPARATOR", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "U+000A", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "codecs", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Your question seems to assume that treating U+000A as a control character (instead of a line separator) is wrong; but that is not at all certain.", "Perhaps it is more wrong for text processing applications everywhere to assume that a legacy printer-platen-scrolling control signal is really a true \"line separator\"."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "U+000A", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can extend the lookup function to handle the characters that aren't included."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def unicode_lookup(x):\n    try:\n        ch = unicodedata.lookup(x)\n    except KeyError:\n        control_chars = {'LINE FEED':unichr(0x0a),'CARRIAGE RETURN':unichr(0x0d)}\n        if x in control_chars:\n            ch = control_chars[x]\n        else:\n            raise\n    return ch\n\n&gt;&gt;&gt; unicode_lookup('SPACE')\nu' '\n&gt;&gt;&gt; unicode_lookup('LINE FEED')\nu'\\n'\n&gt;&gt;&gt; unicode_lookup('FORM FEED')\n\nTraceback (most recent call last):\n  File \"&lt;pyshell#17&gt;\", line 1, in &lt;module&gt;\n    unicode_lookup('FORM FEED')\n  File \"&lt;pyshell#13&gt;\", line 3, in unicode_lookup\n    ch = unicodedata.lookup(x)\nKeyError: \"undefined character name 'FORM FEED'\"\n</code>\n</pre>\n", "senID": 1}]]