[[{"text": ["I'm not sure about \"pythonic\", but why not just create a reset method in your object that does whatever resetting is required?", "Call this method as part of your __init__ so you're not duplicating the data (ie: always (re)initialize it in one place -- the reset method)"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "reset", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "reset", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Not sure if it's \"Pythonic\" enough, but you can define a \"resettable\" decorator \nfor the __init__ method that creates a copy the object's __dict__ and adds a reset() method that switches the current __dict__ to the original one."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__dict__", "childNum": 0, "tag": "code", "childList": []}, {"text": "reset()", "childNum": 0, "tag": "code", "childList": []}, {"text": "__dict__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit - Here's an example implementation:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def resettable(f):\n    import copy\n\n    def __init_and_copy__(self, *args, **kwargs):\n        f(self, *args)\n        self.__original_dict__ = copy.deepcopy(self.__dict__)\n\n        def reset(o = self):\n            o.__dict__ = o.__original_dict__\n\n        self.reset = reset\n\n    return __init_and_copy__\n\nclass Point(object):\n    @resettable\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return \"%d %d\" % (self.x, self.y)\n\nclass LabeledPoint(Point):\n    @resettable\n    def __init__(self, x, y, label):\n        self.x = x\n        self.y = y\n        self.label = label\n\n    def __str__(self):\n        return \"%d %d (%s)\" % (self.x, self.y, self.label)\n\np = Point(1, 2)\n\nprint p # 1 2\n\np.x = 15\np.y = 25\n\nprint p # 15 25\n\np.reset()\n\nprint p # 1 2\n\np2 = LabeledPoint(1, 2, \"Test\")\n\nprint p2 # 1 2 (Test)\n\np2.x = 3\np2.label = \"Test2\"\n\nprint p2 # 3 2 (Test2)\n\np2.reset()\n\nprint p2 # 1 2 (Test)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Edit2: Added a test with inheritance"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Sounds like you want to know if your class should be an immutable object.", "The idea is that, once created, an immutable object can't/should't/would't be changed."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "immutable object", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Immutable_object"}]}, {"text": ["On Python, built-in types like int or tuple instances are immutable, enforced by the language:"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Immutable_object#Python"}, {"text": "int", "childNum": 0, "tag": "code", "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a=(1, 2, 3, 1, 2, 3)\n&gt;&gt;&gt; a[0] = 9\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment\n</code>\n</pre>\n", "senID": 2}, {"text": ["As another example, every time you add two integers a new instance is created:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a=5000\n&gt;&gt;&gt; b=7000\n&gt;&gt;&gt; d=a+b\n&gt;&gt;&gt; d\n12000\n&gt;&gt;&gt; id(d)\n42882584\n&gt;&gt;&gt; d=a+b\n&gt;&gt;&gt; id(d)\n42215680\n</code>\n</pre>\n", "senID": 4}, {"text": ["The id()function returns the address of the int object 12000.", "And every time we add a+b a new 12000 object instance is created."], "childNum": 6, "tag": "p", "senID": 5, "childList": [{"text": "id()function", "tag": "a", "pos": 0, "childList": [{"text": "id()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#id"}, {"text": "id()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "12000", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "a+b", "childNum": 0, "tag": "code", "childList": []}, {"text": "12000", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["User defined immutable classes must be enforced manually, or simply done as a convention with a source code comment:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n class X(object):\n    \"\"\"Immutable class. Don't change instance variables values!\"\"\"\n    def __init__(self, *args):\n        self._some_internal_value = ...\n\n    def some_operation(self, arg0):\n        new_instance = X(arg0 + ...)\n        new_instance._some_internal_operation(self._some_internal_value, 42)\n        return new_instance\n\n    def _some_internal_operation(self, a, b):\n        \"\"\"...\"\"\"\n</code>\n</pre>\n", "senID": 7}, {"text": ["Either way, it's OK to create a new instance for every operation."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["See the Memento Design Pattern if you want to restore previous state, or the Proxy Design Pattern if you want the object to seem pristine, as if just created.", "In any case, you need to put something between what's referenced, and it's state."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "Memento Design Pattern", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Memento_pattern"}, {"text": "Proxy Design Pattern", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Proxy_pattern"}, {"text": "pristine", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "something", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Please comment if you need some code, though I'm sure you'll find plenty on the web if you use the design pattern names as keywords."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # The Memento design pattern\nclass Scores(object):\n    ...\n\nclass Player(object):\n    def __init__(self,...):\n        ...\n        self.scores = None\n        self.history = []\n        self.reset()\n\n    def reset(self):\n        if (self.scores):\n            self.history.append(self.scores)\n        self.scores = Scores()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I would create a default dict as a data member with all of the default values, then do __dict__.update(self.default) during __init__ and then again at some later point to pull all the values back."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "default", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__dict__.update(self.default)", "childNum": 0, "tag": "code", "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["More generally, you can use a __setattr__ hook to keep track of every variable that has been changed and later use that data to reset them."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__setattr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["It sounds like overall your design needs some reworking.", "What about a PlayerGameStatistics class that would keep track of all that, and either a Player or a Game would hold a collection of these objects?"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "PlayerGameStatistics", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Player", "childNum": 0, "tag": "code", "childList": []}, {"text": "Game", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Also the code you show is a good start, but could you show more code that interacts with the Player class?", "I'm just having a hard time seeing why a single Player object should have PlayXGame methods -- does a single Player not interact with other Players when playing a game, or why does a specific Player play the game?"], "childNum": 6, "tag": "p", "senID": 1, "childList": [{"text": "Player", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Player", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "PlayXGame", "childNum": 0, "tag": "code", "childList": []}, {"text": "Player", "childNum": 0, "tag": "code", "childList": []}, {"text": "Player", "childNum": 0, "tag": "code", "childList": []}, {"text": "Player", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["A simple reset method (called in __init__ and re-called when necessary) makes a lot of sense.", "But here's a solution that I think is interesting, if a bit over-engineered: create a context manager.", "I'm curious what people think about this..."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from contextlib import contextmanager\n\n@contextmanager\ndef resetting(resettable):\n    try:\n        resettable.setdef()\n        yield resettable\n    finally:\n        resettable.reset()\n\nclass Resetter(object):\n    def __init__(self, foo=5, bar=6):\n        self.foo = foo\n        self.bar = bar\n    def setdef(self):\n        self._foo = self.foo\n        self._bar = self.bar\n    def reset(self):\n        self.foo = self._foo\n        self.bar = self._bar\n    def method(self):\n        with resetting(self):\n            self.foo += self.bar\n            print self.foo\n\nr = Resetter()\nr.method()    # prints 11\nr.method()    # still prints 11\n</code>\n</pre>\n", "senID": 1}, {"text": ["To over-over-engineer, you could then create a @resetme decorator"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "@resetme", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def resetme(f):\n    def rf(self, *args, **kwargs):\n        with resetting(self):\n            f(self, *args, **kwargs)\n    return rf\n</code>\n</pre>\n", "senID": 3}, {"text": ["So that instead of having to explicitly use with you could just use the decorator:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "with", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n @resetme\ndef method(self):\n    self.foo += self.bar\n    print self.foo\n</code>\n</pre>\n", "senID": 5}], [{"text": ["It sounds to me like you need to rework your model to at least include a separate \"PlayerGameStats\" class."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Something along the lines of:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n PlayerGameStats = collections.namedtuple(\"points fouls rebounds assists turnovers steals\")\n\nclass Player():\n    def __init__(self):\n        self.cup_games = []\n        self.league_games = []\n        self.training_games = []\n\ndef playCupGame(self):\n    # simulates a game and then assigns values to the variables, accordingly\n    stats = PlayerGameStats(points, fouls, rebounds, assists, turnovers, steals)\n    self.cup_games.append(stats)\n\ndef playLeagueGame(self):\n    # simulates a game and then assigns values to the variables, accordingly\n    stats = PlayerGameStats(points, fouls, rebounds, assists, turnovers, steals)\n    self.league_games.append(stats)\n\ndef playTrainingGame(self):\n    # simulates a game and then assigns values to the variables, accordingly\n    stats = PlayerGameStats(points, fouls, rebounds, assists, turnovers, steals)\n    self.training_games.append(stats)\n</code>\n</pre>\n", "senID": 2}, {"text": ["And to answer the question in your edit, yes nested functions can see variables stored in outer scopes.", "You can read more about that in the tutorial: http://docs.python.org/tutorial/classes.html#python-scopes-and-namespaces"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://docs.python.org/tutorial/classes.html#python-scopes-and-namespaces", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html#python-scopes-and-namespaces"}]}]]