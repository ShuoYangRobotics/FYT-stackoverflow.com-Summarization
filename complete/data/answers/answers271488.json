[[{"text": ["Boost.Python provides an easy way to turn C++ code into Python modules.", "It's rather mature and works well in my experience. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Boost.Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.boost.org/doc/libs/1_36_0/libs/python/doc/tutorial/doc/html/index.html"}]}, {"text": ["For example, the inevitable Hello World..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n char const* greet()\n{\n  return \"hello, world\";\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["can be exposed to Python by writing a Boost.Python wrapper:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;boost/python.hpp&gt;\n\nBOOST_PYTHON_MODULE(hello_ext)\n{\n  using namespace boost::python;\n  def(\"greet\", greet);\n}\n</code>\n</pre>\n", "senID": 4}, {"text": ["That's it.", "We're done.", "We can now build this as a shared library.", "The resulting DLL is now visible to Python.", "Here's a sample Python session:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import hello_ext\n&gt;&gt;&gt; print hello.greet()\nhello, world\n</code>\n</pre>\n", "senID": 6}, {"text": ["(example taken from boost.org)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["First, a meta comment: I would highly recommend coding the entire thing in a high-level language, profiling like mad, and optimizing only where profiling shows it's necessary.", "First optimize the algorithm, then the code, then think about bringing in the heavy iron.", "Having an optimum algorithm and clean code will make things much easier when/if you need to reimplement in a lower-level language."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Speaking for Python, IronPython/C# is probably the easiest optimization path. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "IronPython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.codeplex.com/Wiki/View.aspx?ProjectName=IronPython"}]}, {"text": ["CPython with C++ is doable, but I find C a lot easier to handle (but not all that easy, being C).", "Two tools that ease this are cython/pyrex (for C) and shedskin (for C++).", "These compile Python into C/C++, and from there you can access C/C++ libraries without too much ado."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "cython", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://cython.org/"}, {"text": "pyrex", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/"}, {"text": "shedskin", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://shed-skin.blogspot.com/"}]}, {"text": ["I've never used jython, but I hear that the jython/Java optimization path isn't all that bad."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I agree with the Idea of coding first in a high level language such as Python,  Profiling and then Implementing any code that needs speeding up in C / C++ and wrapping it for use in the high level language."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As an alternative to boost I would like to suggest SWIG for creating Python callable code from C. Its reasonably painless to use, and will compile callable modules for a wide range of languages.", "(Python, Ruby, Java, Lua.", "to name a few) from C code."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "SWIG", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.swig.org/"}]}, {"text": ["The wrapping process is semi automated, so there is no need to add new functions to the base C code, making a smoother work flow. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It may be a good approach to start with a script, and call a compilation-based language from that script only for more advanced needs."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For instance, calling java from ruby script works quite well."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "calling java from ruby script", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.javaworld.com/javaworld/jw-07-2006/jw-0717-ruby.html"}]}, {"code": "<pre>\n<code>\n require \"java\"\n# The next line exposes Java's String as JString\ninclude_class(\"java.lang.String\") { |pkg, name| \"J\" + name }\ns = JString.new(\"f\")\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You can build your program in one of the higher level languages for example Python or Ruby and then call modules that are compiled in the lower level language for the parts you need performance.", "You can choose a platform depending on the lower level language you want."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example if you want to do C++ for the speedy stuff you can just use plain Python or Ruby and call DLLs compiled in C++.", "If you want to use Java you can use Jython or one of the other dynamic languages on the Java platform to call the Java code this is easier than the C++ route because you've got a common virtual machine so a Java object can be used directly in Jython or JRuby.", "The same can be done on the .Net platform with the Iron-languages and C# although you seem to have more experience with C++ and Java so those would be better options."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Perl has several ways to use other languages.", "Look at the Inline:: family of modules on CPAN.", "Following the advice from others in this question, I'd write the whole thing in a single dynamic language (Perl, Python, Ruby, etc) and then optimize the bits that need it.", "With Perl and Inline:: you can optimize in C, C++, or Java.", "Or you could look at AI::Prolog which allows you to embed Prolog for AI/Logic programming."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Inline::", "tag": "a", "pos": 1, "childList": [{"text": "", "tag": "em"}], "childNum": 1, "href": "http://search.cpan.org/perldoc?Inline"}, {"text": "", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "AI::Prolog", "tag": "a", "pos": 4, "childList": [], "childNum": 0, "href": "http://search.cpan.org/perldoc?AI::Prolog"}]}], [{"text": ["If you choose Perl there are plenty of resources for interfacing other languages."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Inline::C\nInline::CPP\nInline::Java"], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "Inline::C", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/dist/Inline/C/C.pod"}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"href": "http://search.cpan.org/dist/Inline-CPP/", "text": "Inline::CPP", "childNum": 0, "tag": "a", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"href": "http://search.cpan.org/dist/Inline-Java/Java.pod", "text": "Inline::Java", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["From Inline::C-Cookbook:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Inline::C-Cookbook", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/dist/Inline/C/C-Cookbook.pod"}]}, {"code": "<pre>\n<code>\n use Inline C =&gt; &lt;&lt;'END_C';\n\n  void greet() {\n    printf(\"Hello, world\\n\");\n  }\nEND_C\n\ngreet;\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I have a different perspective, having had lots of luck with integrating C++ and Python for some real time live video image processing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I would say you should match the language to the task for each module.", "If you're responding to a network, do it in Python, Python can keep up with network traffic just fine.", "UI: Python, People are slow, and Python is great for UIs using wxPython or PyObjC on Mac, or PyGTK.", "If you're doing math on lots of data, or signal processing, or image processing... code it in C or C++ with unit tests, then use SWIG to create the binding to any higher level language."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "SWIG", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}, {"text": ["I used the image libraries in wxWidgets in my C++, which are already exposed to Python through wxPython, so it was extremely powerful and quick.", "SCONS is a build tool (like make) which knows what to do with swig's .i files."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The topmost level can be in C or Python, you'll have more control and fewer packaging and deployment issues if the top level is in C or C++... but it will take a really long time to duplicate what Py2EXE or Py2App gives you on Windows or Mac (or freeze on Linux.", ") "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Enjoy the power of hybrid programming!", "(I call using multiple languages in a tightly coupled way 'hybrid' but it's just a quirk of mine."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If the problem domain is hard (and AI problems can often be hard), then I'd choose a language which is expressive or suited to the domain first, and then worry about speeding it up second.", "For example, Ruby has meta-programming primitives (ability to easily examine and modify the running program) which can make it very easy/interesting to implement certain types of algorithms."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you implement it in that way and then later need to speed it up, then you can use benchmarking/profiling to locate the bottleneck and either link to a compiled language for that, or optimise the algorithm.", "In my experience, the biggest performance gain is from tweaking the algorithm, not from using a different implementation language."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]