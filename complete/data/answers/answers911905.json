[[{"text": ["__getattribute__ simply returns the attribute that was requested, in case of a method, the __call__ interface is then used to call it."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__getattribute__", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "__call__", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Instead of returning the method, return a wrapper around it, for instance:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def __getattribute__(self, attr):\n     def make_interceptor(callble):\n         def func(*args, **kwargs):\n             print args, kwargs\n             return callble(*args, **kwargs)\n         return func\n     att = self.__dict__[attr]\n     if callable(att):\n        return make_interceptor(att)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Method invocation in Python is two step process, first a function is looked up, then it is invoked.", "For a more involved discussion see my answer to this question."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this question", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/852308/how-the-method-resolution-and-invocation-works-internally-in-python/870650#870650"}]}, {"text": ["So you would need to do something like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def __getattribute__(self, key):\n    if key == \"something_interesting\":\n        def func(*args, **kwargs):\n            # use arguments, and possibly the self variable from outer scope\n        return func\n    else:\n        return object.__getattribute__(self, key)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Also, overriding __getattribute__ is usually a bad idea.", "Because it is called on all attribute accesses it is really easy to end up in an infinite loop, and even if you do everything correctly it ends up being a pretty big performance hit.", "Are you sure that __getattr__ won't be enough for your purposes?", "Or maybe even a descriptor object that returns functions.", "Descriptors are usually a lot better at reuse."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Honestly I'm not sure I understand your question.", "If you want a way to override getattribute and yet keep the original attributes you can use __dict__"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__dict__", "tag": "a", "pos": 1, "childList": [{"text": "__dict__", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#object.%5F%5Fdict%5F%5F"}, {"text": "__dict__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def __getattribute__(self, attr):\n    if attr in self.__dict__:\n          return self.__dict__[attr]\n    # Add your changes here\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I don't think you can.", "__getattribute__ doesn't intercept the method call, it only intercepts the method name lookup.", "So it should return a function (or callable object), which will then be called with whatever parameters specified at the call site."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__getattribute__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In particular, if it returns a function which takes (*args, **kwargs), then in that function you can examine the arguments however you want."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "(*args, **kwargs)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I think.", "I'm not a Python expert."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Yes"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def argumentViewer(func):\n    def newfunc(*args, **kwargs):\n        print \"Calling %r with %r %r\" % (func, args, kwargs)\n        return func(*args, **kwargs)\n    return newfunc\n\nclass Foo(object):\n    def __getattribute__(self, name):\n        print \"retrieving data\"\n        return object.__getattribute__(self, name)\n\n    @argumentViewer\n    def bar(self, a, b):\n        return a+b\n\n# Output\n&gt;&gt;&gt; a=Foo()\n&gt;&gt;&gt; a.bar\nretrieving data\n&lt;bound method Foo.newfunc of &lt;__main__.Foo object at 0x01B0E3D0&gt;&gt;\n&gt;&gt;&gt; a.bar(2,5)\nretrieving data\nCalling &lt;function bar at 0x01B0ACF0&gt; with (&lt;__main__.Foo object at 0x01B0E3D0&gt;, 2, 5) {}\n7\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is a variation on Unknown's suggestion that returns a callable \"wrapper\" instance in place of the requested function.", "This does not require decorating any methods:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class F(object):\n   def __init__(self, func):\n      self.func = func\n      return\n   def __call__(self, *args, **kw):\n      print \"Calling %r:\" % self.func\n      print \"  args: %r\" % (args,)\n      print \"  kw: %r\" % kw\n      return self.func(*args,**kw)\n\nclass C(object):\n   def __init__(self):\n      self.a = 'an attribute that is not callable.'\n      return\n   def __getattribute__(self,name):\n      attr = object.__getattribute__(self,name)\n      if callable(attr):\n         # Return a callable object that can examine, and even\n         # modify the arguments prior to calling the method.\n         return F(attr)\n      # Return the reference to any non-callable attribute.\n      return attr\n   def m(self, *a, **kw):\n      print \"hello from m!\"\n      return\n\n&gt;&gt;&gt; c=C()\n&gt;&gt;&gt; c.a\n'an attribute that is not callable.'\n&gt;&gt;&gt; c.m\n&lt;__main__.F object at 0x63ff30&gt;\n&gt;&gt;&gt; c.m(1,2,y=25,z=26)\nCalling &lt;bound method C.m of &lt;__main__.C object at 0x63fe90&gt;&gt;:\n  args: (1, 2)\n  kw: {'y': 25, 'z': 26}\nhello from m!\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Ants Aasma above makes an important point regarding recursion when using __getattribute__.", "It is called by all attribute lookups on self, even those inside of the __getattribute__ method.", "Several of the other examples include references to self.__dict__ inside of __getattribute__ which will result in recursing until you exceed the maximum stack depth!", "To avoid this, use one of the\nbase class' versions of __getattribute__ (e.g.", "object.__getattribute__(self,name)."], "childNum": 9, "tag": "p", "senID": 2, "childList": [{"text": "Ants Aasma above", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/911905/is-there-a-way-to-access-the-formal-parameters-if-you-implement-getattribute/911943#911943"}, {"text": "__getattribute__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "all", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__getattribute__", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "self.__dict__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__getattribute__", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "__getattribute__", "childNum": 0, "tag": "code", "childList": []}, {"text": "object.__getattribute__(self,name)", "childNum": 0, "tag": "code", "childList": []}]}]]