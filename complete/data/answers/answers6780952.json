[[{"text": ["Nothing wrong with your approach, but this is similar to the Autovivification feature of Perl, which has been implemented in Python in this question.", "Props to @nosklo for this."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "in this question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/651794/whats-the-best-way-to-initialize-a-dict-of-dicts-in-python"}]}, {"code": "<pre>\n<code>\n class RecursiveDict(dict):\n    \"\"\"Implementation of perl's autovivification feature.\"\"\"\n    def __getitem__(self, item):\n        try:\n            return dict.__getitem__(self, item)\n        except KeyError:\n            value = self[item] = type(self)()\n            return value\n\n&gt;&gt;&gt; a = RecursiveDict()\n&gt;&gt;&gt; a[1][2][3] = 4\n&gt;&gt;&gt; dict(a)\n{1: {2: {3: 4}}}\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["As suggested by @Rosh Oxymoron, using __missing__ results in a more concise implementation.", "Requires Python >= 2.5"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "__missing__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class RecursiveDict(dict):\n    \"\"\"Implementation of perl's autovivification feature.\"\"\"\n    def __missing__(self, key):\n        value = self[key] = type(self)()\n        return value\n</code>\n</pre>\n", "senID": 4}], [{"text": ["edit: As ironchefpython pointed out in comments, this isn't actually doing what I thought it did, as in my example b[1] is still a RecursiveDict.", "This may still be useful, as you essentially get an object pretty similar Rob Cowie's answer, but it is built on defaultdict."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "b[1]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "RecursiveDict", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "defaultdict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You can get the behavior you want (or something very similar) by overriding __repr__, check this out:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__repr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class RecursiveDict(defaultdict):\n    def __init__(self):\n        super(RecursiveDict, self).__init__(RecursiveDict)\n\n    def __repr__(self):\n        return repr(dict(self))\n\n&gt;&gt;&gt; a = RecursiveDict()\n&gt;&gt;&gt; a[1][2][3] = 4\n&gt;&gt;&gt; a             # a looks like a normal dict since repr is overridden\n{1: {2: {3: 4}}}\n&gt;&gt;&gt; type(a)\n&lt;class '__main__.RecursiveDict'&gt;\n&gt;&gt;&gt; b = dict(a)\n&gt;&gt;&gt; b             # dict(a) gives us a normal dictionary\n{1: {2: {3: 4}}}\n&gt;&gt;&gt; b[5][6] = 7   # obviously this won't work anymore\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyError: 5\n&gt;&gt;&gt; type(b)\n&lt;type 'dict'&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["There may be a better way to get to a normal dictionary view of the defaultdict than dict(self) but I couldn't find one, comment if you know how."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "defaultdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict(self)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You can't do it.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I deleted my previous answer, because I found after looking at the source code, that if you call dict(d) on a d that is a subclass of dict, it makes a fast copy of the underlying hash in C, and returns a new dict object."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "dict(d)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "d", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Sorry."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you really want this behavior, you'll need to create a RecursiveDict class that doesn't inherit from dict, and implement the __iter__ interface."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "RecursiveDict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "__iter__", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You need to override __iter__."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__iter__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def __iter__(self): \n    return iter((k, (v.dictify() if isinstance(v, dict) else v)) \n                for (k, v) in self.items())\n</code>\n</pre>\n", "senID": 1}, {"text": ["Instead of self.items(), you should use self.iteritems() on Python 2."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "self.items()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self.iteritems()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: OK, This seems to be your problem:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class B(dict): __iter__ = lambda self: iter(((1, 2), (3, 4)))\n... \n&gt;&gt;&gt; b = B()\n&gt;&gt;&gt; dict(b)\n{}\n&gt;&gt;&gt; class B(list): __iter__ = lambda self: iter(((1, 2), (3, 4)))\n... \n&gt;&gt;&gt; b = B()\n&gt;&gt;&gt; dict(b)\n{1: 2, 3: 4}\n</code>\n</pre>\n", "senID": 4}, {"text": ["So this method doesn't work if the object you're calling dict() on is a subclass of dict."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "dict()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit 2: To be clear, defaultdict is a subclass of dict.", "dict(a_defaultdict) is still a no-op."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "defaultdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Do you want just to print it like a dict ?", "use this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "print", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\nclass RecursiveDict(defaultdict):\n    '''\n    A recursive default dict.\n\n    &gt;&gt;&gt; a = RecursiveDict()\n    &gt;&gt;&gt; a[1][2][3] = 4\n    &gt;&gt;&gt; a.dictify()\n    {1: {2: {3: 4}}}\n    &gt;&gt;&gt; dict(a)\n    {1: {2: {3: 4}}}\n\n    '''\n    def __init__(self):\n        super(RecursiveDict, self).__init__(RecursiveDict)\n\n    def dictify(self):\n        '''Get a standard dictionary of the items in the tree.'''\n        return dict([(k, (v.dictify() if isinstance(v, dict) else v))\n                     for (k, v) in self.items()])\n\n    def __dict__(self):\n        '''Get a standard dictionary of the items in the tree.'''\n        print [(k, v) for (k, v) in self.items()]\n        return dict([(k, (dict(v) if isinstance(v, dict) else v))\n                     for (k, v) in self.items()])\n\n    def __repr__(self):\n        return repr(self.dictify())\n</code>\n</pre>\n", "senID": 1}, {"text": ["Maybe you are looking for __missing__ :"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "__missing__", "tag": "a", "pos": 0, "childList": [{"text": "__missing__", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#dict"}, {"text": "__missing__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class RecursiveDict(dict):\n    '''\n    A recursive default dict.\n\n    &gt;&gt;&gt; a = RecursiveDict()\n    &gt;&gt;&gt; a[1][2][3] = 4\n    &gt;&gt;&gt; a\n    {1: {2: {3: 4}}}\n    &gt;&gt;&gt; dict(a)\n    {1: {2: {3: 4}}}\n\n    '''\n\n    def __missing__(self, key):\n        self[key] = self.__class__()\n        return self[key]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Once you have your dictify function working just do"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dict = dictify\n</code>\n</pre>\n", "senID": 1}, {"text": ["Update:\nHere is a short way to have this recursive dict:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def RecursiveDict():\n...   return defaultdict(RecursiveDict)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then you can:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n d[1][2][3] = 5\nd[1][2][4] = 6\n&gt;&gt;&gt; d\ndefaultdict(&lt;function ReturnsRecursiveDict at 0x7f3ba453a5f0&gt;, {1: defaultdict(&lt;function ReturnsRecursiveDict at 0x7f3ba453a5f0&gt;, {2: defaultdict(&lt;function ReturnsRecursiveDict at 0x7f3ba453a5f0&gt;, {3: 5, 4: 6})})})\n</code>\n</pre>\n", "senID": 5}, {"text": ["I don't see a neat way to implement dictify."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]