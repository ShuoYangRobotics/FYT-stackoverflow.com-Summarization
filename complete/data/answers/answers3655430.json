[[{"text": ["For Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import random\n&gt;&gt;&gt; dst = 70, 20, 10\n&gt;&gt;&gt; vls = 'a', 'b', 'c'\n&gt;&gt;&gt; picks = [v for v, d in zip(vls, dst) for _ in range(d)]\n&gt;&gt;&gt; for _ in range(12): print random.choice(picks),\n... \na c c b a a a a a a a a\n&gt;&gt;&gt; for _ in range(12): print random.choice(picks),\n... \na c a c a b b b a a a a\n&gt;&gt;&gt; for _ in range(12): print random.choice(picks),\n... \na a a a c c a c a a c a\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["General idea: make a list where each item is repeated a number of times proportional to the probability it should have; use random.choice to pick one at random (uniformly), this will match your required probability distribution.", "Can be a bit wasteful of memory if your probabilities are expressed in peculiar ways (e.g., 70, 20, 10 makes a 100-items list where 7, 2, 1 would make a list of just 10 items with exactly the same behavior), but you could divide all the counts in the probabilities list by their greatest common factor if you think that's likely to be a big deal in your specific application scenario."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "random.choice", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "70, 20, 10", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "7, 2, 1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Apart from memory consumption issues, this should be the fastest solution -- just one random number generation per required output result, and the fastest possible lookup from that random number, no comparisons &amp;c.  If your likely probabilities are very weird (e.g., floating point numbers that need to be matched to many, many significant digits), other approaches may be preferable;-)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Here is a complete solution in C#:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Here is a complete solution in C#:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n public class ProportionValue&lt;T&gt;\n{\n    public double Proportion { get; set; }\n    public T Value { get; set; }\n}\n\npublic static class ProportionValue\n{\n    public static ProportionValue&lt;T&gt; Create&lt;T&gt;(double proportion, T value)\n    {\n        return new ProportionValue&lt;T&gt; { Proportion = proportion, Value = value };\n    }\n\n    static Random random = new Random();\n    public static T ChooseByRandom&lt;T&gt;(\n        this IEnumerable&lt;ProportionValue&lt;T&gt;&gt; collection)\n    {\n        var rnd = random.NextDouble();\n        foreach (var item in collection)\n        {\n            if (rnd &lt; item.Proportion)\n                return item.Value;\n            rnd -= item.Proportion;\n        }\n        throw new InvalidOperationException(\n            \"The proportions in the collection do not add up to 1.\");\n    }\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Usage:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n var list = new[] {\n    ProportionValue.Create(0.7, \"a\"),\n    ProportionValue.Create(0.2, \"b\"),\n    ProportionValue.Create(0.1, \"c\")\n};\n\n// Outputs \"a\" with probability 0.7, etc.\nConsole.WriteLine(list.ChooseByRandom());\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Knuth references Walker's method of aliases.", "Searching on this, I find http://code.activestate.com/recipes/576564-walkers-alias-method-for-random-objects-with-diffe/ and http://prxq.wordpress.com/2006/04/17/the-alias-method/.", "This gives the exact probabilities required in constant time per number generated with linear time for setup (curiously, n log n time for setup if you use exactly the method Knuth describes, which does a preparatory sort you can avoid)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "http://code.activestate.com/recipes/576564-walkers-alias-method-for-random-objects-with-diffe/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/576564-walkers-alias-method-for-random-objects-with-diffe/"}, {"text": "http://prxq.wordpress.com/2006/04/17/the-alias-method/", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://prxq.wordpress.com/2006/04/17/the-alias-method/"}]}], [{"text": ["Take the list of and find the cumulative total of the weights: 70, 70+20, 70+20+10.", "Pick a random number greater than or equal to zero and less than the total.", "Iterate over the items and return the first value for which the cumulative sum of the weights is greater than this random number:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def select( values ):\n    variate = random.random() * sum( values.values() )\n    cumulative = 0.0\n    for item, weight in values.items():\n        cumulative += weight\n        if variate &lt; cumulative:\n            return item\n    return item # Shouldn't get here, but just in case of rounding...\n\nprint select( { \"a\": 70, \"b\": 20, \"c\": 10 } )\n</code>\n</pre>\n", "senID": 1}, {"text": ["This solution, as implemented, should also be able to handle fractional weights and weights that add up to any number so long as they're all non-negative."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n def weighted_choice(probabilities):\n    random_position = random.random() * sum(probabilities)\n    current_position = 0.0\n    for i, p in enumerate(probabilities):\n        current_position += p\n        if random_position &lt; current_position:\n            return i\n    return None\n</code>\n</pre>\n", "senID": 0}, {"text": ["Because random.random will always return &lt; 1.0, the final return should never be reached."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "random.random", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["today, the update of python document give an example to make a random.choice() with weighted probabilities:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "the update of python document", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/py3k/library/random.html#examples-and-recipes"}]}, {"text": ["If the weights are small integer ratios, a simple technique is to build a sample population with repeats:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; weighted_choices = [('Red', 3), ('Blue', 2), ('Yellow', 1), ('Green', 4)]\n&gt;&gt;&gt; population = [val for val, cnt in weighted_choices for i in range(cnt)]\n&gt;&gt;&gt; random.choice(population)\n'Green'\n</code>\n</pre>\n", "senID": 2}, {"text": ["A more general approach is to arrange the weights in a cumulative distribution with itertools.accumulate(), and then locate the random value with bisect.bisect():"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; choices, weights = zip(*weighted_choices)\n&gt;&gt;&gt; cumdist = list(itertools.accumulate(weights))\n&gt;&gt;&gt; x = random.random() * cumdist[-1]\n&gt;&gt;&gt; choices[bisect.bisect(cumdist, x)]\n'Blue'\n</code>\n</pre>\n", "senID": 4}, {"text": ["one note: itertools.accumulate() needs python 3.2 or define it with the Equivalent."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "itertools.accumulate() needs python 3.2 or define it with the Equivalent.", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/py3k/library/itertools.html#itertools.accumulate"}]}], [{"text": ["I think you can have an array of small objects (I implemented in Java although I know a little bit C# but I am afraid can write wrong code), so you may need to port it yourself.", "The code in C# will be much smaller with struct, var but I hope you get the idea"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class PercentString {\n  double percent;\n  String value;\n  // Constructor for 2 values\n}\n\nArrayList&lt;PercentString&gt; list = new ArrayList&lt;PercentString();\nlist.add(new PercentString(70, \"a\");\nlist.add(new PercentString(20, \"b\");\nlist.add(new PercentString(10, \"c\");\n\ndouble percent = 0;\nfor (int i = 0; i &lt; list.size(); i++) {\n  PercentString p = list.get(i);\n  percent += p.percent;\n  if (random &lt; percent) {\n    return p.value;\n  }\n}\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import random\n\ndef selector(weights):\n    i=random.random()*sum(x for x,y in weights)\n    for w,v in weights:\n        if w&gt;=i:\n            break\n        i-=w\n    return v\n\nweights = ((70,'a'),(20,'b'),(10,'c'))\nprint [selector(weights) for x in range(10)]\n</code>\n</pre>\n", "senID": 0}, {"text": ["it works equally well for fractional weights"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n weights = ((0.7,'a'),(0.2,'b'),(0.1,'c'))\nprint [selector(weights) for x in range(10)]\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you have a lot of weights, you can use bisect to reduce the number of iterations required"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "lot", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import random\nimport bisect\n\ndef make_acc_weights(weights):\n    acc=0\n    acc_weights = []\n    for w,v in weights:\n        acc+=w\n        acc_weights.append((acc,v))\n    return acc_weights\n\ndef selector(acc_weights):\n    i=random.random()*sum(x for x,y in weights)\n    return weights[bisect.bisect(acc_weights, (i,))][1]\n\nweights = ((70,'a'),(20,'b'),(10,'c'))\nacc_weights = make_acc_weights(weights)    \nprint [selector(acc_weights) for x in range(100)]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Also works fine for fractional weights"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n weights = ((0.7,'a'),(0.2,'b'),(0.1,'c'))\nacc_weights = make_acc_weights(weights)    \nprint [selector(acc_weights) for x in range(100)]\n</code>\n</pre>\n", "senID": 6}], []]