[[{"text": ["I know this is a question about regex.", "I just thought I'd mention the count method for future reference if someone wants a non-regex solution."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "count", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#str.count"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = \"It actually happened when it acted out of turn.\"\n&gt;&gt;&gt; s.count('t a')\n2\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which return the number of non-overlapping occurrences of the substring"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The existing solutions based on findall are fine for non-overlapping matches (and no doubt optimal except maybe for HUGE number of matches), although alternatives such as sum(1 for m in re.finditer(thepattern, thestring)) (to avoid ever materializing the list when all you care about is the count) are also quite possible.", "Somewhat idiosyncratic would be using subn and ignoring the resulting string...:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "findall", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sum(1 for m in re.finditer(thepattern, thestring))", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "subn", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def countnonoverlappingrematches(pattern, thestring):\n  return re.subn(pattern, '', thestring)[1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["the only real advantage of this latter idea would come if you only cared to count (say) up to 100 matches; then, re.subn(pattern, '', thestring, 100)[1] might be practical (returning 100 whether there are 100 matches, or 1000, or even larger numbers)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "re.subn(pattern, '', thestring, 100)[1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Counting overlapping matches requires you to write more code, because the built-in functions in question are all focused on NON-overlapping matches.", "There's also a problem of definition, e.g, with pattern being 'a+' and thestring being 'aa', would you consider this to be just one match, or three (the first a, the second one, both of them), or...?"], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "overlapping", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "'a+'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "'aa'", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Assuming for example that you want possibly-overlapping matches starting at distinct spots in the string (which then would give TWO matches for the example in the previous paragraph):"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "starting at distinct spots in the string", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def countoverlappingdistinct(pattern, thestring):\n  total = 0\n  start = 0\n  there = re.compile(pattern)\n  while True:\n    mo = there.search(thestring, start)\n    if mo is None: return total\n    total += 1\n    start = 1 + mo.start()\n</code>\n</pre>\n", "senID": 5}, {"text": ["Note that you do have to compile the pattern into a RE object in this case: function re.search does not accept a start argument (starting position for the search) the way method search does, so you'd have to be slicing thestring as you go -- definitely more effort than just having the next search start at the next possible distinct starting point, which is what I'm doing in this function."], "childNum": 4, "tag": "p", "senID": 6, "childList": [{"text": "re.search", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "start", "childNum": 0, "tag": "code", "childList": []}, {"text": "method", "childNum": 0, "tag": "em", "childList": []}, {"text": "search", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Have you tried this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n len( pattern.findall(source) )\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import re\nlen(re.findall(pattern, string_to_search))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You can find overlapping matches by using a noncapturing subpattern:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def count_overlapping(pattern, string):\n    return len(re.findall(\"(?=%s)\" % pattern, string))\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import re\nprint len(re.findall(r'ab',u'ababababa'))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["To avoid creating a list of matches one may also use re.sub with a callable as replacement.", "It will be called on each match, incrementing internal counter."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re.sub", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re#re.sub"}]}, {"code": "<pre>\n<code>\n class Counter(object):\n    def __init__(self):\n        self.matched = 0\n    def __call__(self, matchobj):\n        self.matched += 1\n\ncounter = Counter()\nre.sub(some_pattern, counter, text)\n\nprint counter.matched\n</code>\n</pre>\n", "senID": 1}]]