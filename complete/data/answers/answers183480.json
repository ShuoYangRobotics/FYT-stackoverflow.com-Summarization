[[{"text": ["One issue is that there is a race condition in your above code, since there is a gap between testing for existance, and creating the file.", "There may be security implications to this (think about someone maliciously inserting a symlink to a sensitive file which they wouldn't be able to overwrite, but your program running with a higher privilege could)  Attacks like these are why things like os.tempnam() are deprecated."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To get around it, the best approach is to actually try create the file in such a way that you'll get an exception if it fails, and on success, return the actually opened file object.", "This can be done with the lower level os.open functions, by passing both the os.O_CREAT and os.O_EXCL flags.", "Once opened, return the actual file (and optionally filename) you create.", "Eg, here's your code modified to use this approach (returning a (file, filename) tuple):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def unique_file(file_name):\n    counter = 1\n    file_name_parts = os.path.splitext(file_name) # returns ('/path/file', '.ext')\n    while 1:\n        try:\n            fd = os.open(file_name, os.O_CREAT | os.O_EXCL | os.O_RDRW)\n            return os.fdopen(fd), file_name\n        except OSError:\n            pass\n        file_name = file_name_parts[0] + '_' + str(counter) + file_name_parts[1]\n        counter += 1\n</code>\n</pre>\n", "senID": 2}, {"text": ["[Edit]  Actually, a better way, which will handle the above issues for you, is probably to use the tempfile module, though you may lose some control over the naming.", "Here's an example of using it (keeping a similar interface):"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "[Edit]", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def unique_file(file_name):\n    dirname, filename = os.path.split(file_name)\n    prefix, suffix = os.path.splitext(filename)\n\n    fd, filename = tempfile.mkstemp(suffix, prefix+\"_\", dirname)\n    return os.fdopen(fd), filename\n\n&gt;&gt;&gt; f, filename=unique_file('/home/some_dir/foo.txt')\n&gt;&gt;&gt; print filename\n/home/some_dir/foo_z8f_2Z.txt\n</code>\n</pre>\n", "senID": 4}, {"text": ["The only downside with this approach is that you will always get a filename with some random characters in it, as there's no attempt to create an unmodified file (/home/some_dir/foo.txt) first.", "You may also want to look at tempfile.TemporaryFile and NamedTemporaryFile, which will do the above and also automatically delete from disk when closed."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Yes, this is a good strategy for readable but unique filenames."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One important change: You should replace os.path.isfile with os.path.lexists!", "As it is written right now, if there is a directory named /foo/bar.baz, your program will try to overwrite that with the new file (which won't work)... since isfile only checks for files and not directories.", "lexists checks for directories, symlinks, etc... basically if there's any reason that filename could not be created."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "One important change", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "os.path.isfile", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "os.path.lexists", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "isfile", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "lexists", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["EDIT: @Brian gave a better answer, which is more secure and robust in terms of race conditions."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Two small changes..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n base_name, ext = os.path.splitext(file_name)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You get two results with distinct meaning, give them distinct names."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n file_name = \"%s_%d%s\" % (base_name, str(counter), ext)\n</code>\n</pre>\n", "senID": 3}, {"text": ["It isn't faster or significantly shorter.", "But, when you want to change your file name pattern, the pattern is on one place, and slightly easier to work with."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If you want readable names this looks like a good solution.", "There are routines to return unique file names for eg.", "temp files but they produce long random looking names."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}], [{"text": ["if you don't care about readability, uuid.uuid4() is your friend."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import uuid\n\ndef unique_filename(prefix=None, suffix=None):\n    fn = []\n    if prefix: fn.extend([prefix, '-'])\n    fn.append(str(uuid.uuid4()))\n    if suffix: fn.extend(['.', suffix.lstrip('.')])\n    return ''.join(fn)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def ensure_unique_filename(orig_file_path):    \n    from time import time\n    import os\n\n    if os.path.lexists(orig_file_path):\n        name, ext = os.path.splitext(orig_file_path)\n        orig_file_path = name + str(time()).replace('.', '') + ext\n\n    return orig_file_path\n</code>\n</pre>\n", "senID": 1}, {"text": ["time() returns current time in milliseconds.", "combined with original filename, it's fairly unique even in complex multithreaded cases."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]