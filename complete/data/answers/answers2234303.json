[[{"text": ["First of all it sounds like Windows has it wrong right in this case (not that this really matters).", "The C Standard requires that the value output by %.2f is rounded to the appropriate number of digits.", "The best known algorithm for this is dtoa implemented by David M. Gay.", "You can probably port this to Windows or find a native implementation."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "wrong", "childNum": 0, "tag": "strike", "pos": 0, "childList": []}, {"text": "%.2f", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "rounded to the appropriate number of digits", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "dtoa", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://netlib.sandia.gov/fp/index.html"}, {"text": "David M. Gay", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.cs.sandia.gov/~dmgay/"}]}, {"text": ["If you haven't already read \"How to Print Floating-Point Numbers Accurately\" by Steele and White, find a copy and read it.", "It is definitely an enlightening read.", "Make sure to find the original from the late 70's.", "I think that I purchased mine from ACM or IEEE at some point."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "\"How to Print Floating-Point Numbers Accurately\"", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["I don't think Windows is doing anything especially clever (like trying to reinterpret the float in base 10) here:  I'd guess that it's simply computing the first 17 significant digits accurately (which would give '11.545000000000000') and then tacking extra zeros on the end to make up the requested number of places after the point."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As others have said, the different results for 0.125 come from Windows using round-half-up and Linux using round-half-to-even."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Note that for Python 3.1 (and Python 2.7, when it appears), the result of formatting a float will be platform independent (except possibly on unusual platforms)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The decimal module gives you access to several rounding modes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import decimal\n\nfs = ['11.544','11.545','11.546']\n\ndef convert(f,nd):\n    # we want 'nd' beyond the dec point\n    nd = f.find('.') + nd\n    c1 = decimal.getcontext().copy()\n    c1.rounding = decimal.ROUND_HALF_UP\n    c1.prec = nd\n    d1 = c1.create_decimal(f)\n    c2 = decimal.getcontext().copy()\n    c2.rounding = decimal.ROUND_HALF_DOWN\n    c2.prec = nd   \n    d2 = c2.create_decimal(f)\n    print d1, d2\n\nfor f in fs:\n    convert(f,2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can construct a decimal from an int or a string.", "In your case feed it a string with more digits than you want and truncate by setting context.prec. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here is a link to a pymotw post w/ a detailed overview of the decimal module:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["http://broadcast.oreilly.com/2009/08/pymotw-decimal---fixed-and-flo.html"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://broadcast.oreilly.com/2009/08/pymotw-decimal---fixed-and-flo.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://broadcast.oreilly.com/2009/08/pymotw-decimal---fixed-and-flo.html"}]}], [{"text": ["Consider comparing floating point numbers with some tolerance/epsilon instead.", "This is much more robust than trying to match exactly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What I mean is, except saying that two floats are equal when:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n f1 == f2\n</code>\n</pre>\n", "senID": 2}, {"text": ["Say they're equal when:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n fabs(f1 - f2) &lt; eps\n</code>\n</pre>\n", "senID": 4}, {"text": ["For some small eps.", "More details on this issue can be found here."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "eps", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm"}]}], [{"text": ["You could try subtracting (or adding for a negative number) a small delta that will have no effect on the rounding for numbers far enough away from the precision."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, if you're rounding with %.2f, try this version on Windows:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "%.2f", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n printf(\"%.2f\", 11.545 - 0.001);\n</code>\n</pre>\n", "senID": 2}, {"text": ["Floating point numbers are notoriously problematic if you don't know what's happening under the covers.", "In that case, your best bet is to write (or use) a decimal type library to alleviate the problems."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The example program:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;stdio.h&gt;\nint main (void) {\n    printf(\"%.20f\\n\", 11.545);\n    printf(\"%.2f\\n\", 11.545);\n    printf(\"%.2f\\n\", 11.545 + 0.001);\n    return 0;\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["outputs this in my Cygwin environment:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n 11.54499999999999992895\n11.54\n11.55\n</code>\n</pre>\n", "senID": 7}, {"text": ["which is okay for your specific case (it's going the wrong way but should hopefully apply in the other direction as well: you need to test it) but you should check your entire possible input range if you want to be certain this will work for all your cases."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Update:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Update:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Evgeny, based on your comment:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["that's why I said you would have to check the entire range to see if it would work, and why I stated a decimal data type would be preferable."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["If you want decimal accuracy, that's what you'll have to do.", "But you might want to consider the cases in that range where Linux goes the other way too (as per your comment) - there may be situation where Linux and Windows disagree in the opposite direction to what you've found - a decimal type probably won't solve that."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["You may need to make your comparison tools a little more intelligent inasmuch as they can ignore a difference of 1 in the final fractional place."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["You may be able to do subtract a tiny amount from the value to force the rounding down"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n print \"%.2f\"%(11.545-1e-12)\n</code>\n</pre>\n", "senID": 1}]]