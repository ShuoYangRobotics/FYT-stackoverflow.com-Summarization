[[{"text": ["People seem to be over complicating this.. Just combine the two lists, then sort them:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l1 = [1, 3, 4, 7]\n&gt;&gt;&gt; l2 = [0, 2, 5, 6, 8, 9]\n&gt;&gt;&gt; l1.extend(l2)\n&gt;&gt;&gt; sorted(l1)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code>\n</pre>\n", "senID": 1}, {"text": ["..or shorter (and without modifying l1):"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "l1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sorted(l1 + l2)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code>\n</pre>\n", "senID": 3}, {"text": ["..easy!", "Plus, it's using only two built-in functions, so assuming the lists are of a reasonable size, it should be quicker than implementing the sorting/merging in a loop.", "More importantly, the above is much less code, and very readable."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If your lists are large (over a few hundred thousand, I would guess), it may be quicker to use an alternative/custom sorting method, but there are likely other optimisations to be made first (e.g not storing millions of datetime objects)"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "datetime", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Using the timeit.Timer().repeat() (which repeats the functions 1000000 times), I loosely benchmarked it against ghoseb's solution, and sorted(l1+l2) is substantially quicker:"], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "timeit.Timer().repeat()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/464342/combining-two-sorted-lists-in-python#464454", "text": "ghoseb's", "childNum": 0, "tag": "a", "childList": []}, {"text": "sorted(l1+l2)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["merge_sorted_lists took.."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "merge_sorted_lists", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n [9.7439379692077637, 9.8844599723815918, 9.552299976348877]\n</code>\n</pre>\n", "senID": 8}, {"text": ["sorted(l1+l2) took.."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "sorted(l1+l2)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n [2.860386848449707, 2.7589840888977051, 2.7682540416717529]\n</code>\n</pre>\n", "senID": 10}], [{"text": ["This hasn't been mentioned, so I'll go ahead - there is a merge stdlib function in the heapq module of python 2.6+.", "If all you're looking to do is getting things done, this might be a better idea.", "Of course, if you want to implement your own, the merge of merge-sort is the way to go."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "merge stdlib function", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Lib/heapq.py?view=markup"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list1 = [1, 5, 8, 10, 50]\n&gt;&gt;&gt; list2 = [3, 4, 29, 41, 45, 49]\n&gt;&gt;&gt; from heapq import merge\n&gt;&gt;&gt; list(merge(list1, list2))\n[1, 3, 4, 5, 8, 10, 29, 41, 45, 49, 50]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Long story short, unless len(l1 + l2) ~ 1000000 use:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "len(l1 + l2) ~ 1000000", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n L = l1 + l2\nL.sort()\n</code>\n</pre>\n", "senID": 1}, {"src": "http://i403.photobucket.com/albums/pp111/uber_ulrich/_020sorted_random_2147483647.png", "tag": "img", "senID": 2}, {"text": ["Description of the figure and source code can be found here. "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/464960/code-golf-combining-multiple-sorted-lists-into-a-single-sorted-list#464967"}]}, {"text": ["The figure was generated by the following command:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n $ python make-figures.py --nsublists 2 --maxn=0x100000 -s merge_funcs.merge_26 -s merge_funcs.sort_builtin\n</code>\n</pre>\n", "senID": 5}], [{"text": ["This is simply merging.", "Treat each list as if it were a stack, and continuously pop the smaller of the two stack heads, adding the item to the result list, until one of the stacks is empty.", "Then add all remaining items to the resulting list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["There is a slight flaw in ghoseb's solution, making it O(n**2), rather than O(n).", "The problem is that this is performing:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "ghoseb's", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/464342/combining-two-sorted-lists-in-python#464454"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n item = l1.pop(0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["With linked lists or deques this would be an O(1) operation, so wouldn't affect complexity, but since python lists are implemented as vectors, this copies the rest of the elements of l1 one space left, an O(n) operation.", "Since this is done each pass through the list, it turns an O(n) algorithm into an O(n**2) one.", "This can be corrected by using a method that doesn't alter the source lists, but just keeps track of the current position."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I've tried out benchmarking a corrected algorithm vs a simple sorted(l1+l2) as suggested by dbr"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "dbr", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/464342/combining-two-sorted-lists-in-python#464538"}]}, {"code": "<pre>\n<code>\n def merge(l1,l2):\n    if not l1:  return list(l2)\n    if not l2:  return list(l1)\n\n    # l2 will contain last element.\n    if l1[-1] &gt; l2[-1]:\n        l1,l2 = l2,l1\n\n    it = iter(l2)\n    y = it.next()\n    result = []\n\n    for x in l1:\n        while y &lt; x:\n            result.append(y)\n            y = it.next()\n        result.append(x)\n    result.append(y)\n    result.extend(it)\n    return result\n</code>\n</pre>\n", "senID": 4}, {"text": ["I've tested these with lists generated with"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n l1 = sorted([random.random() for i in range(NITEMS)])\nl2 = sorted([random.random() for i in range(NITEMS)])\n</code>\n</pre>\n", "senID": 6}, {"text": ["For various sizes of list, I get the following timings (repeating 100 times):"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n # items:  1000   10000 100000 1000000\nmerge  :  0.079  0.798 9.763  109.044 \nsort   :  0.020  0.217 5.948  106.882\n</code>\n</pre>\n", "senID": 8}, {"text": ["So in fact, it looks like dbr is right, just using sorted() is preferable unless you're expecting very large lists, though it does have worse algorithmic complexity.", "The break even point being at around a million items in each source list (2 million total)."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["One advantage of the merge approach though is that it is trivial to rewrite as a generator, which will use substantially less memory (no need for an intermediate list)."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["[Edit]\nI've retried this with a situation closer to the question - using a list of objects containing a field \"date\" which is a datetime object.", "The above algorithm was changed to compare against .date instead, and the sort method was changed to:"], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "[Edit]", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "date", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": ".date", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n return sorted(l1 + l2, key=operator.attrgetter('date'))\n</code>\n</pre>\n", "senID": 12}, {"text": ["This does change things a bit.", "The comparison being more expensive means that the number we perform becomes more important, relative to the constant-time speed of the implementation.", "This means merge makes up lost ground, surpassing the sort() method at 100,000 items instead.", "Comparing based on an even more complex object (large strings or lists for instance) would likely shift this balance even more."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n # items:  1000   10000 100000  1000000[1]\nmerge  :  0.161  2.034 23.370  253.68\nsort   :  0.111  1.523 25.223  313.20\n</code>\n</pre>\n", "senID": 14}, {"text": ["[1]: Note: I actually only did 10 repeats for 1,000,000 items and scaled up accordingly as it was pretty slow."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}], [{"code": "<pre>\n<code>\n from datetime import datetime\nfrom itertools import chain\nfrom operator import attrgetter\n\nclass DT:\n    def __init__(self, dt):\n        self.dt = dt\n\nlist1 = [DT(datetime(2008, 12, 5, 2)),\n         DT(datetime(2009, 1, 1, 13)),\n         DT(datetime(2009, 1, 3, 5))]\n\nlist2 = [DT(datetime(2008, 12, 31, 23)),\n         DT(datetime(2009, 1, 2, 12)),\n         DT(datetime(2009, 1, 4, 15))]\n\nlist3 = sorted(chain(list1, list2), key=attrgetter('dt'))\nfor item in list3:\n    print item.dt\n</code>\n</pre>\n", "senID": 0}, {"text": ["The output:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n 2008-12-05 02:00:00\n2008-12-31 23:00:00\n2009-01-01 13:00:00\n2009-01-02 12:00:00\n2009-01-03 05:00:00\n2009-01-04 15:00:00\n</code>\n</pre>\n", "senID": 2}, {"text": ["I bet this is faster than any of the fancy pure-Python merge algorithms, even for large data.", "Python 2.6's heapq.merge is a whole another story."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "heapq.merge", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["This is simple merging of two sorted lists.", "Take a look at the sample code below which merges two sorted lists of integers."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n## merge.py -- Merge two sorted lists -*- Python -*-\n## Time-stamp: \"2009-01-21 14:02:57 ghoseb\"\n\nl1 = [1, 3, 4, 7]\nl2 = [0, 2, 5, 6, 8, 9]\n\ndef merge_sorted_lists(l1, l2):\n    \"\"\"Merge sort two sorted lists\n\n    Arguments:\n    - `l1`: First sorted list\n    - `l2`: Second sorted list\n    \"\"\"\n    sorted_list = []\n\n    # Copy both the args to make sure the original lists are not\n    # modified\n    l1 = l1[:]\n    l2 = l2[:]\n\n    while (l1 and l2):\n        if (l1[0] &lt;= l2[0]): # Compare both heads\n            item = l1.pop(0) # Pop from the head\n            sorted_list.append(item)\n        else:\n            item = l2.pop(0)\n            sorted_list.append(item)\n\n    # Add the remaining of the lists\n    sorted_list.extend(l1 if l1 else l2)\n\n    return sorted_list\n\nif __name__ == '__main__':\n    print merge_sorted_lists(l1, l2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This should work fine with datetime objects.", "Hope this helps."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Use the 'merge' step of merge sort, it runs in O(n) time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["From wikipedia (pseudo-code):"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "wikipedia", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Merge_sort"}]}, {"code": "<pre>\n<code>\n function merge(left,right)\n    var list result\n    while length(left) &gt; 0 and length(right) &gt; 0\n        if first(left) \u2264 first(right)\n            append first(left) to result\n            left = rest(left)\n        else\n            append first(right) to result\n            right = rest(right)\n    end while\n    while length(left) &gt; 0 \n        append left to result\n    while length(right) &gt; 0 \n        append right to result\n    return result\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Well, the naive approach (combine 2 lists into large one and sort) will be O(N*log(N)) complexity.", "On the other hand, if you implement the merge manually (i do not know about any ready code in python libs for this, but i'm no expert) the complexity will be O(N), which is clearly faster.", "The idea is described wery well in post by Barry Kelly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n def compareDate(obj1, obj2):\n    if obj1.getDate() &lt; obj2.getDate():\n        return -1\n    elif obj1.getDate() &gt; obj2.getDate():\n        return 1\n    else:\n        return 0\n\n\n\nlist = list1 + list2\nlist.sort(compareDate)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Will sort the list in place.", "Define your own function for comparing two objects, and pass that function into the built in sort function."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Do NOT use bubble sort, it has horrible performance."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]