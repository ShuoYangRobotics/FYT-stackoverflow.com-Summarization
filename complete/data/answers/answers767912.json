[[{"text": ["This is very similar to the Knight's Tour problem which relates moving a knight around a chess board without revisiting the same square.", "Basically it's the same problem but with different \"Traverse Rules\"."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Knight's Tour", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Knight%27s%5Ftour"}]}, {"text": ["The key optimisation I remember from tackling the Knights Tour recursively is take your next moves in increasing order of the number of available moves on the destination square.", "This encourages the search to try and move densely in one area and filling it rather than zooming all over the board and leaving little island squares that can never be visited.", "(This is Warnsdorff's algorithm."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Warnsdorff's algorithm", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Knight%27s%5Ftour#Warnsdorff.27s%5Falgorithm"}]}, {"text": ["Also make sure you have considered symmetry where you can.", "For example, at the simplest level the x and y of your starting square only need to go up to 5 since (10,10) is the same as (1,1) with the board rotated."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I decided to look at the problem and see if I could break it into 5x5 solutions with the ending of a solution one jump away from the corner of another.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First assumption was that 5x5 is solvable.", "It is and fast."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So I ran solve(0,5) and looked at the results.", "I drew a 10x10 numbered grid in Excel with a 5x5 numbered grid for translation.", "Then I just searched the results for #] (ending cells) that would be a jump away from the start of the next 5x5.", "(ex.", "for the first square, I searched for \"13]\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For reference:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n 10 x 10 grid                       5 x 5 grid \n 0  1  2  3  4 |  5  6  7  8  9     0  1  2  3  4\n10 11 12 13 14 | 15 16 17 18 19     5  6  7  8  9\n20 21 22 23 24 | 25 26 27 28 29    10 11 12 13 14\n30 31 32 33 34 | 35 36 37 38 39    15 16 17 18 19\n40 41 42 43 44 | 45 46 47 48 49    20 21 22 23 24\n---------------+---------------\n50 51 52 53 54 | 55 56 57 58 59\n60 61 62 63 64 | 65 66 67 68 69\n70 71 72 73 74 | 75 76 77 78 79\n80 81 82 83 84 | 85 86 87 88 89\n90 91 92 93 94 | 95 96 97 98 99\n</code>\n</pre>\n", "senID": 4}, {"text": ["Here is a possible solution:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["First square: [0, 15, 7, 19, 16, 1, 4, 12, 20, 23, 8, 5, 17, 2, 10, 22, 14, 11, 3, 18, 6, 9, 24, 21, 13] puts it a diagonal jump up to 5 (in 10x10) the first corner of the next 5 x 5."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Second Square: [0, 12, 24, 21, 6, 9, 17, 2, 14, 22, 7, 15, 18, 3, 11, 23, 20, 5, 8, 16, 19, 4, 1, 13, 10] puts it with last square of 25 in the 10x10, which is two jumps away from 55."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Third Square: [0, 12, 24, 21, 6, 9, 17, 5, 20, 23, 8, 16, 19, 4, 1, 13, 10, 2, 14, 11, 3, 18, 15, 7, 22] puts it with last square of 97 in the 10x10, which is two jumps away from 94.  "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Fourth Square can be any valid solution, because end point doesn't matter.", "However, the mapping of the solution from 5x5 to 10x10 is harder, as the square is starting on the opposite corner.", "Instead of translating, ran solve(24,5) and picked one at random: [24, 9, 6, 21, 13, 10, 2, 17, 5, 20, 23, 8, 16, 1, 4, 12, 0, 15, 18, 3, 11, 14, 22, 7, 19]"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["This should be possible to all do programatically, now that 5x5 solutions are know to be valid with endpoints legal moves to the next 5x5 corner.", "Number of 5x5 solutions was 552, which means storing the solutions for further calculation and remapping is pretty easy."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Unless I did this wrong, this gives you one possible solution (defined above 5x5 solutions as one through four respectively):"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def trans5(i, col5, row5):\n    if i &lt; 5: return 5 * col5 + 50 * row5 + i\n    if i &lt; 10: return 5 + 5 * col5 + 50 * row5 + i\n    if i &lt; 15: return 10 + 5 * col5 + 50 * row5 + i\n    if i &lt; 20: return 15 + 5 * col5 + 50 * row5 + i\n    if i &lt; 25: return 20 + 5 * col5 + 50 * row5 + i\n\n&gt;&gt;&gt; [trans5(i, 0, 0) for i in one] + [trans5(i, 1, 0) for i in two] + [trans5(i, 0, 1) for i in three] + [trans5(i, 1, 1) for i in four]\n    [0, 30, 12, 34, 31, 1, 4, 22, 40, 43, 13, 10, 32, 2, 20, 42, 24, 21, 3, 33, 11, 14, 44, 41, 23, 5, 27, 49, 46, 16, 19, 37, 7, 29, 47, 17, 35, 38, 8, 26, 48, 45, 15, 18, 36, 39, 9, 6, 28, 25, 50, 72, 94, 91, 61, 64, 82, 60, 90, 93, 63, 81, 84, 54, 51, 73, 70, 52, 74, 71, 53, 83, 80, 62, 92, 99, 69, 66, 96, 78, 75, 57, 87, 65, 95, 98, 68, 86, 56, 59, 77, 55, 85, 88, 58, 76, 79, 97, 67, 89]\n</code>\n</pre>\n", "senID": 12}, {"text": ["Can some one double check the methodology?", "I think this is a valid solution and method of breaking up the problem."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["Eventually, I have come up with the modified Python code to overcome the problem.", "I've tun the code for a couple of hours and it has already found half a million solutions in a couple of hours.", "The full set of solutions still require a total exhaustive search, i.e.", "to let the program run until it finishes with all combinations.", "However, reaching \"a\" legitimate solution can be reduced to \"linear time\"."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["First, things I have learned: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Upon exhaustive brute-force search, here are key points I have developed on the code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": ["Warnsdorff's algorithm: This\nalgorithm is the key point to reach\nto a handy number of solutions in a\nquick way.", "It simply states that, you\nshould pick your next move to the\n\"least accessible\" place and populate\nyour \"to go\" list with ascending\norder or accesibility.", "Least\naccessible place means the place with\nleast number of possible following\nmoves."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Warnsdorff's algorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Knight%27s%5Ftour#Warnsdorff.27s%5Falgorithm"}]}]}, {"tag": "hr", "senID": 4}, {"text": ["Some definitions:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "A position Q is accessible from a position P if P can move to Q by a single knight's move, and Q has not yet been visited.", "tag": "none", "senID": 6}, {"text": "The accessibility of a position P is the number of positions accessible from P.", "tag": "none", "senID": 7}]}, {"text": ["Algorithm:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"tag": "hr", "senID": 9}, {"tag": "ul", "num": 1, "lis": [{"text": ["Checking for islands"], "childNum": 0, "tag": "a", "senID": 10, "childList": []}]}, {"text": ["And here is my code in Python which solves the riddle (to an acceptable degree considering that the problem is NP-Hard).", "The code is easy to understand as I consider myself at beginner level in Python.", "The comments are straightforward in explaining the implementation.", "Solutions can be displayed on a simple grid by a basic GUI (guidelines in the code)."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n # Solve square puzzle\nimport operator\n\nclass Node:\n# Here is how the squares are defined\n    def __init__(self, ID, base):\n        self.posx = ID % base\n        self.posy = ID / base\n        self.base = base\n    def isValidNode(self, posx, posy):\n        return (0&lt;=posx&lt;self.base and 0&lt;=posy&lt;self.base)\n\n    def getNeighbors(self):\n        neighbors = []\n        if self.isValidNode(self.posx + 3, self.posy): neighbors.append(self.posx + 3 + self.posy*self.base)\n        if self.isValidNode(self.posx + 2, self.posy + 2): neighbors.append(self.posx + 2 + (self.posy+2)*self.base)\n        if self.isValidNode(self.posx, self.posy + 3): neighbors.append(self.posx + (self.posy+3)*self.base)\n        if self.isValidNode(self.posx - 2, self.posy + 2): neighbors.append(self.posx - 2 + (self.posy+2)*self.base)\n        if self.isValidNode(self.posx - 3, self.posy): neighbors.append(self.posx - 3 + self.posy*self.base)\n        if self.isValidNode(self.posx - 2, self.posy - 2): neighbors.append(self.posx - 2 + (self.posy-2)*self.base)\n        if self.isValidNode(self.posx, self.posy - 3): neighbors.append(self.posx + (self.posy-3)*self.base)\n        if self.isValidNode(self.posx + 2, self.posy - 2): neighbors.append(self.posx + 2 + (self.posy-2)*self.base)\n        return neighbors\n\n\n# the nodes go like this:\n# 0 =&gt; bottom left\n# (base-1) =&gt; bottom right\n# base*(base-1) =&gt; top left\n# base**2 -1 =&gt; top right\ndef solve(start_nodeID, base):\n    all_nodes = []\n    #Traverse list is the list to keep track of which moves are made (the id numbers of nodes in a list)\n    traverse_list = [start_nodeID]\n    for i in range(0, base**2): all_nodes.append(Node(i, base))\n    togo = dict()\n    #Togo is a dictionary with (nodeID:[list of neighbors]) tuples\n    togo[start_nodeID] = all_nodes[start_nodeID].getNeighbors()\n    solution_count = 0\n\n\n    while(True):\n        # The search is exhausted\n        if not traverse_list:\n            print \"Somehow, the search tree is exhausted and you have reached the divine salvation.\"\n            print \"Number of solutions:\" + str(solution_count)\n            break\n\n        # Get the next node to hop\n        try:\n            current_node_ID = togo[traverse_list[-1]].pop(0)\n        except IndexError:\n            del togo[traverse_list.pop()]\n            continue\n\n        # end condition check\n        traverse_list.append(current_node_ID)\n        if(len(traverse_list) == base**2):\n            #OMG, a solution is found\n            #print traverse_list\n            solution_count += 1\n            #Print solution count at a steady rate\n            if(solution_count%100 == 0): \n                print solution_count\n                # The solution list can be returned (to visualize the solution in a simple GUI)\n                #return traverse_list\n\n\n        # get valid neighbors\n        valid_neighbor_IDs = []\n        candidate_neighbor_IDs = all_nodes[current_node_ID].getNeighbors()\n        valid_neighbor_IDs = filter(lambda id: not id in traverse_list, candidate_neighbor_IDs)\n\n        # if no valid neighbors, take a step back\n        if not valid_neighbor_IDs:\n            traverse_list.pop()\n            continue\n\n        # if there exists a neighbor which is accessible only through the current node (island)\n        # and it is not the last one to go, the situation is not promising; so just eliminate that\n        stuck_check = True\n        if len(traverse_list) != base**2-1 and any(not filter(lambda id: not id in traverse_list, all_nodes[n].getNeighbors()) for n in valid_neighbor_IDs): stuck_check = False\n\n        # if stuck\n        if not stuck_check:\n            traverse_list.pop()\n            continue\n\n        # sort the neighbors according to accessibility (the least accessible first)\n        neighbors_ncount = []\n        for neighbor in valid_neighbor_IDs:\n            candidate_nn = all_nodes[neighbor].getNeighbors()\n            valid_nn = [id for id in candidate_nn if not id in traverse_list]\n            neighbors_ncount.append(len(valid_nn))\n        n_dic = dict(zip(valid_neighbor_IDs, neighbors_ncount))\n        sorted_ndic = sorted(n_dic.items(), key=operator.itemgetter(1))\n\n        sorted_valid_neighbor_IDs = []\n        for (node, ncount) in sorted_ndic: sorted_valid_neighbor_IDs.append(node)\n\n\n\n        # if current node does have valid neighbors, add them to the front of togo list\n        # in a sorted way\n        togo[current_node_ID] = sorted_valid_neighbor_IDs\n\n\n# To display a solution simply\ndef drawGUI(size, solution):\n    # GUI Code (If you can call it a GUI, though)\n    import Tkinter\n    root = Tkinter.Tk()\n    canvas = Tkinter.Canvas(root, width=size*20, height=size*20)\n    #canvas.create_rectangle(0, 0, size*20, size*20)\n    canvas.pack()\n\n    for x in range(0, size*20, 20):\n        canvas.create_line(x, 0, x, size*20)\n        canvas.create_line(0, x, size*20, x)\n\n    cnt = 1\n    for el in solution:\n        canvas.create_text((el % size)*20 + 4,(el / size)*20 + 4,text=str(cnt), anchor=Tkinter.NW)\n        cnt += 1\n    root.mainloop()\n\n\nprint('Start of run')\n\n# it is the moment\nsolve(0, 10)\n\n#Optional, to draw a returned solution\n#drawGUI(10, solve(0, 10))\n\nraw_input('End of Run...')\n</code>\n</pre>\n", "senID": 12}, {"text": ["Thanks to all everybody sharing their knowledge and ideas."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["This is just an example of the http://en.wikipedia.org/wiki/Hamiltonian_path problem.", "German wikipedia claims that it is NP-hard."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://en.wikipedia.org/wiki/Hamiltonian_path", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Hamiltonian%5Fpath"}]}], [{"text": ["An optimization can me made to check for islands (i.e.", "non-visited spaces with no valid neighbors.", ") and back out of the traverse until the island is eliminated.", "This would occur near the \"cheap\" side of a certain tree traverse.", "I guess the question is if the reduction is worth the expense."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I wanted to see if I could write a program that would come up with all possible solutions."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #! /usr/bin/env perl\nuse Modern::Perl;\n\n{\n  package Grid;\n  use Scalar::Util qw'reftype';\n\n  sub new{\n    my($class,$width,$height) = @_;\n    $width  ||= 10;\n    $height ||= $width;\n\n    my $self = bless [], $class;\n\n    for( my $x = 0; $x &lt; $width; $x++ ){\n      for( my $y = 0; $y &lt; $height; $y++ ){\n        $self-&gt;[$x][$y] = undef;\n      }\n    }\n\n    for( my $x = 0; $x &lt; $width; $x++ ){\n      for( my $y = 0; $y &lt; $height; $y++ ){\n        $self-&gt;[$x][$y] = Grid::Elem-&gt;new($self,$x,$y);;\n      }\n    }\n\n    return $self;\n  }\n\n  sub elem{\n    my($self,$x,$y) = @_;\n    no warnings 'uninitialized';\n    if( @_ == 2 and reftype($x) eq 'ARRAY' ){\n      ($x,$y) = (@$x);\n    }\n    die \"Attempted to use undefined var\" unless defined $x and defined $y;\n    my $return = $self-&gt;[$x][$y];\n    die unless $return;\n    return $return;\n  }\n\n  sub done{\n    my($self) = @_;\n    for my $col (@$self){\n      for my $item (@$col){\n        return 0 unless $item-&gt;visit(undef);\n      }\n    }\n    return 1;\n  }\n\n  sub reset{\n    my($self) = @_;\n    for my $col (@$self){\n      for my $item (@$col){\n        $item-&gt;reset;\n      }\n    }\n  }\n\n  sub width{\n    my($self) = @_;\n    return scalar @$self;\n  }\n\n  sub height{\n    my($self) = @_;\n    return scalar @{$self-&gt;[0]};\n  }\n}{\n  package Grid::Elem;\n  use Scalar::Util 'weaken';\n\n  use overload qw(\n    \"\" stringify\n    eq equal\n    == equal\n  );\n\n  my %dir = (\n    #       x, y\n    n  =&gt; [ 0, 2],\n    s  =&gt; [ 0,-2],\n    e  =&gt; [ 2, 0],\n    w  =&gt; [-2, 0],\n\n    ne =&gt; [ 1, 1],\n    nw =&gt; [-1, 1],\n\n    se =&gt; [ 1,-1],\n    sw =&gt; [-1,-1],\n  );\n\n  sub new{\n    my($class,$parent,$x,$y) = @_;\n    weaken $parent;\n    my $self = bless {\n      parent =&gt; $parent,\n      pos    =&gt; [$x,$y]\n    }, $class;\n\n    $self-&gt;_init_possible;\n\n    return $self;\n  }\n\n  sub _init_possible{\n    my($self) = @_;\n    my $parent = $self-&gt;parent;\n    my $width  = $parent-&gt;width;\n    my $height = $parent-&gt;height;\n    my($x,$y)  = $self-&gt;pos;\n\n    my @return;\n    for my $dir ( keys %dir ){\n      my($xd,$yd) = @{$dir{$dir}};\n      my $x = $x + $xd;\n      my $y = $y + $yd;\n\n      next if $y &lt; 0 or $height &lt;= $y;\n      next if $x &lt; 0 or $width  &lt;= $x;\n\n      push @return, $dir;\n      $self-&gt;{$dir} = [$x,$y];\n    }\n    return  @return if wantarray;\n    return \\@return;\n  }\n\n  sub list_possible{\n    my($self) = @_;\n    return unless defined wantarray;\n\n    # only return keys which are\n    my @return = grep {\n      $dir{$_} and defined $self-&gt;{$_}\n    } keys %$self;\n\n    return  @return if wantarray;\n    return \\@return;\n  }\n\n  sub parent{\n    my($self) = @_;\n    return $self-&gt;{parent};\n  }\n\n  sub pos{\n    my($self) = @_;\n    my @pos = @{$self-&gt;{pos}};\n    return @pos if wantarray;\n    return \\@pos;\n  }\n\n  sub visit{\n    my($self,$v) = @_;\n    my $return = $self-&gt;{visit} || 0;\n\n    $v = 1 if @_ == 1;\n    $self-&gt;{visit} = $v?1:0 if defined $v;\n\n    return $return;\n  }\n\n  sub all_neighbors{\n    my($self) = @_;\n    return $self-&gt;neighbor( $self-&gt;list_possible );\n  }\n  sub neighbor{\n    my($self,@n) = @_;\n    return unless defined wantarray;\n    return unless @n;\n\n    @n = map { exists $dir{$_} ? $_ : undef } @n;\n\n    my $parent = $self-&gt;parent;\n\n    my @return = map {\n      $parent-&gt;elem($self-&gt;{$_}) if defined $_\n    } @n;\n\n    if( @n == 1){\n      my($return) = @return;\n      #die unless defined $return;\n      return $return;\n    }\n    return  @return if wantarray;\n    return \\@return;\n  }\n\n  BEGIN{\n    for my $dir ( qw'n ne e se s sw w nw' ){\n      no strict 'refs';\n      *$dir = sub{\n        my($self) = @_;\n        my($return) = $self-&gt;neighbor($dir);\n        die unless $return;\n        return $return;\n      }\n    }\n  }\n\n  sub stringify{\n    my($self) = @_;\n    my($x,$y) = $self-&gt;pos;\n    return \"($x,$y)\";\n  }\n\n  sub equal{\n    my($l,$r) = @_;\n    \"$l\" eq \"$r\";\n  }\n\n  sub reset{\n    my($self) = @_;\n    delete $self-&gt;{visit};\n    return $self;\n  }\n}\n\n# Main code block\n{\n  my $grid = Grid-&gt;new();\n\n  my $start = $grid-&gt;elem(0,0);\n  my $dest  = $grid-&gt;elem(-1,-1);\n\n  my @all = solve($start,$dest);\n  #say @$_ for @all;\n  say STDERR scalar @all;\n}\n\nsub solve{\n  my($current,$dest,$return,@stack) = @_;\n  $return = [] unless $return;\n  my %visit;\n  $visit{$_} = 1 for @stack;\n\n  die if $visit{$current};\n\n  push @stack, $current-&gt;stringify;\n\n  if( $dest == $current ){\n    say @stack;\n\n    push @$return, [@stack];\n  }\n\n  my @possible = $current-&gt;all_neighbors;\n  @possible = grep{\n    ! $visit{$_}\n  } @possible;\n\n  for my $next ( @possible ){\n    solve($next,$dest,$return,@stack);\n  }\n\n  return @$return if wantarray;\n  return  $return;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["This program came up with more than 100,000 possible solutions before it was terminated.", "I sent STDOUT to a file, and it was more than 200 MB."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "STDOUT", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You could count the number of solutions exactly with a sweep-line dynamic programming algorithm."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]