[[{"code": "<pre>\n<code>\n [x for x in values if x % 2 == 1] + [x for x in values if x % 2 == 0] == values\n</code>\n</pre>\n", "senID": 0}, {"text": ["This is only true, if values starts with all of it's own odd values, followed by all of its even values. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "values", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Well, you don't need to calculate evens:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "evens", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n assert odds == range(len(odds))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A possible solution is to consider that you allow only"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n odd-&gt;odd\nodd-&gt;even\neven-&gt;even\n</code>\n</pre>\n", "senID": 1}, {"text": ["in other words the only forbidden transition is"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n even-&gt;odd\n</code>\n</pre>\n", "senID": 3}, {"text": ["and this translates to"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n (0, 1) not in ((x%2, y%2) for x, y in zip(values, values[1:]))\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n (values[0] % 2) and (len(list(itertools.groupby(values, lambda x: x%2))) == 2)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Rather than collecting the indices, you can just calculate the transition point based on the assumption that all the odd values are at the start; and then check that there are no more odd values after that transition point."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Case where the assertion is true:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n values = [1, 3, 5, 7, 5, 3, 5, 3, 5, 7, 4, 6, 8, 4, 2, 2, 8, 6]\nodd_count = len([x for x in values if (x % 2)])\nassert (not any(x for x in values[odd_count:] if (x % 2) != 0))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Case where the assertion is false:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n values = [1, 3, 5, 7, 5, 3, 5, 3, 44, 5, 7, 4, 6, 8, 4, 2, 2, 8, 6]\nodd_count = len([x for x in values if (x % 2)])\nassert (not any(x for x in values[odd_count:] if (x % 2) != 0))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAssertionError\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Another option is to sort values by parity and see if anything changed:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "values", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n assert sorted(values, key=lambda x: x % 2, reverse=True) == values\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n assert zip(*itertools.groupby(x%2 for x in values))[0] == (1, 0)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Or an easier to understand two-liner:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n odds_and_evens = [x%2 for x in values]\nassert odds_and_evens.index(0) == odds_and_evens.count(1)\n</code>\n</pre>\n", "senID": 2}, {"text": ["If values is valid then odds_and_evens will be some number of 1 followed by only 0, so it is valid if the first 0 comes after every 1."], "childNum": 6, "tag": "p", "senID": 3, "childList": [{"text": "values", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "odds_and_evens", "childNum": 0, "tag": "code", "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "childList": []}, {"text": "0", "childNum": 0, "tag": "code", "childList": []}, {"text": "1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Both of these methods assume you need to have at least one odd followed by at least one even, which I don't think the OP has clarified."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If empty lists, all odd, or all even should be considered valid the following method works:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n odds_and_evens = [x%2 for x in values]\nassert odds_and_evens == sorted(odds_and_evens, reverse=True)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["I think filter reads better than list comprehensions here, e.g., "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "filter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n filter(isodd, values) + filter(iseven, values) == values\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Somewhat longer, but this would seem to capture all (even only, odd only, empty) in addition to requirements.", "It only requires one modulo and one compare on the full list.", "Not nearly as succinct (or clever) as Andrew's sorted answer, but faster(?", ") for long lists."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n values= [1, 3, 5, 7, 5, 3, 5, 3, 5, 7, 2, 4, 6, 8, 10]\nevenOdd = [x%2 for x in values]\n\ntry:\n    evenLoc=evenOdd.index(0)\n    assert evenLoc != 0\nexcept ValueError:\n    evenLoc=len(evenOdd)\n\ntry:\n    badActor=evenOdd[evenLoc:].index(1)\n    assert False \nexcept ValueError:\n    pass\n</code>\n</pre>\n", "senID": 1}]]