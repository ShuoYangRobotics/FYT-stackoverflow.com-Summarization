[[{"text": ["According to the Python documentation subprocess.call() waits for the command to complete.", "You should directly use the subprocess.Popen objects which will give you the flexibility you need."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "subprocess.call()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "subprocess.Popen", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You need to use &amp; to execute them asynchronously.", "Here is an example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n subprocess.call(\"./foo1&amp;\", shell=True)\n subprocess.call(\"./foo2&amp;\", shell=True)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is just like the ordinary unix shell."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT:  Though there are multiple, much better ways to do this.", "See the other answers for some examples."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Python threads are more appropriate to what you are looking for: http://docs.python.org/library/threading.html or even the multiprocessing module: http://docs.python.org/library/multiprocessing.html#module-multiprocessing."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/library/threading.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/threading.html"}, {"href": "http://docs.python.org/library/multiprocessing.html#module-multiprocessing", "text": "http://docs.python.org/library/multiprocessing.html#module-multiprocessing", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["In python 3.2.x the concurrent futures module makes this sort of things very easy."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["subprocess does not make the processes asynchronous.", "What you are trying to achieve can be done using multithreading or multiprocessing module."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["By saying method1(), you're calling the function and waiting for it to return.", "(It's a function, not a method."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "method1()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you just want to run a bunch of heavy-duty function in parallel and collect their result, you can use joblib:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "joblib", "tag": "a", "pos": 0, "childList": [{"text": "joblib", "tag": "code"}], "childNum": 1, "href": "http://packages.python.org/joblib/"}, {"text": "joblib", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from joblib import Parallel, delayed\n\nfunctions = [fn1, fn2, fn3, fn4]\n\nresults = Parallel(n_jobs=4)(delayed(f)() for f in functions)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["subprocess.call() blocks until the process completes."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "subprocess.call()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["multiprocessing sounds more appropriate for what you are doing."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "multiprocessing", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["for example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from multiprocessing import Process\n\ndef f1():\n    while True:\n        print 'foo'\n\ndef f2():\n    while True:\n        print 'bar'\n\ndef f3():\n    while True:\n        print 'baz'\n\nif __name__ == '__main__':\n    for func in (f1, f2, f3):\n        Process(target=func).start()\n</code>\n</pre>\n", "senID": 3}]]