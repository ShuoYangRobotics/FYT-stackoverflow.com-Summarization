[[{"text": ["Why should functions return values of a consistent type?", "To meet the following two rules."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Rule 1 -- a function has a \"type\" -- inputs mapped to outputs.", "It must return a consistent type of result, or it isn't a function.", "It's a mess."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Mathematically, we say some function, F, is a mapping from domain, D, to range, R.  F: D -&gt; R.  The domain and range form the \"type\" of the function.", "The input types and the result type are as essential to the definition of the function as is the name or the body."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "F: D -&gt; R", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Rule 2 -- when you have a \"problem\" or can't return a proper result, raise an exception."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def x(foo):\n    if 'bar' in foo:\n        return (foo, 'bar')\n     raise Exception( \"oh, dear me.\" )\n</code>\n</pre>\n", "senID": 4}, {"text": ["You can break the above rules, but the cost of long-term maintainability and comprehensibility is astronomical."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "can", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["\"Wouldn't it be cheaper memory wise to return a None?", "\"  Wrong question."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["The point is not to optimize memory at the cost of clear, readable, obvious code."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["It's not so clear that a function must always return objects of a limited type, or that returning None is wrong.", "For instance, re.search can return a _sre.SRE_Match object or a NoneType object:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "_sre.SRE_Match", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "NoneType", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import re\nmatch=re.search('a','a')\n\ntype(match)\n# &lt;type '_sre.SRE_Match'&gt;\n\nmatch=re.search('a','b')\n\ntype(match)\n# &lt;type 'NoneType'&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Designed this way, you can test for a match with the idiom"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if match:\n    # do xyz\n</code>\n</pre>\n", "senID": 3}, {"text": ["If the developers had required re.search to return a _sre.SRE_Match object, then\nthe idiom would have to change to"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "_sre.SRE_Match", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if match.group(1) is None:\n    # do xyz\n</code>\n</pre>\n", "senID": 5}, {"text": ["There would not be any major gain by requiring re.search to always return a _sre.SRE_Match object."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "_sre.SRE_Match", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So I think how you design the function must depend on the situation and in particular, how you plan to use the function."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Also note that both _sre.SRE_Match and NoneType are instances of object, so in a broad sense they are of the same type.", "So the rule that \"functions should always return only one type\" is rather meaningless."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "_sre.SRE_Match", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "NoneType", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Having said that, there is a beautiful simplicity to functions that return objects which all share the same properties.", "(Duck typing, not static typing, is the python way!", ")  It can allow you to chain together functions: foo(bar(baz))) and know with certainty the type of object you'll receive at the other end."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["This can help you check the correctness of your code.", "By requiring that a function returns only objects of a certain limited type, there are fewer cases to check.", "\"foo always returns an integer, so as long as an integer is expected everywhere I use foo, I'm golden...\""], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["Best practice in what a function should return varies greatly from language to language, and even between different Python projects."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For Python in general, I agree with the premise that returning None is bad if your function generally returns an iterable, because iterating without testing becomes impossible.", "Just return an empty iterable in this case, it will still test False if you use Python's standard truth testing:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n ret_val = x()\nif ret_val:\n     do_stuff(ret_val)\n</code>\n</pre>\n", "senID": 2}, {"text": ["and still allow you to iterate over it without testing:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for child in x():\n    do_other_stuff(child)\n</code>\n</pre>\n", "senID": 4}, {"text": ["For functions that are likely to return a single value, I think returning None is perfectly acceptable, just document that this might happen in your docstring."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I personally think it is perfectly fine for a function to return a tuple or None.", "However, a function should return at most 2 different types and the second one should be a None.", "A function should never return a string and list for example."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If x is called like this"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n foo, bar = x(foo)\n</code>\n</pre>\n", "senID": 1}, {"text": ["returning None would result in a"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "None", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n TypeError: 'NoneType' object is not iterable\n</code>\n</pre>\n", "senID": 3}, {"text": ["if 'bar' is not in foo."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "'bar'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Example"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Example", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def x(foo):\n    if 'bar' in foo:\n        return (foo, 'bar')\n    return None\n\nfoo, bar = x([\"foo\", \"bar\", \"baz\"])\nprint foo, bar\n\nfoo, bar = x([\"foo\", \"NOT THERE\", \"baz\"])\nprint foo, bar\n</code>\n</pre>\n", "senID": 6}, {"text": ["This results in:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n ['foo', 'bar', 'baz'] bar\nTraceback (most recent call last):\n  File \"f.py\", line 9, in &lt;module&gt;\n    foo, bar = x([\"foo\", \"NOT THERE\", \"baz\"])\nTypeError: 'NoneType' object is not iterable\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Premature optimization is the root of all evil.", "The minuscule efficiency gains might be important, but not until you've proven that you need them. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Whatever your language: a function is defined once, but tends to be used at any number of places.", "Having a consistent return type (not to mention documented pre- and postconditions) means you have to spend more effort defining the function, but you simplify the usage of the function enormously.", "Guess whether the one-time costs tend to outweigh the repeated savings...?"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "defining", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "usage", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}]]