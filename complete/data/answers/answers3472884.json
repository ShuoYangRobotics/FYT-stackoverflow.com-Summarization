[[{"text": ["Here's a way to read fixed width fields using regexp"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; s=\"Techy Inn Val NJ\"\n&gt;&gt;&gt; var1,var2,var3,var4 = re.match(\"(.{5}) (.{3}) (.{3}) (.{2})\",s).groups()\n&gt;&gt;&gt; var1\n'Techy'\n&gt;&gt;&gt; var2\n'Inn'\n&gt;&gt;&gt; var3\n'Val'\n&gt;&gt;&gt; var4\n'NJ'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Off the top of my head:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f = open(.......)\nheader = f.next() # get first line\nposns = [i for i, c in enumerate(header + \"#\") if c = '#']\nfor line in f:\n    fields = [line[posns[k]:posns[k+1]] for k in xrange(len(posns) - 1)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Update with tested, fixed code:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import sys\nf = open(sys.argv[1])\nheader = f.next() # get first line\nprint repr(header)\nposns = [i for i, c in enumerate(header) if c == '#'] + [-1]\nprint posns\nfor line in f:\n    posns[-1] = len(line)\n    fields = [line[posns[k]:posns[k+1]].rstrip() for k in xrange(len(posns) - 1)]\n    print fields\n</code>\n</pre>\n", "senID": 3}, {"text": ["Input file:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n #      #  #\nFoo    BarBaz\n123456789abcd\n</code>\n</pre>\n", "senID": 5}, {"text": ["Debug output:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n '#      #  #\\n'\n[0, 7, 10, -1]\n['Foo', 'Bar', 'Baz']\n['1234567', '89a', 'bcd']\n</code>\n</pre>\n", "senID": 7}, {"text": ["Robustification notes: "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Final(?", ") update: Leapfrooging @gnibbler's suggestion to use slice(): set up the slices once before looping."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "Final(?) update:", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "slice()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import sys\nf = open(sys.argv[1])\nheader = f.next() # get first line\nprint repr(header)\nposns = [i for i, c in enumerate(header) if c == '#']\nprint posns\nslices = [slice(lo, hi) for lo, hi in zip(posns, posns[1:] + [None])]\nprint slices\nfor line in f:\n    fields = [line[sl].rstrip() for sl in slices]\n    print fields\n</code>\n</pre>\n", "senID": 10}], [{"text": ["Adapted from John Machin's answer"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; header = \"#     #   #   #\"\n&gt;&gt;&gt; row = \"Techy Inn Val NJ\"\n&gt;&gt;&gt; posns = [i for i, c in enumerate(header) if c == '#']\n&gt;&gt;&gt; [row[slice(*x)] for x in zip(posns, posns[1:]+[None])]\n['Techy ', 'Inn ', 'Val ', 'NJ']\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can also write the last line like this"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [row[i:j] for i,j in zip(posns, posns[1:]+[None])]\n</code>\n</pre>\n", "senID": 3}, {"text": ["For the other example you give in the comments, you just need to have the correct header"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; header = \"#       #     #     #\"\n&gt;&gt;&gt; row    = \"Techiyi Iniin Viial NiiJ\"\n&gt;&gt;&gt; posns = [i for i, c in enumerate(header) if c == '#']\n&gt;&gt;&gt; [row[slice(*x)] for x in zip(posns, posns[1:]+[None])]\n['Techiyi ', 'Iniin ', 'Viial ', 'NiiJ']\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Ok, to be little different and to give the asked in comments generalized solution, I use the header line instead of slice and generator function.", "Additionally I have allowed first columns to be comment by not putting field name in first column and using of multichar field names instead of only '#'."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Minus point is that one char fields are not possible to have header names but only have '#' in header line (which are allways considered like in previous solutions as beginning of field, even after letters in header)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n sample=\"\"\"\n            HOTEL     CAT ST DEP ##\nTest line   Techy Inn Val NJ FT  FT\n\"\"\"\ndata=sample.splitlines()[1:]\n\ndef fields(header,line):\n    previndex=0\n    prevchar=''\n    for index,char in enumerate(header):\n        if char == '#' or (prevchar != char and prevchar == ' '):\n            if previndex or header[0] != ' ':\n                yield line[previndex:index]\n            previndex=index\n        prevchar = char\n    yield line[previndex:]\n\nheader,dataline = data\nprint list(fields(header,dataline))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Output"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n ['Techy Inn ', 'Val ', 'NJ ', 'FT  ', 'F', 'T']\n</code>\n</pre>\n", "senID": 4}, {"text": ["One practical use of this is to use in parsing fixed field length data without knowing the lengths by just putting copy of dataline with all fields and no comment present and spaces replaced with something else like '_' and single character field values replaced by #."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Header from sample line:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n '            Techy_Inn Val NJ FT  ##'\n</code>\n</pre>\n", "senID": 7}], [{"code": "<pre>\n<code>\n def parse(your_file):\n    first_line = your_file.next().rstrip()\n    slices = []\n    start = None\n    for e, c in enumerate(first_line):\n        if c != '#':\n            continue\n\n        if start is None:\n            start = e\n            continue\n        slices.append(slice(start, e))\n        start = e\n    if start is not None:\n        slices.append(slice(start, None))\n\n    for line in your_file:\n        parsed = [line[s] for s in slices]\n        yield parsed\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n f = open('sample.txt', 'r')\npos = [m.span() for m in re.finditer('#\\s*', f.next())]\npos[-1] = (pos[-1][0], None)\nfor line in f:\n   print [line[i:j].strip() for i, j in pos]\nf.close()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This works well if the delimiter line indicates the fixed width fields."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n delim = '#     #   #   # '\n\n#parse delimiter line\nslices = (slice(*m.span()) for m in re.finditer(r'# *', delim))\n\nline = 'Techy Inn Val NJ'\n\n#read fields\nfields = [line[s] for s in slices]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n with open('somefile','r') as source:\n    line= source.next()\n    sizes= map( len, line.split(\"#\") )[1:]\n    positions = [ (sum(sizes[:x]),sum(sizes[:x+1])) for x in xrange(len(sizes)) ] \n    for line in source:\n        fields = [ line[start,end] for start,end in positions ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Is this what you're looking for?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]