[[{"text": ["If one variable is not \"defined\", you can't access its name.", "So any reference to 'a' raises a NameError Exception."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In the other hand, if you have something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a = None\nb = None\nc = 3\n</code>\n</pre>\n", "senID": 2}, {"text": ["you can do"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n default = 1\nr = a or b or c or default\n# r value is 3\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Did you mean returning first value for what bool(value)==True?", "Then you can just rely on the fact that boolean operators return last evaluated argument:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "bool(value)==True", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "boolean operators return last evaluated argument", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/expressions.html#boolean-operations"}]}, {"code": "<pre>\n<code>\n result = a or b or c or default\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could do something like this (in contrast to the other answers this is a solution where you don't have to define the 'missing' values as being either None or False):"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "have", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n b = 6\nc = 8\n\ndef first_defined(items):\n    for x in items:\n        try:\n            return globals()[x]\n            break\n        except KeyError:\n            continue\n\nprint first_defined([\"a\", \"b\", \"c\"])\n</code>\n</pre>\n", "senID": 1}, {"text": ["In order to avoid NameErrors when a, b or c isn't defined: give the function a list of strings instead of variable references (you can't pass non-existing references).", "If you are using variables outside the 'globals()' scope, you could use getattr with its default argument."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["--  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If a, b and c are defined, I'd go for something like this (considering the fact that an empty string, None or False evaluate to a boolean False):"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "False", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a = None\nb = 6\nc = 8\n\ndef firstitem(items):\n    for x in items:\n        if x:\n            return x\n            break\n        else:\n            continue\n\nprint firstitem([a, b, c])\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Don't know if this works in every case, but this works for this case."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = False\nb = \"b\"\nc = False\ndefault = \"default\"\nprint a or b or c or default # b\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about this ?  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a=None  \nb=None  \nc=None  \nval= reduce(lambda x,y:x or y,(a,b,c,\"default\"))  \nprint val\n</code>\n</pre>\n", "senID": 1}, {"text": ["The above prints \"default\".", "If any of the inputs is defined, val would contain the first defined input."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "\"default\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "val", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["So long as default evaluates to True:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "default", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n result = next((x for x in (a, b, c, d , e, default) if x))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If by defined you mean ever assigned any value whatsoever to in any scope accessible from here, then trying to access an \"undefined\" variable will raise a NameError exception (or some subclass thereof, but catching NameError will catch the subclass too).", "So, the simplest way to perform, literally, the absolutely weird task you ask about, is:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "defined", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ever assigned any value whatsoever to in any scope accessible from here", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n for varname in ('a', 'b', 'c'):\n  try: return eval(varname)\n  except NameError: pass\nreturn default\n</code>\n</pre>\n", "senID": 1}, {"text": ["Any alleged solution lacking a try/except won't work under the above meaning for \"defined\".", "Approaches based on exploring specific scopes will either miss other scopes, or be quite complex by trying to replicate the scope-ordering logic that eval does for you so simply."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "eval", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If by \"defined\" you actually mean \"assigned a value that evaluates to true (as opposed to false)\", i.e., all values are actually defined (but might happen to be false, and you want the first true value instead), then the already-proposed a or b or c or default becomes the simplest approach.", "But that's a totally different (and even weirder!", ") meaning for the word \"defined\"!-)"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "defined", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "a or b or c or default", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}]]