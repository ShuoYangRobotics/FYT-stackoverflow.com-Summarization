[[{"text": ["Looks like you're trying to set up some sort of proxy object scheme.", "That's doable, and there are better solutions than your colleague's, but first consider whether it would be easier to just patch in some extra methods.", "This won't work for built-in classes like bool, but it will for your user-defined classes:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "bool", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n def HTMLDecorator (obj):\n    def html ():\n        sep = cgi.escape (repr (obj))\n        return sep.join ((\"&lt;H1&gt;\", \"&lt;/H1&gt;\"))\n    obj.html = html\n    return obj\n</code>\n</pre>\n", "senID": 1}, {"text": ["And here is the proxy version:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class HTMLDecorator(object):\n    def __init__ (self, wrapped):\n        self.__wrapped = wrapped\n\n    def html (self):\n        sep = cgi.escape (repr (self.__wrapped))\n        return sep.join ((\"&lt;H1&gt;\", \"&lt;/H1&gt;\"))\n\n    def __getattr__ (self, name):\n        return getattr (self.__wrapped, name)\n\n    def __setattr__ (self, name, value):\n        if not name.startswith ('_HTMLDecorator__'):\n            setattr (self.__wrapped, name, value)\n            return\n        super (HTMLDecorator, self).__setattr__ (name, value)\n\n    def __delattr__ (self, name):\n        delattr (self.__wraped, name)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Both of John's solutions would work.", "Another option that allows HTMLDecorator to remain very simple and clean is to monkey-patch it in as a base class.", "This also works only for user-defined classes, not builtin types:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import cgi\n\nclass ClassX(object):\n    pass # ... with own __repr__\n\nclass ClassY(object):\n    pass # ... with own __repr__\n\ninst_x=ClassX()\ninst_y=ClassY()\n\nclass HTMLDecorator:\n    def html(self): # an \"enhanced\" version of __repr__\n        return cgi.escape(self.__repr__()).join((\"&lt;H1&gt;\",\"&lt;/H1&gt;\"))\n\nClassX.__bases__ += (HTMLDecorator,)\nClassY.__bases__ += (HTMLDecorator,)\n\nprint inst_x.html()\nprint inst_y.html()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Be warned, though -- monkey-patching like this comes with a high price in readability and maintainability of your code.", "When you go back to this code a year later, it can become very difficult to figure out how your ClassX got that html() method, especially if ClassX is defined in some other library."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It's certainly possible.", "What's wrong is that HTMLDecorator.__init__() doesn't accept parameters."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "HTMLDecorator.__init__()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Here's a simple example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def decorator (func):\n    def new_func ():\n        return \"new_func %s\" % func ()\n    return new_func\n\n@decorator\ndef a ():\n    return \"a\"\n\ndef b ():\n    return \"b\"\n\nprint a() # new_func a\nprint decorator (b)() # new_func b\n</code>\n</pre>\n", "senID": 2}], [{"text": ["@John (37448):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Sorry, I might have misled you with the name (bad choice).", "I'm not really looking for a decorator function, or anything to do with decorators at all.", "What I'm after is for the html(self) def to use ClassX or ClassY's __repr__.", "I want this to work without modifying ClassX or ClassY."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__repr__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["Ah, in that case, perhaps code like this will be useful?", "It doesn't really have anything to do with decorators, but demonstrates how to pass arguments to a class's initialization function and to retrieve those arguments for later."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import cgi\n\nclass ClassX(object):\n    def __repr__ (self):\n        return \"&lt;class X&gt;\"\n\nclass HTMLDecorator(object):\n    def __init__ (self, wrapped):\n        self.__wrapped = wrapped\n\n    def html (self):\n        sep = cgi.escape (repr (self.__wrapped))\n        return sep.join ((\"&lt;H1&gt;\", \"&lt;/H1&gt;\"))\n\ninst_x=ClassX()\ninst_b=True\n\nprint HTMLDecorator(inst_x).html()\nprint HTMLDecorator(inst_b).html()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["@John (37479):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Very close, but then I lose everything from ClassX.", "Below is something a collegue gave me that does do the trick, but it's hideous.", "There has to be a better way."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import cgi\nfrom math import sqrt\n\nclass ClassX(object): \n  def __repr__(self): \n    return \"Best Guess\"\n\nclass ClassY(object):\n  pass # ... with own __repr__\n\ninst_x=ClassX()\n\ninst_y=ClassY()\n\ninst_z=[ i*i for i in range(25) ]\n\ninst_b=True\n\navoid=\"__class__ __init__ __dict__ __weakref__\"\n\nclass HTMLDecorator(object):\n    def __init__(self,master):\n        self.master = master\n        for attr in dir(self.master):\n            if ( not attr.startswith(\"__\") or \n                attr not in avoid.split() and \"attr\" not in attr):\n                self.__setattr__(attr, self.master.__getattribute__(attr))\n\n    def html(self): # an \"enhanced\" version of __repr__\n        return cgi.escape(self.__repr__()).join((\"&lt;H1&gt;\",\"&lt;/H1&gt;\"))\n\n    def length(self):\n        return sqrt(sum(self.__iter__()))\n\nprint HTMLDecorator(inst_x).html()\nprint HTMLDecorator(inst_y).html()\nwrapped_z = HTMLDecorator(inst_z)\nprint wrapped_z.length()\ninst_z[0] += 70\n#wrapped_z[0] += 71\nwrapped_z.__setitem__(0,wrapped_z.__getitem__(0)+ 71)\nprint wrapped_z.html()\nprint HTMLDecorator(inst_b).html()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n&lt;H1&gt;Best Guess&lt;/H1&gt;\n&lt;H1&gt;&lt;__main__.ClassY object at 0x891df0c&gt;&lt;/H1&gt;\n70.0\n&lt;H1&gt;[141, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576]&lt;/H1&gt;\n&lt;H1&gt;True&lt;/H1&gt;\n</pre>\n", "senID": 4}]]