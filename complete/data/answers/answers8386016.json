[[{"text": ["I really wouldn't bother trying to do this kind of artificial sandboxing because "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n 1024 ** 1024 ** 1024\n</code>\n</pre>\n", "senID": 1}, {"text": ["Will still chew up your interpreter."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["or even this"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n eval(\"__vzcbeg__('gvzr').nfpgvzr()\")\n</code>\n</pre>\n", "senID": 4}, {"text": ["If you want some security look into pypy's sandbox its about the most secure way to run untrusted python code.", "There are a few python only modules like pysandbox but I personally suggest the pypy sandbox."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "sandbox", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://codespeak.net/pypy/dist/pypy/doc/sandbox.html"}, {"text": "pysandbox", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/pysandbox/"}]}], [{"text": ["You can't do this just by static analysis of the code, since it can always do tricky things, e.g."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; getattr(__builtins__, \"__\" + chr(105) + \"mport__\")(\"sys\")\n&lt;module 'sys' (built-in)&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["As you can see, looking at the disassembly, code or ast won't help, as nowhere does it even contain the string \"import\":"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import dis\n&gt;&gt;&gt; dis.dis(lambda: getattr(__builtins__, \"__\" + chr(105) + \"mport__\")(\"sys\"))\n  1           0 LOAD_GLOBAL              0 (getattr)\n              3 LOAD_GLOBAL              1 (__builtins__)\n              6 LOAD_CONST               1 ('__')\n              9 LOAD_GLOBAL              2 (chr)\n             12 LOAD_CONST               2 (105)\n             15 CALL_FUNCTION            1\n             18 BINARY_ADD\n             19 LOAD_CONST               3 ('mport__')\n             22 BINARY_ADD\n             23 CALL_FUNCTION            2\n             26 LOAD_CONST               4 ('sys')\n             29 CALL_FUNCTION            1\n             32 RETURN_VALUE\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I don't think you can detect that sort of thing reliably at all.", "Consider the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; f = None\n&gt;&gt;&gt; b = vars()[[f for f in vars() if 'ti' in f][0]]\n&gt;&gt;&gt; m = getattr(b, [f for f in dir(b) if 't_' in f][0])\n&gt;&gt;&gt; m('x\\x9c+\\xae,\\x06\\x00\\x02\\xc1\\x01`'.decode('zip'))\n&lt;module 'sys' (built-in)&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You may use the ast python module to analyze Python code.", "See my answer to a very similar question here:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ast", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["http://stackoverflow.com/a/8255293/589206"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://stackoverflow.com/a/8255293/589206", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/a/8255293/589206"}]}, {"text": ["Here's a solution for your import statement problem:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import ast\nimport sys\n\nclass FunctionNameFinder(ast.NodeVisitor):\n        def visit_Import(self, node):\n                print \"Importing on line\", node.lineno, \":\",\n                for i in node.names: print i.name,\n                print\n\nwith open(sys.argv[1], 'rU') as f:\n        FunctionNameFinder().visit(ast.parse(\"\".join(f.readlines())))\n</code>\n</pre>\n", "senID": 3}, {"text": ["Of course, this won't help in cases where a malicious user is putting a lot of effort into obfuscating his code, but then, the only way to go is use a real sandbox.", "But that wasn't your question in the first place."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Unfortunately there is no right way to answer this.", "There is only one assured way to ensure that you can remain of any mis-happening.", "You can try to run inside VirtualBox.", "There are linux virtualbox images that you can download and bring up your VM.", "Based on your n/w speed (unless you are still using the dial up network), it will take couple of hours to download, bring up your VM and test your script."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "VirtualBox", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://virtualboxes.org/"}, {"text": "linux virtualbox images", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://virtualboxes.org/images/"}]}], [{"text": ["What you are trying to do is a common scenario: You are already doing dynamic analysis of code by running in a sandbox.", "On top of you'd like to have static analysis as well using another tool read the program for you. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Both approaches have their own shortcomings and due to the nature of the computation, none of them can guarantee to provide you with all kinds of potential scenarios going wrong; however still the combination of two provides you a lot of useful information at a higher confidence level."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In other popular languages, for example C/C++, there are robust tools (e.g.", "Lint) which can analyze the code deeply and report a lot of potential problems including those related to security."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Unfortunately Python doesn't have tools having robustness level that high.", "Having said that, you can still do a lot.", "I think your best choice would to be to use PyLint. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["PyLint comes with some standard rules for the code analysis but you can override those to customize your own code smells."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["For instance, if you simply would like to see the kind of modules being used, you can use the imports checker.", "For handling more complex scenarios, you can customize and extend the functionality.", "Take a look at their documentation for enhancing PyLint."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "imports checker", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.logilab.org/card/pylintfeatures#imports-checker"}, {"text": "documentation for enhancing PyLint", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.logilab.org/card/pylint_manual#enhancing-pylint"}]}, {"text": ["Take a look at the tutorial to get started:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "tutorial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.logilab.org/card/pylint_tutorial"}]}], [{"text": ["While true sand boxing is indeed very difficult, if it is the import statement you try to catch, consider this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "import", "childNum": 0, "tag": "i", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; org_imp = __builtins__.__import__\n&gt;&gt;&gt; def imp_hook(*args, **kw):\n    if args[0] == 'sys':\n        print 'Gotcha!!'\n        return None\n    return org_imp\n\n&gt;&gt;&gt; __builtins__.__import__ = imp_hook\n&gt;&gt;&gt; import sys\nGotcha!!\n&gt;&gt;&gt; sys\n&gt;&gt;&gt; print sys\nNone\n</code>\n</pre>\n", "senID": 1}, {"text": ["This work's regardless of the complexity of the import statement itself."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note: Don't just print &amp; return None, throw meaningful exceptions, but you get the idea!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]