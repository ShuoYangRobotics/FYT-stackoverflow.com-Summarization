[[{"code": "<pre>\n<code>\n min(itertools.izip(Lat, Lon), key=operator.itemgetter(1))[0]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Rather than jumping right in with one of the many alternatives for solving this (which can be seen in the other answers), it's worth enumerating why the code in the original example is so slow."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "why", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n SE_Lat = [Lat[x] for x,y in enumerate(Lon) if y == min(Lon)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["We know from the OP that len(Lon) == 420481.", "Now, finding the minimum value is an O(N) operation (you have to look at every value at least once).", "In a list comprehension, the condition is reevaluated on every iteration.", "The above code recalculates the minimum value on every pass through the loop, blowing what should be an O(N) operation out to be O(N^2) (A mere 177 billion iterations in this case)."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "len(Lon) == 420481", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "every iteration", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "billion", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"text": ["Simply caching the result of min(Lon) in a local variable and using that in the loop condition instead of recalculating it every iteration would likely bring the runtime down to an acceptable level."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "min(Lon)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["However, the way I would personally go about it (assuming I wanted all of the latitude, longitude and index later on):"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n min_longitude, min_index = min(longitude, index for index, longitude in enumerate(Lon))\nmin_latitude = Lat[min_index]\n</code>\n</pre>\n", "senID": 5}, {"text": ["There are plenty of possibilities though, and which one is best will vary based on the exact use case."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["May I recommend numpy?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy\nnplats = numpy.array(lats)\nnplons = numpy.array(lons)\n\n# this part is 20x faster than using the built-in python functions\nindex = numpy.argmin(nplats)\n\nprint nplats[index], nplons[index]\n</code>\n</pre>\n", "senID": 1}, {"text": ["this is way faster than the min(izip()) solution (~20x using my setup when using 420481 randomly created records), although of course you'd need to store your data values in numpy to take advantage of this speed-up."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n pairs = zip(latitudes, longitudes)\nminLonPair = min(pairs, key=lambda p:p[1])\nprint(minLonPair[0])\n</code>\n</pre>\n", "senID": 0}, {"text": ["As per Ignacio's solution, if you are using python2, you will want to use izip rather than zip.", "This is, however, true for everything you do in python2."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "izip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "zip", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Here was my original answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; lats = [1,2,3,4]\n&gt;&gt;&gt; lons = [5,4,8,9]\n&gt;&gt;&gt; from itertools import izip\n&gt;&gt;&gt; min(izip(lats,lons), key=lambda x:x[1])\n(2, 4)\n</code>\n</pre>\n", "senID": 1}, {"text": ["But I see that the OP seemed to be allowing for there being multiple matches at the minimum lon value, and for this, I don't think there is a one-liner.", "The trick is, you only want to find min(lons) once, not once for every lat,lon pair:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; lats = [1,2,3,4]\n&gt;&gt;&gt; lons = [5,4,8,4]\n&gt;&gt;&gt; minlon = min(lons)\n&gt;&gt;&gt; [(lat,lon) for lat,lon in izip(lats,lons) if lon==minlon]\n[(2, 4), (4, 4)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["This one-liner might work for you, since the lambda argument minlon should only be computed once:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; filter(lambda latlon,minlon=min(lons):latlon[1]==minlon, izip(lats,lons))\n[(2, 4), (4, 4)]\n</code>\n</pre>\n", "senID": 5}, {"text": ["Not sure how well it will work on 420481-element lists though.", "And for readability and long-term support, I would probably choose the more explicit 2-liner solution."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Last point:\nSometimes you only get one pass through a sequence, such as when it is an iterator, or the output of a generator.", "To support multiple matches and take only one pass through the two lists, this was the best I could do:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip\n\ndef get_lats_at_min_lon(lats, lons):\n    minlon = 200\n    minlats = []\n    for lat,lon in izip(lats, lons):\n        if lon &lt; minlon:\n            minlats = [lat]\n            minlon = lon\n        elif lon == minlon:\n            minlats.append(lat)\n    return minlon, minlats\n\nlats = iter([1,2,3,4])\nlons = iter([5,4,8,4])\n\nprint get_lats_at_min_lon(lats,lons)\n</code>\n</pre>\n", "senID": 8}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n (4, [2, 4])\n</code>\n</pre>\n", "senID": 10}], [{"text": ["Just first find the index:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n index = min(enumerate(Lon), key=operator.itemgetter(1))[1] \nLat[index]\n</code>\n</pre>\n", "senID": 1}]]