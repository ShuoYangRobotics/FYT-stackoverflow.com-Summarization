[[{"text": ["If you organized the necessary list as a trie, then you could look in that trie to check if the fruit starts with a valid prefix.", "That should be faster than comparing the fruit against every prefix."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "necessary", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "trie", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Trie"}, {"text": "fruit", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "fruit", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For example (only mildly tested):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import bisect\nimport re\n\nclass Node(object):\n    def __init__(self):\n        self.children = []\n        self.children_values = []\n        self.exists = False\n\n    # Based on code at http://docs.python.org/library/bisect.html                \n    def _index_of(self, ch):\n        i = bisect.bisect_left(self.children_values, ch)\n        if i != len(self.children_values) and self.children_values[i] == ch:\n            return (i, self.children[i])\n        return (i, None)\n\n    def add(self, value):\n        if len(value) == 0:\n            self.exists = True\n            return\n        i, child = self._index_of(value[0])\n        if not child:\n            child = Node()\n            self.children.insert(i, child)\n            self.children_values.insert(i, value[0])\n        child.add(value[1:])\n\n    def contains_prefix_of(self, value):\n        if self.exists:\n            return True\n        i, child = self._index_of(value[0])\n        if not child:\n            return False\n        return child.contains_prefix_of(value[1:])\n\nnecessary = ['RED', 'GREEN', 'BLUE', 'ORANGE', 'BLACK',\n             'LIGHTRED', 'LIGHTGREEN', 'GRAY']\n\ntrie = Node()\nfor value in necessary:\n    trie.add(value)\n\n# Find lines that match values in the trie\nfiltered = []\nregexp = re.compile(r'fruit=([A-Z]+)')\nfor line in open('whatever-file'):\n    fruit = regexp.findall(line)[0]\n    if trie.contains_prefix_of(fruit):\n        filtered.append(line)\n</code>\n</pre>\n", "senID": 2}, {"text": ["This changes your algorithm from O(N * k), where N is the number of elements of necessary and k is the length of fruit, to just O(k) (more or less).", "It does take more memory though, but that might be a worthwhile trade-off for your case."], "childNum": 6, "tag": "p", "senID": 3, "childList": [{"text": "O(N * k)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "necessary", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "k", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "fruit", "childNum": 0, "tag": "code", "childList": []}, {"text": "O(k)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Tested (but unbenchmarked) code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nimport fileinput\n\nregexp = re.compile(r'^.*?fruit=([A-Z]+)')\nnecessary = ['YELLOW', 'GREEN', 'RED', ]\n\nfiltered = []\nfor line in fileinput.input([\"test.txt\"]):\n    try:\n        key = regexp.match(line).group(1)\n    except AttributeError:\n        continue # no match\n    for p in necessary:\n        if key.startswith(p):\n            filtered.append(line)\n            break\n\n# \"filtered\" now holds your results\nprint \"\".join(filtered)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Diff to code in question:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If the format of the input file is consistent, you can squeeze out a little more performance by getting rid of regex altogether."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n try:\n    # with line = \"2 asdasd fruit=SOMETHING asdasd....\"\n    key = line.split(\" \", 3)[2].split(\"=\")[1]\nexcept:\n    continue # no match\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I'd make a simple list of ['fruit=RED','fruit=GREEN'... etc.", "with ['fruit='+n for n in necessary], then use in rather than a regex to test them.", "I don't think there's any way to do it really quickly, though."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "['fruit=RED','fruit=GREEN'...", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "['fruit='+n for n in necessary]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "in", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n filtered = (line for line in f if any(a in line for a in necessary_simple))\n</code>\n</pre>\n", "senID": 1}, {"text": ["(The any() function is doing the same thing as your any_it() function)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Oh, and get rid of file.readlines(), just iterate over the file."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n filtered=[]\nfor line in open('huge_file'):\n    found=regexp.findall(line)\n    if found:\n        fruit=found[0]\n        for x in necessary:\n            if fruit.startswith(x):\n                filtered.append(line)\n                break\n</code>\n</pre>\n", "senID": 0}, {"text": ["or maybe : "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n necessary=['fruit=%s'%x for x in necessary]\nfiltered=[]\nfor line in open('huge_file'):\n    for x in necessary:\n        if x in line:\n            filtered.append(line)\n            break\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I personally like your code as is since you consider \"fruit=COLOR\" as a pattern which others does not.", "I think you want to find some solution like memoization which enables you to skip test for already solved problem but this is not the case I guess."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["def any_it(iterable):\n      for element in iterable:\n          if element: return True\n      return False"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["necessary = ['YELLOW', 'GREEN', 'RED', ...]"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["predicate = lambda line: any_it(\"fruit=\" + color in line for color in necessary)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["filtered = ifilter(predicate, open(\"testest\"))"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I'm convinced Zach's answer is on the right track.", "Out of curiosity, I've implemented another version (incorporating Zach's comments about using a dict instead of bisect) and folded it into a solution that matches your example."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Zach's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4397859/smart-filter-with-python/4398588#4398588"}, {"text": "bisect", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nimport re\nfrom trieMatch import PrefixMatch # https://gist.github.com/736416\n\npm = PrefixMatch(['YELLOW', 'GREEN', 'RED', ]) # huge list of 10 000 members\n# if list is static, it might be worth picking \"pm\" to avoid rebuilding each time\n\nf = open(\"huge_file.txt\", \"r\") ## file with &gt; 100 000 lines\nlines = f.readlines()\nf.close()\n\nregexp = re.compile(r'^.*?fruit=([A-Z]+)')\nfiltered = (line for line in lines if pm.match(regexp.match(line).group(1)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["For brevity, implementation of PrefixMatch is published here."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "PrefixMatch", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "https://gist.github.com/736416", "text": "published here", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["If your list of necessary prefixes is static or changes infrequently, you can speed up subsequent runs by pickling and reusing the PickleMatch object instead of rebuilding it each time. "], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "necessary", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "PickleMatch", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["According to the changelog for Python 2.4:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "changelog for Python 2.4", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/release/2.4/whatsnew/node12.html"}]}, {"text": ["also, in the source code, line 1792:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "the source code, line 1792", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/tags/r243/Objects/listobject.c?revision=43414&view=markup"}]}, {"code": "<pre>\n<code>\n /* Special wrapper to support stable sorting using the decorate-sort-undecorate\n   pattern.  Holds a key which is used for comparisons and the original record\n   which is returned during the undecorate phase.  By exposing only the key\n   .... */\n</code>\n</pre>\n", "senID": 6}, {"text": ["This means that your regex pattern is only evaluated once for each entry (not once for each compare), hence it should not be too expensive to do:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n sorted_generator = sorted(filtered, key=regexp.match(line).group(1))\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Untested code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n filtered = []\nfor line in lines:\n    value = line.split('=', 1)[1].split(' ',1)[0]\n    if value not in necessary:\n        filtered.append(line)\n</code>\n</pre>\n", "senID": 1}, {"text": ["That should be faster than pattern matching 10 000 patterns onto a line.", "Possibly there are even faster ways.", ":)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It shouldn't take too long to iterate through 100,000 strings, but I see you have a 10,000 strings list, which means you iterate 10,000 * 100,000 = 1,000,000,000 times the strings, so I don't know what did you expect...\nAs for your question, if you encounter a word from the list and you only need 1 or more (if you want exacly 1 you need to iterate through the whole list) you can skip the rest, it should optimize the search operation."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "can", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}]]