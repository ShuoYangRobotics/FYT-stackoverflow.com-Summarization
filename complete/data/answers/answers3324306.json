[[{"text": ["This is old solution, completely new 6 bajillion times faster solution is on the bottom."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "This is old solution", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/3324306/puzzle-that-defies-the-brute-force-approach/3328629#3328629", "text": "is on the bottom", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Solution:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n time { python solution.py; } \n0: 0\n1: 199990\n2: 1999919999999980\n3: 19999199999999919999999970\n4: 199991999999999199999999919999999960\n5: 1999919999999991999999999199999999919999999950\n6: 19999199999999919999999991999999999199999999919999999940\n7: 199991999999999199999999919999999991999999999199999999919999999930\n8: 1999919999999991999999999199999999919999999991999999999199999999919999999920\n9: 19999199999999919999999991999999999199999999919999999991999999999199999999919999999918\n\nreal    1m53.493s\nuser    1m53.183s\nsys 0m0.036s\n</code>\n</pre>\n", "senID": 2}, {"text": ["Code:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n OPTIMIZE_1 = True # we assum that '1' will run out first (It's easy to prove anyway)\n\nif OPTIMIZE_1:\n    NUMBERS = [1]\nelse:\n    NUMBERS = range(10)\n\ndef how_many_have(dight, n, stickers):\n    return stickers * n\n\ncache = {}\ndef how_many_used(dight, n):\n    if (dight, n) in cache:\n        return cache[(dight,n)]\n    result = 0\n    if dight == \"0\":\n        if OPTIMIZE_1:\n            return 0\n        else:\n            assert(False)\n            #TODO\n    else:\n        if int(n) &gt;= 10:\n            if n[0] == dight:\n                result += int(n[1:]) + 1\n            result += how_many_used(dight, str(int(n[1:])))\n            result += how_many_used(dight, str(int(str(int(n[0])-1) + \"9\"*(len(n) - 1))))\n        else:\n            result += 1 if n &gt;= dight else 0\n    if n.endswith(\"9\" * (len(n)-4)): # '4' constant was pick out based on preformence tests\n        cache[(dight, n)] = result\n    return result\n\ndef best_jump(i, stickers_left):\n    no_of_dights = len(str(i))\n    return max(1, min(\n        stickers_left / no_of_dights,\n        10 ** no_of_dights - i - 1,\n    ))\n\ndef solve(stickers):\n    i = 0\n    stickers_left = 0\n    while stickers_left &gt;= 0:\n        i += best_jump(i, stickers_left)\n\n        stickers_left = min(map(\n            lambda x: how_many_have(x, i, stickers) - how_many_used(str(x), str(i)),\n            NUMBERS\n        ))\n    return i - 1\n\nfor stickers in range(10):\n    print '%d: %d' % (stickers, solve(stickers))\n</code>\n</pre>\n", "senID": 4}, {"text": ["Prove that '1' will run out first:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def(number, position):\n    \"\"\" when number[position] is const, this function is injection \"\"\"\n    if number[position] &gt; \"1\":\n        return (position, number[:position]+\"1\"+number[position+1:])\n    else:\n        return (position, str(int(number[:position])-1)+\"1\"+number[position+1:])\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Here is proof that a solution exists:  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "proof that a solution exists", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Assuming you ever get to 21 digit numbers, you will start losing a sticker with every DVD you purchase and label ((+20)  +  (-21)).", "It doesn't matter how many stickers you have accumulated until this point.", "From here on it is all downhill for your sticker stash and you  will eventually run out."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "(+20)  +  (-21)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}], [{"text": ["here's a quick and dirty python script:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/bin/env python\n\ndisc = 0\nstickers = {\n    0: 0, 1: 0,\n    2: 0, 3: 0,\n    4: 0, 5: 0,\n    6: 0, 7: 0,\n    8: 0, 9: 0 }\n\ndef buyDisc():\n    global disc\n    disc += 1\n    for k in stickers.keys():\n        stickers[k] += 1\n\ndef labelDisc():\n    lbl = str(disc)\n    for c in lbl:\n        if(stickers[int(c)] &lt;= 0): return False;\n        stickers[int(c)] -= 1;\n    return True\n\nwhile True:\n    buyDisc()\n    if not labelDisc(): break\n\nprint(\"No stickers left after \" + str(disc) + \" discs.\")\nprint(\"Remaining stickers: \" + str(stickers))\n</code>\n</pre>\n", "senID": 1}, {"text": ["i don't know if it yields the correct result though.", "if you find logical errors, please comment"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["result with debug output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n Bought disc 199991. Labels: \nRemaining stickers: {0: 111102, 1: 0, 2: 99992, 3: 99992, 4: 99992, 5: 99997, 6: 99992, 7: 99992, 8: 99992, 9: 100024}\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Completely new solution.", "6 bajillion times faster than first one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n time { python clean.py ; }\n0: 0\n1: 199990\n2: 1999919999999980\n3: 19999199999999919999999970\n4: 199991999999999199999999919999999960\n5: 1999919999999991999999999199999999919999999950\n6: 19999199999999919999999991999999999199999999919999999940\n7: 199991999999999199999999919999999991999999999199999999919999999930\n8: 1999919999999991999999999199999999919999999991999999999199999999919999999920\n9: 19999199999999919999999991999999999199999999919999999991999999999199999999919999999918\n\nreal    0m0.777s\nuser    0m0.772s\nsys 0m0.004s\n</code>\n</pre>\n", "senID": 1}, {"text": ["code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n cache = {}\ndef how_many_used(n):\n    if n in cache:\n        return cache[n]\n    result = 0\n    if int(n) &gt;= 10:\n        if n[0] == '1':\n            result += int(n[1:]) + 1\n        result += how_many_used(str(int(n[1:])))\n        result += how_many_used(str(int(str(int(n[0])-1) + \"9\"*(len(n) - 1))))\n    else:\n        result += 1 if n &gt;= '1' else 0\n    if n.endswith(\"9\" * (len(n)-0)) or n.endswith(\"0\" * (len(n)-1)):\n        cache[n] = result\n    return result\n\ndef how_many_have(i, stickers):\n    return int(i) * stickers\n\ndef end_state(i, stickers):\n    if i == '':\n        return 0\n    return how_many_have(i, stickers) - how_many_used(i)\n\ncache2 = {}\ndef lowest_state(i, stickers):\n    if stickers &lt;= 0:\n        return end_state(i, stickers)\n    if i in ('', '0'):\n        return 0\n    if (i, stickers) in cache2:\n        return cache2[(i, stickers)]\n\n    lowest_candidats = []\n\n    tail9 = '9' * (len(i)-1)\n    if i[0] == '1':\n        tail = str(int('0'+i[1:]))\n        lowest_candidats.append(end_state(str(10**(len(i) - 1)), stickers))\n        lowest_candidats.append(lowest_state(tail, stickers - 1) + end_state(str(10**(len(i) - 1)), stickers))\n    else:\n        tail = str(int(i[0])-1) + tail9\n        series = end_state(tail9, stickers)\n        if series &lt; 0:\n             lowest_candidats.append(lowest_state(str(int('0'+i[1:])), stickers) + end_state(i[0] + '0'*(len(i)-1), stickers))\n        lowest_candidats.append(lowest_state(tail, stickers))\n    result =  min(lowest_candidats)\n    cache2[(i, stickers)] = result\n    return result\n\ndef solve(stickers):\n    i=1\n    while lowest_state(str(i), stickers) &gt;= 0:\n        i *= 2\n\n    top = i\n    bottom = 0\n    center = 0\n\n    while top - bottom &gt; 1:\n        center = (top + bottom) / 2\n        if lowest_state(str(center), stickers) &gt;= 0:\n            bottom = center\n        else:\n            top = center\n\n    if lowest_state(str(top), stickers) &gt;= 0:\n        return top\n    else:\n        return bottom\n\nimport sys\nsys.setrecursionlimit(sys.getrecursionlimit() * 10)\n\nfor i in xrange(10):\n    print \"%d: %d\" % (i, solve(i))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["The results for any base N and number of stickers per digit per DVD \"S\" are:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n N\\S ]      1 |        2 |          3 |         4 |    5 |        S?\n===================================================================\n  2 ]      2 |       14 |         62 |       254 | 1022 |   4^S - 2\n----+--------+----------+------------+-----------+------+----------\n  3 ]     12 |      363 |       9840 |    265719 |     (27^S - 3)/2\n----+--------+----------+------------+-----------+-----------------\n  4 ]     28 |     7672 |    1965558 | 503184885 |\n----+--------+----------+------------+-----------+\n  5 ]    181 |   571865 | 1787099985 |\n----+--------+----------+------------+\n  6 ]    426 | 19968756 |\n----+--------+----------+\n  7 ]   3930 | (\u2265 2^31) |\n----+--------+----------+\n  8 ]   8184 |\n----+--------+\n  9 ] 102780 |\n----+--------+\n 10 ] 199990 |\n----+--------+\n</code>\n</pre>\n", "senID": 1}, {"text": ["I can't see any patterns."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Alternatively, if the sticker starts from 0 instead of 1,"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n N\\S ]       1 |        2 |          3 |         4 |    5 |          S?\n======================================================================\n  2 ]       4 |       20 |         84 |       340 | 1364 | (4^S-1)*4/3\n----+---------+----------+------------+-----------+------+------------\n  3 ]      12 |      363 |       9840 |    265719 |       (27^S - 3)/2\n----+---------+----------+------------+-----------+-------------------\n  4 ]      84 |     7764 |    1965652 | 503184980 |\n----+---------+----------+------------+-----------+\n  5 ]     182 |   571875 | 1787100182 |\n----+---------+----------+------------+\n  6 ]    1728 | 19970496 |\n----+---------+----------+\n  7 ]    3931 | (\u2265 2^31) |\n----+---------+----------+\n  8 ]   49152 |\n----+---------+\n  9 ]  102789 |\n----+---------+\n 10 ] 1600000 |\n----+---------+\n</code>\n</pre>\n", "senID": 4}, {"text": ["Let's assume that it's the \u201c1\u201d sticker running out first \u2014 which is indeed the case for most other computed info. "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "assume", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Suppose we are in base N and there will be S new stickers per digit per DVD."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["At DVD #X, there will be totally X&times;S  \u201c1\u201d stickers, used or not."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["The number of \u201c1\u201d stickers used is just the number of \u201c1\u201d in the digits from 1 to X in base N expansion."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Thus we just need to find the cross-over point of X&times;S and the total \u201c1\u201d digit count."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "N = 2: ", "tag": "none", "senID": 10}, {"text": "N = 3: 1,1,2,4,5,5,6,6,7,9,10,12,15,17,18,20,21,21,22,22,23,25,26,26,27,\u2026", "tag": "none", "senID": 11}, {"text": "N = 10: ", "tag": "none", "senID": 12}]}, {"text": ["there does not seem to be a closed for all these sequences, so a loop proportional X iterations is necessary.", "The digits can be extracted in log X time, so in principle the algorithm can finish in O(X log X) time."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["This is no better than the other algorithm but at least a lot computations can be removed.", "A sample C code:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;stdio.h&gt;\n\nstatic inline int ones_in_digit(int X, int N) {\n    int res = 0;\n    while (X) {\n        if (X % N == 1)\n            ++ res;\n        X /= N;\n    }\n    return res;\n}\n\nint main() {\n    int N, S, X;\n\n    printf(\"Base N?   \");\n    scanf(\"%d\", &amp;N);\n    printf(\"Stickers? \");\n    scanf(\"%d\", &amp;S);\n\n    int count_of_1 = 0;\n    X = 0;\n    do {\n        ++ X;\n        count_of_1 += S - ones_in_digit(X, N);\n        if (X % 10000000 == 0)\n            printf(\"%d -&gt; %d\\n\", X/10000000, count_of_1);\n    } while (count_of_1 &gt;= 0);\n    printf(\"%d\\n\", X-1);\n    return 0;\n}\n</code>\n</pre>\n", "senID": 15}], [{"text": ["Here's some thoughts on the upper bound demonstrated by @Tal Weiss:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@Tal Weiss", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3324306/puzzle-that-defies-the-brute-force-approach/3324796#3324796"}]}, {"text": ["The first 21-digit number is 10^20, at which point we will have at most 20 * 10^20 stickers.", "Each subsequent DVD will then cost us at least 1 net sticker, so we will definitely have run out by 10^20 + 20 * 10^20, which equals 21 * 10^20.", "This is therefore an upper bound on the solution.", "(Not a particularly tight upper bound by any means!", "But one that's easy to establish)."], "childNum": 6, "tag": "p", "senID": 1, "childList": [{"text": "10^20,", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "at most", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "20 * 10^20", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "at least", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "10^20 + 20 * 10^20", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "21 * 10^20", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Generalising the above result to base b: "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 3, "lis": [{"text": "each DVD comes with ", "tag": "none", "senID": 3}, {"text": "the first DVD that costs us 1 net sticker is number ", "tag": "none", "senID": 4}, {"text": "so we will definitely run out by ", "tag": "none", "senID": 5}]}, {"text": ["So for example if we work in base 3, this calculation gives an upper bound of 5103; in base 4, it is 589824.", "These are numbers it is going to be far easier to brute-force / mathematically solve with."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]