[[{"text": ["Try \"glob\":"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import glob\n&gt;&gt;&gt; glob.glob('./[0-9].*')\n['./1.gif', './2.txt']\n&gt;&gt;&gt; glob.glob('*.gif')\n['1.gif', 'card.gif']\n&gt;&gt;&gt; glob.glob('?.gif')\n['1.gif']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["try changing the inner loop to something like this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n results += [each for each in os.listdir(folder) if each.endswith('.c')]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n for _,_,filenames in os.walk(folder):\n    for file in filenames:\n        fileExt=os.path.splitext(file)[-1]\n        if fileExt == '.c':\n            results.append(file)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["KISS"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # KISS\n\nimport os\n\nresults = []\n\nfor folder in gamefolders:\n    for f in os.listdir(folder):\n        if f.endswith('.c'):\n            results.append(f)\n\nprint results\n</code>\n</pre>\n", "senID": 1}], [{"text": ["For another alternative you could use fnmatch"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "fnmatch", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/fnmatch.html"}]}, {"code": "<pre>\n<code>\n import fnmatch\nimport os\n\nresults = []\nfor root, dirs, files in os.walk(path)\n    for _file in files:\n        if fnmatch.fnmatch(_file, '*.c'):\n            results.append(os.path.join(root, _file))\n\nprint results\n</code>\n</pre>\n", "senID": 1}, {"text": ["or with a list comprehension:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for root, dirs, files in os.walk(path)\n    [results.append(os.path.join(root, _file))\\\n        for _file in files if \\\n            fnmatch.fnmatch(_file, '*.c')]\n</code>\n</pre>\n", "senID": 3}, {"text": ["or using filter:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n for root, dirs, files in os.walk(path):\n    [results.append(os.path.join(root, _file))\\\n        for _file in fnmatch.filter(files, '*.c')]\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n import os, re\ncfile = re.compile(\"^.*?\\.c$\")\nresults = []\n\nfor name in os.listdir(directory):\n    if cfile.match(name):\n        results.append(name)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If you replace '.c' with '[.", "]c$', you're searching for files that contain .c as the last two characters of the name, rather than all files that contain a c, with at least one character before it."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "'.c'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'[.]c$'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": ".c", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit: Alternatively, match f[-2:] with '.c', this MAY be computationally cheaper than pulling out a regexp match."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "f[-2:]", "childNum": 0, "tag": "code", "childList": []}, {"text": "'.c'", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The implementation of shutil.copytree is in the docs.", "I mofdified it to take a list of extentions to INCLUDE."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def my_copytree(src, dst, symlinks=False, *extentions):\n    \"\"\" I modified the 2.7 implementation of shutils.copytree\n    to take a list of extentions to INCLUDE, instead of an ignore list.\n    \"\"\"\n    names = os.listdir(src)\n    os.makedirs(dst)\n    errors = []\n    for name in names:\n        srcname = os.path.join(src, name)\n        dstname = os.path.join(dst, name)\n        try:\n            if symlinks and os.path.islink(srcname):\n                linkto = os.readlink(srcname)\n                os.symlink(linkto, dstname)\n            elif os.path.isdir(srcname):\n                my_copytree(srcname, dstname, symlinks, *extentions)\n            else:\n                ext = os.path.splitext(srcname)[1]\n                if not ext in extentions:\n                    # skip the file\n                    continue\n                copy2(srcname, dstname)\n            # XXX What about devices, sockets etc.?\n        except (IOError, os.error), why:\n            errors.append((srcname, dstname, str(why)))\n        # catch the Error from the recursive copytree so that we can\n        # continue with other files\n        except Error, err:\n            errors.extend(err.args[0])\n    try:\n        copystat(src, dst)\n    # except WindowsError: # cant copy file access times on Windows\n    #     pass\n    except OSError, why:\n        errors.extend((src, dst, str(why)))\n    if errors:\n        raise Error(errors)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage: For example, to copy only .config and .bat files...."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]