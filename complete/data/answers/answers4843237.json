[[{"text": ["To give you an idea how this would look like in Python, here is some example code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n operators = \"+-*/^\"\n\ndef parse(it, count=1):\n    token = next(it)\n    if token in operators:\n        op1, count = parse(it, count)\n        op2, count = parse(it, count)\n        tmp = \"t%s\" % count\n        print tmp, \"=\", op1, token, op2\n        return tmp, count + 1\n    return token, count\n\ns = \"- + ^ x 2 ^ y 2 1\"\na = s.split()\nres, dummy = parse(iter(a))\nprint res, \"is the result\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["The output is the same as your example output."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This example aside, I think any of the high-level languages you listed are almost equally suited for the task."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The sympy python package does symbolic algebra, including common subexpression elimination and generating evaluation steps for a set of expressions."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sympy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["See:  http://docs.sympy.org/dev/modules/rewriting.html  (Look at the cse method at the bottom of the page)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.sympy.org/dev/modules/rewriting.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.sympy.org/dev/modules/rewriting.html"}, {"text": "cse", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The Python example is elegantly short, but I suspect that you won't actually get enough control over your expressions that way.", "You're much better off actually building an expression tree, even though it takes more work, and then querying the tree.", "Here's an example in Scala (suitable for cutting and pasting into the REPL):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n object OpParser {\n  private def estr(oe: Option[Expr]) = oe.map(_.toString).getOrElse(\"_\")\n  case class Expr(text: String, left: Option[Expr] = None, right: Option[Expr] = None) {\n    import Expr._\n    def varsUsed: Set[String] = text match {\n      case Variable(v) =&gt; Set(v)\n      case Op(o) =&gt;\n        left.map(_.varsUsed).getOrElse(Set()) ++ right.map(_.varsUsed).getOrElse(Set())\n      case _ =&gt; Set()\n    }\n    def printTemp(n: Int = 0, depth: Int = 0): (String,Int) = text match {\n      case Op(o) =&gt; \n        val (tl,nl) = left.map(_.printTemp(n,depth+1)).getOrElse((\"_\",n))\n        val (tr,nr) = right.map(_.printTemp(nl,depth+1)).getOrElse((\"_\",n))\n        val t = \"t\"+(nr+1)\n        println(t + \" = \" + tl + \" \" + text + \" \" + tr)\n        if (depth==0) println(t + \" is the result\")\n        (t, nr+1)\n      case _ =&gt; (text, n)\n    }\n    override def toString: String = {\n      if (left.isDefined || right.isDefined) {\n        \"(\" + estr(left) + \" \" + text + \" \" + estr(right) + \")\"\n      }\n      else text\n    }\n  }\n  object Expr {\n    val Digit = \"([0-9]+)\"r\n    val Variable = \"([a-z])\"r\n    val Op = \"\"\"([+\\-*/^])\"\"\"r\n    def parse(s: String) = {\n      val bits = s.split(\" \")\n      val parsed = (\n        if (bits.length &gt; 2 &amp;&amp; Variable.unapplySeq(bits(0)).isDefined &amp;&amp; bits(1)==\"=\") {\n          parseParts(bits,2)\n        }\n        else parseParts(bits)\n      )\n      parsed.flatMap(p =&gt; if (p._2&lt;bits.length) None else Some(p._1))\n    }\n    def parseParts(as: Array[String], from: Int = 0): Option[(Expr,Int)] = {\n      if (from &gt;= as.length) None\n      else as(from) match {\n        case Digit(n) =&gt; Some(Expr(n), from+1)\n        case Variable(v) =&gt; Some(Expr(v), from+1)\n        case Op(o) =&gt;\n          parseParts(as, from+1).flatMap(lhs =&gt;\n            parseParts(as, lhs._2).map(rhs =&gt; (Expr(o,Some(lhs._1),Some(rhs._1)), rhs._2))\n          )\n        case _ =&gt; None\n      }\n    }\n  }\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["This may be a little much to digest all at once, but then again, this does rather a lot."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Firstly, it's completely bulletproof (note the heavy use of Option where a result might fail).", "If you throw garbage at it, it will just return None.", "(With a bit more work, you could make it complain about the problem in an informative way--basically the case Op(o) which then does parseParts nested twice could instead store the results and print out an informative error message if the op didn't get two arguments.", "Likewise, parse could complain about trailing values instead of just throwing back None.", ")  "], "childNum": 6, "tag": "p", "senID": 3, "childList": [{"text": "Option", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "case Op(o)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "parseParts", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "parse", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Secondly, when you're done with it, you have a complete expression tree.", "Note that printTemp prints out the temporary variables you wanted, and varsUsed lists the variables used in a particular expression, which you can use to expand to a full list once you parse multiple lines.", "(You might need to fiddle with the regexp a little if your variables can be more than just a to z.", ")  Note also that the expression tree prints itself out in normal infix notation.", "Let's look at some examples:"], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "printTemp", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "varsUsed", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "z", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n scala&gt; OpParser.Expr.parse(\"4\")\nres0: Option[OpParser.Expr] = Some(4)\n\nscala&gt; OpParser.Expr.parse(\"+ + + + + 1 2 3 4 5 6\")\nres1: Option[OpParser.Expr] = Some((((((1 + 2) + 3) + 4) + 5) + 6))\n\nscala&gt; OpParser.Expr.parse(\"- + ^ x 2 ^ y 2 1\")\nres2: Option[OpParser.Expr] = Some((((x ^ 2) + (y ^ 2)) - 1))\n\nscala&gt; OpParser.Expr.parse(\"+ + 4 4 4 4\") // Too many 4s!\nres3: Option[OpParser.Expr] = None\n\nscala&gt; OpParser.Expr.parse(\"Q#$S!M$#!*)000\") // Garbage!\nres4: Option[OpParser.Expr] = None\n\nscala&gt; OpParser.Expr.parse(\"z =\") // Assigned nothing?! \nres5: Option[OpParser.Expr] = None\n\nscala&gt; res2.foreach(_.printTemp())\nt1 = x ^ 2\nt2 = y ^ 2\nt3 = t1 + t2\nt4 = t3 - 1\nt4 is the result\n\nscala&gt; res2.map(_.varsUsed)       \nres10: Option[Set[String]] = Some(Set(x, y))\n</code>\n</pre>\n", "senID": 5}, {"text": ["Now, you could do this in Python also without too much additional work, and in a number of the other languages besides.", "I prefer to use Scala, but you may prefer otherwise.", "Regardless, I do recommend creating the full expression tree if you want to retain maximum flexibility for handling tricky cases."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "could", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Prefix notation is really simple to do with plain recursive parsers.", "For instance:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n object Parser {\n    val Subexprs = collection.mutable.Map[String, String]()\n    val Dependencies = collection.mutable.Map[String, Set[String]]().withDefaultValue(Set.empty)\n    val TwoArgsOp = \"([-+*/^])\".r     // - at the beginning, ^ at the end\n    val Ident = \"(\\\\p{Alpha}\\\\w*)\".r\n    val Literal = \"(\\\\d+)\".r\n\n    var counter = 1\n    def getIdent = {\n        val ident = \"t\" + counter\n        counter += 1\n        ident\n    }\n\n    def makeOp(op: String) = {\n        val op1 = expr\n        val op2 = expr\n        val ident = getIdent \n        val subexpr = op1 + \" \" + op + \" \" + op2\n        Subexprs(ident)  = subexpr\n        Dependencies(ident) = Dependencies(op1) ++ Dependencies(op2) + op1 + op2\n        ident\n    }\n\n    def expr: String = nextToken match {\n        case TwoArgsOp(op) =&gt; makeOp(op)\n        case Ident(id)     =&gt; id\n        case Literal(lit)  =&gt; lit\n        case x             =&gt; error(\"Unknown token \"+x)\n    }\n\n    def nextToken = tokens.next\n    var tokens: Iterator[String] = _\n\n    def parse(input: String) = {\n        tokens = input.trim split \"\\\\s+\" toIterator;\n        counter = 1\n        expr\n        if (tokens.hasNext)\n            error(\"Input not fully parsed: \"+tokens.mkString(\" \"))\n\n        (Subexprs, Dependencies)\n    }\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will generate output like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n scala&gt; val (subexpressions, dependencies) = Parser.parse(\"- + ^ x 2 ^ y 2 1\")\nsubexpressions: scala.collection.mutable.Map[String,String] = Map(t3 -&gt; t1 + t2, t4 -&gt; t3 - 1, t1 -&gt; x ^ 2, t2 -&gt; y ^ 2)\ndependencies: scala.collection.mutable.Map[String,Set[String]] = Map(t3 -&gt; Set(x, y, t2, 2, t1), t4 -&gt; Set(x, y, t3, t2, 1, 2, t1), t1 -&gt; Set(x, 2), t\n2 -&gt; Set(y, 2))\n\nscala&gt; subexpressions.toSeq.sorted foreach println\n(t1,x ^ 2)\n(t2,y ^ 2)\n(t3,t1 + t2)\n(t4,t3 - 1)\n\nscala&gt; dependencies.toSeq.sortBy(_._1) foreach println\n(t1,Set(x, 2))\n(t2,Set(y, 2))\n(t3,Set(x, y, t2, 2, t1))\n(t4,Set(x, y, t3, t2, 1, 2, t1))\n</code>\n</pre>\n", "senID": 3}, {"text": ["This can be easily expanded.", "For instance, to handle multiple expression statements you can use this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n object Parser {\n    val Subexprs = collection.mutable.Map[String, String]()\n    val Dependencies = collection.mutable.Map[String, Set[String]]().withDefaultValue(Set.empty)\n    val TwoArgsOp = \"([-+*/^])\".r     // - at the beginning, ^ at the end\n    val Ident = \"(\\\\p{Alpha}\\\\w*)\".r\n    val Literal = \"(\\\\d+)\".r\n\n    var counter = 1\n    def getIdent = {\n        val ident = \"t\" + counter\n        counter += 1\n        ident\n    }\n\n    def makeOp(op: String) = {\n        val op1 = expr\n        val op2 = expr\n        val ident = getIdent \n        val subexpr = op1 + \" \" + op + \" \" + op2\n        Subexprs(ident)  = subexpr\n        Dependencies(ident) = Dependencies(op1) ++ Dependencies(op2) + op1 + op2\n        ident\n    }\n\n    def expr: String = nextToken match {\n        case TwoArgsOp(op) =&gt; makeOp(op)\n        case Ident(id)     =&gt; id\n        case Literal(lit)  =&gt; lit\n        case x             =&gt; error(\"Unknown token \"+x)\n    }\n\n    def assignment: Unit = {\n        val ident = nextToken\n        nextToken match {\n            case \"=\" =&gt; \n                val tmpIdent = expr\n                Dependencies(ident) = Dependencies(tmpIdent)\n                Subexprs(ident) = Subexprs(tmpIdent)\n                Dependencies.remove(tmpIdent)\n                Subexprs.remove(tmpIdent)\n            case x   =&gt; error(\"Expected assignment, got \"+x)\n        }\n     }\n\n    def stmts: Unit = while(tokens.hasNext) tokens.head match {\n        case TwoArgsOp(_) =&gt; expr\n        case Ident(_)     =&gt; assignment\n        case x            =&gt; error(\"Unknown statement starting with \"+x)\n    }\n\n    def nextToken = tokens.next\n    var tokens: BufferedIterator[String] = _\n\n    def parse(input: String) = {\n        tokens = (input.trim split \"\\\\s+\" toIterator).buffered\n        counter = 1\n        stmts\n        if (tokens.hasNext)\n            error(\"Input not fully parsed: \"+tokens.mkString(\" \"))\n\n        (Subexprs, Dependencies)\n    }\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["Yielding:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n scala&gt; val (subexpressions, dependencies) = Parser.parse(\"\"\"\n     | z = ^ x 2\n     | - + z ^ y 2 1\n     | - z y\n     | \"\"\")\nsubexpressions: scala.collection.mutable.Map[String,String] = Map(t3 -&gt; z + t2, t5 -&gt; z - y, t4 -&gt; t3 - 1, z -&gt; x ^ 2, t2 -&gt; y ^ 2)\ndependencies: scala.collection.mutable.Map[String,Set[String]] = Map(t3 -&gt; Set(x, y, t2, 2, z), t5 -&gt; Set(x, 2, z, y), t4 -&gt; Set(x, y, t3, t2, 1, 2, z\n), z -&gt; Set(x, 2), t2 -&gt; Set(y, 2))\n\nscala&gt; subexpressions.toSeq.sorted foreach println\n(t2,y ^ 2)\n(t3,z + t2)\n(t4,t3 - 1)\n(t5,z - y)\n(z,x ^ 2)\n\nscala&gt; dependencies.toSeq.sortBy(_._1) foreach println\n(t2,Set(y, 2))\n(t3,Set(x, y, t2, 2, z))\n(t4,Set(x, y, t3, t2, 1, 2, z))\n(t5,Set(x, 2, z, y))\n(z,Set(x, 2))\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Ok, since recursive parsers are not your thing, here's an alternative with parse combinators:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n object PrefixParser extends JavaTokenParsers {\n    import scala.collection.mutable\n\n    // Maps generated through parsing\n\n    val Subexprs = mutable.Map[String, String]()\n    val Dependencies = mutable.Map[String, Set[String]]().withDefaultValue(Set.empty)\n\n    // Initialize, read, parse &amp; evaluate string\n\n    def read(input: String) = {\n        counter = 1\n        Subexprs.clear\n        Dependencies.clear\n        parseAll(stmts, input)\n    }\n\n    // Grammar\n\n    def stmts               = stmt+\n    def stmt                = assignment | expr\n    def assignment          = (ident &lt;~ \"=\") ~ expr ^^ assignOp\n    def expr: P             = subexpr | identifier | number\n    def subexpr: P          = twoArgs | nArgs\n    def twoArgs: P          = operator ~ expr ~ expr ^^ twoArgsOp\n    def nArgs: P            = \"sum\" ~ (\"\\\\d+\".r &gt;&gt; args) ^^ nArgsOp\n    def args(n: String): Ps = repN(n.toInt, expr)\n    def operator            = \"[-+*/^]\".r\n    def identifier          = ident ^^ (id =&gt; Result(id, Set(id)))\n    def number              = wholeNumber ^^ (Result(_, Set.empty))\n\n    // Evaluation helper class and types\n\n    case class Result(ident: String, dependencies: Set[String])\n    type P = Parser[Result]\n    type Ps = Parser[List[Result]]\n\n    // Evaluation methods\n\n    def assignOp: (String ~ Result) =&gt; Result = {\n        case ident ~ result =&gt; \n            val value = assign(ident, \n                               Subexprs(result.ident),\n                               result.dependencies - result.ident)\n            Subexprs.remove(result.ident)\n            Dependencies.remove(result.ident)\n            value\n    }\n\n    def assign(ident: String, \n               value: String, \n               dependencies: Set[String]): Result = {\n        Subexprs(ident) = value\n        Dependencies(ident) = dependencies\n        Result(ident, dependencies)\n    }\n\n    def twoArgsOp: (String ~ Result ~ Result) =&gt; Result = { \n        case op ~ op1 ~ op2 =&gt; makeOp(op, op1, op2) \n    }\n\n    def makeOp(op: String, \n               op1: Result, \n               op2: Result): Result = {\n        val ident = getIdent\n        assign(ident, \n               \"%s %s %s\" format (op1.ident, op, op2.ident),\n               op1.dependencies ++ op2.dependencies + ident)\n    } \n\n    def nArgsOp: (String ~ List[Result]) =&gt; Result = { \n        case op ~ ops =&gt; makeNOp(op, ops) \n    }\n\n    def makeNOp(op: String, ops: List[Result]): Result = {\n        val ident = getIdent\n        assign(ident, \n               \"%s(%s)\" format (op, ops map (_.ident) mkString \", \"),\n               ops.foldLeft(Set(ident))(_ ++ _.dependencies))\n    } \n\n    var counter = 1\n    def getIdent = {\n        val ident = \"t\" + counter\n        counter += 1\n        ident\n    }\n\n    // Debugging helper methods\n\n    def printAssignments = Subexprs.toSeq.sorted foreach println\n    def printDependencies = Dependencies.toSeq.sortBy(_._1) map {\n        case (id, dependencies) =&gt; (id, dependencies - id)\n    } foreach println\n\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is the kind of results you get:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n scala&gt; PrefixParser.read(\"\"\"\n     | z = ^ x 2\n     | - + z ^ y 2 1\n     | - z y\n     | \"\"\")\nres77: PrefixParser.ParseResult[List[PrefixParser.Result]] = [5.1] parsed: List(Result(z,Set(x)), Result(t4,Set(t4, y, t3, t2, z)), Result(t5,Set(z, y\n, t5)))\n\nscala&gt; PrefixParser.printAssignments\n(t2,y ^ 2)\n(t3,z + t2)\n(t4,t3 - 1)\n(t5,z - y)\n(z,x ^ 2)\n\nscala&gt; PrefixParser.printDependencies\n(t2,Set(y))\n(t3,Set(z, y, t2))\n(t4,Set(y, t3, t2, z))\n(t5,Set(z, y))\n(z,Set(x))\n</code>\n</pre>\n", "senID": 3}, {"text": ["n-Ary operator"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "n-Ary operator", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n scala&gt; PrefixParser.read(\"\"\"\n     | x = sum 3 + 1 2 * 3 4 5\n     | * x x\n     | \"\"\")\nres93: PrefixParser.ParseResult[List[PrefixParser.Result]] = [4.1] parsed: List(Result(x,Set(t1, t2)), Result(t4,Set(x, t4)))\n\nscala&gt; PrefixParser.printAssignments\n(t1,1 + 2)\n(t2,3 * 4)\n(t4,x * x)\n(x,sum(t1, t2, 5))\n\nscala&gt; PrefixParser.printDependencies\n(t1,Set())\n(t2,Set())\n(t4,Set(x))\n(x,Set(t1, t2))\n</code>\n</pre>\n", "senID": 5}], [{"text": ["It turns out that this sort of parsing is of interest to me also, so I've done a bit more work on it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There seems to be a sentiment that things like simplification of expressions is hard.", "I'm not so sure.", "Let's take a look at a fairly complete solution.", "(The printing out of tn expressions is not useful for me, and you've got several Scala examples already, so I'll skip that."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "tn", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["First, we need to extract the various parts of the language.", "I'll pick regular expressions, though parser combinators could be used also:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n object OpParser {\n  val Natural = \"([0-9]+)\"r\n  val Number = \"\"\"((?:-)?[0-9]+(?:\\.[0-9]+)?(?:[eE](?:-)?[0-9]+)?)\"\"\"r\n  val Variable = \"([a-z])\"r\n  val Unary = \"(exp|sin|cos|tan|sqrt)\"r\n  val Binary = \"([-+*/^])\"r\n  val Nary = \"(sum|prod|list)\"r\n</code>\n</pre>\n", "senID": 3}, {"text": ["Pretty straightforward.", "We define the various things that might appear.", "(I've decided that user-defined variables can only be a single lowercase letter, and that numbers can be floating-point since you have the exp function.", ")  The r at the end means this is a regular expression, and it will give us the stuff in parentheses."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "exp", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "r", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Now we need to represent our tree.", "There are a number of ways to do this, but I'll choose an abstract base class with specific expressions as case classes, since this makes pattern matching easy.", "Furthermore, we might want nice printing, so we'll override toString.", "Mostly, though, we'll use recursive functions to do the heavy lifting."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "toString", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n abstract class Expr {\n    def text: String\n    def args: List[Expr]\n    override def toString = args match {\n      case l :: r :: Nil =&gt; \"(\" + l + \" \" + text + \" \" + r + \")\"\n      case Nil =&gt; text\n      case _ =&gt; args.mkString(text+\"(\", \",\", \")\")\n    }\n  }\n  case class Num(text: String, args: List[Expr]) extends Expr {\n    val quantity = text.toDouble\n  }\n  case class Var(text: String, args: List[Expr]) extends Expr {\n    override def toString = args match {\n      case arg :: Nil =&gt; \"(\" + text + \" &lt;- \" + arg + \")\"\n      case _ =&gt; text\n    }\n  }\n  case class Una(text: String, args: List[Expr]) extends Expr\n  case class Bin(text: String, args: List[Expr]) extends Expr\n  case class Nar(text: String, args: List[Expr]) extends Expr {\n    override def toString = text match {\n      case \"list\" =&gt;\n        (for ((a,i) &lt;- args.zipWithIndex) yield {\n           \"%3d: %s\".format(i+1,a.toString)\n        }).mkString(\"List[\\n\",\"\\n\",\"\\n]\")\n      case _ =&gt; super.toString\n    }\n  }\n</code>\n</pre>\n", "senID": 6}, {"text": ["Mostly this is pretty dull--each case class overrides the base class, and the text and args automatically fill in for the def.", "Note that I've decided that a list is a possible n-ary function, and that it will be printed out with line numbers.", "(The reason is that if you have multiple lines of input, it's sometimes more convenient to work with them all together as one expression; this lets them be one function."], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "text", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "args", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Once our data structures are defined, we need to parse the expressions.", "It's convenient to represent the stuff to parse as a list of tokens; as we parse, we'll return both an expression and the remaining tokens that we haven't parsed--this is a particularly useful structure for recursive parsing.", "Of course, we might fail to parse anything, so it had better be wrapped in an Option also."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Option", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n def parse(tokens: List[String]): Option[(Expr,List[String])] = tokens match {\n    case Variable(x) :: \"=\" :: rest =&gt;\n      for ((expr,remains) &lt;- parse(rest)) yield (Var(x,List(expr)), remains)\n    case Variable(x) :: rest =&gt; Some(Var(x,Nil), rest)\n    case Number(n) :: rest =&gt; Some(Num(n,Nil), rest)\n    case Unary(u) :: rest =&gt;\n      for ((expr,remains) &lt;- parse(rest)) yield (Una(u,List(expr)), remains)\n    case Binary(b) :: rest =&gt;\n      for ((lexp,lrem) &lt;- parse(rest); (rexp,rrem) &lt;- parse(lrem)) yield\n        (Bin(b,List(lexp,rexp)), rrem)\n    case Nary(a) :: Natural(b) :: rest =&gt;\n      val buffer = new collection.mutable.ArrayBuffer[Expr]\n      def parseN(tok: List[String], n: Int = b.toInt): List[String] = {\n        if (n &lt;= 0) tok\n        else {\n          for ((expr,remains) &lt;- parse(tok)) yield { buffer += expr; parseN(remains, n-1) }\n        }.getOrElse(tok)\n      }\n      val remains = parseN(rest)\n      if (buffer.length == b.toInt) Some( Nar(a,buffer.toList), remains )\n      else None\n    case _ =&gt; None\n  }\n</code>\n</pre>\n", "senID": 9}, {"text": ["Note that we use pattern matching and recursion to do most of the heavy lifting--we pick off part of the list, figure out how many arguments we need, and pass those along recursively.", "The N-ary operation is a little less friendly, but we create a little recursive function that will parse N things at a time for us, storing the results in a buffer."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Of course, this is a little unfriendly to use, so we add some wrapper functions that let us interface with it nicely:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def parse(s: String): Option[Expr] = parse(s.split(\" \").toList).flatMap(x =&gt; {\n    if (x._2.isEmpty) Some(x._1) else None\n  })\n  def parseLines(ls: List[String]): Option[Expr] = {\n    val attempt = ls.map(parse).flatten\n    if (attempt.length&lt;ls.length) None\n    else if (attempt.length==1) attempt.headOption\n    else Some(Nar(\"list\",attempt))\n  }\n</code>\n</pre>\n", "senID": 12}, {"text": ["Okay, now, what about simplification?", "One thing we might want to do is numeric simplification, where we precompute the expressions and replace the original expression with the reduced version thereof.", "That sounds like some sort of a recursive operation--find numbers, and combine them.", "First we get some helper functions to do calculations on numbers:"], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "numeric simplification", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def calc(n: Num, f: Double =&gt; Double): Num = Num(f(n.quantity).toString, Nil)\n  def calc(n: Num, m: Num, f: (Double,Double) =&gt; Double): Num =\n    Num(f(n.quantity,m.quantity).toString, Nil)\n  def calc(ln: List[Num], f: (Double,Double) =&gt; Double): Num =\n    Num(ln.map(_.quantity).reduceLeft(f).toString, Nil)\n</code>\n</pre>\n", "senID": 14}, {"text": ["and then we do the simplification:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n def numericSimplify(expr: Expr): Expr = expr match {\n    case Una(t,List(e)) =&gt; numericSimplify(e) match {\n      case n @ Num(_,_) =&gt; t match {\n        case \"exp\" =&gt; calc(n, math.exp _)\n        case \"sin\" =&gt; calc(n, math.sin _)\n        case \"cos\" =&gt; calc(n, math.cos _)\n        case \"tan\" =&gt; calc(n, math.tan _)\n        case \"sqrt\" =&gt; calc(n, math.sqrt _)\n      }\n      case a =&gt; Una(t,List(a))\n    }\n    case Bin(t,List(l,r)) =&gt; (numericSimplify(l), numericSimplify(r)) match {\n      case (n @ Num(_,_), m @ Num(_,_)) =&gt; t match {\n        case \"+\" =&gt; calc(n, m, _ + _)\n        case \"-\" =&gt; calc(n, m, _ - _)\n        case \"*\" =&gt; calc(n, m, _ * _)\n        case \"/\" =&gt; calc(n, m, _ / _)\n        case \"^\" =&gt; calc(n, m, math.pow)\n      }\n      case (a,b) =&gt; Bin(t,List(a,b))\n    }\n    case Nar(\"list\",list) =&gt; Nar(\"list\",list.map(numericSimplify))\n    case Nar(t,list) =&gt;\n      val simple = list.map(numericSimplify)\n      val nums = simple.collect { case n @ Num(_,_) =&gt; n }\n      if (simple.length == 0) t match {\n        case \"sum\" =&gt; Num(\"0\",Nil)\n        case \"prod\" =&gt; Num(\"1\",Nil)\n      }\n      else if (nums.length == simple.length) t match {\n        case \"sum\" =&gt; calc(nums, _ + _)\n        case \"prod\" =&gt; calc(nums, _ * _)\n      }\n      else Nar(t, simple)\n    case Var(t,List(e)) =&gt; Var(t, List(numericSimplify(e)))\n    case _ =&gt; expr\n  }\n</code>\n</pre>\n", "senID": 16}, {"text": ["Notice again the heavy use of pattern matching to find when we're in a good case, and to dispatch the appropriate calculation."], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"text": ["Now, surely algebraic substitution is much more difficult!", "Actually, all you need to do is notice that an expression has already been used, and assign a variable.", "Since the syntax I've defined above allows in-place variable substitution, we can actually just modify our expression tree to include more variable assignments.", "So we do (edited to only insert variables if the user hasn't):"], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "edited to only insert variables if the user hasn't", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n def algebraicSimplify(expr: Expr): Expr = {\n    val all, dup, used = new collection.mutable.HashSet[Expr]\n    val made = new collection.mutable.HashMap[Expr,Int]\n    val user = new collection.mutable.HashMap[Expr,Expr]\n    def findExpr(e: Expr) {\n      e match {\n        case Var(t,List(v)) =&gt;\n          user += v -&gt; e\n          if (all contains e) dup += e else all += e\n        case Var(_,_) | Num(_,_) =&gt; // Do nothing in these cases\n        case _ =&gt; if (all contains e) dup += e else all += e\n      }\n      e.args.foreach(findExpr)\n    }\n    findExpr(expr)\n    def replaceDup(e: Expr): Expr = {\n      if (made contains e) Var(\"x\"+made(e),Nil)\n      else if (used contains e) Var(user(e).text,Nil)\n      else if (dup contains e) {\n        val fixed = replaceDupChildren(e)\n        made += e -&gt; made.size\n        Var(\"x\"+made(e),List(fixed))\n      }\n      else replaceDupChildren(e)\n    }\n    def replaceDupChildren(e: Expr): Expr = e match {\n      case Una(t,List(u)) =&gt; Una(t,List(replaceDup(u)))\n      case Bin(t,List(l,r)) =&gt; Bin(t,List(replaceDup(l),replaceDup(r)))\n      case Nar(t,list) =&gt; Nar(t,list.map(replaceDup))\n      case Var(t,List(v)) =&gt;\n        used += v\n        Var(t,List(if (made contains v) replaceDup(v) else replaceDupChildren(v)))\n      case _ =&gt; e\n    }\n    replaceDup(expr)\n  }\n</code>\n</pre>\n", "senID": 19}, {"text": ["That's it--a fully functional algebraic replacement routine.", "Note that it builds up sets of expressions that it's seen, keeping special track of which ones are duplicates.", "Thanks to the magic of case classes, all the equalities are defined for us, so it just works.", "Then we can replace any duplicates as we recurse through to find them.", "Note that the replace routine is split in half, and that it matches on an unreplaced version of the tree, but uses a replaced version."], "childNum": 2, "tag": "p", "senID": 20, "childList": [{"text": "matches", "childNum": 0, "tag": "em", "pos": 4, "childList": []}, {"text": "uses", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Okay, now let's add a few tests:"], "childNum": 0, "tag": "p", "senID": 21, "childList": []}, {"code": "<pre>\n<code>\n def main(args: Array[String]) {\n    val test1 = \"- + ^ x 2 ^ y 2 1\"\n    val test2 = \"+ + +\"  // Bad!\n    val test3 = \"exp sin cos sum 5\"  // Bad!\n    val test4 = \"+ * 2 3 ^ 3 2\"\n    val test5 = List(test1, test4, \"^ y 2\").mkString(\"list 3 \",\" \",\"\")\n    val test6 = \"+ + x y + + * + x y + 4 5 * + x y + 4 y + + x y + 4 y\"\n\n    def performTest(test: String) = {\n      println(\"Start with: \" + test)\n      val p = OpParser.parse(test)\n      if (p.isEmpty) println(\"  Parsing failed\")\n      else {\n        println(\"Parsed:     \" + p.get)\n        val q = OpParser.numericSimplify(p.get)\n        println(\"Numeric:    \" + q)\n        val r = OpParser.algebraicSimplify(q)\n        println(\"Algebraic:  \" + r)\n      }\n      println\n    }\n\n    List(test1,test2,test3,test4,test5,test6).foreach(performTest)\n  }\n}\n</code>\n</pre>\n", "senID": 22}, {"text": ["How does it do?"], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"code": "<pre>\n<code>\n $ scalac OpParser.scala; scala OpParser\nStart with: - + ^ x 2 ^ y 2 1\nParsed:     (((x ^ 2) + (y ^ 2)) - 1)\nNumeric:    (((x ^ 2) + (y ^ 2)) - 1)\nAlgebraic:  (((x ^ 2) + (y ^ 2)) - 1)\n\nStart with: + + +\n  Parsing failed\n\nStart with: exp sin cos sum 5\n  Parsing failed\n\nStart with: + * 2 3 ^ 3 2\nParsed:     ((2 * 3) + (3 ^ 2))\nNumeric:    15.0\nAlgebraic:  15.0\n\nStart with: list 3 - + ^ x 2 ^ y 2 1 + * 2 3 ^ 3 2 ^ y 2\nParsed:     List[\n  1: (((x ^ 2) + (y ^ 2)) - 1)\n  2: ((2 * 3) + (3 ^ 2))\n  3: (y ^ 2)\n]\nNumeric:    List[\n  1: (((x ^ 2) + (y ^ 2)) - 1)\n  2: 15.0\n  3: (y ^ 2)\n]\nAlgebraic:  List[\n  1: (((x ^ 2) + (x0 &lt;- (y ^ 2))) - 1)\n  2: 15.0\n  3: x0\n]\n\nStart with: + + x y + + * + x y + 4 5 * + x y + 4 y + + x y + 4 y\nParsed:     ((x + y) + ((((x + y) * (4 + 5)) + ((x + y) * (4 + y))) + ((x + y) + (4 + y))))\nNumeric:    ((x + y) + ((((x + y) * 9.0) + ((x + y) * (4 + y))) + ((x + y) + (4 + y))))\nAlgebraic:  ((x0 &lt;- (x + y)) + (((x0 * 9.0) + (x0 * (x1 &lt;- (4 + y)))) + (x0 + x1)))\n</code>\n</pre>\n", "senID": 24}, {"text": ["So I don't know if that's useful for you, but it turns out to be useful for me.", "And this is the sort of thing that I would be very hesitant to tackle in C++ because various things that were supposed to be easy ended up being painful instead."], "childNum": 0, "tag": "p", "senID": 25, "childList": []}, {"text": ["Edit: Here's an example of using this structure to print temporary assignments, just to demonstrate that this structure is perfectly okay for doing such things."], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"text": ["Code:"], "childNum": 0, "tag": "p", "senID": 27, "childList": []}, {"code": "<pre>\n<code>\n def useTempVars(expr: Expr): Expr = {\n    var n = 0\n    def temp = { n += 1; \"t\"+n }\n    def replaceTemp(e: Expr, exempt: Boolean = false): Expr = {\n      def varify(x: Expr) = if (exempt) x else Var(temp,List(x))\n      e match {\n        case Var(t,List(e)) =&gt; Var(t,List(replaceTemp(e, exempt = true)))\n        case Una(t,List(u)) =&gt; varify( Una(t, List(replaceTemp(u,false))) )\n        case Bin(t,lr) =&gt; varify( Bin(t, lr.map(replaceTemp(_,false))) )\n        case Nar(t,ls) =&gt; varify( Nar(t, ls.map(replaceTemp(_,false))) )\n        case _ =&gt; e\n      }\n    }\n    replaceTemp(expr)\n  }\n  def varCut(expr: Expr): Expr = expr match {\n    case Var(t,_) =&gt; Var(t,Nil)\n    case Una(t,List(u)) =&gt; Una(t,List(varCut(u)))\n    case Bin(t,lr) =&gt; Bin(t, lr.map(varCut))\n    case Nar(t,ls) =&gt; Nar(t, ls.map(varCut))\n    case _ =&gt; expr\n  }\n  def getAssignments(expr: Expr): List[Expr] = {\n    val children = expr.args.flatMap(getAssignments)\n    expr match {\n      case Var(t,List(e)) =&gt; children :+ expr\n      case _ =&gt; children\n    }\n  }\n  def listAssignments(expr: Expr): List[String] = {\n    getAssignments(expr).collect(e =&gt; e match {\n      case Var(t,List(v)) =&gt; t + \" = \" + varCut(v)\n    }) :+ (expr.text + \" is the answer\")\n  }\n</code>\n</pre>\n", "senID": 28}, {"text": ["Selected results (from listAssignments(useTempVars(r)).foreach(printf(\"  %s\\n\",_))):"], "childNum": 1, "tag": "p", "senID": 29, "childList": [{"text": "listAssignments(useTempVars(r)).foreach(printf(\"  %s\\n\",_))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n Start with: - + ^ x 2 ^ y 2 1\nAssignments:\n  t1 = (x ^ 2)\n  t2 = (y ^ 2)\n  t3 = (t1 + t2)\n  t4 = (t3 - 1)\n  t4 is the answer\n\nStart with: + + x y + + * + x y + 4 5 * + x y + 4 y + + x y + 4 y\nAlgebraic:  ((x0 &lt;- (x + y)) + (((x0 * 9.0) + (x0 * (x1 &lt;- (4 + y)))) + (x0 + x1)))\nAssignments:\n  x0 = (x + y)\n  t1 = (x0 * 9.0)\n  x1 = (4 + y)\n  t2 = (x0 * x1)\n  t3 = (t1 + t2)\n  t4 = (x0 + x1)\n  t5 = (t3 + t4)\n  t6 = (x0 + t5)\n  t6 is the answer\n</code>\n</pre>\n", "senID": 30}, {"text": ["Second edit: finding dependencies is also not too bad."], "childNum": 0, "tag": "p", "senID": 31, "childList": []}, {"text": ["Code:"], "childNum": 0, "tag": "p", "senID": 32, "childList": []}, {"code": "<pre>\n<code>\n def directDepends(expr: Expr): Set[Expr] = expr match {\n    case Var(t,_) =&gt; Set(expr)\n    case _ =&gt; expr.args.flatMap(directDepends).toSet\n  }\n  def indirectDepends(expr: Expr) = {\n    val depend = getAssignments(expr).map(e =&gt; \n      e -&gt; e.args.flatMap(directDepends).toSet\n    ).toMap\n    val tagged = for ((k,v) &lt;- depend) yield (k.text -&gt; v.map(_.text))\n    def percolate(tags: Map[String,Set[String]]): Option[Map[String,Set[String]]] = {\n      val expand = for ((k,v) &lt;- tags) yield (\n        k -&gt; (v union v.flatMap(x =&gt; tags.get(x).getOrElse(Set())))\n      )\n      if (tags.exists(kv =&gt; expand(kv._1) contains kv._1)) None  // Cyclic dependency!\n      else if (tags == expand) Some(tags)\n      else percolate(expand)\n    }\n    percolate(tagged)\n  }\n  def listDependents(expr: Expr): List[(String,String)] = {\n    def sayNothing(s: String) = if (s==\"\") \"nothing\" else s\n    val e = expr match {\n      case Var(_,_) =&gt; expr\n      case _ =&gt; Var(\"result\",List(expr))\n    }\n    indirectDepends(e).map(_.toList.map(x =&gt;\n      (x._1, sayNothing(x._2.toList.sorted.mkString(\" \")))\n    )).getOrElse(List((e.text,\"cyclic\")))\n  }\n</code>\n</pre>\n", "senID": 33}, {"text": ["And if we add new test cases val test7 = \"list 3 z = ^ x 2 - + z ^ y 2 1 w = - z y\" and val test8 = \"list 2 x = y y = x\" and show the answers with for ((v,d) &lt;- listDependents(r)) println(\"  \"+v+\" requires \"+d) we get (selected results):"], "childNum": 3, "tag": "p", "senID": 34, "childList": [{"text": "val test7 = \"list 3 z = ^ x 2 - + z ^ y 2 1 w = - z y\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "val test8 = \"list 2 x = y y = x\"", "childNum": 0, "tag": "code", "childList": []}, {"text": "for ((v,d) &lt;- listDependents(r)) println(\"  \"+v+\" requires \"+d)", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n Start with: - + ^ x 2 ^ y 2 1\nDependencies:\n  result requires x y\n\nStart with: list 3 z = ^ x 2 - + z ^ y 2 1 w = - z y\nParsed:     List[\n  1: (z &lt;- (x ^ 2))\n  2: ((z + (y ^ 2)) - 1)\n  3: (w &lt;- (z - y))\n]\nDependencies:\n  z requires x\n  w requires x y z\n  result requires w x y z\n\nStart with: list 2 x = y y = x\nParsed:     List[\n  1: (x &lt;- y)\n  2: (y &lt;- x)\n]\nDependencies:\n  result requires cyclic\n\nStart with: + + x y + + * + x y + 4 5 * + x y + 4 y + + x y + 4 y\nAlgebraic:  ((x0 &lt;- (x + y)) + (((x0 * 9.0) + (x0 * (x1 &lt;- (4 + y)))) + (x0 + x1)))\nDependencies:\n  x0 requires x y\n  x1 requires y\n  result requires x x0 x1 y\n</code>\n</pre>\n", "senID": 35}, {"text": ["So I think that on top of this sort of structure, all of your individual requirements are met by blocks of one or two dozen lines of Scala code."], "childNum": 0, "tag": "p", "senID": 36, "childList": []}, {"text": ["Edit: here's expression evaluation, if you're given a mapping from vars to values:"], "childNum": 0, "tag": "p", "senID": 37, "childList": []}, {"code": "<pre>\n<code>\n def numericEvaluate(expr: Expr, initialValues: Map[String,Double]) = {\n    val chain = new collection.mutable.ArrayBuffer[(String,Double)]\n    val evaluated = new collection.mutable.HashMap[String,Double]\n    def note(xv: (String,Double)) { chain += xv; evaluated += xv }\n    evaluated ++= initialValues\n    def substitute(expr: Expr): Expr = expr match {\n      case Var(t,List(n @ Num(v,_))) =&gt; { note(t -&gt; v.toDouble); n }\n      case Var(t,_) if (evaluated contains t) =&gt; Num(evaluated(t).toString,Nil)\n      case Var(t,ls) =&gt; Var(t,ls.map(substitute))\n      case Una(t,List(u)) =&gt; Una(t,List(substitute(u)))\n      case Bin(t,ls) =&gt; Bin(t,ls.map(substitute))\n      case Nar(t,ls) =&gt; Nar(t,ls.map(substitute))\n      case _ =&gt; expr\n    }\n    def recurse(e: Expr): Expr = {\n      val sub = numericSimplify(substitute(e))\n      if (sub == e) e else recurse(sub)\n    }\n    (recurse(expr), chain.toList)\n  }\n</code>\n</pre>\n", "senID": 38}, {"text": ["and it's used like so in the testing routine:"], "childNum": 0, "tag": "p", "senID": 39, "childList": []}, {"code": "<pre>\n<code>\n val (num,ops) = numericEvaluate(r,Map(\"x\"-&gt;3,\"y\"-&gt;1.5))\n        println(\"Evaluated:\")\n        for ((v,n) &lt;- ops) println(\"  \"+v+\" = \"+n)\n        println(\"  result = \" + num)\n</code>\n</pre>\n", "senID": 40}, {"text": ["giving results like these (with input of x = 3 and y = 1.5):"], "childNum": 2, "tag": "p", "senID": 41, "childList": [{"text": "x = 3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y = 1.5", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n Start with: list 3 - + ^ x 2 ^ y 2 1 + * 2 3 ^ 3 2 ^ y 2\nAlgebraic:  List[\n  1: (((x ^ 2) + (x0 &lt;- (y ^ 2))) - 1)\n  2: 15.0\n  3: x0\n]\nEvaluated:\n  x0 = 2.25\n  result = List[\n  1: 10.25\n  2: 15.0\n  3: 2.25\n]\n\nStart with: list 3 z = ^ x 2 - + z ^ y 2 1 w = - z y\nAlgebraic:  List[\n  1: (z &lt;- (x ^ 2))\n  2: ((z + (y ^ 2)) - 1)\n  3: (w &lt;- (z - y))\n]\nEvaluated:\n  z = 9.0\n  w = 7.5\n  result = List[\n  1: 9.0\n  2: 10.25\n  3: 7.5\n]\n</code>\n</pre>\n", "senID": 42}, {"text": ["The other challenge--picking out the vars that haven't already been used--is just set subtraction off of the dependencies result list.", "diff is the name of the set subtraction method."], "childNum": 2, "tag": "p", "senID": 43, "childList": [{"text": "result", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "diff", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["The problem consists of two subproblems: parsing and symbolic manipulation.", "It seems to me the answer boils down to two possible solutions."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One is to implement everything from scratch: \"I do recommend creating the full expression tree if you want to retain maximum flexibility for handling tricky cases.", "\" - proposed by Rex.", "As Sven points out: \"any of the high-level languages you listed are almost equally suited for the task,\" however \"Python (or any of the high-level languages you listed) won't take away the complexity of the problem.", "\"\nI have received very nice solutions in Scala (many thanks for Rex and Daniel), a nice little example in Python (from Sven).", "However, I am still interested in Lisp, Haskell or Erlang solutions."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["The other solution is to use some existing library/software for the task, with all the implied pros and cons.", "Candidates are Maxima (Common Lisp), SymPy (Python, proposed by payne) and GiNaC (C++)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]