[[{"text": ["The answer is almost always \"no\".", "The general idea in Python, Ruby, and some other languages us called \"Duck Typing\".", "You shouldn't care what something is, only how it works.", "In other words, \"if all you want is something that quacks, you don't need to check that it's actually a duck."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Duck Typing", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Duck%5Ftyping"}]}, {"text": ["In real life, the problem with putting in all those type checks is the inability to replace inputs with alternate implementations.", "You may check for dict, but I may want to pass something in which is not a dict, but implements the dict API."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Type checking only checks for one of many possible errors in code.", "For example, it doesn't include range checking (at least not in Python).", "A modern response to the assertion that there needs to be type checking is that it's more effective to develop unit tests which ensure that not only are the types correct, but also that the functionality is correct."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Another viewpoint is that you should treat your API users like consenting adults, and trust them to use the API correctly.", "Of course there are times when input checking is helpful, but that's less common than you think.", "One example is input from untrusted sources, like from the public web."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The simple answer is No, use Polymorphism, Exceptions etc. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "No", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["In Python, you treat programmers as intelligent beings!!", "Just document your code well (make things obvious), raise Exceptions where appropriate, write polymorphic code etc.", "Leave the Exception handling(where it is appropriate only)/errors in construction to the client code."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Warning\nLeaving Exception handling to clients doesn't mean that you should chuck a lot of garbage errors at the unwitting user.", "If at all possible, handle exceptions that might occur due to bad construction or any other reason in your code itself.", "Your code should be robust.", "Where it is impossible for you to handle the error, politely inform the user/client code programmer!"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Warning", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"text": ["Note\nIn general, bad arguments to a constructor isn't something I worry about too much."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Note", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}], [{"text": ["Check all you like, you just have to be explicit.", "The following example is a constructor from a module in the standard library - it checks the extrasaction arg:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "a module", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Lib/csv.py?view=markup"}, {"text": "extrasaction", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class DictWriter:\n  def __init__(self, f, fieldnames, restval=\"\", extrasaction=\"raise\",\n               dialect=\"excel\", *args, **kwds):\n      self.fieldnames = fieldnames    # list of keys for the dict\n      self.restval = restval          # for writing short dicts\n      if extrasaction.lower() not in (\"raise\", \"ignore\"):\n          raise ValueError, \\\n                (\"extrasaction (%s) must be 'raise' or 'ignore'\" %\n                 extrasaction)\n      self.extrasaction = extrasaction\n      self.writer = writer(f, dialect, *args, **kwds)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["\"If I don't and set the object's members to the arguments it will cause problems later."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Please be very clear on the exact list of \"problems\" which will be caused later."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["Will it not work at all?", "That what try/except blocks are for."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Will it behave \"oddly\"?", "This is really rare, and is limited to \"near-miss\" types and operators.", "The standard example is division.", "If you expected integers, but got floating-point, then division may not do what you wanted.", "But that's fixed with the //, vs. / division operators."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Will it be simply wrong, but still appear to complete?", "This is really rare, and would require a pretty-carefully crafted type that used standard names, but did non-standard things.", "For example"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]}, {"text": ["Other than that, it's hard to have things \"cause problems later\".", "Please update your question with specific examples of \"problems\"."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["It is often a good thing to do.", "Checking for explicit types is probably not so useful in Python (as others have said), but checking for legal values can be a good idea.", "The reason it's a good idea is that the software will fail closer to the source of the bug (it follows the Fail Fast Principle).", "Also, the checks act as documentation to other programmers and yourself.", "Even better, it is \"executable documentation\", which is good because it's documentation that can't lie."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A quick and dirty but reasonable way to check your arguments is to use assert:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def my_sqrt(x):\n    assert x &gt;= 0, \"must be greater or equal to zero\"\n    # ...\n</code>\n</pre>\n", "senID": 2}, {"text": ["Asserting your arguments is a kind of poor man's Design by Contract.", "(You might like to look up Design by Contract; it is interesting.", ") "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["AFAIU, you want to make sure that some objects behave (\"follow an interface\") at an earlier time than that of the actual use.", "In your example, you want to know that objects are appropriate at instance creation time, not when they will actually be used."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Keeping in mind that we're talking Python here, I won't suggest assert (what if python -O or an environment variable PYTHONOPTIMIZE is set to 1 when your program runs?", ") or checking for specific types (because that unnecessarily restricts the types you can use), but I will suggest early testing functionality, something along the lines:"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "assert", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "python -O", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "functionality", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def __init__(self, a_number, a_boolean, a_duck, a_sequence):\n\n    self.a_number= a_number + 0\n\n    self.a_boolean= not not a_boolean\n\n    try:\n        a_duck.quack\n    except AttributeError:\n        raise TypeError, \"can't use it if it doesn't quack\"\n    else:\n        self.a_duck= a_duck\n\n    try:\n        iter(a_sequence)\n    except TypeError:\n        raise TypeError, \"expected an iterable sequence\"\n    else:\n        self.a_sequence= a_sequence\n</code>\n</pre>\n", "senID": 2}, {"text": ["I used try\u2026 except\u2026 else in this suggestion because I want to set the instance members only if the test succeeded, even if the code is changed or augmented.", "You don't have to do it so, obviously."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "try\u2026 except\u2026 else", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "only", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["For function arguments and setting properties, I wouldn't do these tests in advance, I'd just use the provided objects and act on thrown exceptions, unless the suspect objects are going to be used after a lengthy process."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["As dalke says, the answer is almost always \"no\".", "In Python, you generally do not care that a a parameter is a certain type but rather that it behaves like a certain type.", "This is known as \"Duck Typing\".", "There are two ways to test whether a parameter behaves like a given type: (1) you can use it as if it behaved as you expect and throw an exception when/if it doesn't or (2) you can define an interface that describes how that type should behave and test conformance with that interface."], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": "is", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "behaves", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "Duck Typing", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Duck%5Ftyping"}, {"text": "behaves", "childNum": 0, "tag": "em", "pos": 3, "childList": []}, {"text": "behave", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["zope.interface is my prefered interface system for Python, but there are several others.", "With any one of them, you define an interface, then declare that a given type conforms to that interface or define an adaptor that turns your type into something that does conform to that interface.", "You can then assert (or test as you wish) that paramters provide (in the zope.interface terminology) that interface."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "zope.interface", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://apidoc.zope.org/%2B%2Bapidoc%2B%2B/Book/ifaceschema/interface/show.html"}]}]]