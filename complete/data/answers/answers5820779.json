[[{"text": ["If you use a regex tool, it will make your life a lot easier for troubleshooting regex.", "Try this free one - there are probably better ones, but this works great.", "You can paste your log file there, and try your regex a little bit at a time, and it will highlight matches in real time."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this free one", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://gskinner.com/RegExr/"}]}], [{"text": ["Why regex?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Consider using split to get all words.", "This will give you the timestamp directly.", "Then go through all other words, check if there's a = in them, split them again in this case and there you have your paths and other parameters nicely.", "Standard Python path handling (os.path) will aid you at getting folder and file names."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "split", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "=", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "os.path", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Of course this approach fails if your path names may contain spaces, but otherwise it is definitely worth consideration."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can do it simply by normal string processing"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f=open(\"file\")\nfor line in f:\n    date,b = line.split(\"input\")\n    print \"time: \" , date.split()[0]\n    input_path = b.split(\"output\")[0]\n    tokens=input_path.split(\"\\\\\")\n    filename=tokens[-1]\n    directory=tokens[-2].split(\"-\")[-1]\n    print filename, directory\nf.close()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using split is a good idea.", "If you really want a regex, I would do it like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (\\d\\d:\\d\\d:\\d\\d).*?input file=.*?(ABC|DEF)\\\\\\\\(.*?)\\soutput\n</code>\n</pre>\n", "senID": 1}, {"text": ["Test it here"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://rubular.com/r/3kzNiW8BHm"}]}], [{"text": ["Regular expressions are very good at solving problems like this one - i.e.", "parsing log file records.", "MarcoS's answer solves your immediate problem nicely.", "However, another approach is to write a (reusable) generalized function which decomposes a log file record into its various components and returns a match object containing all these parsed components.", "Once decomposed, tests can easily be applied to the component parts to check for various requirements (such as the input file path must end in ABC or DEF).", "Here is a python script which has just such a function: decomposeLogEntry() and demonstrates how to use it to solve your problem at hand:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "ABC", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "DEF", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "decomposeLogEntry()", "childNum": 0, "tag": "code", "pos": 5, "childList": []}]}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n import re\ndef decomposeLogEntry(text):\n    r\"\"\" Decompose log file entry into its various components.\n\n    If text is a valid log entry, return regex match object of\n    log entry components strings. Otherwise return None.\"\"\"\n    return re.match(r\"\"\"\n        # Decompose log file entry into its various components.\n        ^                            # Anchor to start of string\n        (?P&lt;time&gt;\\d\\d:\\d\\d:\\d\\d)     # Capture: time\n        \\s+\n        (?P&lt;modname&gt;\\w+?)            # Capture module name\n        \\s-\\s\\[\n        (?P&lt;msgtype&gt;[^]]+)           # Capture message type\n        \\]\n        (?P&lt;message&gt;[^!]+)           # Capture message text\n        !!\\sftp_site=\n        (?P&lt;ftpsite&gt;\\S+?)            # Capture ftp URL\n        \\sfile_dir=\n        (?P&lt;filedir&gt;\\S+?)            # Capture file directory?\n        \\sinput\\sfile=\n        (?P&lt;infile&gt;                  # Capture input path and filename\n          (?P&lt;infilepath&gt;\\S+)\\\\      # Capture input file path\n          (?P&lt;infilename&gt;[^\\s\\\\]+)   # Capture input file filename\n        )\n        \\soutput\\sfile=\n        (?P&lt;outfile&gt;                 # Capture input path and filename\n          (?P&lt;outfilepath&gt;\\S+)\\\\     # Capture output file path\n          (?P&lt;outfilename&gt;[^\\s\\\\]+)  # Capture output file filename\n        )\n        \\s*                          # Optional whitespace at end.\n        $                            # Anchor to end of string\n        \"\"\", text, re.IGNORECASE | re.VERBOSE)\n\n# Demonstrate decomposeLogEntry function. Print components of all log entries.\nf=open(\"testdata.log\")\nmcnt = 0\nfor line in f:\n    # Decompose this line into its components.\n    m = decomposeLogEntry(line)\n    if m:\n        mcnt += 1\n        print \"Match number %d\" % (mcnt)\n        print \"  Time:             %s\" % m.group(\"time\")\n        print \"  Module name:      %s\" % m.group(\"modname\")\n        print \"  Message type:     %s\" % m.group(\"time\")\n        print \"  Message:          %s\" % m.group(\"message\")\n        print \"  FTP site URL:     %s\" % m.group(\"ftpsite\")\n        print \"  Input file:       %s\" % m.group(\"infile\")\n        print \"  Input file path:  %s\" % m.group(\"infilepath\")\n        print \"  Input file name:  %s\" % m.group(\"infilename\")\n        print \"  Output file:      %s\" % m.group(\"outfile\")\n        print \"  Output file path: %s\" % m.group(\"outfilepath\")\n        print \"  Output file name: %s\" % m.group(\"outfilename\")\n        print \"\\n\",\nf.close()\n\n# Next pick out only the desired data.\nf=open(\"testdata.log\")\nmcnt = 0\nmatches = []\nfor line in f:\n    # Decompose this line into its components.\n    m = decomposeLogEntry(line)\n    if m:\n        # See if this record meets desired requirements\n        if re.search(r\"ABC$|DEF$\", m.group(\"infilepath\")):\n            matches.append(line)\nf.close()\nprint \"There were %d matching records\" % len(matches)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This function not only picks out the various parts you are interested in, it also validates the input and rejects badly formatted records.", "Once written and debugged, this function can be reused by other programs which need to analyze the log files for other requirements."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here is the output from the script when applied to your test data:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre class=\"lang-py prettyprint-override\">\n<code>\n r\"\"\"\nMatch number 1\n  Time:             08:38:36\n  Module name:      TestModule\n  Message type:     08:38:36\n  Message:          result success\n  FTP site URL:     ftp.test.com\n  Input file:       \\root\\level1\\level2-ABC\\2C.013000000B.dat\n  Input file path:  \\root\\level1\\level2-ABC\n  Input file name:  2C.013000000B.dat\n  Output file:      c:\\local\\project1\\data\\2C.013000000B.dat.ext\n  Output file path: c:\\local\\project1\\data\n  Output file name: 2C.013000000B.dat.ext\n\nMatch number 2\n  Time:             06:40:37\n  Module name:      TestModule\n  Message type:     06:40:37\n  Message:          result success\n  FTP site URL:     ftp.test.com\n  Input file:       \\root\\level1\\level2-ABC\\20100722B.TXT\n  Input file path:  \\root\\level1\\level2-ABC\n  Input file name:  20100722B.TXT\n  Output file:      c:\\local\\project1\\data\\20100722B.TXT.ext\n  Output file path: c:\\local\\project1\\data\n  Output file name: 20100722B.TXT.ext\n\nMatch number 3\n  Time:             06:40:39\n  Module name:      TestModule\n  Message type:     06:40:39\n  Message:          result success\n  FTP site URL:     ftp.test.com\n  Input file:       \\root\\level1\\level2-DEF\\20100722D1-XYZ.TXT\n  Input file path:  \\root\\level1\\level2-DEF\n  Input file name:  20100722D1-XYZ.TXT\n  Output file:      c:\\local\\project1\\data\\20100722D1-YFP.TXT.ext\n  Output file path: c:\\local\\project1\\data\n  Output file name: 20100722D1-YFP.TXT.ext\n\nMatch number 4\n  Time:             06:40:42\n  Module name:      TestModule\n  Message type:     06:40:42\n  Message:          result success\n  FTP site URL:     ftp.test.com\n  Input file:       \\root\\level1\\level2-DEF\\2C.250B\n  Input file path:  \\root\\level1\\level2-DEF\n  Input file name:  2C.250B\n  Output file:      c:\\local\\project1\\data\\2C.250B.ext\n  Output file path: c:\\local\\project1\\data\n  Output file name: 2C.250B.ext\n\nThere were 4 matching records\n\"\"\"\n</code>\n</pre>\n", "senID": 4}], [{"text": ["This worked for your examples:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n r'(\\d\\d:\\d\\d:\\d\\d).*(ABC|DEF).*?([^\\\\]*)\\soutput.*'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Although a well written regular expression is appropriate here, I would have approached this differently.", "Most specifically, os.path.split is designed to separate filenames from base paths, and deals with all the corner cases that this regular expression ignores."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "os.path.split", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]