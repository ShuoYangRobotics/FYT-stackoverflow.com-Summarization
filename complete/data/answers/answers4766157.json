[[{"text": ["So you have two lists: the list of words you want to check and possibly remove, and a list of valid words.", "If you like, you can use the same list for both purposes, but I'll assume you have two lists."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For speed, you should turn your list of valid words into a set.", "Then you can very quickly check to see if any particular word is in that set.", "Then, take each word, and check whether all its prefixes exist in the valid words list or not.", "Since \"a\" and \"I\" are valid words in English, will you remove all valid words starting with 'a', or will you have a rule that sets a minimum length for the prefix?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I am using the file /usr/share/dict/words from my Ubuntu install.", "This file has all sorts of odd things in it; for example, it seems to contain every letter by itself as a word.", "Thus \"k\" is in there, \"q\", \"z\", etc.", "None of these are words as far as I know, but they are probably in there for some technical reason.", "Anyway, I decided to simply exclude anything shorter than three letters from my valid words list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here is what I came up with:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # build valid list from /usr/dict/share/words\nwfile = \"/usr/dict/share/words\"\nvalid = set(line.strip() for line in open(wfile) if len(line) &gt;= 3)\n\nlst = [\"ark\", \"booze\", \"kite\", \"live\", \"rodeo\"]\n\ndef subwords(word):\n    for i in range(len(word) - 1, 0, -1):\n        w = word[:i]\n        yield w\n\nnewlst = []\nfor word in lst:\n    # uncomment these for debugging to make sure it works\n    # print \"subwords\", [w for w in subwords(word)]\n    # print \"valid subwords\", [w for w in subwords(word) if w in valid]\n    if not any(w in valid for w in subwords(word)):\n        newlst.append(word)\n\nprint(newlst)\n</code>\n</pre>\n", "senID": 4}, {"text": ["If you are a fan of one-liners, you could do away with the for list and use a list comprehension:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n newlst = [word for word in lst if not any(w in valid for w in subwords(word))]\n</code>\n</pre>\n", "senID": 6}, {"text": ["I think that's more terse than it should be, and I like being able to put in the print statements to debug."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Hmm, come to think of it, it's not too terse if you just add another function:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def keep(word):\n    return not any(w in valid for w in subwords(word))\n\nnewlst = [word for word in lst if keep(word)]\n</code>\n</pre>\n", "senID": 9}, {"text": ["Python can be easy to read and understand if you make functions like this, and give them good names."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["I'm assuming that you only have one list from which you want to remove any elements that have prefixes in that same list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #Important assumption here... wordlist is sorted\n\nbase=wordlist[0]                      #consider the first word in the list\nfor word in wordlist:                 #loop through the entire list checking if\n    if not word.startswith(base):     # the word we're considering starts with the base\n        print base                    #If not... we have a new base, print the current\n        base=word                     #  one and move to this new one\n    #else word starts with base\n        #don't output word, and go on to the next item in the list\nprint base                            #finish by printing the last base\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: Added some comments to make the logic more obvious"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I find jkerian's asnwer to be the best (assuming only one list) and I would like to explain why."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is my version of the code (as a function):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n wordlist = [\"a\",\"arc\",\"arcane\",\"apple\",\"car\",\"carpenter\",\"cat\",\"zebra\"];\n\ndef root_words(wordlist):\n    result = []\n    base = wordlist[0]\n    for word in wordlist:\n        if not word.startswith(base):\n            result.append(base)\n            base=word\n    result.append(base)\n    return result;\n\nprint root_words(wordlist);\n</code>\n</pre>\n", "senID": 2}, {"text": ["As long as the word list is sorted (you could do this in the function if you wanted to), this will get the result in a single parse.", "This is because when you sort the list, all words made up of another word in the list, will be directly after that root word.", "e.g.", "anything that falls between \"arc\" and \"arcane\" in your particular list, will also be eliminated because of the root word \"arc\"."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You should use the built-in  lambda function for this.", "I think it'll make your life a lot easier"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n words = ['rode', 'nick'] # this is the list of all the words that you have.\n                         # I'm using 'rode' and 'nick' as they're in your example\nlistOfWordsToTry = ['rodeo', 'snicker']\ndef validate(w):\n    for word in words:\n        if w.startswith(word):\n            return False\n    return True\n\nwordsThatDontStartWithValidEnglishWords = \\\n    filter(lambda x : validate(x), listOfWordsToTry)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This should work for your purposes, unless I misunderstand your question."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Hope this helps"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I wrote an answer that assumes two lists, the list to be pruned and the list of valid words.", "In the discussion around my answer, I commented that maybe a trie solution would be good."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What the heck, I went ahead and wrote it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can read about a trie here:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://en.wikipedia.org/wiki/Trie"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://en.wikipedia.org/wiki/Trie", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Trie"}]}, {"text": ["For my Python solution, I basically used dictionaries.", "A key is a sequence of symbols, and each symbol goes into a dict, with another Trie instance as the data.", "A second dictionary stores \"terminal\" symbols, which mark the end of a \"word\" in the Trie.", "For this example, the \"words\" are actually words, but in principle the words could be any sequence of hashable Python objects."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The Wikipedia example shows a trie where the keys are letters, but can be more than a single letter; they can be a sequence of multiple letters.", "For simplicity, my code uses only a single symbol at a time as a key."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["If you add both the word \"cat\" and the word \"catch\" to the trie, then there will be nodes for 'c', 'a', and 't' (and also the second 'c' in \"catch\").", "At the node level for 'a', the dictionary of \"terminals\" will have 't' in it (thus completing the coding for \"cat\"), and likewise at the deeper node level of the second 'c' the dictionary of terminals will have 'h' in it (completing \"catch\").", "So, adding \"catch\" after \"cat\" just means one additional node and one more entry in the terminals dictionary.", "The trie structure makes a very efficient way to store and index a really large list of words."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def _pad(n):\n    return \" \" * n\n\nclass Trie(object):\n    def __init__(self):\n        self.t = {}  # dict mapping symbols to sub-tries\n        self.w = {}  # dict listing terminal symbols at this level\n\n    def add(self, word):\n        if 0 == len(word):\n            return\n        cur = self\n        for ch in word[:-1]: # add all symbols but terminal\n            if ch not in cur.t:\n                cur.t[ch] = Trie()\n            cur = cur.t[ch]\n        ch = word[-1]\n        cur.w[ch] = True  # add terminal\n\n    def prefix_match(self, word):\n        if 0 == len(word):\n            return False\n        cur = self\n        for ch in word[:-1]: # check all symbols but last one\n            # If you check the last one, you are not checking a prefix,\n            # you are checking whether the whole word is in the trie.\n            if ch in cur.w:\n                return True\n            if ch not in cur.t:\n                return False\n            cur = cur.t[ch]  # walk down the trie to next level\n        return False\n\n    def debug_str(self, nest, s=None):\n        \"print trie in a convenient nested format\"\n        lst = []\n        s_term = \"\".join(ch for ch in self.w)\n        if 0 == nest:\n            lst.append(object.__str__(self))\n            lst.append(\"--top--: \" + s_term)\n        else:\n            tup = (_pad(nest), s, s_term)\n            lst.append(\"%s%s: %s\" % tup)\n        for ch, d in self.t.items():\n            lst.append(d.debug_str(nest+1, ch))\n        return \"\\n\".join(lst)\n\n    def __str__(self):\n        return self.debug_str(0)\n\n\n\nt = Trie()\n\n\n# Build valid list from /usr/dict/share/words, which has every letter of\n# the alphabet as words!  Only take 2-letter words and longer.\n\nwfile = \"/usr/share/dict/words\"\nfor line in open(wfile):\n    word = line.strip()\n    if len(word) &gt;= 2:\n        t.add(word)\n\n# add valid 1-letter English words\nt.add(\"a\")\nt.add(\"I\")\n\n\n\nlst = [\"ark\", \"booze\", \"kite\", \"live\", \"rodeo\"]\n# \"ark\" starts with \"a\"\n# \"booze\" starts with \"boo\"\n# \"kite\" starts with \"kit\"\n# \"live\" is good: \"l\", \"li\", \"liv\" are not words\n# \"rodeo\" starts with \"rode\"\n\nnewlst = [w for w in lst if not t.prefix_match(w)]\n\nprint(newlst)  # prints: ['live']\n</code>\n</pre>\n", "senID": 7}], [{"text": ["I don't want to provide an exact solution, but I think there are two key functions in Python that will help you greatly here. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The first, jkerian mentioned: string.startswith() http://docs.python.org/library/stdtypes.html#str.startswith"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/stdtypes.html#str.startswith", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#str.startswith"}]}, {"text": ["The second: filter() http://docs.python.org/library/functions.html#filter"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://docs.python.org/library/functions.html#filter", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#filter"}]}, {"text": ["With filter, you could write a conditional function that will check to see if a word is the base of another word and return true if so. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["For each word in the list, you would need to iterate over all of the other words and evaluate the conditional using filter, which could return the proper subset of root words."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]