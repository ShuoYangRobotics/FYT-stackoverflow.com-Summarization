[[{"text": ["@Staale"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There is a better way:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n job = dict(zip(keys, values))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I'd say that a dictionary is definitely the best way to do it.", "It's easily extensible, allows you to give each value a sensible name, and Python has a lot of built-in language features for using and manipulating dictionaries.", "If you need to add more fields later, all you need to change is the code that converts the tuple to a dictionary and the code that actually makes use of the new values."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n job={}\njob['jobid'], job['label'], job['username']=&lt;querycode&gt;\n</code>\n</pre>\n", "senID": 2}], [{"text": ["This is an old question, but..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I'd suggest using a named tuple in this situation: collections.namedtuple"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "collections.namedtuple", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/3.1/library/collections.html#collections.namedtuple"}]}, {"text": ["This is the part, in particular, that you'd find useful:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Perhaps this is overkill for your case, but I would be tempted to create a \"Job\" class that takes the tuple as its constructor argument and has respective properties on it.", "I'd then pass instances of this class around instead."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I would use a dictionary.", "You can convert the tuple to a dictionary this way:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n values = &lt;querycode&gt;\nkeys = [\"jobid\", \"label\", \"username\"]\njob = dict([[keys[i], values [i]] for i in xrange(len(values ))])\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will first create an array [[\"jobid\", val1], [\"label\", val2], [\"username\", val3]] and then convert that to a dictionary.", "If the result order or count changes, you just need to change the list of keys to match the new result."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["PS still fresh on Python myself, so there might be better ways off doing this."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["An old question, but since no one mentioned it I'll add this from the Python Cookbook: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Recipe 81252: Using dtuple for Flexible Query Result Access"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Recipe 81252: Using dtuple for Flexible Query Result Access", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/81252/"}]}, {"text": ["This recipe is specifically designed for dealing with database results, and the dtuple solution allows you to access the results by name OR index number.", "This avoids having to access everything by subscript which is very difficult to maintain, as noted in your question."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["With a tuple it will always be a hassle to add or change fields.", "You're right that a dictionary will be much better. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want something with slightly friendlier syntax you might want to take a look at the answers this question about a simple 'struct-like' object.", "That way you can pass around an object, say job, and access its fields even more easily than a tuple or dict:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "this question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/35988/c-like-structures-in-python"}, {"text": "job", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n job.jobId, job.username = jobId, username\n</code>\n</pre>\n", "senID": 2}], [{"text": ["If you're using the MySQLdb package, you can set up your cursor objects to return dicts instead of tuples."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import MySQLdb, MySQLdb.cursors\nconn = MySQLdb.connect(..., cursorclass=MySQLdb.cursors.DictCursor)\ncur = conn.cursor() # a DictCursor\ncur2 = conn.cursor(cursorclass=MySQLdb.cursors.Cursor) # a \"normal\" tuple cursor\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class TypedTuple:\n    def __init__(self, fieldlist, items):\n       self.fieldlist = fieldlist\n       self.items = items\n    def __getattr__(self, field):\n       return self.items[self.fieldlist.index(field)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could then do:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n j = TypedTuple([\"jobid\", \"label\", \"username\"], job)\nprint j.jobid\n</code>\n</pre>\n", "senID": 3}, {"text": ["It should be easy to swap self.fieldlist.index(field) with a dictionary lookup later on... just edit your __init__ method!", "Something like Staale does."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "self.fieldlist.index(field)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}]]