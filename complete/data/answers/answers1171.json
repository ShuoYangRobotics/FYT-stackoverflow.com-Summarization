[[{"text": ["I would strongly advocate you look at NetworkX.", "It's a battle-tested war horse and the first tool most 'research' types reach for when they need to do analysis of network based data.", "I have manipulated graphs with 100s of thousands of edges without problem on a notebook.", "Its feature rich and very easy to use.", "You will find yourself focusing more on the problem at hand rather than the details in the underlying implementation."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "NetworkX", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://networkx.lanl.gov/wiki"}]}, {"text": ["Example ofErd\u0151s-R\u00e9nyirandom graph generation and analysis"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Example ofErd\u0151s-R\u00e9nyirandom graph generation and analysis", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "Erd\u0151s-R\u00e9nyi", "tag": "a"}]}, {"href": "http://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model", "text": "Erd\u0151s-R\u00e9nyi", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n \"\"\"\nCreate an G{n,m} random graph with n nodes and m edges\nand report some properties.\n\nThis graph is sometimes called the Erd##[m~Qs-R\u00e9nyi graph\nbut is different from G{n,p} or binomial_graph which is also\nsometimes called the Erd##[m~Qs-R\u00e9nyi graph.\n\"\"\"\n__author__ = \"\"\"Aric Hagberg (hagberg@lanl.gov)\"\"\"\n__credits__ = \"\"\"\"\"\"\n#    Copyright (C) 2004-2006 by \n#    Aric Hagberg \n#    Dan Schult \n#    Pieter Swart \n#    Distributed under the terms of the GNU Lesser General Public License\n#    http://www.gnu.org/copyleft/lesser.html\n\nfrom networkx import *\nimport sys\n\nn=10 # 10 nodes\nm=20 # 20 edges\n\nG=gnm_random_graph(n,m)\n\n# some properties\nprint \"node degree clustering\"\nfor v in nodes(G):\n    print v,degree(G,v),clustering(G,v)\n\n# print the adjacency list to terminal \nwrite_adjlist(G,sys.stdout)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Visualizations are also straightforward:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"src": "http://www.visualcomplexity.com/vc/images/376_big01.jpg", "tag": "img", "senID": 4}, {"text": ["More visualization: http://jonschull.blogspot.com/2008/08/graph-visualization.html"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "http://jonschull.blogspot.com/2008/08/graph-visualization.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://jonschull.blogspot.com/2008/08/graph-visualization.html"}]}], [{"text": ["A dictionary may also contain overhead, depending on the actual implementation.", "A hashtable usually contain some prime number of available nodes to begin with, even though you might only use a couple of the nodes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Judging by your example, \"Property\", would you be better of with a class approach for the final level and real properties?", "Or is the names of the properties changing a lot from node to node?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I'd say that what \"efficient\" means depends on a lot of things, like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "speed of updates (insert, update, delete)", "tag": "none", "senID": 3}, {"text": "speed of random access retrieval", "tag": "none", "senID": 4}, {"text": "speed of sequential retrieval", "tag": "none", "senID": 5}, {"text": "memory used", "tag": "none", "senID": 6}]}, {"text": ["I think that you'll find that a data structure that is speedy will generally consume more memory than one that is slow.", "This isn't always the case, but most data structures seems to follow this."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["A dictionary might be easy to use, and give you relatively uniformly fast access, it will most likely use more memory than, as you suggest, lists.", "Lists, however, generally tend to contain more overhead when you insert data into it, unless they preallocate X nodes, in which they will again use more memory."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["My suggestion, in general, would be to just use the method that seems the most natural to you, and then do a \"stress test\" of the system, adding a substantial amount of data to it and see if it becomes a problem."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["You might also consider adding a layer of abstraction to your system, so that you don't have to change the programming interface if you later on need to change the internal data structure."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["As I understand it, random access is in constant time for both Python's dicts and lists, the difference is that you can only do random access of integer indexes with lists.", "I'm assuming that you need to lookup a node by its label, so you want a dict of dicts."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, on the performance front, loading it into memory may not be a problem, but if you use too much you'll end up swapping to disk, which will kill the performance of even Python's highly efficient dicts.", "Try to keep memory usage down as much as possible.", "Also, RAM is amazingly cheap right now; if you do this kind of thing a lot, there's no reason not to have at least 4GB."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you'd like advice on keeping memory usage down, give some more information about the kind of information you're tracking for each node."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As already mentioned, NetworkX is very good, with another option being igraph.", "Both modules will have most (if not all) the analysis tools you're likely to need, and both libraries are routinely used with large networks."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "igraph", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cneurocvs.rmki.kfki.hu/igraph/"}]}], [{"text": ["Making a class-based structure would probably have more overhead than the dict-based structure, since in python classes actually use dicts when they are implemented."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["even though this question is now quite old, I think it is worthwhile to mention my own python module for graph manipulation called graph-tool.", "It is very efficient, since the data structures and algorithms are implemented in C++, with template metaprograming, using the Boost Graph Library.", "Therefore its performance (both in memory usage and runtime) is comparable to a pure C++ library, and can be orders of magnitude better than typical python code, without sacrificing ease of use.", "I use it myself constantly to work with very large graphs."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "graph-tool", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://graph-tool.skewed.de"}]}]]