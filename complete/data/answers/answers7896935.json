[[{"text": ["The first approach is reasonable and isn't conceptually different from what set.union and set.intersection do.", "Any func(Point, Point) --&gt; Point is clearly related to the Point class, so there is no question about interfering with the unity or cohesion of the class."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "set.union", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "set.intersection", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "func(Point, Point) --&gt; Point", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["It would be a tougher choice if different classes were involved:  draw_perpendicular(line, point) --&gt; line.", "To resolve the choice of classes, you would pick the one that has the most related logic.", "For example, str.join needs a string delimiter and a list of strings.", "It could have been a standalone function (as it was in the old days with the string module), or it could be a method on lists (but it only works for lists of strings), or a method on strings.", "The latter was chosen because joining is more about strings than it is about lists.", "This choice was made eventhough it led to the arguably awkward expression delimiter.join(things_to_join)."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "draw_perpendicular(line, point) --&gt; line", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "str.join", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "delimiter.join(things_to_join)", "childNum": 0, "tag": "code", "pos": 5, "childList": []}]}, {"text": ["I disagree with the other respondent who recommended using a classmethod.", "Those are often used for alternate constructor signatures but not for transformations on instances of the class.", "For example, datetime.fromordinal is a classmethod for constructing a date from something other than an instance of the class (in this case, an from an int).", "This contrasts with datetime.replace which is a regular method for making a new datetime instance based on an existing instance.", "This should steer you away from using classmethod for the midpoint computation."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "datetime.fromordinal", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "int", "childNum": 0, "tag": "em", "pos": 4, "childList": []}, {"text": "datetime.replace", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["One other thought: if you keep midpoint() with the Point() class, it makes it possible to create other classes that have the same Point API but a different internal representation (i.e.", "polar coordinates may be more convenient for some types of work than Cartesian coordinates).", "If midpoint() is a separate function you start to lose the benefits of encapsulation and of a coherent interface."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I would choose the second option because, in my opinion, it is clearer than the first.", "You are performing the midpoint operation between two points; not the midpoint operation with respect to a point.", "Similarly, a natural extension of this interface could be to define dot, cross, magnitude, average, median, etc.", "Some of those functions will operate on pairs of Points and others may operate on lists.", "Making it a function makes them all have consistent interfaces."], "childNum": 8, "tag": "p", "senID": 0, "childList": [{"text": "between", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "respect", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "dot", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "cross", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "magnitude", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "average", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "median", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Points", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Defining it as a function also allows it to be used with any pair of objects that present a .x .y interface, while making it a method requires that at least one of the two is a Point."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": ".x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".y", "childNum": 0, "tag": "code", "childList": []}, {"text": "Point", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Lastly, to address the location of the function, I believe it makes sense to co-locate it in the same package as the Point class.", "This places it in the same namespace, which clearly indicates its relationship with Point and, in my opinion, is more pythonic than a static or class method."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Point", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Update:\nFurther reading on the Pythonicness of @staticmethod vs package/module:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "@staticmethod", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In both Thomas Wouter's answer to the question What is the difference between staticmethod and classmethod in Python and Mike Steder's answer to initand arguments in Python, the authors indicated that a package or module of related functions is perhaps a better solution.", "Thomas Wouter has this to say:"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "What is the difference between staticmethod and classmethod in Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python/136138#136138"}, {"text": "initand arguments in Python", "tag": "a", "pos": -1, "childList": [{"text": "init", "tag": "strong"}], "childNum": 1, "href": "http://stackoverflow.com/questions/5169257/init-and-arguments-in-python/5169458#5169458"}, {"text": "init", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["While Mike Steder comments:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["However, codeape rightly points out below that a calling convention of Point.midpoint(a,b) will co-locate the functionality with the type.", "The BDFL also seems to value @staticmethod as the __new__ method is a staticmethod."], "childNum": 5, "tag": "p", "senID": 6, "childList": [{"text": "Point.midpoint(a,b)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "@staticmethod", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__new__", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://www.python.org/download/releases/2.2/descrintro/#staticmethods", "text": "staticmethod", "childNum": 1, "tag": "a", "childList": [{"text": "staticmethod", "tag": "code"}]}, {"text": "staticmethod", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["My personal preference would be to use a function for the reasons cited above, but it appears that the choice between @staticmethod and a stand-alone function are largely in the eye of the beholder."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "@staticmethod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["In this case you can use operator overloading:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import namedtuple\n\nclass Point(namedtuple('Point', 'x y')):\n    __slots__ = ()\n    #Attached to class\n    def __add__(self, otherpoint):\n        mx = (self.x + otherpoint.x)\n        my = (self.y + otherpoint.y)\n        return Point(mx, my)\n\n    def __div__(self, scalar):\n        return Point(self.x/scalar, self.y/scalar)\n\n\na = Point(1.0, 2.0)\nb = Point(2.0, 3.0)\n\ndef mid(a,b): # general function\n    return (a+b)/2\n\nprint mid(a,b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think the decision mostly depends on how general and abstract the function is.", "If you can write the function in a way that works on all objects that implement a small set of clean interfaces, then you can turn it into a separate function.", "The more interfaces your function depends on and the more specific they are, the more it makes sense to put it on the class (as instances of this class will most likely be the only objects the function will work with anyways). "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "small set of clean interfaces", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["I would choose version one, because this way all functionality for points is stored in the point class, i.e.", "grouping related functionality.", "Additionally, point objects know best about the meaning and inner workings of their data, so it's the right place to implement your function.", "An external function, for example in C++, would have to be a friend, which smells like a hack."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Another option is to use a @classmethod.", "It is probably what I would prefer in this case."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@classmethod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Point(...):\n    @classmethod\n    def midpoint(cls, p1, p2):\n        mx = (p1.x + p2.x) / 2.0\n        my = (p1.y + p2.y) / 2.0\n        return cls(mx, my)\n\n# ...\nprint Point.midpoint(a, b)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["A different way of doing this is to access x and y through the namedtuple's subscript interface.", "You can then completely generalize the midpoint function to n dimensions."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "midpoint", "childNum": 0, "tag": "code", "childList": []}, {"text": "n", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n class Point(namedtuple('Point', 'x y')):\n    __slots__ = ()\n\ndef midpoint(left, right):\n    return tuple([sum(a)/2. for a in zip(left, right)])\n</code>\n</pre>\n", "senID": 1}, {"text": ["This design works for Point classes, n-tuples, lists of length n, etc.", "For example:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "n", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "n", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; midpoint(Point(0,0), Point(1,1))\n(0.5, 0.5)\n&gt;&gt;&gt; midpoint(Point(5,1), (3, 2))\n(4.0, 1.5)\n&gt;&gt;&gt; midpoint((1,2,3), (4,5,6))\n(2.5, 3.5, 4.5)\n</code>\n</pre>\n", "senID": 3}]]