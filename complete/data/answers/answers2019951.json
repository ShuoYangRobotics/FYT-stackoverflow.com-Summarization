[[{"text": ["With a little bit of LINQ:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n var q = from el in li\n        orderby foo(el)\n        select el;\nli = q.ToList();\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The Haskell solution is particularly elegant with the on combinator from Data.Function."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "on", "tag": "a", "pos": 0, "childList": [{"text": "on", "tag": "code"}], "childNum": 1, "href": "http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/Data-Function.html#v%3Aon"}, {"text": "on", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import Data.Function (on)\nimport Data.List (sortBy)\n\nlists = [ [ 5, 6, 8 ]\n        , [ 1, 2, 3 ]\n        ]\n\nmain = do\n  print $ sortBy (compare `on` foo) lists\n  where\n    foo = sum\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:\n[[1,2,3],[5,6,8]]"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[[1,2,3],[5,6,8]]", "childNum": 0, "tag": "pre", "pos": 0, "childList": []}]}, {"text": ["There's also comparing from Data.Ord that lets us instead write"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "comparing", "tag": "a", "pos": 0, "childList": [{"text": "comparing", "tag": "code"}], "childNum": 1, "href": "http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/Data-Ord.html#v%3Acomparing"}, {"text": "comparing", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n main = do\n  print $ sortBy (comparing foo) lists\n  where\n    foo = sum\n</code>\n</pre>\n", "senID": 4}, {"text": ["The definition ofcomparing is a straightforward"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "definition ofcomparing", "tag": "a", "pos": 0, "childList": [{"text": "comparing", "tag": "code"}], "childNum": 1, "href": "http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/src/Data-Ord.html#comparing"}, {"text": "comparing", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n comparing :: (Ord a) =&gt; (b -&gt; a) -&gt; b -&gt; b -&gt; Ordering\ncomparing p x y = compare (p x) (p y)\n</code>\n</pre>\n", "senID": 6}, {"text": ["but we could also define it in terms of on:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "on", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n comparing :: (Ord b) =&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; Ordering\ncomparing f = compare `on` f\n</code>\n</pre>\n", "senID": 8}, {"text": ["or completely point-free with"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n comparing :: (Ord b) =&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; Ordering\ncomparing = (compare `on`)\n</code>\n</pre>\n", "senID": 10}, {"text": ["Haskell manipulates functions as powerfully as Perl manipulates strings."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["This is the Python way: Just pass the function as the key argument to sorted() or .sort():"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "key", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sorted()", "childNum": 0, "tag": "code", "childList": []}, {"text": ".sort()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; mylist = [123, 765, 4, 13]\n&gt;&gt;&gt; def mod5(x):\n...     return x%5\n...\n&gt;&gt;&gt; sorted(mylist, key = mod5)\n[765, 123, 13, 4]\n&gt;&gt;&gt; sorted(mylist, key = mod5, reverse = True)\n[4, 123, 13, 765]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Ruby:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n mylist = [[1,2,3],\n             [3,5,9],\n             [1,1,1],\n             [10,23,14]]\n\nsortedlist = mylist.sort {|a,b| b.inject {|sum, n| sum + n } &lt;=&gt; a.inject {|sum,n| sum + n}}\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'm not sure the rules of Code Golf and I didn't write a foo method, but the sum could easily occur in foo."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["My test output:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n puts sortedlist.inspect\n</code>\n</pre>\n", "senID": 4}, {"text": ["[[10, 23, 14], [3, 5, 9], [1, 2, 3], [1, 1, 1]]"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["In Perl, this is often done with the well-known Schwartzian transform."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Schwartzian transform", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Schwartzian_transform"}]}, {"code": "<pre>\n<code>\n use List::Util qw(sum);\n@li = map {$$_[0]} sort {$$a[1] &lt;=&gt; $$b[1]} map {[$_, sum(@$_)]} @li;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Reusing Sort::Key is better, though."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Sort::Key", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/perldoc?Sort%3A%3AKey"}]}, {"code": "<pre>\n<code>\n use List::Util qw(sum);\nuse Sort::Key qw(nkeysort);\n@li = nkeysort {sum(@$_)} @li;\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Any other language?", "Ok, here's some F#:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Example: sort by sum:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n let foo = List.sum\nlet li = [[1;2];[42;1];[3;4]]\n\nlet result = li |&gt; List.sortBy (fun el -&gt; foo el)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Result (F# interactive):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n val result : int list list = [[1; 2]; [3; 4]; [42; 1]]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Golfed:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n let result = li |&gt; List.sortBy (fun el -&gt; foo el)\n//shorter\nlet res = li |&gt; List.sortBy foo\n//evn shrtr\nlet r=List.sortBy foo li\n</code>\n</pre>\n", "senID": 6}, {"text": ["The C# version:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n var result = li.OrderBy(el=&gt;el.Sum());\n</code>\n</pre>\n", "senID": 8}], [{"text": ["in erlang:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n -module (codegolfs).\n-export ([sortmain/0]).\n\nsortmain() -&gt;\n    sort( \n    fun (SubList) -&gt; lists:sum(SubList) end,\n    [ [1,2,3],[1,3],[2,5,6] ]).\n    % output: [[2,5,6],[1,2,3],[1,3]]\n\nsort(Fun,List) -&gt;\n    lists:sort( fun(A,B) -&gt; Fun(A) &lt; Fun(B) end,List ).\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Ruby (shamelessly copying Beanish's input data):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n list = [\n  [1, 2, 3],\n  [3, 5, 9],\n  [1, 1, 1],\n  [10, 23, 14]\n]\n\np list.sort_by { |a| -a.inject(&amp;:+) }\n# =&gt; [[10, 23, 14], [3, 5, 9], [1, 2, 3], [1, 1, 1]]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Clojure:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (let [lst '((1 2 3)  (3 5 9) (1 1 1) (10 23 14))]   \n (sort #(&gt; (foo %1) (foo %2)) lst))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could adapt any of the popular sorting routines to do this.", "Just use foo(x) for comparison rather than x. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Tcl: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n proc foo nums {tcl::mathop::+ {*}$nums}\nset l {{1 2 3} {4 5 6} {3} {42 -40}}\nlsort -command {apply {{a b} {expr {[foo $a] - [foo $b]}}}} $l\n# =&gt; {42 -40} 3 {1 2 3} {4 5 6}\n</code>\n</pre>\n", "senID": 1}]]