[[{"text": ["Using the test code suggested by your link, I tested my Python installation and confirmed that it indeed leaks.", "But, if, as @Russell suggested, I put each urlopen in its own process, the OS should clean up the memory leaks.", "In my tests, memory, unreachable objects and open files all remain more or less constant.", "I split the code into two files:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "urlopen", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "should", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import cPickle, urllib2\n\ndef connectFunction(queryString):\n    conn = urllib2.urlopen('http://something.com/foo.php?parameter='+str(queryString))\n    data = conn.read()\n    outfile = ('sometempfile'. 'wb')\n    cPickle.dump(data, outfile)\n    outfile.close()\n\nif __name__ == '__main__':\n    connectFunction(sys.argv[1])\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n<code>\n ###launcher.py\nimport subprocess, cPickle\n\n#code from your link to check the number of unreachable objects\n\ndef print_unreachable_len():\n    # check memory on memory leaks\n    import gc\n    gc.set_debug(gc.DEBUG_SAVEALL)\n    gc.collect()\n    unreachableL = []\n\n    for it in gc.garbage:\n        unreachableL.append(it)\n    return len(str(unreachableL))\n\n    #my code\n    if __name__ == '__main__':        \n        print 'Before running a single process:', print_unreachable_len()\n        return_value_list = []\n        for i, value in enumerate(values): #where values is a list or a generator containing (or yielding) the parameters to pass to the URL\n             subprocess.call(['python', 'connection.py', str(value)])\n             print 'after running', i, 'processes:', print_unreachable_len()\n             infile = open('sometempfile', 'rb')\n             return_value_list.append(cPickle.load(infile))\n             infile.close()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Obviously, this is sequential, so you will only execute a single connection at a time, which may or may not be an issue for you.", "If it is, you will have to find a non-blocking way of communicating with the processes you're launching, but I'll leave that as an exercise for you."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["EDIT: On re-reading your question, it seems you don't care about the server response.", "In that case, you can get rid of all the pickling related code.", "And obviously, you won't have the print_unreachable_len() related bits in your final code either."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "print_unreachable_len()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["This seems like a (very!", ") hacky workaround, but a bit of googling found this comment on the problem:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this comment", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.mail-archive.com/python-bugs-list@python.org/msg36857.html"}]}, {"text": ["Apparently adding f.read(1) will stop the leaking!"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "f.read(1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import urllib2\nf = urllib2.urlopen('http://www.google.com')\nf.read(1)\nf.close()\n</code>\n</pre>\n", "senID": 2}, {"text": ["EDIT: oh, I see you already have f.read(1)...", "I'm all out of ideas then :/"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "f.read(1)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Consider using the low-level socket API (related howto) instead of urllib2."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "socket API", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/socket.html"}, {"href": "http://docs.python.org/howto/sockets.html", "text": "howto", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n HOST = 'daring.cwi.nl'    # The remote host\nPORT = 50007              # The same port as used by the server\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((HOST, PORT))\ns.send('GET /path/to/file/index.html HTTP/1.0\\n\\n')\n\n # you'll need to figure out how much data to read and read that exactly\n # or wait for read() to return data of zero length (I think!)\nDATA_SZ = 1024\ndata    = s.recv(DATA_SZ)\ns.close()\nprint 'Received', repr(data)\n</code>\n</pre>\n", "senID": 1}, {"text": ["How to execute and read a HTTP request via low-level sockets is a bit beyond the scope of the question (and perhaps may make a good question on its own on stackoverflow &mdash; I searched but didn't see it), but I hope this points you in the direction of a solution that may resolve your problem!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["edit An answer in here about using makefile may be helpful: HTTP basic authentication using sockets in python"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "edit", "childNum": 0, "tag": "b", "pos": 0, "childList": []}, {"text": "makefile", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://stackoverflow.com/questions/2929532/http-basic-authentication-using-sockets-in-python", "text": "HTTP basic authentication using sockets in python", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["This does not leak for me with Python 2.6.1 on a Mac.", "Which version are you using?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["BTW, your program doesn't work due to a few typos.", "Here is one that does work: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import urllib2, httplib, gc\nvalue = \"foo\"\ncount = 0\nwhile(True):\n    url = \"http://192.168.1.1/?parameter=\" + value \n    f = urllib2.urlopen(url)\n    f.read(1)\n    f.fp._sock.recv=None # hacky avoidance\n    f.close()\n    del f\n    print \"count=\",count\n    count += 1\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Depending on platform and python version, python might not release memory back to OS.", "See this stackoverflow thread.", "That said, python should not endlessly consume memory.", "Judging from the code you use, it appears to be bug in python runtime unless, urllib/sockets use globals which I don't believe it does - blame it on Python on S60! "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "stackoverflow thread", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3935675/python-reclaiming-memory-after-deleting-items-in-a-dictionary/3935766#3935766"}, {"text": "unless", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"text": ["Have you considered other sources of memory leakage?", "Endless log file open, ever increasing array or smth like that?", "If it truly is a bug in sockets interface, then your only option is to use the subprocess approach."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I think this is probably your problem.", "To summarize that thread, there's a memory leak in Pys60's DNS lookup, and you can work around it by moving DNS lookup outside the inner loop."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://discussion.forum.nokia.com/forum/showthread.php?187767-urllib-out-of-memory"}]}]]