[[{"text": ["How about the following (in Python):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n prev = None\nfor line in sorted(open('file')):\n  line = line.strip()\n  if prev is not None and not line.startswith(prev):\n    print prev\n  prev = line\nif prev is not None:\n  print prev\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you find memory usage an issue, you can do the sort as a pre-processing step using Unix sort (which is disk-based) and change the script so that it doesn't read the entire file into memory."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "sort", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://vkundeti.blogspot.com/2008/03/tech-algorithmic-details-of-unix-sort.html", "text": "disk-based", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["awk '{x[$1 \" \" $2 \" \" $3] = $0} END {for (y in x) print x[y]}'"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "awk '{x[$1 \" \" $2 \" \" $3] = $0} END {for (y in x) print x[y]}'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you need to specify the number of columns for different files:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n awk -v ncols=3 '\n  {\n    key = \"\";\n    for (i=1; i&lt;=ncols; i++) {key = key FS $i}\n    if (length($0) &gt; length(x[key])) {x[key] = $0}\n  }\n  END {for (y in x) print y \"\\t\" x[y]}\n'\n</code>\n</pre>\n", "senID": 2}], [{"text": ["This or a slight variant should do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n finalData = {}\nfor line in input:\n    parts = line.split()\n    key,extra = tuple(parts[0:3]),parts[3:]\n    if key not in finalData or extra:\n        finalData[key] = extra\n\npprint(finalData)\n</code>\n</pre>\n", "senID": 1}, {"text": ["outputs:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n {('BOB', '123', '1DB'): ['EXTRA', 'BITS'],\n ('DAVE', '789', '1DB'): [],\n ('JIM', '456', '3DB'): ['AX']}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This variation on glenn jackman's answer should work regardless of the position of lines with extra bits:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n awk '{idx = $1 \" \" $2 \" \" $3; if (length($0) &gt; length(x[idx])) x[idx] = $0} END {for (idx in x) print x[idx]}' inputfile\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n awk -v ncols=3 '\n  {\n    key = \"\";\n    for (i=1; i&lt;=ncols; i++) {key = key FS $i}\n    if (length($0) &gt; length(x[key])) x[key] = $0\n  }\n  END {for (y in x) print x[y]}\n' inputfile\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You'll have to define a function to split your line into important bits and extra bits, then you can do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def split_extra(s):\n    \"\"\"Return a pair, the important bits and the extra bits.\"\"\"\n    return blah blah blah\n\ndata = {}\nfor line in open('file'):\n    impt, extra = split_extra(line)\n    existing = data.setdefault(impt, extra)\n    if len(extra) &gt; len(existing):\n        data[impt] = extra\n\nout = open('newfile', 'w')\nfor impt, extra in data.iteritems():\n    out.write(impt + extra)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Since you need the extra bits the fastest way is to create a set of unique entries (sort -u will do) and then you must compare each entry against each other, e.g.", "if x.startswith(y) and not y.startswith(x)\nand just leave x and discard y."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "if x.startswith(y) and not y.startswith(x)", "childNum": 1, "tag": "pre", "pos": 1, "childList": [{"text": "if x.startswith(y) and not y.startswith(x)", "tag": "code"}]}, {"text": "if x.startswith(y) and not y.startswith(x)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If you have perl and want only the last entry to be preserved :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n cat file.txt | perl -ne 'BEGIN{%k={}} @_ = split(/ /);$kw = shift(@_); $kws{$kw} = \"@_\"; END{ foreach(sort keys %kws){ print \"$_ $kws{$_}\";} }' &gt; file.new.txt\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The function find_unique_lines will work for a file object or a list of strings."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "find_unique_lines", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\n\ndef split_line(s):\n    parts = s.strip().split(' ')\n    return \" \".join(parts[:3]), parts[3:], s\n\ndef find_unique_lines(f):\n    result = {}\n    for key, data, line in itertools.imap(split_line, f):\n        if data or key not in result:\n            result[key] = line\n    return result.itervalues()\n\ntest = \"\"\"BOB 123 1DB\nJIM 456 3DB AX\nDAVE 789 1DB\nBOB 123 1DB\nJIM 456 3DB AX\nDAVE 789 1DB\nBOB 123 1DB EXTRA BITS\"\"\".split('\\n')\n\nfor line in find_unique_lines(test):\n        print line\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\nBOB 123 1DB EXTRA BITS\nJIM 456 3DB AX\nDAVE 789 1DB\n</pre>\n", "senID": 2}]]