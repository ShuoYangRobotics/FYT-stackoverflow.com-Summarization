[[{"text": ["In the clas body, you're creating the class; there is no self, so you obviously cannot yet refer to self.anything.", "But also within that body there is as yet no a: name a gets bound AFTER the class body is done.", "So, although that's a tad less obvious, in the body of class a you cannot refer to a.anything either, yet."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self.anything", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "a.anything", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["What you CAN refer to are bare names of class attributes that have already been bound: for example, you could simply use 5, spam] at the end of your list lut.", "spam will be there as a function, as you say at one point that you want; not as a method, and most definitely NOT as a class method (I don't see classmethod ANYWHERE in your code, why do you think a class method would magically spring into existence unless you explicitly wrap a function in the classmethod builtin, directly or by decorator?", ") -- I suspect your use of \"class method\" does not actually refer to the class-method type (though it's certainly confusing;-)."], "childNum": 5, "tag": "p", "senID": 1, "childList": [{"text": "5, spam]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "lut", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "spam", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "classmethod", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "classmethod", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["So, if you later need to call that function on some instance x of a, you'll be calling e.g.", "a.lut[-1](x), with the argument explicitly there."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "a.lut[-1](x)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you need to do something subtler it may be possible to get a bound or unbound method of some sort at various points during processing (after the class creation is done, or, if you want a bound instance method, only after a specific instance is instantiated).", "But you don't explain clearly and completely enough what exactly it is that you want to do, for us to offer very detailed help on this later-stage alternatives."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["While you are in the scope of the class, you can just write"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class A:\n    def spam(self):\n        pass\n\n    lut = [1, 2, 3, spam]\n\na = A()\nprint a.lut\n</code>\n</pre>\n", "senID": 1}, {"text": ["gives"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [1, 2, 3, &lt;function spam at 0xb7bb764c&gt;]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Don't forget that this is a function in your lookup table, not a number as you probably intended.", "You probably want to solve another problem."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "function", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Remember that there's no such thing as static, or constant, in Python.", "Just make it easy to read.", "Here's an example which generates a cached version of lut per object:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "lut", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n class A(object):\n    def __init__(self):\n        self.__cached_lut = None\n\n    def spam0(self):\n        return (some_calculation_based_on_self)\n\n    def spam1(self):\n        return (a_different_calculation_based_on_self)\n\n    @property\n    def lut(self):\n         if self.__cached_lut is None:\n             self.__cached_lut = [1,\n               3,\n               17,\n               [12,34],\n               5,\n               self.spam0()\n               self.spam1()]\n         return self.__cached_lut\n\na = A()\nprint a.lut\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm not sure I understand the question.", "Is this what you mean?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class a:\n    lut = [1,\n           3,\n           17,\n           [12,34],\n           5]\n\n    def __init__(self):\n        self.lut.append(self.spam)\n\n    def spam(self, a):\n        print \"this is %s\" % a\n\nb = a()\nb.lut[-1](4)\n</code>\n</pre>\n", "senID": 1}, {"text": ["this will output: \"this is 4\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Trivial:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class a:\n    @classmethod\n    def spam(cls):\n        # not really pass, but you get the idea\n        pass\n\n    lut = [1,\n           3,\n           17,\n           [12,34],\n           5,\n           spam]\n\n\nassert a().lut[-1] == a.spam\nassert a.spam() is None\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You want the function to be bound to the class.", "None of the answers seem to address this."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This won't be done automatically; when you do this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class a:\n    def spam(self): print self\n    lut = [1, spam]\n</code>\n</pre>\n", "senID": 2}, {"text": ["lut[1] is spam itself, not a bound method to an object, so you can't simply call lut[1](); you'd have to call lut[1](self)."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "lut[1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "lut[1]()", "childNum": 0, "tag": "code", "childList": []}, {"text": "lut[1](self)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you specifically want to be able to include functions in the list that can be called directly, you need to arrange for the functions to be bound, which means referencing them from an instance and not the class.", "To do this, you'd probably want to initialize this list from __init__:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class a:\n    def spam(self): print self\n    def __init__(self):\n        self.lut = [1, self.spam]\n</code>\n</pre>\n", "senID": 5}, {"text": ["and now self.lut[1]() is correct, since it's a bound method."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "self.lut[1]()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This all has the advantage that other functions can be placed in the list for other purposes, possibly bound to other objects or otherwise not expecting a parameter."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["It has the disadvantage that you aren't reusing the list between instances; this may or may not matter to you."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["You're going to need to move the definition of a.lut outside of the definition of a.  "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "a.lut", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class a():\n    def spam():pass\n\na.lut = [1,2,3,a.spam]\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you think about it, this makes perfect sense.", "Using self wouldn't work because self is actually only defined for class methods for which you use the parameter \"self\".", "self has no special meaning in Python and is not a reserved word; it is simply the conventional argument passed to bound class methods, but could also be this, or foo, or whatever you want."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "childList": []}, {"text": "this", "childNum": 0, "tag": "code", "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Referring to a.lut doesn't work because the definition of a isn't complete yet.", "How should Python know, at that point in the code, what a is?", "In the scope of a's class definition, a itself is still undefined."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "a.lut", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}]}]]