[[{"text": ["You should never favor zip over izip, range over xrange, or list comprehensions over generator comprehensions.", "In Python 3.0 range has xrange-like semantics and zip has izip-like semantics."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["List comprehensions are actually clearer like list(frob(x) for x in foo) for those times you need an actual list."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["In general, don't use a generator when you need list operations, like len(), reversed(), and so on."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There may also be times when you don't want lazy evaluation (e.g.", "to do all the calculation up front so you can release a resource).", "In that case, a list expression might be better."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Profile, Profile, Profile."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Profiling your code is the only way to know if what you're doing has any effect at all."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Most usages of xrange, generators, etc are over static size, small datasets.", "It's only when you get to large datasets that it really makes a difference.", "range() vs. xrange() is mostly just a matter of making the code look a tiny little bit more ugly, and not losing anything, and maybe gaining something."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Profile, Profile, Profile."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["As far as performance is concerned, I can't think of any times that you would want to use a list over a generator."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Regarding performance: if using psyco, lists can be quite a bit faster than generators.", "In the example below, lists are almost 50% faster when using psyco.full()"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import psyco\nimport time\nimport cStringIO\n\ndef time_func(func):\n    \"\"\"The amount of time it requires func to run\"\"\"\n    start = time.clock()\n    func()\n    return time.clock() - start\n\ndef fizzbuzz(num):\n    \"\"\"That algorithm we all know and love\"\"\"\n    if not num % 3 and not num % 5:\n        return \"%d fizz buzz\" % num\n    elif not num % 3:\n        return \"%d fizz\" % num\n    elif not num % 5:\n        return \"%d buzz\" % num\n    return None\n\ndef with_list(num):\n    \"\"\"Try getting fizzbuzz with a list comprehension and range\"\"\"\n    out = cStringIO.StringIO()\n    for fibby in [fizzbuzz(x) for x in range(1, num) if fizzbuzz(x)]:\n        print &gt;&gt; out, fibby\n    return out.getvalue()\n\ndef with_genx(num):\n    \"\"\"Try getting fizzbuzz with generator expression and xrange\"\"\"\n    out = cStringIO.StringIO()\n    for fibby in (fizzbuzz(x) for x in xrange(1, num) if fizzbuzz(x)):\n        print &gt;&gt; out, fibby\n    return out.getvalue()\n\ndef main():\n    \"\"\"\n    Test speed of generator expressions versus list comprehensions,\n    with and without psyco.\n    \"\"\"\n\n    #our variables\n    nums = [10000, 100000]\n    funcs = [with_list, with_genx]\n\n    # first, try without psyco\n    print \"without psyco\"\n    for num in nums:\n        print \"  number:\", num\n        for func in funcs:\n            print func.__name__, time_func(lambda : func(num)), \"seconds\"\n        print\n\n    # now with pscyo\n    print \"with psyco\"\n    psyco.full()\n    for num in nums:\n        print \"  number:\", num\n        for func in funcs:\n            print func.__name__, time_func(lambda : func(num)), \"seconds\"\n        print\n\nif __name__ == \"__main__\":\n    main()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Results:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n without psyco\n  number: 10000\nwith_list 0.0519102208309 seconds\nwith_genx 0.0535933367509 seconds\n\n  number: 100000\nwith_list 0.542204280744 seconds\nwith_genx 0.557837353115 seconds\n\nwith psyco\n  number: 10000\nwith_list 0.0286369007033 seconds\nwith_genx 0.0513424889137 seconds\n\n  number: 100000\nwith_list 0.335414877839 seconds\nwith_genx 0.580363490491 seconds\n</code>\n</pre>\n", "senID": 3}], [{"text": ["As you mention, \"This especially makes sense for large datasets\", I think this answers your question."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If your not hitting any walls, performance-wise, I would stick to lists and standard functions.", "Then when you run into problems with performance make the switch."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I've never found a situation where generators would hinder what you're trying to do.", "There are, however, plenty of instances where using generators would not help you any more than not using them."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n sorted(xrange(5))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Does not offer any improvement over:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n sorted(range(5))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You should prefer list comprehensions if you need to keep the values around for something else later and the size of your set is not too large."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example:\n you are creating a list that you will loop over several times later in your program. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["To some extent you can think of generators as a replacement for iteration (loops) vs. list comprehensions as a type of data structure initialization.", "If you want to keep the data structure then use list comprehensions."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]