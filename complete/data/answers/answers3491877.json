[[{"text": ["Firstly, I suggest your data structure should look more like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n items = [\n    ['Schools', None, None, 32],\n    ['Schools', 'Primary schools', None, 16],\n    ['Schools', 'Secondary schools', None, 8],\n    ['Schools', 'Secondary schools', 'Special ed', 4],\n    ['Schools', 'Secondary schools', 'Non-special ed', 4],\n]\n</code>\n</pre>\n", "senID": 1}, {"text": ["We can sort them into a dictionary like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n result = {}\n\nfor item in items:\n    if not item[0] in result or not isinstance(result[item[0]], dict): result[item[0]] = {}\n    if not item[1] in result[item[0]] or not isinstance(result[item[0]][item[1]], dict): result[item[0]][item[1]] = {}\n    if not item[2] in result[item[0]][item[1]] or not isinstance(result[item[0]][item[1]][item[2]], dict): result[item[0]][item[1]][item[2]] = {}\n\n    if not item[0]:\n        result = item[3]\n    elif not item[1]:\n        result[item[0]] = item[3]\n    elif not item[2]:\n        result[item[0]][item[1]] = item[3]\n    else:\n        result[item[0]][item[1]][item[2]] = item[3]\n</code>\n</pre>\n", "senID": 3}, {"text": ["And you should end up with a dictionary like:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n result = {\n    'Schools': {\n        'Secondary schools': {\n            'Non-special ed': '4',\n            'Special ed': '4'\n        },\n        'Primary schools': '16'\n    }\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["My routine could probably be optimized and made recursive."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Also, the numbers total to 24 -- is this an error on your part?"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"code": "<pre>\n<code>\n list_keys = [ \"\".join(x[:-1]) for x in items ]\nfor i in range(len(list_keys)-1):\n  if not list_keys[i+1].startswith(list_keys[i]):\n     print items[i]\nprint items[-1]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Here I find the \"key\" of each item, which is all entries in an item, concatenated, except the last value."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["An aggregate item's key is always a prefix of succeeding items' keys, so we can use this test to detect aggregate items and dismiss them."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This alg.", "prints (on your input):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n ['Schools', 'Primary schools', '', '16']\n['Schools', 'Secondary schools', 'Special ed', '4']\n['Schools', 'Secondary schools', 'Non-special ed', '4'],\n</code>\n</pre>\n", "senID": 4}, {"text": ["Note:\nThis assumes all items are ordered neatly in a tree structure (as your original data).", "If it's not, it'll be (slightly) more complicated as you'll have to sort the keys before the loop (and keep track of which key belongs to which item)."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}], [{"text": ["How about making your items objects?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class School (object):\n    __init__(self, is_aggregate=false):\n        self.is_aggregate = is_aggregate\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm using a helper function that"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "makes a set of the entries with more fine-grained data", "tag": "none", "senID": 1}, {"text": "returns a function suitable for ", "tag": "none", "senID": 2}]}, {"text": ["Run your example data through this function, and it will give the desired output :)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def remove_aggregates(items):\n\n    def mk_pred(index_i, blank_i, items):\n        posts = set(x[index_i] for x in items if x[blank_i] != '')    \n        def pred(item):\n            return not (item[blank_i] == '' and item[index_i] in posts)\n        return pred    \n\n    items = filter(mk_pred(0,1,items), items)\n    items = filter(mk_pred(1,2,items), items)\n    return items\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You've asked how to do so elegantly, and further, how to do so better.", "Your nota bene suggests that the structure you're working with is still malleable.", "If you want to be able to do so more elegantly, I would suggest changing the way the data is stored.", "Some options are:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Include an additional field in each list, which indicates whether it is an aggregate value or not:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n items = [\n    ['Schools', '', '', '32', True],\n    ['Schools', 'Primary schools', '', '16', False],\n    ['Schools', 'Secondary schools', '', '8', True],\n    ['Schools', 'Secondary schools', 'Special ed', '4', False],\n    ['Schools', 'Secondary schools', 'Non-special ed', '4', False],\n]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Split your data into two lists:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n items = [\n    [\n        ['Schools', '', '', '32'],\n        ['Schools', 'Secondary schools', '', '8'],\n    ],\n    [\n        ['Schools', 'Primary schools', '', '16'],\n        ['Schools', 'Secondary schools', 'Special ed', '4'],\n        ['Schools', 'Secondary schools', 'Non-special ed', '4'],\n    ],\n]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Make the aggregate values contain a list of their children (although this still wouldn't be much fun to reduce):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n items = [\n    ['Schools', '', '', '32', [\n        ['Schools', 'Primary schools', '', '16', []],\n        ['Schools', 'Secondary schools', '', '8', [\n            ['Schools', 'Secondary schools', 'Special ed', '4'],\n            ['Schools', 'Secondary schools', 'Non-special ed', '4'],\n        ],\n    ],\n]\n</code>\n</pre>\n", "senID": 6}, {"text": ["I would say that the current structure of your data does not allow you to do anything elegant with it.", "You require logic along the lines of \"if this index is blank but it isn't for another entry that has the same value at another of my indexes\", and this has to be done twice per list entry, because that logic can occur at two separate pairs of index locations.", "Fix the way you store your information, and you will be able to write an elegant method of reducing that data."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["For example, if you went with the first option I listed (using booleans to indicate whether the entry is aggregate), you could reduce the list with:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n reduced = [item for item in items where item[4] == False]\n</code>\n</pre>\n", "senID": 9}], [{"text": ["This attemp tries not to be dependend of sorting of the input:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n items = [\n    ['Schools', '', '', '32'],\n    ['Schools', 'Primary schools', '', '16'],\n    ['Schools', 'Secondary schools', '', '16'],\n    ['Schools', 'Secondary schools', 'Special ed', '8'],\n    ['Schools', 'Secondary schools', 'Non-special ed', '8'],\n]\n\ndef path(item,upto=None):\n    return \".\".join([p for p in item[:-1] if p][:upto])    \n\nfrom collections import defaultdict\nchildren_counter = defaultdict(int)\nfor i in items:\n    children_counter[path(i,-1)] += 1\n\nfor i in items:\n   if children_counter[path(i)] == 0:\n        print i\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could use a list comprehension, as follows:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n items = [a for a in items if a[1] != '' and a[2] != '']\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or, if an empty string in any position denotes an aggregate item:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n items = [a for a in items if '' not in a]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Of course, you don't necessarily need to assign the reduced list to items - you can use it however you like."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]