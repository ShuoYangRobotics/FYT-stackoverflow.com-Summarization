[[{"text": ["Perl 'one-liner' intended/expanded out so that everything fits in the window:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ perl -F -lane '\n\n      $hash{ $F[0] }{ $F[1] }++;\n  } END {\n\n      for my $columnA ( keys %hash ) {\n\n          print $columnA, \" - \", join( \",\", keys %$hash{$columnA} ), \"\\n\";\n      }\n  '\n</code>\n</pre>\n", "senID": 1}, {"text": ["Explanation will follow if I see a concerted attempt on the part of the original poster."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I would use Python dictionaries where the dictionary keys are column A values and the dictionary values are Python's built-in Set type holding column B values"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Set type", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#set-types-set-frozenset"}]}, {"code": "<pre>\n<code>\n def parse_the_file():\n    lower = str.lower\n    split = str.split\n    with open('f.txt') as f:\n        d = {}\n        lines = f.read().split('\\n')\n        for A,B in [split(l) for l in lines]:\n            try:\n                d[lower(A)].add(B)\n            except KeyError:\n                d[lower(A)] = set(B)\n\n        for a in d:\n            print \"%s - %s\" % (a,\",\".join(list(d[a])))\n\nif __name__ == \"__main__\":\n    parse_the_file()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The advantage of using a dictionary is that you'll have a single dictionary key per column A value.", "The advantage of using a set is that you'll have a unique set of column B values.            "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Efficiency notes:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "The use of try-catch is more efficient than using an if\\else statement to check for initial cases.", "tag": "none", "senID": 4}, {"text": "The evaluation and assignment of the str functions outside of the loop is more efficient than simply using them inside the loop.", "tag": "none", "senID": 5}, {"text": "Depending on the proportion of new A values vs. reappearance of A values throughout the file, you may consider using ", "tag": "none", "senID": 6}, {"text": "I used a function, as accessing local variables is more efficient in Python than accessing global variables", "tag": "none", "senID": 7}, {"text": "Some of these performance tips are from ", "tag": "none", "senID": 8}]}, {"text": ["Testing the code above on your input example yields:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n xxxd - 4\nxxxa - 1,3,2\nxxxb - 2\nxxxc - 3\n</code>\n</pre>\n", "senID": 10}], [{"text": ["You can use this simple multimap:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MultiMap(object):\n    values = {}\n\n    def __getitem__(self, index):\n        return self.values[index]\n    def __setitem__(self, index, value):\n        if not self.values.has_key(index):\n            self.values[index] = []\n        self.values[index].append(value)\n    def __repr__(self):\n        return repr(self.values)\n</code>\n</pre>\n", "senID": 1}, {"text": ["See it in action: http://codepad.org/xOOrlbnf"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://codepad.org/xOOrlbnf", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://codepad.org/xOOrlbnf"}]}], [{"text": ["Simple Perl version:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/perl\n\nuse strict;\nuse warnings;\n\nmy (%v, @row);\n\nforeach (&lt;DATA&gt;) {\n        chomp;\n        $_ = lc($_);\n        @row = split(/\\s+/, $_);\n        push( @{ $v{$row[0]} }, $row[1]);\n} \n\nforeach (sort keys %v) {\n        print \"$_ - \", join( \", \", @{ $v{$_} } ), \"\\n\";\n}\n\n__DATA__\nxxxA 2\nxxxA 1\nxxxB 2\nXXXC 3\nXXXA 3\nxxxD 4\n</code>\n</pre>\n", "senID": 1}, {"text": ["Did not focus on variable names.", "From example i see they are not case sensitive."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"code": "<pre>\n<code>\n f = \"\"\"xxxA 2\nxxxA 1\nxxxB 2\nXXXC 3\nXXXA 3\nxxxD 4\"\"\"\n\n\nd = {}\n\nfor line in f.split(\"\\n\"):\n    key, val = line.lower().split()\n    try:\n        d[key].append(val)        \n    except KeyError:\n        d[key] = [val]\n\n\nprint d\n</code>\n</pre>\n", "senID": 0}, {"text": ["Python"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"code": "<pre>\n<code>\n while() {\n\n($key, $value) = split / /, $_;\n\n$hash{lc($key)} = 1;\n\npush(@array, \"$key$value\");\n\n}\n\nforeach $key (sort keys %hash) {\n\n@arr = (grep /$key/i, @array);\n\nchomp(@arr);\n\n$val = join (\", \", @arr);\n\n$val =~ s#$key##gi; \n\nprint \"$key\\t$val\\n\";\n\n}\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Using Perl oneliner:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n perl -lane'$F[0]=~s/.../lc$&amp;/e;exists$s{$F[0]}and$s{$F[0]}.=\",$F[1]\"or push@v,$F[0]and$s{$F[0]}=$F[1]}{print\"$_ $s{$_}\"for@v'\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can remove $F[0]=~s/.../lc$&amp;/e; if your key is case sensitive (which is not true in your test data) or use $F[0]=lc$F[0]; or $F[0]=uc$F[0]; if you can unify your key to lower or upper case."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "$F[0]=~s/.../lc$&amp;/e;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "$F[0]=lc$F[0];", "childNum": 0, "tag": "code", "childList": []}, {"text": "$F[0]=uc$F[0];", "childNum": 0, "tag": "code", "childList": []}]}]]