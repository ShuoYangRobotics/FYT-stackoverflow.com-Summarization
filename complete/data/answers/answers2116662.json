[[{"text": ["Start with the recursive algorithm (pseudocode) : "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n traverse(node):\n  if node != None do:\n    traverse(node.left)\n    print node.value\n    traverse(node.right)\n  endif\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is a clear case of tail recursion, so you can easily turn it into a while-loop. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n traverse(node):\n  while node != None do:\n    traverse(node.left)\n    print node.value\n    node = node.right\n  endwhile\n</code>\n</pre>\n", "senID": 3}, {"text": ["You're left with a recursive call.", "What the recursive call does is push a new context on the stack, run the code from the beginning, then retrieve the context and keep doing what it was doing.", "So, you create a stack for storage, and a loop that determines, on every iteration, whether we're in a \"first run\" situation (non-null node) or a \"returning\" situation (null node, non-empty stack) and runs the appropriate code: "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n traverse(node):\n  stack = []\n  while !empty(stack) || node != None do:\n    if node != None do: // this is a normal call, recurse\n      push(stack,node)\n      node = node.left\n    else // we're returning: pop and print the current node\n      node = pop(stack)\n      print node.value\n      node = node.right\n    endif\n  endwhile\n</code>\n</pre>\n", "senID": 5}, {"text": ["The hard thing to grasp is the \"return\" part: you have to determine, in your loop, whether the code you're running is in the \"entering the function\" situation or in the \"returning from a call\" situation, and you will have an if/else chain with as many cases as you have non-terminal recursions in your code."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "if/else", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In this specific situation, we're using the node to keep information about the situation.", "Another way would be to store that in the stack itself (just like a computer does for recursion).", "With that technique, the code is less optimal, but easier to follow"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n traverse(node):\n  // entry:\n  if node == NULL do return\n  traverse(node.left)\n  // after-left-traversal:\n  print node.value\n  traverse(node.right)\n\ntraverse(node):\n   stack = [node,'entry']\n   while !empty(stack) do:\n     [node,state] = pop(stack)\n     switch state: \n       case 'entry': \n         if node == None do: break; // return\n         push(stack,[node,'after-left-traversal']) // store return address\n         push(stack,[node.left,'entry']) // recursive call\n         break;\n       case 'after-left-traversal': \n         print node.value;\n         // tail call : no return address\n         push(stack,[node.right,'entry']) // recursive call\n      end\n    endwhile\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Here is a simple in-order non-recursive c++ code .."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n void inorder (node *n)\n{\n    stack s;\n\n    while(n){\n        s.push(n);\n        n=n-&gt;left;\n    }\n\n    while(!s.empty()){\n        node *t=s.pop();\n        cout&lt;&lt;t-&gt;data;\n        t=t-&gt;right;\n\n        while(t){\n            s.push(t);\n            if (t-&gt;left)\n                t=t-&gt;left;\n            else\n                break;\n        }\n    }\n}\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def traverseInorder(node):\n   lifo = Lifo()\n\n  while node is not None:\n    if node.left is not None:\n       lifo.push(node)\n       node = node.left\n       continue\n\n   print node.value\n\n   if node.right is not None:\n      node = node.right\n      continue\n\n   node = lifo.Pop()\n   if node is not None :\n      print node.value\n      node = node.right\n</code>\n</pre>\n", "senID": 0}, {"text": ["PS: I don't know Python so there may be a few syntax issues."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["State can be remembered implicitly,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n traverse(node) {\n   if(!node) return;\n   push(stack, node);\n   while (!empty(stack)) {\n     /*Remember the left nodes in stack*/\n     while (node-&gt;left) {\n        push(stack, node-&gt;left);\n        node = node-&gt;left;\n      }\n\n      /*Process the node*/\n      printf(\"%d\", node-&gt;data);\n\n      /*Do the tail recursion*/\n      if(node-&gt;right) {\n         node = node-&gt;right\n      } else {\n         node = pop(stack); /*New Node will be from previous*/\n      }\n    }\n }\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think part of the problem is the use of the \"prev\" variable.", "You shouldn't have to store the previous node you should be able to maintain the state on the stack (Lifo) itself."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["From Wikipedia, the algorithm you are aiming for is:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Wikipedia", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Tree_traversal"}]}, {"text": ["In pseudo code (disclaimer, I don't know Python so apologies for the Python/C++ style code below!", ") your algorithm would be something like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n lifo = Lifo();\nlifo.push(rootNode);\n\nwhile(!lifo.empty())\n{\n    node = lifo.pop();\n    if(node is not None)\n    {\n        print node.value;\n        if(node.right is not None)\n        {\n            lifo.push(node.right);\n        }\n        if(node.left is not None)\n        {\n            lifo.push(node.left);\n        }\n    }\n}\n</code>\n</pre>\n", "senID": 3}, {"text": ["For postorder traversal you simply swap the order you push the left and right subtrees onto the stack."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["@Victor, I have some suggestion on your implementation trying to push the state into the stack.", "I don't see it is necessary.", "Because every element you take from the stack is already left traversed.", "so instead of store the information into the stack, all we need is a flag to indicate if the next node to be processed is from that stack or not.", "Following is my implementation which works fine:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def intraverse(node):\n    stack = []\n    leftChecked = False\n    while node != None:\n        if not leftChecked and node.left != None:\n            stack.append(node)\n            node = node.left\n        else:\n            print node.data\n            if node.right != None:\n                node = node.right\n                leftChecked = False\n            elif len(stack)&gt;0:\n                node = stack.pop()\n                leftChecked = True\n            else:\n                node = None\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\ndef print_tree_in(root):\n    stack = []\n    current = root\n    while True:\n        while current is not None:\n            stack.append(current)\n            current = current.getLeft();\n        if not stack:\n            return\n        current = stack.pop()\n        print current.getValue()\n        while current.getRight is None and stack:\n            current = stack.pop()\n            print current.getValue()\n        current = current.getRight();\n</pre>\n", "senID": 0}]]