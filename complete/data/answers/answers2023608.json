[[{"text": ["I ended up wrapping the built-in file object at the entry point of my program.", "I found out that I wasn't closing my loggers."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import __builtin__\nopenfiles = set()\noldfile = __builtin__.file\nclass newfile(oldfile):\n    def __init__(self, *args):\n        self.x = args[0]\n        print \"### OPENING %s ###\" % str(self.x)            \n        oldfile.__init__(self, *args)\n        openfiles.add(self)\n\n    def close(self):\n        print \"### CLOSING %S ###\" % str(self.x)\n        oldfile.close(self)\n        openfiles.remove(self)\noldopen = __builtin__.open\ndef newopen(*args):\n    return newfile(*args)\n__builtin__.file = newfile\n__builtin__.open = newopen\n\ndef printOpenFiles():\n    print \"### %d OPEN FILES: [%s]\" % (len(openfiles), \", \".join(f.x for f in openfiles))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["On Linux, you can look at the contents of /proc/self/fd:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "/proc/self/fd", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ ls -l /proc/self/fd/\ntotal 0\nlrwx------ 1 foo users 64 Jan  7 15:15 0 -&gt; /dev/pts/3\nlrwx------ 1 foo users 64 Jan  7 15:15 1 -&gt; /dev/pts/3\nlrwx------ 1 foo users 64 Jan  7 15:15 2 -&gt; /dev/pts/3\nlr-x------ 1 foo users 64 Jan  7 15:15 3 -&gt; /proc/9527/fd\n</code>\n</pre>\n", "senID": 1}], [{"text": ["On Linux, you can use lsof to show all files opened by a process."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "lsof", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["On Windows, you can use Process Explorer to show all file handles owned by a process."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Process Explorer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://technet.microsoft.com/en-us/sysinternals/bb896653.aspx"}]}], [{"text": ["I'd guess that you are leaking file descriptors.", "You probably want to look through your code to make sure that you are closing all of the files that you open."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Although the solutions above that wrap opens are useful for one's own code, I was debugging my client to a third party library including some c extension code, so I needed a more direct way.", "The following routine works under darwin, and (I hope) other unix-like environments:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def get_open_fds():\n    '''\n    return the number of open file descriptors for current process\n\n    .. warning: will only work on UNIX-like os-es.\n    '''\n    import subprocess\n    import os\n\n    pid = os.getpid()\n    procs = subprocess.check_output( \n        [ \"lsof\", '-w', '-Ff', \"-p\", str( pid ) ] )\n\n    nprocs = len( \n        filter( \n            lambda s: s and s[ 0 ] == 'f' and s[1: ].isdigit(),\n            procs.split( '\\n' ) )\n        )\n    return nprocs\n</code>\n</pre>\n", "senID": 1}, {"text": ["If anyone can extend to be portable to windows, I'd be grateful."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]