[[{"text": ["Pyparsing can be used to parse mathematical expressions.", "In particular, fourFn.py\nshows how to parse basic arithmetic expressions.", "Below, I've rewrapped fourFn into a numeric parser class for easier reuse. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Pyparsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}, {"text": "fourFn.py", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/file/view/fourFn.py"}]}, {"code": "<pre>\n<code>\n from __future__ import division\nfrom pyparsing import (Literal,CaselessLiteral,Word,Combine,Group,Optional,\n                       ZeroOrMore,Forward,nums,alphas,oneOf)\nimport math\nimport operator\n\n__author__='Paul McGuire'\n__version__ = '$Revision: 0.0 $'\n__date__ = '$Date: 2009-03-20 $'\n__source__='''http://pyparsing.wikispaces.com/file/view/fourFn.py\nhttp://pyparsing.wikispaces.com/message/view/home/15549426\n'''\n__note__='''\nAll I've done is rewrap Paul McGuire's fourFn.py as a class, so I can use it\nmore easily in other places.\n'''\n\nclass NumericStringParser(object):\n    '''\n    Most of this code comes from the fourFn.py pyparsing example\n\n    '''\n    def pushFirst(self, strg, loc, toks ):\n        self.exprStack.append( toks[0] )\n    def pushUMinus(self, strg, loc, toks ):\n        if toks and toks[0]=='-': \n            self.exprStack.append( 'unary -' )\n    def __init__(self):\n        \"\"\"\n        expop   :: '^'\n        multop  :: '*' | '/'\n        addop   :: '+' | '-'\n        integer :: ['+' | '-'] '0'..'9'+\n        atom    :: PI | E | real | fn '(' expr ')' | '(' expr ')'\n        factor  :: atom [ expop factor ]*\n        term    :: factor [ multop factor ]*\n        expr    :: term [ addop term ]*\n        \"\"\"\n        point = Literal( \".\" )\n        e     = CaselessLiteral( \"E\" )\n        fnumber = Combine( Word( \"+-\"+nums, nums ) + \n                           Optional( point + Optional( Word( nums ) ) ) +\n                           Optional( e + Word( \"+-\"+nums, nums ) ) )\n        ident = Word(alphas, alphas+nums+\"_$\")       \n        plus  = Literal( \"+\" )\n        minus = Literal( \"-\" )\n        mult  = Literal( \"*\" )\n        div   = Literal( \"/\" )\n        lpar  = Literal( \"(\" ).suppress()\n        rpar  = Literal( \")\" ).suppress()\n        addop  = plus | minus\n        multop = mult | div\n        expop = Literal( \"^\" )\n        pi    = CaselessLiteral( \"PI\" )\n        expr = Forward()\n        atom = ((Optional(oneOf(\"- +\")) +\n                 (pi|e|fnumber|ident+lpar+expr+rpar).setParseAction(self.pushFirst))\n                | Optional(oneOf(\"- +\")) + Group(lpar+expr+rpar)\n                ).setParseAction(self.pushUMinus)       \n        # by defining exponentiation as \"atom [ ^ factor ]...\" instead of \n        # \"atom [ ^ atom ]...\", we get right-to-left exponents, instead of left-to-right\n        # that is, 2^3^2 = 2^(3^2), not (2^3)^2.\n        factor = Forward()\n        factor &lt;&lt; atom + ZeroOrMore( ( expop + factor ).setParseAction( self.pushFirst ) )\n        term = factor + ZeroOrMore( ( multop + factor ).setParseAction( self.pushFirst ) )\n        expr &lt;&lt; term + ZeroOrMore( ( addop + term ).setParseAction( self.pushFirst ) )\n        # addop_term = ( addop + term ).setParseAction( self.pushFirst )\n        # general_term = term + ZeroOrMore( addop_term ) | OneOrMore( addop_term)\n        # expr &lt;&lt;  general_term       \n        self.bnf = expr\n        # map operator symbols to corresponding arithmetic operations\n        epsilon = 1e-12\n        self.opn = { \"+\" : operator.add,\n                \"-\" : operator.sub,\n                \"*\" : operator.mul,\n                \"/\" : operator.truediv,\n                \"^\" : operator.pow }\n        self.fn  = { \"sin\" : math.sin,\n                \"cos\" : math.cos,\n                \"tan\" : math.tan,\n                \"abs\" : abs,\n                \"trunc\" : lambda a: int(a),\n                \"round\" : round,\n                \"sgn\" : lambda a: abs(a)&gt;epsilon and cmp(a,0) or 0}\n    def evaluateStack(self, s ):\n        op = s.pop()\n        if op == 'unary -':\n            return -self.evaluateStack( s )\n        if op in \"+-*/^\":\n            op2 = self.evaluateStack( s )\n            op1 = self.evaluateStack( s )\n            return self.opn[op]( op1, op2 )\n        elif op == \"PI\":\n            return math.pi # 3.1415926535\n        elif op == \"E\":\n            return math.e  # 2.718281828\n        elif op in self.fn:\n            return self.fn[op]( self.evaluateStack( s ) )\n        elif op[0].isalpha():\n            return 0\n        else:\n            return float( op )\n    def eval(self,num_string,parseAll=True):\n        self.exprStack=[]\n        results=self.bnf.parseString(num_string,parseAll)\n        val=self.evaluateStack( self.exprStack[:] )\n        return val\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can use it like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n nsp=NumericStringParser()\nresult=nsp.eval('2^4')\nprint(result)\n# 16.0\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You need to use the eval() function,  as in"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "eval() function", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #btw that's probably what you meant, 2 to the 4th power, not the XOR operation\n&gt;&gt;&gt;stringExp = \"2**4\"  \n&gt;&gt;&gt;print(eval(stringExp))\n16\n</code>\n</pre>\n", "senID": 1}, {"text": ["Beware that eval(), and its cousin exec() are dangerous tools in the Python's \"workshop\" because, depending on the origin of the string to be evaluated, the expression could at best simply generate an exception, and at worse, well...,  take over the computer or something like that ;-)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "eval(), and its cousin exec() are dangerous tools in the Python's \"workshop\"", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Therefore you typically need to"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "parse (if only roughly) the string for \"dangerous\" keywords etc.;\nFor simple expressions, a simple regex which checks for the absence of letters may just suffice.", "tag": "none", "senID": 4}, {"text": "run the eval in the context of a try-except construct", "tag": "none", "senID": 5}]}, {"text": ["Better yet, to check the input string against erroneous syntax and malicious code, you could use functions from the ast module (Abstract Syntax Tree)\nFor example, after ast.parse()ing the expression use ast.walk() to check that the tree only contains an ast.Expr, void of ast.Assign and such."], "childNum": 7, "tag": "p", "senID": 6, "childList": [{"text": "ast module", "tag": "a", "pos": 0, "childList": [{"text": "ast module", "tag": "strong"}], "childNum": 1, "href": "http://docs.python.org/library/ast.html#module-ast"}, {"text": "ast module", "childNum": 0, "tag": "strong", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "ast.parse()", "childNum": 0, "tag": "code", "childList": []}, {"text": "ast.walk()", "childNum": 0, "tag": "code", "childList": []}, {"text": "ast.Expr", "childNum": 0, "tag": "code", "childList": []}, {"text": "ast.Assign", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Use eval in a clean namespace:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "eval", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; ns = {'__builtins__': None}\n&gt;&gt;&gt; eval('2 ** 4', ns)\n16\n</code>\n</pre>\n", "senID": 1}, {"text": ["The clean namespace should prevent injection.", "For instance:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; eval('__builtins__.__import__(\"os\").system(\"echo got through\")', ns)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;string&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'NoneType' object has no attribute '__import__'\n</code>\n</pre>\n", "senID": 3}, {"text": ["Otherwise you would get:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; eval('__builtins__.__import__(\"os\").system(\"echo got through\")')\ngot through\n0\n</code>\n</pre>\n", "senID": 5}, {"text": ["You might want to give access to the math module:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import math\n&gt;&gt;&gt; ns = vars(math).copy()\n&gt;&gt;&gt; ns['__builtins__'] = None\n&gt;&gt;&gt; eval('cos(pi/3)', ns)\n0.50000000000000011\n</code>\n</pre>\n", "senID": 7}], [{"text": ["I think I would use eval(), but would first check to make sure the string is a valid mathematical expression, as opposed to something malicious.", "You could use a regex for the validation."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "eval()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["eval() also takes additional arguments which you can use to restrict the namespace it operates in for greater security."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "eval()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["What is wrong with eval?", "If you have some expression as a string, then eval is the way to go."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "eval", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "string", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "eval", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Just run:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n try:\n  result = eval('2**4')\nexcept SyntaxError:\n  result = 0\n</code>\n</pre>\n", "senID": 2}, {"text": ["Or something like this."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If you want to sanitaze your code, you can use compiler package and parse the given code.", "If you notice anything but mathematical expressions, just refuse to evaluate the code."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "compiler", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/compiler.html"}]}], [{"text": ["lybniz shows how to use eval() with untrustworthy input."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "lybniz", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://lybniz2.sourceforge.net/index.html"}, {"text": "eval()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If you don't want to use eval, then the only solution is to implement the appropriate grammar parser.", "Have a look at pyparsing."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pyparsing", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}]}]]