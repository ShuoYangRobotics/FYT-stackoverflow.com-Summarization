[[{"text": ["You can't.", "There are not overloads or multimethods or similar things.", "One name refers to one thing.", "As far as the language is concerned anyway, you can always emulate them yourself... You could check types with isinstance (but please do it properly - e.g.", "in Python 2, use basestring to detect both strings and unicode), but it's ugly, generally discouraged and rarely useful.", "If the methods do different things, give them different names.", "Consider polymorphism as well."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "could", "childNum": 0, "tag": "em", "pos": 3, "childList": []}, {"text": "isinstance", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "basestring", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}], [{"text": ["You can have a function that takes in variable number of arguments."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def my_method(*args, **kwds):\n    # do something\n\n# when you call the method\nmy_method(a1, a2, k1=a3, k2=a4)\n\n# you get: \nargs = (a1, a2)\nkwds = {'k':a3, 'k2':a4}\n</code>\n</pre>\n", "senID": 1}, {"text": ["So you can modify your function like so"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def my_method(*args):\n    if len(args) == 1 and isinstance(args[0], str):\n        # case 1\n    elif len(args) == 2 and isinstance(args[1], int):\n        # case 2 \n    elif len(args) == 2 and isinstance(args[1], str):\n        # case 3\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You can try multimethods in Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.artima.com/weblogs/viewpost.jsp?thread=101605"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.artima.com/weblogs/viewpost.jsp?thread=101605", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.artima.com/weblogs/viewpost.jsp?thread=101605"}]}, {"text": ["But I don't believe multimethod is a way to go.", "Rather objects that you pass to a method should have common interface.", "You are trying to achieve method overloading similar to the one in C++, but it is very rarely required in python.", "One way to do this is a cascade of ifs using isinstance, but that's ugly."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "ifs", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "isinstance", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Short answer: you can't (see this previous discussion).", "Typically you'd use something like (you could add more type checking and reorder):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "see this previous discussion", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/733264/function-overloading-in-python-missing"}]}, {"code": "<pre>\n<code>\n def my_method(self,parameter_A, parameter_B=None):\n  if isinstance(parameter_B, int):\n    print parameter_A * parameter_B\n  else:\n    print parameter_A\n    if parameter_B is not None:\n      print parameter_B\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Python is nothing like Java."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There is not really types, just objects with methods."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There is way to test if a passed object is from a class, but it is mainly bad practices."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["However, the code you want to produce for the two first methods should be something like "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class MyClass(object):\n    def my_method(self, str1, str2=None):\n        print str1\n        if str2: print str2\n</code>\n</pre>\n", "senID": 4}, {"text": ["For the third, well... Use a different name..."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["You probably want a pattern similar to the following:\nNote that adding '_' to the beginning of a method name is convention for marking a private method. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class MyClass:\n    \"\"\"\"\"\"\n\n    #----------------------------------------------------------------------\n    def __init__(self):\n        \"\"\"Constructor\"\"\"\n    def my_method(self,parameter_A_that_Must_Be_String, param2=None):\n        if type(param2) == str:\n            return self._my_method_extra_string_version(parameter_A_that_Must_Be_String, param2)\n        elif type(param2) == int:\n            return self._my_method_extra_int_version(parameter_A_that_Must_Be_String, param2)\n        else:\n            pass # use the default behavior in this function\n        print parameter_A_that_Must_Be_String\n\n    def _my_method_extra_string_version(self,parameter_A_that_Must_Be_String, parameter_B_that_Must_Be_String):\n        print parameter_A_that_Must_Be_String\n        print parameter_B_that_Must_Be_String\n\n    def _my_method_extra_int_version(self,parameter_A_that_Must_Be_String, parameter_A_that_Must_Be_Int):\n        print parameter_A_that_Must_Be_String * parameter_A_that_Must_Be_Int\n</code>\n</pre>\n", "senID": 1}]]