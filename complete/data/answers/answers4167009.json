[[{"text": ["There is function in itertools that works here:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.groupby"}]}, {"code": "<pre>\n<code>\n import itertools\n[key for key,seq in itertools.groupby([1,1,1,2,2,3,4,4])]\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can also write a generator:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def remove_adjacent(items):\n    # iterate the items\n    it = iter(items)\n    # get the first one\n    last = next(it)\n    # yield it in any case\n    yield last\n    for current in it:\n        # if the next item is different yield it\n        if current != last:\n            yield current\n            last = current\n        # else: its a duplicate, do nothing with it\n\nprint list(remove_adjacent([1,1,1,2,2,3,4,4]))\n</code>\n</pre>\n", "senID": 3}], [{"text": ["itertools to the rescue."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "tag": "a", "pos": 0, "childList": [{"text": "itertools", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html"}, {"text": "itertools", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\n\ndef remove_adjacent(lst):\n  i = iter(lst)\n  yield next(i)\n  for x, y in itertools.izip(lst, i):\n    if x != y:\n      yield y\n\n\nL = [1, 2, 2, 3]\n\nprint list(remove_adjacent(L))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Solution using list comprehensions, zipping then iterating through a twice.", "Inefficient, but short and sweet.", "It also has the problem of extending a[1:] with something. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = [ 1,2,2,2,3,4,4,5,3,3 ]\n\nb = [ i for i,j in zip(a,a[1:] + [None]) if not i == j ]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This works, but I'm not quite happy with it yet because of the +[None] bit to ensure that the last element is also returned..."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "+[None]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; mylist=[1,2,2,3,3,3,3,4,5,5,5]\n&gt;&gt;&gt; [x for x, y in zip(mylist, mylist[1:]+[None]) if x != y]\n[1, 2, 3, 4, 5]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The most Pythonic way is probably to go the path of least resistance and use itertools.groupby() as suggested by THC4K and be done with it."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "itertools.groupby()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; def collapse( data ):\n...  return list(sorted(set(data)))\n... \n&gt;&gt;&gt; collapse([1,2,2,3])\n[1, 2, 3]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Second attempt after the additional requirment was added:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def remove_adjacent( data ):\n...     last = None\n...     for datum in data:\n...         if datum != last:\n...             last = datum\n...             yield datum\n...             \n&gt;&gt;&gt; list( remove_adjacent( [1,2,2,3,2] ) )\n[1, 2, 3, 2]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["A good post about this very problem:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.peterbe.com/plog/uniqifiers-benchmark"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.peterbe.com/plog/uniqifiers-benchmark", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.peterbe.com/plog/uniqifiers-benchmark"}]}], [{"text": ["You may want to look at itertools.", "Also, here's a tutorial on Python iterators and generators (pdf)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html"}, {"text": "tutorial on Python iterators and generators (pdf)", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.google.com/viewer?a=v&q=cache%3aLtZo_DxLjGcJ%3aheather.cs.ucdavis.edu/~matloff/Python/PyIterGen.pdf+python+iter&hl=en&gl=us&pid=bl&srcid=ADGEESiaLc1Y5ma90UngbCLHgKMWQnU6fOItL9OlFjIBRFC21CPcdd3e8LR51I84KQ7sMYI3JceHf2Enmhk2jvmcczpjBIZ9N2Wu--5Mu0cgpklukXtvLchh8_VGqq52uLXbt_HkwXNm&sig=AHIEtbSwRJgimaInqD5eJWvY7-TlChvpVA"}]}], [{"text": ["This is also somewhat functional; it could be written as a one-liner using lambdas but that would just make it more confusing.", "In Python 3 you'd need to import reduce from functools."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def remove_adjacent(nums):\n  def maybe_append(l, x):\n    return l + ([] if len(l) and l[-1] == x else [x])\n  return reduce(maybe_append, nums, [])\n</code>\n</pre>\n", "senID": 1}]]