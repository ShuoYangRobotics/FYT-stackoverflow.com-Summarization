[[{"text": ["As of 2.6, use abstract base classes."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "abstract base classes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/abc.html#module-abc"}]}, {"code": "<pre class=\"lang-none prettyprint-override\">\n<code>\n &gt;&gt;&gt; import collections\n&gt;&gt;&gt; isinstance([], collections.Sequence)\nTrue\n&gt;&gt;&gt; isinstance(0, collections.Sequence)\nFalse\n</code>\n</pre>\n", "senID": 1}, {"text": ["Furthermore ABC's can be customized to account for exceptions, such as not considering strings to be sequences.", "Here an example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import abc\nimport collections\n\nclass Atomic(object):\n    __metaclass__ = abc.ABCMeta\n    @classmethod\n    def __subclasshook__(cls, other):\n        return not issubclass(other, collections.Sequence) or NotImplemented\n\nAtomic.register(basestring)\n</code>\n</pre>\n", "senID": 3}, {"text": ["After registration the Atomic class can be used with isinstance and issubclass:"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "Atomic", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "isinstance", "childNum": 0, "tag": "strong", "childList": []}, {"text": "issubclass", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n assert isinstance(\"hello\", Atomic) == True\n</code>\n</pre>\n", "senID": 5}, {"text": ["This is still much better than a hard-coded list, because you only need to register the exceptions to the rule, and external users of the code can register their own."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["In older versions, there are type checkers in the operator module."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre class=\"lang-none prettyprint-override\">\n<code>\n &gt;&gt;&gt; import operator\n&gt;&gt;&gt; operator.isSequenceType([])\nTrue\n&gt;&gt;&gt; operator.isSequenceType(0)\nFalse\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Sequences are described here:\nhttp://www.python.org/doc/2.5.2/lib/typesseq.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.python.org/doc/2.5.2/lib/typesseq.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/typesseq.html"}]}, {"text": ["So sequences are not the same as iterable objects.", "I think sequence must implement\n__getitem__, whereas iterable objects must implement __iter__.", "So for example string are sequences and don't implement __iter__, xrange objects are sequences and don't implement __getslice__."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "__getitem__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__iter__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__iter__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__getslice__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["But from what you seen to want to do, I'm not sure you want sequences, but rather iterable objects.", "So go for hasattr(\"__getitem__\", X) you want sequences, but go rather hasattr(\"__iter__\", X) if you don't want strings for example."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "hasattr(\"__getitem__\", X)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "hasattr(\"__iter__\", X)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["IMHO, the python way is to pass the list as *list.", "As in:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n myfunc(item)\nmyfunc(*items)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Based on the revised question, it sounds like what you want is something more like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def to_sequence(arg):\n    ''' \n    determine whether an arg should be treated as a \"unit\" or a \"sequence\"\n    if it's a unit, return a 1-tuple with the arg\n    '''\n    def _multiple(x):  \n        return hasattr(x,\"__iter__\")\n    if _multiple(arg):  \n        return arg\n    else:\n        return (arg,)\n\n&gt;&gt;&gt; to_sequence(\"a string\")\n('a string',)\n&gt;&gt;&gt; to_sequence( (1,2,3) )\n(1, 2, 3)\n&gt;&gt;&gt; to_sequence( xrange(5) )\nxrange(5)\n</code>\n</pre>\n", "senID": 1}, {"text": ["This isn't guaranteed to handle all types, but it handles the cases you mention quite well, and should do the right thing for most of the built-in types."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "all", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["When using it, make sure whatever receives the output of this can handle iterables."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["In cases like this, I prefer to just always take the sequence type or always take the scalar.", "Strings won't be the only types that would behave poorly in this setup; rather, any type that has an aggregate use and allows iteration over its parts might misbehave."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The simplest method would be to check if you can turn it into an iterator.", "ie"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    it = iter(X)\n    # Iterable\nexcept TypeError:\n    # Not iterable\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you need to ensure that it's a restartable or random access sequence (ie not a generator etc), this approach won't be sufficient however."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["As others have noted, strings are also iterable, so if you need so exclude them (particularly important if recursing through items, as list(iter('a')) gives ['a'] again, then you may need to specifically exclude them with:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n if not isinstance(X, basestring)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Revised answer: "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Revised answer:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I don't know if your idea of \"sequence\" matches what the Python manuals call a \"Sequence Type\", but in case it does, you should look for the __Contains__ method.", "That is the method Python uses to implement the check \"if something in object:\""], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Sequence Type", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.5.2/lib/typesseq.html"}]}, {"code": "<pre>\n<code>\n if hasattr(X, '__contains__'):\n    print \"X is a sequence\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["My original answer:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "My original answer:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I would check if the object that you received implements an iterator interface:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n if hasattr(X, '__iter__'):\n    print \"X is a sequence\"\n</code>\n</pre>\n", "senID": 5}, {"text": ["For me, that's the closest match to your definition of sequence since that would allow you to do something like:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n for each in X:\n    print each\n</code>\n</pre>\n", "senID": 7}], [{"text": ["I'm new here so I don't know what's the correct way to do it.", "I want to answer my answers:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The problem with all of the above mentioned ways is that str is considered a sequence (it's iterable, has __getitem__, etc.", ") yet it's usually treated as a single item."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "str", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "str", "tag": "code"}]}, {"text": "str", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__getitem__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["For example, a function may accept an argument that can either be a filename or a list of filenames.", "What's the most Pythonic way for the function to detect the first from the latter?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Should I post this as a new question?", "Edit the original one?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If strings are the problem, detect a sequence and filter out the special case of strings:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_iterable(x):\n  if type(x) == str:\n    return False\n  try:\n    iter(x)\n    return True\n  except TypeError:\n    return False\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think what I would do is check whether the object has certain methods that indicate it is a sequence.", "I'm not sure if there is an official definition of what makes a sequence.", "The best I can think of is, it must support slicing.", "So you could say:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n is_sequence = '__getslice__' in dir(X)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You might also check for the particular functionality you're going to be using."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["As pi pointed out in the comment, one issue is that a string is a sequence, but you probably don't want to treat it as one.", "You could add an explicit test that the type is not str."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You're asking the wrong question.", "You don't try to detect types in Python; you detect behavior."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def _use_single_val(v):\n        print v + 1  # this will fail if v is not a value type\n\n    def _use_sequence(s):\n        print s[0]   # this will fail if s is not indexable\n\n    def use_seq_or_val(item):    \n        try:\n            _use_single_val(item)\n        except TypeError:\n            pass\n\n        try:\n            _use_sequence(item)\n        except TypeError:\n            pass\n\n        raise TypeError, \"item not a single value or sequence\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: Revised to handle the \"sequence or single value\" asked about in the question. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could pass your parameter in the built-in len() function and check whether this causes an error.", "As others said, the string type requires special handling."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["According to the documentation the len function can accept a sequence (string, list, tuple) or a dictionary."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You could check that an object is a string with the following code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n x.__class__ == \"\".__class__\n</code>\n</pre>\n", "senID": 3}]]