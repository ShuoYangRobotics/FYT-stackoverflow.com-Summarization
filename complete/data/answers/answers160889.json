[[{"text": ["Look at documentation for following modules on CPAN"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "CPAN", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cpan.org/"}]}, {"text": ["HTML::TreeBuilder"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "HTML::TreeBuilder", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/search?query=HTML%3A%3ATreeBuilder&mode=all"}]}, {"text": ["HTML::TableExtract"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "HTML::TableExtract", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/author/MSISK/HTML-TableExtract-2.10/lib/HTML/TableExtract.pm"}]}, {"text": ["and"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Parse::RecDescent"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Parse::RecDescent", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/search?query=parse+recdescent&mode=all"}]}, {"text": ["I've used these modules to process quite large and complex web-pages."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["If you're specifically after parsing links out of web-pages, then Perl's WWW::Mechanize module will figure things out for you in a very elegant fashion.", "Here's a sample program that grabs the first page of Stack Overflow and parses out all the links, printing their text and corresponding URLs:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "WWW::Mechanize", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/perldoc?WWW::Mechanize"}]}, {"code": "<pre>\n<code>\n #!/usr/bin/perl\nuse strict;\nuse warnings;\nuse WWW::Mechanize;\n\nmy $mech = WWW::Mechanize-&gt;new;\n\n$mech-&gt;get(\"http://stackoverflow.com/\");\n\n$mech-&gt;success or die \"Oh no! Couldn't fetch stackoverflow.com\";\n\nforeach my $link ($mech-&gt;links) {\n    print \"* [\",$link-&gt;text, \"] points to \", $link-&gt;url, \"\\n\";\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["In the main loop, each $link is a WWW::Mechanize::Link object, so you're not just constrained to getting the text and URL."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "$link", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://search.cpan.org/perldoc?WWW::Mechanize::Link", "text": "WWW::Mechanize::Link", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["All the best,"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Paul"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Sounds like you really just want to parse HTML, I recommend looking at any of the wonderful packages for doing so:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["BeautifulSoup"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["lxml.html"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}, {"text": ["html5lib"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}]}, {"text": ["Or!", "You can use a parser like one of the following:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["PyParsing"], "childNum": 0, "tag": "a", "senID": 5, "childList": []}, {"text": ["DParser"], "childNum": 0, "tag": "a", "senID": 6, "childList": []}, {"text": ["ANTLR"], "childNum": 0, "tag": "a", "senID": 7, "childList": []}]}, {"text": ["This example is from the BeautifulSoup Documentation:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/documentation.html"}]}, {"code": "<pre>\n<code>\n from BeautifulSoup import BeautifulSoup, SoupStrainer\nimport re\n\nlinks = SoupStrainer('a')\n[tag for tag in BeautifulSoup(doc, parseOnlyThese=links)]\n# [&lt;a href=\"http://www.bob.com/\"&gt;success&lt;/a&gt;, \n#  &lt;a href=\"http://www.bob.com/plasma\"&gt;experiments&lt;/a&gt;, \n#  &lt;a href=\"http://www.boogabooga.net/\"&gt;BoogaBooga&lt;/a&gt;]\n\nlinksToBob = SoupStrainer('a', href=re.compile('bob.com/'))\n[tag for tag in BeautifulSoup(doc, parseOnlyThese=linksToBob)]\n# [&lt;a href=\"http://www.bob.com/\"&gt;success&lt;/a&gt;, \n#  &lt;a href=\"http://www.bob.com/plasma\"&gt;experiments&lt;/a&gt;]\n</code>\n</pre>\n", "senID": 9}], [{"text": ["Have you looked at PyParsing?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PyParsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}]}, {"text": ["From their homepage:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here is a program to parse \"Hello, World!", "\" (or any greeting of the form \", !", "\"):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from pyparsing import Word, alphas\ngreet = Word( alphas ) + \",\" + Word( alphas ) + \"!\" # &lt;-- grammar defined here\nhello = \"Hello, World!\"\nprint hello, \"-&gt;\", greet.parseString( hello )\n</code>\n</pre>\n", "senID": 3}, {"text": ["The program outputs the following:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n Hello, World! -&gt; ['Hello', ',', 'World', '!']\n</code>\n</pre>\n", "senID": 5}], [{"text": ["If your problem has anything at all to do with web scraping, I recommend looking at Web::Scraper , which provides easy element selection via XPath respectively CSS selectors.", "I have a (German) talk on Web::Scraper , but if you run it through babelfish or just look at the code samples, that can help you to get a quick overview of the syntax."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Web::Scraper", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/perldoc?Web::Scraper"}, {"text": "talk on Web::Scraper", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://datenzoo.de/pub/gpw2008/web-scraper/web-scraper-talk.html"}]}, {"text": ["Hand-parsing HTML is onerous and won't give you much over using one of the premade HTML parsers.", "If your HTML is of very limited variation, you can get by by using clever regular expressions, but if you're already breaking out hard-core parser tools, it sounds as if your HTML is far more regular than what is sane to parse with regular expressions."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Also check out pQuery it as a really nice Perlish way of doing this kind of stuff...."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pQuery", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/dist/pQuery/"}]}, {"code": "<pre>\n<code>\n use pQuery;\n\npQuery( 'http://www.perl.com' )-&gt;find( 'a' )-&gt;each( \n    sub {\n        my $pQ = pQuery( $_ ); \n        say $pQ-&gt;text, ' -&gt; ', $pQ-&gt;toHtml;\n    }\n);\n\n# prints all HTML anchors on www.perl.com\n# =&gt;  link text -&gt; anchor HTML\n</code>\n</pre>\n", "senID": 1}, {"text": ["However if your requirement is beyond HTML/Web then here is the earlier \"Hello World!", "\" example in Parse::RecDescent..."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Parse::RecDescent", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://search.cpan.org/dist/Parse-RecDescent/lib/Parse/RecDescent.pm"}]}, {"code": "<pre>\n<code>\n use strict;\nuse warnings;\nuse Parse::RecDescent;\n\nmy $grammar = q{\n    alpha : /\\w+/\n    sep   : /,|\\s/\n    end   : '!'\n    greet : alpha sep alpha end { shift @item; return \\@item }\n};\n\nmy $parse = Parse::RecDescent-&gt;new( $grammar );\nmy $hello = \"Hello, World!\";\nprint \"$hello -&gt; @{ $parse-&gt;greet( $hello ) }\";\n\n# =&gt; Hello, World! -&gt; Hello , World !\n</code>\n</pre>\n", "senID": 3}, {"text": ["Probably too much of a large hammer to crack this nut ;-)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["/I3az/"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["From  perlop:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "perlop", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://perldoc.perl.org/perlop.html#Regexp-Quote-Like-Operators"}]}], [{"text": ["Modifying Bruno's example to include error checking:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n my $input = \"...\";\nwhile (1) {\n    if ($input =~ /\\G(\\w+)/gc) { print \"word: '$1'\\n\"; next }\n    if ($input =~ /\\G(\\s+)/gc) { print \"whitespace: '$1'\\n\"; next }\n\n    if ($input !~ /\\G\\z/gc)  { print \"tokenizing error at character \" . pos($input) . \"\\n\" }\n    print \"done!\\n\"; last;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Note that using scalar //g is unfortunately the one place where you really can't avoid using the $1, etc.", "variables."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Oh, yes.", "Look here."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/133886/simple-regex-based-lexer-in-python"}]}]]