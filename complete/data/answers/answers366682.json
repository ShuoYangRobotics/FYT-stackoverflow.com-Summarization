[[{"text": ["I'm not sure how cross-platform this might be, but using signals and alarm might be a good way of looking at this.", "With a little work you could make this completely generic as well and usable in any situation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://docs.python.org/library/signal.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/signal.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/signal.html"}]}, {"text": ["So your code is going to look something like this."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import signal\n\ndef signal_handler(signum, frame):\n    raise Exception(\"Timed out!\")\n\nsignal.signal(signal.SIGALRM, signal_handler)\nsignal.alarm(10)   # Ten seconds\ntry:\n    long_function_call()\ncatch Exception, msg:\n    print \"Timed out!\"\n</code>\n</pre>\n", "senID": 3}], [{"text": ["An improvement on @rik.the.vik's answer would be to use the withstatement to give the timeout function some syntactic sugar:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "withstatement", "tag": "a", "pos": 0, "childList": [{"text": "with", "tag": "code"}], "childNum": 1, "href": "http://www.python.org/dev/peps/pep-0343/"}, {"text": "with", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from __future__ import with_statement # Required in 2.5\nimport signal\nfrom contextlib import contextmanager\n\nclass TimeoutException(Exception): pass\n\n@contextmanager\ndef time_limit(seconds):\n    def signal_handler(signum, frame):\n        raise TimeoutException, \"Timed out!\"\n    signal.signal(signal.SIGALRM, signal_handler)\n    signal.alarm(seconds)\n    try:\n        yield\n    finally:\n        signal.alarm(0)\n\n\ntry:\n    with time_limit(10):\n        long_function_call()\nexcept TimeoutException, msg:\n    print \"Timed out!\"\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You don't have to use threads.", "You can use another process to do the blocking work, for instance, maybe using the subprocess module.", "If you want to share data structures between different parts of your program then Twisted is a great library for giving yourself control of this, and I'd recommend it if you care about blocking and expect to have this trouble a lot.", "The bad news with Twisted is you have to rewrite your code to avoid any blocking, and there is a fair learning curve. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "subprocess", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/subprocess.html"}, {"text": "Twisted", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://twistedmatrix.com/trac/"}]}, {"text": ["You can use threads to avoid blocking, but I'd regard this as a last resort, since it exposes you to a whole world of pain.", "Read a good book on concurrency before even thinking about using threads in production, e.g.", "Jean Bacon's \"Concurrent Systems\".", "I work with a bunch of people who do really cool high performance stuff with threads, and we don't introduce threads into projects unless we really need them. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "can", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["The only \"safe\" way to do this, in any language, is to use a secondary process to do that timeout-thing, otherwise you need to build your code in such a way that it will time out safely by itself, for instance by checking the time elapsed in a loop or similar.", "If changing the method isn't an option, a thread will not suffice."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Why?", "Because you're risking leaving things in a bad state when you do.", "If the thread is simply killed mid-method, locks being held, etc.", "will just be held, and cannot be released."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So look at the process way, do not look at the thread way."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Doing this from within a signal handler is dangerous: you might be inside an exception handler at the time the exception is raised, and leave things in a broken state.", "For example,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def function_with_enforced_timeout():\n  f = open_temporary_file()\n  try:\n   ...\n  finally:\n   here()\n   unlink(f.filename)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If your exception is raised here(), the temporary file will never be deleted."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The solution here is for asynchronous exceptions to be postponed until the code is not inside exception-handling code (an except or finally block), but Python doesn't do that."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Note that this won't interrupt anything while executing native code; it'll only interrupt it when the function returns, so this may not help this particular case.", "(SIGALRM itself might interrupt the call that's blocking--but socket code typically simply retries after an EINTR."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Doing this with threads is a better idea, since it's more portable than signals.", "Since you're starting a worker thread and blocking until it finishes, there are none of the usual concurrency worries.", "Unfortunately, there's no way to deliver an exception asynchronously to another thread in Python (other thread APIs can do this).", "It'll also have the same issue with sending an exception during an exception handler, and require the same fix."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Here's a timeout function I think I found via google and it works for me."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["From:\nhttp://code.activestate.com/recipes/473878/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://code.activestate.com/recipes/473878/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/473878/"}]}, {"code": "<pre>\n<code>\n def timeout(func, args=(), kwargs={}, timeout_duration=1, default=None):\n    '''This function will spwan a thread and run the given function using the args, kwargs and \n    return the given default value if the timeout_duration is exceeded \n    ''' \n    import threading\n    class InterruptableThread(threading.Thread):\n        def __init__(self):\n            threading.Thread.__init__(self)\n            self.result = default\n        def run(self):\n            try:\n                self.result = func(*args, **kwargs)\n            except:\n                self.result = default\n    it = InterruptableThread()\n    it.start()\n    it.join(timeout_duration)\n    if it.isAlive():\n        return it.result\n    else:\n        return it.result\n</code>\n</pre>\n", "senID": 2}]]