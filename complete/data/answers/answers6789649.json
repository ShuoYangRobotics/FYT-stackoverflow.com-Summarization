[[{"text": ["The purpose of Project Euler is not really to think learn programming, but to think about algorithms.", "On problem #10, your algorithm will need to be even faster than on #7, etc.", "etc.", "So you need to come up with a better way to find prime numbers, not a faster way to run Python code.", "People solve these problems under the time limit with far slower computers that you're using now by thinking about the math."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "algorithms", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "math", "childNum": 0, "tag": "strong", "pos": 4, "childList": []}]}, {"text": ["On that note, maybe ask about your prime number algorithm on http://math.stackexchange.com/ if you really need help thinking about the problem."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://math.stackexchange.com/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://math.stackexchange.com/"}]}], [{"text": ["A few questions to ponder:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Do you really need to check the division until n-1? How earlier can you stop?", "tag": "none", "senID": 1}, {"text": "Apart from 2, do you really need to check the division by all the multiples of two ?", "tag": "none", "senID": 2}, {"text": "What about the multiples of 3? 5? Is there a way to extend this idea to all the multiples of previously tested primes?", "tag": "none", "senID": 3}]}], [{"text": ["A faster interpreter won't cut it.", "Even an implementation written in C or assembly language won't be fast enough (to be in the \"about one second\" timeframe of project Euler).", "To put it bluntly, your algorithm is pathetic.", "Some research and thinking will help you write an algorithm that runs faster in a dog-slow interpreter than your current algorithm implemented in native code (I won't name any specifics, partly because that's your job and partly because I can't tell offhand how much optimization will be needed)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Without discussing your algorithm, the PyPy interpreter can be ridiculously faster than the normal CPython one for tight numerical computation like this.", "You might want to try it out."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "PyPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypy.org/"}]}], [{"text": ["Many of the Euler problems (including this one) are designed to have a solution that computes in acceptable time on pretty much any given hardware and compiler (well, not INTERCAL on a PDP-11 maybe)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You algorithm works, but it has quadratic complexity.", "Using a faster interpreter will give you a linear performance boost, but the quadratic complexity will dwarf it long before you calculate 10,000 primes.", "There are algorithms with much lower complexity; find them (or google them, no shame in that and you'll still learn a lot) and implement them."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["As most people have said, it's all about coming up with the correct algorithm.", "Have you considered looking at a \nSieve of Eratosthenes"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Sieve of Eratosthenes", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"}]}], [{"text": ["based on the haskell code in the paper: The Genuine Sieve of Eratosthenes by Melissa E. O'Neill"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "The Genuine Sieve of Eratosthenes by Melissa E. O'Neill", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf"}]}, {"code": "<pre>\n<code>\n from itertools import cycle, chain, tee, islice\n\nwheel2357 = [2,4,2,4,6,2,6,4,2,4,6,6,2,6,4,2,6,4,6,8,4,2,4,2,4,8,6,4,6,2,4,6,2,6,6,4,2,4,6,2,6,4,2,4,2,10,2,10]\n\ndef spin(wheel, n):\n    for x in wheel:\n        yield n\n        n = n + x\n\nimport heapq\n\ndef insertprime(p,xs,t):\n    heapq.heappush(t,(p*p,(p*v for v in xs)))\n\ndef adjust(t,x):\n    while True:\n        n, ns = t[0]\n        if n &lt;= x:\n            n, ns = heapq.heappop(t)\n            heapq.heappush(t, (ns.next(), ns))\n        else:\n            break\n\ndef sieve(it):\n    t = []\n    x = it.next()\n    yield x\n    xs0, xs1 = tee(it)\n    insertprime(x,xs1,t)\n    it = xs0\n    while True:\n        x = it.next()\n        if t[0][0] &lt;= x:\n            adjust(t,x)\n            continue\n        yield x\n        xs0, xs1 = tee(it)\n        insertprime(x,xs1,t)\n        it = xs0\n\nprimes = chain([2,3,5,7], sieve(spin(cycle(wheel2357), 11)))\n\nfrom time import time\ns = time()\nprint list(islice(primes, 10000, 10001))\ne = time()\nprint \"%.8f seconds\" % (e-s)\n</code>\n</pre>\n", "senID": 1}, {"text": ["prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [104743]\n0.18839407 seconds\n</code>\n</pre>\n", "senID": 3}, {"code": "<pre>\n<code>\n from itertools import islice\nfrom heapq import heappush, heappop\n\nwheel2357 = [2,4,2,4,6,2,6,4,2,4,6,6,2,6,4,2,6,4,6,8,4,2,4,2,\n             4,8,6,4,6,2,4,6,2,6,6,4,2,4,6,2,6,4,2,4,2,10,2,10]\n\nclass spin(object):\n    __slots__ = ('wheel','o','n','m')\n    def __init__(self, wheel, n, o=0, m=1):\n        self.wheel = wheel\n        self.o = o\n        self.n = n\n        self.m = m\n    def __iter__(self):\n        return self\n    def next(self):\n        v = self.m*self.n\n        self.n += self.wheel[self.o]\n        self.o = (self.o + 1) % len(self.wheel)\n        return v\n    def copy(self):\n        return spin(self.wheel, self.n, self.o, self.m)\n    def times(self, x):\n        return spin(self.wheel, self.n, self.o, self.m*x)\n\ndef adjust(t,x):\n    while t[0][0] &lt;= x:\n        n, ns = heappop(t)\n        heappush(t, (ns.next(), ns))\n\ndef sieve_primes():\n\n    for p in [2,3,5,7]:\n        yield p\n\n    it = spin(wheel2357, 11)\n\n    t = []\n    p = it.next()\n    yield p\n    heappush(t, (p*p, it.times(p)))\n\n    while True:\n        p = it.next()\n        if t[0][0] &lt;= p:\n            adjust(t,p)\n            continue\n        yield p\n        heappush(t, (p*p, it.times(p)))\n\nfrom time import time\ns = time()\nprint list(islice(sieve_primes(), 10000, 10001))[-1]\ne = time()\nprint \"%.8f seconds\" % (e-s)\n</code>\n</pre>\n", "senID": 4}, {"text": ["prints:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n 104743\n0.22022200 seconds\n</code>\n</pre>\n", "senID": 6}, {"code": "<pre>\n<code>\n import time\nfrom math import sqrt\n\nwheel2357 = [2,4,2,4,6,2,6,4,2,4,6,6,2,6,4,2,6,4,6,8,4,2,4,2,4,8,6,4,6,2,4,6,2,6,6,4,2,4,6,2,6,4,2,4,2,10,2,10]\n\nlist_prime = [2,3,5,7]\n\ndef isprime(num):\n    limit = sqrt(num)\n    for prime in list_prime:\n        if num % prime == 0: return 0\n        if prime &gt; limit: break\n    return 1\n\ndef generate_primes(no_of_primes):\n    o = 0\n    n = 11\n    w = wheel2357\n    l = len(w)\n    while len(list_prime) &lt; no_of_primes:\n        i = n\n        n = n + w[o]\n        o = (o + 1) % l\n        if isprime(i): \n            list_prime.append(i)\n\nt0 = time.time()\ngenerate_primes(10001)\nprint list_prime[-1]        # 104743\nt1 = time.time()\nprint t1-t0                 # 0.18 seconds\n</code>\n</pre>\n", "senID": 7}, {"text": ["prints:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n 104743\n0.307313919067\n</code>\n</pre>\n", "senID": 9}]]