[[{"text": ["I don't think there's a more elegant way.", "Your code is very simple and clear."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Yes, that's definitely possible."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; [b for a in ((x,-x) for x in range(1, 10 + 1)) for b in a]\n[1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7, 8, -8, 9, -9, 10, -10]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Perhaps a generator expression?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i in (x/2 * (x%2 * 2 - 1) for x in xrange(2, radius*2)):\n    print i\n</code>\n</pre>\n", "senID": 1}, {"text": ["It is short and fits to your \"without defining a special function\" requirement..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["But, franky, I'd still prefer to use that special function instead - just for the sake of having more clear code.", ":)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Here's my go at it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import chain\n\n&gt;&gt;&gt; list(chain(*zip(range(1, 7), range(-7, 0)[::-1])))\n[1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Adjust as needed.", ":)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Why not just do this with an inner loop, instead of creating a funky generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n found = False\nfor i_abs in range(1, radius+1):\n    for i in (i_abs, -i_abs):\n        listitem = myList[baseIndex + i]\n        if pred(listitem):\n             result = listitem\n             found = True\n             break # terminate search when first item is found \n    if found:\n        break\nelse:\n    # handling in case no match found for pred\n</code>\n</pre>\n", "senID": 1}, {"text": ["Some other comments:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": ["you never test the 0'th element"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["since you are testing from both left\nand right, you should stop after\ni_abs reaches the halfway mark"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I don't like repeating list indexing operations,\nwould rather repeat a variable reference; so I\nlifted out the repeated myList[baseIndex+i] and\nassigned it to listitem"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "myList[baseIndex+i]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "listitem", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["you should add some handling in case\nthere is no matching element found"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["instead of breaking from the inner loop (which\nhere requires an extra found variable to \nbreak out of the outer for loop), you might \nbe better just returning result right from the \ninner loop, "], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "found", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "result", "childNum": 0, "tag": "code", "childList": []}]}]}, {"text": ["as in:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n for i_abs in range(1, radius+1):\n    for i in (i_abs, -i_abs):\n        listitem = myList[baseIndex + i]\n        if pred(listitem):\n             return listitem\n</code>\n</pre>\n", "senID": 9}, {"text": ["Then there is no break management or found variable required."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "found", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Why alternate -i, i?", "Just do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i in range(-radius, radius+1):\n    listitem = myList[baseIndex + i]\n        if pred(listitem):\n            return listitem\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or if you absolutely must approach from front and back to get the outermost pred-matcher, how about:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for i in sorted(range(-radius, radius+1), key=abs):\n    listitem = myList[baseIndex + i]\n        if pred(listitem):\n            return listitem\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you have to do this often, just build sorted(range(-radius,radius+1),key=abs) once and keep it around for future iterating."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "sorted(range(-radius,radius+1),key=abs)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If you absolutely must not use the 0'th element, just insert a if not i: continue at the start of your loop."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "if not i: continue", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This appears to me at least as readable as a separate function -- and arguably more understandable:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n radius = 3\nfor outerbounds in ((-r,r) for r in range(1,radius+1)):\n    for i in outerbounds :\n        print i\n# -1\n# 1\n# -2\n# 2\n# -3\n# 3\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Your own solution, adding a yield 0 at the start of the generator, is the most straightforward (aka pythonic)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "yield 0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Here's an infinite offset generator with a different algorithm:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def gen_offsets():\n    offset= 0\n    yield offset\n    step= 1; sign= 1\n    while 1:\n        offset+= sign*step\n        yield offset\n        step+= 1; sign= -sign\n</code>\n</pre>\n", "senID": 2}, {"text": ["A more fanciful (aka not-so-pythonic :) way to write the algorithm above is:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import itertools as it, operator as op\n\ndef gen_offsets():\n    steps= it.imap(op.mul, it.count(1), it.cycle( (1, -1) ))\n    offset= 0\n    yield offset\n    for step in steps:\n        offset+= step\n        yield offset\n</code>\n</pre>\n", "senID": 4}]]