[[{"text": ["Just removing the slash at the end won't work, as you can probably have a URL that looks like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n http://www.google.com/test.php?filepath=tests/hey.xml\n</code>\n</pre>\n", "senID": 1}, {"text": ["...in which case you'll get back \"hey.xml\".", "Instead of manually checking for this, you can use urlparse to get rid of the parameters, then do the check other people suggested:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "urlparse", "childNum": 0, "tag": "b", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from urlparse import urlparse\nurl = \"http://www.google.com/test.php?something=heyharr/sir/a.txt\"\nf = urlparse(url)[2].rstrip(\"/\")\nprint f[f.rfind(\"/\")+1:]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Use [r]strip to remove trailing slashes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n url.rstrip('/').rsplit('/', 1)[-1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["If a wider range of possible URLs is possible, including URLs with ?queries, #anchors or without a path, do it properly with urlparse:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n path= urlparse.urlparse(url).path\nreturn path.rstrip('/').rsplit('/', 1)[-1] or '(root path)'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Filenames with a slash at the end are technically still path definitions and indicate that the index file is to be read.", "If you actually have one that' ends in test.php/, I would consider that an error.", "In any case, you can strip the / from the end before running your code as follows:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "test.php/", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n url = url.rstrip('/')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There is a library called urlparse that will parse the url for you, but still doesn't remove the / at the end so one of the above will be the best option"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "urlparse", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/2.4/lib/module-urlparse.html"}]}], [{"text": ["Just for fun, you can use a Regexp:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nprint re.search('/([^/]+)/?$', url).group(1)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could use"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n print url[url.rstrip(\"/\").rfind(\"/\") +1 : ]\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n filter(None, url.split('/'))[-1]\n</code>\n</pre>\n", "senID": 0}, {"text": ["(But urlparse is probably more readable, even if more verbose."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]