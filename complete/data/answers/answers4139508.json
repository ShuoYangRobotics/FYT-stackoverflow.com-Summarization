[[{"text": ["You can add the methods as functions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Foo.b = Mixin.b.im_func\nFoo.c = Mixin.c.im_func\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def mixer(*args):\n    \"\"\"Decorator for mixing mixins\"\"\"\n    def inner(cls):\n        for a,k in ((a,k) for a in args for k,v in vars(a).items() if callable(v)):\n            setattr(cls, k, getattr(a, k).im_func)\n        return cls\n    return inner\n\nclass Mixin(object):\n    def b(self): print \"b()\"\n    def c(self): print \"c()\"\n\nclass Mixin2(object):\n    def d(self): print \"d()\"\n    def e(self): print \"e()\"\n\n\n@mixer(Mixin, Mixin2)\nclass Foo(object):\n    # Somehow mix in the behavior of the Mixin class,\n    # so that all of the methods below will run and\n    # the issubclass() test will be False.\n\n    def a(self): print \"a()\"\n\nf = Foo()\nf.a()\nf.b()\nf.c()\nf.d()\nf.e()\nprint issubclass(Foo, Mixin)\n</code>\n</pre>\n", "senID": 0}, {"text": ["output:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a()\nb()\nc()\nd()\ne()\nFalse\n</code>\n</pre>\n", "senID": 2}], [{"text": ["EDIT: Fixed what could (and probably should) be construed as a bug.", "Now it builds a new dict and then updates that from the class's dict.", "This prevents mixins from overwriting methods that are defined directly on the class.", "The code is still untested but should work.", "I'm busy ATM so I'll test it later.", "It worked fine except for a syntax error.", "In retrospect, I decided that I don't like it (even after my further improvements) and much prefer my other solution even if it is more complicated.", "The test code for that one applies here as well but I wont duplicate it."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "The code is still untested but should work. I'm busy ATM so I'll test it later.", "childNum": 0, "tag": "strike", "pos": -1, "childList": []}, {"text": "my other solution", "tag": "a", "pos": 6, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4139508/in-python-can-one-implement-mixin-behavior-without-using-inheritance/4144261#4144261"}]}, {"text": ["You could use a metaclass factory:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import inspect\n\n def add_mixins(*mixins):\n     Dummy = type('Dummy', mixins, {})\n     d = {}\n\n     for mixin in reversed(inspect.getmro(Dummy)):\n         d.update(mixin.__dict__)\n\n     class WithMixins(type):\n         def __new__(meta, classname, bases, classdict):\n             d.update(classdict)\n             return super(WithMixins, meta).__new__(meta, classname, bases, d)\n     return WithMixins\n</code>\n</pre>\n", "senID": 2}, {"text": ["then use it like:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Foo(object):\n     __metaclass__ = add_mixins(Mixin1, Mixin2)\n\n     # rest of the stuff\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I am not that familiar with Python, but from what I know about Python metaprogramming, you could actually do it pretty much the same way it is done in Ruby."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In Ruby, a module basically consists of two things: a pointer to a method dictionary and a pointer to a constant dictionary.", "A class consists of three things: a pointer to a method dictionary, a pointer to a constant dictionary and a pointer to the superclass."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["When you mix in a module M into a class C, the following happens:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "M", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "C", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In other words: a fake class which shares its behavior with the mixin is injected into the inheritance hierarchy.", "So, Ruby actually does use inheritance for mixin composition."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "does", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["I left out a couple of subleties above: first off, the module doesn't actually get inserted as C's superclass, it gets inserted as C's superclasses' (which is C's singleton class) superclass.", "And secondly, if the mixin itself has mixed in other mixins, then those also get wrapped into fake classes which get inserted directly above \u03b1, and this process is applied recursively, in case the mixed in mixins in turn have mixins."], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "C", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "C", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "C", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "those", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "\u03b1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Basically, the whole mixin hierarchy gets flattened into a straight line and spliced into the inheritance chain."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["AFAIK, Python actually allows you to change a class's superclass(es) after the fact (something which Ruby does not allow you to do), and it also gives you access to a class's dict (again, something that is impossible in Ruby), so you should be able to implement this yourself."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["This one is based on the way it's done in ruby as explained by J\u00f6rg W Mittag.", "All of the wall of code after if __name__=='__main__' is test/demo code.", "There's actually only 13 lines of real code to it."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "explained by J\u00f6rg W Mittag", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4139508/in-python-can-one-implement-mixin-behavior-without-using-inheritance/4139785#4139785"}, {"text": "if __name__=='__main__'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import inspect\n\ndef add_mixins(*mixins):\n    Dummy = type('Dummy', mixins, {})\n    d = {}\n\n    # Now get all the class attributes. Use reversed so that conflicts\n    # are resolved with the proper priority. This rules out the possibility\n    # of the mixins calling methods from their base classes that get overridden\n    # using super but is necessary for the subclass check to fail. If that wasn't a\n    # requirement, we would just use Dummy above (or use MI directly and\n    # forget all the metaclass stuff).\n\n    for base in reversed(inspect.getmro(Dummy)):\n        d.update(base.__dict__)\n\n    # Create the mixin class. This should be equivalent to creating the\n    # anonymous class in Ruby.\n    Mixin = type('Mixin', (object,), d)\n\n    class WithMixins(type):\n        def __new__(meta, classname, bases, classdict):\n            # The check below prevents an inheritance cycle from forming which\n            # leads to a TypeError when trying to inherit from the resulting\n            # class.\n            if not any(issubclass(base, Mixin) for base in bases):\n                # This should be the the equivalent of setting the superclass \n                # pointers in Ruby.\n                bases = (Mixin,) + bases\n            return super(WithMixins, meta).__new__(meta, classname, bases,\n                                                   classdict)\n\n    return WithMixins \n\n\nif __name__ == '__main__':\n\n    class Mixin1(object):\n        def b(self): print \"b()\"\n        def c(self): print \"c()\"\n\n    class Mixin2(object):\n        def d(self): print \"d()\"\n        def e(self): print \"e()\"\n\n    class Mixin3Base(object):\n        def f(self): print \"f()\"\n\n    class Mixin3(Mixin3Base): pass\n\n    class Foo(object):\n        __metaclass__ = add_mixins(Mixin1, Mixin2, Mixin3)\n\n        def a(self): print \"a()\"\n\n    class Bar(Foo):\n        def f(self): print \"Bar.f()\"\n\n    def test_class(cls):\n        print \"Testing {0}\".format(cls.__name__)\n        f = cls()\n        f.a()\n        f.b()\n        f.c()\n        f.d()\n        f.e()\n        f.f()\n        print (issubclass(cls, Mixin1) or \n               issubclass(cls, Mixin2) or\n               issubclass(cls, Mixin3))\n\n    test_class(Foo)\n    test_class(Bar)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could decorate the classes __getattr__ to check in the mixin.", "The problem is that all methods of the mixin would always require an object the type of the mixin as their first parameter, so you would have to decorate __init__ as well to create a mixin-object.", "I believe you could achieve this using a class decorator."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__getattr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "class decorator", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/681953/python-class-decorator"}]}], [{"code": "<pre>\n<code>\n from functools import partial\nclass Mixin(object):\n    @staticmethod\n    def b(self): print \"b()\"\n    @staticmethod\n    def c(self): print \"c()\"\n\nclass Foo(object):\n    def __init__(self, mixin_cls):\n        self.delegate_cls = mixin_cls\n\n    def __getattr__(self, attr):\n        if hasattr(self.delegate_cls, attr):\n            return partial(getattr(self.delegate_cls, attr), self)\n\n    def a(self): print \"a()\"\n\nf = Foo(Mixin)\nf.a()\nf.b()\nf.c()\nprint issubclass(Foo, Mixin)\n</code>\n</pre>\n", "senID": 0}, {"text": ["This basically uses the Mixin class as a container to hold ad-hoc functions (not methods) that behave like methods by taking an object instance (self) as the first argument.", "__getattr__ will redirect missing calls to these methods-alike functions."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "Mixin", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ad-hoc", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "__getattr__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This passes your simple tests as shown below.", "But I cannot guarantee it will do all the things you want.", "Make more thorough test to make sure."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ python mixin.py \na()\nb()\nc()\nFalse\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Composition?", "It seems like that would be the simplest way to handle this: either wrap your object in a decorator or just import the methods as an object into your class definition itself.", "This is what I usually do: put the methods that I want to share between classes in a file and then import the file.", "If I want to override some behavior I import a modified file with the same method names as the same object name.", "It's a little sloppy, but it works."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, if I want the init_covers behavior from this file (bedg.py)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "init_covers", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import cove as cov\n\n\ndef init_covers(n):\n    n.covers.append(cov.Cover((set([n.id]))))\n    id_list = []\n    for a in n.neighbors:\n        id_list.append(a.id)\n    n.covers.append(cov.Cover((set(id_list))))\n\ndef update_degree(n):\n    for a in n.covers:\n        a.degree = 0\n        for b in n.covers:\n            if  a != b:\n                a.degree += len(a.node_list.intersection(b.node_list))\n</code>\n</pre>\n", "senID": 2}, {"text": ["In my bar class file I would do: import bedg as foo"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "import bedg as foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["and then if I want to change my foo behaviors in another class that inherited bar, I write"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["import bild as foo"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "import bild as foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Like I say, it is sloppy."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]