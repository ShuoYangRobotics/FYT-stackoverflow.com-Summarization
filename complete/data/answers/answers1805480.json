[[{"text": ["you could use a 2 dimensional array, holding objects for the state of each field:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class FieldState(object):\n  def __init__(self):\n    self.unexplored = True\n    self.mine = Random()\n    self.flag = Random()\n    ...\n\nfor x in range(12):\n  for y in range(24):\n    list[x][y] = FieldState()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Use a nested list.", "It's easy to set up:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n field = [([None] * height) for x in range(width)]\n\nfield[x][y] = \"*\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["The clearest thing would probably be a new class:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class MineField(object):\n    class _SingleField(object):\n        mine = False\n        flagged = False\n        covered = True\n\n    width = None\n    height = None\n\n    def __init__(self, width, height):\n        super(MineField, self).__init__()\n        self.width = width\n        self.height = height\n        self._field = [[self._SingleField() for y in range(height)]\n                                            for x in range(width)]\n\n        self.init_field(10)\n\n    def init_field(self, minecount):\n        pass\n\n    def __getitem__(self, index):\n        x, y = index\n        return self._field[x][y]\n</code>\n</pre>\n", "senID": 3}, {"text": ["To be used like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n> m = MineField(10,10)\n> m[4,9].mine\nFalse\n</pre>\n", "senID": 5}], [{"text": ["Just to throw another option in the mix, you could use dicts indexed by tuples"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n board = {}\nboard[1, 2] = 9\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you use an instance of Board class you can always change the internal representation later."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Board", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Board(object):\n    def __init__(self, width, height):\n        self.__width, self.__height = width, height\n        self._board = [[FieldState() for y in xrange(height)]\n                       for x in xrange(width)]\n    @property\n    def width(self):\n        return self.__width\n\n    def mark(self, x, y):\n        self._board[x][y].mark()\n\n    def __getitem__(self, coord):\n        \"\"\"\n        &gt;&gt;&gt; board = Board(3, 4)\n        &gt;&gt;&gt; field = board[1,2] # 2nd column, 3rd row\n        \"\"\"\n        x, y = coord\n        return self._board[x][y]\n\n    ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["Where FieldState is similar to the one from @zlack's answer."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "FieldState", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/1805480/how-would-you-represent-a-minesweeper-grid-in-python/1805509#1805509", "text": "@zlack's answer", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I think there are basically two layers of data: 1) map data: does square have a bomb (e.g represented by -1) or how many bombs are around it, 2) display data, what is shown on the square: bomb count, bomb, flag, question mark, empty, unopened."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So two nested lists (or one nested list of tuples) might be enough."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You could mark locations with a single int showing exactly what sits there, easing your coding considerably.", "You wouldnt need two data layers. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n 00 nothing, noflag\n10 bomb, noflag\n01 nothing,flagged\n11 bomb, flagged\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now since the first bit of that int shows whether there is a bomb or not, we can actually give it a few more bits and indicate neighbour count as well. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 000 no-neighbor\n001 one neighbor\n010 two...\n</code>\n</pre>\n", "senID": 3}, {"text": ["and so on.", "Storing this only takes a single byte and even leaves room for expansion."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["A map of 'tile' or 'cell' objects, keyed to the coordinates as a pair. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n current = (1,1)\nif grid[current].isFlagged():\n   do_whatever;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Of course, map takes a little more space than array, and the tile class will have a tiny bit more footprint than a primitive bitmap or number, but I assume your board isn't 1024x1024 and you're not in a highly constrainted RAM situation."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you do more than look up the tiles in the grid, then do consider JF's Board object to wrap the array."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Python is an OO language, and often the simplest and clearest thing that works is to use classes and objects wisely."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Note: you might also look at the named_tuple class for situations that seem too simple for a proper class."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]