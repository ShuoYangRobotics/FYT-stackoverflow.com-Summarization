[[{"text": ["I would assume a regex is better than checking for each substring individually because conceptually the regular expression is modeled as a DFA, and so as the input is consumed all matches are being tested for at the same time (resulting in one scan of the input string)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "conceptually", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["So, here is an example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef work():\n  to_find = re.compile(\"cat|fish|dog\")\n  search_str = \"blah fish cat dog haha\"\n  match_obj = to_find.search(search_str)\n  the_index = match_obj.start()  # produces 5, the index of fish\n  which_word_matched = match_obj.group()  # \"fish\"\n  # Note, if no match, match_obj is None\n</code>\n</pre>\n", "senID": 2}, {"text": ["It should be noted that you will want to form the regex (ie - call to re.compile()) as little as possible.", "The best case would be you know ahead of time what your searches are (or you compute them once/infrequently) and then save the result of re.compile somewhere.", "My example is just a simple nonsense function so you can see the usage of the regex.", "There are some more regex docs here:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["http://docs.python.org/library/re.html"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "http://docs.python.org/library/re.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html"}]}, {"text": ["Hope this helps."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["UPDATE: I am unsure about how python implements regular expressions, but to answer Rax's question about whether or not there are limitations of re.compile() (for example, how many words you can try to \"|\" together to match at once), and the amount of time to run compile: neither of these seem to be an issue.", "I tried out this code, which is good enough to convince me.", "(I could have made this better by adding timing and reporting results, as well as throwing the list of words into a set to ensure there are no duplicates... but both of these improvements seem like overkill).", "This code ran basically instantaneously, and convinced me that I am able to search for 2000 words (of size 10), and that and of them will match appropriately.", "Here is the code:"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "UPDATE:", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "UPDATE:", "tag": "em"}]}, {"text": "UPDATE:", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import random\nimport re\nimport string\nimport sys\n\ndef main(args):\n    words = []\n    letters_and_digits = \"%s%s\" % (string.letters, string.digits)\n    for i in range(2000):\n        chars = []\n        for j in range(10):\n            chars.append(random.choice(letters_and_digits))\n        words.append((\"%s\"*10) % tuple(chars))\n    search_for = re.compile(\"|\".join(words))\n    first, middle, last = words[0], words[len(words) / 2], words[-1]\n    search_string = \"%s, %s, %s\" % (last, middle, first)\n    match_obj = search_for.search(search_string)\n    if match_obj is None:\n        print \"Ahhhg\"\n        return\n    index = match_obj.start()\n    which = match_obj.group()\n    if index != 0:\n        print \"ahhhg\"\n        return\n    if words[-1] != which:\n        print \"ahhg\"\n        return\n\n    print \"success!!! Generated 2000 random words, compiled re, and was able to perform matches.\"\n\nif __name__ == \"__main__\":\n    main(sys.argv)\n</code>\n</pre>\n", "senID": 7}, {"text": ["UPDATE: It should be noted that the order of of things ORed together in the regex matters.", "Have a look at the following test inspired by TZOTZIOY:"], "childNum": 4, "tag": "p", "senID": 8, "childList": [{"text": "UPDATE:", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "UPDATE:", "tag": "em"}]}, {"text": "UPDATE:", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "matters", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "TZOTZIOY", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/6899/"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; search_str = \"01catdog\"\n&gt;&gt;&gt; test1 = re.compile(\"cat|catdog\")\n&gt;&gt;&gt; match1 = test1.search(search_str)\n&gt;&gt;&gt; match1.group()\n'cat'\n&gt;&gt;&gt; match1.start()\n2\n&gt;&gt;&gt; test2 = re.compile(\"catdog|cat\")  # reverse order\n&gt;&gt;&gt; match2 = test2.search(search_str)\n&gt;&gt;&gt; match2.group()\n'catdog'\n&gt;&gt;&gt; match2.start()\n2\n</code>\n</pre>\n", "senID": 9}, {"text": ["This suggests the order matters :-/.", "I am not sure what this means for Rax's application, but at least the behavior is known."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["UPDATE: I posted this questions about the implementation of regular expressions in Python which will hopefully give us some insight"], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "UPDATE:", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "UPDATE:", "tag": "em"}]}, {"text": "UPDATE:", "childNum": 0, "tag": "em", "childList": []}, {"href": "http://stackoverflow.com/questions/844183/python-regular-expression-implementation-details", "text": "this questions about the implementation of regular expressions in Python", "childNum": 0, "tag": "a", "childList": []}]}], [{"code": "<pre>\n<code>\n subs = ['cat', 'fish', 'dog']\nsentences = ['0123dog789cat']\n\nimport re\n\nsubs = re.compile(\"|\".join(subs))\ndef search():\n    for sentence in sentences:\n        result = subs.search(sentence)\n        if result != None:\n            return (result.group(), result.span()[0])\n\n# ('dog', 4)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This is a vague, theoretical answer with no code provided, but I hope it can point you in the right direction."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First, you will need a more efficient lookup for your substring list.", "I would recommend some sort of tree structure.", "Start with a root, then add an 'a' node if any substrings start with 'a', add a 'b' node if any substrings start with 'b', and so on.", "For each of these nodes, keep adding subnodes."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "'a'", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "'a'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "'b'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "'b'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["For example, if you have a substring with the word \"ant\", you should have a root node, a child node 'a', a grandchild node 'n', and a great grandchild node 't'."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "'a'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'n'", "childNum": 0, "tag": "code", "childList": []}, {"text": "'t'", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Nodes should be easy enough to make."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class Node(object):\n    children = []\n\n    def __init__(self, name):\n        self.name = name\n</code>\n</pre>\n", "senID": 4}, {"text": ["where name is a character."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "name", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Iterate through your strings letter by letter.", "Keep track of which letter you're on.", "At each letter, try to use the next few letters to traverse the tree.", "If you're successful, your letter number will be the position of the substring, and your traversal order will indicate the substring that was found."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Clarifying edit: DFAs should be much faster than this method, and so I should endorse Tom's answer.", "I'm only keeping this answer up in case your substring list changes often, in which case using a tree might be faster."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "Tom's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/842856/whats-the-most-efficient-way-to-find-one-of-several-substrings-in-python/842871#842871"}, {"text": "might", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["I just want to point out the time difference between DisplacedAussie's answer and Tom's answer.", "Both were fast when used once, so you shouldn't have any noticeable wait for either, but when you time them:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random\nimport re\nimport string\n\nwords = []\nletters_and_digits = \"%s%s\" % (string.letters, string.digits)\nfor i in range(2000):\n    chars = []\n    for j in range(10):\n        chars.append(random.choice(letters_and_digits))\n    words.append((\"%s\"*10) % tuple(chars))\nsearch_for = re.compile(\"|\".join(words))\nfirst, middle, last = words[0], words[len(words) / 2], words[-1]\nsearch_string = \"%s, %s, %s\" % (last, middle, first)\n\ndef _search():\n    match_obj = search_for.search(search_string)\n    # Note, if no match, match_obj is None\n    if match_obj is not None:\n         return (match_obj.start(), match_obj.group())\n\ndef _map():\n    search_for = search_for.pattern.split(\"|\")\n    found = map(lambda x: (search_string.index(x), x), filter(lambda x: x in search_string, search_for))\n    if found:\n        return min(found, key=lambda x: x[0])\n\n\nif __name__ == '__main__':\n    from timeit import Timer\n\n\n    t = Timer(\"_search(search_for, search_string)\", \"from __main__ import _search, search_for, search_string\")\n    print _search(search_for, search_string)\n    print t.timeit()\n\n    t = Timer(\"_map(search_for, search_string)\", \"from __main__ import _map, search_for, search_string\")\n    print _map(search_for, search_string)\n    print t.timeit()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Outputs:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n (0, '841EzpjttV')\n14.3660159111\n(0, '841EzpjttV')\n# I couldn't wait this long\n</code>\n</pre>\n", "senID": 3}, {"text": ["I would go with Tom's answer, for both readability, and speed."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["First of all, I would suggest you to sort the initial list in ascending order.", "Because scanning for a shorter substring is faster that scanning for a longer substring."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["How about this one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; substrings = ['cat', 'fish', 'dog']\n&gt;&gt;&gt; _string = '0123dog789cat'\n&gt;&gt;&gt; found = map(lambda x: (_string.index(x), x), filter(lambda x: x in _string, substrings))\n[(10, 'cat'), (4, 'dog')]\n&gt;&gt;&gt; if found:\n&gt;&gt;&gt;     min(found, key=lambda x: x[0])\n(4, 'dog')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Obviously, you could return something other than a tuple."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This works by: "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Filtering the list of substrings down to those that are in the string", "tag": "none", "senID": 4}, {"text": "Building a list of tuples containing the index of the substring, and the substring", "tag": "none", "senID": 5}, {"text": "If a substring has been found, find the minimum value based on the index", "tag": "none", "senID": 6}]}]]