[[{"code": "<pre>\n<code>\n from itertools import takewhile\nusefullines = takewhile(lambda x: not re.search(stopterm, x), lines)\n\nfrom itertools import takewhile\nusefullines = takewhile(lambda x: stopterm not in x, lines)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Here's a way that keeps the stopterm line:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def useful_lines(lines, stopterm):\n    for line in lines:\n        if stopterm in line:\n            yield line\n            break\n        yield line\n\nusefullines = useful_lines(lines, stopterm)\n# or...\nfor line in useful_lines(lines, stopterm):\n    # ... do stuff\n    pass\n</code>\n</pre>\n", "senID": 2}], [{"text": ["\" I was hoping for a 1 thought->1 Python line mapping.", "\"  Wouldn't we all love a programming language that somehow mirrored our natural language?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can achieve that, you just need to define your unique thoughts once.", "Then you have the 1:1 mapping you were hoping for."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def usefulLines( aFile ):\n    for line in aFile:\n        yield line\n        if line == stopterm:\n            break\n</code>\n</pre>\n", "senID": 2}, {"text": ["Is pretty much it."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for line in usefulLines( aFile ):\n    # process a line, knowing it occurs BEFORE stopterm.\n</code>\n</pre>\n", "senID": 4}, {"text": ["There are more general approaches.", "The lassevk answers with enum_while and enum_until are generalizations of this simple design pattern."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "lassevk", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "enum_while", "childNum": 0, "tag": "code", "childList": []}, {"text": "enum_until", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["That itertools solution is neat.", "I have earlier been amazed by itertools.groupby, one handy tool."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But still i was just tinkering if I could do this without itertools.", "So here it is\n(There is one assumption and one drawback though: the file is not huge and its goes for one extra complete iteration over the lines, respectively."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I created a sample file named \"try\":"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n hello\nworld\nhappy\nday\nbye\n</code>\n</pre>\n", "senID": 3}, {"text": ["once you read the file and have the lines in a variable name lines:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n lines=open('./try').readlines()\n</code>\n</pre>\n", "senID": 5}, {"text": ["then "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n print [each for each in lines if lines.index(each)&lt;=[lines.index(line) for line in lines if 'happy' in line][0]]\n</code>\n</pre>\n", "senID": 7}, {"text": ["gives the result:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n ['hello\\n', 'world\\n', 'happy\\n']\n</code>\n</pre>\n", "senID": 9}, {"text": ["and "], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n print [each for each in lines if lines.index(each)&lt;=[lines.index(line) for line in lines if 'day' in line][0]]\n</code>\n</pre>\n", "senID": 11}, {"text": ["gives the result:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n ['hello\\n', 'world\\n', 'happy\\n', 'day\\n']\n</code>\n</pre>\n", "senID": 13}, {"text": ["So you got the last line - the stop term line also included."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}], [{"text": ["Forget this"], "childNum": 0, "tag": "h2", "senID": 0, "childList": []}, {"text": ["Leaving the answer, but marking it community.", "See Stewen Huwig's answer for the correct way to do this."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Stewen Huwig", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/28604/steven-huwig"}, {"text": "correct", "childNum": 0, "tag": "strong", "childList": []}]}, {"tag": "hr", "senID": 2}, {"text": ["Well, [x for x in enumerable] will run until enumerable doesn't produce data any more, the if-part will simply allow you to filter along the way."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["What you can do is add a function, and filter your enumerable through it:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def enum_until(source, until_criteria):\n    for k in source:\n        if until_criteria(k):\n            break;\n        yield k;\n\ndef enum_while(source, while_criteria):\n    for k in source:\n        if not while_criteria(k):\n            break;\n        yield k;\n\nl1 = [k for k in enum_until(xrange(1, 100000), lambda y: y == 100)];\nl2 = [k for k in enum_while(xrange(1, 100000), lambda y: y &lt; 100)];\nprint l1;\nprint l2;\n</code>\n</pre>\n", "senID": 5}, {"text": ["Of course, it doesn't look as nice as what you wanted..."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I think it's fine to keep it that way.", "Sophisticated one-liner are not really pythonic, and since Guido had to put a limit somewhere, I guess this is it..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I'd go with Steven Huwig's or S.Lott's solutions for real usage, but as a slightly hacky solution, here's one way to obtain this behaviour:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Steven Huwig's", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/337223/python-item-for-item-until-stopterm-in-item#337285"}, {"href": "http://stackoverflow.com/questions/337223/python-item-for-item-until-stopterm-in-item#337279", "text": "S.Lott's", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n def stop(): raise StopIteration()\n\nusefullines = list(stop() if stopterm in line else line for line in file)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's slightly abusing the fact that anything that raises StopIteration will abort the current iteration (here the generator expression) and uglier to read than your desired syntax, but will work."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]