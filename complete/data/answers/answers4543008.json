[[{"text": ["By all means take a look at Pyparsing.", "It's the most pythonic implementations of parsing I've come across, and it's a great design from a purely academic standpoint."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Pyparsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}]}, {"text": ["I used both ANTLR and JavaCC to teach translator and compiler theory at a local university.", "They're both good and mature, but I wouldn't use them in a Python project."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "ANTLR", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.antlr.org/"}, {"text": "JavaCC", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/JavaCC"}]}, {"text": ["That said, unlike programming languages, natural languages are much more about the semantics than about the syntax, so you could be much better off skipping the learning curves of existing parsing tools, going with a home-brewed (top-down, backtracking, unlimited lookahead) lexical analyzer and parser, and spending the bulk of your time writing the code that figures out what a parsed, but ambiguous, natural-language sentence means."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Try running it on PyPy, it might be a lot faster."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I've used pyparsing for limited vocabulary command parsing, but here is a little framework on top of pyparsing that addresses your posted example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from pyparsing import *\n\ntransVerb, transVerbPlural, transVerbPast, transVerbProg = (Forward() for i in range(4))\nintransVerb, intransVerbPlural, intransVerbPast, intransVerbProg = (Forward() for i in range(4))\nsingNoun,pluralNoun,properNoun = (Forward() for i in range(3))\nsingArticle,pluralArticle = (Forward() for i in range(2))\nverbProg = transVerbProg | intransVerbProg\nverbPlural = transVerbPlural | intransVerbPlural\n\nfor expr in (transVerb, transVerbPlural, transVerbPast, transVerbProg,\n            intransVerb, intransVerbPlural, intransVerbPast, intransVerbProg,\n            singNoun, pluralNoun, properNoun, singArticle, pluralArticle):\n    expr &lt;&lt; MatchFirst([])\n\ndef appendExpr(e1, s):\n    c1 = s[0]\n    e2 = Regex(r\"[%s%s]%s\\b\" % (c1.upper(), c1.lower(), s[1:]))\n    e1.expr.exprs.append(e2)\n\ndef makeVerb(s, transitive):\n    v_pl, v_sg, v_past, v_prog = s.split()\n    if transitive:\n        appendExpr(transVerb, v_sg)\n        appendExpr(transVerbPlural, v_pl)\n        appendExpr(transVerbPast, v_past)\n        appendExpr(transVerbProg, v_prog)\n    else:\n        appendExpr(intransVerb, v_sg)\n        appendExpr(intransVerbPlural, v_pl)\n        appendExpr(intransVerbPast, v_past)\n        appendExpr(intransVerbProg, v_prog)\n\ndef makeNoun(s, proper=False):\n    if proper:\n        appendExpr(properNoun, s)\n    else:\n        n_sg,n_pl = (s.split() + [s+\"s\"])[:2]\n        appendExpr(singNoun, n_sg)\n        appendExpr(pluralNoun, n_pl)\n\ndef makeArticle(s, plural=False):\n    for ss in s.split():\n        if not plural:\n            appendExpr(singArticle, ss)\n        else:\n            appendExpr(pluralArticle, ss)\n\nmakeVerb(\"disappear disappears disappeared disappearing\", transitive=False)\nmakeVerb(\"walk walks walked walking\", transitive=False)\nmakeVerb(\"see sees saw seeing\", transitive=True)\nmakeVerb(\"like likes liked liking\", transitive=True)\n\nmakeNoun(\"dog\")\nmakeNoun(\"girl\")\nmakeNoun(\"car\")\nmakeNoun(\"child children\")\nmakeNoun(\"Kim\", proper=True)\nmakeNoun(\"Jody\", proper=True)\n\nmakeArticle(\"a the\")\nmakeArticle(\"this every\")\nmakeArticle(\"the these all some several\", plural=True)\n\ntransObject = (singArticle + singNoun | properNoun | Optional(pluralArticle) + pluralNoun | verbProg | \"to\" + verbPlural)\nsgSentence = (singArticle + singNoun | properNoun) + (intransVerb | intransVerbPast | (transVerb | transVerbPast) + transObject)\nplSentence = (Optional(pluralArticle) + pluralNoun) + (intransVerbPlural | intransVerbPast | (transVerbPlural |transVerbPast) + transObject)\n\nsentence = sgSentence | plSentence\n\n\ndef test(s):\n    print s\n    try:\n        print sentence.parseString(s).asList()\n    except ParseException, pe:\n        print pe\n\ntest(\"Kim likes cars\")\ntest(\"The girl saw the dog\")\ntest(\"The dog saw Jody\")\ntest(\"Kim likes walking\")\ntest(\"Every girl likes dogs\")\ntest(\"All dogs like children\")\ntest(\"Jody likes to walk\")\ntest(\"Dogs like walking\")\ntest(\"All dogs like walking\")\ntest(\"Every child likes Jody\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Kim likes cars\n['Kim', 'likes', 'cars']\nThe girl saw the dog\n['The', 'girl', 'saw', 'the', 'dog']\nThe dog saw Jody\n['The', 'dog', 'saw', 'Jody']\nKim likes walking\n['Kim', 'likes', 'walking']\nEvery girl likes dogs\n['Every', 'girl', 'likes', 'dogs']\nAll dogs like children\n['All', 'dogs', 'like', 'children']\nJody likes to walk\n['Jody', 'likes', 'to', 'walk']\nDogs like walking\n['Dogs', 'like', 'walking']\nAll dogs like walking\n['All', 'dogs', 'like', 'walking']\nEvery child likes Jody\n['Every', 'child', 'likes', 'Jody']\n</code>\n</pre>\n", "senID": 3}, {"text": ["This is likely to get slow as you expand the vocabulary.", "Half a million entries?", "I thought that a reasonable functional vocabulary was on the order of 5-6 thousand words.", "And you will be pretty limited in the sentence structures that you can handle - natural language is what NLTK is for."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Tooling aside..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You may remember from theory that there are infinite grammars that define the same language.", "There are criteria for categorizing grammars and determining which is the \"canonical\" or \"minimal\" one for a given language, but in the end, the \"best\" grammar is the one that's more convenient for the task and tools at hand (remember the transformations of CFGs into LL and LR grammars?", ")."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Then, you probably don't need a huge lexicon to parse an sentence in English.", "There's a lot to be known about a word in languages like German or Latin (or even Spanish), but not in the many times arbitrary and ambiguos English.", "You should be able to get away with a small lexicon that contains only the key words necessary to arrive to the structure of a sentence.", "At any rate, the grammar you choose, no matter its size, can be cached in a way that thee tooling can directly use it (i.e., you can skip parsing the grammar)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Given that, it could be a good idea to take a look at a simpler parser already worked on by someone else.", "There must be thousands of those in the literature.", "Studying different approaches will let you evaluate your own, and may lead you to adopt someone else's."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Finally, as I already mentioned, interpreting natural languages is much more about artificial intelligence than about parsing.", "Because structure determines meaning and meaning determines structure you have to play with both at the same time.", "An approach I've seen in the literature since the '80s is to let different specialized agents take shots at solving the problem against a \"blackboard\".", "With that approach syntatic and semantic analysis happen concurrently."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "blackboard", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Blackboard_system"}]}], [{"text": ["Somewhat late on this, but here are two more options for you:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Spark is a Earley parser written in Python. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Spark", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pages.cpsc.ucalgary.ca/~aycock/spark/"}]}, {"text": ["Elkhound is a GLR parser written in C++  Elkhound uses a Bison like syntax "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Elkhound", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://scottmcpeak.com/elkhound/"}]}], [{"text": ["I would recommend using bitpar, a very efficient PCFG parser written in C++.", "I've written a shell-based Python wrapper for it, see https://github.com/andreasvc/eodop/blob/master/bitpar.py"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "https://github.com/andreasvc/eodop/blob/master/bitpar.py", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "https://github.com/andreasvc/eodop/blob/master/bitpar.py"}]}], [{"text": ["I think ANTLR is the best parser-generator that I know of for Java.", "I don't know if Jython would provide you a good way for Python and Java to interact."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If it can be expressed as a PEG language (I don't think all CFGs can, but supposedly many can), then you might use pyPEG, which is supposed to be linear-time when using a packrat parsing implementation (although potentially prohibitive on memory usage)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "PEG", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pdos.csail.mit.edu/papers/parsing%3apopl04.pdf"}, {"href": "http://fdik.org/pyPEG/", "text": "pyPEG", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["I don't have any experience with it as I am just starting to research parsing and compilation again after a long time away from it, but I am reading some good buzz about this relatively up-to-date technique.", "YMMV."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]