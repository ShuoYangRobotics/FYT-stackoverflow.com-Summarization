[[{"text": ["I don't advice you to use eval at all.", "It is slow and insecure.", "You can do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n result = map(lambda a: tuple(map(int, a[1:-1].split(','))), s)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The numbers speak for themselves:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n timeit.Timer(\"map(lambda a: tuple(map(int, a[1:-1].split(','))), s)\", \"s = ('(-1,0)', '(1,0)', '(2,0)', '(3,0)', '(4,0)', '(5,0)', '(6,0)')\").timeit(100000)\n\n1.8787779808044434\n\ntimeit.Timer(\"map(eval, s)\", \"s = ('(-1,0)', '(1,0)', '(2,0)', '(3,0)', '(4,0)', '(5,0)', '(6,0)')\").timeit(100000)\n\n11.571426868438721\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n map(eval, tuples)\n</code>\n</pre>\n", "senID": 0}, {"text": ["This won't account for the case where one of the tuples isn't syntactically correct.", "For that, I'd recommend something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def do(tup):\n    try: return eval(tup)\n    except: return None\n\nmap(do, tuples)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Both methods tested for speed:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; tuples = [\"(1,0)\"] * 1000000\n\n&gt;&gt;&gt; # map eval\n&gt;&gt;&gt; st = time.time(); parsed = map(eval, tuples); print \"%.2f s\" % (time.time() - st)\n16.02 s\n\n&gt;&gt;&gt; # map do\n&gt;&gt;&gt; &gt;&gt;&gt; st = time.time(); parsed = map(do, tuples); print \"%.2f s\" % (time.time() - st)\n18.46 s\n</code>\n</pre>\n", "senID": 4}, {"text": ["For 1,000,000 tuples that's not bad (but isn't great either).", "The overhead, presumably, is in parsing Python one million times by using eval.", "However, it is the easiest way to do what you're after."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "bad", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "great", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "eval", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The answer using list comprehension instead of map is about as slow as my try/except case (interesting in itself):"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; st = time.time(); parsed = [eval(t) for t in tuples]; print \"%.2f s\" % (time.time() - st)\n18.13 s\n</code>\n</pre>\n", "senID": 7}, {"text": ["All that being said, I'm going to venture premature optimization is at work here -- parsing strings is always slow.", "How many tuples are you expecting?"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["I'd do string parsing if you know the format.", "Faster than eval()."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; tuples = [\"(1,0)\"] * 1000000\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; st = time.time(); parsed = map(eval, tuples); print \"%.2f s\" % (time.time() - st)\n32.71 s\n&gt;&gt;&gt; def parse(s) :\n...   return s[1:-1].split(\",\")\n...\n&gt;&gt;&gt; parse(\"(1,0)\")\n['1', '0']\n&gt;&gt;&gt; st = time.time(); parsed = map(parse, tuples); print \"%.2f s\" % (time.time() - st)\n5.05 s\n</code>\n</pre>\n", "senID": 1}, {"text": ["if you need ints"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def parse(s) :\n...   return map(int, s[1:-1].split(\",\"))\n...\n&gt;&gt;&gt; parse(\"(1,0)\")\n[1, 0]\n&gt;&gt;&gt; st = time.time(); parsed = map(parse, tuples); print \"%.2f s\" % (time.time() - st)\n9.62 s\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If you're sure the input is well formed:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n tuples = ('(-1,0)', '(1,0)', '(2,0)', '(3,0)', '(4,0)', '(5,0)', '(6,0)')\nresult = [eval(t) for t in tuples]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can get a parser up and running pretty quickly with YAPPS. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["you can just use yaml or json to parse it into tuples for you."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["My computer is slower than Nadia's, however this runs faster"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; timeit.Timer(\n    \"list((int(a),int(c)) for a,b,c in (x[1:-1].partition(',') for x in s))\", \n    \"s = ('(-1,0)', '(1,0)', '(2,0)', '(3,0)', '(4,0)', '(5,0)', '(6,0)')\").timeit(100000)\n3.2250211238861084\n</code>\n</pre>\n", "senID": 1}, {"text": ["than this"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; timeit.Timer(\n    \"map(lambda a: tuple(map(int, a[1:-1].split(','))), s)\", \n    \"s = ('(-1,0)', '(1,0)', '(2,0)', '(3,0)', '(4,0)', '(5,0)', '(6,0)')\").timeit(100000)\n3.8979239463806152\n</code>\n</pre>\n", "senID": 3}, {"text": ["using a list comprehension is faster still"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; timeit.Timer(\n    \"[(int(a),int(c)) for a,b,c in (x[1:-1].partition(',') for x in s)]\", \n    \"s = ('(-1,0)', '(1,0)', '(2,0)', '(3,0)', '(4,0)', '(5,0)', '(6,0)')\").timeit(100000)\n2.452484130859375\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n import ast\n\nlist_of_tuples = map(ast.literal_eval, tuple_of_strings)\n</code>\n</pre>\n", "senID": 0}]]