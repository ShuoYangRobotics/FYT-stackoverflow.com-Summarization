[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; words = ['xoo', 'dsd', 'xdd']\n&gt;&gt;&gt; sorted(words, key=lambda x: (x[0] != 'x', x))\n['xdd', 'xoo', 'dsd']\n</code>\n</pre>\n", "senID": 0}, {"text": ["Explanation: the key function returns a pair (tuple).", "The first element is False or True, depending on whether the first char in the string is 'x'.", "False sorts before True, so strings starting with 'x' will be first in the sorted output.", "The second element in the tuple will be used to compare two elements that are the same in the first element, so all the strings starting with 'x' will be sorted amongst themselves, and all the strings not starting with 'x' will be sorted amongst themselves."], "childNum": 8, "tag": "p", "senID": 1, "childList": [{"text": "False", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "'x'", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "childList": []}, {"text": "True", "childNum": 0, "tag": "code", "childList": []}, {"text": "'x'", "childNum": 0, "tag": "code", "childList": []}, {"text": "'x'", "childNum": 0, "tag": "code", "childList": []}, {"text": "'x'", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["First: stop saying \"pythonic\" when you mean \"clean\".", "It's just a cheesy buzzword."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Don't use terniary expressions like that; it's meant to be used as part of an expression, not as flow control.", "This is cleaner:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for word in words:\n    if word[0] == 'x':\n        list_1.append(word)\n    else:\n        list_2.append(word)\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can improve it a bit more--using terniary expressions like this is fine:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for word in words:\n    target = list_1 if word[0] == 'x' else list_2\n    target.append(word)\n</code>\n</pre>\n", "senID": 4}, {"text": ["If words is a container and not an iterator, you could use:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "words", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n list_1 = [word for word in words if word[0] == 'x']\nlist_2 = [word for word in words if word[0] != 'x']\n</code>\n</pre>\n", "senID": 6}, {"text": ["Finally, we can scrap the whole thing, and instead use two sorts:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n result = sorted(words)\nresult = sorted(result, key=lambda word: word[0] != 'x')\n</code>\n</pre>\n", "senID": 8}, {"text": ["which first sorts normally, then uses the stable property of Python sorts to move words beginning with \"x\" to the front without otherwise changing the ordering."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"code": "<pre>\n<code>\n words = ['xoo', 'dsd', 'xdd']\nlist1 = [word for word in words if word[0] == 'x']\nlist2 = [word for word in words if word[0] != 'x']\n</code>\n</pre>\n", "senID": 0}], [{"text": ["It should be noted that sorted was added in Python 2.4 .", "If you would like a shorter version which is a bit cleaner and somewhat more backwards compatible you can alternatively use the .sort() functionality directly off of list.", "It should also be noted that empty strings will throw an exception when usingx[0]style array indexing syntax in this case (as many examples have).", ".startswith()should be used instead, as is properly used in Tony Veijalainen's answer."], "childNum": 7, "tag": "p", "senID": 0, "childList": [{"text": "sorted", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".sort()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "list", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "It should also be noted that empty strings will throw an exception when usingx[0]style array indexing syntax in this case (as many examples have).", "childNum": 1, "tag": "strong", "pos": 2, "childList": [{"text": "x[0]", "tag": "code"}]}, {"text": "x[0]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": ".startswith()should be used instead, as is properly used in Tony Veijalainen's answer", "tag": "a", "pos": 3, "childList": [{"text": ".startswith()", "tag": "code"}], "childNum": 1, "href": "http://stackoverflow.com/questions/4077249/a-more-pythonic-way-to-write-this-expression/4079610#4079610"}, {"text": ".startswith()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; words = ['mix', 'xyz', '', 'apple', 'xanadu', 'aardvark']\n&gt;&gt;&gt; words.sort(key=lambda x: (not x.startswith('x'), x))\n&gt;&gt;&gt; words\n['xanadu', 'xyz', '', 'aardvark', 'apple', 'mix']\n</code>\n</pre>\n", "senID": 1}, {"text": ["The only disadvantage is that you're mutating the given object.", "This may be remedied by slicing the list beforehand."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; words = ['mix', 'xyz', '', 'apple', 'xanadu', 'aardvark']\n&gt;&gt;&gt; new_words = words[:]\n&gt;&gt;&gt; new_words.sort(key=lambda x: (not x.startswith('x'), x))\n&gt;&gt;&gt; new_words\n['xanadu', 'xyz', '', 'aardvark', 'apple', 'mix']\n&gt;&gt;&gt; words\n['mix', 'xyz', '', 'apple', 'xanadu', 'aardvark']\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n words = ['xoo', 'dsd', 'xdd']\nlist1=filter(lambda word:word[0]=='x',words)\nlist2=filter(lambda word:word[0]!='x',words)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["To resend variation SilenGhosts code (feel free to copy, SilentGhost) as code not command prompt log"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n notinorder = ['mix', 'xyz', '', 'apple', 'xanadu', 'aardvark']\nprint sorted(notinorder, key = lambda x: (not x.startswith('x'), x))\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; x = ['abc', 'xyz', 'bcd', 'xabc']\n&gt;&gt;&gt; y = [ele for ele in x if ele.startswith('x')]\n&gt;&gt;&gt; y\n['xyz', 'xabc']\n&gt;&gt;&gt; z = [ele for ele in x if not ele.startswith('x')]\n&gt;&gt;&gt; z\n['abc', 'bcd']\n</code>\n</pre>\n", "senID": 0}], [{"text": ["More along the lines of your original solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\nl1=[]\nl2=[]\nfor w in sorted(words):\n    (l1 if w[0] == 'x' else l2).append(w)\nl1.extend(l2)\nreturn l1\n</pre>\n", "senID": 1}]]