[[{"code": "<pre>\n<code>\n import heapq\nimport itertools\nimport operator\n\n\ndef increasing(fn, left, right):\n    \"\"\"\n    Given two never decreasing iterators produce another iterator\n    resulting from passing the value from left and right to fn.\n    This iterator should also be never decreasing.\n    \"\"\"\n    # Imagine an infinite 2D-grid.\n    # Each column corresponds to an entry from right\n    # Each row corresponds to an entry from left\n    # Each cell correspond to apply fn to those two values\n\n    # If the number of columns were finite, then we could easily solve\n    # this problem by keeping track of our current position in each column\n    # in each iteration, we'd take the smallest value report it, and then\n    # move down in that column. This works because the values must increase\n    # as we move down the column. That means the current set of values\n    # under consideration must include the lowest value not yet reported\n\n    # To extend this to infinite columns, at any point we always track a finite\n    # number of columns. The last column current tracked is always in the top row\n    # if it moves down from the top row, we add a new column which starts at the top row\n    # because the values are increasing as we move to the right, we know that\n    # this last column is always lower then any columns that come after it\n\n\n\n\n\n    # Due to infinities, we need to keep track of all\n    # items we've ever seen. So we put them in this list\n    # The list contains the first part of the incoming iterators that\n    # we have explored\n    left_items = [next(left)]\n    right_items = [next(right)]\n\n    # we use a heap data structure, it allows us to efficiently\n    # find the lowest of all value under consideration\n    heap = []\n\n    def add_value(left_index, right_index):\n        \"\"\"\n        Add the value result from combining the indexed attributes\n        from the two iterators. Assumes that the values have already\n        been copied into the lists\n        \"\"\"\n        value = fn( left_items[left_index], right_items[right_index] )\n        # the value on the heap has the index and value.\n        # since the value is first, low values will be \"first\" on the heap\n        heapq.heappush( heap, (value, left_index, right_index) )\n\n    # we know that every other value must be larger then \n    # this one. \n    add_value(0,0)\n\n    # I assume the incoming iterators are infinite\n    while True:\n        # fetch the lowest of all values under consideration\n        value, left_index, right_index = heapq.heappop(heap)\n\n        # produce it\n        yield value\n\n        # add moving down the column\n        if left_index + 1 == len(left_items):\n            left_items.append(next(left))\n\n        add_value(left_index+1, right_index)\n\n        # if this was the first row in this column, add another column\n        if left_index == 0:\n            right_items.append( next(right) )\n            add_value(0, right_index+1)\n\n\n\n\n\n\ndef fib():\n    a = 1\n    b = 1\n    while True:\n        yield a\n        a,b = b,a+b\n\n\n\nr = increasing(operator.add, fib(), itertools.count() )\nfor x in range(100):\n    print next(r)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Define the sequences as:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a1 &lt;= a2 &lt;= a3 ...\nb1 &lt;= b2 &lt;= b3 ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["Let a1b1 mean op(a1,b1) for short."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "a1b1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "op(a1,b1)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Based on your allowable assumptions (very important) you know the following:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n max(a1, b1) &lt;= a1b1 &lt;= a1b2 &lt;= a1b3 ...\n   &lt;=\nmax(a2, b1) &lt;= a2b1 &lt;= a2b2 &lt;= a2b3 ...\n   &lt;=\nmax(a3, b1) &lt;= a3b1 &lt;= a3b2 &lt;= a3b3 ...\n    .     .\n    .      .\n    .       .\n</code>\n</pre>\n", "senID": 4}, {"text": ["You'll have to do something like: "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Generate a1b1.", "You know that if you continue increasing the b variables, you will only get higher values.", "The question now is: is there a smaller value by increasing the a variables?", "Your lower bound is min(a1, b1), so you will have to increase the a values until min(ax,b1) &gt;= a1b1.", "Once you hit that point, you can find the smallest value from anb1 where 1 &lt;= n &lt;= x and yield that safely. "], "childNum": 8, "tag": "p", "senID": 6, "childList": [{"text": "a1b1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "min(a1, b1)", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "min(ax,b1) &gt;= a1b1", "childNum": 0, "tag": "code", "childList": []}, {"text": "anb1", "childNum": 0, "tag": "code", "childList": []}, {"text": "1 &lt;= n &lt;= x", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You then will have multiple horizontal chains that you'll have to keep track of.", "Every time you have a value that goes past min(ax,b1), you'll have to increase x (adding more chains) until min(ax,b1) is larger than it before safely emitting it. "], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "min(ax,b1)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}, {"text": "min(ax,b1)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Just a starting point...", "I don't have time to code it at the moment."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["EDIT: Oh heh that's exactly what you already had.", "Well, without more info, this is all you can do, as I'm pretty sure that mathematically, that's what is necessary. "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["EDIT2: As for your 'acceptable' solution: you can just yield a1bn in increasing order of n, returning min(a1,b1) as N =P.", "You'll need to be more specific.", "You speak as if you have a heuristic of what you generally want to see, the general way you want to progress through both iterables, but without telling us what it is I don't know how one could do better. "], "childNum": 4, "tag": "p", "senID": 10, "childList": [{"text": "a1bn", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "n", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "min(a1,b1)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["UPDATE: Winston's is good but makes an assumption that the poster didn't mention: that op(a,c) > op(b,c) if b&gt;a.", "However, we do know that op(a,b)&gt;=a and op(a,b)&gt;=b."], "childNum": 5, "tag": "p", "senID": 11, "childList": [{"text": "op(a,c)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "op(b,c)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "b&gt;a", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "op(a,b)&gt;=a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "op(a,b)&gt;=b", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Here is my solution which takes that second assumption but not the one Winston took.", "Props to him for the code structure, though:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n def increasing(fn, left, right):\n    left_items = [next(left)]\n    right_items = [next(right)]\n\n    #columns are (column value, right index)\n    columns = [(fn(left_items[0],right_items[0]),0)]\n\n    while True:\n        #find the current smallest value\n        min_col_index = min(xrange(len(columns)), key=lambda i:columns[i][0])\n\n        #generate columns until it's impossible to get a smaller value\n        while right_items[0] &lt;= columns[min_col_index][0] and \\\n              left_items[-1] &lt;= columns[min_col_index][0]:\n            next_left = next(left)\n\n            left_items.append(next_left)\n            columns.append((fn(next_left, right_items[0]),0))\n\n            if columns[-1][0] &lt; columns[min_col_index][0]:\n                min_col_index = len(columns)-1\n\n        #yield the smallest value\n        yield columns[min_col_index][0]\n\n        #move down that column\n        val, right_index = columns[min_col_index]\n\n        #make sure that right value is generated:\n        while right_index+1 &gt;= len(right_items):\n            right_items.append(next(right))\n\n        columns[min_col_index] = (fn(left_items[min_col_index],right_items[right_index+1]),\n                                  right_index+1)\n        #repeat\n</code>\n</pre>\n", "senID": 13}, {"text": ["For a (pathological) input that demonstrates the difference, consider:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n def pathological_one():\n    cur = 0\n    while True:\n        yield cur\n        cur += 100\n\ndef pathological_two():\n    cur = 0\n    while True:\n        yield cur\n        cur += 100\n\nlookup = [\n    [1,   666, 500],\n    [666, 666, 666],\n    [666, 666, 666],\n    [666, 666, 666]]\n\ndef pathological_op(a, b):\n    if a &gt;= 300 or b &gt;= 400: return 1005\n    return lookup[b/100][a/100]\n\nr = increasing(pathological_op, pathological_one(), pathological_two())\nfor x in range(15):\n    print next(r)\n</code>\n</pre>\n", "senID": 15}, {"text": ["Winston's answer gives:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; \n1\n666\n666\n666\n666\n500\n666\n666\n666\n666\n666\n666\n1005\n1005\n1005\n</code>\n</pre>\n", "senID": 17}, {"text": ["While mine gives:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; \n1\n500\n666\n666\n666\n666\n666\n666\n666\n666\n666\n666\n1005\n1005\n1005\n</code>\n</pre>\n", "senID": 19}], [{"text": ["So you basically want to take two monotonically increasing sequences, and then (lazily) compute the multiplication (or addition, or another operation) table between them, which is a 2-D array.", "Then you want to put the elements of that 2-D array in sorted order and iterate through them."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In general, this is impossible.", "However, if your sequences and operation are such that you can make certain guarantees about the rows and columns of the table, then you can make some progress.", "For example, let's assume that your sequences are monitonically-increasing sequences of positive integers only, and that the operation is multiplication (as in your example).", "In this case, we know that every row and column of the array is a monotonically-increasing sequence.", "In this case, you do not need to compute the entire array, but rather only parts of it.", "Specifically, you must keep track of the following:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "How many rows you have ever used", "tag": "none", "senID": 2}, {"text": "The number of elements you have taken from each row that you have used", "tag": "none", "senID": 3}, {"text": "Every element from either input sequence that you have ever used, plus one more from each", "tag": "none", "senID": 4}]}, {"text": ["To compute the next element in your iterator, you must do the following:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "For each row that you have ever used, compute the \"next\" value in that row. For example, if you have used 5 values from row 1, then compute the 6th value (i=1, j=6) by taking the 1st value from the first sequence and the 6th value from the second sequence (both of which you have cached) and applying the operation (multiplication) to them. Also, compute the first value in the first unused row.", "tag": "none", "senID": 6}, {"text": "Take the minimum of all the values you computed. Yield this value as the next element in your iterator", "tag": "none", "senID": 7}, {"text": "Increment the counter for the row from which you sampled the element in the previous step. If you took the element from a new, unused row, you must increment the count of the number of rows you have used, and you must create a new counter for that row initialized to 1. If necessary, you must also compute more values of one or both input sequences.", "tag": "none", "senID": 8}]}, {"text": ["This process is kind of complex, and in particular notice that to compute N values, you must in the worst case save an amount of state proportional to the square root of N. (Edit: sqrt(N) is actually the best case.", ") This is in stark contrast to a typical generator, which only requires constant space to iterate through its elements regardless of length."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "square root of", "childNum": 0, "tag": "strike", "pos": 0, "childList": []}, {"text": "best", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["In summary, you can do this under certain assumptions, and you can provide a generator-like interface to it, but it cannot be done in a \"streaming\" fashion, because you need to save a lot of state in order to iterate through the elements in the correct order."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["Let me start with an example of how I would solve this intuitively."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Because reading code inline is a little tedious, I'll introduce some notation:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["i1"], "childNum": 0, "tag": "em", "senID": 2, "childList": []}, {"text": "\u203b will represent the ", "tag": "none", "senID": 3}]}, {"text": ["By using simplifying assumption 2, we know that i10 \u203b i20 is the smallest element that will ever be yielded from your final iterator.", "The next element would the smaller of i10 \u203b i21 and i11 \u203b i20."], "childNum": 12, "tag": "p", "senID": 4, "childList": [{"text": "i1", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "0", "childNum": 0, "tag": "sub", "pos": 1, "childList": []}, {"text": "i2", "childNum": 0, "tag": "em", "childList": []}, {"text": "0", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i1", "childNum": 0, "tag": "em", "childList": []}, {"text": "0", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i2", "childNum": 0, "tag": "em", "childList": []}, {"text": "1", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i1", "childNum": 0, "tag": "em", "childList": []}, {"text": "1", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i2", "childNum": 0, "tag": "em", "childList": []}, {"text": "0", "childNum": 0, "tag": "sub", "childList": []}]}, {"text": ["Assuming i10 \u203b i21 is smaller, you would yield that element.", "Next, you would yield the smaller of i11 \u203b i20, i11 \u203b i20, and i11 \u203b i21."], "childNum": 16, "tag": "p", "senID": 5, "childList": [{"text": "i1", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "0", "childNum": 0, "tag": "sub", "pos": 1, "childList": []}, {"text": "i2", "childNum": 0, "tag": "em", "childList": []}, {"text": "1", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i1", "childNum": 0, "tag": "em", "childList": []}, {"text": "1", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i2", "childNum": 0, "tag": "em", "childList": []}, {"text": "0", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i1", "childNum": 0, "tag": "em", "childList": []}, {"text": "1", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i2", "childNum": 0, "tag": "em", "childList": []}, {"text": "0", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i1", "childNum": 0, "tag": "em", "childList": []}, {"text": "1", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i2", "childNum": 0, "tag": "em", "childList": []}, {"text": "1", "childNum": 0, "tag": "sub", "childList": []}]}, {"text": ["What you have here is a graph traversal problem.", "First, think of the problem as a tree.", "The root of the tree is i10 \u203b i20.", "This node, and each node below it, has two children.", "The two children of i1x \u203b i2y are the following: One child is i1x+1 \u203b i2y, and the other child is i1x \u203b i2y+1.", "Based on your second assumption, we know that i1x \u203b i2y is less than both of its children."], "childNum": 20, "tag": "p", "senID": 6, "childList": [{"text": "i1", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "0", "childNum": 0, "tag": "sub", "pos": -1, "childList": []}, {"text": "i2", "childNum": 0, "tag": "em", "pos": 4, "childList": []}, {"text": "0", "childNum": 0, "tag": "sub", "pos": -1, "childList": []}, {"text": "i1", "childNum": 0, "tag": "em", "pos": 5, "childList": []}, {"text": "x", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i2", "childNum": 0, "tag": "em", "childList": []}, {"text": "y", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i1", "childNum": 0, "tag": "em", "childList": []}, {"text": "x+1", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i2", "childNum": 0, "tag": "em", "childList": []}, {"text": "y", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i1", "childNum": 0, "tag": "em", "childList": []}, {"text": "x", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i2", "childNum": 0, "tag": "em", "childList": []}, {"text": "y+1", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i1", "childNum": 0, "tag": "em", "childList": []}, {"text": "x", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i2", "childNum": 0, "tag": "em", "childList": []}, {"text": "y", "childNum": 0, "tag": "sub", "childList": []}]}, {"text": ["(In fact, as Ryan mentions in a comment, this is a directed acyclic graph, or DAG.", "Some \"parents\" share \"children\" with other \"parent\" nodes."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Now, we need to keep a frontier - a collection of nodes that could be next to be returned.", "After returning a node, we add both its children to the frontier.", "To select the next node to visit (and return from your new iterator), we compare the values of all the nodes in the frontier.", "We take the node with the smallest value and we return it.", "Then, we again add both of its child nodes to the frontier.", "If the child is already in the frontier (added as the child of some other parent), just ignore it."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "frontier", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Because you are primarily interested in the value of the nodes, it makes sense to store these nodes indexed by value.", "As such, it may be in your interest to use a dict.", "Keys in this dict should be the values of nodes.", "Values in this dict should be lists containing individual nodes.", "Because the only identifying information in a node is the pair of operands, you can store individual nodes as a two-tuple of operands."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In practice, after a few iterations, your frontier may look like the following:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; frontier\n{1: [(2, 3), (2, 4)], 2: [(3, 5), (5, 4)], 3: [(1, 6)], 4: [(6, 3)]}\n</code>\n</pre>\n", "senID": 11}, {"text": ["Because iterators don't support random access, you'll need to hang on to values that are produced by your first two iterators until they are no longer needed.", "You'll know that a value is still needed if it is referenced by any value in your frontier.", "You'll know that a value is no longer needed once all nodes in the frontier reference values later/greater than one you've stored.", "For example,i120is no longer needed when nodes in your frontier reference onlyi121,i125,i133, ..."], "childNum": 9, "tag": "p", "senID": 12, "childList": [{"text": "You'll know that a value is still needed if it is referenced by any value in your frontier. You'll know that a value is no longer needed once all nodes in the frontier reference values later/greater than one you've stored. For example,i120is no longer needed when nodes in your frontier reference onlyi121,i125,i133, ...", "childNum": 8, "tag": "strike", "pos": -1, "childList": [{"text": "i1", "tag": "em"}, {"text": "20", "tag": "sub"}, {"text": "i1", "tag": "em"}, {"text": "21", "tag": "sub"}, {"text": "i1", "tag": "em"}, {"text": "25", "tag": "sub"}, {"text": "i1", "tag": "em"}, {"text": "33", "tag": "sub"}]}, {"text": "i1", "childNum": 0, "tag": "em", "pos": 3, "childList": []}, {"text": "20", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i1", "childNum": 0, "tag": "em", "childList": []}, {"text": "21", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i1", "childNum": 0, "tag": "em", "childList": []}, {"text": "25", "childNum": 0, "tag": "sub", "childList": []}, {"text": "i1", "childNum": 0, "tag": "em", "childList": []}, {"text": "33", "childNum": 0, "tag": "sub", "childList": []}]}, {"text": ["As mentioned by Ryan, each value from each iterator will be used an infinite number of times.", "Thus, every value produced will need to be saved."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["Unfortunately, in order to assure that elements are returned only in increasing order, the frontier will grow without bound.", "Your memoized values will probably also take a significant amount of space also grow without bound.", "This may be something you can address by making your problem less general, but this should be a good starting point."], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "probably also take a significant amount of space", "childNum": 0, "tag": "strike", "pos": 1, "childList": []}]}], [{"text": ["Use generators, which are just iterators written as functions that yield results.", "In this case you can write generators for iter1 and iter2 and another generator to wrap them and yield their results (or do calculations with them, or the history of their results) as you go."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "generators", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html#generators"}, {"text": "iter1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "iter2", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["From my reading of the question you want something like this, which will calculate every element of the first iterator with every element of the next, using said operation, you also state you want some way to wrap-up \"iter1\", \"iter2\", and \"op\" in an iterable that itself yields the values in monotonically increasing output.", "I propose generators offer a simple solution to such problem."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "calculate every element of the first iterator with every element of the next, using said operation", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "wrap-up \"iter1\", \"iter2\", and \"op\" in an iterable that itself yields the values in monotonically increasing output", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import itertools\n\ndef prime_gen():\n    D, q = {}, 2\n    while True:\n        if q not in D:\n            yield q\n            D[q * q] = [q]\n        else:\n            for p in D[q]:\n                D.setdefault(p + q, []).append(p)\n            del D[q]\n        q += 1\n\ndef infinite_gen(op, iter1, iter2):\n    while True:\n        yield op(iter1.next(), iter2.next())\n\n&gt;&gt;&gt; gen = infinite_gen(operator.mul, prime_gen(), itertools.count())\n\n&gt;&gt;&gt; gen.next()\n&lt;&lt;&lt; 0\n\n&gt;&gt;&gt; gen.next()\n&lt;&lt;&lt; 3\n\n&gt;&gt;&gt; gen.next()\n&lt;&lt;&lt; 10\n</code>\n</pre>\n", "senID": 2}, {"text": ["Generators offer a lot of flexibility, so it should be fairly easy to write iter1 and iter2 as generators that return values you want in the order you want.", "You could also consider using coroutines, which let you send values into a generator. "], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "iter1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "iter2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "coroutines", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0342/"}, {"text": "into", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["Discussion in other answers observes that there is potentially infinite storage required no matter what the algorithm, since every a[n] must remain available for each new b[n].", "If you remove the restriction that the input be two iterators and instead only require that they be sequences (indexable or merely something that can be regenerated repeatedly) then I believe all of your state suddenly collapses to one number:  The last value you returned.", "Knowing the last result value you can search the output space looking for the next one.", "(If you want to emit duplicates properly then you may need to also track the number of times the result has been returned)"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "a[n]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b[n]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "input", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["With a pair of sequences you have a simple recurrence relation:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n result(n) = f(seq1, seq1, result(n-1))\n</code>\n</pre>\n", "senID": 2}, {"text": ["where f(seq1, seq1, p) searches for the minimum value in the output space q such that q &gt; p.  In practical terms you'd probably make the sequences memoized functions and choose your search algorithm to avoid thrashing the pool of memoized items."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "f(seq1, seq1, p)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "q", "childNum": 0, "tag": "code", "childList": []}, {"text": "q &gt; p", "childNum": 0, "tag": "code", "childList": []}]}]]