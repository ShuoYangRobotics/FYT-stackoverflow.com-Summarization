[[{"text": ["You can trick matplotlib into plotting implicit equations in 3D.", "Just make a one-level contour plot of the equation for each z value within the desired limits.", "You can repeat the process along the y and z axes as well for a more solid-looking shape."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from mpl_toolkits.mplot3d import axes3d\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef plot_implicit(fn, bbox=(-2.5,2.5)):\n    ''' create a plot of an implicit function\n    fn  ...implicit function (plot where fn==0)\n    bbox ..the x,y,and z limits of plotted interval'''\n    xmin, xmax, ymin, ymax, zmin, zmax = bbox*3\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n    A = np.linspace(xmin, xmax, 100) # resolution of the contour\n    B = np.linspace(xmin, xmax, 15) # number of slices\n    A1,A2 = np.meshgrid(A,A) # grid on which the contour is plotted\n\n    for z in B: # plot contours in the XY plane\n        X,Y = A1,A2\n        Z = fn(X,Y,z)\n        cset = ax.contour(X, Y, Z+z, [z], zdir='z')\n        # [z] defines the only level to plot for this contour for this value of z\n\n    for y in B: # plot contours in the XZ plane\n        X,Z = A1,A2\n        Y = fn(X,y,Z)\n        cset = ax.contour(X, Y+y, Z, [y], zdir='y')\n\n    for x in B: # plot contours in the YZ plane\n        Y,Z = A1,A2\n        X = fn(x,Y,Z)\n        cset = ax.contour(X+x, Y, Z, [x], zdir='x')\n\n    # must set plot limits because the contour will likely extend\n    # way beyond the displayed level.  Otherwise matplotlib extends the plot limits\n    # to encompass all values in the contour.\n    ax.set_zlim3d(zmin,zmax)\n    ax.set_xlim3d(xmin,xmax)\n    ax.set_ylim3d(ymin,ymax)\n\n    plt.show()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here's the plot of the Goursat Tangle:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def goursat_tangle(x,y,z):\n    a,b,c = 0.0,-5.0,11.8\n    return x**4+y**4+z**4+a*(x**2+y**2+z**2)**2+b*(x**2+y**2+z**2)+c\n\nplot_implicit(goursat_tangle)\n</code>\n</pre>\n", "senID": 3}, {"src": "http://i.stack.imgur.com/7s2yC.png", "tag": "img", "senID": 4}, {"text": ["You can make it easier to visualize by adding depth cues with creative colormapping:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"src": "http://i.stack.imgur.com/93caD.png", "tag": "img", "senID": 6}, {"text": ["Here's how the OP's plot looks:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n def hyp_part1(x,y,z):\n    return -(x**2) - (y**2) + (z**2) - 1\n\nplot_implicit(hyp_part1, bbox=(-100.,100.))\n</code>\n</pre>\n", "senID": 8}, {"src": "http://i.stack.imgur.com/mcreb.png", "tag": "img", "senID": 9}, {"text": ["Bonus:  You can use python to functionally combine these implicit functions:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n def sphere(x,y,z):\n    return x**2 + y**2 + z**2 - 2.0**2\n\ndef translate(fn,x,y,z):\n    return lambda a,b,c: fn(x-a,y-b,z-c)\n\ndef union(*fns):\n    return lambda x,y,z: np.min(\n        [fn(x,y,z) for fn in fns], 0)\n\ndef intersect(*fns):\n    return lambda x,y,z: np.max(\n        [fn(x,y,z) for fn in fns], 0)\n\ndef subtract(fn1, fn2):\n    return intersect(fn1, lambda *args:-fn2(*args))\n\nplot_implicit(union(sphere,translate(sphere, 1.,1.,1.)), (-2.,3.))\n</code>\n</pre>\n", "senID": 11}, {"src": "http://i.stack.imgur.com/mk6d3.png", "tag": "img", "senID": 12}], [{"text": ["Matplotlib expects a series of points; it will do the plotting if you can figure out how to render your equation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Referring to Is it possible to plot implicit equations using Matplotlib?", "Mike Graham's answer suggests using scipy.optimize to numerically explore the implicit function."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Is it possible to plot implicit equations using Matplotlib?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2484527/is-it-possible-to-plot-implicit-equations-using-matplotlib"}]}, {"text": ["There is an interesting gallery at http://xrt.wikidot.com/gallery:implicit showing a variety of raytraced implicit functions - if your equation matches one of these, it might give you a better idea what you are looking at."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://xrt.wikidot.com/gallery:implicit", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://xrt.wikidot.com/gallery:implicit"}]}, {"text": ["Failing that, if you care to share the actual equation, maybe someone can suggest an easier approach."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["As far as I know, it is not possible.", "You have to solve this equation numerically by yourself.", "Using scipy.optimize is a good idea.", "The simplest case is that you know the range of the surface that you want to plot, and just make a regular grid in x and y, and try to solve equation F(xi,yi,z)=0 for z, giving a starting point of z.", "Following is a very dirty code that might help you"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from scipy import *\nfrom scipy import optimize\n\nxrange = (0,1)\nyrange = (0,1)\ndensity = 100\nstartz = 1\n\ndef F(x,y,z):\n    return x**2+y**2+z**2-10\n\nx = linspace(xrange[0],xrange[1],density)\ny = linspace(yrange[0],yrange[1],density)\n\npoints = []\nfor xi in x:\n    for yi in y:\n        g = lambda z:F(xi,yi,z)\n        res = optimize.fsolve(g, startz, full_output=1)\n        if res[2] == 1:\n            zi = res[0]\n            points.append([xi,yi,zi])\n\npoints = array(points)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Have you looked at mplot3d on matplotlib?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "mplot3d", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://matplotlib.sourceforge.net/mpl_toolkits/mplot3d/api.html"}]}], [{"text": ["Finally, I did it (I updated my matplotlib to 1.0.1).", "Here is code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import matplotlib.pyplot as plt\nimport numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\n\ndef hyp_part1(x,y,z):\n    return -(x**2) - (y**2) + (z**2) - 1\n\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\n\nx_range = np.arange(-100,100,10) \ny_range = np.arange(-100,100,10)\nX,Y = np.meshgrid(x_range,y_range)\nA = np.linspace(-100, 100, 15)\n\nA1,A2 = np.meshgrid(A,A)    \n\nfor z in A: \n    X,Y = A1, A2\n    Z = hyp_part1(X,Y,z)\n    ax.contour(X, Y, Z+z, [z], zdir='z')\n\nfor y in A: \n    X,Z= A1, A2\n    Y = hyp_part1(X,y,Z)\n    ax.contour(X, Y+y, Z, [y], zdir='y')\n\nfor x in A:\n    Y,Z = A1, A2 \n    X = hyp_part1(x,Y,Z)\n    ax.contour(X+x, Y, Z, [x], zdir='x')\n\nax.set_zlim3d(-100,100)\nax.set_xlim3d(-100,100)\nax.set_ylim3d(-100,100)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here is result:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "img", "pos": 0, "childList": []}]}, {"text": ["Thank You, Paul!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["MathGL (GPL plotting library) can plot it easily.", "Just create a data mesh with function values f[i,j,k] and use Surf3() function to make isosurface at value f[i,j,k]=0.", "See this sample."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "MathGL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mathgl.sf.net/"}, {"text": "sample", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://mathgl.sourceforge.net/mathgl_en/mathgl_en_92.html#Surf3-sample"}]}]]