[[{"text": ["Check if the cross product of (b-a) and (c-a) is 0, as tells Darius Bacon, tells you if the points a, b and c are aligned."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "cross product", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["But, as you want to know if c is between a and b, you also have to check that the dot product of (b-a) and (c-a) is positive and is less than the square of the distance between a and b."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "dot product", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "positive", "childNum": 0, "tag": "em", "childList": []}, {"text": "less", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["In non-optimized pseudocode:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def isBetween(a, b, c):\n    crossproduct = (c.y - a.y) * (b.x - a.x) - (c.x - a.x) * (b.y - a.y)\n    if abs(crossproduct) &gt; epsilon : return False   # (or != 0 if using integers)\n\n    dotproduct = (c.x - a.x) * (b.x - a.x) + (c.y - a.y)*(b.y - a.y);\n    if dotproduct &lt; 0 : return False\n\n    squaredlengthba = (b.x - a.x)*(b.x - a.x) + (b.y - a.y)*(b.y - a.y) )\n    if dotproduct &gt; squaredlengthba: return False\n\n    return True\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Check if the cross product of (b-a) and (c-a) is 0.", "Ah, wait, you say you want to know if it's on the line segment, not the same line.", "That's a little more work and I don't have time to answer; I'll delete this partial answer after someone fills in a proper one."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "segment", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Update: Two more notes: first, Brian Hayes's chapter in Beautiful Code covers the design space for a collinearity-test function -- useful background.", "Second, [points that have since been answered]."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "chapter", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://bit-player.org/bph-publications/BeautifulCode-2007-Hayes.pdf"}, {"text": "Beautiful Code", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["Update 2: I like vincent's approach best now (and I'm embarrassed\nI didn't see it).", "But the comparison could still be done in a cleaner way, I think, like this:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Update 2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "vincent's approach", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/328107/how-can-you-determine-a-point-is-between-two-other-points-on-a-line-segment#328337"}]}, {"code": "<pre>\n<code>\n def is_on(a, b, c):\n    \"Return true iff point c intersects the line segment from a to b.\"\n    # (or the degenerate case that all 3 points are coincident)\n    return (collinear(a, b, c)\n            and (within(a.x, c.x, b.x) if a.x != b.x else \n                 within(a.y, c.y, b.y)))\n\ndef collinear(a, b, c):\n    \"Return true iff a, b, and c all lie on the same line.\"\n    return (b.x - a.x) * (c.y - a.y) == (c.x - a.x) * (b.y - a.y)\n\ndef within(p, q, r):\n    \"Return true iff q is between p and r (inclusive).\"\n    return p &lt;= q &lt;= r or r &lt;= q &lt;= p\n</code>\n</pre>\n", "senID": 3}, {"text": ["Update 3: Brian Hayes pointed out that you only need to range-check one coordinate, once you know the points are collinear.", "(Previously my code had \"and\" instead of \"if a.x != b.x\"."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "Update 3:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "and", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "if a.x != b.x", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Here's another approach:  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Lets assume the two points be A (x1,y1) and B (x2,y2)", "tag": "none", "senID": 1}, {"text": "The equation of the line passing through those points is (x-x1)/(y-y1)=(x2-x1)/(y2-y1) .. (just making equating the slopes)", "tag": "none", "senID": 2}]}, {"text": ["Point C (x3,y3) will lie between A &amp; B if:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "x3,y3 satisfies the above equation.", "tag": "none", "senID": 4}, {"text": "x3 lies between x1 &amp; x2 and y3 lies between y1 &amp; y2 (trivial check)", "tag": "none", "senID": 5}]}], [{"text": ["Here's how I'd do it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def distance(a,b):\n    return sqrt((a.x - b.x)**2 + (a.y - b.y)**2)\n\ndef is_between(a,c,b):\n    return distance(a,c) + distance(c,b) == distance(a,b)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The length of the segment is not important, thus using a square root is not required and should be avoided since we could lose some precision."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Segment:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n    def is_between(self, c):\n        # Check if slope of a to c is the same as a to b ;\n        # that is, when moving from a.x to c.x, c.y must be proportionally\n        # increased than it takes to get from a.x to b.x .\n\n        # Then, c.x must be between a.x and b.x, and c.y must be between a.y and b.y.\n        # =&gt; c is after a and before b, or the opposite\n        # that is, the absolute value of cmp(a, b) + cmp(b, c) is either 0 ( 1 + -1 )\n        #    or 1 ( c == a or c == b)\n\n        a, b = self.a, self.b             \n\n        return ((b.x - a.x) * (c.y - a.y) == (c.x - a.x) * (b.y - a.y) and \n                abs(cmp(a.x, c.x) + cmp(b.x, c.x)) &lt;= 1 and\n                abs(cmp(a.y, c.y) + cmp(b.y, c.y)) &lt;= 1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Some random example of usage :"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a = Point(0,0)\nb = Point(50,100)\nc = Point(25,50)\nd = Point(0,8)\n\nprint Segment(a,b).is_between(c)\nprint Segment(a,b).is_between(d)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Ok, lots of mentions of linear algebra (cross product of vectors) and this works in a real (ie continuous or floating point) space but the question specifically stated that the two points were expressed as integers and thus a cross product is not the correct solution although it can give an approximate solution."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "integers", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The correct solution is to use Bresenham's Line Algorithm between the two points and to see if the third point is one of the points on the line.", "If the points are sufficiently distant that calculating the algorithm is non-performant (and it'd have to be really large for that to be the case) I'm sure you could dig around and find optimisations."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Bresenham's Line Algorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm"}]}], [{"text": ["The scalar product between (c-a) and (b-a) must be equal to the product of their lengths (this means that the vectors (c-a) and (b-a) are aligned and with the same direction).", "Moreover, the length of (c-a) must be less than or equal to that of (b-a).", "Pseudocode:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # epsilon = small constant\n\ndef isBetween(a, b, c):\n    lengthca2  = (c.x - a.x)*(c.x - a.x) + (c.y - a.y)*(c.y - a.y)\n    lengthba2  = (b.x - a.x)*(b.x - a.x) + (b.y - a.y)*(b.y - a.y)\n    if lengthca2 &gt; lengthba2: return False\n    dotproduct = (c.x - a.x)*(b.x - a.x) + (c.y - a.y)*(b.y - a.y)\n    if dotproduct &lt; 0.0: return False\n    if abs(dotproduct*dotproduct - lengthca2*lengthba2) &gt; epsilon: return False \n    return True\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using a more geometric approach, calculate the following distances:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ab = sqrt((a.x-b.x)**2 + (a.y-b.y)**2)\nac = sqrt((a.x-c.x)**2 + (a.y-c.y)**2)\nbc = sqrt((b.x-c.x)**2 + (b.y-c.y)**2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["and test whether ac+bc equals ab:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "ac+bc", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "ab", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n is_on_segment = abs(ac + bc - ab) &lt; EPSILON\n</code>\n</pre>\n", "senID": 3}, {"text": ["That's because there are three possibilities:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "The 3 points form a triangle => ", "tag": "none", "senID": 5}, {"text": "They are collinear and ", "tag": "none", "senID": 6}, {"text": "They are collinear and ", "tag": "none", "senID": 7}]}], [{"text": ["Here's how I did it at school.", "I forgot why it is not a good idea."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["EDIT: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["@Darius Bacon: cites a \"Beautiful Code\" book which contains an explanation why the belowed code is not a good idea."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "cites a \"Beautiful Code\" book", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/328107/how-can-you-determine-a-point-is-between-two-other-points-on-a-line-segment#328110"}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nfrom __future__ import division\n\nepsilon = 1e-6\n\nclass Point:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n\nclass LineSegment:\n    \"\"\"\n    &gt;&gt;&gt; ls = LineSegment(Point(0,0), Point(2,4))\n    &gt;&gt;&gt; Point(1, 2) in ls\n    True\n    &gt;&gt;&gt; Point(.5, 1) in ls\n    True\n    &gt;&gt;&gt; Point(.5, 1.1) in ls\n    False\n    &gt;&gt;&gt; Point(-1, -2) in ls\n    False\n    &gt;&gt;&gt; Point(.1, 0.20000001) in ls\n    True\n    &gt;&gt;&gt; Point(.1, 0.2001) in ls\n    False\n    &gt;&gt;&gt; ls = LineSegment(Point(1, 1), Point(3, 5))\n    &gt;&gt;&gt; Point(2, 3) in ls\n    True\n    &gt;&gt;&gt; Point(1.5, 2) in ls\n    True\n    &gt;&gt;&gt; Point(0, -1) in ls\n    False\n    &gt;&gt;&gt; ls = LineSegment(Point(1, 2), Point(1, 10))\n    &gt;&gt;&gt; Point(1, 6) in ls\n    True\n    &gt;&gt;&gt; Point(1, 1) in ls\n    False\n    &gt;&gt;&gt; Point(2, 6) in ls \n    False\n    &gt;&gt;&gt; ls = LineSegment(Point(-1, 10), Point(5, 10))\n    &gt;&gt;&gt; Point(3, 10) in ls\n    True\n    &gt;&gt;&gt; Point(6, 10) in ls\n    False\n    &gt;&gt;&gt; Point(5, 10) in ls\n    True\n    &gt;&gt;&gt; Point(3, 11) in ls\n    False\n    \"\"\"\n    def __init__(self, a, b):\n        if a.x &gt; b.x:\n            a, b = b, a\n        (self.x0, self.y0, self.x1, self.y1) = (a.x, a.y, b.x, b.y)\n        self.slope = (self.y1 - self.y0) / (self.x1 - self.x0) if self.x1 != self.x0 else None\n\n    def __contains__(self, c):\n        return (self.x0 &lt;= c.x &lt;= self.x1 and\n                min(self.y0, self.y1) &lt;= c.y &lt;= max(self.y0, self.y1) and\n                (not self.slope or -epsilon &lt; (c.y - self.y(c.x)) &lt; epsilon))\n\n    def y(self, x):        \n        return self.slope * (x - self.x0) + self.y0\n\nif __name__ == '__main__':\n    import  doctest\n    doctest.testmod()\n</code>\n</pre>\n", "senID": 3}], [{"text": ["how about just ensuring that the slope is the same and the point is between the others?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["given points (x1, y1) and (x2, y2) ( with x2 > x1)\nand candidate point (a,b)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["if  (b-y1) / (a-x1) = (y2-y2) / (x2-x1)  And x1 &lt; a &lt; x2 "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Then (a,b) must be on line between (x1,y1) and (x2, y2)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Any point on the line segment (a, b) (where a and b are vectors) can be expressed as a linear combination of the two vectors a and b:"], "childNum": 7, "tag": "p", "senID": 0, "childList": [{"text": "a", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "b", "childNum": 0, "tag": "strong", "childList": []}, {"text": "a", "childNum": 0, "tag": "strong", "childList": []}, {"text": "b", "childNum": 0, "tag": "strong", "childList": []}, {"text": "linear combination", "childNum": 0, "tag": "em", "childList": []}, {"text": "a", "childNum": 0, "tag": "strong", "childList": []}, {"text": "b", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["In other words, if c lies on the line segment (a, b):"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "c", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "strong", "childList": []}, {"text": "b", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n c = ma + (1 - m)b, where 0 &lt;= m &lt;= 1\n</code>\n</pre>\n", "senID": 2}, {"text": ["Solving for m, we get:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "m", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n m = (c.x - b.x)/(a.x - b.x) = (c.y - b.y)/(a.y - b.y)\n</code>\n</pre>\n", "senID": 4}, {"text": ["So, our test becomes (in Python):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def is_on(a, b, c):\n    \"\"\"Is c on the line segment ab?\"\"\"\n\n    def _is_zero( val ):\n        return -epsilon &lt; val &lt; epsilon\n\n    x1 = a.x - b.x\n    x2 = c.x - b.x\n    y1 = a.y - b.y\n    y2 = c.y - b.y\n\n    if _is_zero(x1) and _is_zero(y1):\n        # a and b are the same point:\n        # so check that c is the same as a and b\n        return _is_zero(x2) and _is_zero(y2)\n\n    if _is_zero(x1):\n        # a and b are on same vertical line\n        m2 = y2 * 1.0 / y1\n        return _is_zero(x2) and 0 &lt;= m2 &lt;= 1\n    elif _is_zero(y1):\n        # a and b are on same horizontal line\n        m1 = x2 * 1.0 / x1\n        return _is_zero(y2) and 0 &lt;= m1 &lt;= 1\n    else:\n        m1 = x2 * 1.0 / x1\n        if m1 &lt; 0 or m1 &gt; 1:\n            return False\n        m2 = y2 * 1.0 / y1\n        return _is_zero(m2 - m1)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["c#\nFrom http://www.faqs.org/faqs/graphics/algorithms-faq/\n-> Subject 1.02: How do I find the distance from a point to a line?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.faqs.org/faqs/graphics/algorithms-faq/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.faqs.org/faqs/graphics/algorithms-faq/"}]}, {"code": "<pre>\n<code>\n Boolean Contains(PointF from, PointF to, PointF pt, double epsilon)\n        {\n\n            double segmentLengthSqr = (to.X - from.X) * (to.X - from.X) + (to.Y - from.Y) * (to.Y - from.Y);\n            double r = ((pt.X - from.X) * (to.X - from.X) + (pt.Y - from.Y) * (to.Y - from.Y)) / segmentLengthSqr;\n            if(r&lt;0 || r&gt;1) return false;\n            double sl = ((from.Y - pt.Y) * (to.X - from.X) - (from.X - pt.X) * (to.Y - from.Y)) / System.Math.Sqrt(segmentLengthSqr);\n            return -epsilon &lt;= sl &amp;&amp; sl &lt;= epsilon;\n        }\n</code>\n</pre>\n", "senID": 1}]]