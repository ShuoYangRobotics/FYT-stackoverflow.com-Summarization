[[{"code": "<pre>\n<code>\n def memoize(fn):\n  get = [lambda key: (False, None)]\n\n  def vset(args):\n    value = fn(*args)\n    oldget = get[0]\n    def newget(key):\n      if args == key:\n        return (True, value)\n      return oldget(key)\n    get[0] = newget\n    return value\n\n  def mfun(*args):\n    found, value = get[0](args)\n    if found:\n      return value\n    return vset(args)\n\n  return mfun\n\nCALLS = 0\n\ndef fib(x):\n  global CALLS\n  CALLS += 1\n  if x&lt;2: return x\n  return fib(x-1)+fib(x-2)\n\n@memoize\ndef fibm(x):\n  global CALLS\n  CALLS += 1\n  if x&lt;2: return x\n  return fibm(x-1)+fibm(x-2)\n\nCALLS = 0\nprint \"fib(35) is\", fib(35), \"and took\", CALLS, \"calls\"\nCALLS = 0\nprint \"fibm(35) is\", fibm(35), \"and took\", CALLS, \"calls\"\n</code>\n</pre>\n", "senID": 0}, {"text": ["Output is:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n fib(35) is 9227465 and took 29860703 calls\nfibm(35) is 9227465 and took 36 calls\n</code>\n</pre>\n", "senID": 2}, {"text": ["Similar to other answers, however this one works.", ":)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The important change from the code in the question is assigning to a non-global non-local (get); however, I also made some improvements while trying to maintain your *cough*broken*cough* closure use.", "Usually the cache is a dict instead of a linked list of closures."], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "*", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "broken", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["The problem is in your scoping, not in your closures.", "If you're up for some heavy reading, then you can try http://www.python.org/dev/peps/pep-3104/."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://www.python.org/dev/peps/pep-3104/", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3104/"}]}, {"text": ["If that's not the case, here's the simple explanation:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The problem is in the statement global get .", "global refers to the outermost scope, and since there isn't any global function get, it throws."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "global get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "global", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "get", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["What you need, is an access specifier for variables in the enclosing scope, and not the global scope."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["In python 3.0, as I've tested, the nonlocal keyword is exactly what you need, in the place of global."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "global", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n nonlocal get\n...\n</code>\n</pre>\n", "senID": 5}, {"text": ["In python 2.x, I just removed the global get and the oldget references and it works properly."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "global get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "oldget", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Get is not global, but local to the surrounding function, that's why the global declaration fails."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "global", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you remove the global, it still fails, because you can't assign to the captured variable name.", "To work around that, you can use an object as the variable captured by your closures and than just change properties of that object:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "global", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Memo(object):\n    pass\n\ndef memoize(fn):\n    def defaultget(key):\n        return (False,)\n\n    memo = Memo()\n    memo.get = defaultget\n\n    def vset(key, value):\n        oldget = memo.get\n        def newget(ky):\n            if key==ky: return (True, value)\n            return oldget(ky)\n        memo.get = newget\n\n    def mfun(*args):\n        cache = memo.get(args)\n        if cache[0]: return cache[1]\n\n        val = apply(fn, args)\n        vset(args, val)\n        return val\n\n    return mfun\n</code>\n</pre>\n", "senID": 2}, {"text": ["This way you don't need to assign to the captured variable names but still get what you wanted."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You want to put global get at the beginning of every function (except get itself)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "global get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "every", "childNum": 0, "tag": "em", "childList": []}, {"text": "get", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["the def get is an assignment to the name get, so you want get to be declared global before that."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "def get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "get", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Putting global get in mfun and vset makes them work.", "I can't point to the scoping rules that makes this necessary, but it works ;-)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "global get", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Your conses are quite lispy too... :)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Probably because you want the global get while it isn't a global?", "By the way, apply is deprecated, use fn(*args) instead."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "global", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def memoize(fn):\n    def get(key):\n        return (False,)\n\n    def vset(key, value):\n        def newget(ky):\n            if key==ky: return (True, value)\n            return get(ky)\n        get = newget\n\n    def mfun(*args):\n        cache = get(args)\n        if (cache[0]): return cache[1]\n\n        val = fn(*args)\n        vset(args, val)\n        return val\n\n    return mfun\n\ndef fib(x):\n    if x&lt;2: return x\n    return fib(x-1)+fib(x-2)\n\ndef fibm(x):\n    if x&lt;2: return x\n    return fibm(x-1)+fibm(x-2)\n\nfibm = memoize(fibm)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think the best way would be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Memoized(object):\n    def __init__(self,func):\n        self.cache = {}\n        self.func = func\n    def __call__(self,*args):\n        if args in self.cache: return cache[args]\n        else:\n            self.cache[args] = self.func(*args)\n            return self.cache[args]\n</code>\n</pre>\n", "senID": 1}]]