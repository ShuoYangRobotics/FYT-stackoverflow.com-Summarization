[[{"code": "<pre>\n<code>\n alternatives = (\"// @in \", \"// @out \", \"// @ret \")\nif any(a in sTxT for a in alternatives):\n    print \"found\"\n\nif all(a in sTxT for a in alternatives):\n   print \"found all\"\n</code>\n</pre>\n", "senID": 0}, {"text": ["any() and all() takes an iterable and checks if any/all of them evaluate to a true value.", "Combine that with a generator expressions, and you can check multiple items."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "any()", "tag": "a", "pos": 0, "childList": [{"text": "any()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#any"}, {"text": "any()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "all()", "tag": "a", "pos": -1, "childList": [{"text": "all()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#all"}, {"text": "all()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["any(snippet in text_body for snippet in (\"hi\", \"foo\", \"bar\", \"spam\"))"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "any(snippet in text_body for snippet in (\"hi\", \"foo\", \"bar\", \"spam\"))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If you're testing lots of lines for the same words, it may be faster to compile them as a regular expression.", "eg:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import  re\nwords = [\"// @in \", \"// @out \", \"// @ret \"] + [\"// @test%s \" % i for i in range(10)]\n\nmy_regex = re.compile(\"|\".join(map(re.escape, words)))\n\nfor line in lines_to_search:\n    if my_regex.search(line):  print \"Found match\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Some quick timing shows that this is usually faster than the any(word in theString for word in words) approach.", "I've tested both approaches with varying text (short/long with/without matches).", "Here are the results:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "any(word in theString for word in words)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n { No keywords  } |  {contain Keywords }\n         short    long       short    long\nregex  : 0.214    27.214     0.147    0.149\nany in : 0.579    81.341     0.295    0.300\n</code>\n</pre>\n", "senID": 3}, {"text": ["If performance doesn't matter though, the any() approach is more readable."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "any()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If you want any check then you would use this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "any", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n inthere = False\nchecks = ('a', 'b')\n\nfor check in checks:\n    if check in 'abrakadabra':\n        inthere = True\n        break\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want all check out you could use this:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "all", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n inthere = True\nchecks = ('a', 'b')\n\nfor check in checks:\n    if check not in 'abrakadabra':\n        inthere = False\n        break\n</code>\n</pre>\n", "senID": 3}, {"text": ["EDIT: Didn't know the more pythonic any().", "It's probably better to use that on python."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "any()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["EDIT2: Added break statements, and corrected the all-case."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "all", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["You could also use set methods and operators:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "set methods and operators", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/3.0/library/stdtypes.html#set-types-set-frozenset"}]}, {"code": "<pre>\n<code>\n not alternatives.isdisjoint(sTxt)  # for \"any\"\n(alternatives &amp; sTxt) != set()  # Again, the intersection is nonempty\nalternatives &lt;= sTxt  # for \"all\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think these are easier to read than using the any or all, but have to convert your collections into sets.", "Since intersection and containment are what you care about, you might consider making them sets in the first place."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["There's no built in way in the syntax to do it.", "However you can use the 'any' function to make it easier as @MizardX and @Benjamin Peterson showed."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]