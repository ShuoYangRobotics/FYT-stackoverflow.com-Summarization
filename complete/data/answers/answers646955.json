[[{"text": ["shoosh beat me to it :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If I remember correctly, you should try to read the first 2 characters in the file.", "If you get back \"MZ\", you have an exe."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n hnd = open(file,\"rb\")\nif hnd.read(2) == \"MZ\":\n  print \"exe\"\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I think, that this should be sufficient:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I don't really understand how you can tell the difference between somefile.py and somefile.txt because association can be really the same.", "You can configure system to run .txt files the same way as .py files."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["A windows PE always starts with the characters \"MZ\".", "This includes however also any kind of DLLs which are not necessarily executables.", "To check for this however you'll have to open the file and read the header so that's probably not what you're looking for."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "PE", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Portable%5FExecutable"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}], [{"text": ["Here's the grepath.py that I've linked in my question:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "grepath.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://gist.github.com/79233/"}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\"\"\"Find executables in %PATH% that match PATTERN.\n\n\"\"\"\n#XXX: remove --use-pathext option\n\nimport fnmatch, itertools, os, re, sys, warnings\nfrom optparse import OptionParser\nfrom stat import S_IMODE, S_ISREG, ST_MODE\nfrom subprocess import PIPE, Popen\n\n\ndef warn_import(*args):\n    \"\"\"pass '-Wd' option to python interpreter to see these warnings.\"\"\"\n    warnings.warn(\"%r\" % (args,), ImportWarning, stacklevel=2)\n\n\nclass samefile_win:\n    \"\"\"\nhttp://timgolden.me.uk/python/win32_how_do_i/see_if_two_files_are_the_same_file.html\n\"\"\"\n    @staticmethod\n    def get_read_handle (filename):\n        return win32file.CreateFile (\n            filename,\n            win32file.GENERIC_READ,\n            win32file.FILE_SHARE_READ,\n            None,\n            win32file.OPEN_EXISTING,\n            0,\n            None\n            )\n\n    @staticmethod\n    def get_unique_id (hFile):\n        (attributes,\n         created_at, accessed_at, written_at,\n         volume,\n         file_hi, file_lo,\n         n_links,\n         index_hi, index_lo\n         ) = win32file.GetFileInformationByHandle (hFile)\n        return volume, index_hi, index_lo\n\n    @staticmethod\n    def samefile_win(filename1, filename2):\n        \"\"\"Whether filename1 and filename2 represent the same file.\n\nIt works for subst, ntfs hardlinks, junction points.\nIt works unreliably for network drives.\n\nBased on GetFileInformationByHandle() Win32 API call.\nhttp://timgolden.me.uk/python/win32_how_do_i/see_if_two_files_are_the_same_file.html\n\"\"\"\n        if samefile_generic(filename1, filename2): return True\n        try:\n            hFile1 = samefile_win.get_read_handle (filename1)\n            hFile2 = samefile_win.get_read_handle (filename2)\n            are_equal = (samefile_win.get_unique_id (hFile1)\n                         == samefile_win.get_unique_id (hFile2))\n            hFile2.Close ()\n            hFile1.Close ()\n            return are_equal\n        except win32file.error:\n            return None\n\n\ndef canonical_path(path):\n    \"\"\"NOTE: it might return wrong path for paths with symbolic links.\"\"\"\n    return os.path.realpath(os.path.normcase(path))\n\n\ndef samefile_generic(path1, path2):\n    return canonical_path(path1) == canonical_path(path2)\n\n\nclass is_executable_destructive:\n    @staticmethod\n    def error_message(barename):\n        r\"\"\"\n\"'%(barename)s' is not recognized as an internal or external\\r\\n\ncommand, operable program or batch file.\\r\\n\"\n\nin Russian:\n\"\"\"\n        return '\"%(barename)s\" \\xad\\xa5 \\xef\\xa2\\xab\\xef\\xa5\\xe2\\xe1\\xef \\xa2\\xad\\xe3\\xe2\\xe0\\xa5\\xad\\xad\\xa5\\xa9 \\xa8\\xab\\xa8 \\xa2\\xad\\xa5\\xe8\\xad\\xa5\\xa9\\r\\n\\xaa\\xae\\xac\\xa0\\xad\\xa4\\xae\\xa9, \\xa8\\xe1\\xaf\\xae\\xab\\xad\\xef\\xa5\\xac\\xae\\xa9 \\xaf\\xe0\\xae\\xa3\\xe0\\xa0\\xac\\xac\\xae\\xa9 \\xa8\\xab\\xa8 \\xaf\\xa0\\xaa\\xa5\\xe2\\xad\\xeb\\xac \\xe4\\xa0\\xa9\\xab\\xae\\xac.\\r\\n' % dict(barename=barename)\n\n    @staticmethod\n    def is_executable_win_destructive(path):\n        # assume path &lt;-&gt; barename that is false in general\n        barename = os.path.splitext(os.path.basename(path))[0]\n        p = Popen(barename, stdout=PIPE, stderr=PIPE, shell=True)\n        stdout, stderr = p.communicate()\n        return p.poll() != 1 or stdout != '' or stderr != error_message(barename)\n\n\ndef is_executable_win(path):\n    \"\"\"Based on:\nhttp://timgolden.me.uk/python/win32_how_do_i/tell-if-a-file-is-executable.html\n\nKnown bugs: treat some \"*~\" files as executable, e.g. some \"*.bat~\" files\n\"\"\"\n    try:\n        _, executable = FindExecutable(path)\n        return bool(samefile(GetLongPathName(executable), path))\n    except error:\n        return None # not an exe or a document with assoc.\n\n\ndef is_executable_posix(path):\n    \"\"\"Whether the file is executable.\n\nBased on which.py from stdlib\n\"\"\"\n    #XXX it ignores effective uid, guid?\n    try: st = os.stat(path)\n    except os.error:\n        return None\n\n    isregfile = S_ISREG(st[ST_MODE])\n    isexemode = (S_IMODE(st[ST_MODE]) &amp; 0111)\n    return bool(isregfile and isexemode)\n\ntry:\n    #XXX replace with ctypes?\n    from win32api import FindExecutable, GetLongPathName, error\n    is_executable = is_executable_win\nexcept ImportError, e:\n    warn_import(\"is_executable: fall back on posix variant\", e)\n    is_executable = is_executable_posix\n\ntry: samefile = os.path.samefile\nexcept AttributeError, e:\n    warn_import(\"samefile: fallback to samefile_win\", e)\n    try:\n        import win32file\n        samefile = samefile_win.samefile_win\n    except ImportError, e:\n        warn_import(\"samefile: fallback to generic\", e)\n        samefile = samefile_generic\n\ndef main():\n    parser = OptionParser(usage=\"\"\"\n%prog [options] PATTERN\n%prog [options] -e PATTERN\"\"\", description=__doc__)\n    opt = parser.add_option\n    opt(\"-e\", \"--regex\", metavar=\"PATTERN\",\n        help=\"use PATTERN as a regular expression\")\n    opt(\"--ignore-case\", action=\"store_true\", default=True,\n        help=\"\"\"[default] ignore case when --regex is present; for \\\nnon-regex PATTERN both FILENAME and PATTERN are first \\\ncase-normalized if the operating system requires it otherwise \\\nunchanged.\"\"\")\n    opt(\"--no-ignore-case\", dest=\"ignore_case\", action=\"store_false\")\n    opt(\"--use-pathext\", action=\"store_true\", default=True,\n        help=\"[default] whether to use %PATHEXT% environment variable\")\n    opt(\"--no-use-pathext\", dest=\"use_pathext\", action=\"store_false\")\n    opt(\"--show-non-executable\", action=\"store_true\", default=False,\n        help=\"show non executable files\")\n\n    (options, args) = parser.parse_args()\n\n    if len(args) != 1 and not options.regex:\n       parser.error(\"incorrect number of arguments\")\n    if not options.regex:\n       pattern = args[0]\n    del args\n\n    if options.regex:\n       filepred = re.compile(options.regex, options.ignore_case and re.I).search\n    else:\n       fnmatch_ = fnmatch.fnmatch if options.ignore_case else fnmatch.fnmatchcase\n       for file_pattern_symbol in \"*?\":\n           if file_pattern_symbol in pattern:\n               break\n       else: # match in any place if no explicit file pattern symbols supplied\n           pattern = \"*\" + pattern + \"*\"\n       filepred = lambda fn: fnmatch_(fn, pattern)\n\n    if not options.regex and options.ignore_case:\n       filter_files = lambda files: fnmatch.filter(files, pattern)\n    else:\n       filter_files = lambda files: itertools.ifilter(filepred, files)\n\n    if options.use_pathext:\n       pathexts = frozenset(map(str.upper,\n            os.environ.get('PATHEXT', '').split(os.pathsep)))\n\n    seen = set()\n    for dirpath in os.environ.get('PATH', '').split(os.pathsep):\n        if os.path.isdir(dirpath): # assume no expansion needed\n           # visit \"each\" directory only once\n           # it is unaware of subst drives, junction points, symlinks, etc\n           rp = canonical_path(dirpath)\n           if rp in seen: continue\n           seen.add(rp); del rp\n\n           for filename in filter_files(os.listdir(dirpath)):\n               path = os.path.join(dirpath, filename)\n               isexe = is_executable(path)\n\n               if isexe == False and is_executable == is_executable_win:\n                  # path is a document with associated program\n                  # check whether it is a script (.pl, .rb, .py, etc)\n                  if not isexe and options.use_pathext:\n                     ext = os.path.splitext(path)[1]\n                     isexe = ext.upper() in pathexts\n\n               if isexe:\n                  print path\n               elif options.show_non_executable:\n                  print \"non-executable:\", path\n\n\nif __name__==\"__main__\":\n   main()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Parse the PE format."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://code.google.com/p/pefile/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://code.google.com/p/pefile/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/pefile/"}]}, {"text": ["This is probably the best solution you will get other than using python to actually try to run the program."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: I see you also want files that have associations.", "This will require mucking in the registry which I don't have the information for."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Edit2: I also see that you differentiate between .doc and .py.", "This is a rather arbitrary differentiation which must be specified with manual rules, because to windows, they are both file extensions that a program reads."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["> Parse the PE format."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "> Parse the PE format.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["No, totally useless.", "Just use buit-in Win32 apis\n(1 api call)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}], [{"text": ["Your question can't be answered.", "Windows can't tell the difference between a file which is associated with a scripting language vs. some other arbitrary program.", "As Windows is concerned, a .PY file is simply a document which is opened by python.exe."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]