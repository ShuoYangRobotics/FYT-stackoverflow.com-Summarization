[[{"text": ["Assuming your classes are already in scope (i.e.", "they're not in a separate module), you can refer to a class by its name very easily through the globals() dict.", "For example:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "globals()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class Foo:\n    pass\n\nfoo_cls = globals()['Foo']\nfoo = foo_cls()\n# foo is now an instance of __main__.Foo\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The other answers do what you asked, but I wanted to add a small measure of flexibility (and protection.", ") I would use a dictionary to map the line names to the class objects, so you're not letting the text file instantiate anything it wants.", "It has to be a class that you allow it to, in your code.", "This also makes it easier because you can change names on either side without trouble (and you could map multiple line-names to a single class name, if you wanted."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n classes = {'classa': classa, 'classb': classb}\ncls = type(classes[line], (object,), {})  ## or whichever method to instantiate you prefer\n</code>\n</pre>\n", "senID": 1}, {"text": ["But in general, it's not a very Pythonic thing to do, in my opinion."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Reading each line from the file is pretty easy:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n with open(filename) as f:\n    for line in f:\n</code>\n</pre>\n", "senID": 1}, {"text": ["The first thing that comes to mind for class creation is the type function:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "type", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n cls = type(line, (object,), {})\n</code>\n</pre>\n", "senID": 3}, {"text": ["This will create a new empty class which is a subclass of object and has a name given by the contents of the line."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "object", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I have to wonder why you're trying to do this, though.", "An empty class like that doesn't seem very useful in Python."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Assuming that all classes are declared in a module foo:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n classname = sys.stdin.read().rstrip()\ncls = getattr(foo, classname)()\n</code>\n</pre>\n", "senID": 1}, {"text": ["To access classes in the same module, use the builtin globals() function."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As you are using YAML anyway, consider using PyYAML with the serialized classes deriving from the yaml.YAMLObject metaclass or registering your own represenenter."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "PyYAML", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyyaml.org/wiki/PyYAMLDocumentation#Constructorsrepresentersresolvers"}, {"text": "yaml.YAMLObject", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["From the documentation of PyYAML:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Monster(yaml.YAMLObject):\n    yaml_tag = u'!Monster'\n    def __init__(self, name, hp, ac, attacks):\n        self.name = name\n        self.hp = hp\n        self.ac = ac\n        self.attacks = attacks\n    def __repr__(self):\n        return \"%s(name=%r, hp=%r, ac=%r, attacks=%r)\" % (\n            self.__class__.__name__, self.name, self.hp, self.ac, self.attacks)\n\nprint yaml.load(\"\"\"\n--- !Monster\nname: Cave spider\nhp: [2,6]    # 2d6\nac: 16\nattacks: [BITE, HURT]\n\"\"\")\n</code>\n</pre>\n", "senID": 2}, {"text": ["prints Monster(name='Cave spider', hp=[2, 6], ac=16, attacks=['BITE', 'HURT'])"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Monster(name='Cave spider', hp=[2, 6], ac=16, attacks=['BITE', 'HURT'])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["That way you can leave out many of the code you need for error handling (e.g.", "class is not present) and you also have system that is more robust against malicious configuration files.", "As an additional bonus, you are able to dump objects from your program into a YAML file."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["This should be fairly easily possible using a dictionary of classes (not that this is not necessarily a restriction as each python namespace can be accessed as a dictionary so if you want these classes say to all be within a module or another class, just replace classes with the __dict__ attribute of the class or use globals as others have suggested):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__dict__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n classes = dict()\nwith open('filename') as f:\n    for line in f:\n        classes[line] = class()\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Implementation details may vary)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You may however want to look into using pickling instead as on the face of it, this approach seems flawed (it might work well in PHP though :-) )."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]