[[{"code": "<pre>\n<code>\n v = [1,2,3,4,3,1,2]\nany([2,3] == v[i:i+2] for i in xrange(len(v) - 1))\n</code>\n</pre>\n", "senID": 0}, {"text": ["While @PaoloCapriotti's version does the trick, this one is faster, because it stops parsing the v as soon as a match is found."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "v", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n [2, 3] in [v[i:i+2] for i in range(len(v) - 1)]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This is probably a bit of a round about way to do it, but you could use (with your variable v above):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ' 2, 3' in str(v)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n v = [1,2,3,4,3,1,2]\n\ndef find(x,y,v):\n        return (x,y) in zip(v,v[1:])\n\nprint find(2,3,v)\nprint find(1,4,v)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["In general it is impossible without iterating over all the values.", "After all, a list of a thousand elements may end in [.., 2, 3]."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "[.., 2, 3]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In special cases, there are shortcuts.", "Are the values always ordered and are you always looking for a specific value?", "If so, you can e.g.", "use a binary search to find the value and then compare it with the next value.", "If the values are unordered, there is no shortcut.", "If you are looking for any two subsequent values, there is no shortcut.", "For cases in between, there may be a shortcut."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You're going to need a loop.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Unlike Python strings which support a subsequence test using the in operator, Python lists do not have a builtin subsequence test."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "in", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["You can use the Boyer-Moore algorithm for a totally unnecessary speedup.", "The general case is a bit difficult, but it's straightforward if you're just looking for a pair."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Boyer-Moore algorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm"}]}, {"code": "<pre>\n<code>\n def find_pair(seq, a, b):\n    i = 1\n    while i &lt; len(seq):\n        if seq[i] == b and seq[i - 1] == a: return i - 1\n        i += 2 - (seq[i] == a)\n\nprint find_pair([1, 5, 3, 4, 3, 1, 2, 3, 3], 2, 3)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If writing the list happens far less often than reading from it, perhaps you could build a tree of prefixes upon write.", "[1] would have a child node [2], [2] would have a [3], and [3] a [4].", "With a more complex data set, the tree would be more useful.", "It would have a depth of 2 in your case and would be indexed on the initial element in your search sequence."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You'd still be visiting each node, but only once for the life of the searched sequence, if append-only.", "As you append an element, you'd update the tree to include the subsequnce if not present.", "Then reads are down to a maximum of O(2 * k) where k is the number of unique elements.", "In the case of digits, that's 20 reads maximum to test if a sequence is in the list."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The speed advantage comes from precomputing the length-2 subsequences the list contains and from removing duplicates.", "It also scales well to longer lengths.", "O(depth * k) worst case.", "Even better if hashtables are employed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I know you are already happy with one of the answer's in this post but, you may try with the following"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; v = [1,2,3,4,3,1,2]\ndef InList(v,(i,j)):\n    start=1\n    try:\n         while True:\n            if v[v.index(i,start)+1]==j and v[v.index(j,start)-1]==i:\n                return True\n            start=v.index(i)+1\n    except IndexError:\n        return False\n    except ValueError:\n        return False\n\n\n&gt;&gt;&gt; InList(v,(2,3))\nTrue\n&gt;&gt;&gt; InList(v,(4,5))\nFalse\n&gt;&gt;&gt; InList(v,(1,2))\nTrue\n&gt;&gt;&gt; InList(v,(12,2))\nFalse\n&gt;&gt;&gt; InList(v,(3,1))\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["Ok Curiosity got better of me and so wanted to test how does this implementation performed with the fastest posted implementation "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; stmt1=\"\"\"\nv = [1,2,3,4,3,1,2]\ndef InList(v,(i,j)):\n    start=1\n    try:\n         while True:\n            if v[v.index(i,start)+1]==j and v[v.index(j,start)-1]==i:\n                return True\n            start=v.index(i)+1\n    except IndexError:\n        return False\n    except ValueError:\n        return False\nInList(v,(2,3))\nInList(v,(4,5))\nInList(v,(1,2))\nInList(v,(12,2))\n\"\"\"\n&gt;&gt;&gt; stmt2=\"\"\"\nv = [1,2,3,4,3,1,2]\ndef InList(v,(x,y)):\n    any([x,y] == v[i:i+2] for i in xrange(len(v) - 1))\nInList(v,(2,3))\nInList(v,(4,5))\nInList(v,(1,2))\nInList(v,(12,2))\n\"\"\"\n&gt;&gt;&gt; t1=timeit.Timer(stmt=stmt1)\n&gt;&gt;&gt; t2=timeit.Timer(stmt=stmt2)\n&gt;&gt;&gt; print \"%.2f usec/pass\" % (1000000 * t1.timeit(number=100000)/100000)\n13.67 usec/pass\n&gt;&gt;&gt; print \"%.2f usec/pass\" % (1000000 * t2.timeit(number=100000)/100000)\n20.67 usec/pass\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["Gosh this is way fast "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Note** Thanks Michael for pointing it out.", "I have corrected it and here is my updated solution."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["eumiro's answer wins for elegance, but if you need something even faster, you can take advantage of the built-in list.index() method which saves some time over iterating over the whole list."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "list.index()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n v = [1,2,3,4,3,1,2]\n\ndef f1(items):\n    return any([2,3] == v[i:i+2] for i in xrange(len(v) - 1))\n\ndef f2(items):\n    i = 0\n    index = items.index\n    try:\n        while 1:\n            i = index(2, i) + 1\n            if items[i] == 3:\n                return True\n    except IndexError:\n        return False\n\nfrom timeit import repeat    \nprint \"f1\", min(repeat(\"f1(v)\", \"from __main__ import f1, v\", number=1000))\nprint \"f2\", min(repeat(\"f2(v)\", \"from __main__ import f2, v\", number=1000))\n</code>\n</pre>\n", "senID": 1}, {"text": ["When I run this, I get:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre class=\"lang-none prettyprint-override\">\n<code>\n f1 0.00300002098083\nf2 0.0\n</code>\n</pre>\n", "senID": 3}, {"text": ["This should be even faster when the match isn't so close to the beginning of the list."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Perhaps even simpler:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = range(100)\nexists = (55,56) in zip(a, a[1:])\n</code>\n</pre>\n", "senID": 1}]]