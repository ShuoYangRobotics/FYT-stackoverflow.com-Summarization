[[{"text": ["When you run a script through the Python interpreter (or import that script from another script), it actually executes all the code from beginning to end -- in that sense, there is no \"entry point\" to a Python script."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "it actually executes all the code from beginning to end", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "that", "childNum": 0, "tag": "em", "childList": []}, {"text": "there is no \"entry point\" to a Python script", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["So to work around this, Python automatically creates a __name__ variable and fills it with the value \"__main__\" when you are running a script by itself (as opposed to something else importing that script).", "That's why you'll see many scripts like:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "__name__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\"__main__\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def foo():\n    print \"Hello!\"\n\nif __name__ == \"__main__\":\n   foo()\n</code>\n</pre>\n", "senID": 2}, {"text": ["where all the function/class definitions are at the top, and there is a similar if-statement as the last thing in the script.", "You are guaranteed that Python will start executing the script from top-to-bottom, so it will read all of your definitions there.", "If you wanted, you could intermingle actual functional code inside all the function definitions."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If this script was named bar.py, you could do python bar.py at the command line and you would see the script print out \"Hello!", "\"."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "bar.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "python bar.py", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\"Hello!\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["On the other hand, if you did import bar from another Python script, nothing would print out until you did bar.foo(), because __name__ was no longer \"__main__\" and the if-statement failed, thus foo was never executed."], "childNum": 5, "tag": "p", "senID": 5, "childList": [{"text": "import bar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "bar.foo()", "childNum": 0, "tag": "code", "childList": []}, {"text": "__name__", "childNum": 0, "tag": "code", "childList": []}, {"text": "\"__main__\"", "childNum": 0, "tag": "code", "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Excellent answer, but none points out what I think is one key insight for programmers coming to Python with background in other languages such as Java or C++: import, def and class are not \"instructions to the compiler\", \"declarations\", or other kind of magical incantations: they're executable statements like any other.", "For example, the def statement:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "import", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "class", "childNum": 0, "tag": "code", "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def f(x): return x + 23\n</code>\n</pre>\n", "senID": 1}, {"text": ["is almost exactly equivalent to the assignment statement:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n f = lambda x: x + 23\n</code>\n</pre>\n", "senID": 3}, {"text": ["(stylistically the def is preferable as it makes f.__name__ meaningful -- that's the \"almost\" part; lambda is rather limited and should only ever be used when you're really keen to make an anonymous function rather than a normal named one).", "Similarly,"], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "def", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "f.__name__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "anonymous", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n class X(object): zap = 23\n</code>\n</pre>\n", "senID": 5}, {"text": ["is equivalent to the assignment:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n X = type('X', (), {'zap': 23})\n</code>\n</pre>\n", "senID": 7}, {"text": ["(again, stylistically, class is preferable, afford more generality, like def it allows decoration, etc, etc; the point I'm making is that there is semantic equivalence here)."], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "class", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "childList": []}, {"text": "semantic", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["So, when you run a .py file, or import it for the first time in a program's run, Python executes its top-level statements one after the other -- in normal good Python style, most will be assignments, def, class, or import, but at least one will be a call (normally to a function) to execute that function's body of code (def, like lambda, just compiles that code; the compiled code object only executes when the function or lambda is called).", "Other answers have already suggested practical considerations such as testing __name__ in order to make a module that can either be run directly or imported, etc."], "childNum": 10, "tag": "p", "senID": 9, "childList": [{"text": ".py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "class", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "import", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "body", "childNum": 0, "tag": "em", "childList": []}, {"text": "def", "childNum": 0, "tag": "code", "childList": []}, {"text": "lambda", "childNum": 0, "tag": "code", "childList": []}, {"text": "compiles", "childNum": 0, "tag": "em", "childList": []}, {"text": "called", "childNum": 0, "tag": "em", "childList": []}, {"text": "__name__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Finally, it's best to have all \"significant\" code in functions (or methods in classes), not just stylistically, but because code in a function executes significantly faster (since the Python compiler can then automatically optimize all accesses to local variables).", "For example, consider...:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n import time\n\nlotsotimes = range(1000*1000)\n\nstart = time.time()\nfor x in lotsotimes:\n  x = x + x\nstend = time.time()\n\nprint 'in module toplev: %.6f' % (stend - start)\n\ndef fun():\n  start = time.time()\n  for x in lotsotimes:\n    x = x + x\n  stend = time.time()\n\n  print 'in function body: %.6f' % (stend - start)\n\nfun()\n</code>\n</pre>\n", "senID": 11}, {"text": ["On my laptop, with Python 2.6, this emits:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n in module toplev: 0.405440\nin function body: 0.123296\n</code>\n</pre>\n", "senID": 13}, {"text": ["So, for code that does a lot of variable accesses and little else, running it in a function as opposed to running it as module top-level code could speed it up by more than 3 times."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["The detailed explanation: at module-level, all variables are inevitably kept in a dictionary, so each variable access is a dict-access; local variables of a function get optimized into a special array, so access is faster (the difference is even more extreme than the 20% or so speed-up you'd see by accessing an item in a Python list vs one in a Python dict, since the local-variable optimization also saves hashing &amp; other ancillary costs)."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}], [{"text": ["Dive into Python is a good start.", "I wouldn't recommend to someone with no programming experience, but if you have coded in another language before, it will help you learn python idioms quickly."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Dive into Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://diveintopython.org/"}]}], [{"text": ["If you are quite familiar with several languages like C++ and Java, you may find it easy to follow the official Python Tutorial.", "It is written in a classical language description bottom-up style from the lexical structure and syntax to more advanced concepts."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Python Tutorial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/"}]}, {"text": ["The already mentioned Dive Into Python takes a top-down approach in learning languages starting from a complete program that is obscure for a beginner and diving into its details."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Dive Into Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://diveintopython.org/"}]}], [{"text": ["I started Python over a year ago too, also C++ background.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I've learned that everything is simpler in Python, you don't need to worry so much if you're doing it right, you probably are.", "Most of the things came natural."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I can't say I've read a book or anything, I usually pested the guys in #python on freenode a lot and looked at lots of other great code out there."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Good luck :)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I second Dive in to Python as a resource.", "As for the main function, there isn't one.", "The \"main\" function is what you write in the script you run. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Dive in to Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://diveintopython.org/"}]}, {"text": ["So a helloworld.py looks like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n print \"Hello World\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["and you run it with"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n python helloworld.py\n</code>\n</pre>\n", "senID": 4}, {"text": ["That's it!"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["The pithiest comment I guess is that the entry point is the 1st line of your script that is not a function or a class.", "You don't necessarily need to use the if hack unless you want to and your script is meant to be imported."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]