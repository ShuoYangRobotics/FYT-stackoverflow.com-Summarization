[[{"text": ["Here is an example in C++ that simulates generators using fibers:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Yield Return Iterator for Native C++ Using Fibers"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Yield Return Iterator for Native C++ Using Fibers", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.codeproject.com/KB/library/fiber-based%5Fiterator.aspx"}]}, {"text": ["There are also the primitive C routines setjmp, longjmp to achieve similar results.", "(Lua coroutines are implemented with the above method)"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "primitive", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "setjmp, longjmp", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Setjmp/longjmp"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"href": "http://www.lua.org/manual/5.1/manual.html#2.11", "text": "coroutines", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I wouldn't use yield at all in Lisp/Scheme."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "I wouldn't use yield at all in Lisp/Scheme.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["'yield' requires some kind of co-routine or continuation facility in the language.", "Many uses of yield can be implemented in a simpler functional way."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["YIELD is basically related to the famous COME-FROM operator.", ";-) Here, a call in some place can lead to different places in some other routine, depending on its execution context.", "So a routine suddenly has multiple entry points whose order is determined at runtime.", "For simple uses this may be fine, but I would argue that for more complex code reasoning about the code would get harder."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Take the Scheme example linked in the question:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n (define/y (step) \n  (yield 1)\n  (yield 2)\n  (yield 3)\n  'finished)\n\n(list (step) (step) (step))\n</code>\n</pre>\n", "senID": 4}, {"text": ["Calling (step) multiple times returns different values then."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I would just create a closure:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n (define step\n  (let ((state '(1 2 3 finished)))\n    (lambda ()\n      (pop state))))\n</code>\n</pre>\n", "senID": 7}, {"text": ["This breaks above function with a yield into two different things: a variable that carries the state and a simple function that changes the state.", "The state is no longer implicitly coded into the execution sequence."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n (list (step) (step) (step))))\n</code>\n</pre>\n", "senID": 9}, {"text": ["One can imagine similar solutions for other uses of yield."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Compare that with the generators from the Common Lisp SERIES library:"], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "generators from the Common Lisp SERIES library", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node364.html#SECTION003520000000000000000"}]}, {"code": "<pre>\n<code>\n (let ((x (generator (scan '(1 2 3 finished)))))\n  (list (next-in x)\n        (next-in x)\n        (next-in x)))\n</code>\n</pre>\n", "senID": 12}, {"text": ["If we look at this Python example from another answer"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n def simpleRange(n):\n    for i in xrange(n):\n        yield i\n\nfor n in simpleRange(5):\n     print(n)\n</code>\n</pre>\n", "senID": 14}, {"text": ["we can see that it duplicates the control structure.", "Both the calling place and the generator use a FOR iteration control structure.", "Using closures, we can get rid of the use of control structures inside the generator, by only providing the state transition code."], "childNum": 0, "tag": "p", "senID": 15, "childList": []}], [{"text": ["Monads can be used to represent generators (even if the semantics are little different)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Monads", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikibooks.org/wiki/Haskell/Understanding%5Fmonads"}]}, {"text": ["So any language allowing us to define monadic operations within a special syntax can be used here."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "VB.NET/C# (Linq - but C# already got ", "tag": "none", "senID": 2}, {"text": "Scala (For-comprehensions)", "tag": "none", "senID": 3}, {"text": "Haskell (do-notation)", "tag": "none", "senID": 4}, {"text": "F#/OCaml (Computation expressions/Perform)", "tag": "none", "senID": 5}]}, {"text": ["Ruby can emulate generators through its builtin continuation capabilities."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["In JavaScript 1.7+ I usually only have to add a few parentheses and brackets.", "Everything else is about the same.", "JavaScript 1.7 introduced pythonic generators and iterators among other things."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Generator expressions:"], "childNum": 0, "tag": "h2", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # Python\n(x + 1 for x in y if x &gt; 100)\n\n// JavaScript 1.8+\n(x + 1 for (x in y) if (x &gt; 100))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Generators"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # Python\ndef simpleRange(n):\n    for i in xrange(n):\n        yield i\n\nfor n in simpleRange(5):\n     print(n)\n\n\n// JavaScript 1.7+\nfunction simpleRange(n) {\n    for (let i = 0; i &lt; n; i++)\n        yield i;\n}\n\nfor (n in simpleRange(5))\n    print(n);\n</code>\n</pre>\n", "senID": 4}, {"text": ["List/Array comprehensions"], "childNum": 0, "tag": "h2", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n # Python\n[x + 1 for x in y if x &gt; 100]\n\n// JavaScript 1.7+\n[x + 1 for (x in y) if (x &gt; 100)]\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Common Lisp, although does not have native continuations, allows to create delimited continuations using CPS transformers like cl-cont.", "So generators in Common Lisp can be written in pretty much the same way as Scheme generators."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "cl-cont", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://common-lisp.net/project/cl-cont/"}]}, {"text": ["By the way, continuation-based generators have one trait that Python and C# generators lack: the yield may be called in the dynamic extent of the generator function call.", "Python and C# generators allow yield to be placed only inside the body of a generator."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "yield", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Ruby:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Generator function:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def simple_range(n)\n    Enumerator.new do |y|    \n        (0..n).each { |v| y.yield(v) }\n    end\nend\n</code>\n</pre>\n", "senID": 2}]]