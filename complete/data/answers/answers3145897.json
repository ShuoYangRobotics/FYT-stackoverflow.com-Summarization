[[{"text": ["Your code doesn't make sure it prints the largest product, since there could later be a smaller product which replaces it.", "To fix it, initialize t to zero, and replace your condition with"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "t", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n if z==s and int(z)&gt;t:\n    t = int(z)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or equivalently,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if z==s:\n    t = max(t,int(z))\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit: Fixed int/string issues above.", "It's a bit cleaner to avoid the conversion to string and back to int like this though:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def isPalindrome(x):\n    s = str(x)\n    return s == s[::-1]\n\nt = 0\nfor x in range(100, 1000):\n    for y in range(100, 1000):\n        z = x * y\n        if isPalindrome(z) and z &gt; t:\n            t = z\nprint t\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Here's a tricky but correct way to do it in a single expression...:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def main():\n  print max(p for x in range(100, 1000) for y in range(x, 1000)\n              for p in (x * y,) if str(p) == str(p)[::-1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["The tricky part is the single-item for p clause which plays the role of an assignment (just to stop recomputing that product several times;-)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "for p", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Note that the accepted answer is wrong (as are several others), because it looks for the string \"max\", which is different from the int max -- try running it, and you'll see!-)"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "string", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "int", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["The problem is to find the largest palindrome.", "You have nothing here to find the largest, simply the last.", "You assumed the last one would be the largest, but that isn't so because you are examining the entire ZxZ square of possibilities."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, you are considering 200*101 after you've considered 101*999."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You need to add a check if the one you found is larger than the one you already have."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Because of the way you're using the 2 for loops you're going to get the number with the largest x value, not the largest product."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["906609 = 993 * 913"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Then x keeps incrementing and the next palindrome is:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["580085 = 995 * 583"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You need a variable to keep track of the largest palindrome you've found."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def main():\n    largest = 0\n    for x in range(100, 1000):\n        for y in range(100, 1000):\n            z = str( x * y )\n            s = str( z[::-1] ) # Reverse z\n            if z == s:\n                t = int(z)\n                if t &gt; largest:\n                    largest = t\n    print largest\n</code>\n</pre>\n", "senID": 5}], [{"text": ["I'll add that you can save yourself some time in this test.", "All 6 digit palindromes must be divisible by 11.", "Therefore at least one of the factors must be divisible by 11."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]