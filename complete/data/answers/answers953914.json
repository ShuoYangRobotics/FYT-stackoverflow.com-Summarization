[[{"text": ["If you mean, can the function act differently based on the return types the caller is expecting, the answer is no (bar seriously nasty bytecode inspection).", "In this case, you should provide two different iterators on your object, and write something like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for item in something:  # Default iterator: returns non-tuple objects\n    do_something(item)\n\nfor (item,key) in something.iter_pairs(): # iter_pairs returns different iterator\n    do_something_else(item, key)\n</code>\n</pre>\n", "senID": 1}, {"text": ["eg.", "see the dictionary object, which uses this pattern.", "for key in mydict iterates over the dictionary keys.", "for k,v in mydict.iteritems() iterates over (key, value) pairs."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "for key in mydict", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "for k,v in mydict.iteritems()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["[Edit] Just in case anyone wants to see what I mean by \"seriously nasty bytecode inspection\", here's a quick implementation:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "[Edit]", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import inspect, opcode\n\ndef num_expected_results():\n    \"\"\"Return the number of items the caller is expecting in a tuple.\n\n    Returns None if a single value is expected, rather than a tuple.\n    \"\"\"\n    f = inspect.currentframe(2)\n    code = map(ord, f.f_code.co_code)\n    pos = f.f_lasti\n    if code[pos] == opcode.opmap['GET_ITER']: pos += 1 # Skip this and the FOR_ITER\n    if code[pos] &gt; opcode.EXTENDED_ARG: pos +=5\n    elif code[pos] &gt; opcode.HAVE_ARGUMENT: pos +=3\n    else: pos += 1\n    if code[pos] == opcode.opmap['UNPACK_SEQUENCE']:\n        return code[pos+1] + (code[pos+2] &lt;&lt; 8)\n    return None\n</code>\n</pre>\n", "senID": 4}, {"text": ["Usable something like:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class MagicDict(dict):\n    def __iter__(self):\n        if num_expected_results() == 2:\n            for k,v in self.iteritems():\n                yield k,v\n        else:\n            for k in self.iterkeys(): \n                yield k\n\nd=MagicDict(foo=1, bar=2)\n\nprint \"Keys:\"\nfor key in d:\n    print \"   \", key\nprint \"Values\"    \nfor k,v in d:\n    print \"   \",k,v\n</code>\n</pre>\n", "senID": 6}, {"text": ["Disclaimer: This is incredibly hacky, insanely bad practice, and will cause other programmers to hunt you down and kill you if they ever see it in real code.", "Only works on cpython (if that).", "Never use this in production code (or for that matter, probably any code)."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "Disclaimer:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "will", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "Never", "childNum": 0, "tag": "strong", "pos": 2, "childList": []}]}], [{"text": ["Have you tried that?", "It works."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def myfunction(data):\n    datalen = len(data)\n    result1 = data[:datalen/2]\n    result2 = data[datalen/2:]\n    return result1, result2\n\n\na, b = myfunction('stuff')\nprint a\nprint b\n\nc = myfunction('other stuff')\nprint c\n</code>\n</pre>\n", "senID": 1}, {"text": ["In fact there is no such thing as \"return signature\".", "All functions return a single object.", "It seems that you are returning more than one, but in fact you wrap them into a container tuple object."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Update:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Given the example use case, I'd write different generators to handle the cases:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Something(object): \n   def __init__(self): \n       self.d = {'a' : 1, \n               'b' : 2, \n               'c' : 3} \n\n   def items(self): \n       for i in self.d.values(): \n           yield i \n\n  def items_keys(self): \n      for k,i in self.d.items(): \n          yield i,k \n\nsomething = Something()\n\nfor item in something.items():\n....:     print item\n....: \n1\n3\n2\n\nfor item,key in something.items_keys():\n....:     print key, \" : \", item\n....: \na  :  1\nb  :  2\nc  :  3\n</code>\n</pre>\n", "senID": 2}, {"text": ["Or"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You can return a tuple:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n In [1]: def func(n):\n   ...:     return (n, n+1)\n   ...: \n\nIn [2]: a,b = func(1)\n\nIn [3]: a\nOut[3]: 1\n\nIn [4]: b\nOut[4]: 2\n\nIn [5]: x = func(1)\n\nIn [6]: x\nOut[6]: (1, 2)\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; def func(a,b):\n      return (a,b)\n\n&gt;&gt;&gt; x = func(1,2)\n&gt;&gt;&gt; x\n(1, 2)\n&gt;&gt;&gt; (y,z) = func(1,2)\n&gt;&gt;&gt; y\n1\n&gt;&gt;&gt; z\n2\n</code>\n</pre>\n", "senID": 0}, {"text": ["That doesn't really answer your question.", "The real answer is that the left side of the assignment doesn't affect the returned type of the function and can't be used to distinguish between functions with different return types.", "As noted in other answers, the function can return different types from different return statements but it doesn't know what's on the other side of the equals sign. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In the case of this function, it returns a tuple.", "If you assign it to x, x has the value of the tuple.", "(y, z) on the left side of the assignment is \"tuple unpacking\".", "The tuple returned by func() is unpacked into y and z."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It's possible only if you're happy for val to be a 2-item tuple (or if args need not be the same in the two cases).", "The former is what would happen if the function just ended with something like return 23, 45.", "Here's an example of the latter idea:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "val", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "args", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "return 23, 45", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def weirdfunc(how_many_returns):\n  assert 1 &lt;= how_many_returns &lt;= 4\n  return 'fee fie foo fum'.split()[:how_many_returns]\n\nvar1, var2 = weirdfunc(2)  # var1 gets 'fee', var2 gets 'fie'\n\nvar, = weirdfunc(1)  # var gets 'fee'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Yes, both would work.", "In the first example, val1 and val2 would have the two values.", "In the second example, val would have a tuple.", "You can try this in your python interpreter:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def foo():\n...   return ( 1, 2 )\n...\n&gt;&gt;&gt; x = foo()\n&gt;&gt;&gt; (y,z) = foo()\n&gt;&gt;&gt; x\n(1, 2)\n&gt;&gt;&gt; y\n1\n&gt;&gt;&gt; z\n2\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Yes it's doable:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def a(b):\nif b &lt; 5:\n\treturn (\"o\", \"k\")\nelse:\n\treturn \"ko\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["and the result:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; b = a(4)\n&gt;&gt;&gt; b\n('o', 'k')\n&gt;&gt;&gt; b = a(6)\n&gt;&gt;&gt; b\n'ko'\n</code>\n</pre>\n", "senID": 3}, {"text": ["I think the thing after is to be careful when you will use the values returned..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["This is asking for major confusion.", "Instead you can follow dict with separate keys, values, items, etc.", "methods, or you can use a convention of naming unused variables with a single underscore.", "Examples:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n for k in mydict.keys(): pass\nfor k, v in mydict.items(): pass\n\nfor a, b in myobj.foo(): pass\nfor a, _ in myobj.foo(): pass\nfor _, b in myobj.foo(): pass\n\nfor _, _, _, d in [(\"even\", \"multiple\", \"underscores\", \"works\")]:\n    print(d)\n\nfor item in something: # or something.keys(), etc.\n    do_item(item)\n\nfor item, key in something.items():\n    do_more(key, item)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If this doesn't fit your function, you should refactor it as two or more functions, because it's clearly trying to fulfill two or more different goals."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]