[[{"text": ["Well, if what you want to do is send emails then use the emailmodule. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "emailmodule", "tag": "a", "pos": 0, "childList": [{"text": "email", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/email-examples.html"}, {"text": "email", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If I were you, I would write a simple Python script which processes a bunch of rules, probably just written as simple Python statements in a separate file, then send the emails / sms / ... for those rules that require an action to be performed. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can make that run once a day (or whatever) using a service such as cron"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "cron", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Cron"}]}, {"text": ["For example, if your rules look like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n # Rule file: rules.py\n\ndef rule1():\n    if db.getAllUsers().contains(\"admin\"): \n        return ('email', 'no admin user in db')\n    else:\n        return None, None\n\ndef rule2():\n    if temp &gt; 100.0: \n        return ('sms', 'too hot in greenhouse')\n    else:\n        return (None, None)\n\n...\n\nrules = [rule1, rule2, ....]\n</code>\n</pre>\n", "senID": 4}, {"text": ["then your processing script might look like this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n # Script file: engine.py\n\nimport rules\nimport email\n...\n\ndef send_email(message, receiver):\n    # function that sends an email...\n\ndef send_sms(message, receiver):\n    # function that sends an sms...\n\nactions = {'email':send_email, 'sms':send_sms, ...}    \n\nif __name__ == '__main__':\n\n    # Declare receiver here...\n\n    for rule in rules.rules:\n        # Does the rule return a do-able action?\n        # To be really paranoid we might wrap this in a try/finally\n        # in case the rules themselves have any side effects,\n        # or they don't all return 2-tuples.\n        act, message = rule()\n        if act in actions:\n            # perform the action\n            actions[rule()](message, receiver)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Undoubtedly there are other ways to do this, such as creating a Pythonic DSL with which to write the rules."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Pythonic DSL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ibm.com/developerworks/library/l-cpdec/index.html"}]}], [{"text": ["There are several ways to achieve this.", "The other answers are valuable, and I'd like to add two techniques."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Provided you can rewrite the table juste create each rules as a pickled function that you can deserialize when needed", "tag": "none", "senID": 1}, {"text": "Write a big dictionary with rules as a key, and a function a a value. If you got 100 max rules, this is manageable. Just make sure you make very flexible functions using *args and **kwargs.", "tag": "none", "senID": 2}]}, {"text": ["Example with pickle:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Example with pickle:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["First, make a function that is flexible with its input."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def greater_than(value, *args, **kwargs):\n    return all(value &gt; i for i in args)\n</code>\n</pre>\n", "senID": 5}, {"text": ["Then pickle it:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "pickle", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/pickle.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import pickle\n&gt;&gt;&gt; rule = pickle.dumps(greater_than)\n&gt;&gt;&gt; rule # store this in DB\n'ctest\\ngreater_than\\np0\\n.'\n</code>\n</pre>\n", "senID": 7}, {"text": ["Then when you need to get you business rule back:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; func = pickle.loads(rule) # rule is the sring from DB\n&gt;&gt;&gt; func(5, 4, 3, 1)\nTrue\n&gt;&gt;&gt; func(5, 6) \nFalse\n</code>\n</pre>\n", "senID": 9}, {"text": ["The purpose of having flexible input is that you can get an arbitrary number of parameters :"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; args = [1, 2, 3]\n&gt;&gt;&gt; func(5, *args)\nTrue\n</code>\n</pre>\n", "senID": 11}, {"text": ["Example with a dictionary"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "Example with a dictionary", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Store all functions in one big mapping:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n def greater_than(value, *args, **kwargs):\n    return all(value &gt; i for i in args)\n\nRULES = {\n    'if x &gt; y': greater_than\n    'other rule': other_func,\n    etc\n}\n</code>\n</pre>\n", "senID": 14}, {"text": ["Then when you need it:"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; func = RULES['if x &gt; y']\n   &gt;&gt;&gt; func(5, 1)\n   True\n</code>\n</pre>\n", "senID": 16}], [{"text": ["Since the \"variable\", \"value\" and comparison operator for eahc rule are on the database, you could write a Rule class that will take the apropriate parameters (operator, action, value, etc...), and yield a callable object that will receive all the relevant variables in the form of a dictionary, and take the proper registered action."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It would look like this, though you have to adapt it to proper get the parameters for your actions:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import operator\n\nclass Rule(object):\n    def __init__(self, variable_name, op, value, action):\n        op_dict = {\"=\": operator.eq,\n                   \"&gt;\": operator.gt,\n                   \"&lt;\": operator.lt,\n                   #(...)\n                  }\n        action_dict = {\"email\": email_function,\n                       \"log\": log_function,\n                       # ...\n                      }\n        self.variable = variable_name\n        self.op = op_dict[op]\n        self.value = value\n        self.action = action_dict[action]\n    def __call__(self, value_dict, action_parameters, k_action_parameters):\n        if self.op(value_dict[self.variable], self.value):\n            return self.action(*action_parameters, **k_action_parameters)\n        return False\n\nrule = Rule(\"temp\", \"&gt;\", \"email\")\nfor result in query():\n     rule(result, ())\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Write a parser.", "See pyparsing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Alternatively, make a table driven approach. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Why do you need to store rules into a database?", "Can't you just store the data in the database and put the rules into a python module?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["For example in a file rules.py you could:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "rules.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "Write a set of rules", "tag": "none", "senID": 2}, {"text": "Write a parser for your data that will apply the right rule for each paramenter", "tag": "none", "senID": 3}]}, {"text": ["Then in your main you just have to pass the data to your rules.parser() and everything will be taken care of."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "rules.parser()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit: Seen your comment I've made a new answer."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/a/8871883/1132524", "text": "new answer", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I think you mainly need two things:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "a ", "tag": "none", "senID": 1}, {"text": ["pickle"], "childNum": 1, "tag": "a", "senID": 2, "childList": [{"text": "pickle", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}, {"text": ["This is how your main could look like:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import pickle\n\n# some data loaded from your DB\ndata = {'temp': 60, 'wind': 150}\n\n# entry should be provided by your front-end template\nentry = {'param_name': 'temp', 'test': Test(gt, 50), 'action': send_email}\n\nrule = Rule(**entry)\nto_store = pickle.dumps(rule)\n# store 'to_store' into your DB\n\n# Let's pretend to load the previously stored rule\nstored = to_store\nrule = pickle.loads(stored)\nrule(data)\n</code>\n</pre>\n", "senID": 4}, {"text": ["The idea is to get every information that you need to build a Rule from your template and then you just store that rule with pickle."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["This may be a Rule implementation:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Rule", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # =======\n# Actions\n# =======\n#\n# Any callable with no arguments is an Action\n# (you may need to implement this)\n#\n\ndef send_email():\n    print('email sent')\n\n# ==========\n# Test class\n# ==========\n#\n# Test class is a way to call your test function.\n# The real test is in self.function\n#\n\nclass Test:\n\n    def __init__(self, function, *args):\n        self.function = function\n        self.args = args\n\n    def __call__(self, parameter):\n        return self.function(parameter, *self.args)\n\n# ==============\n# Test functions\n# ==============\n#\n# These are the functions that are going to be executed\n#\n\nimport operator\n\ngt = operator.gt\n\ndef more_complex_test(*args):\n    pass\n\n# ==========\n# Rule class\n# ==========\n#\n# A Rule needs to know:\n#  - the parameter to test\n#  - the test to perform\n#      - the action to execute\n#\n\nclass Rule:\n\n    def __init__(self, param_name, test, action):\n        self.param_name = param_name\n        self.test = test\n        self.action = action\n\n    def __call__(self, data):   # data is a dictionary {'temp': 60, ...}\n        param_value = data[self.param_name]\n        if self.test(param_value):\n            return self.action()\n        return False\n</code>\n</pre>\n", "senID": 7}, {"text": ["Note: The two pieces of code above (if put togheter) can be executed.", "Give it a try!"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Note:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["I have used @jsbuenos code snippet and done a few changes to form this.", "Basicaly, I also need support to check the \"unit of measure\" for a rule to evaluate the condition.", "So to support diff.", "rules like if time > 24 hrs send email OR if temp > 40 celsius send email etc.", "(I would probably have other units later on as well..) I have included a new dict to map the unit of measure to a calculate function and accordingly changed the callable function for the class.", "Would this be the right approach to do it?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\n\nclass Rule(object):\n    def __init__(self, variable_name, op, value, action):\n      op_dict = {\"=\": operator.eq,\n               \"&gt;\": operator.gt,\n               \"&lt;\": operator.lt,\n               #(...)\n              }\n      action_dict = {\"email\": email_function,\n                   \"log\": log_function,\n                   # ...\n                  }\n\n      eval_condition = {\"hrs\" :  self.raise_timeexceeded_alert,\n                    \"celsius\" : self.raise_tempexceeded_alert,\n                    #}  \n\n      self.variable = variable_name\n      self.op = op_dict[op]\n      self.value = value\n      self.action = action_dict[action]\n      self.uom = measure      \n      self.raise_alert = eval_condition[measure]\n\n   def __call__(self, actual_value, *action_parameters):\n     if self.raise_alert(actual_value,self.op,self.uom,self.threshold):\n        return self.action(*action_parameters)\n    return False\n\n   def raise_timeexceeded_alert(self,timevalue, op, uom, threshold):\n    #calculate time difference with respect to local timezone and return true\n    # if diff is 'operator' threshold\n    localtime=pytz.timezone(TIMEZONE)\n    ....\n    ...\n    return False\n\n\n   def raise_tempexceeded_alert(self,timevalue, op, uom, threshold):\n     #return True if temp. is 'operator' threshold\n     ....\n     .....\n     return False\n\n\nrule = Rule(\"time\", \"&gt;=\", \"24\" , \"hrs\", \"email\")\nargs = [contact_email,message]\nrule(\"2011-12-11 12:06:03\",*args)\n</code>\n</pre>\n", "senID": 1}]]