[[{"text": ["A rarely seen trick is that a lambda function can refer to itself recursively:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fib = lambda n: n if n &lt; 2 else fib(n-1) + fib(n-2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["By the way, it's rarely seen because it's confusing, and in this case it is also inefficient.", "It's much better to write it on multiple lines:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def fibs():\n    a = 0\n    b = 1\n    while True:\n        yield a\n        a, b = b, a + b\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n fib = lambda n:reduce(lambda x,n:[x[1],x[0]+x[1]], range(n),[0,1])[0]\n</code>\n</pre>\n", "senID": 0}, {"text": ["(this maintains a tuple mapped from [a,b] to [b,a+b], initialized to [0,1], iterated N times, then takes the first tuple element)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; fib(1000)\n43466557686937456435688527675040625802564660517371780402481729089536555417949051\n89040387984007925516929592259308032263477520968962323987332247116164299644090653\n3187938298969649928516003704476137795166849228875L\n</code>\n</pre>\n", "senID": 2}, {"text": ["(note that in this numbering, fib(0) = 0, fib(1) = 1, fib(2) = 1, fib(3) = 2, etc."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If we consider the \"most Pythonic way\" to be elegant and effective then:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fib(nr):\n    return int(((1 + math.sqrt(5)) / 2) ** nr / math.sqrt(5) + 0.5)\n</code>\n</pre>\n", "senID": 1}, {"text": ["wins hands down.", "Why use a inefficient algorithm (and if you start using memoization we can forget about the oneliner) when you can solve the problem just fine in O(1) by approximation the result with the golden ratio?", "Though in reality I'd obviously write it in this form:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def fib(nr):\n    ratio = (1 + math.sqrt(5)) / 2\n    return int(ratio ** nr / math.sqrt(5) + 0.5)\n</code>\n</pre>\n", "senID": 3}, {"text": ["More efficient and much easier to understand."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["This is a memoizing one liner"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fib = lambda x,y=[1,1]:y[x] if x&lt;len(y) else (y.append(y[-1]+y[-2]),fib(x))[1]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Another example, taking the cue from Mark Byers's answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fib = lambda n,a=0,b=1: a if n&lt;=0 else fib(n-1,b,a+b)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n fib = lambda n, x=0, y=1 : x if not n else fib(n-1, y, x+y)\n</code>\n</pre>\n", "senID": 0}, {"text": ["run time O(n), fib(0) = 0, fib(1) = 1, fib(2) = 1 ..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Here's an implementation that doesn't use recursion, and only memoizes the last two values instead of the whole sequence history. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["nthfib() below is the direct solution to the original problem (as long as imports are allowed)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It's less elegant than using the Reduce methods above, but, although slightly different that what was asked for, it gains the ability to to be used more efficiently as an infinite generator if one needs to output the sequence up to the nth number as well  (re-writing slightly as fibgen() below)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from itertools import imap, islice, repeat\n\nnthfib = lambda n: next(islice((lambda x=[0, 1]: imap((lambda x: (lambda setx=x.__setitem__, x0_temp=x[0]: (x[1], setx(0, x[1]), setx(1, x0_temp+x[1]))[0])()), repeat(x)))(), n-1, None))    \n\n&gt;&gt;&gt; nthfib(1000)\n43466557686937456435688527675040625802564660517371780402481729089536555417949051\n89040387984007925516929592259308032263477520968962323987332247116164299644090653\n3187938298969649928516003704476137795166849228875L\n</code>\n</pre>\n", "senID": 3}, {"tag": "br", "senID": 4}, {"code": "<pre>\n<code>\n from itertools import imap, islice, repeat\n\nfibgen = lambda:(lambda x=[0,1]: imap((lambda x: (lambda setx=x.__setitem__, x0_temp=x[0]: (x[1], setx(0, x[1]), setx(1, x0_temp+x[1]))[0])()), repeat(x)))()\n\n&gt;&gt;&gt; list(islice(fibgen(),12))\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\n</code>\n</pre>\n", "senID": 5}]]