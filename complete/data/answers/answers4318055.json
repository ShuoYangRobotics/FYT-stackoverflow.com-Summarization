[[{"text": ["No"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's perfectly unclear what the real rules are.", "The \"some have 3 digits and some have 4\" isn't really a very precise or complete specification.", "All your examples show 4 letters in front of the digits.", "Is this always true?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import re\nkey_pat = re.compile( r\"^(\\D+)(\\d+)$\" )\ndef key( item ):\n    m= key_pat.match( item )\n    return m.group(1), int(m.group(2))\n</code>\n</pre>\n", "senID": 2}, {"text": ["That key function might do what you want.", "Or it might be too complex.", "Or maybe the pattern is really r\"^(.", "*)(\\d{3,4})$\" or maybe the rules are even more obscure."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "key", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "r\"^(.*)(\\d{3,4})$\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; data= ['asdf123', 'asdf1234', 'asdf111', 'asdf124']\n&gt;&gt;&gt; data.sort( key=key )\n&gt;&gt;&gt; data\n['asdf111', 'asdf123', 'asdf124', 'asdf1234']\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The issue is that the sorting is alphabetical here since they are strings.", "Each sequence of character is compared before moving to next character."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "alphabetical here since they are strings", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 'a1234' &lt; 'a124'  &lt;----- positionally '3' is less than '4' \nTrue\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["You will need to due numeric sorting to get the desired output."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "numeric sorting", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = ['asdf123', 'asdf1234', 'asdf111', 'asdf124']\n&gt;&gt;&gt; y = [ int(t[4:]) for t in x]\n&gt;&gt;&gt; z = sorted(y)\n&gt;&gt;&gt; z\n[111, 123, 124, 1234]\n&gt;&gt;&gt; l = ['asdf'+str(t) for t in z]\n&gt;&gt;&gt; l\n['asdf111', 'asdf123', 'asdf124', 'asdf1234']\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n l = ['asdf123', 'asdf1234', 'asdf111', 'asdf124']\nl.sort(cmp=lambda x,y:cmp(int(x[4:]), int(y[4:]))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You need a key function.", "You're willing to specify 3 or 4 digits at the end and I have a feeling that you want them to compare numerically. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sorted(list_, key=lambda s: (s[:-4], int(s[-4:])) if s[-4] in '0123456789' else (s[:-3], int(s[-3:])))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Without the lambda and conditional expression that's"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def key(s):\n    if key[-4] in '0123456789':\n         return (s[:-4], int(s[-4:]))\n    else:\n         return (s[:-3], int(s[-3:]))\n\nsorted(list_, key=key)\n</code>\n</pre>\n", "senID": 3}, {"text": ["This just takes advantage of the fact that tuples sort by the first element, then the second.", "So because the key function is called to get a value to compare, the elements will now be compared like the tuples returned by the key function.", "For example, 'asdfbad123' will compare to  'asd7890' as ('asdfbad', 123) compares to ('asd', 7890).", "If the last 3 characters of a string aren't in fact digits, you'll get a ValueError which is perfectly appropriate given the fact that you passed it data that doesn't fit the specs it was designed for."], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "key", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "'asdfbad123'", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "'asd7890'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "('asdfbad', 123)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "('asd', 7890)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"code": "<pre>\n<code>\n L.sort(key=lambda s:int(''.join(filter(str.isdigit,s[-4:]))))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["What you're probably describing is called a Natural Sort, or a Human Sort.", "If you're using Python, you can borrow from Ned's implementation."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Natural Sort", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.codinghorror.com/blog/2007/12/sorting-for-humans-natural-sort-order.html"}, {"text": "Ned's implementation", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://nedbatchelder.com/blog/200712.html#e20071211T054956"}]}, {"text": ["The algorithm for a natural sort is approximately as follows:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Split each value into alphabetical \"chunks\" and numerical \"chunks\"", "tag": "none", "senID": 2}, {"text": "Sort by the first chunk of each value\n", "tag": "none", "senID": 3}, {"text": "Take the values that have the same first chunk and sort them by the second chunk", "tag": "none", "senID": 4}, {"text": "And so on", "tag": "none", "senID": 5}]}]]