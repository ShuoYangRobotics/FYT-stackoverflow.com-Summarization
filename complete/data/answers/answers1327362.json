[[{"text": ["How about:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def call_one(func, param1, param2):\n    if param2:\n        code_chunk_1\n\n    func(param1)\n\n    if param2:\n        code_chunk_2\n\ndef _fooA(param1):\n    fooA_code  #uses only param1\n\ndef _fooB(param1):\n    fooB_code  #uses only param1\n\ndef fooA(param1, param2):\n    call_one(_fooA, param1, param2)\n\ndef fooB(param1, param2):\n    call_one(_fooB, param1, param2)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Since you try to enable some wrapper functionality iff the passed option is True, consider using keyword arguments.", "Here is a real-world example that will wrap your code in a (database-) transaction if requested:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def wrap_transaction(func):\n    def wrapper(*args, **kwargs):\n        # If the option \"use_transaction\" is given, wrap the function in\n        # a transaction.  Note that pop() will remove the parameter so\n        # that it won't get passed to the wrapped function, that does not need\n        # to know about its existance.\n        use_transaction = kwargs.pop('use_transaction', False)\n\n        if use_transaction:\n            get_connection().begin_transaction()\n\n        try:\n            result = func(*args, **kwargs)\n        except:\n            if use_transaction:\n                get_connection().rollback()\n            raise\n\n        if use_transaction:\n            get_connection().commit()\n\n        return result\n\n    return wrapper\n\n@wrap_transaction\ndef my_func(param):\n    # Note that this function knows nothing about the 'use_transaction' parameter\n    get_connection().exec(\"...\")\n\n\n# Usage: Explicitely enabling the transaction.\nmy_func(param, use_transaction=True)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["What you are describing is a situation where you have some boilerplate, some behaviour, followed by some boiler plate.", "Essentially a situation where you could use a Higher Order Function (like map, reduce or filter)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Higher Order Function", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Higher-order%5Ffunction"}]}, {"text": ["You could do what Ned suggests (though, I'd use functools.partial rather than defining fooA/fooB longhand):"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "functools.partial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functools.html#functools.partial"}]}, {"code": "<pre>\n<code>\n import functools\n\n...\n\nfooA = functools.partial(call_one, _fooA)\nfooB = functools.partial(call_one, _fooB)\n</code>\n</pre>\n", "senID": 2}, {"text": ["... but that effectively gets you back to the same place as with your decorator, introducing some clutter into the namespace along the way."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You could rewrite your decorator to allow functions that only take one parameter, but return functions that take two:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def refactorMe(func):\n    def wrapper(parm1, parm2):\n        if parm1:\n            code_chunk_1\n\n        func(parm1)\n\n        if parm2[-1]:\n            code_chunk_2\n\n    return wrapper\n</code>\n</pre>\n", "senID": 5}, {"text": ["Getting rid of the star magic is an improvement as this decorator is not general to all functions so we should be explicit about it.", "I like the fact that we change the number of parameters less as anyone looking at the code could easily be confused by the fact that when we call the function we are adding an extra parameter.", "Furthermore it just feels like decorators that change the signature of the function they decorate should be bad form."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "should", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["In summary:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Decorators are higher order functions, and templating behaviour is precisely what they're for."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "precisely", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["I would embrace the fact that this code is specific to your fooXXX functions, by making the decorator internal and having it take precisely the number of arguments needed (because foo(*args, **kwargs) signatures makes introspection a pain)."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n def _refactorMe(func):\n        @functools.wraps(func) #the wraps decorator propagates name/docsting\n        def wrapper(parm1, parm2):\n            if parm1:\n                code_chunk_1\n\n            func(parm1, parm2)\n\n            if parm2:\n                code_chunk_2\n\n        return wrapper\n</code>\n</pre>\n", "senID": 10}, {"text": ["I'd leave the calls taking two parameters, even though one is unused just so that the decorator doesn't change the signature.", "This isn't strictly necessary as if you document the functions as they look after decoration and you are restricting the use of the decorator to this small set of functions then the fact that the signature changes shouldn't be that big a deal."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n @_refactorMe\ndef fooB(param1, param2):\n    fooB_code  #uses only param1\n\n\n@_refactorMe\ndef fooB(param1, param2):\n    fooB_code  #uses only param1\n</code>\n</pre>\n", "senID": 12}], [{"text": ["I would do a straightforward extract method refactoring:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def _code_chunk_1(param):\n    if param == True:\n        code_chunk_1\n\ndef _code_chunk_2(param):\n    if param == True:\n        code_chunk_2\n\ndef fooA(param1, param2):\n    _code_chunk_1(param2)\n\n    fooA_code  #uses only param1\n\n    _code_chunk_2(param2)\n\ndef fooB(param1, param2):\n    _code_chunk_1(param2)\n\n    fooB_code  #uses only param1\n\n    _code_chunk_2(param2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The decorator looks inappropriate to me in this context.", "Ned's answer above also looks nice."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I like Ferdinand Beyer's answer and I think we need examples like that to understand what we are talking about.", "I'm just goin to give two further inspirational suggestions."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Why not explicitly use transaction code?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def fooA(param1, use_transaction=param2):\n    enter_transaction(param2)\n    fooA_code  #uses only param1\n    exit_transaction(param2)\n\ndef fooB(param1, use_transaction=param2):\n    enter_transaction(param2)\n    fooB_code  #uses only param1\n    exit_transaction(param2)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now with that written we understand that we should probably write this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def fooA(param1, use_transaction=param2):\n    with transaction(param2):\n        fooA_code  #uses only param1\n\ndef fooB(param1, use_transaction=param2):\n    with transaction(param2):\n        fooB_code  #uses only param1\n</code>\n</pre>\n", "senID": 4}, {"text": ["Using some context manager."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["But wait!", "We can put that outside!"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["if you want this use:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n with transactional():\n    fooA(param1)\n</code>\n</pre>\n", "senID": 8}, {"text": ["for the not param2 case, simply call fooA(param1)"], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "not param2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "fooA(param1)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Last syntax suggestion, when param2 == true:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n do_transaction(fooA, param1)\n</code>\n</pre>\n", "senID": 11}, {"text": ["here we define"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n def do_transaction(func, *args):\n    code_1\n    func(*args)\n    code_2\n</code>\n</pre>\n", "senID": 13}, {"text": ["Ok that was my stream of thoughts.", "Can you use a context manager?", "It is also hard to document, but somehow this wrapping process must be integral to your application, or if it's not, you could remove it."], "childNum": 0, "tag": "p", "senID": 14, "childList": []}], [{"text": ["I'm wondering if you're adding debugging code.", "Since param2 is not used in the function proper, maybe you want to move it into the decorator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class debugging:\n    def __init__(self, show):\n        self.show = show\n\n    def __call__(self, f):\n        def wrapper(*args):\n            if self.show:\n                print \"inside\", f\n\n            rv = f(*args)\n\n            if self.show:\n                print \"outside\", f\n\n            return rv\n\n        return wrapper\n\n@debugging(True)\ndef test(n):\n    print n\n\ntest(10)\n</code>\n</pre>\n", "senID": 1}, {"text": ["will print"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n inside &lt;function test at 0x7fb28ff102a8&gt;\n10\noutside &lt;function test at 0x7fb28ff102a8&gt;\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Having a similar problem, I came up with a more generic solution that allows to:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "wrap a function with one implementing more parameters", "tag": "none", "senID": 1}, {"text": "preserving the wrapped function documentation, including the wrapper documentation", "tag": "none", "senID": 2}]}, {"text": ["Hoping to help I wanted to share it and found this \"old\" question, which seems appropriate."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n @decorator_more_args_prepend\ndef add_params_a_b(f, a, b, *args, **kw):\n    \"\"\"\n    Wrapper whose description we don't want in the generated function\n\n    Line that we want in the generated function\n\n    :param a: description of a\n    :param b: description of b\n\n    No idea about the rest of the arguments\n    \"\"\"\n    print(\"Doing something with %s and %s, calling %s with args %s\" % (a, b, f.__name__, args))\n    return f(*args, **kw)\n\n@add_params_a_b\ndef test_func(c, d):\n    \"\"\"\n    Test function that we want augmented\n\n    :param c: description of c\n    :param d: description of d\n    \"\"\"\n    print(\"Called with c=%(c)s and d=%(d)s\" % locals())\n</code>\n</pre>\n", "senID": 5}, {"text": ["Help:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n Help on function test_func in module __main__:\n\ntest_func(a, b, c, d)\n    Test function that we want augmented\n\n    Line that we want in the generated function\n\n    :param a: description of a\n    :param b: description of b\n\n    No idea about the rest of the arguments\n\n    :param c: description of c\n    :param d: description of d\n</code>\n</pre>\n", "senID": 7}, {"text": ["Call:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; test_func(1, 2, 3, 4)\nDoing something with 1 and 2, calling test_func with args (3, 4)\nCalled with c=3 and d=4\n</code>\n</pre>\n", "senID": 9}, {"text": ["So the implementation of decorator_more_args_prepend uses decorator:"], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "decorator_more_args_prepend", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "decorator", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n# encoding: utf-8\n# A few decorators\n\n__author__ = \"J\u00e9r\u00f4me Carretero &lt;cJ-py@zougloub.eu&gt;\"\n__contact__ = \"http://gitorious.org/py_decorators\"\n__license__ = \"Python\"\n__credits__ = [\"Michele Simionato\"]\n__version__ = \"1.0.0\"\n\nfrom decorator import FunctionMaker, partial, inspect, decorator\n\n# \ndef decorator_more_args_prepend(caller, func=None):\n    \"\"\"\n    Decorator that construcs a function which calls the caller on func,\n    adding the arguments of caller as first arguments of the function.\n\n    Directly inspired by the decorator module code, but:\n\n    - we build a generated signature instead of passing the callee function\n    - we generate a docstring consisting of a merging of info from wrapper and wrapped ones\n\n    Based on decorator.decorator, Copyright (c) 2005-2011, Michele Simionato\n    \"\"\"\n    if func is not None: # returns a decorated function\n        evaldict = func.__globals__.copy()\n        evaldict.update({'_call_': caller, '_func_': func})\n        caller_spec = inspect.getargspec(caller)\n        callee_spec = inspect.getargspec(func)\n        def cleaned_docstring(o):\n            import pydoc\n            return pydoc.getdoc(o).split(\"\\n\")\n        caller_doc = cleaned_docstring(caller)\n        callee_doc = cleaned_docstring(func)\n        newdoc = \"\\n\".join(callee_doc[:1] + caller_doc[1:] + callee_doc[1:])\n        return FunctionMaker.create(\n         \"%s(%s)\" % (func.__name__, \", \".join(caller_spec.args[1:]+callee_spec.args)),\n         \"return _call_(_func_, %(shortsignature)s)\",\n         evaldict, undecorated=func, __wrapped__=func, doc=newdoc,\n        )\n    else:\n        if isinstance(caller, partial):\n            return partial(decorator, caller)\n        # otherwise assume caller is a function\n        first = inspect.getargspec(caller)[0][0]\n        evaldict = caller.__globals__.copy()\n        evaldict['_call_'] = caller\n        evaldict['decorator'] = decorator\n        return FunctionMaker.create(\n         '%s(%s)' % (caller.__name__, first),\n         'return %s(_call_, %s)' % (inspect.stack()[0][3], first),\n         evaldict, undecorated=caller, __wrapped__=caller,\n         doc=caller.__doc__, module=caller.__module__)\n</code>\n</pre>\n", "senID": 11}, {"text": ["Edit: I put the code on gitorious and won't maintain it here."], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "gitorious", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://gitorious.org/py_decorators"}]}]]