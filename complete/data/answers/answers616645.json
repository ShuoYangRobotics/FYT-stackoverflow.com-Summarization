[[{"text": ["I had this same issue before and found this snippet very useful:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Tee(object):\n    def __init__(self, name, mode):\n        self.file = open(name, mode)\n        self.stdout = sys.stdout\n        sys.stdout = self\n    def __del__(self):\n        sys.stdout = self.stdout\n        self.file.close()\n    def write(self, data):\n        self.file.write(data)\n        self.stdout.write(data)\n</code>\n</pre>\n", "senID": 1}, {"text": ["from: http://mail.python.org/pipermail/python-list/2007-May/442737.html"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://mail.python.org/pipermail/python-list/2007-May/442737.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/python-list/2007-May/442737.html"}]}], [{"text": ["What you really want is logging module from stanard library.", "Create a logger and attach two handlers, one would be writing to a file and another in stodout or stderr."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "logging", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["See  Logging to multiple destinations for details"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Logging to multiple destinations", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/logging.html#logging-to-multiple-destinations"}]}], [{"text": ["Theprintstatement will call thewrite()method of any object you assign to sys.stdout. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Theprintstatement will call thewrite()method of any object you assign to sys.stdout.", "childNum": 2, "tag": "strong", "pos": 0, "childList": [{"text": "print", "tag": "code"}, {"text": "write()", "tag": "code"}]}, {"text": "print", "childNum": 0, "tag": "code", "childList": []}, {"text": "write()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I would spin up a small class to write to two places at once..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import sys\n\nclass Logger(object):\n    def __init__(self):\n        self.terminal = sys.stdout\n        self.log = open(\"log.dat\", \"a\")\n\n    def write(self, message):\n        self.terminal.write(message)\n        self.log.write(message)  \n\nsys.stdout = Logger()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now theprintstatement will both echo to the screen and append to your log file:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Now theprintstatement will both echo to the screen and append to your log file:", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "print", "tag": "code"}]}, {"text": "print", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n # prints \"1 2\" to &lt;stdout&gt; AND log.dat\nprint \"%d %d\" % (1,2)\n</code>\n</pre>\n", "senID": 4}, {"text": ["This is obviously quick-and-dirty.", "Some notes:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "You probably ought to parametize the log filename.", "tag": "none", "senID": 6}, {"text": "You should probably revert sys.stdout to ", "tag": "none", "senID": 7}, {"text": "You may want the ability to write to multiple log files at once, or handle different log levels, etc.", "tag": "none", "senID": 8}]}, {"text": ["These are all straightforward enough that I'm comfortable leaving them as exercises for the reader.", "The key insight here is that print just calls a \"file-like object\" that's assigned to sys.stdout."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "print", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "sys.stdout", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Since you're comfortable spawning external processes from your code, you could use tee itself.", "I don't know of any Unix system calls that do exactly what tee does."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "tee", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tee", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import subprocess, os, sys\n\nsys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)\n\ntee = subprocess.Popen([\"tee\", \"log.txt\"], stdin=subprocess.PIPE)\nos.dup2(tee.stdin.fileno(), sys.stdout.fileno())\nos.dup2(tee.stdin.fileno(), sys.stderr.fileno())\n\nprint \"\\nstdout\"\nprint &gt;&gt;sys.stderr, \"stderr\"\nos.spawnve(\"P_WAIT\", \"/bin/ls\", [\"/bin/ls\"], {})\nos.execve(\"/bin/ls\", [\"/bin/ls\"], os.environ)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could also emulate tee using the multiprocessing package (or use processing if you're using Python 2.5 or earlier)."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "tee", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/dev/library/multiprocessing.html", "text": "multiprocessing", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://pypi.python.org/pypi/processing", "text": "processing", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["(Ah, just re-read your question and see that this doesn't quite apply."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is a sample program that makes uses the python logging module.", "This logging module has been in all versions since 2.3.", "In this sample the logging is configurable by command line options.  "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "python logging module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/logging.html"}]}, {"text": ["In quite mode it will only log to a file, in normal mode it will log to both a file and the console."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import os\nimport sys\nimport logging\nfrom optparse import OptionParser\n\ndef initialize_logging(options):\n    \"\"\" Log information based upon users options\"\"\"\n\n    logger = logging.getLogger('project')\n    formatter = logging.Formatter('%(asctime)s %(levelname)s\\t%(message)s')\n    level = logging.__dict__.get(options.loglevel.upper(),logging.DEBUG)\n    logger.setLevel(level)\n\n    # Output logging information to screen\n    if not options.quiet:\n        hdlr = logging.StreamHandler(sys.stderr)\n        hdlr.setFormatter(formatter)\n        logger.addHandler(hdlr)\n\n    # Output logging information to file\n    logfile = os.path.join(options.logdir, \"project.log\")\n    if options.clean and os.path.isfile(logfile):\n        os.remove(logfile)\n    hdlr2 = logging.FileHandler(logfile)\n    hdlr2.setFormatter(formatter)\n    logger.addHandler(hdlr2)\n\n    return logger\n\ndef main(argv=None):\n    if argv is None:\n        argv = sys.argv[1:]\n\n    # Setup command line options\n    parser = OptionParser(\"usage: %prog [options]\")\n    parser.add_option(\"-l\", \"--logdir\", dest=\"logdir\", default=\".\", help=\"log DIRECTORY (default ./)\")\n    parser.add_option(\"-v\", \"--loglevel\", dest=\"loglevel\", default=\"debug\", help=\"logging level (debug, info, error)\")\n    parser.add_option(\"-q\", \"--quiet\", action=\"store_true\", dest=\"quiet\", help=\"do not log to console\")\n    parser.add_option(\"-c\", \"--clean\", dest=\"clean\", action=\"store_true\", default=False, help=\"remove old log file\")\n\n    # Process command line options\n    (options, args) = parser.parse_args(argv)\n\n    # Setup logger format and output locations\n    logger = initialize_logging(options)\n\n    # Examples\n    logger.error(\"This is an error message.\")\n    logger.info(\"This is an info message.\")\n    logger.debug(\"This is a debug message.\")\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I wrote a tee() implementation in Python that should work for most cases, and it works on Windows also."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "tee()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["http://github.com/ssbarnea/tendo/blob/master/tendo/tee.py"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://github.com/ssbarnea/tendo/blob/master/tendo/tee.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/ssbarnea/tendo/blob/master/tendo/tee.py"}]}, {"text": ["Also, you can use it in combination with logging module from Python if you want."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "logging", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["As described elsewhere, perhaps the best solution is to use the logging module directly:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import logging\n\nlogging.basicConfig(level=logging.DEBUG, filename='mylog.log')\nlogging.info('this should to write to the log file')\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, there are some (rare) occasions where you really want to redirect stdout.", "I had this situation when I was extending django's runserver command which uses print: I didn't want to hack the django source but needed the print statements to go to a file."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "really want", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["This is a way of redirecting stdout and stderr away from the shell using the logging module:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import logging, sys\n\nclass LogFile(object):\n    \"\"\"File-like object to log text using the `logging` module.\"\"\"\n\n    def __init__(self, name=None):\n        self.logger = logging.getLogger(name)\n\n    def write(self, msg, level=logging.INFO):\n        self.logger.log(level, msg)\n\n    def flush(self):\n        for handler in self.logger.handlers:\n            handler.flush()\n\nlogging.basicConfig(level=logging.DEBUG, filename='mylog.log')\n\n# Redirect stdout and stderr\nsys.stdout = LogFile('stdout')\nsys.stderr = LogFile('stderr')\n\nprint 'this should to write to the log file'\n</code>\n</pre>\n", "senID": 4}, {"text": ["You should only use this LogFile implementation if you really cannot use the logging module directly."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["another solution using logging module:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import logging\nimport sys\n\nlog = logging.getLogger('stdxxx')\n\nclass StreamLogger(object):\n\n    def __init__(self, stream, prefix=''):\n        self.stream = stream\n        self.prefix = prefix\n        self.data = ''\n\n    def write(self, data):\n        self.stream.write(data)\n        self.stream.flush()\n\n        self.data += data\n        tmp = str(self.data)\n        if '\\x0a' in tmp or '\\x0d' in tmp:\n            tmp = tmp.rstrip('\\x0a\\x0d')\n            log.info('%s%s' % (self.prefix, tmp))\n            self.data = ''\n\n\nlogging.basicConfig(level=logging.INFO,\n                    filename='text.log',\n                    filemode='a')\n\nsys.stdout = StreamLogger(sys.stdout, '[stdout] ')\n\nprint 'test for stdout'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I'm writing a script to run cmd-line scripts.", "( Because in some cases, there just is no viable substitute for a Linux command -- such as the case of rsync."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What I really wanted was to use the default python logging mechanism in every case where it was possible to do so, but to still capture any error when something went wrong that was unanticipated."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This code seems to do the trick.", "It may not be particularly elegant or efficient ( although it doesn't use string+=string, so at least it doesn't have that particular potential bottle-\nneck ).", "I'm posting it in case it gives someone else any useful ideas."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import logging\nimport os, sys\nimport datetime\n\n# Get name of module, use as application name\ntry:\n  ME=os.path.split(__file__)[-1].split('.')[0]\nexcept:\n  ME='pyExec_'\n\nLOG_IDENTIFIER=\"uuu___( o O )___uuu \"\nLOG_IDR_LENGTH=len(LOG_IDENTIFIER)\n\nclass PyExec(object):\n\n  # Use this to capture all possible error / output to log\n  class SuperTee(object):\n      # Original reference: http://mail.python.org/pipermail/python-list/2007-May/442737.html\n      def __init__(self, name, mode):\n          self.fl = open(name, mode)\n          self.fl.write('\\n')\n          self.stdout = sys.stdout\n          self.stdout.write('\\n')\n          self.stderr = sys.stderr\n\n          sys.stdout = self\n          sys.stderr = self\n\n      def __del__(self):\n          self.fl.write('\\n')\n          self.fl.flush()\n          sys.stderr = self.stderr\n          sys.stdout = self.stdout\n          self.fl.close()\n\n      def write(self, data):\n          # If the data to write includes the log identifier prefix, then it is already formatted\n          if data[0:LOG_IDR_LENGTH]==LOG_IDENTIFIER:\n            self.fl.write(\"%s\\n\" % data[LOG_IDR_LENGTH:])\n            self.stdout.write(data[LOG_IDR_LENGTH:])\n\n          # Otherwise, we can give it a timestamp\n          else:\n\n            timestamp=str(datetime.datetime.now())\n            if 'Traceback' == data[0:9]:\n              data='%s: %s' % (timestamp, data)\n              self.fl.write(data)\n            else:\n              self.fl.write(data)\n\n            self.stdout.write(data)\n\n\n  def __init__(self, aName, aCmd, logFileName='', outFileName=''):\n\n    # Using name for 'logger' (context?), which is separate from the module or the function\n    baseFormatter=logging.Formatter(\"%(asctime)s \\t %(levelname)s \\t %(name)s:%(module)s:%(lineno)d \\t %(message)s\")\n    errorFormatter=logging.Formatter(LOG_IDENTIFIER + \"%(asctime)s \\t %(levelname)s \\t %(name)s:%(module)s:%(lineno)d \\t %(message)s\")\n\n    if logFileName:\n      # open passed filename as append\n      fl=logging.FileHandler(\"%s.log\" % aName)\n    else:\n      # otherwise, use log filename as a one-time use file\n      fl=logging.FileHandler(\"%s.log\" % aName, 'w')\n\n    fl.setLevel(logging.DEBUG)\n    fl.setFormatter(baseFormatter)\n\n    # This will capture stdout and CRITICAL and beyond errors\n\n    if outFileName:\n      teeFile=PyExec.SuperTee(\"%s_out.log\" % aName)\n    else:\n      teeFile=PyExec.SuperTee(\"%s_out.log\" % aName, 'w')\n\n    fl_out=logging.StreamHandler( teeFile )\n    fl_out.setLevel(logging.CRITICAL)\n    fl_out.setFormatter(errorFormatter)\n\n    # Set up logging\n    self.log=logging.getLogger('pyExec_main')\n    log=self.log\n\n    log.addHandler(fl)\n    log.addHandler(fl_out)\n\n    print \"Test print statement.\"\n\n    log.setLevel(logging.DEBUG)\n\n    log.info(\"Starting %s\", ME)\n    log.critical(\"Critical.\")\n\n    # Caught exception\n    try:\n      raise Exception('Exception test.')\n    except Exception,e:\n      log.exception(str(e))\n\n    # Uncaught exception\n    a=2/0\n\n\nPyExec('test_pyExec',None)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Obviously, if you're not as subject to whimsy as I am, replace LOG_IDENTIFIER with another string that you're not like to ever see someone write to a log."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["None of the answers above really seems to answer the problem posed.", "I know this is an old thread, but I think this problem is a lot simpler than everyone is making it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class tee_err(object):\n\n def __init__(self):\n    self.errout = sys.stderr\n\n    sys.stderr = self\n\n    self.log = 'logfile.log'\n    log = open(self.log,'w')\n    log.close()\n\n def write(self, line):\n\n    log = open(self.log,'a')\n    log.write(line)\n    log.close()   \n\n    self.errout.write(line)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now this will repeat everything to the normal sys.stderr handler and your file.", "Create another class tee_out for sys.stdout."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "tee_out", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "sys.stdout", "childNum": 0, "tag": "code", "childList": []}]}]]