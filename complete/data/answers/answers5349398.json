[[{"text": ["You can't pickle classes, even if you solve your \"... not found as ...\" problem it still won't work (as in save the name of the class, without the content, then fail to unpickle because the class doesn't exist after your program restarts)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You will have to manually serialize dict and reconstruct the class from it later on, which depending on what it contains will be fun too: function objects can't be serialized by anything, you have to extract their code objects, serialize them with marshal then recreate them when loading."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "marshal", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["How about creating a Factory class with methods to create, pickle, and unpickle dynamically created type objects?", "The following is a rough start.", "To use, simply replace calls to pickle.dump(type, fh) with TypeFactory.pickle(type, fh), and replace calls to pickle.load(fh) with TypeFactory.unpickle(fh)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import pickle\n\nclass TypeFactory(object):\n    def __init__(self):\n        pass\n    @staticmethod\n    def create_type(name='DynamicType', dict={}):\n        return type(name, (object,), dict)\n    @staticmethod\n    def pickle(t, fh):\n        dict = t.__dict__.copy()\n        name = t.__name__\n        for key in dict.keys():\n            if key.startswith('__') and key.endswith('__'):\n                del dict[key]\n        pickle.dump((name, dict), fh)\n    @classmethod\n    def unpickle(cls, fh):\n        name, dict = pickle.load(fh)\n        return cls.create_type(name, dict)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In python, classes are objects too.", "So, you should be able to pickle the class objects, and save them to a file.", "You can then unpickle them later."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Maybe you could try json module (note: I haven't used it myself so I don't know if it'll solve your problem, it's just a suggestion):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\"The json module provides an API similar to pickle for converting in-memory Python objects to a serialized representation known as JavaScript Object Notation (JSON).", "Unlike pickle, JSON has the benefit of having implementations in many languages (especially JavaScript), making it suitable for inter-application communication.", "JSON is probably most widely used for communicating between the web server and client in an AJAX application, but is not limited to that problem domain.(...", ")\""], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["JSON Module at 'Python Module of The Week' website"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "JSON Module at 'Python Module of The Week' website", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.doughellmann.com/PyMOTW/json/"}]}], [{"text": ["Saving the dict to JSON seems like it would be easiest, however it looks like pickle or shelve could be leveraged to create some kind of dynamic class serialization."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A quick search on SO reveals this helpful post: getting the class path or name space of a class in python even if it is nested"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "getting the class path or name space of a class in python even if it is nested", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4468253/getting-the-class-path-or-name-space-of-a-class-in-python-even-if-it-is-nested"}]}], [{"text": ["You can 'inject' the new class in the global namespace before pickling to avoid the pickle error:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import pickle\n\nclass TestClass(object):\n    def __init__(self):\n        self.a = 1     # Initial instance attributes\n        self.b = 2\n        self.c = 3\n\nmy_classname = \"NewTestClass\"\nobj = type(my_classname, (TestClass,), {})()\nobj.d = 4                # Extra attributes\nprint obj.a, obj.b, obj.c, obj.d\nprint obj.__class__\n\nglobals()[my_classname] = obj.__class__     # Inject the new class in the global namespace\n\nobj2 = pickle.dumps(obj)\nobj = None           # Free original obj instance\nobj = pickle.loads(obj2)\nprint obj.a, obj.b, obj.c, obj.d   # 1,2,3,4\n</code>\n</pre>\n", "senID": 1}], [{"text": ["There is no automatic solution for your question.", "All \"default\" mechanisms, like pickle, just saves the instance data (including metadata like the type).", "What you want to do, is to save the class too.", "You might be able to build something using byte code magic, but it's probably easier to implement your own serialization code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]