[[{"code": "<pre>\n<code>\n itertools.product(*A)\n</code>\n</pre>\n", "senID": 0}, {"text": ["For more details check the python tutorial"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "python tutorial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/doc/current/tutorial/controlflow.html#arbitrary-argument-lists"}]}], [{"text": ["This works for your example, if there is only one level of nested lists (no lists of lists of lists):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n itertools.product(*A)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["you can probably call itertools.product like so:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n itertools.product(*A) # where A is your list of lists of tuples\n</code>\n</pre>\n", "senID": 1}, {"text": ["This way it expands your list's elements into arguments for the function you are calling."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["This is not exactly one step, but this would do what you want if for some reason you don't want to use the itertools solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def crossprod(listoflists):\n    if len(listoflists) == 1:\n        return listoflists\n    else:\n        result = []\n        remaining_product = prod(listoflists[1:])\n        for outertupe in listoflists[0]:\n            for innercombo in remaining_product[0]:\n                newcombo = [outertupe]\n                newcombo.append(innercombo)\n                result.append(newcombo)\n        return result\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def flatten(A)\n    answer = []\n    for i in A:\n        if type(i) == list:\n            ans.extend(i)\n        else:\n            ans.append(i)\n    return ans\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Late to the party but ..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I'm new to python and come from a lisp background.", "This is what I came up with (check out the var names for lulz):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def flatten(lst):\n    if lst:\n        car,*cdr=lst\n        if isinstance(car,(list)):\n            if cdr: return flatten(car) + flatten(cdr)\n            return flatten(car)\n        if cdr: return [car] + flatten(cdr)\n        return [car]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Seems to work.", "Test:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n A = [ [(1,2,3),(4,5,6)], [(7,8,9),(8,7,6),(5,4,3)],[(2,1,0),(1,3,5)] ]\n\nflatten(A)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Result:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n [(1, 2, 3), (4, 5, 6), (7, 8, 9), (8, 7, 6), (5, 4, 3), (2, 1, 0), (1, 3, 5)]\n</code>\n</pre>\n", "senID": 6}, {"text": ["Note: the line car,*cdr=lst only works in Python 3.0"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "car,*cdr=lst", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]