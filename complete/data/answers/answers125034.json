[[{"text": ["You should use the @property decorator."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@property", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class a(object):\n...     def __init__(self, x):\n...             self.x = x\n...     @property\n...     def xval(self):\n...             return self.x\n... \n&gt;&gt;&gt; b = a(5)\n&gt;&gt;&gt; b.xval\n5\n&gt;&gt;&gt; b.xval = 6\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: can't set attribute\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n class C(object):\n\n    def __init__(self):\n\n        self.fullaccess = 0\n        self.__readonly = 22 # almost invisible to outside code...\n\n    # define a publicly visible, read-only version of '__readonly':\n    readonly = property(lambda self: self.__readonly)\n\n    def inc_readonly( self ):\n        self.__readonly += 1\n\nc=C()\n\n# prove regular attribute is RW...\nprint \"c.fullaccess = %s\" % c.fullaccess\nc.fullaccess = 1234\nprint \"c.fullaccess = %s\" % c.fullaccess\n\n# prove 'readonly' is a read-only attribute\nprint \"c.readonly = %s\" % c.readonly\ntry:\n    c.readonly = 3\nexcept AttributeError:\n    print \"Can't change c.readonly\"\nprint \"c.readonly = %s\" % c.readonly\n\n# change 'readonly' indirectly...\nc.inc_readonly()\nprint \"c.readonly = %s\" % c.readonly\n</code>\n</pre>\n", "senID": 0}, {"text": ["This outputs:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["$ python ./p.py\nc.fullaccess = 0\nc.fullaccess = 1234\nc.readonly = 22\nCan't change c.readonly\nc.readonly = 22\nc.readonly = 23\n\nMy fingers itch to be able to say"], "childNum": 8, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"code": "<pre>\n<code>\n @readonly\n    self.readonly = 22\n</code>\n</pre>\n", "senID": 3}, {"text": ["i.e., use a decorator on an attribute.", "It would be so clean..."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Here's how:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class whatever(object):\n  def __init__(self, a, b, c, ...):\n    self.__foobar = 1\n    self.__blahblah = 2\n\n  foobar = property(lambda self: self.__foobar)\n  blahblah = property(lambda self: self.__blahblah)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Assuming foobar and blahblah are the attributes you want to be read-only.", ")  Prepending two underscores to an attribute name effectively hides it from outside the class, so the internal versions won't be accessible from the outside.", "This only works for new-style classes inheriting from object since it depends on property."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "foobar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "blahblah", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "two", "childNum": 0, "tag": "b", "pos": 1, "childList": []}, {"text": "only works for new-style classes inheriting from object", "childNum": 0, "tag": "b", "pos": 2, "childList": []}, {"text": "property", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["On the other hand... this is a pretty silly thing to do.", "Keeping variables private seems to be an obsession that comes from C++ and Java.", "Your users should use the public interface to your class because it's well-designed, not because you force them to."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Edit: Looks like Kevin already posted a similar version."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["There is no real way to do this.", "There are ways to make it more 'difficult', but there's no concept of completely hidden, inaccessible class attributes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If the person using your class can't be trusted to follow the API docs, then that's their own problem.", "Protecting people from doing stupid stuff just means that they will do far more elaborate, complicated, and damaging stupid stuff to try to do whatever they shouldn't have been doing in the first place."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You could use a metaclass that auto-wraps methods (or class attributes) that follow a naming convention into properties (shamelessly taken from Unifying Types and Classes in Python 2.2:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Unifying Types and Classes in Python 2.2", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/download/releases/2.2/descrintro/#metaclasses"}]}, {"code": "<pre>\n<code>\n class autoprop(type):\n    def __init__(cls, name, bases, dict):\n        super(autoprop, cls).__init__(name, bases, dict)\n        props = {}\n        for name in dict.keys():\n            if name.startswith(\"_get_\") or name.startswith(\"_set_\"):\n                props[name[5:]] = 1\n        for name in props.keys():\n            fget = getattr(cls, \"_get_%s\" % name, None)\n            fset = getattr(cls, \"_set_%s\" % name, None)\n            setattr(cls, name, property(fget, fset))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This allows you to use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class A:\n    __metaclass__ = autosuprop\n    def _readonly(self):\n        return __x\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I am aware that William Keller is the cleanest solution by far.. but here's something I came up with.. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class readonly(object):\n    def __init__(self, attribute_name):\n        self.attribute_name = attribute_name\n\n    def __get__(self, instance, instance_type):\n        if instance != None:\n            return getattr(instance, self.attribute_name)\n        else:\n            raise AttributeError(\"class %s has no attribute %s\" % \n                                 (instance_type.__name__, self.attribute_name))\n\n    def __set__(self, instance, value):\n        raise AttributeError(\"attribute %s is readonly\" % \n                              self.attribute_name)\n</code>\n</pre>\n", "senID": 1}, {"text": ["And here's the usage example"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class a(object):\n    def __init__(self, x):\n        self.x = x\n    xval = readonly(\"x\")\n</code>\n</pre>\n", "senID": 3}, {"text": ["Unfortunately this solution can't handle private variables (__ named variables)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]