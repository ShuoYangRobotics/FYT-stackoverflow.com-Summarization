[[{"text": ["What does the input line that gives you trouble look like?", "I'd try printing that out.", "I suspect your CPU is pegged while this is running. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Nested regexps, like you have can have VERY bad performance when they don't match quickly."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "VERY", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.regular-expressions.info/catastrophic.html"}]}, {"code": "<pre>\n<code>\n ((\\w+).?)+:\n</code>\n</pre>\n", "senID": 2}, {"text": ["Imagine a string that doesn't have the : in it but is fairly long.", "You'll end up in a world of backtracking as the regexp tries EVERY combination of ways to separate word characters between \\w and .", "and THEN tries to group them in every way possible.", "If you can be more specific in your pattern it'll pay off big time. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Your problem is definitely the part @paulrubel pointed out:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n ((\\w+).?)+:\\d+\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now that you've added sample data, it's obvious that the .", "is supposed to match a literal dot, which means you should have escaped it (\\.).", "Also, you don't need the inner set of parentheses, and the outer set should be non-capturing, but it's the basic structure that's killing you; there are too many arrangements of word characters and dots it has to try before giving up.", "The other lines all fail before that part of the regex is attempted, which is why you don't have any problem with them."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": ".", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\.", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["When I try it in RegexBuddy, your regex matches the good line in 186 steps, and gives up trying on line 57802 after 1,000,000 steps.", "When I escape the dot, the good line only takes 90 steps to match, but it still times out on line 57802.", "But now I know that part of the regex can only match word characters and dots.", "Once it has consumed all of those it can, the next bit has to match :\\d+; if it doesn't, I know there's no point trying other arrangements.", "I can use an atomic group to tell it not to bother:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": ":\\d+", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n (?&gt;(?:\\w+\\.?)+):\\d+\n</code>\n</pre>\n", "senID": 4}, {"text": ["With that change, the good line matches in 83 steps, and line 57802 only takes 66 steps to report failure.", "But it's not always feasible to use atomic groups, so you should try to make your regex conform to the actual structure of the text it's matching.", "In this case you're matching what looks like a Java class name (some word characters, followed by zero or more instances of (a dot and some more word characters)) followed by a colon and and a line number:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n \\w+(?:\\.\\w+)*:\\d+\n</code>\n</pre>\n", "senID": 6}, {"text": ["When I plug that into the regex, it matches the good line in 80 steps, and rejects line 57802 in 67 steps--the atomic group isn't even needed."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["you compiled your regex but never use it?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n lookup = re.search(match,line)\n</code>\n</pre>\n", "senID": 1}, {"text": ["should be"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n lookup = match.search(line)\n</code>\n</pre>\n", "senID": 3}, {"text": ["and you should use os.path.join()"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "os.path.join()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n infile = os.path.join(\"C:\\\\\",\"Python26\",\"Scripts\",\"stdout.log\")\n</code>\n</pre>\n", "senID": 5}, {"text": ["Update:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Your regular expression can be simpler.Just check for the date time stamp.", "Or else, don't use regular expression at all.", "Say your date and time starts at beginning of line"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n for line in open(\"stdout.log\"):\n    s = line.split()\n    D,T=s[0],s[1]\n    # use the time module and strptime to check valid date/time\n    # or you can split \"-\" on D and T and do manual check using &gt; or &lt; and math\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Your pattern contains the fixed string SEARCH_ and a bunch of complicated expressions (including captures) that are really going to hammer the regex engine.. but you don't do anything with the captured text so all you want to know 'is does it match?", "'  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It may be simpler and quicker to just search for the fixed pattern on each line. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n if '_SEARCH:' in line:\n    print line\n    count += 1\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Try using pdb.", "If you put pdb.set_trace() in your heartbeat shortly before it stops, you can look at the specific line it's stopping on and see what each of your lines of code does with that line."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "pdb", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/pdb.html"}, {"text": "pdb.set_trace()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Edit: An example of pdb use:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import pdb\nfor i in range(50):\n    print i\n    if i == 12:\n        pdb.set_trace()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Run that script, and you'll get something like the following:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n 0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n&gt; &lt;stdin&gt;(1)&lt;module&gt;()\n(Pdb)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now you can evaluate Python expressions from the context of i=12."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n (Pdb) print i\n12\n</code>\n</pre>\n", "senID": 6}, {"text": ["Use that, but put the pdb.set_trace() in your loop after you increment heartbeat, if heartbeat == 57802.", "Then you can print out line with p line, the result of your regex search with p match.search(line), etc."], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "pdb.set_trace()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "heartbeat == 57802", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "p line", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "p match.search(line)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["It might be a memory issue anyway.", "With huge files it's probably better to use the fileinput module instead like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "fileinput", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import fileinput\nfor line in fileinput.input([infile]):\n    lookup = re.search(match, line)\n     # etc.\n</code>\n</pre>\n", "senID": 1}]]