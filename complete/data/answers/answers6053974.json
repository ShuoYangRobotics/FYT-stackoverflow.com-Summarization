[[{"text": ["You can throw your ranges into tuples and put the tuples in a list.", "Then use any() to help you find if your value is within these ranges."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "any()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n ranges = [(1000,2429), (2545,2575), (2640,2686), (2890, 2890)]\nif any(lower &lt;= postcode &lt;= upper for (lower, upper) in ranges):\n    print('M')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Probably the fastest will be to check the membership of a set"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import chain\n&gt;&gt;&gt; ranges = ((1000, 2429), (2545, 2575), (2640, 2686), (2890, 2890))\n&gt;&gt;&gt; postcodes = set(chain(*(xrange(start, end+1) for start, end in ranges)))\n&gt;&gt;&gt; 1000 in postcodes\nTrue\n&gt;&gt;&gt; 2500 in postcodes\nFalse\n</code>\n</pre>\n", "senID": 1}, {"text": ["But it does use more memory this way, and building the set takes time, so it's only better if you are building the set once to check against many postcodes in a loop"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: seems that different ranges need to map to different letters"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import chain\n&gt;&gt;&gt; ranges = {'M':((1000,2429), (2545,2575), (2640,2686), (2890, 2890)),\n              # more ranges\n              }\n&gt;&gt;&gt; postcodemap = dict((k,v) for v in ranges for k in chain(*imap(xrange, *zip(*ranges[v]))))    \n&gt;&gt;&gt; print postcodemap.get(1000)\nM\n&gt;&gt;&gt; print postcodemap.get(2500)\nNone\n</code>\n</pre>\n", "senID": 4}], [{"text": ["you only have to solve for edge cases and for one number between edge cases when doing inequalities."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["e.g.", "if you do the following tests on TEN:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "TEN", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["10 &lt; 20, 10 &lt; 15, 10 > 8, 10 >12"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "10 &lt; 20, 10 &lt; 15, 10 > 8, 10 >12", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["It will give True True True False"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["but note that the closest numbers to 10 are 8 and 12"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "the closest numbers to 10 are 8 and 12", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["this means that 9,10,11 will give the answers that ten did.. if you don't have too many initial range numbers and they are sparse then this well help.", "Otherwise you will need to  see if your inequalities are transitive and use a range tree or something."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "9,10,11", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["So what you can do is sort all of your boundaries into intervals.", "e.g.", "if your inequalities had the numbers 12, 50, 192,999"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["you would get the following intervals that ALL have the same answer:\nless than 12, 12, 13-49, 50, 51-191, 192, 193-998, 999, 999+"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["as you can see from these intervals we only need to solve for 9 cases and we can then quickly solve for anything."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Here is an example of how I might carry it out for solving for a new number x using these pre-calculated results:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["a) is x a boundary?", "(is it in the set)\nif yes, then return the answer you found for that boundary previously.", "otherwise use case b)"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["b) find the maximum boundary number that is smaller than x, call it maxS\nfind the minimum boundary number that is larger than x call it minL.", "Now just return any previously found solution that was between maxS and minL."], "childNum": 4, "tag": "p", "senID": 11, "childList": [{"text": "maxS", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "maxS", "tag": "em"}]}, {"text": "maxS", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "minL", "childNum": 1, "tag": "strong", "childList": [{"text": "minL", "tag": "em"}]}, {"text": "minL", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["see Python binary search-like function to find first number in sorted list greater than a specific value\nfor finding closest numbers.", "bisect module will help (import it in your code)\nThis will help finding maxS and minL"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "Python binary search-like function to find first number in sorted list greater than a specific value", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3556496/python-binary-search-like-function-to-find-first-number-in-sorted-list-greater-th"}]}, {"text": ["You can use bisect and the function i have included in my sample code:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n def find_ge(a, key):\n    '''Find smallest item greater-than or equal to key.\n    Raise ValueError if no such item exists.\n    If multiple keys are equal, return the leftmost.\n\n    '''\n    i = bisect_left(a, key)\n    if i == len(a):\n        raise ValueError('No item found with key at or above: %r' % (key,))\n    return a[i]\n\n\n\n\nranges=[(1000,2429), (2545,2575), (2640,2686), (2890, 2890)]\nnumbers=[]\nfor pair in ranges:\n        numbers+=list(pair)\n\nnumbers+=[-999999,999999] #ensure nothing goes outside the range\nnumbers.sort()\nedges=set(numbers)\n\nedgepairs={}\n\nfor i in range(len(numbers)-1):\n        edgepairs[(numbers[i],numbers[i+1])]=(numbers[i+1]-numbers[i])//2\n\n\n\ndef slow_solver(x):\n        return #your answer for postcode x\n\n\nlistedges=list(edges)\nedgeanswers=dict(zip(listedges,map(solver,listedges)))\nedgepairsanswers=dict(zip(edgepairs.keys(),map(solver,edgepairs.values())))\n\n#now we are ready for fast solving:\ndef fast_solver(x):\n        if x in edges:\n                return edgeanswers[x]\n        else:\n                #find minL and maxS using find_ge and your own similar find_le\n                return edgepairsanswers[(minL,maxS)]\n</code>\n</pre>\n", "senID": 14}], [{"text": ["Warning - This is probably premature optimisation.", "For a large list of ranges it might be worthwhile, but probably not in your case.", "Also, although dictionary/set solutions will use more memory, they are still probably a better choice."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Warning", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You could do a binary-search into your range end-points.", "This would be easy if all ranges are non-overlapping, but could still be done (with some tweaks) for overlapping ranges."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Do a find-highest-match-less-than binary search.", "This is the same as a find-lowest-match-greater-than-or-equal (lower bound) binary search, except that you subtract one from the result."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Use half-open items in your list of end points - that is if your range is 1000..2429 inclusive, use the values 1000 and 2430.", "If you get an end-point and a start-point with the same value (two ranges touching, so there is no gap between) exclude the end-point for the lower range from your list."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If you find a start-of-range end-point, your goal value is within that range.", "If you find an end-of-range end-point, your goal value isn't in any range."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The binary search algorithm is roughly (don't expect this to run without editing)..."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n while upperbound &gt; lowerbound :\n  testpos = lowerbound + ((upperbound-lowerbound) // 2)\n\n  if item [testpos] &gt; goal :\n    #  new best-so-far\n    upperbound = testpos\n  else :\n    lowerbound = testpos + 1\n</code>\n</pre>\n", "senID": 6}, {"text": ["Note - the \"//\" division operator is necessary for integer division in Python 3.", "In Python 2, the normal \"/\" will work, but it's best to be ready for Python 3."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Note", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["At the end, both upperbound and lowerbound point to the found item - but for the \"upper bound\" search.", "Subtract one to get the required search result.", "If that gives -1, there is no matching range."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["There's probably a binary search routine in the library that does the upper-bound search, so prefer that to this if so.", "To get a better understanding of how the binary search works, see How can I better understand the one-comparison-per-iteration binary search?", "- no, I'm not above begging for upvotes ;-)"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "How can I better understand the one-comparison-per-iteration binary search?", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4948162/how-can-i-better-understand-the-one-comparison-per-iteration-binary-search"}]}], [{"text": ["Your benchmarks seem to include setting up the data structure from scratch each for each call.", "Why?", "Have you considered a mapping from postcode to region code, loaded from file ONCE at module import time?", "These look suspiciously like Australian postcodes.", "If so, there aren't very many of them. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Python has a range(a, b) function which means the range from (and including) a, to (but excluding) b.", "You can make a list of these ranges and check to see if a number is in any of them.", "It may be more efficient to use xrange(a, b) which has the same meaning but doesn't actually make a list in memory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n list_of_ranges = []\nlist_of_ranges.append(xrange(1000, 2430))\nlist_of_ranges.append(xrange(2545, 2576))\nfor x in [999, 1000, 2429, 2430, 2544, 2545]:\n    result = False\n    for r in list_of_ranges:\n        if x in r:\n            result = True\n            break\n    print x, result\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here is a fast and short solution, using numpy:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy as np\nlows = np.array([1, 10, 100]) # the lower bounds\nups = np.array([3, 15, 130]) # the upper bounds\n\ndef in_range(x):\n    return np.any((lows &lt;= x) &amp; (x &lt;= ups))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now for instance"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n in_range(2) # True\nin_range(23) # False\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Have you really made benchmarks?", "Does the performance of this piece of code influence the performance of the overall application?", "So benchmark first!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But you can also use a dict e.g.", "for storing all keys of the \"M\" ranges:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n mhash = {1000: true, 1001: true,..., 2429: true,...}\n\nif postcode in mhash:\n   print 'M'\n</code>\n</pre>\n", "senID": 2}, {"text": ["Of course: the hashes require more memory but access time is O(1)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]