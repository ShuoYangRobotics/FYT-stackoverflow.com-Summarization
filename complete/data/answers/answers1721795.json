[[{"text": ["you can do something like this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def add_dry_foo(d, namespace, fooName):\n    d[fooName] = namespace[fooName]\n\nfoo = 'oh-foo'\nd = {}\nadd_dry_foo(d, locals(), 'foo')\nprint d\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n name = 'foo'\nd[name] = vars[name]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I don't see the difference between your d and e cases: both set 'foo' to the value of foo.  "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "d", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "e", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It gets trickier if you want to bury this in a function:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def add_variable(d, name):\n    # blah\n</code>\n</pre>\n", "senID": 4}, {"text": ["because then it has to use inspect to start poking around in frames."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "inspect", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This sounds like a larger problem that might have a nicer solution if you wanted to describe it to us.", "For example, if the problem is that you don't care just about foo, but in fact, a whole slew of local variables, then maybe you want something like:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n d.update(locals())\n</code>\n</pre>\n", "senID": 7}, {"text": ["which will copy the names and value of all the local variables into d."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "d", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Actutally using foo twice is remarkably common in python programs.", "It is used extensively for passing on arguments eg"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def f(foo, bar):\n    g(foo=foo)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which is a specialised case of the dictionary manipulations in your question."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I don't think there is a way of avoiding it without resorting to magic, so I think you'll have to live with it."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "magic", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Magic%5F%28programming%29#Referential%5Fopacity"}]}], [{"text": ["To add all the local variables to a dict you can do:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d.update(locals())\n</code>\n</pre>\n", "senID": 1}, {"text": ["The same works for function calls:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n func(**locals())\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that depending on where you are locals() might of course contain stuff that should not end up in the dict.", "So you could implement a filter function:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "locals()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def filtered_update(d, namespace):\n    for key, value in namespace.items():\n        if not key.startswith('__'):\n            d[key] = value\n\nfiltered_update(d, locals())\n</code>\n</pre>\n", "senID": 5}, {"text": ["Of course the Python philosophy is \"explicit is better than implicit\", so generally I would walk the extra mile and do this kind of stuff by hand (otherwise you have to be careful about what goes on in your local namespace)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["If you don't want to pass all of locals() (which may be a security risk if you don't fully trust the function you're sending the data too), a one-line answer could be this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "locals()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["dict([ (var, locals()[var]) for var in ['foo', 'bar'] ])"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "dict([ (var, locals()[var]) for var in ['foo', 'bar'] ])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["or in Python 3.0 this would become possible:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["{ var: locals()[var] for var in ['foo', 'bar'] }"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "{ var: locals()[var] for var in ['foo', 'bar'] }", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You could use eval, although I'm not sure that I'd recommend it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; d = dict()\n&gt;&gt;&gt; foo = 'wibble'\n&gt;&gt;&gt; def add(d, name):\n        d[name] = eval(name)\n\n\n&gt;&gt;&gt; add(d, 'foo')\n&gt;&gt;&gt; d\n{'foo': 'wibble'}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit:\nI should point out why I don't recommend \"eval\".", "What happens if you do something like this?", "(from: http://mail.python.org/pipermail/tutor/2005-November/042854.html)"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "http://mail.python.org/pipermail/tutor/2005-November/042854.html", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/tutor/2005-November/042854.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = \"(lambda loop: loop(loop)) (lambda self: self(self))\"\n&gt;&gt;&gt; add(d, s)\n\nTraceback (most recent call last):\n  File \"&lt;pyshell#54&gt;\", line 1, in &lt;module&gt;\n    add(d, s)\n  File \"&lt;pyshell#43&gt;\", line 2, in add\n    d[name] = eval(name)\n  File \"&lt;string&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;string&gt;\", line 1, in &lt;lambda&gt;\n  File \"&lt;string&gt;\", line 1, in &lt;lambda&gt;\n  ...\n  File \"&lt;string&gt;\", line 1, in &lt;lambda&gt;\nRuntimeError: maximum recursion depth exceeded\n</code>\n</pre>\n", "senID": 3}], [{"text": ["It seems to me what you are talking about is an \nenhancement to parameter passing functionality:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def func(*vars):\n</code>\n</pre>\n", "senID": 1}, {"text": ["provides a tuple of ordered values without keys"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def func(**vars):\n</code>\n</pre>\n", "senID": 3}, {"text": ["provides a dict of key value pairs, that \n  MUST be passed as key=value pairs."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "key=value", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def func(***vars):\n</code>\n</pre>\n", "senID": 5}, {"text": ["WOULD PROVIDE a dict of key value pairs, \n  passed either explicitly as key=value, \n  or implicitly as key (a variable,\n  literals would cause error without key=)"], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "key=value", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "key", "childNum": 0, "tag": "strong", "childList": []}, {"text": "key=", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["SO:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n (x1,x2,x3) = (1,2,3)\ndef myfunc(***vars):\n  retrun vars\nmyfunc(x1,x2,x3)\n&gt;&gt;&gt; {'x1':1,'x2':2,'x3':3}\n</code>\n</pre>\n", "senID": 8}, {"text": ["But of course, this is just wishful thinking..."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}]]