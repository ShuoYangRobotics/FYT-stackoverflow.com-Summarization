[[{"text": ["Steps 2 &amp; 3 can be done in one step:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n manage.py reset appname\n</code>\n</pre>\n", "senID": 1}, {"text": ["Step 4 is most easily managed, from my understanding, by using fixtures"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "fixtures", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.djangoproject.com/documentation/models/fixtures/"}]}], [{"text": ["This is a job for Django's fixtures.", "They are convenient because they are database independent and the test harness (and manage.py) have built-in support for them."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To use them:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Now, after your syncdb stage, you just type:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n python manage.py loaddata foo.json\n</code>\n</pre>\n", "senID": 3}, {"text": ["And your data will be re-created."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["If you want them in a test case:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class FooTests(TestCase):\n    fixtures = ['foo.json']\n</code>\n</pre>\n", "senID": 6}, {"text": ["Note that you will have to recreate or manually update your fixtures if your schema changes drastically."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["You can read more about fixtures in the django docs for Fixture Loading"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Fixture Loading", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev/topics/testing/#fixture-loading"}]}], [{"text": ["Here's what we do."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The point is that drop and recreate isn't always appropriate.", "It's sometimes helpful to move data form the old model to the new model without rebuilding from scratch."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["South is the coolest."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Though good ol' reset works best when data doesn't matter. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://south.aeracode.org/"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://south.aeracode.org/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://south.aeracode.org/"}]}], [{"text": ["To add to Matthew's response, I often also use custom SQL to provide initial data as documented here."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev/howto/initial-data/#providing-initial-sql-data"}]}, {"text": ["Django just looks for files in &lt;app&gt;/sql/&lt;modelname&gt;.sql and runs them after creating tables during syncdb or sqlreset.", "I use custom SQL when I need to do something like populate my Django tables from other non-Django database tables."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "&lt;app&gt;/sql/&lt;modelname&gt;.sql", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "syncdb", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sqlreset", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Personally my development db is for a project I'm working on right now is rather large, so I use dmigrations to create db migration scripts to modify the db (rather than wiping out the db everytime like I did in the beginning)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dmigrations", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/dmigrations/"}]}, {"text": ["Edit: Actually, I'm using South now :-)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]