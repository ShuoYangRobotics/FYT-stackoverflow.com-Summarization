[[{"text": ["Here is a version that works on any iterable and returns a generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; inp = (\"hello\", \"my\", \"friend\")\n&gt;&gt;&gt; def apply_nth(fn, n, iterable):\n...    return (fn(x) if i==n else x for (i,x) in enumerate(iterable))\n... \n&gt;&gt;&gt; tuple(apply_nth(str.upper, 1, inp))\n('hello', 'MY', 'friend')\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can extend this so that instead of one position you can give it a list of positions:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def apply_at(fn, pos_lst, iterable):\n...    pos_lst = set(pos_lst)\n...    return (fn(x) if i in pos_lst else x for (i,x) in enumerate(iterable))\n... \n&gt;&gt;&gt; ''.join(apply_at(str.upper, [2,4,6,8], \"abcdefghijklmno\"))\n'abCdEfGhIjklmno'\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; inp = \"hello\", \"my\", \"friend\"\n&gt;&gt;&gt; index = 1\n&gt;&gt;&gt; inp[:index] + ( str.upper(inp[index]),) + inp[index + 1:]\n('hello', 'MY', 'friend')\n</code>\n</pre>\n", "senID": 0}, {"text": ["Seems simple, the only thing you may need to know is that to make a single element tuple, do (elt,)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Maybe some' like this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;inp = (\"hello\", \"my\", \"friend\")\n&gt;&gt;&gt;out =  tuple([i == 1 and x.upper() or x for (x,i) in zip(t,range(len(t)))])\n\n&gt;&gt;&gt; out\n('hello', 'MY', 'friend')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note: rather than (x,i) in zip(t, range(len(t))) I should have thought of using the enumerate function :  (i,x) in enumerate(t)"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "(x,i) in zip(t, range(len(t)))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(i,x) in enumerate(t)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Making it a bit more general:\nRather than hard-coding the 1, we can place it in a variable.", "Also, by using a tuple for that purpose, we can apply the function to elements at multiple indexes."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;inp = (\"hello\", \"my\", \"friend\")\n&gt;&gt;&gt;ix  = (0,2)\n&gt;&gt;&gt;out =  tuple([i in ix and x.upper() or x for (i, x) in enumerate(t)])\n\n&gt;&gt;&gt; out\n('HELLO', 'my', 'FRIEND')\n</code>\n</pre>\n", "senID": 4}, {"text": ["Also, we can \"replace\" the zip()/enumerate() by map(), in something like"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n out = tuple(map(lambda x,i : i == 1 and x.upper() or x, inp, range(len(inp)) ) )\n</code>\n</pre>\n", "senID": 6}, {"text": ["Edit: (addressing comment about specifying the function to apply):\nCould be something as simple as:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; f = str.upper  # or whatever function taking a single argument\n&gt;&gt;&gt; out = tuple(map(lambda x,i : i == 1 and f(x) or x, inp, range(len(inp)) ) )\n</code>\n</pre>\n", "senID": 8}, {"text": ["Since we're talking about applying any function, we should mention the small caveat with the condition and if_true or if_false construct which is not exactly a substitute for the if/else ternary operator found in other languages.", "The limitation is that the function cannot return a value which is equivalent to False (None, 0, 0.0, '' for example).", "A suggestion to avoid this problem, is, with Python 2.5 and up, to use the true if-else ternary operator, as shown in Dave Kirby's answer (note the when_true if condition else when_false syntax of this operator)"], "childNum": 4, "tag": "p", "senID": 9, "childList": [{"text": "any", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "condition and if_true or if_false", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "exactly", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "when_true if condition else when_false", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["I commented in support of your first snippet, but here are a couple other ways for the record:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (lambda (a,b,c): [a,b.upper(),c])(inp)\n</code>\n</pre>\n", "senID": 1}, {"text": ["(Won't work in Python 3.x.", ") And:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [inp[0], inp[1].upper(), inp[1]]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["I don't understand if you want to apply a certain function to every element in the tuple that passes some test, or if you would like it to apply the function to any element present at a certain index of the tuple.", "So I have coded both algorithms:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is the algorithm (coded in Python) that I would use to solve this problem in a functional language like scheme:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This function will identify the element identifiable by id and apply func to it and return a list with that element changed to the output of func.", "It will do this for every element identifiable as id:"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "id", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "func", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "func", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "id", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def doSomethingTo(tup, id):\n    return tuple(doSomethingToHelper(list(tup), id))\n\ndef doSomethingToHelper(L, id):\n    if len(L) == 0:\n        return L\n    elif L[0] == id:\n        return [func(L[0])] + doSomethingToHelper(L[1:], id)\n    else:\n        return [L[0]] + doSomethingToHelper(L[1:], id)\n</code>\n</pre>\n", "senID": 3}, {"text": ["\nThis algorithm will find the element at the index of the tuple and apply func to it, and stick it back into its original index in the tuple"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "func", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def doSomethingAt(tup, i): \n    return tuple(doSomethingAtHelper(list(tup), i, 0))\n\ndef doSomethingAtHelper(L, index, i):\nif len(L) == 0: \n        return L\nelif i == index: \n        return [func(L[0])] + L[1:]\nelse: \n        return [L[0]] + doSomethingAtHelper(L[1:], index, i+1)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["i also like the answer that Dave Kirby gave.", "however, as a public service announcement, i'd like to say that this is not a typical use case for tuples -- these are data structures that originated in Python as a means to move data (parameters, arguments) to and from functions... they were not meant for the programmer to use as general array-like data structures in applications -- this is why lists exist.", "naturally, if you're needing the read-only/immutable feature of tuples, that is a fair argument, but given the OP question, this should've been done with lists instead -- note how there is extra code to either pull the tuple apart and put the resulting one together and/or the need to temporarily convert to a list and back."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]