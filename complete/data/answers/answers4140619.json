[[{"text": ["This will work for your problem:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/perl\nwhile (&lt;DATA&gt;) {\n    my($new, $old) = split;\n    rename(\"$old.jpg\", \"$new.jpg\")\n        || die \"can't rename \"$old.jpg\", \"$new.jpg\": $!\";\n}\n__END__\nSH103239 1500000704\nSH103240 1500000705\nSH103241 1500000711\nSH103242 1500000712\nSH103243 1500000714\nSH103244 1500000744\nSH103245 1500000745\nSH103252 1500000802\nSH103253 1500000803\nSH103254 1500000804\n</code>\n</pre>\n", "senID": 1}, {"text": ["Switch to ARGV from DATA to read the lines from a particular input file."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "ARGV", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "DATA", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Normally for mass rename operations, I use something more like this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/perl\n# rename script by Larry Wall\n#\n# eg:\n#      rename 's/\\.orig$//'  *.orig\n#      rename 'y/A-Z/a-z/ unless /^Make/'  *\n#      rename '$_ .= \".bad\"'  *.f\n#      rename 'print \"$_: \"; s/foo/bar/ if &lt;STDIN&gt; =~ /^y/i'  *\n#      find /tmp -name '*~' -print | rename 's/^(.+)~$/.#$1/'\n\n($op = shift) || die \"Usage: rename expr [files]\\n\";\n\nchomp(@ARGV = &lt;STDIN&gt;) unless @ARGV;\n\nfor (@ARGV) {\n    $was = $_;\n    eval $op;\n    die if $@;  # means eval `failed'\n    rename($was,$_) unless $was eq $_;\n}\n</code>\n</pre>\n", "senID": 4}, {"text": ["I\u2019ve a more full-featured version, but that should suffice."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Here's a simple Python 2 script to do the rename."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n\nimport os\n\n# A dict with keys being the old filenames and values being the new filenames\nmapping = {}\n\n# Read through the mapping file line-by-line and populate 'mapping'\nwith open('mapping.txt') as mapping_file:\n    for line in mapping_file:\n        # Split the line along whitespace\n        # Note: this fails if your filenames have whitespace\n        new_name, old_name = line.split()\n        mapping[old_name] = new_name\n\nsuffix = '_full'\n\n# List the files in the current directory\nfor filename in os.listdir('.'):\n    root, extension = os.path.splitext(filename)\n    if not root.endswith(suffix):\n        # File doesn't end with this suffix; ignore it\n        continue\n    # Strip off the number of characters that make up suffix\n    stripped_root = root[:-len(suffix)]\n    if stripped_root in mapping:\n        os.rename(filename, ''.join(mapping[stripped_root] + suffix + extension))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Various bits of the script are hard-coded that really shouldn't be.", "These include the name of the mapping file (mapping.txt) and the filename suffix (_full).", "These could presumably be passed in as arguments and interpreted using sys.argv."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "mapping.txt", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "_full", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sys.argv", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["A rewrite of Wesley's using generators:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os, os.path\n\nwith open('mapping.txt') as mapping_file:\n    mapping = dict(line.strip().split() for line in mapping_file)\n\nrootextiter = ((filename, os.path.splitext(filename)) for filename in os.listdir('.'))\nmappediter = (\n    (filename, os.path.join(mapping[root], extension))\n    for filename, root, extension in rootextiter\n    if root in mapping\n)\nfor oldname, newname in mappediter:\n    os.rename(oldname, newname)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Read in the text file, create a hash with the current file name, so files['1500000704'] = 'SH103239' and so on.", "Then go through the files in the current directory, grab the new filename from the hash, and rename it."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "files['1500000704'] = 'SH103239'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This is very straightforward to do in Bash assuming that there's an entry in the lookup file for each file and each file has a lookup entry."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/bin/bash\nwhile read -r to from\ndo\n    if [ -e \"${from}_full.jpg\" ]\n    then\n        mv \"${from}_full.jpg\" \"${to}_full.jpg\"\n    fi\ndone &lt; lookupfile.txt\n</code>\n</pre>\n", "senID": 1}, {"text": ["If the lookup file has many more entries than there are files then this approach may be inefficient.", "If the reverse is true then an approach that iterates over the files may be inefficient.", "However, if the numbers are close then this may be the best approach since it doesn't have to actually do any lookups."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you'd prefer a lookup version that's pure-Bash:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n #!/bin/bash\nwhile read -r to from\ndo\n    lookup[from]=$to\ndone &lt; lookupfile.txt\n\nfor file in *.jpg\ndo\n    base=${file%*_full.jpg}\n    mv \"$file\" \"${lookup[base]}_full.jpg\"\ndone\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n #!/bin/bash\n\nfor FILE in *.jpg; do\n    OLD=${FILE%.*}  # Strip off extension.\n    NEW=$(awk -v \"OLD=$OLD\" '$2==OLD {print $1}' map.txt)\n    mv \"$OLD.jpg\" \"$NEW.jpg\"\ndone\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Here's a fun little hack:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n paste -d \" \" lookupfile.txt lookupfile.txt | cut -d \" \" -f 2,3 | sed \"s/\\([ ]\\|$\\)/_full.jpg /g;s/^/mv /\" | sh\n</code>\n</pre>\n", "senID": 1}]]