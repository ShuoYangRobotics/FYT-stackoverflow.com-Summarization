[[{"text": ["Contrary to most other answers here, this can be done in a single regex using a lookahead assertion with a capturing group:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; my_pattern = '(?=(a.*?b.*?c))'\n&gt;&gt;&gt; my_regex = re.compile(my_pattern, re.DOTALL|re.IGNORECASE)\n&gt;&gt;&gt; matches = my_regex.findall(string)\n&gt;&gt;&gt; print min(matches, key=len)\nA|B|C\n</code>\n</pre>\n", "senID": 1}, {"text": ["findall() will return all overlapping matches, so you need min() to get the shortest one."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "findall()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "min()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["How this works:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 6, "lis": [{"text": "We're not matching any text in this regex, just positions in the string (which the regex engine steps through during a match attempt). ", "tag": "none", "senID": 4}, {"text": "At each position, the regex engine looks ahead to see whether your regex would match at this position. ", "tag": "none", "senID": 5}, {"text": "If so, it will be captured by the capturing group. ", "tag": "none", "senID": 6}, {"text": "If not, it won't. ", "tag": "none", "senID": 7}, {"text": "In either case, the regex engine then steps ahead one character and repeats the process until the end of the string. ", "tag": "none", "senID": 8}, {"text": "Since the lookahead assertion doesn't consume any characters, all overlapping matches will be found.", "tag": "none", "senID": 9}]}], [{"text": ["No.", "Perl returns the longest, leftmost match, while obeying your non-greedy quantifiers.", "You'll have to loop, I'm afraid."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Edit: Yes, I realize I said Perl above, but I believe it is true for Python."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["The regex engine starts searching from the beginning of the string till it finds a match and then exits.", "Thus if it finds a match before it even considers the smaller one, there is no way for you to force it to consider later matches in the same run - you will have to rerun the regex on substrings."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Setting the global flag and choosing the shortest matched string won't help as it is evident from your example - the shorter match might be a substring of another match (or partly included in it).", "I believe you will have to start subsequent searches from (1 + index of previous match) and go on like that."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I do not think that this task can be accomplished by a single regular expression.", "I have no proof that this is the case, but there are quite a lot of things that can't be done with regexes and I expected this problem to be one of them.", "Some good examples of the limitations of regexes are given in this blog post."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this blog post", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://blogs.msdn.com/jaredpar/archive/2008/10/15/regular-expression-limitations.aspx"}]}], [{"text": ["This might be a useful application of sexegers.", "Regular-expression matching is biased toward the longest, leftmost choice.", "Using non-greedy quantifiers such as in .*?", "skirts the longest part, and reversing both the input and pattern can get around leftmost-matching semantics."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sexegers", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.perlmonks.org/index.pl?node=sexeger"}, {"text": ".*?", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Consider the following program that outputs A|B|C as desired:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "A|B|C", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #! /usr/bin/env python\n\nimport re\n\nstring = \"A|B|A|B|C|D|E|F|G\"\nmy_pattern = 'c.*?b.*?a'\n\nmy_regex = re.compile(my_pattern, re.DOTALL|re.IGNORECASE)\nmatches = my_regex.findall(string[::-1])\n\nfor match in matches:\n    print match[::-1]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Another way is to make a stricter pattern.", "Say you don't want to allow repetitions of characters already seen:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n my_pattern = 'a[^a]*?b[^ab]*?c'\n</code>\n</pre>\n", "senID": 4}, {"text": ["Your example is generic and contrived, but if we had a better idea of the inputs you're working with, we could offer better, more helpful suggestions."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["You might be able to write the regex in such a way that it can't contain smaller matches."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For your regex:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a.*?b.*?c\n</code>\n</pre>\n", "senID": 2}, {"text": ["I think you can write this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n a[^ab]*b[^c]*c\n</code>\n</pre>\n", "senID": 4}, {"text": ["It's tricky to get that correct, and I don't see any more general or more obviously correct way to do it.", "(Edit&mdash;earlier I suggested a negative lookahead assertion, but I don't see a way to make that work."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "(Edit&mdash;earlier I suggested a negative lookahead assertion, but I don't see a way to make that work.)", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}], [{"text": ["A Python loop to look for the shortest match, by brute force testing each substring from left to right, picking the shortest:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n shortest = None\nfor i in range(len(string)):\n    m = my_regex.match(string[i:])\n    if m: \n        mstr = m.group()\n        if shortest is None or len(mstr) &lt; len(shortest):\n            shortest = mstr\n\nprint shortest\n</code>\n</pre>\n", "senID": 1}, {"text": ["Another loop, this time letting re.findall do the hard work of searching for all possible matches, then brute force testing each match right-to-left looking for a shorter substring:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # find all matches using findall\nmatches = my_regex.findall(string)\n\n# for each match, try to match right-hand substrings\nshortest = None\nfor m in matches:\n    for i in range(-1,-len(m),-1):\n        mstr = m[i:]        \n        if my_regex.match(mstr):\n            break\n    else:\n        mstr = m\n\n    if shortest is None or len(mstr) &lt; len(shortest):\n        shortest = mstr\n\nprint shortest\n</code>\n</pre>\n", "senID": 3}], [{"text": ["No, there isn't in the Python regular expression engine."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["My take for a custom function, though:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import re, itertools\n\n# directly from itertools recipes\ndef pairwise(iterable):\n    \"s -&gt; (s0,s1), (s1,s2), (s2, s3), ...\"\n    a, b = itertools.tee(iterable)\n    for elem in b:\n        break\n    return itertools.izip(a, b)\n\ndef find_matches(rex, text):\n    \"Find all matches, even overlapping ones\"\n    matches= list(rex.finditer(text))\n\n    # first produce typical matches\n    for match in matches:\n        yield match.group(0)\n\n    # next, run it for any patterns included in matches\n    for match1, match2 in pairwise(matches):\n        subtext= text[match1.start()+1:match2.end()+1]\n        for result in find_matches(rex, subtext):\n            yield result\n\n    # also test the last match, if there was at least one\n    if matches:\n        subtext= text[matches[-1].start()+1:matches[-1].end()+1]\n        # perhaps the previous \"matches[-1].end()+1\" can be omitted\n        for result in find_matches(rex, subtext):\n            yield result\n\ndef shortest_match(rex, text):\n    \"Find the shortest match\"\n    return min(find_matches(rex, text), key=len)\n\nif __name__ == \"__main__\":\n    pattern= re.compile('a.*?b.*?c', re.I)\n    searched_text= \"A|B|A|B|C|D|E|F|G\"\n    print (shortest_match(pattern, searched_text))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Another regex solution; it finds only the last occurence of .*a.*b.", "*c:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n my_pattern = 'a(?!.*a.*b.*c).*b[^c]*c'\n\n#a(?!.*a.*?b.*?c) - ensures that there is no 'a.*?b.*?c' after first 'A'\n#strings like A|A|B|C or A|B|A|B|C or A|B|C|A|B|C in results are eliminated\n#\n#b[^c]*c - ensures that after 'B' there is only one 'C'\n#strings like A|B|C|B|C or A|B|C|C in results are eliminated\n#\n#so you have the smallest matching 'a.*?b.*?c'\n</code>\n</pre>\n", "senID": 1}]]