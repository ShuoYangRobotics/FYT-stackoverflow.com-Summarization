[[{"text": ["The random module defines choice(), which does what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import random\n\nwords = [line.strip() for line in open('/etc/dictionaries-common/words')]\nprint random.choice(words)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note also that this assumes that each word is by itself on a line in the file.", "If the file is very big, or if you perform this operation frequently, you may find that constantly rereading the file impacts your application's performance negatively."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Another solution is to use getline"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "getline", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/linecache.html#linecache.getline"}]}, {"code": "<pre>\n<code>\n import linecache\nimport random\nline_number = random.randint(0, total_num_lines)\nlinecache.getline('/etc/dictionaries-common/words', line_number)\n</code>\n</pre>\n", "senID": 1}, {"text": ["From the documentation:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT:\nYou can calculate the total number once and store it, since the dictionary file is unlikely to change."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import random\n&gt;&gt;&gt; random.choice(list(open('/etc/dictionaries-common/words')))\n'jaundiced\\n'\n</code>\n</pre>\n", "senID": 0}, {"text": ["It is efficient human-time-wise.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["btw, your implementation coincides with the one from stdlib's random.py:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "random.py", "tag": "a", "pos": 0, "childList": [{"text": "random.py", "tag": "code"}], "childNum": 1, "href": "http://svn.python.org/view/python/trunk/Lib/random.py?view=markup"}, {"text": "random.py", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def choice(self, seq):\n    \"\"\"Choose a random element from a non-empty sequence.\"\"\"\n    return seq[int(self.random() * len(seq))]\n</code>\n</pre>\n", "senID": 3}, {"text": ["I was wondering what is the relative performance of the presented solutions.", "linecache-based is the obvious favorite.", "How much slower is the random.choice's one-liner compared to honest algorithm implemented in select_random_line()?"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "linecache", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "random.choice", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "select_random_line()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n # nadia_known_num_lines   9.6e-06 seconds 1.00\n# nadia                   0.056 seconds 5843.51\n# jfs                     0.062 seconds 1.10\n# dcrosta_no_strip        0.091 seconds 1.48\n# dcrosta                 0.13 seconds 1.41\n# mark_ransom_no_strip    0.66 seconds 5.10\n# mark_ransom_choose_from 0.67 seconds 1.02\n# mark_ransom             0.69 seconds 1.04\n</code>\n</pre>\n", "senID": 5}, {"text": ["(Each function is called 10 times (cached performance))."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["These result show that simple solution (dcrosta) is faster in this case than a more deliberate one (mark_ransom)."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "dcrosta", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "mark_ransom", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import linecache\nimport random\nfrom timeit import default_timer\n\n\nWORDS_FILENAME = \"/etc/dictionaries-common/words\"\n\n\ndef measure(func):\n    measure.func_to_measure.append(func)\n    return func\nmeasure.func_to_measure = []\n\n\n@measure\ndef dcrosta():\n    words = [line.strip() for line in open(WORDS_FILENAME)]\n    return random.choice(words)\n\n\n@measure\ndef dcrosta_no_strip():\n    words = [line for line in open(WORDS_FILENAME)]\n    return random.choice(words)\n\n\ndef select_random_line(filename):\n    selection = None\n    count = 0\n    for line in file(filename, \"r\"):\n        if random.randint(0, count) == 0:\n            selection = line.strip()\n            count = count + 1\n    return selection\n\n\n@measure\ndef mark_ransom():\n    return select_random_line(WORDS_FILENAME)\n\n\ndef select_random_line_no_strip(filename):\n    selection = None\n    count = 0\n    for line in file(filename, \"r\"):\n        if random.randint(0, count) == 0:\n            selection = line\n            count = count + 1\n    return selection\n\n\n@measure\ndef mark_ransom_no_strip():\n    return select_random_line_no_strip(WORDS_FILENAME)\n\n\ndef choose_from(iterable):\n    \"\"\"Choose a random element from a finite `iterable`.\n\n    If `iterable` is a sequence then use `random.choice()` for efficiency.\n\n    Return tuple (random element, total number of elements)\n    \"\"\"\n    selection, i = None, None\n    for i, item in enumerate(iterable):\n        if random.randint(0, i) == 0:\n            selection = item\n\n    return selection, (i+1 if i is not None else 0)\n\n\n@measure\ndef mark_ransom_choose_from():\n    return choose_from(open(WORDS_FILENAME))\n\n\n@measure\ndef nadia():\n    global total_num_lines\n    total_num_lines = sum(1 for _ in open(WORDS_FILENAME))\n\n    line_number = random.randint(0, total_num_lines)\n    return linecache.getline(WORDS_FILENAME, line_number)\n\n\n@measure\ndef nadia_known_num_lines():\n    line_number = random.randint(0, total_num_lines)\n    return linecache.getline(WORDS_FILENAME, line_number)\n\n\n@measure\ndef jfs():\n    return random.choice(list(open(WORDS_FILENAME)))\n\n\ndef timef(func, number=1000, timer=default_timer):\n    \"\"\"Return number of seconds it takes to execute `func()`.\"\"\"\n    start = timer()\n    for _ in range(number):\n        func()\n    return (timer() - start) / number\n\n\ndef main():\n    # measure time\n    times = dict((f.__name__, timef(f, number=10))\n                 for f in measure.func_to_measure)\n\n    # print from fastest to slowest\n    maxname_len = max(map(len, times))\n    last = None\n    for name in sorted(times, key=times.__getitem__):\n        print \"%s %4.2g seconds %.2f\" % (name.ljust(maxname_len), times[name],\n                                         last and times[name] / last or 1)\n        last = times[name]\n\n\nif __name__ == \"__main__\":\n    main()\n</code>\n</pre>\n", "senID": 8}], [{"text": ["This article may help"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.bryceboe.com/2009/03/23/random-lines-from-a-file/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.bryceboe.com/2009/03/23/random-lines-from-a-file/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.bryceboe.com/2009/03/23/random-lines-from-a-file/"}]}], [{"text": ["Pythonizing my answer from What\u2019s the best way to return a random line in a text file using C?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "What\u2019s the best way to return a random line in a text file using C?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/232237/whats-the-best-way-to-return-a-random-line-in-a-text-file-using-c"}]}, {"code": "<pre>\n<code>\n import random\n\ndef select_random_line(filename):\n    selection = None\n    count = 0\n    for line in file(filename, \"r\"):\n        if random.randint(0, count) == 0:\n            selection = line.strip()\n        count = count + 1\n    return selection\n\nprint select_random_line(\"/etc/dictionaries-common/words\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: the original version of my answer used readlines, which didn't work as I thought and was totally unnecessary.", "This version will iterate through the file instead of reading it all into memory, and do it in a single pass, which should make it much more efficient than any answer I've seen thus far."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "readlines", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import random\n\ndef choose_from(iterable):\n    \"\"\"Choose a random element from a finite `iterable`.\n\n    If `iterable` is a sequence then use `random.choice()` for efficiency.\n\n    Return tuple (random element, total number of elements)\n    \"\"\"\n    selection, i = None, None\n    for i, item in enumerate(iterable):\n        if random.randint(0, i) == 0:\n            selection = item\n\n    return selection, (i+1 if i is not None else 0)\n</code>\n</pre>\n", "senID": 3}, {"code": "<pre>\n<code>\n print choose_from(open(\"/etc/dictionaries-common/words\"))\nprint choose_from(dict(a=1, b=2))\nprint choose_from(i for i in range(10) if i % 3 == 0)\nprint choose_from(i for i in range(10) if i % 11 == 0 and i) # empty\nprint choose_from([0]) # one element\nchunk, n = choose_from(urllib2.urlopen(\"http://google.com\"))\nprint (chunk[:20], n)\n</code>\n</pre>\n", "senID": 4}, {"code": "<pre>\n('yeps\\n', 98569)\n('a', 2)\n(6, 4)\n(None, 0)\n(0, 1)\n('window._gjp && _gjp(', 10)\n</pre>\n", "senID": 5}], [{"text": ["You could do this without using fileinput:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "fileinput", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import random\ndata = open(\"/etc/dictionaries-common/words\").readlines()\nprint random.choice(data)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I have also used data instead of file because file is a predefined type in Python."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "data", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "file", "childNum": 0, "tag": "code", "childList": []}, {"text": "file", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I don't have code for you but as far as an algorithm goes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Efficiency and verbosity aren't the same thing in this case.", "It's tempting to go for the most beautiful, pythonic approach that does everything in one or two lines but for file I/O, stick with classic fopen-style, low-level interaction, even if it does take up a few more lines of code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I could copy and paste some code and claim it to be my own (others can if they want) but have a look at this: http://mail.python.org/pipermail/tutor/2007-July/055635.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://mail.python.org/pipermail/tutor/2007-July/055635.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mail.python.org/pipermail/tutor/2007-July/055635.html"}]}], [{"text": ["There are a few different ways to optimize this problem.", "You can optimize for speed, or for space."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you want a quick but memory-hungry solution, read in the entire file using file.readlines() and then use random.choice()"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you want a memory-efficient solution, first check the number of lines in the file by calling somefile.readline() repeatedly until it returns \"\", then generate a random number smaller then the number of lines (say, n), seek back to the beginning of the file, and finally call somefile.readline() n times.", "The next call to somefile.readline() will return the desired random line.", "This approach wastes no memory holding \"unnecessary\" lines.", "Of course, if you plan on getting lots of random lines from the file, this will be horribly inefficient, and it's better to just keep the entire file in memory, like in the first approach."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]