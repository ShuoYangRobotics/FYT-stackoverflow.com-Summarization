[[{"text": ["Best way to merge two dicts as you're doing (with locals overriding globals) is dict(globals(), **locals())."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dict(globals(), **locals())", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["What the approach of merging globals and locals is missing is (a) builtins (I imagine that's deliberate, i.e.", "you don't think of builtins as \"variables\"... but, they COULD be, if you so choose!-), and (b) if you're in a nested function, any variables that are local to enclosing functions (no really good way to get a dict with all of those, plus -- only those explicitly accessed in the nested function, i.e.", "\"free variables\" thereof, survive as cells in a closure, anyway)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "nested", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "those", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["I imagine these issues are no big deal for your intended use, but you did mention \"corner cases\";-).", "If you need to cover them, there are ways to get the built-ins (that's easy) and (not so easy) all the cells (variables from enclosing functions that you explicitly mention in the nested function -- thefunction.func_code.co_freevars to get the names, thefunction.func_closure to get the cells, cell_contents on each cell to get its value).", "(But, remember, those will only be variables from enclosing functions that are explicitly accessed in your nested function's code!", ")."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "thefunction.func_code.co_freevars", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "thefunction.func_closure", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "cell_contents", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "explicitly accessed", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}], [{"text": ["Does this do what you intended?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d = dict(globals())\nd.update(locals())\n</code>\n</pre>\n", "senID": 1}, {"text": ["If I read the documentation correctly, you create a copy of the globals() dict, then you overwrite any duplicates and insert new entries from the locals() dict (since the locals() should have preference within your scope, anyway)."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "globals()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "and", "childNum": 0, "tag": "em", "childList": []}, {"text": "locals()", "childNum": 0, "tag": "code", "childList": []}, {"text": "locals()", "childNum": 0, "tag": "code", "childList": []}]}, {"tag": "hr", "senID": 3}, {"text": ["I haven't had any luck in getting a proper function to return the full dictionary of variables in scope of the calling  function.", "Here's the code (I only used pprint to format the output nicely for SO):"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "any", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "calling", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n from pprint import *\n\ndef allvars_bad():\n    fake_temp_var = 1\n    d = dict(globals())\n    d.update(locals())\n    return d\n\ndef foo_bad():\n    x = 5\n    return allvars_bad()\n\ndef foo_good():\n    x = 5\n    fake_temp_var = \"good\"\n    d = dict(globals())\n    d.update(locals())\n    return d\n\npprint (foo_bad(), width=50)\npprint (foo_good(), width=50)\n</code>\n</pre>\n", "senID": 5}, {"text": ["and the output:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n {'PrettyPrinter': &lt;class pprint.PrettyPrinter at 0xb7d316ec&gt;,\n '__builtins__': &lt;module '__builtin__' (built-in)&gt;,\n '__doc__': None,\n '__file__': 'temp.py',\n '__name__': '__main__',\n '__package__': None,\n 'allvars_bad': &lt;function allvars_bad at 0xb7d32b1c&gt;,\n 'd': &lt;Recursion on dict with id=3084093748&gt;,\n 'fake_temp_var': 1,\n 'foo_bad': &lt;function foo_bad at 0xb7d329cc&gt;,\n 'foo_good': &lt;function foo_good at 0xb7d32f0c&gt;,\n 'isreadable': &lt;function isreadable at 0xb7d32c34&gt;,\n 'isrecursive': &lt;function isrecursive at 0xb7d32c6c&gt;,\n 'pformat': &lt;function pformat at 0xb7d32bc4&gt;,\n 'pprint': &lt;function pprint at 0xb7d32b8c&gt;,\n 'saferepr': &lt;function saferepr at 0xb7d32bfc&gt;}\n{'PrettyPrinter': &lt;class pprint.PrettyPrinter at 0xb7d316ec&gt;,\n '__builtins__': &lt;module '__builtin__' (built-in)&gt;,\n '__doc__': None,\n '__file__': 'temp.py',\n '__name__': '__main__',\n '__package__': None,\n 'allvars_bad': &lt;function allvars_bad at 0xb7d32b1c&gt;,\n 'd': &lt;Recursion on dict with id=3084093884&gt;,\n 'fake_temp_var': 'good',\n 'foo_bad': &lt;function foo_bad at 0xb7d329cc&gt;,\n 'foo_good': &lt;function foo_good at 0xb7d32f0c&gt;,\n 'isreadable': &lt;function isreadable at 0xb7d32c34&gt;,\n 'isrecursive': &lt;function isrecursive at 0xb7d32c6c&gt;,\n 'pformat': &lt;function pformat at 0xb7d32bc4&gt;,\n 'pprint': &lt;function pprint at 0xb7d32b8c&gt;,\n 'saferepr': &lt;function saferepr at 0xb7d32bfc&gt;,\n 'x': 5}\n</code>\n</pre>\n", "senID": 7}, {"text": ["Note that in the second output, we have overwritten fake_temp_var, and x is present; the first output only included the local vars within the scope of allvars_bad."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "fake_temp_var", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "allvars_bad", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So if you want to access the full variable scope, you cannot put locals() inside another function."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"tag": "hr", "senID": 10}, {"text": ["I had suspected there was some sort of frame object, I just didn't (know where to) look for it."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["This works to your spec, I believe:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n def allvars_good(offset=0):\n    frame = sys._getframe(1+offset)\n    d = frame.f_globals\n    d.update(frame.f_locals)\n    return d\n\n\ndef foo_good2():\n    a = 1\n    b = 2\n    return allvars_good()\n</code>\n</pre>\n", "senID": 13}, {"text": ["-->"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n {'PrettyPrinter': &lt;class pprint.PrettyPrinter at 0xb7d6474c&gt;,\n '__builtins__': &lt;module '__builtin__' (built-in)&gt;,\n '__doc__': None,\n '__file__': 'temp.py',\n '__name__': '__main__',\n '__package__': None,\n 'a': 1,\n 'allvars_bad': &lt;function allvars_bad at 0xb7d65b54&gt;,\n 'allvars_good': &lt;function allvars_good at 0xb7d65a04&gt;,\n 'b': 2,\n 'foo_bad': &lt;function foo_bad at 0xb7d65f44&gt;,\n 'foo_good': &lt;function foo_good at 0xb7d65f7c&gt;,\n 'foo_good2': &lt;function foo_good2 at 0xb7d65fb4&gt;,\n 'isreadable': &lt;function isreadable at 0xb7d65c6c&gt;,\n 'isrecursive': &lt;function isrecursive at 0xb7d65ca4&gt;,\n 'pformat': &lt;function pformat at 0xb7d65bfc&gt;,\n 'pprint': &lt;function pprint at 0xb7d65bc4&gt;,\n 'saferepr': &lt;function saferepr at 0xb7d65c34&gt;,\n 'sys': &lt;module 'sys' (built-in)&gt;}\n</code>\n</pre>\n", "senID": 15}], [{"text": ["You could make your own:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n allvars = dict()\nallvars.update(globals())\nallvars.update(locals())\n</code>\n</pre>\n", "senID": 1}, {"text": ["or combine the first two lines:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n allvars = dict(globals())\nallvars.update(locals())\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Interpolation into strings works in the simplest possible way.", "Just list your variables.", "Python checks locals and globals for you."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n globalVar = 25\n\ndef myfunc(paramVar):\n    localVar = 30\n    print \"Vars: %d, %d, %d!\" % ( globalVar, paramVar, localVar )\n\nmyfunc(123)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n globalVar = 25\n\ndef myfunc(paramVar):\n    localVar = 30\n    all_vars = locals.copy()\n    all_vars.update(globals())\n    print \"Vars: {globalVar}, {paramVar}, {localVar}!\".format(all_vars)\n\nmyfunc(123)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Be more specific and write more concise code, honestly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]