[[{"text": ["Buffering the individual bits until you've accumulated a whole byte seems like a good idea:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n byte b;\nint s;\n\nvoid WriteBit(bool x)\n{\n    b |= (x ? 1 : 0) &lt;&lt; s;\n    s++;\n\n    if (s == 8)\n    {\n        WriteByte(b);\n        b = 0;\n        s = 0;\n    }\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["You just have to deal with the case when the number of bits to be written is not a multiple of eight."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can use boost::dynamic_bitset along with std::ostream_iterator to achieve the desired result in a concise manner:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "boost::dynamic_bitset", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html"}, {"href": "http://www.sgi.com/tech/stl/ostream_iterator.html", "text": "std::ostream_iterator", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n #include &lt;fstream&gt;\n#include &lt;iterator&gt;\n#include &lt;boost/dynamic_bitset.hpp&gt;\n\ntypedef boost::dynamic_bitset&lt;unsigned char&gt; Bitset;\n\n// To help populate the bitset with literals */\nBitset&amp; operator&lt;&lt;(Bitset&amp; lhs, bool val) {lhs.push_back(val); return lhs;}\n\nint main()\n{\n    Bitset bitset;\n    bitset&lt;&lt;0&lt;&lt;1&lt;&lt;0&lt;&lt;1&lt;&lt;0&lt;&lt;1&lt;&lt;0&lt;&lt;1\n          &lt;&lt;1&lt;&lt;0&lt;&lt;1&lt;&lt;0;\n\n    std::ofstream os(\"data.dat\", std::ios::binary);\n    std::ostream_iterator&lt;char&gt; osit(os);\n    boost::to_block_range(bitset, osit);\n\n    return 0;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["I made the block size of my dynamic_bitset 8 bits by specifying unsigned char as the template parameter.", "You can make the block size bigger by specifying a larger integer type."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "dynamic_bitset", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "unsigned char", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["boost::to_block_range dumps the bitset in blocks to the given output iterator.", "If there are empty remainder bits in the last block, they'll be padded with zero."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "boost::to_block_range", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["When I open data.dat in a hex editor I see: AA 05.", "This is on a little endian platform (x64)."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "AA 05", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Which filesystem are you using?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Most likely it stores the length of the file in bytes (are there any that don't?", "), so it's impossible to have a physical file that is not a whole number of bytes."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "any", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["So if you are writing to the file as a stream of bits, you either have to truncate the last few bits when you are finished, or write out the final byte with what ammounts to junk in the remaining bits."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here's some Python code to get you started"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Python", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class BitFile(file):\n    def __init__(self, filename, mode):\n        super(BitFile, self).__init__(filename, mode)\n        self.bitCount=0\n        self.byte = 0\n\n    def write(self, bit):\n        self.bitCount+=1\n        self.byte = self.byte*2+bit\n        if self.bitCount%8==0:\n            super(BitFile, self).write(chr(self.byte))\n            self.byte=0\n\n    def close(self):\n        if self.bitCount%8!=0:\n            super(BitFile, self).write(chr(self.byte))\n        super(BitFile, self).close()     \n\nwith BitFile(\"bitfile.bin\",\"w\") as bf:\n    bf.write(1)\n    bf.write(1)\n    bf.write(1)\n    bf.write(0)\n    bf.write(0)\n    bf.write(0)\n    bf.write(0)\n    bf.write(0)\n    bf.write(1)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["You can't really.", "I'm pretty sure the problem is not with the language or the filesystem, but a hardware issue.", "Processors are designed to work with bytes.", "Probably the closest you can do is write your last byte over and over again, right padded with zeros, changing them as you go, one at a time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["so to write bits '11011', you could do the following (python example, but any language should have facilities to do this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n f.write(chr(0b10000000))\nf.flush()\nf.seek(-1)\nf.write(chr(0b11000000))\nf.flush()\nf.seek(-1)\nf.write(chr(0b11000000))\nf.flush()\nf.seek(-1)\nf.write(chr(0b11010000))\nf.flush()\nf.seek(-1)\nf.write(chr(0b11011000)) \nf.flush()\n</code>\n</pre>\n", "senID": 2}, {"text": ["You weren't hoping to get some sort of performance gain from this were you?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I would recommend allocating a rather large buffer (4096 bytes at least) and flush that off to disk whenever it fills up.", "Using a one-byte buffer usually causes bad performance."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I did this once for huffman decoding and ended up writing the bits as chars and thus handling everything internally as a plain old C string. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That way you don't have to worry about the trailing byte and it's human readable as well.", "Also checking bits is is easier since its just a matter of addressing the char array (binbuf[123] == '1') instead of having to fiddle with bits.", "Not the most optimized solution, but it solved my problem neatly."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "binbuf[123] == '1'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The obvious drawback is that this representation uses more memory."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The issue here is that many platforms do not have direct bit access.", "They group bits into a minimal package, often times the byte or word.", "Also, the protocol for stream devices does not facilitate transmission of individual bits.  "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "byte", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "word", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["The common method to deal with individual bits is to pack them into the smallest portable and (addressable) accessible unit.", "The unused bits are usually set to zero.", "This can be accomplished with binary arithmetic operations (OR, AND, EXCLUSIVE-OR, NOT, etc.", ")."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["With modern processors, bit twiddling slows down the machine and the performance.", "Memory is cheap and with large addressing spaces, justification for bit packing has become more difficult.", "Generally, bit packing is reserved for hardware oriented operations (and also transmission protocols).", "For example, if a processor's word capacity is 16 bits, the processor can probably handle 16 words faster than 16 bit manipulations in one word. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "word", "childNum": 0, "tag": "em", "pos": 3, "childList": []}]}, {"text": ["Also, keep in mind that writing to and from memory is often faster than I/O from streams.", "Efficient systems buffer data in memory before transmitting the data.", "You may want to consider this technique in your designs.", "Reducing I/O operations will improve the performance of your program."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]