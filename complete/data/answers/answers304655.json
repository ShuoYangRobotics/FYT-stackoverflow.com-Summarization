[[{"text": ["Quite simply, the solution is that f does not need to be a member of the class.", "I am assuming that your thought-process has gone through a Javaish language filter causing the mental block.", "It goes a little something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f(n):\n    return '&lt;' + str(num) + '&gt;'\n\nclass C(object):\n\n    v = f(9)\n    w = f(42)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then when you want to use f again, just use it"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; f(4)\n'&lt;4&gt;'\n</code>\n</pre>\n", "senID": 3}, {"text": ["I think the moral of the tale is \"In Python, you don't have to force everything into a class\". "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "have", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Extending Ali A's answer,\nif you really want to avoid f in the module namespace (and using a non-exported name like _f, or setting __all__ isn't sufficient), then\nyou could achieve this by creating the class within a closure."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Ali A", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/304655/the-best-way-to-invoke-methods-in-python-class-declarations#304679"}]}, {"code": "<pre>\n<code>\n def create_C():\n    def f(num):\n        return '&lt;' + str(num) + '&gt;'\n\n    class C(object):\n        v = f(9)\n        def method_using_f(self, x):  return f(x*2)\n    return C\n\nC=create_C()\ndel create_C\n</code>\n</pre>\n", "senID": 1}, {"text": ["This way C has access to f within its definition and methods, but nothing else does (barring fairly involved introspection\nof its methods (C.method_using_f.im_func.func_closure))"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "C.method_using_f.im_func.func_closure", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This is probably overkill for most purposes though - documenting that f is internal by using the \"_\" prefix nameing convention should\ngenerally be sufficient."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["[Edit]  One other option is to hold a reference to the pre-wrapped function object in the methods you wish to use it in.", "For example, by setting it as a default argument:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "[Edit]", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class C(object):\n    def f(num):\n        return '&lt;' + str(num) + '&gt;'\n\n    v = f(9)\n    def method_using_f(self, x, f=f):  return f(x*2)\n\n    del f\n</code>\n</pre>\n", "senID": 5}, {"text": ["(Though I think the closure approach is probably better)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["This is one possibility:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class _C:\n    # Do most of the function definitions in here\n    @classmethod\n    def f(cls):\n        return 'boo'\n\nclass C(_C):\n    # Do the subsequent decoration in here\n    v = _C.f()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I believe you are trying to do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class C():\n...     class F():\n...         def __call__(self,num):\n...             return \"&lt;\"+str(num)+\"&gt;\"\n...     f=F()\n...     v=f(9)\n&gt;&gt;&gt; C.v\n'&lt;9&gt;'\n&gt;&gt;&gt; C.f(25)\n'&lt;25&gt;'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Maybe there is better or more pythonic solution..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["\"Can't be done\" doesn't seem to get along with Python"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["One option: write a better staticmethod:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "staticmethod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class staticfunc(object):\n    def __init__(self, func):\n        self.func = func\n    def __call__(self, *args, **kw):\n        return self.func(*args, **kw)\n    def __repr__(self):\n        return 'staticfunc(%r)' % self.func\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Let's begin from the beginning."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\"declare a function in a class, use it during its declaration, and also use it later from within the class\""], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Sorry.", "Can't be done.", "\"In a class\" contradicts \"used during declaration\"."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "In a class means created as part of the declaration.", "tag": "none", "senID": 3}, {"text": "Used during declaration means it exists outside the class.  Often as a meta class.  However, there are other ways.", "tag": "none", "senID": 4}]}, {"text": ["It's not clear what C.w and C.v are supposed to be.", "Are they just strings?", "If so, an external function f is the best solution.", "The \"not clutter the namespace\" is a bit specious.", "After all, you want to use it again."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "f", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["It's in the same module as C.  That's why Python has modules.", "It binds the function and class together."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import myCmod\n\nmyCmod.C.w\nmyCmod.C.v\nmyCmod.f(42)\n</code>\n</pre>\n", "senID": 7}, {"text": ["If w and v aren't simple strings, there's a really good solution that gives a lot of flexibility."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Generally, for class-level (\"static\") variables like this, we can use other classes.", "It's not possible to completely achieve the desired API, but this is close."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class F(object):\n    def __init__( self, num ):\n    \tself.value= num\n    \tself.format= \"&lt;%d&gt;\" % ( num, )\n\n&gt;&gt;&gt; class C(object):\n    w= F(42)\n    v= F(9)\n\n&gt;&gt;&gt; C.w\n&lt;__main__.F object at 0x00C58C30&gt;\n&gt;&gt;&gt; C.w.format\n'&lt;42&gt;'\n&gt;&gt;&gt; C.v.format\n'&lt;9&gt;'\n</code>\n</pre>\n", "senID": 10}, {"text": ["The advantage of this is that F is a proper, first-class thing that can be extended.", "Not a \"hidden\" thing that we're trying to avoid exposing.", "It's a fact of life, so we might as well follow the Open/Closed principle and make it open to extension."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}]]