[[{"text": ["Yes, there is.", "The Python way is even better."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There are three possibilities:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["1)  Like File.listFiles():"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "1)  Like File.listFiles():", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Python has the function os.listdir(path).", "It works like the Java method."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["2) pathname pattern expansion with glob:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "2) pathname pattern expansion with glob:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The module glob contains functions to list files on the file system using Unix shell like pattern, e.g.", "files = glob.glob('/usr/joe/*.gif')"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "files = glob.glob('/usr/joe/*.gif')", "childNum": 0, "tag": "pre", "pos": 1, "childList": []}]}, {"text": ["3)  File Traversal with walk:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "3)  File Traversal with walk:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Really nice is the os.walk function of Python."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["The walk method returns a generation function that recursively list all directories and files below a given starting path."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["An Example:\n import os\nfrom os.path import join\nfor root, dirs, files in os.walk('/usr'):\n   print \"Current directory\", root\n   print \"Sub directories\", dirs\n   print \"Files\", files\nYou can even on the fly remove directories from \"dirs\" to avoid walking to that dir: if \"joe\" in dirs: dirs.remove(\"joe\") to avoid walking into directories called \"joe\"."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "import os\nfrom os.path import join\nfor root, dirs, files in os.walk('/usr'):\n   print \"Current directory\", root\n   print \"Sub directories\", dirs\n   print \"Files\", files", "childNum": 0, "tag": "pre", "childList": []}]}, {"text": ["listdir and walk are documented here.", "glob is documented here."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/os-file-dir.html"}, {"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-glob.html"}]}], [{"text": ["As a long-time Pythonista, I have to say the path/file manipulation functions in the std library are sub-par: they are not object-oriented and they reflect an obsolete, lets-wrap-OS-system-functions-without-thinking philosophy.", "I'd heartily recommend the 'path' module as a wrapper (around os, os.path, glob and tempfile if you must know): much nicer and OOPy: http://pypi.python.org/pypi/path.py/2.2"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://pypi.python.org/pypi/path.py/2.2", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/path.py/2.2"}]}, {"text": ["This is walk() with the path module:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n dir = path(os.environ['HOME'])\nfor f in dir.walk():\n    if f.isfile() and f.endswith('~'):\n        f.remove()\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Try \"listdir()\" in the os module (docs):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/os-file-dir.html"}]}, {"code": "<pre>\n<code>\n import os\nprint os.listdir('.')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Straight from Python's Refererence Library"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import glob\n&gt;&gt;&gt; glob.glob('./[0-9].*')\n['./1.gif', './2.txt']\n&gt;&gt;&gt; glob.glob('*.gif')\n['1.gif', 'card.gif']\n&gt;&gt;&gt; glob.glob('?.gif')\n['1.gif']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Take a look at os.walk() and the examples here.", "With os.walk() you can easily process a whole directory tree. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "os.walk()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "here", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/os-file-dir.html"}, {"text": "os.walk()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["An example from the link above..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # Delete everything reachable from the directory named in 'top',\n# assuming there are no symbolic links.\n# CAUTION:  This is dangerous!  For example, if top == '/', it\n# could delete all your disk files.\nimport os\nfor root, dirs, files in os.walk(top, topdown=False):\n    for name in files:\n        os.remove(os.path.join(root, name))\n    for name in dirs:\n        os.rmdir(os.path.join(root, name))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Use os.path.walk if you want subdirectories as well."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\nwalk(top, func, arg)\n\n        Directory tree walk with callback function.\n\n        For each directory in the directory tree rooted at top (including top\n        itself, but excluding '.' and '..'), call func(arg, dirname, fnames).\n        dirname is the name of the directory, and fnames a list of the names of\n        the files and subdirectories in dirname (excluding '.' and '..').  func\n        may modify the fnames list in-place (e.g. via del or slice assignment),\n        and walk will only recurse into the subdirectories whose names remain in\n        fnames; this can be used to implement a filter, or to impose a specific\n        order of visiting.  No semantics are defined for, or required of, arg,\n        beyond that arg is always passed to func.  It can be used, e.g., to pass\n        a filename pattern, or a mutable object designed to accumulate\n        statistics.  Passing None for arg is common.\n</pre>\n", "senID": 1}], [{"text": ["I'd recommend against os.path.walk as it is being removed in Python 3.0.  os.walk is simpler, anyway, or at least I find it simpler."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "os.path.walk", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "os.walk", "childNum": 0, "tag": "code", "childList": []}, {"text": "I", "childNum": 0, "tag": "em", "childList": []}]}]]