[[{"text": ["I don't know Python, but you can do this with three simple regex-replaces (possibly doable as a single regex, but the following should work fine)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Javascript version:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n str = '[' + str.replace(/!\\n/, ', ').replace(/&lt;[^\\/&gt;]*&gt;/, '[').replace(/&lt;\\/[^&gt;]*&gt;/, ']') + ']';\n</code>\n</pre>\n", "senID": 2}, {"text": ["Hopefully that will be understandable enough to translate to Python. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Edit: Are you looking for array output?", "I thought your sample output was a literal string, but now I think that was meant to represent a nested array."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Wouldn't it be easier to just replace &lt;tag&gt; with [ and &lt;/tag&gt; with ], and !\\n with ,, and at the end embrace everything in one more pair of []?"], "childNum": 7, "tag": "p", "senID": 0, "childList": [{"text": "&lt;tag&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[", "childNum": 0, "tag": "code", "childList": []}, {"text": "&lt;/tag&gt;", "childNum": 0, "tag": "code", "childList": []}, {"text": "]", "childNum": 0, "tag": "code", "childList": []}, {"text": "!\\n", "childNum": 0, "tag": "code", "childList": []}, {"text": ",", "childNum": 0, "tag": "code", "childList": []}, {"text": "[]", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Yes it is possible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To generate a flat array, your regex would be quite hairy, involving backtracking.", "It would be very similar to a regex for splitting a CSV file while allowing quoted strings, where the &lt;tag&gt; / &lt;/tag&gt; markers take the place of the quote marks, and the !", "takes the place of the comma."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "&lt;tag&gt;", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "&lt;/tag&gt;", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "!", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["But you asked for a nested array structure, and in fact that makes things easier."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In order to get the nested array structure, you're going to need to do two separate split operations, which means doing two separate regex operations.", "You could do the first one as described above, but in fact, having to do two separate operations actually makes it easier for you because you can split out the sections embedded in the &lt;tag&gt;s in the first pass, and since you say there's no nested tags, that means you don't need to do any complex regex back-tracking."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "&lt;tag&gt;", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Hope that helps."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n from collections import deque\nfrom types import StringTypes\n\ns = \"A!\\nB!\\nC!\\n&lt;tag&gt;\\nD!\\nE!\\n&lt;/tag&gt;\\nF!\\n&lt;tag&gt;\\nG!\\n&lt;/tag&gt;\"\n\ndef parse(parts):\n    if type(parts) in StringTypes:\n        parts = deque(parts.split(\"\\n\"))\n    ret = []\n    while parts:\n        part = parts.popleft()\n        if part[-1] == \"!\":\n            ret.append(part[:-1])\n        elif part == \"&lt;tag&gt;\":\n            ret.append(parse(parts))\n        elif part == \"&lt;/tag&gt;\":\n            return ret\n    return ret\n\nprint parse(s)\n</code>\n</pre>\n", "senID": 0}, {"text": ["I use a deque for speed because pop(0) would be very slow, and reversing the list and using pop() would make the function harder to read and understand."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I dare anyone to create a regexp doing the same, while also improving clarity!"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["(BTW, I think you could also use the pyparsing module to solve this problem, since it supports recursion."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "pyparsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/"}]}, {"text": ["EDIT: Changed function to expect either string or deque as argument, simplifying invocation."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Here is my solution to the problem.", "It uses regexp and some operations on the list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nmy_str = \"A!\\nB!\\n&lt;tag&gt;\\nC!\\n&lt;/tag&gt;\\nD!\\nE!\\n&lt;tag&gt;\\nF!\\nG!\\n&lt;/tag&gt;\\nH!\\n\"\n\nx = re.findall(\"^(?:.|\\n)+?(?=\\n&lt;tag&gt;)\",str) + re.findall(\"(?&lt;=&lt;/tag&gt;\\n)(?:.|\\n)+?(?=\\n&lt;tag&gt;\\n)\",str) + re.findall(\"(?&lt;=&gt;\\n)(?:[^&gt;]|\\n)+(?=\\n)$\",my_str)\n\n\ny =[]\nfor elem in x:\n    y += elem.split('\\n')\nx = re.findall(\"((?&lt;=&lt;tag&gt;\\n)(?:.|\\n)+?(?=\\n&lt;/tag&gt;\\n))\",my_str)\nfor elem in x:\n    y.append(elem.split('\\n'))   \n\nprint y\n</code>\n</pre>\n", "senID": 1}, {"text": ["it produces the output"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ['A!', 'B!', 'D!', 'E!', 'H!', ['C!'], ['F!', 'G!']]\n</code>\n</pre>\n", "senID": 3}, {"text": ["I didn't have much time to test it, though."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["I do not think there is an easier way of doing this, as there is no recursive regexp in Python, see SO thread. "], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "no recursive", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"href": "http://stackoverflow.com/questions/1656859/how-can-be-implemented-recursive-regexp-in-python", "text": "SO thread", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Have a good night (my time-zone).", ";)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Note: probably it could have been made nicer by including everything in one regexp by using xor (see XOR in Regexp) but I think it would loose readability."], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "Note", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "xor", "childNum": 0, "tag": "strong", "childList": []}, {"href": "http://stackoverflow.com/questions/247167/exclusive-or-in-regular-expression", "text": "XOR in Regexp", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["If all the conditions I understood are verified (for exemple: there is no character on a line before '&lt;tag&gt;' or before '&lt;/tag&gt;' ; right ?", ") , the following code does the job, I think:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "'&lt;tag&gt;'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "'&lt;/tag&gt;'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\nRE = ('(\\A\\n*&lt;tag&gt;\\n+)',\n      '(\\A\\n*)',\n      '(!\\n*&lt;/tag&gt;(?!\\n*\\Z)\\n*)',\n      '(!\\n*&lt;/tag&gt;\\n*\\Z)',\n      '(!\\n*&lt;tag&gt;\\n+)',\n      '(!\\n*\\Z)',\n      '(!\\n+)')\n\npat = re.compile('|'.join(RE))\n\ndef repl(mat, d = {1:\"[['\", 2:\"['\", 3:\"'],'\", 4:\"']]\", 5:\"',['\", 6:\"']\", 7:\"','\"}):\n    return d[mat.lastindex]\n\nch =  .... # a string to parse\ndh = eval(pat.sub(repl,ch))\n</code>\n</pre>\n", "senID": 1}, {"text": ["applying:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ch1 = '''\n\nA!\nB!\nC!\n&lt;tag&gt;\nD!\n\n\nE!\n&lt;/tag&gt;\nF!\n&lt;tag&gt;\nG!\n&lt;/tag&gt;\n\n\n'''\n\nch2 = '''A!\nB!\nC!\n\n\n\n&lt;tag&gt;\nD!\nE!\n&lt;/tag&gt;\nF!\n&lt;tag&gt;\nG!\n&lt;/tag&gt;\n\nH!\n\n'''\n\nch3 = '''\n\n\nA!\nB!\nC!\n&lt;tag&gt;\nD!\nE!\n&lt;/tag&gt;\nFududu!gutuyu!!\n&lt;tag&gt;\nG!\n\n&lt;/tag&gt;\n\nH!'''\n\nch4 = '''&lt;tag&gt;\nA!\nB!\n\n&lt;/tag&gt;\nC!\n&lt;tag&gt;\nD!\nE!\n&lt;/tag&gt;\nF!\n&lt;tag&gt;\nG!\n\n&lt;/tag&gt;\n\nH!'''\n\nimport re\n\nRE = ('(\\A\\n*&lt;tag&gt;\\n+)',\n      '(\\A\\n*)',\n      '(!\\n*&lt;/tag&gt;(?!\\n*\\Z)\\n*)',\n      '(!\\n*&lt;/tag&gt;\\n*\\Z)',\n      '(!\\n*&lt;tag&gt;\\n+)',\n      '(!\\n*\\Z)',\n      '(!\\n+)')\n\npat = re.compile('|'.join(RE))\n\ndef repl(mat, d = {1:\"[['\", 2:\"['\", 3:\"'],'\", 4:\"']]\", 5:\"',['\", 6:\"']\", 7:\"','\"}):\n    return d[mat.lastindex]\n\n\nfor ch in (ch1,ch2,ch3,ch4):\n    print ch\n    dh = eval(pat.sub(repl,ch))\n    print dh,'\\n',type(dh)\n    print '\\n\\n============================='\n</code>\n</pre>\n", "senID": 3}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; \n\n\nA!\nB!\nC!\n&lt;tag&gt;\nD!\n\n\nE!\n&lt;/tag&gt;\nF!\n&lt;tag&gt;\nG!\n&lt;/tag&gt;\n\n\n\n['A', 'B', 'C', ['D', 'E'], 'F', ['G']] \n&lt;type 'list'&gt;\n\n\n=============================\nA!\nB!\nC!\n\n\n\n&lt;tag&gt;\nD!\nE!\n&lt;/tag&gt;\nF!\n&lt;tag&gt;\nG!\n&lt;/tag&gt;\n\nH!\n\n\n['A', 'B', 'C', ['D', 'E'], 'F', ['G'], 'H'] \n&lt;type 'list'&gt;\n\n\n=============================\n\n\n\nA!\nB!\nC!\n&lt;tag&gt;\nD!\nE!\n&lt;/tag&gt;\nFududu!gutuyu!!\n&lt;tag&gt;\nG!\n\n&lt;/tag&gt;\n\nH!\n['A', 'B', 'C', ['D', 'E'], 'Fududu!gutuyu!', ['G'], 'H'] \n&lt;type 'list'&gt;\n\n\n=============================\n&lt;tag&gt;\nA!\nB!\n\n&lt;/tag&gt;\nC!\n&lt;tag&gt;\nD!\nE!\n&lt;/tag&gt;\nF!\n&lt;tag&gt;\nG!\n\n&lt;/tag&gt;\n\nH!\n[['A', 'B'], 'C', ['D', 'E'], 'F', ['G'], 'H'] \n&lt;type 'list'&gt;\n\n\n=============================\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 5}]]