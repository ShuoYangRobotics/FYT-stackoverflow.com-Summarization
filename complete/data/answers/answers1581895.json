[[{"text": ["If you don't care about the order in which items are processed, I'd try a subclass of Queue that uses set internally:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Queue", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class SetQueue(Queue):\n\n    def _init(self, maxsize):\n        self.maxsize = maxsize\n        self.queue = set()\n\n    def _put(self, item):\n        self.queue.add(item)\n\n    def _get(self):\n        return self.queue.pop()\n</code>\n</pre>\n", "senID": 1}, {"text": ["As Paul McGuire pointed out, this would allow adding a duplicate item after it's been removed from the \"to-be-processed\" set and not yet added to the \"processed\" set.", "To solve this, you can store both sets in the Queue instance, but since you are using the larger set for checking if the item has been processed, you can just as well go back to queue which will order requests properly."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Queue", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "queue", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class SetQueue(Queue):\n\n    def _init(self, maxsize):\n        Queue._init(self, maxsize) \n        self.all_items = set()\n\n    def _put(self, item):\n        if item not in self.all_items:\n            Queue._put(self, item) \n            self.all_items.add(item)\n</code>\n</pre>\n", "senID": 3}, {"text": ["The advantage of this, as opposed to using a set separately, is that the Queue's methods are thread-safe, so that you don't need additional locking for checking the other set."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Queue", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["SQLite is so simple to use and would fit perfectly... just a suggestion."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The way I solved this (actually I did this in Scala, not Python) was to use both a Set and a Queue, only adding links to the queue (and set) if they did not already exist in the set."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Both the set and queue were encapsulated in a single thread, exposing only a queue-like interface to the consumer threads."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit: someone else suggested SQLite and that is also something I am considering, if the set of visited URLs needs to grow large.", "(Currently each crawl is only a few hundred pages so it easily fits in memory.", ") But the database is something that can also be encapsulated within the set itself, so the consumer threads need not be aware of it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Also, instead of a set you might try using a dictionary.", "Operations on sets tend to get rather slow when they're big, whereas a dictionary lookup is nice and quick."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["My 2c."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n url in q.queue\n</code>\n</pre>\n", "senID": 1}, {"text": ["which returns True iff url is in the queue"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "url", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Why only use the array (ideally, a dictionary would be even better) to filter things you've already visited?", "Add things to your array/dictionary as soon as you queue them up, and only add them to the queue if they're not already in the array/dict.", "Then you have 3 simple separate things:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["instead of \"array of pages already visited\" make an \"array of pages already added to the queue\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]