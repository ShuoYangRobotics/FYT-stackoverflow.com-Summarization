[[{"text": ["Just iterate over pairs, using zip(), which is much more readable."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "zip()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["UPDATE: for python 2.x, use itertools.izip instead as it is more efficient!"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "UPDATE:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "itertools.izip", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import izip\nfor prev, next in izip(tmp, tmp[1:]):\n    print 'seq: ', next[1], 'prev seq:', prev[1], 'variance: ', next[1]-prev[1]\n</code>\n</pre>\n", "senID": 2}, {"text": ["which can also use value unpacking to avoid the index:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for (_, prev), (_, next) in izip(tmp, tmp[1:]):\n    print 'seq: ', next, 'prev seq:', prev, 'variance: ', next-prev\n</code>\n</pre>\n", "senID": 4}, {"text": ["Or, if you really need the first iteration too"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n for prev, next in izip(tmp, tmp[:1] + tmp):\n    print 'seq: ', next[1], 'prev seq:', prev[1], 'variance: ', next[1]-prev[1]\n</code>\n</pre>\n", "senID": 6}, {"text": ["EDIT"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "EDIT", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If you want to avoid the creation of a list in the second argument you can also use an explicit iterator:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n itr = iter(tmp)\nitr.next() # here I assume tmp is not empty, otherwise an exception will be thrown\nfor prev, next in izip(tmp, itr):\n    print 'seq: ', next[1], 'prev seq:', prev[1], 'variance: ', next[1]-prev[1]\n</code>\n</pre>\n", "senID": 9}, {"text": ["Note: This zip pattern is useful in similar problems too.", "For example to extract successive triplets from a list:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Note", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n xs = range(9)\ntriplets = zip(xs[::3], xs[1::3], xs[2::3]) # python 2.x, zip returns a list\n\nprint xs       # [0, 1, 2, 3, 4, 5, 6, 7, 8]\nprint triplets # [(0, 1, 2), (3, 4, 5), (6, 7, 8)]\n</code>\n</pre>\n", "senID": 11}, {"text": ["Also note that in python 3 zip returns an iterator, similar to itertools.izip."], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "python 3 zip returns an iterator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://diveintopython3.org/porting-code-to-python-3-with-2to3.html#zip"}, {"text": "itertools.izip", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Your code is going to be doing the \"if not prev\" test every time round the loop, even though it only applies to the first element.", "Also your code seems broken to me - the first time round the loop the prev and current values are the same."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I would do it like this, assuming that there is at least one element:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n tmp_iter = iter(tmp)\nprev = tmp_iter.next()\n\nfor x in tmp_iter: \n   print 'seq: ', x[1], 'prev seq:', prev[1], 'variance: ', x[1]-prev[1]\n   prev = x\n</code>\n</pre>\n", "senID": 2}, {"text": ["this could be optimised further by getting rid of the indexing:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n tmp_iter = iter(tmp)\n[_, prev] = tmp_iter.next()\n\nfor [_, x] in tmp_iter: \n   print 'seq: ', x, 'prev seq:', prev, 'variance: ', x-prev\n   prev = x\n</code>\n</pre>\n", "senID": 4}, {"text": ["I use the assignment to spit the list into its constituent parts, and assign the first element to _ because it is not used."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Using itertools:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import izip, islice\nfor prev, cur in izip(l, islice(l, 1, None)):\n    print 'seq:', cur[1], 'prev seq:', prev[1], 'delta:', cur[1]-prev[1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["For the specific example given in the question, note that, if the numbers\ncan be represented using 32-bit ints, and the list of numbers fits into\nmemory, one of the fastest ways to compute the difference would be to\nuse numpy:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "numpy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import numpy\na = numpy.array([x[1] for x in tmp])\ndelta = numpy.diff(a)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Guido's time machine to the rescue!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["From the itertools recipes page:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "itertools recipes", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#recipes"}]}, {"code": "<pre>\n<code>\n import itertools\ndef pairwise(iterable):\n    \"s -&gt; (s0,s1), (s1,s2), (s2, s3), ...\"\n    a, b = itertools.tee(iterable)\n    next(b, None)\n    return itertools.izip(a, b)\n</code>\n</pre>\n", "senID": 2}, {"text": ["This should be the most appropriate method (consider the iterable was (random.randint(100) for x in xrange(1000)); here iter(iterable); next(iterable) as a secondary iterator might not provide correct functionality."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "(random.randint(100) for x in xrange(1000))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "iter(iterable); next(iterable)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Use it in your loop as:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n for prev_item, item in pairwise(iterable):\n    \u2026\n</code>\n</pre>\n", "senID": 5}], [{"text": ["This code generates NameError because at if not prev, prev is not defined.", "Set it to False or None before the cycle.", "Also you may make a different loop:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "if not prev", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for i in xrange(1, len(tmp)):\n    print 'seq: {0}, prev seq: {1}, variance: {2}'.format(tmp[i][1], tmp[i - 1][1], tmp[i] - tmp[i - 1][1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you'll use 100,000+ records, the bottleneck will be not the cycle, but the memory used by the app.", "Don't store all the data in such a format: each pair of values (a list) will eat 100+ bytes.", "If they're in a file, it's better to iterate over it's lines:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "will eat 100+ bytes", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.valuedlessons.com/2008/10/blog-post.html"}]}, {"text": ["(assuming the data is tab-separated)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def reader(filename):\n    with open(filename) as f:\n        prev = f.next()\n        for l in f:\n            l = l.split('\\t')\n            yield (prev, l)\n            prev = l\n\nfor (prev, curr) in reader(myfile):\n    print 'seq: {0}, prev seq: {1}, variance: {2}'.format(curr[1], prev[1], curr[1] - prev[1])\n</code>\n</pre>\n", "senID": 4}, {"text": ["reader is a generator, it returns values from a sequence many times.", "This way, only 2 lines of data will be stored in memory at any moment, and your app will sustain even millions of rows."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "reader", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "generator", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/classes.html#generators"}]}, {"text": ["To make the code readable, I put it aside, so that in the program body we dealed with the sequence of data, without caring how it's composed."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"code": "<pre>\n<code>\n it = imap(operator.itemgetter(1), tmp) # get all 2nd items\nprev = next(it, None) # get 1st element (doesn't throw exception for empty `tmp`)\nfor x in it:\n    print 'seq: %s prev seq: %s variance: %s' % (x, prev, x-prev)\n    prev = x\n</code>\n</pre>\n", "senID": 0}]]