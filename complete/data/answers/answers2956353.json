[[{"text": ["The following regular expression do what you need:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\ns = \"Hi there @guy\"\np = re.search(r'@(\\w+)', s)\nprint p.group(1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It will also work for the following string formats:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": ["s = \"Hi there @guy \""], "childNum": 0, "tag": "code", "senID": 3, "childList": []}, {"text": ["s = \"Hi there @guy,\""], "childNum": 0, "tag": "code", "senID": 4, "childList": []}, {"text": ["s = \"Hi there @guy and\""], "childNum": 0, "tag": "code", "senID": 5, "childList": []}, {"text": ["s = \"Hi there @guy22\""], "childNum": 0, "tag": "code", "senID": 6, "childList": []}, {"text": ["s = \"Hi there @22guy\""], "childNum": 0, "tag": "code", "senID": 7, "childList": []}]}], [{"text": ["That regex does not do what you think it does."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s = \"Hi there @guy\"\np = re.search(r'@([^ ]+)', s) # this is the regex you described\nprint p.group(1) # first thing matched inside of ( .. )\n</code>\n</pre>\n", "senID": 1}, {"text": ["But as usually with regex, there are tons of examples that break this, for example if the text is s = \"Hi there @guy, what's with the comma?", "\" the result would be guy,. "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "s = \"Hi there @guy, what's with the comma?\"", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "guy,", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["So you really need to think about every possible thing you want and don't want to match.", "r'@([a-zA-Z]+)' might be a good starting point, it literally only matches letters (a .. z, no unicode etc)."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "r'@([a-zA-Z]+)'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["p.group(0) should return guy.", "If you want to find out what function an object has, you can use the dir(p) method to find out.", "This will return a list of attributes and methods that are available for that object instance."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "p.group(0)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "guy", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "dir(p)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"code": "<pre>\n<code>\n (?&lt;=@)\\w+\n</code>\n</pre>\n", "senID": 0}, {"text": ["will match a word if it's preceded by a @ (without adding it to the match, a so-called positive lookbehind).", "This will match \"words\" that are composed of letters, numbers, and/or underscore; if you don't want those, use (?&lt;=@)[^\\W\\d_]+"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "@", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "(?&lt;=@)[^\\W\\d_]+", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In Python:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; strg = \"Hi there @guy!\"\n&gt;&gt;&gt; p = re.search(r'(?&lt;=@)\\w+', strg)\n&gt;&gt;&gt; p.group()\n'guy'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["As it's evident from the answers so far regex is the most efficient solution for your problem.", "Answers differ slightly regarding what you allow to be followed by the @:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "@", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n [^ ] anything but space\n\\w   in python-2.x is equivalent to [A-Za-z0-9_], in py3k is locale dependent\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you have better idea what characters might be included in the user name you might adjust your regex to reflect that, e.g., only lower case ascii letters, would be:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [a-z]\n</code>\n</pre>\n", "senID": 3}, {"text": ["NB: I skipped quantifiers for simplicity."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You say: \"\"\"If I do p = re.search('[/@.", "* /]', str) I'll get any words that start with @ and end up with a space.", "\"\" But this is incorrect -- that pattern is a character class which will match ONE character in the set @/.", "* and space.", "Note: there's a redundant second / in the pattern.", "For example:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "p = re.search('[/@.* /]', str)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "@/.*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "/", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; re.findall('[/@.* /]', 'xxx@foo x/x.x*x xxxx')\n['@', ' ', '/', '.', '*', ' ']\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["You say that you want \"guy\" returned from \"Hi there @guy\" but that conflicts with \"and end up with a space\"."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "\"guy\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\"Hi there @guy\"", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Please edit your question to include what you really want/need to match."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]