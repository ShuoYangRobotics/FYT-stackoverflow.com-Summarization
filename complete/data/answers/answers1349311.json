[[{"text": ["Some of us Python committers, I believe mostly Rigo and Hettinger, went out of their way (on the way to 2.5 I believe) to optimize some special cases of the alas-far-too-common s += something blight, arguing that it was proven that beginners will never be covinced that ''.join is the right way to go and the horrible slowness of the += might be giving Python a bad name.", "Others of us weren't that hot, because they just couldn't possibly optimize every occurrence (or even just a majority of them) to decent performance; but we didn't feel hotly enough on the issue to try and actively block them."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "s += something", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "blight", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "''.join", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["I believe this thread proves we should have opposed them more sternly.", "As it is now, they optimized += in a certain hard-to-predict subset of cases to where it can be maybe 20% faster for particular stupid cases than the proper way (which IS still ''.join) -- just a perfect way to trap beginners into pursuing those irrelevant 20% gains by using the wrong idiom... at the cost, once in a while and from their POV out of the blue, of being hit with a performance loss of 200% (or more, since non-linear behavior IS still lurking there just outside of the corners that Hettinger and Rigo prettied up and put flowers in;-) -- one that MATTERS, one that WILL make them miserable.", "This goes against the grain of Python's \"ideally only one obvious way to do it\" and it feels to me like we, collectively, have lain a trap for beginners -- the best kind, too... those who don't just accept what they're told by their \"betters\", but inquisitively go and question and explore."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "+=", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "''.join", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Ah well -- I give up.", "OP, @mshsayem, go ahead, use += everywhere, enjoy your irrelevant 20% speedups in trivial, tiny, irrelevant cases, and you'd better enjoy them to the hilt -- because one day, when you can't see it coming, on an IMPORTANT, LARGE operation, you'll be hit smack in the midriff by the oncoming trailer truck of a 200% slowdown (unless you get unlucky and it's a 2000% one;-).", "Just remember: if you ever feel that \"Python is horribly slow\", REMEMBER, more likely than not it's one of your beloved loops of += turning around and biting the hand that feeds it."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "+=", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["For the rest of us -- those who understand what it means to say We should forget about small efficiencies, say about 97% of the time, I'll keep heartily recommending ''.join, so we all can sleep in all tranquility and KNOW we won't be hit with a superlinear slowdown when we least expect and least can afford you.", "But for you, Armin Rigo, and Raymond Hettinger (the last two, dear personal friends of mine, BTW, not just co-commiters;-) -- may your += be smooth and your big-O's never worse than N!-)"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "We should forget about small efficiencies, say about 97% of the time", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://shreevatsa.wordpress.com/2008/05/16/premature-optimization-is-the-root-of-all-evil/"}, {"text": "''.join", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["So, for the rest of us, here's a more meaningful and interesting set of measurements:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'r=[str(x)*99 for x in xrange(100,1000)]' 's=\"\".join(r)'\n1000 loops, best of 3: 319 usec per loop\n</code>\n</pre>\n", "senID": 5}, {"text": ["900 strings of 300 chars each, joining the list directly is of course fastest, but the OP is terrified about having to do appends before then.", "But:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'r=[str(x)*99 for x in xrange(100,1000)]' 's=\"\"' 'for x in r: s+=x'\n1000 loops, best of 3: 779 usec per loop\n$ python -mtimeit -s'r=[str(x)*99 for x in xrange(100,1000)]' 'z=[]' 'for x in r: z.append(x)' '\"\".join(z)'\n1000 loops, best of 3: 538 usec per loop\n</code>\n</pre>\n", "senID": 7}, {"text": ["...with a semi-important amount of data (a very few 100's of KB -- taking a measurable fraction of a millisecond every which way), even plain good old .append is alread superior.", "In addition, it's obviously and trivially easy to optimize:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": ".append", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ python -mtimeit -s'r=[str(x)*99 for x in xrange(100,1000)]' 'z=[]; zap=z.append' 'for x in r: zap(x)' '\"\".join(z)'\n1000 loops, best of 3: 438 usec per loop\n</code>\n</pre>\n", "senID": 9}, {"text": ["shaving another tenths of a millisecond over the average looping time.", "Everybody (at least everybody who's totally obsessed abound performance) obviously knows that HOISTING (taking OUT of the inner loop a repetitive computation that would be otherwise performed over and over) is a crucial technique in optimization -- Python doesn't hoist on your behalf, so you have to do your own hoisting in those rare occasions where every microsecond matters."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["I assume x() is slower because you're first building the array and then joining it.", "So you're not only measuring the time that join takes, but also the time that you take to build the array."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In a scenario where you already have an array and you want to create a string out of its elements, join should be faster than iterating through the array and building the string step by step."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You are measuring two distinct operations: the creation of an array of strings, and the concatenation of strings."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import timeit\n    def x():\n        s = []\n        for i in range(100):\n            s.append(\"abcdefg\"[i%7])\n        return ''.join(s)\n    def y():\n        s = ''\n        for i in range(100):\n            s += \"abcdefgh\"[i%7]\n\n    # timeit.timeit(x) returns about 32s\n    # timeit.timeit(y) returns about 23s\n</code>\n</pre>\n", "senID": 1}, {"text": ["From the above it would indeed seem that '+' is a faster operation than join.", "But consider:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n src = []\n    def c():\n        global src\n        s = []\n        for i in range(100):\n            s.append(\"abcdefg\"[i%7])\n        src = s\n    def x2():\n        return ''.join(src)\n    def y2():\n        s = ''\n        for i in range(len(src)):\n            s += src[i]\n        return s\n\n    # timeit.timeit(c) returns about 30s\n    # timeit.timeit(x2) returns about 1.5s\n    # timeit.timeit(y2) returns about 14s\n</code>\n</pre>\n", "senID": 3}, {"text": ["In other words, by timing x() vs y(), your result is polluted by the construction of your source array.", "If you break that out, you find that join is faster."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Furthermore, you're working with small arrays, and your timing numbers just happen to coincide.", "If you increase the size of the array and the length of each string significantly, the differences are more clear:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def c2():\n       global src\n       s = []\n       for i in range(10000):\n           s.append(\"abcdefghijklmnopqrstuvwxyz0123456789\"\n       src = s\n\n   # timeit.timeit(x2, number=10000) returns about 1s\n   # timeit.timeit(y2, number=10000) returns about 80s\n</code>\n</pre>\n", "senID": 6}], [{"text": ["This question is really about what things cost.", "We'll play a bit fast and loose here, subtracting results in similar cases.", "You can decide for yourself if this is a valid method.", "Here are some basic test cases:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import timeit\ndef append_to_list_with_join():\n    s=[]\n    for i in xrange(100):\n        s.append(\"abcdefg\"[i%7])\n    return ''.join(s)\n\ndef append_to_list_with_join_opt():\n    s=[]\n    x = s.append\n    for i in xrange(100):\n        x(\"abcdefg\"[i%7])\n    return ''.join(s)\n\ndef plus_equals_string():\n    s=''\n    for i in xrange(100):\n        s+=\"abcdefg\"[i%7]\n    return s\n\ndef plus_assign_string():\n    s=''\n    for i in xrange(100):\n        s=s+\"abcdefg\"[i%7]\n    return s\n\ndef list_comp_join():\n    return ''.join([\"abcdefg\"[i%7] for i in xrange(100)])\n\ndef list_comp():\n    return [\"abcdefg\"[i%7] for i in xrange(100)]\n\ndef empty_loop():\n    for i in xrange(100):\n    \tpass\n\ndef loop_mod():\n    for i in xrange(100):\n    \ta = \"abcdefg\"[i%7]\n\ndef fast_list_join():\n    return \"\".join([\"0\"] * 100)\n\nfor f in [append_to_list_with_join, append_to_list_with_join_opt, plus_equals_string,plus_assign_string,list_comp_join, list_comp, empty_loop,loop_mod, fast_list_join]:\n    print f.func_name, timeit.timeit(f)\n</code>\n</pre>\n", "senID": 1}, {"text": ["And here is what they cost:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n append_to_list_with_join 25.4540209021\nappend_to_list_with_join_opt 19.9999782794\nplus_equals_string 16.7842428996\nplus_assign_string 14.8312124167\nlist_comp_join 16.329590353\nlist_comp 14.6934344309\nempty_loop 2.3819276612\nloop_mod 10.1424356308\nfast_list_join 2.58149394686\n</code>\n</pre>\n", "senID": 3}, {"text": ["First off, lots of things have unexpected costs in python.", "append_to_list_with_join versus append_to_list_with_join_opt shows that even looking up a method on an object has a non-negligible cost.", "In this case, looking up s.append is one-quarter of the time."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Next, list_comp_join versus list_comp shows that join() is pretty fast: It takes about 1.7 or only 10% of list_comp_join's time."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["loop_mod shows that the greatest part of this test is actually in setting up the data, irrespective of which string construction method is used.", "By inference, the time taken for \"string = string + \", \"string += \", and list comprehension are:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n plus_equals_string = 16.78 - 10.14 = 6.64\nplus_assign_string = 14.83 - 10.14 = 4.69\nlist_comp = 14.69 - 10.14 = 4.55\n</code>\n</pre>\n", "senID": 7}, {"text": ["So as to the OP's question, join() is fast but the time to create the underlying list, whether with list primitives or list comprehension, is comparable to creating the string with string primitives.", "If you already have a list, convert it to a string with join() -- it will be fast."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["The timings the OP presents indicate that constructing lists using concatenate operators is slow.", "In contrast, using list comprehensions is fast.", "If you have to build a list, use a list comprehension."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Finally, let's take three of the OP's closest functions: what is the difference between x, p, and q?", "Let's simplify a bit:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n import timeit\ndef x():\n    s=[]\n    for i in range(100):\n        s.append(\"c\")\n\ndef p():\n    s=[]\n    for i in range(100):\n        s += \"c\"\n\ndef q():\n    s=[]\n    for i in range(100):\n        s = s + [\"c\"]\n\nfor f in [x,p,q]:\n    print f.func_name, timeit.timeit(f)\n</code>\n</pre>\n", "senID": 11}, {"text": ["Here are the results:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n x 16.0757342064\np 87.1533697719\nq 85.0999698984\n</code>\n</pre>\n", "senID": 13}, {"text": ["And here is the disassembly:"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "disassembly", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/3.0/library/dis.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import dis\n&gt;&gt;&gt; dis.dis(x)\n  2           0 BUILD_LIST               0\n              3 STORE_FAST               0 (s)\n\n  3           6 SETUP_LOOP              33 (to 42)\n              9 LOAD_GLOBAL              0 (range)\n             12 LOAD_CONST               1 (100)\n             15 CALL_FUNCTION            1\n             18 GET_ITER\n        &gt;&gt;   19 FOR_ITER                19 (to 41)\n             22 STORE_FAST               1 (i)\n\n  4          25 LOAD_FAST                0 (s)\n             28 LOAD_ATTR                1 (append)\n             31 LOAD_CONST               2 ('c')\n             34 CALL_FUNCTION            1\n             37 POP_TOP\n             38 JUMP_ABSOLUTE           19\n        &gt;&gt;   41 POP_BLOCK\n        &gt;&gt;   42 LOAD_CONST               0 (None)\n             45 RETURN_VALUE\n&gt;&gt;&gt; dis.dis(p)\n  2           0 BUILD_LIST               0\n              3 STORE_FAST               0 (s)\n\n  3           6 SETUP_LOOP              30 (to 39)\n              9 LOAD_GLOBAL              0 (range)\n             12 LOAD_CONST               1 (100)\n             15 CALL_FUNCTION            1\n             18 GET_ITER\n        &gt;&gt;   19 FOR_ITER                16 (to 38)\n             22 STORE_FAST               1 (i)\n\n  4          25 LOAD_FAST                0 (s)\n             28 LOAD_CONST               2 ('c')\n             31 INPLACE_ADD\n             32 STORE_FAST               0 (s)\n             35 JUMP_ABSOLUTE           19\n        &gt;&gt;   38 POP_BLOCK\n        &gt;&gt;   39 LOAD_CONST               0 (None)\n             42 RETURN_VALUE\n&gt;&gt;&gt; dis.dis(q)\n  2           0 BUILD_LIST               0\n              3 STORE_FAST               0 (s)\n\n  3           6 SETUP_LOOP              33 (to 42)\n              9 LOAD_GLOBAL              0 (range)\n             12 LOAD_CONST               1 (100)\n             15 CALL_FUNCTION            1\n             18 GET_ITER\n        &gt;&gt;   19 FOR_ITER                19 (to 41)\n             22 STORE_FAST               1 (i)\n\n  4          25 LOAD_FAST                0 (s)\n             28 LOAD_CONST               2 ('c')\n             31 BUILD_LIST               1\n             34 BINARY_ADD\n             35 STORE_FAST               0 (s)\n             38 JUMP_ABSOLUTE           19\n        &gt;&gt;   41 POP_BLOCK\n        &gt;&gt;   42 LOAD_CONST               0 (None)\n             45 RETURN_VALUE\n</code>\n</pre>\n", "senID": 15}, {"text": ["The loops are nearly identical.", "The comparison amounts to CALL_FUNCTION+POP_TOP vs. INPLACE_ADD+STORE_FAST vs. BUILD_LIST+BINARY_ADD+STORE_FAST.", "However, I can't give a more low-level explanation than that -- I just can't find costs of python bytecodes on the Net.", "However, you might get some inspiration from looking at Doug Hellmann's Python Module of the Week posting on dis."], "childNum": 1, "tag": "p", "senID": 16, "childList": [{"text": "dis", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://www.doughellmann.com/PyMOTW/dis/index.html"}]}], [{"text": ["Interesting: I've done some tests where the size of the string changes, and this is what I found:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def x():\n    x = \"a\" * 100\n    s=[]\n    for i in range(100):\n        # Other codes here...\n        s.append(x)\n    return ''.join(s)\n\ndef z():\n    x = \"a\" * 100\n    s=''\n    for i in xrange(100):\n        # Other codes here...\n        s=s+x\n    return s\n\nfrom timeit import timeit\nprint \"x:\", timeit(x, number=1000000)\nprint \"z:\", timeit(z, number=1000000)\n</code>\n</pre>\n", "senID": 1}, {"text": ["For strings of length 1 (x = \"a\" * 1):"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "x = \"a\" * 1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n x: 27.2318270206\nz: 14.4046051502\n</code>\n</pre>\n", "senID": 3}, {"text": ["For strings of length 100:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n x: 30.0796670914\nz: 21.5891489983\n</code>\n</pre>\n", "senID": 5}, {"text": ["And for strings of length 1000, running timeit 100,000 times instead of 1,000,000"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n x: 14.1769361496\nz: 31.4864079952\n</code>\n</pre>\n", "senID": 7}, {"text": ["Which, if my reading of Objects/stringobject.c is correct, makes sense."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Objects/stringobject.c", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["It appears, on a first reading, that the String.join algorithm (edge-cases aside) is:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n def join(sep, sequence):\n    size = 0\n    for string in sequence:\n        size += len(string) + len(sep)\n\n    result = malloc(size)\n\n    for string in sequence:\n        copy string into result\n        copy sep into result\n\n    return result\n</code>\n</pre>\n", "senID": 10}, {"text": ["So this will require more or less O(S) steps (where S is the sum of the lengths of all the strings being joined)."], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "O(S)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "S", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["There's a difference between += and + with strings -- if there's no other references to \"x\", x+=y can just append to x, rather than having to take a copy of the string to append to -- which is the same benefit you get from using \"\".join()."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The main benefit from \"\".join() over + or += is that join() should always give linear performance, while in many cases +/+= will give quadratic performance (ie, when you double the amount of text, you quadruple the amount of time taken).", "But this will only matter with a lot of text, not merely 100 bytes, and I think it won't get triggered if you only have one reference to the string you're appending to."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "think", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["In detail:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Your best case performance for string concatenation is to look at every character in the final string once.", "\"\".join() does that naturally -- it has all the information it needs to right from the start. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["However a+=b can work in two ways, it can either just add \"b\" to an existing string, in which case it only needs to look at the characters in \"b\", or it can have to look at the characters in \"a\" too."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In C, strcat() always looks at all the characters in both strings, so it's works badly always.", "In Python, however, the string length is stored, so the string can be extended as long as it's not referenced elsewhere -- and you get good performance by only copying the characters in \"b\".", "If it is referenced elsewhere, python will make a copy of \"a\" first, then add \"b\" to the end, giving you bad performance.", "If you're appending five strings in this manner, your time taken will be:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n ab = a+b       # Time is a + b\nabc = ab+c     # Time is (a+b) + c\nabcd = abc+d   # Time is (a+b+c) + d\nabcde = abcd+e # Time is (a+b+c+d) + e\n</code>\n</pre>\n", "senID": 6}, {"text": ["which if a,b,c,d,e are all roughly the same size, say, n, is n*(n-1)/2-1 operations, or essentially n-squared."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["To get the bad behaviour for x+=y, try:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def a(n=100):\n    res = \"\"\n    for k in xrange(n):\n        v=res\n        res += \"foobar\"\n    return res\n</code>\n</pre>\n", "senID": 9}, {"text": ["Even though v isn't actually used, it's enough to trigger the slower path for += and get the bad behaviour that worries people."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["I believe += wasn't introduced until Python 2.0, so it wasn't possible to append efficiently without using something like \"\".join() in Python 1.6 and earlier."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["In addition to what the others said, 100 1-char strings is really small.", "(I'm kind of surprised you get separation of results at all.", ")  That's the sort of dataset that fits in your processor cache.", "You're not going to see asymptotic performance on a microbenchmark."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "really small", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["As to why q is a lot slower:  when you say "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "q", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n l += \"a\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["you are appending the string \"a\" to the end of l, but when you say"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "\"a\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "l", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n l = l + [\"a\"]\n</code>\n</pre>\n", "senID": 3}, {"text": ["you are creating a new list with the contents of l and [\"a\"] and then reassigning the results back to l. Thus new lists are constantly being generated."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "l", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[\"a\"]", "childNum": 0, "tag": "code", "childList": []}, {"text": "l", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["String concatenation was a lot slower before Python 2.5, when it still created a new copy for every string concatenation rather than appending to the original, leading to join() becoming a popular workaround."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's an old benchmark demonstrating the old problem:\nhttp://www.skymind.com/~ocrow/python%5Fstring/"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.skymind.com/~ocrow/python%5Fstring/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.skymind.com/~ocrow/python%5Fstring/"}]}], [{"text": ["I have figured out the answer from the answers posted here by experts.", "Python string concatenation (and timing measurements) depends on these (as far as I've seen):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "Number of concatenations", "tag": "none", "senID": 1}, {"text": "Average length of strings", "tag": "none", "senID": 2}, {"text": "Number of function callings", "tag": "none", "senID": 3}]}, {"text": ["I have built a new code that relates these.", "Thanks to Peter S Magnusson, sepp2k, hughdbrown, David Wolever and others for indicating important points I had missed earlier.", "Also, in this code I might have missed something.", "So, I highly appreciate any replies pointing our errors, suggestions, criticisms etc.", "After all, I am here for learning.", "Here is my new code:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from timeit import timeit\n\nnoc = 100\ntocat = \"a\"\ndef f_call():\n    pass\n\ndef loop_only():\n    for i in range(noc):\n        pass\n\ndef concat_method():\n    s = ''\n    for i in range(noc):\n        s = s + tocat\n\ndef list_append():\n    s=[]\n    for i in range(noc):\n        s.append(tocat)\n    ''.join(s)\n\ndef list_append_opt():\n    s = []\n    zap = s.append\n    for i in range(noc):\n        zap(tocat)\n    ''.join(s)\n\ndef list_comp():\n    ''.join(tocat for i in range(noc))\n\ndef concat_method_buildup():\n    s=''\n\ndef list_append_buildup():\n    s=[]\n\ndef list_append_opt_buildup():\n    s=[]\n    zap = s.append\n\ndef function_time(f):\n    return timeit(f,number=1000)*1000\n\nf_callt = function_time(f_call)\n\ndef measure(ftuple,n,tc):\n    global noc,tocat\n    noc = n\n    tocat = tc\n    loopt = function_time(loop_only) - f_callt\n    buildup_time = function_time(ftuple[1]) -f_callt if ftuple[1] else 0\n    total_time = function_time(ftuple[0])\n    return total_time, total_time - f_callt - buildup_time - loopt*ftuple[2]\n\nfunctions ={'Concat Method\\t\\t':(concat_method,concat_method_buildup,True),\n            'List append\\t\\t\\t':(list_append,list_append_buildup,True),\n            'Optimized list append':(list_append_opt,list_append_opt_buildup,True),\n            'List comp\\t\\t\\t':(list_comp,0,False)}\n\nfor i in range(5):\n    print(\"\\n\\n%d concatenation\\t\\t\\t\\t10'a'\\t\\t\\t\\t 100'a'\\t\\t\\t1000'a'\"%10**i)\n    print('-'*80)\n    for (f,ft) in functions.items():\n        print(f,\"\\t|\",end=\"\\t\")\n        for j in range(3):\n            t = measure(ft,10**i,'a'*10**j)\n            print(\"%.3f %.3f |\" % t,end=\"\\t\")\n        print()\n</code>\n</pre>\n", "senID": 5}, {"text": ["And here is what I have got.", "[In the time column two times (scaled) are shown: first one is the total function execution time, and the second time is the actual(?", ") concatenation time.", "I have deducted the function calling time, function buildup time(initialization time), and iteration time.", "Here I am considering a case where it can't be done without loop (say more statement inside)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n 1 concatenation                 1'a'                  10'a'               100'a'\n-------------------     ----------------------  -------------------  ----------------\nList comp               |   2.310 2.168       |  2.298 2.156       |  2.304 2.162\nOptimized list append   |   1.069 0.439       |  1.098 0.456       |  1.071 0.413\nConcat Method           |   0.552 0.034       |  0.541 0.025       |  0.565 0.048\nList append             |   1.099 0.557       |  1.099 0.552       |  1.094 0.552\n\n\n10 concatenations                1'a'                  10'a'               100'a'\n-------------------     ----------------------  -------------------  ----------------\nList comp               |   3.366 3.224       |  3.473 3.331       |  4.058 3.916\nOptimized list append   |   2.778 2.003       |  2.956 2.186       |  3.417 2.639\nConcat Method           |   1.602 0.943       |  1.910 1.259       |  3.381 2.724\nList append             |   3.290 2.612       |  3.378 2.699       |  3.959 3.282\n\n\n100 concatenations               1'a'                  10'a'               100'a'\n-------------------     ----------------------  -------------------  ----------------\nList comp               |   15.900 15.758     |  17.086 16.944     |  20.260 20.118\nOptimized list append   |   15.178 12.585     |  16.203 13.527     |  19.336 16.703\nConcat Method           |   10.937 8.482      |  25.731 23.263     |  29.390 26.934\nList append             |   20.515 18.031     |  21.599 19.115     |  24.487 22.003\n\n\n1000 concatenations               1'a'                  10'a'               100'a'\n-------------------     ----------------------  -------------------  ----------------\nList comp               |   134.507 134.365   |  143.913 143.771   |  201.062 200.920\nOptimized list append   |   112.018 77.525    |  121.487 87.419    |  151.063 117.059\nConcat Method           |   214.329 180.093   |  290.380 256.515   |  324.572 290.720\nList append             |   167.625 133.619   |  176.241 142.267   |  205.259 171.313\n\n\n10000 concatenations              1'a'                  10'a'               100'a'\n-------------------     ----------------------  -------------------  ----------------\nList comp               |   1309.702 1309.560 |  1404.191 1404.049 |  2912.483 2912.341\nOptimized list append   |   1042.271 668.696  |  1134.404 761.036  |  2628.882 2255.804\nConcat Method           |   2310.204 1941.096 |  2923.805 2550.803 |  STUCK    STUCK\nList append             |   1624.795 1251.589 |  1717.501 1345.137 |  3182.347 2809.233\n</code>\n</pre>\n", "senID": 7}, {"text": ["To sum up all these I have made this decisions for me:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Finally, I say it again that I am a noob and trying to learn python more deeply.", "So, it is not unusual that there will be mistakes (error) in my observations.", "So, comment on this and suggest me if I am taking a wrong route.", "Thanks to all for participating. "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}]]