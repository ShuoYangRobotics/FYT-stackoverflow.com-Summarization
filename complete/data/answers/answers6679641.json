[[{"text": ["This seems like a job for itertools."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; first = list(itertools.takewhile(str.isalpha, l))\n&gt;&gt;&gt; second = list(itertools.dropwhile(str.isalpha, l))\n&gt;&gt;&gt; first\n['a', 'b', 'c']\n&gt;&gt;&gt; second\n['1', 'a', '2', 'b']\n</code>\n</pre>\n", "senID": 1}, {"text": ["This needs to be altered if l is an iterator rather than a sequence."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "l", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def bisect_iter(pred, i):\n...     i1, i2 = itertools.tee(i)\n...     return itertools.takewhile(pred, i1), itertools.dropwhile(pred, i2)\n... \n&gt;&gt;&gt; i1, i2 = bisect_iter(str.isalpha, iter(l))\n&gt;&gt;&gt; list(i1)\n['a', 'b', 'c']\n&gt;&gt;&gt; list(i2)\n['1', 'a', '2', 'b']\n</code>\n</pre>\n", "senID": 3}, {"text": ["The downside of tee is that the initial values are cached and tested twice (by both takewhile and dropwhile).", "That's wasteful.", "But caching values is unavoidable if you want to both accept and return iterators. "], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "tee", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "takewhile", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "dropwhile", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["However, if you can return lists from an iterator, I can think of one solution that doesn't make extra copies or tests, and it's very close to yours:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def bisect_iter_to_list(pred, it):\n...     l1 = []\n...     for i in it:\n...         if pred(i):\n...             l1.append(i)\n...         else:\n...             l2 = [i]\n...             l2.extend(it)\n...     return l1, l2\n... \n&gt;&gt;&gt; bisect_iter_to_list(str.isalpha, iter(l))\n(['a', 'b', 'c'], ['1', 'a', '2', 'b'])\n</code>\n</pre>\n", "senID": 6}, {"text": ["The only sneaky bit is that where there would normally be a break statement (i.e.", "after the else clause), I've simply consumed the iterator, causing the for loop to terminate early. "], "childNum": 3, "tag": "p", "senID": 7, "childList": [{"text": "break", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "else", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Finally, if you still want to return iterators, but don't want to do extra tests, here's a variation on the above that I believe is optimal."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "still", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def bisect_any_to_iter(pred, it):\n...     it = iter(it)\n...     head = []\n...     for i in it:\n...         if pred(i):\n...             head.append(i)\n...         else:\n...             tail = itertools.chain([i], it)\n...             break\n...     return iter(head), tail\n... \n&gt;&gt;&gt; a, b = bisect_iter_to_iter(str.isalpha, iter(l))\n&gt;&gt;&gt; list(a)\n['a', 'b', 'c']\n&gt;&gt;&gt; list(b)\n['1', 'a', '2', 'b']\n</code>\n</pre>\n", "senID": 9}], [{"text": ["How about this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def split_at_first_false(pred, seq):\n    for i, item in enumerate(seq):\n        if not pred(item):\n            return seq[:i], seq[i:]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["What about this?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def split_at_first_false(pred, seq):\n    pos = 0\n    for item in seq:\n        if not pred(item):\n            return seq[:pos], seq[pos:]\n        pos += 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Don't shy away from iterators, this is a perfect case for using one.", "Once the first false item is hit, use the same iterator to just fill out the rest of the items into the second list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def split_at_false(pred, seq):\n    # if seq is not already an iterator, make it one\n    if not hasattr(seq,'next'):\n        seq = iter(seq)\n\n    first, second = [], []\n    for item in seq:\n        if not pred(item):\n            second.append(item)\n            break\n        first.append(item)\n\n    # at this point, seq points to the first item\n    # after the false item, just add it and all the \n    # rest to the second list\n    second.extend(seq)\n\n    return first, second\n\nis_odd = lambda x : x % 2    \nprint split_at_false(is_odd, [1])    \nprint split_at_false(is_odd, [1,2,3,4,5])\nprint split_at_false(is_odd, [2,3,4,5,6])\nprint split_at_false(is_odd, [])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ([1], [])\n([1], [2, 3, 4, 5])\n([], [2, 3, 4, 5, 6])\n([], [])\n</code>\n</pre>\n", "senID": 3}, {"text": ["No tee'ing, no extra list storage, no iterating twice over the list, no slicing, just an iterator."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Try that:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def split_at_first_false(pred, seq):\n        index = 0\n        while index &lt; len(seq):\n            if not pred(seq[index]):\n                 return seq[:index], seq[index+1:]\n            index+=1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Try the following code :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n data = \"abc1a2b\"\n\ndef split_at_first_false(pred, seq):\n    if not isinstance(seq, list):\n       seq = list(seq)\n    for i,x in enumerate(seq):\n        if not pred(x):\n            return seq[:i], seq[i:]\n    return seq, []\n</code>\n</pre>\n", "senID": 1}]]