[[{"text": ["You need to know whether multi-byte types are big or little endian and whether it's signed or unsigned.", "Assuming the two bytes are an unsigned, big-endian short, I would do the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; buf = '\\xAE\\x02\\x59'\n&gt;&gt;&gt; from struct import unpack\n&gt;&gt;&gt; unpack('&gt;BH', buf)\n(174, 601)\n</code>\n</pre>\n", "senID": 1}, {"text": ["'>' means big endian.", "'B' is the first unsigned byte, which you don't want.", "'H' is an unsigned short."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["There are two easy ways to do it.", "One way would be to convert your buffer to a hexdecimal integer, and use a bit-mask to get the last 32 bits.", "The other is to use the slice operator to get the last 4 characters, and interpret that remainder as a hexadecimal integer."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; buffer = 'AE0259'\n&gt;&gt;&gt; print int(buffer, 16) &amp; 0xFFFF\n601\n&gt;&gt;&gt; print int(buffer[-4:], 16) \n601\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT - eryksun has the right answer, but I wanted to update my example for the actual use case."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; buffer = '\\xAE\\x02\\x59'\n&gt;&gt;&gt; # print the integer value of the last two binary \"characters\"\n&gt;&gt;&gt; print sum((ord(x) &lt;&lt; i*8 for i,x in enumerate(buffer[:-2-1:-1])))\n601\n&gt;&gt;&gt; # print the integer value all binary \"characters\" \n&gt;&gt;&gt; # with a bitmask of the lower 32 digits\n&gt;&gt;&gt; print sum((ord(x) &lt;&lt; i*8 for i,x in enumerate(buffer[::-1]))) &amp; 0xFFFF\n601\n</code>\n</pre>\n", "senID": 3}], [{"text": ["There's a pure python module that might help you handling bit operation:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["code.google.com/p/python-bitstring"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "code.google.com/p/python-bitstring", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/python-bitstring"}]}], [{"text": ["If you only need to do byte unpacking then the struct module is your friend (see eryksun's answer) as is the bytearray type:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "struct", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/functions.html#bytearray", "text": "bytearray", "childNum": 1, "tag": "a", "childList": [{"text": "bytearray", "tag": "code"}]}, {"text": "bytearray", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; ba = bytearray('\\xae\\x02\\x59')\n</code>\n</pre>\n", "senID": 1}, {"text": ["This allows you to index and slice at the byte level"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; hex(ba[0])\n'0xae'\n&gt;&gt;&gt; ba[1:3]\nbytearray(b'\\x02Y')\n</code>\n</pre>\n", "senID": 3}, {"text": ["In terms of converting multiple bytes to ints this is quite helpful, but you're unlikely to gain much over struct unless you have some unusual byte lengths.", "Your two byte conversion to int becomes:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "struct", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; (ba[1] &lt;&lt; 8) + ba[2]\n601\n</code>\n</pre>\n", "senID": 5}, {"text": ["You say in a comment that you'd like a general way of doing bitwise slicing too.", "I'm afraid there isn't one - your best place to start is with shifting and masking from a bytearray.", "That's why modules like bitstring are useful (I wrote it btw) - you get someone else to do all the tedious error-prone stuff!"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "bitstring", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://python-bitstring.googlecode.com"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; b = bitstring.Bits(ba)\n&gt;&gt;&gt; b[8:].uint\n601\n&gt;&gt;&gt; b.unpack('hex:8, uint:16')\n['ae', 601]\n</code>\n</pre>\n", "senID": 7}], [{"text": ["if buffer is a string, you could \"cut off\" the remaining characters by trimming the string like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "buffer", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n newstr = buffer[1:]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["@ironchefpython suggested what you should use, except that your comment indicates that your buffer actually consists of binary data.", "Assuming that is the case, this solution should work, though it is not very elegant:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from struct import unpack\ndef strmask(buffer, mask):\n   #calculate the number of bytes to extract\n   mask_length = mask.bit_length() / 8  + (1 if mask.bit_length() % 8 &gt; 0 else 0)\n   #extract those bytes and put them into a Python int, then perform the mask\n   return mask &amp; reduce(lambda l,r: (l&lt;&lt;8)+r, unpack(\"B\" * mask_length, buffer[-1 * mask_length:]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This yields the result you want -for example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print strmask('\\xAE\\x02\\x59', 0xFFFF)\n601\n</code>\n</pre>\n", "senID": 3}]]