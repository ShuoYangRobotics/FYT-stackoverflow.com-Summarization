[[{"text": ["You don't need two classes here.", "Here's your example code written in a more concise fashion."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class ChildClass:\n    def __init__(self, stream):\n        idx = stream.read_ui16()\n        self.name = self.constant_pool[idx]\n\ndef makeChildren(stream):\n    ChildClass.constant_pool = ConstantPool(stream)\n    return [ChildClass(stream) for i in range(stream.read_ui16())]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Welcome to Python.", "Classes are mutable at runtime.", "Enjoy."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Despite my \"bit patronizing\" comment (fair play to call it that!", "), there are actually ways to achieve what you want: a different avenue of inheritance.", "A couple:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's the decorator approach, since it's the most straightforward:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def matryoshka(cls):\n\n    # get types of classes\n    class classtypes:\n        pass\n    classtypes = (type, type(classtypes))\n\n    # get names of all public names in outer class\n    directory = [n for n in dir(cls) if not n.startswith(\"_\")]\n\n    # get names of all non-callable attributes of outer class\n    attributes = [n for n in directory if not callable(getattr(cls, n))]\n\n    # get names of all inner classes\n    innerclasses = [n for n in directory if isinstance(getattr(cls, n), classtypes)]\n\n    # copy attributes from outer to inner classes (don't overwrite)\n    for c in innerclasses:\n        c = getattr(cls, c)\n        for a in attributes:\n            if not hasattr(c, a):\n                setattr(c, a, getattr(cls, a))\n\n    return cls\n</code>\n</pre>\n", "senID": 2}, {"text": ["Here is a simple example of its use:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n @matryoshka\nclass outer(object):\n\n    answer = 42\n\n    class inner(object):\n\n        def __call__(self):\n            print self.answer\n\nouter.inner()()   # 42\n</code>\n</pre>\n", "senID": 4}, {"text": ["However, I can't help but think some of the ideas suggested in other answers would serve you better."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Well, the following works (further simplified from your example).", "Note that you don't have to \"declare\" member variables at class level like C++/C#/Java etc, just set them on self within __init__:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class ParentClass:\n    def __init__(self):\n        self.constant_pool = [\"test\"]\n        self.ChildClass.constant_pool = self.constant_pool\n        self.children = [self.ChildClass()]\n\n    class ChildClass:\n        def __init__(self):\n            self.name = self.constant_pool[0]\n            print \"child name is\", self.name\n\np = ParentClass() # Prints \"child name is test\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that you could still do the same sort of thing without the child classes being nested."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can access the parent class through its name:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class ChildClass:\n\n    name = None\n\n    def __init__(self, stream):\n        idx = stream.read_ui16()\n        self.name = ParentClass.constant_pool[idx]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then again, I'm not sure I understand what you are trying to achieve."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Your question uses the word subclass, so I'm keying from that to interpret your question.", "As with the others who have answered, I am not certain I understand what you are looking for."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class ParentClass(object):\n  constant_pool = [c1, c2, c3]\n  def __init__(self):\n    # anything not included in your question\n\nclass ChildClass(ParentClass):\n  def __init__(self, stream):\n    ParentClass.__init__(self)\n    self.name = ParentClass.constant_pool[stream.read_ui16()]\n\nstream = get_new_stream()\nchildren = []\nfor count in range(stream.read_ui16()):\n  children.append(ChildClass(stream))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This code uses inheritance to derive ChildClass from ParentClass (and all methods, etc).", "The constant_pool is an attribute of ParentClass itself, though it is OK to treat as an attribute of any instance of ParentClass or ChildClass (saying self.constant_pool within ChildClass.__init__ would be equivalent to the above but, in my view, misleading)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "self.constant_pool", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "ChildClass.__init__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Nesting the class definitions is not necessary.", "Nesting the definition of ChildClass within ParentClass just means that ChildClass is an attribute of ParentClass, nothing more.", "It does not make instances of ChildClass inherit anything from ParentClass."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Another alternative design to consider:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When you find yourself trying to use classes as namespaces, it might make more sense to put the inner classes into a module of their own and make what were the attributes of the outer class global variables.", "In other words, if you never intend to instantiate your ParentClass, then it's just serving as a glorified module."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "ParentClass", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Global variables get a bad rap in most programming languages, but they are not truly global in Python, and are nicely encapsulated to the module."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]