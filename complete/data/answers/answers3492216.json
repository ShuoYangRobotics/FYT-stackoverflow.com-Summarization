[[{"code": "<pre>\n<code>\n &gt;&gt;&gt; def f():\n...   x = (set(),)\n...   y = set([0])\n...   x[0] |= y\n...   return   \n... \n&gt;&gt;&gt; import dis\n&gt;&gt;&gt; dis.dis(f)\n  2           0 LOAD_GLOBAL              0 (set)\n              3 CALL_FUNCTION            0\n              6 BUILD_TUPLE              1\n              9 STORE_FAST               0 (x)\n\n  3          12 LOAD_GLOBAL              0 (set)\n             15 LOAD_CONST               1 (0)\n             18 BUILD_LIST               1\n             21 CALL_FUNCTION            1\n             24 STORE_FAST               1 (y)\n\n  4          27 LOAD_FAST                0 (x)\n             30 LOAD_CONST               1 (0)\n             33 DUP_TOPX                 2\n             36 BINARY_SUBSCR       \n             37 LOAD_FAST                1 (y)\n             40 INPLACE_OR          \n             41 ROT_THREE           \n             42 STORE_SUBSCR        \n\n  5          43 LOAD_CONST               0 (None)\n             46 RETURN_VALUE\n</code>\n</pre>\n", "senID": 0}, {"text": ["This shows that the statement x[0] |= y is implemented by calling x[0].__ior__(y) and then assigning the returned value to x[0]."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "x[0] |= y", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x[0].__ior__(y)", "childNum": 0, "tag": "code", "childList": []}, {"text": "x[0]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["set implements in-place |= by having set.__ior__ return self.", "However, the assignment to x[0] still takes place.", "The fact that it's assigning the same value that was already there is irrelevant; it fails for the same reason that:"], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "set", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "|=", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "set.__ior__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "self", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "x[0]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n x = (set(),)\nx[0] = x[0]\n</code>\n</pre>\n", "senID": 3}, {"text": ["fails."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n foo[0] |= set(range(5))\n</code>\n</pre>\n", "senID": 0}, {"text": ["doesn't work, because what you wanted to achieve is:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n foo[0] = foo[0] | set(range(5))\n</code>\n</pre>\n", "senID": 2}, {"text": ["and you can't assign new elements to an old tuple, because they are immutable.", "For example you cant do this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n x = (0, 1, 2)\nx[0] = 3\n</code>\n</pre>\n", "senID": 4}, {"text": ["When you are running update, you don't change references in the tuple, but only object behind the reference.", "You could also do this like this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n x = set()\ny = (x,)\nx.update(set(range(5))\n</code>\n</pre>\n", "senID": 6}, {"text": ["as you can see you don't change the tuple, but x (and y[0]) will be changed."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "y[0]", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n x |= y\n</code>\n</pre>\n", "senID": 8}, {"text": ["and "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n x.update(y)\n</code>\n</pre>\n", "senID": 10}, {"text": ["aren't the same, because update works in place and x |= y will create a new object (x | y) and store it under name x."], "childNum": 4, "tag": "p", "senID": 11, "childList": [{"text": "update", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x |= y", "childNum": 0, "tag": "code", "childList": []}, {"text": "(x | y)", "childNum": 0, "tag": "code", "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["In your example foo is a tuple.", "Tuples in python are inmutable, this means that you cannot change the reference of any tuple element - foo[0] in your case.", "Things like the following can't be done:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Tuples", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#tuple"}, {"text": "foo[0]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = ('foo','bar')\n&gt;&gt;&gt; x[0]='foo2'\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: 'tuple' object does not support item assignment\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could use a list instead"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; foo = [set(),None]\n&gt;&gt;&gt; foo\n[set([]), None]\n&gt;&gt;&gt; foo[0] |= set(range(5))\n&gt;&gt;&gt; foo\n[set([0, 1, 2, 3, 4]), None]\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Tuples are immutable.", "By trying to assign to foo[0], you are attempting to change a value that the tuple stores (a reference to a set).", "When you use the update() function, you are not changing the reference, but instead the actual set.", "Because the reference is the same, this is allowed."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "foo[0]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "update()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["Tuples are immutable so u cannot reassign values to it.", "But if a tuple contains a mutable type such as list or set u can update them.", "now in your case when u use '|=' u actually first update the set (which is a value in the tuple) then assign it to tuple which causes the exception.", "Exception is thrown after the updation of the set."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In the next case u r simply updating the set so there is no exception.", "Refer to http://docs.python.org/reference/datamodel.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/reference/datamodel.html", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html"}]}], [{"text": ["Because there are multiple side-effects.", "Try to avoid that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That's what the "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Correct.", "First the set mutation is done."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Then the tuple mutation is attempted and fails."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Correct.", "The set is mutated.  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["No.", "The first statement involves explicit assignment -- changing the tuple -- which is forbidden."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["The second statement updates a member of an immutable tuple, an operation that is not forbidden, but is suspicious as pushing the envelope."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["But the Legalism Scholar argues, aren't they supposed to be the same?", "Or similar?", "No."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "But", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Updating the tuple object (via assignment) is forbidden."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Updating a member of an existing tuple object (via a mutator function) is not forbidden."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["The best way to explain this is to show it \"algebraically\":"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n foo[0] |= set(range(5))\nfoo[0] = set.__ior__(foo[0], set(range(5)))\ntuple.__setitem__(foo, 0, set.__ior__(foo[0], set(range(5))))\n\nfoo[0].update(set(range(5)))\nset.__ior__(foo[0], set(range(5)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["As you can see, the update form is not the same, it modifies foo[0] in place.", "__or__ generates a new set from the elements of the left and right operands.", "This is then assigned back to foo."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "update", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo[0]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__or__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Note that for simplicity, the expansions that aren't helpful to the problem are not expanded (such as foo[0] -&gt; tuple.__getitem__(foo, 0))."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "foo[0] -&gt; tuple.__getitem__(foo, 0)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The TypeError thrown is in tuple.__setitem__.", "tuple does not allow its items references to be replaced.", "The update form does not touch foo in any way (ie.", "it doesn't not invoke tuple.__setitem__)."], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": "TypeError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tuple.__setitem__", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}, {"text": "update", "childNum": 0, "tag": "code", "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "childList": []}, {"text": "tuple.__setitem__", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["That explains the behaviour you are observing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The underlying problem, is that changing the value of a tuple is a violation of contract.", "You should not try doing it.", "Since you can have any object in a tuple, there are loopholes you can exploit, but then you get the kind of weird behaviour you are observing."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Tuple items should be frozenset instead of set.", "If you do this, you will get a consistent behaviour, and no unwanted side-effect on error."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "frozenset", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}]]