[[{"text": ["You could try re.findall():"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "re.findall()", "tag": "a", "pos": 0, "childList": [{"text": "re.findall()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/re.html#re.findall"}, {"text": "re.findall()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a='05 03 04 01 0A  The Header 03 08 0B BD AF  The PAYLOAD 0D 0A  The Footer'\n&gt;&gt;&gt; re.findall(r\"\\b[0-9A-F]{2}\\b\", a)\n['05', '03', '04', '01', '0A', '03', '08', '0B', 'BD', 'AF', '0D', '0A']\n</code>\n</pre>\n", "senID": 1}, {"text": ["The \\b in the regular expression matches a \"word boundary\"."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "\\b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Of course, your input is ambiguous if the serial monitor inserts something like THIS BE THE HEADER."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "THIS BE THE HEADER", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["It might be easier to find all the hexadecimal numbers, assuming the inserted strings won't contain a match:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; data = '05 03 04 01 0A  The Header 03 08 0B BD AF  The PAYLOAD 0D 0A  The Footer'\n&gt;&gt;&gt; import re\n&gt;&gt;&gt; pattern = re.compile(\"[0-9A-F]{2} \")\n&gt;&gt;&gt; \"\".join(pattern.findall(data))\n'05 03 04 01 0A 03 08 0B BD AF AD 0D 0A '\n</code>\n</pre>\n", "senID": 1}, {"text": ["Otherwise you could use the fact that the inserted strings are preceed by two spaces:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; data = '05 03 04 01 0A  The Header 03 08 0B BD AF  The PAYLOAD 0D 0A  The Footer'\n&gt;&gt;&gt; re.sub(\"(  .*?)(?=( [0-9A-F]{2} |$))\",\"\",data)\n'05 03 04 01 0A 03 08 0B BD AF 0D 0A'\n</code>\n</pre>\n", "senID": 3}, {"text": ["This uses a look ahead to work out when the inserted string ends.", "It looks for either a hexadecimal string surround by spaces or the end of the source string."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Using your regex"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n hexa = '([0-9A-F]{2} )+'\n\" \".join(re.findall(hexa, line))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["While you already received two answers that find you all hexadecimal numbers, here's the same with a direct regular expression that finds you all text that does not look like a hexadecimal number (assuming that's two letter/digits in uppercase / lowercase 0-9 and A-F range, followed by a space)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Something like this (sorry, I'm not a pythoneer, but you get the idea):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n newstring = re.sub(r\"[^ ]+(?&lt;![0-9A-Fa-f ]{2}|^.)\", \"\", yourstring)\n</code>\n</pre>\n", "senID": 2}, {"text": ["It works by \"looking back\".", "It finds every consecutive non-space substring, then negatively looks back with (?&lt;!....).", "It says: \"if the previous two characters were not a hex number, then succeed\".", "The little ^.", "at the end prevents to incorrectly match the first character of the string."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "(?&lt;!....)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "^.", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Edit"], "childNum": 0, "tag": "h2", "senID": 4, "childList": []}, {"text": ["As suggested by Alan Moore, here's the same idea with a positive lookahead expression:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n newstring = re.sub(r\"(?&gt;\\b[0-9A-Fa-f ]{2}\\b)\", \"\", yourstring)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Why regexp?", "More pythonic for me is (fixed for hexdigit not regular digit):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n command='05 03 04 01 0A  The Header 03 08 0B BD AF  The PAYLOAD 0D 0A  The Footer'\nprint ' '.join(com for com in command.split()\n               if len(com)==2 and all(c.upper() in '0123456789ABCDEF' for c in com))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["How about a solution that actually uses regex negation?", ";)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n result = re.sub(r\"[ ]+(?:(?!\\b[0-9A-F]{2}\\b).)+\", \"\", subject)\n</code>\n</pre>\n", "senID": 1}]]