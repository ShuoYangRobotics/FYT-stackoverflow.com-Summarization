[[{"text": ["s!foo!bar!", "is the same as the more common s/foo/bar/, except that foo and bar can contain unescaped slashes without causing problems.", "What it does is, it replaces the first occurence of the regex foo with bar.", "The version with g replaces all occurences."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "s!foo!bar!", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "s/foo/bar/", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["It's doing exactly the same as $var =~ s///.", "i.e.", "performing a search and replace within the $var variable."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "$var =~ s///", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "$var", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["In Perl you can define the delimiting character following the s. Why ?", "So, for example, if you're matching '/', you can specify another delimiting character ('!", "' in this case) and not have to escape or backtick the character you're matching.", "Otherwise you'd end up with (say)"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n s/;/\\//g;\n</code>\n</pre>\n", "senID": 2}, {"text": ["which is a little more confusing."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Perlre has more info on this."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Perlre", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://perldoc.perl.org/perlre.html"}]}], [{"text": ["Perl lets you choose the delimiter for many of its constructs.", "This makes it easier to see what is going on in expressions like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $str =~ s{/foo/bar/baz/}{/quux/};\n</code>\n</pre>\n", "senID": 1}, {"text": ["As you can see though, not all delimiters have the same effects.", "Bracketing characters (&lt;&gt;, [], {}, and ()) use different characters for the beginning and ending.", "And ?, when used as a delimiter to a regex, causes the regexes to match only once between calls to the reset() operator."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "&lt;&gt;", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "[]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "{}", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "?", "childNum": 0, "tag": "code", "childList": []}, {"text": "reset()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You may find it helpful to read perldoc perlop (in particular the sections on m/PATTERN/msixpogc, ?PATTERN?, and s/PATTERN/REPLACEMENT/msixpogce)."], "childNum": 7, "tag": "p", "senID": 3, "childList": [{"text": "perldoc perlop", "tag": "a", "pos": 0, "childList": [{"text": "perldoc perlop", "tag": "code"}], "childNum": 1, "href": "http://perldoc.perl.org/perlop.html"}, {"text": "perldoc perlop", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://perldoc.perl.org/perlop.html#m/PATTERN/msixpogc", "text": "m/PATTERN/msixpogc", "childNum": 1, "tag": "a", "childList": [{"text": "m/PATTERN/msixpogc", "tag": "code"}]}, {"text": "m/PATTERN/msixpogc", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://perldoc.perl.org/perlop.html#?PATTERN?", "text": "?PATTERN?", "childNum": 1, "tag": "a", "childList": [{"text": "?PATTERN?", "tag": "code"}]}, {"text": "?PATTERN?", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://perldoc.perl.org/perlop.html#s/PATTERN/REPLACEMENT/msixpogce", "text": "s/PATTERN/REPLACEMENT/msixpogce", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["s is the substitution operator.", "Usually it is in the form of s/foo/bar/, but you can replace // separator characters some other characters like !.", "Using other separator charaters may make working with things like paths a lot easier since you don't need to escape path separators."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "s/foo/bar/", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "!", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["See manual page for further info."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "manual page", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://perldoc.perl.org/perlop.html#Quote-Like-Operators"}]}, {"text": ["You can find similar functionality for python in re-module."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "re-module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/re.html"}]}], [{"text": ["s is the substitution operator.", "Normally this uses '/' for the delimiter:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n s/foo/bar/\n</code>\n</pre>\n", "senID": 1}, {"text": [", but this is not required: a number of other characters can be used as delimiters instead.", "In this case, '!", "' has been used as the delimiter, presumably to avoid the need to escape the '/' characters in the actual text to be substituted."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In your specific case, the first line removes text matching '.+?", "'; i.e.", "it removes 'foo' tags with or without content."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The second line replaces all ';' characters with '/' characters, globally (all occurences)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The python equivalent code uses the re module:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "re", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n f=re.sub(searchregx,replacement_str,line)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["s!", "is syntactic sugar for the 'proper' s/// operator.", "Basically, you can substitute whatever delimiter you want instead of the '/'s."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "s!", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "s///", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["As to what each line is doing, the first line is matching occurances of the regex &lt;foo&gt;.+?&lt;/foo&gt; and replacing the whole lot with nothing.", "The second is matching the regex ; and replacing it with /."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "&lt;foo&gt;.+?&lt;/foo&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ";", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "/", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["s/// is the substitute operator.", "It takes a regular expression and a substitution string."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "s///", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n s/regex/replace string/;\n</code>\n</pre>\n", "senID": 3}, {"text": ["It supports most (all?", ") of the normal regular expression switches, which are used in the normal way (by appending them to the end of the operator)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["And the python equivalent is to use the re module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]