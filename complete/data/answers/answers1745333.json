[[{"text": ["itertools often helps even there - you need to provide concrete examples where you think it doesn't."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["itertools.chain.from_iterable."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "itertools.chain.from_iterable", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Both chain and chain_from_iterable do that -- no sub-iterator is \"started up\" until the very instant the first item from it is needed."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "chain", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "chain_from_iterable", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["A specific example would be greatly appreciated.", "Anyway, worst case, you'll be coding for x in blargh: yield x where the suspended Pep3080 would let you code yield from blargh -- about 4 extra characters (not a tragedy;-)."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "for x in blargh: yield x", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "yield from blargh", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["And if some sophisticated coroutine-version of some itertools functionality (itertools mostly supports iterators - there's no equivalent coroutools module yet) becomes warranted, because a certain pattern of coroutine composition is often repeated in your code, then it's not too hard to code it yourself."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["For example, suppose we often find ourselves doing something like: first yield a certain value; then, repeatedly, if we're sent 'foo', yield the next item from fooiter, if 'bla', from blaiter, if 'zop', from zopiter, anything else, from defiter.", "As soon as we spot the second occurrence of this compositional pattern, we can code:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def corou_chaiters(initsend, defiter, val2itermap):\n  currentiter = iter([initsend])\n  while True:\n    val = yield next(currentiter)\n    currentiter = val2itermap(val, defiter)\n</code>\n</pre>\n", "senID": 6}, {"text": ["and call this simple compositional function as and when needed.", "If we need to compose other coroutines, rather than general iterators, we'll have a slightly different composer using the send method instead of the next built-in function; and so forth."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["If you can offer an example that's not easily tamed by such techniques, I suggest you do so in a separate question (specifically targeted to coroutine-like generators), as there's already a lot of material on this one that will have little to do with your other, much more complex/sophisticated, example."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["You want to chain several iterators together:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "chain several iterators", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.chain"}]}, {"code": "<pre>\n<code>\n from itertools import chain\n\ndef sillyGenerator(a,b,c):\n    return chain(quadraticRange(a),quadraticRange(b),quadraticRange(c))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Impractical (unfortunately) answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import PEP0380\n\ndef sillyGenerator():\n    yield from quadraticRange(10)\n    yield from quadraticRange(12)\n    yield from quadraticRange(8)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Potentially practical reference: Syntax for delegating to a subgenerator"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Syntax for delegating to a subgenerator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0380/"}]}, {"text": ["Unfortunately making this impractical: Python language moratorium"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Python language moratorium", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://python.org/dev/peps/pep-3003/"}]}, {"text": ["UPDATE Feb 2011:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "UPDATE", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The moratorium has been lifted, and PEP 380 is on the TODO list for Python 3.3.", "Hopefully this answer will be practical soon."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Read Guido's remarks on comp.python.devel"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Guido's remarks on comp.python.devel", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://article.gmane.org/gmane.comp.python.devel/121459"}]}], [{"code": "<pre>\n<code>\n import itertools\n\ndef quadraticRange(n):\n  for i in xrange(n)\n    yield i*i\n\ndef sillyGenerator():\n  return itertools.chain(\n    quadraticRange(10),\n    quadraticRange(12),\n    quadraticRange(8),\n  )\n\ndef sillyGenerator2():\n  return itertools.chain.from_iterable(\n    quadraticRange(n) for n in [10, 12, 8])\n</code>\n</pre>\n", "senID": 0}, {"text": ["The last is useful if you want to make sure one iterator is exhausted before another starts (including its initialization code)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["There is a Python Enhancement Proposal for providing a yield fromstatement for \"delegating generation\".", "Your example would be written as:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "yield fromstatement", "tag": "a", "pos": 0, "childList": [{"text": "yield from", "tag": "code"}], "childNum": 1, "href": "http://www.python.org/dev/peps/pep-0380/"}, {"text": "yield from", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def sillyGenerator():\n  sq = lambda i: i * i\n  yield from map(sq, xrange(10))\n  yield from map(sq, xrange(12))\n  yield from map(sq, xrange(8))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or better, in the spirit of DRY:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def sillyGenerator():\n  for i in [10, 12, 8]:\n    yield from quadraticRange(i)\n</code>\n</pre>\n", "senID": 3}, {"text": ["The proposal is in draft status and its eventual inclusion is not certain, but it shows that other developers share your thoughts about generators."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["For an arbitrary number of calls to quadraticRange:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "quadraticRange", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import chain\n\ndef sillyGenerator(*args):\n    return chain(*map(quadraticRange, args))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This code uses map and itertools.chain.", "It takes an arbitrary number of arguments and passes them in order to quadraticRange.", "The resulting iterators are then chained."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "map", "tag": "a", "pos": 0, "childList": [{"text": "map", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/functions.html#map"}, {"text": "map", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "itertools.chain", "tag": "a", "pos": -1, "childList": [{"text": "itertools.chain", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/itertools.html#chain"}, {"text": "itertools.chain", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "quadraticRange", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["There is a pattern which I call \"generator kernel\" where generators don't yield directly to the user but to some \"kernel\" loop that treats (some of) their yields as \"system calls\" with special meaning."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can apply it here by an intermediate function that accepts yielded generators and unrolls them automatically.", "To make it easy to use, we'll create that intermediate function in a decorator:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import functools, types\n\ndef flatten(values_or_generators):\n    for x in values_or_generators:\n        if isinstance(x, GeneratorType):\n            for y in x:\n                yield y\n        else:\n            yield x\n\n# Better name anyone?\ndef subgenerator(g):\n    \"\"\"Decorator making ``yield &lt;gen&gt;`` mean ``yield from &lt;gen&gt;``.\"\"\"\n\n    @functools.wraps(g)\n    def flat_g(*args, **kw):\n        return flatten(g(*args, **kw))\n    return flat_g\n</code>\n</pre>\n", "senID": 2}, {"text": ["and then you can just write:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def quadraticRange(n):\n    for i in xrange(n)\n        yield i*i\n\n@subgenerator\ndef sillyGenerator():\n    yield quadraticRange(10)\n    yield quadraticRange(12)\n    yield quadraticRange(8)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Note that subgenerator() is unrolling exactly one level of the hierarchy.", "You could easily make it multi-level (by managing a manual stack, or just replacing the inner loop with for y in flatten(x): - but I think it's better as it is, so that every generator that wants to use this non-standard syntax has to be explicitly wrapped with @subgenerator."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "for y in flatten(x):", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Note also that detection of generators is imperfect!", "It will detect things written as generators, but that's an implementation detail.", "As a caller of a generator, all you care about is that it returns an iterator.", "It could be a function returning some itertools object, and then this decorator would fail."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Checking whether the object has a .next() method is too broad - you won't be able to yield strings without them being taken apart.", "So the most reliable way would be to check for some explicit marker, so you'd write e.g."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": ".next()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n @subgenerator\ndef sillyGenerator():\n    yield 'from', quadraticRange(10)\n    yield 'from', quadraticRange(12)\n    yield 'from', quadraticRange(8)\n</code>\n</pre>\n", "senID": 8}, {"text": ["Hey, that's almost like the PEP!"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["[credits: this answer gives a similar function - but it's deep (which I consider wrong) and is not a framed as a decorator]"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "this answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/248830/python-using-a-recursive-algorithm-as-a-generator/252199#252199"}]}], [{"code": "<pre>\n<code>\n class Communicator:\n    def __init__(self, inflow):\n        self.outflow = None\n        self.inflow = inflow\n</code>\n</pre>\n", "senID": 0}, {"text": ["Then you do:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n c = Communicator(something)\nyield c\nresponse = c.outflow\n</code>\n</pre>\n", "senID": 2}, {"text": ["And instead of the boilerplate code you can simply do:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for i in run():\n     something = i.inflow\n     # ...\n     i.outflow = value_to_return_back\n</code>\n</pre>\n", "senID": 4}, {"text": ["It's simple enough code that works without much brain."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]