[[{"text": ["The easiest mechanism I can think of is to use awk(1):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "awk(1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ echo 101222_1_1_ab | awk -F_ '{print $1 \"_\" $2 \"_\" $4 \"_\" $3;}'\n101222_1_ab_1\n</code>\n</pre>\n", "senID": 1}, {"text": ["The -F_ asks awk(1) to split fields apart on underscores."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "-F_", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "awk(1)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Update Glenn Jackman recommends the following, far more legible, version:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n awk -F_ -v OFS=_ '{print $1, $2, $4, $3}'\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n echo 101222_1_1_ab | sed -r -e 's/(.*_.*_)(.*)_(.*)/\\1\\3_\\2/'\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This might work for you:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # echo \"101222_1_1_ab\" | sed -re 's/(_[^_]+)(_.*)$/\\2\\1/'\n101222_1_ab_1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["FWIW, I would use awk for this."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "awk", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n $ echo 101222_1_1_ab | awk 'BEGIN {FS = OFS = \"_\"} {print $1, $2, $4, $3}' \n101222_1_ab_1\n</code>\n</pre>\n", "senID": 1}, {"text": ["But since you ask:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = '101222_1_1_ab'\n&gt;&gt;&gt; s.split('_')\n['101222', '1', '1', 'ab']\n&gt;&gt;&gt; l = s.split('_')\n&gt;&gt;&gt; l[0], l[1], l[3], l[2]\n('101222', '1', 'ab', '1')\n&gt;&gt;&gt; '_'.join((l[0], l[1], l[3], l[2]))\n'101222_1_ab_1'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If you want to use sed, this splits at the underscores and rearranges:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n echo 101222_1_1_ab | sed 's/\\(.*_.*\\)_\\(.*\\)_\\(.*\\)/\\1_\\3_\\2/'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit As @dmitry.malikov points out, the -r option can make it much more readable:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "-r", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n echo 101222_1_1_ab | sed -r 's/(.*_.*)_(.*)_(.*)/\\1_\\3_\\2/'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Just with bash:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n word=101222_1_1_ab\nnew=$(\n  IFS=_\n  parts=($word)\n  tmp=${parts[2]}; parts[2]=${parts[3]}; parts[3]=$tmp\n  printf \"%s\" \"${parts[*]}\"\n)\necho $new # =&gt; 101222_1_ab_1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Bash:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/bin/bash\nword='101222_1_1_ab' IFS='_' parts=( $word )\necho \"${parts[0]}_${parts[1]}_${parts[3]}_${parts[2]}\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["(wanted to put this in reply to glenn jackman)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]