[[{"code": "<pre>\n<code>\n if num &lt; 0:\n    lst = list(chained)\n    lst.reverse()\n    return lst\nelse:\n    return chained\n</code>\n</pre>\n", "senID": 0}, {"text": ["reversed() needs an actual sequence, because it iterates it backwards by index, and that wouldn't work for a generator (which only has the notion of \"next\" item)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "reversed()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Since you will need to unroll the whole generator anyway for reversing, the most efficient way is to read it to a list and reverse the list in-place with the .reverse() method."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": ".reverse()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You cannot reverse generators by definition.", "The interface of a generator is the iterator, which is a container that supports only forward iteration.", "When you want to reverse a iterator, you have to collect all it's items first and reverse them after that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Use lists instead or generate the sequences backwards from the start."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["itertools.chain would need to implement __reversed__() (this would be best) or __len__() and __getitem__()"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "__reversed__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__len__()", "childNum": 0, "tag": "code", "childList": []}, {"text": "__getitem__()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Since it doesn't, and there's not even a way to access the internal sequences you'll need to expand the entire sequence to be able to reverse it."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n reversed(list(CHAIN_INSTANCE))\n</code>\n</pre>\n", "senID": 2}, {"text": ["It would be nice if chain would make __reversed__() available when all the sequences are reversable, but currently it does not do that.", "Perhaps you can write your own version of chain that does"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "__reversed__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["reversed only works on objects that support len and indexing.", "You have to first generate all results of a generator before wrapping reversed around them."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "reversed", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "len", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "reversed", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["However, you could easily do this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def bar(num):\n    import itertools\n    some_sequence = (x*1.5 for x in range(num, -1, -1))\n    some_other_sequence = (x*2.6 for x in range(num, -1, -1))\n    chained = itertools.chain(some_other_sequence, some_sequence)\n    return chained\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Does this work in you real app?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def bar(num):\n    import itertools\n    some_sequence = (x*1.5 for x in range(num))\n    some_other_sequence = (x*2.6 for x in range(num))\n    list_of_chains = [some_sequence, some_other_sequence]\n    if num &lt; 0:\n        list_of_chains.reverse()\n    chained = itertools.chain(*list_of_chains)\n    return chained\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In theory you can't because chained objects may even contain infinite sequences such as itertools.count(...)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.count(...)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You should try to reverse your generators/sequences or use reversed(iterable) for each sequence if applicable and then chain them together last-to-first.", "Of course this highly depends on your use case."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "reversed(iterable)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n def reversed2(iter):\n    return reversed(list(iter))\n</code>\n</pre>\n", "senID": 0}]]