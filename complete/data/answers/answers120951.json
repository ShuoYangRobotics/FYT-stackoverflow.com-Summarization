[[{"text": ["Have a look at this module: werkzeug.utils."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "werkzeug.utils", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.bitbucket.org/mitsuhiko/werkzeug-main/src/tip/werkzeug/utils.py"}]}, {"text": ["The function you are looking for is called \"url_fix\" and works like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; url_fix(u'http://de.wikipedia.org/wiki/Elf (Begriffskl\u00e4rung)')\n'http://de.wikipedia.org/wiki/Elf%20%28Begriffskl%C3%A4rung%29'\n</code>\n</pre>\n", "senID": 2}, {"text": ["It's implemented in Werkzeug as follows:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import urllib\nimport urlparse\n\ndef url_fix(s, charset='utf-8'):\n    \"\"\"Sometimes you get an URL by a user that just isn't a real\n    URL because it contains unsafe characters like ' ' and so on.  This\n    function can fix some of the problems in a similar way browsers\n    handle data entered by the user:\n\n    &gt;&gt;&gt; url_fix(u'http://de.wikipedia.org/wiki/Elf (Begriffskl\u00e4rung)')\n    'http://de.wikipedia.org/wiki/Elf%20%28Begriffskl%C3%A4rung%29'\n\n    :param charset: The target charset for the URL if the url was\n                    given as unicode string.\n    \"\"\"\n    if isinstance(s, unicode):\n        s = s.encode(charset, 'ignore')\n    scheme, netloc, path, qs, anchor = urlparse.urlsplit(s)\n    path = urllib.quote(path, '/%')\n    qs = urllib.quote_plus(qs, ':&amp;=')\n    return urlparse.urlunsplit((scheme, netloc, path, qs, anchor))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["use urllib.quote or urllib.quote_plus"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "urllib.quote", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "urllib.quote_plus", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["From the urllib documentation:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "urllib documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-urllib.html"}]}, {"text": ["EDIT: Using urllib.quote or urllib.quote_plus on the whole URL will mangle it, as @\u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5 points out:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "\u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "#120959"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; quoted_url = urllib.quote('http://www.example.com/foo goo/bar.html')\n&gt;&gt;&gt; quoted_url\n'http%3A//www.example.com/foo%20goo/bar.html'\n&gt;&gt;&gt; urllib2.urlopen(quoted_url)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"c:\\python25\\lib\\urllib2.py\", line 124, in urlopen\n    return _opener.open(url, data)\n  File \"c:\\python25\\lib\\urllib2.py\", line 373, in open\n    protocol = req.get_type()\n  File \"c:\\python25\\lib\\urllib2.py\", line 244, in get_type\n    raise ValueError, \"unknown url type: %s\" % self.__original\nValueError: unknown url type: http%3A//www.example.com/foo%20goo/bar.html\n</code>\n</pre>\n", "senID": 3}, {"text": ["@\u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5 provides a function that uses urlparse.urlparse and urlparse.urlunparse to parse the url and only encode the path.", "This may be more useful for you, although if you're building the URL from a known protocol and host but with a suspect path, you could probably do just as well to avoid urlparse and just quote the suspect part of the URL, concatenating with known safe parts."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "\u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "#120959"}, {"text": "urlparse.urlparse and urlparse.urlunparse", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-urlparse.html"}]}], [{"text": ["Real fix in Python 2.7 for that problem"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Real fix in Python 2.7 for that problem", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://svn.python.org/view/python/trunk/Lib/urllib.py?r1=71780&r2=71779&pathrev=71780"}]}, {"text": ["Right solution was:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n # percent encode url, fixing lame server errors for e.g, like space\n # within url paths.\n fullurl = quote(fullurl, safe=\"%/:=&amp;?~#+!$,;'@()*[]\")\n</code>\n</pre>\n", "senID": 2}, {"text": ["For more information see Issue918368: \"urllib doesn't correct server returned urls\""], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Issue918368: \"urllib doesn't correct server returned urls\"", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://bugs.python.org/issue918368"}]}], [{"text": ["Because this page is a top result for Google searches on the topic, I think it's worth mentioning some work that has been done on URL normalization with Python that goes beyond urlencoding space characters.", "For example, dealing with default ports, character case, lack of trailing slashes, etc."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When the Atom syndication format was being developed, there was some discussion on how to normalize URLs into canonical format; this is documented in the article PaceCanonicalIds on the Atom/Pie wiki.", "That article provides some good test cases."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "PaceCanonicalIds", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.intertwingly.net/wiki/pie/PaceCanonicalIds"}]}, {"text": ["I believe that one result of this discussion was Mark Nottingham's urlnorm.py library, which I've used with good results on a couple projects.", "That script doesn't work with the URL given in this question, however.", "So a better choice might be Sam Ruby's version of urlnorm.py, which handles that URL, and all of the aforementioned test cases from the Atom wiki."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "urlnorm.py", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.mnot.net/python/urlnorm.py"}, {"text": "Sam Ruby's version of urlnorm.py", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://intertwingly.net/blog/2004/08/04/Urlnorm"}]}], [{"code": "<pre>\n<code>\n import urlparse, urllib\ndef myquote(url):\n    parts= urlparse.urlparse(url)\n    return urlparse.urlunparse(parts[:2] + urllib.quote(parts[2]) + parts[3:])\n</code>\n</pre>\n", "senID": 0}, {"text": ["This quotes only the path component."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Otherwise, you could do: urllib.quote(url, safe=\":/\")"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "urllib.quote(url, safe=\":/\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Just FYI, urlnorm has moved to github:\n  http://gist.github.com/246089"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://gist.github.com/246089", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://gist.github.com/246089"}]}]]