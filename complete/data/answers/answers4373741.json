[[{"text": ["Update"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I've changed my answer a bit to address the OP's follow-up question about whether it could be modified to instead generate random non-colliding squares rather than arbitrarily rectangles.", "I did this in the simplest way I could that would work, which was to post-process the output of my original answer and turn it into square sub-regions.", "I also updated the optional visualization code to show both kinds of output.", "Obviously this sort of filtering could be extended to do other tasks such as insetting each rectangle or square to prevent them from touching each other."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "squares", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Unlike many of the answers already posted randomly generate rectangles and reject any that collide with those already created, which sounds both somewhat slow and computationally expensive.", "To avoid those issues, the approach I would take would be to only generate ones that don't overlap."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["That makes what you want to do a relatively simple and fast area subdivision problem.", "Below is one implementation of how this could be done.", "It starts with a rectangle defining the outer boundary which it divides into four smaller non-overlapping rectangles.", "That is accomplished by choosing a semi-random interior point and using it along with the four existing corner points of the outer rectangle to form the four subsections."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Most of the action take place in the quadsect() function.", "The choice of the interior point is crucial in determining what the output looks like.", "You can constrain it any way you wish, such as only selecting one that would result in sub-rectangles of at least a certain minimum width or height or no bigger than some amount.", "In the sample code in my answer, it's defined as the center point \u00b1 1/3 of the width and height of the outer rectangle, but basically any interior point would work to some degree."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "quadsect()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Since this algorithm generates sub-rectangles very rapidly, it's OK to spend some computational time determining a good interior divisor point."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["To help visualize the results of this approach, there's some extra non-essential code at the very end that uses the PIL (Python Imaging Library) module to create an image file displaying the rectangles generated during some test runs I made."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "PIL", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Anyway, here's the latest version of the code and output samples:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import random\nrandom.seed()\nrandint = random.randint\n\nclass Point(object):\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n\n    @staticmethod\n    def from_point(other):\n        return Point(other.x, other.y)\n\nclass Rect(object):\n    def __init__(self, x1, y1, x2, y2):\n        minx, maxx = (x1,x2) if x1 &lt; x2 else (x2,x1)\n        miny, maxy = (y1,y2) if y1 &lt; y2 else (y2,y1)\n        self.min = Point(minx, miny)\n        self.max = Point(maxx, maxy)\n\n    @staticmethod\n    def from_points(p1, p2):\n        return Rect(p1.x, p1.y, p2.x, p2.y)\n\n    def __str__(self):\n        return 'Rect({:d}, {:d}, {:d}, {:d})'.format(self.min.x, self.min.y,\n                                                     self.max.x, self.max.x)\n    width  = property(lambda self: self.max.x - self.min.x)\n    height = property(lambda self: self.max.y - self.min.y)\n\nplus_or_minus = lambda v: v * [-1,1][(randint(0,99) % 2)]\n\ndef quadsect(rect, factor):\n    \"\"\" Divide given rectangle into four non-overlapping sub-rectangles \"\"\"\n    # pick a point in the interior of given rectangle\n    w, h = rect.width, rect.height # cache properties\n    center = Point(rect.min.x + (w // 2), rect.min.y + (h // 2))\n    delta = Point(plus_or_minus(randint(0, w // factor)),\n                  plus_or_minus(randint(0, h // factor)))\n    interior = Point(center.x + delta.x, center.y + delta.y)\n\n    # create rectangles from the interior point and the corners of the outer one\n    rect1 = Rect(interior.x, interior.y, rect.min.x, rect.min.y)\n    rect2 = Rect(interior.x, interior.y, rect.max.x, rect.min.y)\n    rect3 = Rect(interior.x, interior.y, rect.max.x, rect.max.y)\n    rect4 = Rect(interior.x, interior.y, rect.min.x, rect.max.y)\n\n    return [rect1,rect2,rect3,rect4]\n\ndef square_sub_region(rect):\n    \"\"\" Determine a square that fits inside the given rectangle \"\"\"\n    w, h = rect.width, rect.height # cache properties\n    if w &lt; h:\n        offset = (h - w) // 2\n        return Rect(rect.min.x, rect.min.y+offset, rect.max.x, rect.min.y+offset+w)\n    else:\n        offset = (w - h) // 2\n        return Rect(rect.min.x+offset, rect.min.y, rect.min.x+offset+h, rect.max.y)\n\nnum_rects = 20\nregion = Rect(0, 0, 640, 480)\nrects = [region] # seed output list\n\n# generate at least the number wanted\nwhile len(rects) &lt; num_rects:\n    sub_rects = []\n    for rect in rects:\n        sub_rects.extend(quadsect(rect, 3))\n    rects = sub_rects\n\nrandom.shuffle(rects) # mix them up\nsample = random.sample(rects, num_rects) # select the desired number\nprint '%d out of the %d rectangles selected' % (num_rects, len(rects))\n\n#################################################\n# optional - create an image file showing results\n\nfrom PIL import Image, ImageDraw\nBLACK, DARKGRAY, GRAY, LIGHTGRAY, WHITE = (0, 64, 128, 192, 255)\nimgx = region.max.x+1\nimgy = region.max.y+1\nimage = Image.new(\"L\", (imgx, imgy), WHITE) # greyscale image\ndraw = ImageDraw.Draw(image)\n\ndef draw_rect(rect, fill=None, outline=WHITE):\n    draw.rectangle([(rect.min.x, rect.min.y), (rect.max.x, rect.max.y)],\n                   fill=fill, outline=outline)\n\n# first draw all the rectanges generated\nfor rect in rects:\n    draw_rect(rect, outline=LIGHTGRAY)\n\n# then draw the random sample of them selected\nfor rect in sample:\n    draw_rect(rect, fill=(LIGHTGRAY+WHITE)//2, outline=WHITE)\n\n# and lastly convert the those into squares and re-draw them in anothe color\nfor rect in sample:\n    sq = square_sub_region(rect)\n    draw_rect(sq, fill=GRAY, outline=WHITE)\n\nimage.save(\"sq_quadsections.png\", \"PNG\")\nprint 'image saved'\n</code>\n</pre>\n", "senID": 8}, {"text": ["Output Sample 1"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"src": "http://dl.dropbox.com/u/5508445/stackoverflow/sq_quadsections1.png", "tag": "img", "senID": 10}, {"text": ["Output Sample 2"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"src": "http://dl.dropbox.com/u/5508445/stackoverflow/sq_quadsections2.png", "tag": "img", "senID": 12}], [{"text": ["Three ideas:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The first method fails because hitting a random array of 20 non-overlapping objects is highly improbable (actually (1-p)^20, where 0&lt;p&lt;1 is the probability of two objects colliding).", "If you could dramatically (orders-of-magnitude drama) decrease their size, it might help."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "(1-p)^20", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "0&lt;p&lt;1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The most obvious improvement would be:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n while len(rectangles)&lt;N:\n    new_rectangle=get_random_rectangle()\n    for rectangle in rectangles:\n        if not any(intersects (rectangle, new_rectangle) for rectangle in rectangles)\n            rectangles.add(new_rectangle)\n</code>\n</pre>\n", "senID": 3}, {"text": ["This would greatly improve your performance, as having a single intersection will not force you to generate a whole new set, just to pick a different single rectangle."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["How often will you be using these sets in your game?", "Using a different set every second is a different scenario than using a set once in an hour.", "If you don't use these sets too often, pre-calculate s large-enough set so that the gamer would probably never see the same set twice.", "When pre-calculating, you don't care too much for the time spent (so you can even use your inefficient first algorithm). "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Even if you actually need these rectangles at run time, it might be a good idea to calculate them a bit before you need them, when the CPU is idle for some reason, so that you'll always have a set ready in hand."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["At run time, just pick a set at random.", "This is probably the best approach for real-time gaming."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Note:\nThis solution assumes that you rectangles are kept in a space-saving manner, e.g.", "pairs of (x, y) coordinates.", "These pairs consume very little space, and you can actually save thousands, and even millions, in a file with reasonable size."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "Note:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "(x, y)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Useful links:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Useful links:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": ["Place random non-overlapping rectangles on a panel"], "childNum": 0, "tag": "a", "senID": 10, "childList": []}, {"text": ["minimizing overlap in random rectangles"], "childNum": 0, "tag": "a", "senID": 11, "childList": []}]}], [{"code": "<pre>\n<code>\n list_of_objects = []\nfor i in range(20):\n    while True:\n        new_object = create_object()\n        if not any(collides(new_object, x) for x in list_of_objects):\n            break\n    list_of_objects.append(new_object)\n</code>\n</pre>\n", "senID": 0}, {"text": ["I assume you already have the create_object() and collides() functions"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "create_object()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "collides()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You may also need to decrease the size of the rects if this loops too many times"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Did you try:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Until there are enough objects:\n    create new object\n    if it doesn't collide with anything in the list:\n        add it to the list\n</code>\n</pre>\n", "senID": 1}, {"text": ["No sense recreating the entire list, or taking out everything that's involved in a collision."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Another idea is to \"fix\" collisions by either of the following approaches:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["1) Find the center of the region of intersection, and adjust the appropriate corner of each intersecting rect to that point, such that they now touch on corner/edge instead of intersecting."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["2) When a rectangle collides with something, randomly generate a sub-region of that rectangle and try that instead."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["an alternative pseudocode, to those already mentioned:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n while not enough objects:\n  place object randomly\n  if overlaps with anything else:\n    reduce size until it fits or has zero size\n  if zero size: \n    remove\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or something like that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["But this has the advantage of possibly creating some smaller objects than you intended, and creating objects which almost intersect (i.e.", "touch)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If it's a map for the player to traverse, they may still not be able to traverse it because their path could be blocked."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["There is a very simple approximation to your problem which worked fine for me:\n- Define a grid.", "For instance a 100 pixel grid writes (x,y) -> (int(x/100),int(y/100)).", "The grid elements do not overlap.", "- Either put each object in a different grid (randomly inside the grid will look prettier), either put randomly a few objects in each grid, if you can allow a few objects to overlap."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I used this to randomly generate a 2D map (Zelda like).", "My objects' images are smaller than &lt;100*100>, so I used grid of size &lt;500*500> and allowed for 1-6 objects in each grid."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]