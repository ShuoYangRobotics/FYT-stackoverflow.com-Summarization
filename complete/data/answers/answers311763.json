[[{"text": ["splitting should do the trick.", "Here's a good way to extract the data, as well:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; line=\"$GPRMC,199304.973,3248.7780,N,11355.7832,W,1,06,02.2,25722.5,M,,,*00\"\n&gt;&gt;&gt; line=line.split(\",\")\n&gt;&gt;&gt; neededData = (float(line[2]), line[3], float(line[4]), line[5], float(line[9]))\n&gt;&gt;&gt; print neededData\n(3248.7779999999998, 'N', 11355.7832, 'W', 25722.5)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It's simpler to use split than a regex."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; line=\"$GPRMC,092204.999,4250.5589,S,14718.5084,E,1,12,24.4,89.6,M,,,0000*1F \"\n&gt;&gt;&gt; line.split(',')\n['$GPRMC', '092204.999', '4250.5589', 'S', '14718.5084', 'E', '1', '12', '24.4', '89.6', 'M', '', '', '0000*1F ']\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You should also first check the checksum of the data.", "It is calculated by XORing the characters between the $ and the * (not including them) and comparing it to the hex value at the end."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Your pastebin looks like it has some corrupt lines in it.", "Here is a simple check, it assumes that the line starts with $ and has no CR/LF at the end.", "To build a more robust parser you need to search for the '$' and work through the string until hitting the '*'."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def check_nmea0183(s):\n    \"\"\"\n    Check a string to see if it is a valid NMEA 0183 sentence\n    \"\"\"\n    if s[0] != '$':\n        return False\n    if s[-3] != '*':\n        return False\n\n    checksum = 0\n    for c in s[1:-3]:\n        checksum ^= ord(c)\n\n    if int(s[-2:],16) != checksum:\n        return False\n\n    return True\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Those are comma separated values, so using a csv library is the easiest solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I threw that sample data you have into /var/tmp/sampledata, then I did this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import csv\n&gt;&gt;&gt; for line in csv.reader(open('/var/tmp/sampledata')):\n...   print line\n['$GPRMC', '092204.999', '**4250.5589', 'S', '14718.5084', 'E**', '1', '12', '24.4', '**89.6**', 'M', '', '', '0000\\\\*1F']\n['$GPRMC', '093345.679', '**4234.7899', 'N', '11344.2567', 'W**', '3', '02', '24.5', '**1000.23**', 'M', '', '', '0000\\\\*1F']\n['$GPRMC', '044584.936', '**1276.5539', 'N', '88734.1543', 'E**', '2', '04', '33.5', '**600.323**', 'M', '', '', '\\\\*00']\n['$GPRMC', '199304.973', '**3248.7780', 'N', '11355.7832', 'W**', '1', '06', '02.2', '**25722.5**', 'M', '', '', '\\\\*00']\n['$GPRMC', '066487.954', '**4572.0089', 'S', '45572.3345', 'W**', '3', '09', '15.0', '**35000.00**', 'M', '', '', '\\\\*1F']\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can then process the data however you wish.", "It looks a little odd with the '**' at the start and end of some of the values, you might want to strip that stuff off, you can do:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt; eastwest = 'E**'\n&gt;&gt; eastwest = eastwest.strip('*')\n&gt;&gt; print eastwest\nE\n</code>\n</pre>\n", "senID": 4}, {"text": ["You will have to cast some values as floats.", "So for example, the 3rd value on the first line of sample data is:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt; data = '**4250.5589'\n&gt;&gt; print float(data.strip('*'))\n4250.5589\n</code>\n</pre>\n", "senID": 6}], [{"text": ["I suggest a small fix in your code because if used to parse data from the previous century the date looks like sometime in the future (for instance 2094 instead of 1994)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["My fix is not fully accurate, but I take the stand that prior to the 70's no GPS data existed."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In the def parse function for RMC sentences just replace the format line by:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n p = int(v[4:])\nprint \"p = \", p\nif p &gt; 70:\n    tokens[k] = '19%s/%s/%s' % (v[4:],v[2:4],v[:2])\nelse:\n    tokens[k] = '20%s/%s/%s' % (v[4:],v[2:4],v[:2])\n</code>\n</pre>\n", "senID": 3}, {"text": ["This will look at the two yy digits of the year and assume that past year 70 we are dealing with sentences from the previous century.", "It could be better done by comparing to today's date and assuming that every time you deal with some data in the future, they are in fact from the past century"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Thanks for all the pieces of code your provided above...", "I had some fun with this."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["If you need to do some more extensive analysis of your GPS data streams, here is a pyparsing solution that breaks up your data into named data fields.", "I extracted your pastebin'ned data to a file gpsstream.txt, and parsed it with the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \"\"\"\n Parse NMEA 0183 codes for GPS data\n http://en.wikipedia.org/wiki/NMEA_0183\n\n (data formats from http://www.gpsinformation.org/dale/nmea.htm)\n\"\"\"\nfrom pyparsing import *\n\nlead = \"$\"\ncode = Word(alphas.upper(),exact=5)\nend = \"*\"\nCOMMA = Suppress(',')\ncksum = Word(hexnums,exact=2).setParseAction(lambda t:int(t[0],16))\n\n# define basic data value forms, and attach conversion actions\nword = Word(alphanums)\nN,S,E,W = map(Keyword,\"NSEW\")\ninteger = Regex(r\"-?\\d+\").setParseAction(lambda t:int(t[0]))\nreal = Regex(r\"-?\\d+\\.\\d*\").setParseAction(lambda t:float(t[0]))\ntimestamp = Regex(r\"\\d{2}\\d{2}\\d{2}\\.\\d+\")\ntimestamp.setParseAction(lambda t: t[0][:2]+':'+t[0][2:4]+':'+t[0][4:])\ndef lonlatConversion(t):\n    t[\"deg\"] = int(t.deg)\n    t[\"min\"] = float(t.min)\n    t[\"value\"] = ((t.deg + t.min/60.0) \n                    * {'N':1,'S':-1,'':1}[t.ns] \n                    * {'E':1,'W':-1,'':1}[t.ew])\nlat = Regex(r\"(?P&lt;deg&gt;\\d{2})(?P&lt;min&gt;\\d{2}\\.\\d+),(?P&lt;ns&gt;[NS])\").setParseAction(lonlatConversion)\nlon = Regex(r\"(?P&lt;deg&gt;\\d{3})(?P&lt;min&gt;\\d{2}\\.\\d+),(?P&lt;ew&gt;[EW])\").setParseAction(lonlatConversion)\n\n# define expression for a complete data record\nvalue = timestamp | Group(lon) | Group(lat) | real | integer | N | S | E | W | word\nitem = lead + code(\"code\") + COMMA + delimitedList(Optional(value,None))(\"datafields\") + end + cksum(\"cksum\")\n\n\ndef parseGGA(tokens):\n    keys = \"time lat lon qual numsats horiz_dilut alt _ geoid_ht _ last_update_secs stnid\".split()\n    for k,v in zip(keys, tokens.datafields):\n        if k != '_':\n            tokens[k] = v\n    #~ print tokens.dump()\n\ndef parseGSA(tokens):\n    keys = \"auto_manual _3dfix prn prn prn prn prn prn prn prn prn prn prn prn pdop hdop vdop\".split()\n    tokens[\"prn\"] = []\n    for k,v in zip(keys, tokens.datafields):\n        if k != 'prn':\n            tokens[k] = v\n        else:\n            if v is not None:\n                tokens[k].append(v)\n    #~ print tokens.dump()\n\ndef parseRMC(tokens):\n    keys = \"time active_void lat lon speed track_angle date mag_var _ signal_integrity\".split()\n    for k,v in zip(keys, tokens.datafields):\n        if k != '_':\n            if k == 'date' and v is not None:\n                v = \"%06d\" % v\n                tokens[k] = '20%s/%s/%s' % (v[4:],v[2:4],v[:2])\n            else:\n                tokens[k] = v\n    #~ print tokens.dump()\n\n\n# process sample data\ndata = open(\"gpsstream.txt\").read().expandtabs()\n\ncount = 0\nfor i,s,e in item.scanString(data):\n    # use checksum to validate input \n    linebody = data[s+1:e-3]\n    checksum = reduce(lambda a,b:a^b, map(ord, linebody))\n    if i.cksum != checksum:\n        continue\n    count += 1\n\n    # parse out specific data fields, depending on code field\n    fn = {'GPGGA' : parseGGA, \n          'GPGSA' : parseGSA,\n          'GPRMC' : parseRMC,}[i.code]\n    fn(i)\n\n    # print out time/position/speed values\n    if i.code == 'GPRMC':\n        print \"%s %8.3f %8.3f %4d\" % (i.time, i.lat.value, i.lon.value, i.speed or 0) \n\n\nprint count\n</code>\n</pre>\n", "senID": 1}, {"text": ["The $GPRMC records in your pastebin don't seem to quite match with the ones you included in your post, but you should be able to adjust this example as necessary."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]