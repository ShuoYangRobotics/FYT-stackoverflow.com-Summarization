[[{"text": ["That's not inheritance."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That's a completely different concept.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Your \"shared variables\" are simply objects that can be mutated and have references in other objects.", "Nothing interesting."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Inheritance is completely different from this.  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I think your workaround is doable; You could use properties to make access to P's attributes easier:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "P", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class P(object):\n    def __init__(self,name='default',pvar=1):\n        self.pname  = name\n        self.pvar=pvar\n\nclass C(object):\n    def __init__(self,name,pobject=P()):  #&lt;-- The same default `P()` is \n                                          # used for all instances of `C`, \n                                          # unless pobject is explicitly defined.\n        self.cname  = name\n        self.pobject=pobject\n    @property\n    def pvar(self):\n        return self.pobject.pvar\n    @pvar.setter\n    def pvar(self,val):\n        self.pobject.pvar=val\n\nc1=C('1')\nc2=C('2')\n</code>\n</pre>\n", "senID": 1}, {"text": ["c1 and c2 share the same pobject:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "c1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "c2", "childNum": 0, "tag": "code", "childList": []}, {"text": "pobject", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n print(c1.pvar)\n# 1\nc1.pvar=2\n</code>\n</pre>\n", "senID": 3}, {"text": ["Notice that changing pvar through c1 changes c2.pvar:"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "pvar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "c1", "childNum": 0, "tag": "code", "childList": []}, {"text": "c2.pvar", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n print(c2.pvar)\n# 2\n</code>\n</pre>\n", "senID": 5}, {"text": ["c3 has a different pobject:"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "c3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "pobject", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n c3=C('3',P())\nprint(c3.pvar)\n# 1\n</code>\n</pre>\n", "senID": 7}, {"text": ["Regarding OOP design for the psychology experiment (mentioned in the comments):"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n import Image\n\nclass Picture(object):\n    def __init__(self,filename):\n        self.filename = filename\n        self.image=Image.open(filename)       \n\nclass Person(object):\n    def __init__(self,name):\n        self.name=name\n        # other vital statistics associated with people as individuals here\n\nclass Trial(object):\n    # A trial is composed of one person, one picture, and the places they look\n    def __init__(self,person,picture,locations):\n        self.person=person\n        self.picture=picture\n        self.locations = locations\n    # put methods for analyzing where the person looked here\n</code>\n</pre>\n", "senID": 9}, {"text": ["A Picture is certainly not a Person, nor vice versa.", "And the same goes for Trials.", "So none of these classes should inherit from each other."], "childNum": 3, "tag": "p", "senID": 10, "childList": [{"text": "Picture", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Person", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Trial", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Each of these classes have a public (and maybe a private) interface.", "Public methods and attributes should be freely accessible from other classes.", "So given a Trial instance, t, the image should be accessible through t.picture.image.", "As long as you are only accessing public attributes and methods, then everything should be fine. "], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "Trial", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "t", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "t.picture.image", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["For convenience, you can use properties to link attributes to component-attributes.", "For example:"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "properties", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n class Trial(object):\n    ...\n    @property\n    def image(self):\n        return self.picture.image\n</code>\n</pre>\n", "senID": 13}, {"text": ["But to short-cut this by making, say, Trial a subclass of Picture would be contrary to fundamental OOP design principles."], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "Trial", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Picture", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["The other answer is right, your question is more about namespaces and references than about inheritance. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["All variables in Python are references, and all object instance is a namespace.", "So you can do:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class C():\n    def __init__(self, x):\n        self.x  = x\n\nclass Shared(object):\n    def __init__(self, value):\n        self.value  = value\n\n# instances:\n&gt;&gt;&gt; shared1 = Shared(1)\n&gt;&gt;&gt; shared2 = Shared(2)\n&gt;&gt;&gt; c1 = C(shared1)\n&gt;&gt;&gt; c2 = C(shared1)\n&gt;&gt;&gt; c3 = C(shared2)\n&gt;&gt;&gt; c4 = C(shared2)\n# c1 and c2 sharing a reference to shared1\n&gt;&gt;&gt; c1.x.value\n1\n&gt;&gt;&gt; c2.x.value\n1\n# change c2.x will reflect on c1 \n&gt;&gt;&gt; c2.x.value = 3\n&gt;&gt;&gt; c1.x.value\n3\n# but not on c3, because shared1 and shared2 are distinct namespaces\n&gt;&gt;&gt; c3.x.value\n2\n</code>\n</pre>\n", "senID": 2}, {"text": ["UPDATE:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["But watch out, it is easy to make a mistake:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; c4.x = 4\n&gt;&gt;&gt; c3.x.value\n2\n&gt;&gt;&gt; c4.x.value\nTraceback (most recent call last):\n  File \"&lt;interactive input&gt;\", line 1, in &lt;module&gt;\nAttributeError: 'int' object has no attribute 'value'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 5}, {"text": ["I think the state of the art would be using properties to hide the __shared_instance in a private instance variable - so you can use c1.x instead of c1.x.value and avoid a typo like the example above."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "properties", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/functions.html#property"}, {"href": "http://docs.python.org/tutorial/classes.html#private-variables", "text": "__shared_instance", "childNum": 1, "tag": "a", "childList": [{"text": "__shared_instance", "tag": "code"}]}, {"text": "__shared_instance", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I am lost in all these diverse answers."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But I think that what you need is expressed in the following code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class P:\n    pvar=1                    # &lt;--- class attribute\n    def __init__(self,name):\n        self.cname  = name\n\nclass C(P):\n    def __init__(self,name):\n        self.cname  = name\n\n\nc1=C('1')\nc2=C('2')\n\nprint\nprint \"C.pvar ==\",C.pvar,'  id(C.pvar) ==',id(C.pvar)\nprint \"c1.pvar==\",c1.pvar,'  id(c1.pvar)==',id(c1.pvar)\nprint \"c2.pvar==\",c2.pvar,'  id(c2.pvar)==',id(c2.pvar)\n\nprint\nC.pvar = [1,2]\nprint \"instruction   C.pvar = [1,2]   executed\"\nprint \"C.pvar ==\",C.pvar,'  id(C.pvar) ==',id(C.pvar)\nprint \"c1.pvar==\",c1.pvar,'  id(c1.pvar)==',id(c1.pvar)\nprint \"c2.pvar==\",c2.pvar,'  id(c2.pvar)==',id(c2.pvar)\n\nprint\nc2.__class__.pvar = 'sun'\nprint \"instruction   c2.__class__.pvar = 'sun'   executed\"\nprint \"C.pvar ==\",C.pvar,'  id(C.pvar) ==',id(C.pvar)\nprint \"c1.pvar==\",c1.pvar,'  id(c1.pvar)==',id(c1.pvar)\nprint \"c2.pvar==\",c2.pvar,'  id(c2.pvar)==',id(c2.pvar)\n\nprint\nc2.pvar = 145\nprint \"instruction   c2.pvar = 145   executed\"\nprint \"C.pvar ==\",C.pvar,'  id(C.pvar) ==',id(C.pvar)\nprint \"c1.pvar==\",c1.pvar,'  id(c1.pvar)==',id(c1.pvar)\nprint \"c2.pvar==\",c2.pvar,'  id(c2.pvar)==',id(c2.pvar)\n</code>\n</pre>\n", "senID": 2}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n C.pvar == 1   id(C.pvar) == 10021768\nc1.pvar== 1   id(c1.pvar)== 10021768\nc2.pvar== 1   id(c2.pvar)== 10021768\n\ninstruction   C.pvar = [1,2]   executed\nC.pvar == [1, 2]   id(C.pvar) == 18729640\nc1.pvar== [1, 2]   id(c1.pvar)== 18729640\nc2.pvar== [1, 2]   id(c2.pvar)== 18729640\n\ninstruction   c2.__class__.pvar = 'sun'   executed\nC.pvar == sun   id(C.pvar) == 18579136\nc1.pvar== sun   id(c1.pvar)== 18579136\nc2.pvar== sun   id(c2.pvar)== 18579136\n\ninstruction   c2.pvar = 145   executed\nC.pvar == sun   id(C.pvar) == 18579136\nc1.pvar== sun   id(c1.pvar)== 18579136\nc2.pvar== 145   id(c2.pvar)== 10022024\n</code>\n</pre>\n", "senID": 4}, {"text": ["I mean that what you must know is that to change , through an instruction implying directly the name of an instance (and not through a change implying only the parent class's name) the class attribute pvar while it continues to be shared by all the P 's instances, you must write "], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "pvar", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "P", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n c2.__class__.pvar = something\n</code>\n</pre>\n", "senID": 6}, {"text": ["and not "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n c2.pvar =something\n</code>\n</pre>\n", "senID": 8}, {"text": ["Note that C is a class effectively inheriting from a parent class P"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["One thing you must know as a base of the understanding of  functionning of classes and instances:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In the second sentence, I don't exactly understand the meaning of \"by that name\" , but I understand of the global that an attribute is searched first in the namespace of an instance and then in the namespace of its type."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In the following code :"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "For class ", "tag": "none", "senID": 3}]}, {"text": ["the name 'dataclass' and object dataclass really belong to the P class's namespace and only APPARENTLY belong to the c instance's namespace: when c.dataclass is called , that's in fact c.__class__.dataclass that is attained, by the course of search described above."], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": "'dataclass'", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "dataclass", "childNum": 0, "tag": "code", "childList": []}, {"text": "P", "childNum": 0, "tag": "code", "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}, {"text": "c.dataclass", "childNum": 0, "tag": "code", "childList": []}, {"text": "c.__class__.dataclass", "childNum": 0, "tag": "code", "childList": []}]}, {"tag": "ul", "num": 1, "lis": [{"text": "But in an instance ", "tag": "none", "senID": 5}]}, {"text": ["Hence, the only solution to obtain the class's data's value is to call it by its real reference, either PP.data or cc.__class__.data  ."], "childNum": 3, "tag": "p", "senID": 6, "childList": [{"text": "data", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "PP.data", "childNum": 0, "tag": "code", "childList": []}, {"text": "cc.__class__.data", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class   P:\n    dataclass    = \"shareddata\"\n\n    def __init__(self,newdata):\n        self.data   = newdata\n\n    def printname(self):\n        print   self.name\n\nc = P(1)\n\nprint 'P.__dict__.keys()==',P.__dict__.keys()\nprint 'c.__dict__.keys()==',c.__dict__.keys()\nprint  \nprint 'c.data==',c.data\nprint 'c.dataclass==',c.dataclass\n\n\nprint \n\nclass   PP:\n    data    = \"shareddata\"\n\n    def __init__(self,newdata):\n        self.data   = newdata\n\n    def printname(self):\n        print   self.name\n\ncc = PP(2)\nprint 'PP.__dict__.keys()==',PP.__dict__.keys()\nprint 'cc.__dict__.keys()==',cc.__dict__.keys()\nprint\nprint 'cc.data==',cc.data\nprint 'PP.data==',PP.data\nprint 'cc.__class__.data==',cc.__class__.data\n</code>\n</pre>\n", "senID": 7}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n P.__dict__.keys()== ['dataclass', '__module__', 'printname', '__init__', '__doc__']\nc.__dict__.keys()== ['data']\n\nc.data== 1\nc.dataclass== shareddata\n\nPP.__dict__.keys()== ['__module__', 'data', 'printname', '__init__', '__doc__']\ncc.__dict__.keys()== ['data']\n\ncc.data== 2\nPP.data== shareddata\ncc.__class__.data== shareddata\n</code>\n</pre>\n", "senID": 9}, {"text": [], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Note:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Hence, the use of dir(ob) to display the attributes of the object ob is a trap because it display more attributes than the ones belonging strictly to the object."], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "dir(ob)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "ob", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In other words, __dict__ is the real thing, while dir() gives a dashboard, in a sense."], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "__dict__", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "dir()", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["r6d9, please, when you write an update, you should put the date and hour by the word UPDATE.", "It begins to be complcated to follow all that"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Concerning this code of you:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def replaceinstance(parent,child):\n    for item in parent.__dict__.items():\n        child.__dict__.__setitem__(item[0],item[1])\n        print item\n\nclass P(object):\n    def __init__(self,pvar):\n        self.pvar   = pvar\n    def printname(self):\n        print self.name\n\nclass C(P):\n    def __init__(self,name,pobject):\n        P.__init__(self,None)\n        replaceinstance(pobject,self)\n        self.name   = name\n</code>\n</pre>\n", "senID": 4}, {"text": ["it can be replaced by this one:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n class P(object):\n    def __init__(self,pvar):\n        self.pvar   = pvar\n    def printname(self):\n        print self.name\n\nclass C(P):\n    def __init__(self,name,pobject):\n        P.__init__(self,None)\n        self.pvar = pobject.pvar\n        self.name   = name\n</code>\n</pre>\n", "senID": 6}, {"text": ["but it seems to simple "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Finally, I found a way to do it. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The key point is to abandon the aim to obtain instances c with real pvar field, because it is impossible:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "c", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "pvar", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Since it is the same _init_() function (the one being in class P) that processes to create the objects pvar, it isn't possible to create pvar in instances c that will points to the pvar in an instance p to mirror its value and that will also give the possibility to change this value of a p's pvar each time a c's pvar's value will change.", "That makes too much contradictory conditions to verify."], "childNum": 11, "tag": "p", "senID": 2, "childList": [{"text": "_init_()", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "init", "tag": "em"}]}, {"text": "init", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "pvar", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "pvar", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "c", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "pvar", "childNum": 0, "tag": "strong", "childList": []}, {"text": "p", "childNum": 0, "tag": "strong", "childList": []}, {"text": "p", "childNum": 0, "tag": "strong", "childList": []}, {"text": "pvar", "childNum": 0, "tag": "strong", "childList": []}, {"text": "c", "childNum": 0, "tag": "strong", "childList": []}, {"text": "pvar", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Consequently, since the instances c can't have a real pvar field, the best is to set up a mechanism controling the creation of ( with _setattr_ ) and access to ( with _getattr_ )  these c's seemingly pvar objects to give the illusion that they exist."], "childNum": 8, "tag": "p", "senID": 3, "childList": [{"text": "c", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "pvar", "childNum": 0, "tag": "strong", "childList": []}, {"text": "_setattr_", "childNum": 1, "tag": "strong", "childList": [{"text": "setattr", "tag": "em"}]}, {"text": "setattr", "childNum": 0, "tag": "em", "childList": []}, {"text": "_getattr_", "childNum": 1, "tag": "strong", "childList": [{"text": "getattr", "tag": "em"}]}, {"text": "getattr", "childNum": 0, "tag": "em", "childList": []}, {"text": "c", "childNum": 0, "tag": "strong", "childList": []}, {"text": "pvar", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n class P(object):\n    def __init__(self,pvar_arg,foo=\"^^^ \"):\n        self.pvar = pvar_arg\n        self.cat  = foo\n    def printname(self):\n        print self.name\n\nclass C(P):\n\n    def __init__(self,name,pobject,foo=''):\n        self.__dict__['name'] = name\n        P.__init__(self,None,pobject.cat+foo)\n        C.dic[name] = pobject\n\n    def __setattr__(self,xn,val):\n        if xn!='pvar':\n            self.__dict__[xn] = val\n        elif self.name in C.dic:\n            # During the creation of an instance c,\n            # this condition is False because the instruction\n            # C.dic[name] = pobject is  written after \n            # P.__init__(self,None,pobject.cat+foo).\n            # Hence the value of pobject.pvar is preserved,\n            # not changed with the value val being None\n            # due to P.__init__(self,None,pobject.cat+foo)\n            # that provokes self.pvar = pvar_arg and\n            # consequently a call __setattr__(self,'pvar',None)\n            C.dic[self.name].pvar = val\n\n    def __getattribute__(self,xn):\n        if xn=='pvar':\n            return object.__getattribute__(C.dic[self.name],'pvar')\n        else:\n            return object.__getattribute__(self,xn)\n\n    dic = {}\n\n\np1  = P(\"1\")\np2  = P(\"2\",\"QZX \")\nprint '--- p1  = P(\"1\")  and  p2  = P(\"2\",\"QZX \")  executed ---'\nprint \"p1.__dict__  ==\",p1.__dict__\nprint \"p2.__dict__  ==\",p2.__dict__\nprint 'p1.pvar==',p1.pvar\nprint 'p2.pvar==',p2.pvar\n\nc1a = C(\"c1a\",p1,'sea')\nc1b = C(\"c1b\",p1,'mountain')\nc1c = C(\"c1c\",p1,'desert')\nc2a = C(\"c2a\",p2,'banana')\nc2b = C(\"c2b\",p2)\nc2c = C(\"c2c\",p2,'pear')\nprint '\\n--- creations of c1a, c1b, c1c, c2a, c2b, c2c executed ---'\nprint \"p1.__dict__  ==\",p1.__dict__\nprint \"p2.__dict__  ==\",p2.__dict__\nprint \"c1a.__dict__ ==\",c1a.__dict__\nprint \"c1b.__dict__ ==\",c1b.__dict__\nprint \"c1c.__dict__ ==\",c1c.__dict__\nprint \"c2a.__dict__ ==\",c2a.__dict__\nprint \"c2b.__dict__ ==\",c2b.__dict__\nprint \"c2c.__dict__ ==\",c2c.__dict__\nprint 'p1.pvar==',p1.pvar\nprint 'p2.pvar==',p2.pvar\nprint '(c1a.pvar, c1b.pvar, c1c.pvar)==',(c1a.pvar,c1b.pvar,c1c.pvar)\nprint '(c2a.pvar, c2b.pvar, c2c.pvar)==',(c2a.pvar,c2b.pvar,c2c.pvar)\n\nc1a.pvar = \"newpvar1\"\nprint '\\n--- c1a.pvar = \"newpvar1\"  executed ---'\nprint 'p1.pvar==',p1.pvar\nprint 'p2.pvar==',p2.pvar\nprint '(c1a.pvar, c1b.pvar, c1c.pvar)==',(c1a.pvar,c1b.pvar,c1c.pvar)\nprint '(c2a.pvar, c2b.pvar, c2c.pvar)==',(c2a.pvar,c2b.pvar,c2c.pvar)\n\nc2c.pvar = 45789\nprint '\\n--- c2c.pvar = 45789  executed ---'\nprint 'p1.pvar==',p1.pvar\nprint 'p2.pvar==',p2.pvar\nprint '(c1a.pvar, c1b.pvar, c1c.pvar)==',(c1a.pvar,c1b.pvar,c1c.pvar)\nprint '(c2a.pvar, c2b.pvar, c2c.pvar)==',(c2a.pvar,c2b.pvar,c2c.pvar)\n</code>\n</pre>\n", "senID": 4}, {"text": ["result"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n --- p1  = P(\"1\")  and  p2  = P(\"2\",\"QZX \")  executed ---\np1.__dict__  == {'cat': '^^^ ', 'pvar': '1'}\np2.__dict__  == {'cat': 'QZX ', 'pvar': '2'}\np1.pvar== 1\np2.pvar== 2\n\n--- creations of c1a, c1b, c1c, c2a, c2b, c2c executed ---\np1.__dict__  == {'cat': '^^^ ', 'pvar': '1'}\np2.__dict__  == {'cat': 'QZX ', 'pvar': '2'}\nc1a.__dict__ == {'name': 'c1a', 'cat': '^^^ sea'}\nc1b.__dict__ == {'name': 'c1b', 'cat': '^^^ mountain'}\nc1c.__dict__ == {'name': 'c1c', 'cat': '^^^ desert'}\nc2a.__dict__ == {'name': 'c2a', 'cat': 'QZX banana'}\nc2b.__dict__ == {'name': 'c2b', 'cat': 'QZX '}\nc2c.__dict__ == {'name': 'c2c', 'cat': 'QZX pear'}\np1.pvar== 1\np2.pvar== 2\n(c1a.pvar, c1b.pvar, c1c.pvar)== ('1', '1', '1')\n(c2a.pvar, c2b.pvar, c2c.pvar)== ('2', '2', '2')\n\n--- c1a.pvar = \"newpvar1\"  executed ---\np1.pvar== newpvar1\np2.pvar== 2\n(c1a.pvar, c1b.pvar, c1c.pvar)== ('newpvar1', 'newpvar1', 'newpvar1')\n(c2a.pvar, c2b.pvar, c2c.pvar)== ('2', '2', '2')\n\n--- c2c.pvar = 45789  executed ---\np1.pvar== newpvar1\np2.pvar== 45789\n(c1a.pvar, c1b.pvar, c1c.pvar)== ('newpvar1', 'newpvar1', 'newpvar1')\n(c2a.pvar, c2b.pvar, c2c.pvar)== (45789, 45789, 45789)\n</code>\n</pre>\n", "senID": 6}, {"text": ["Remarks:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["EDIT 1"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["I think it's better to write "], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n def __setattr__(self,xn,val):\n    if xn=='pvar':\n        self.__class__.dic[self.name].pvar = val\n</code>\n</pre>\n", "senID": 11}, {"text": ["than "], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n def __setattr__(self,xn,val):\n    if xn=='pvar':\n        C.dic[self.name].pvar = val\n</code>\n</pre>\n", "senID": 13}, {"text": ["In the first case, the interpreter has to search for the reference to the self's class C ( that is to say under the name '_class_' ) in the namespace of self."], "childNum": 4, "tag": "p", "senID": 14, "childList": [{"text": "self", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "C", "childNum": 0, "tag": "strong", "childList": []}, {"text": "'_class_'", "childNum": 1, "tag": "strong", "childList": [{"text": "class", "tag": "em"}]}, {"text": "class", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["In the second case, the interpreter  must search for the same reference ( but under the name 'C') in the namespace of the level in which classes P and C are defined. "], "childNum": 3, "tag": "p", "senID": 15, "childList": [{"text": "'C'", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "P", "childNum": 0, "tag": "strong", "childList": []}, {"text": "C", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["This second namespace may be  more more  big than the limited namespace of an instance.", "In the first case, the name '_class_'  is looked for as a key in the dictionary implementing the self's namespace.", "In the second, the name 'C' is the key searched for in the dictionary of the level inclosing the classes P and C."], "childNum": 5, "tag": "p", "senID": 16, "childList": [{"text": "'_class_'", "childNum": 1, "tag": "strong", "pos": 1, "childList": [{"text": "class", "tag": "em"}]}, {"text": "class", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "'C'", "childNum": 0, "tag": "strong", "childList": []}, {"text": "P", "childNum": 0, "tag": "strong", "childList": []}, {"text": "C", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["The identity of these two objects can be verified with the function id()"], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "id()", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"text": ["EDIT 2"], "childNum": 0, "tag": "p", "senID": 20, "childList": []}, {"text": ["There is another possibility for the dic object: instead of making it a class attribute of the class C, it can be defined in the outer scope of the class C. If this outer level is a module, then dic is a global object."], "childNum": 4, "tag": "p", "senID": 21, "childList": [{"text": "dic", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "C", "childNum": 0, "tag": "strong", "childList": []}, {"text": "C", "childNum": 0, "tag": "strong", "childList": []}, {"text": "dic", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n class P(object):\n    def __init__(self,pvar,foo=\"^^^ \"):\n        self.pvar   = pvar\n        self.cat = foo\n    def printname(self):\n        print self.name\n\nclass C(P):\n\n    def __init__(self,name,pobject,foo=''):\n        self.__dict__['name'] = name\n        P.__init__(self,None,pobject.cat+foo)\n        dic[name] = pobject\n\n    def __setattr__(self,xn,val):\n        if xn!='pvar':\n            self.__dict__[xn] = val\n        elif self.name in dic:\n            # During the creation of an instance c,\n            # this condition is False because the instruction\n            # dic[name] = pobject is  written after \n            # P.__init__(self,None,pobject.cat+foo).\n            # Hence the value of pobject.pvar is preserved,\n            # not changed with the value val being None\n            # due to P.__init__(self,None,pobject.cat+foo)\n            # that provokes self.pvar = pvar_arg and\n            # consequently a call __setattr__(self,'pvar',None)\n            dic[self.name].pvar = val\n\n    def __getattribute__(self,xn):\n        if xn=='pvar':\n            return object.__getattribute__(dic[self.name],'pvar')\n        else:\n            return object.__getattribute__(self,xn)\n\n\ndic = {}\n</code>\n</pre>\n", "senID": 22}, {"text": ["The result is exactly the same"], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"text": ["Doing so, dic looses its OOish nature."], "childNum": 1, "tag": "p", "senID": 24, "childList": [{"text": "dic", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": [], "childNum": 0, "tag": "p", "senID": 25, "childList": []}, {"text": [], "childNum": 0, "tag": "p", "senID": 26, "childList": []}, {"text": ["EDIT 3"], "childNum": 0, "tag": "p", "senID": 27, "childList": []}, {"text": ["At last, there is still another way: instead of creating an illusory attribute pvar for each instance c with help of functions __setattr__ and __getattribute__ , it is better, according to me, to use a function with the dictionary dic as a default argument and that will replace them."], "childNum": 5, "tag": "p", "senID": 28, "childList": [{"text": "pvar", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "c", "childNum": 0, "tag": "strong", "childList": []}, {"text": "__setattr__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__getattribute__", "childNum": 0, "tag": "code", "childList": []}, {"text": "dic", "childNum": 0, "tag": "strong", "childList": []}]}, {"code": "<pre>\n<code>\n class P(object):\n    def __init__(self,pvar,foo=\"^^^ \"):\n        self.pvar   = pvar\n        self.cat = foo\n    def printname(self):\n        print self.name\n\nclass C(P):\n    def __init__(self,name,pobject,foo=''):\n        P.__init__(self,None,pobject.cat+foo)\n        self.__dict__['name'] = name\n        del self.pvar\n        self.pvar(pobject)\n\n    def pvar(self,x = None,dic = {}):\n        if x.__class__==P: # a pobject\n            dic[self.name] = x\n        elif x: # a value\n            dic[self.name].pvar = x\n        else: # to return value\n            return dic[self.name].pvar\n\np1  = P(\"1\")\np2  = P(\"2\",\"QZX \")\nprint '--- p1  = P(\"1\")  and  p2  = P(\"2\",\"QZX \")  executed ---'\nprint \"p1.__dict__  ==\",p1.__dict__\nprint \"p2.__dict__  ==\",p2.__dict__\nprint 'p1.pvar==',p1.pvar\nprint 'p2.pvar==',p2.pvar\n\nc1a = C(\"c1a\",p1,'sea')\nc1b = C(\"c1b\",p1,'mountain')\nc1c = C(\"c1c\",p1,'desert')\nc2a = C(\"c2a\",p2,'banana')\nc2b = C(\"c2b\",p2)\nc2c = C(\"c2c\",p2,'pear')\nprint '\\n--- creations of c1a, c1b, c1c, c2a, c2b, c2c executed ---'\nprint \"p1.__dict__  ==\",p1.__dict__\nprint \"p2.__dict__  ==\",p2.__dict__\nprint \"c1a.__dict__ ==\",c1a.__dict__\nprint \"c1b.__dict__ ==\",c1b.__dict__\nprint \"c1c.__dict__ ==\",c1c.__dict__\nprint \"c2a.__dict__ ==\",c2a.__dict__\nprint \"c2b.__dict__ ==\",c2b.__dict__\nprint \"c2c.__dict__ ==\",c2c.__dict__\nprint 'p1.pvar==',p1.pvar\nprint 'p2.pvar==',p2.pvar\nprint   '(c1a.pvar(),c1b.pvar(),c1c.pvar())==',(c1a.pvar(),c1b.pvar(),c1c.pvar())\nprint   '(c2a.pvar(),c2b.pvar(),c2c.pvar())==',(c2a.pvar(),c2b.pvar(),c2c.pvar())\n\nc1a.pvar(\"newpvar1\")\nprint '\\n--- c1a.pvar(\"newpvar1\")  executed ---'\nprint 'p1.pvar==',p1.pvar\nprint 'p2.pvar==',p2.pvar\nprint   '(c1a.pvar(),c1b.pvar(),c1c.pvar())==',(c1a.pvar(),c1b.pvar(),c1c.pvar())\nprint   '(c2a.pvar(),c2b.pvar(),c2c.pvar())==',(c2a.pvar(),c2b.pvar(),c2c.pvar())\n\nc2c.pvar(45789)\nprint '\\n--- c2c.pvar(45789) ---'\nprint 'p1.pvar==',p1.pvar\nprint 'p2.pvar==',p2.pvar\nprint   '(c1a.pvar(),c1b.pvar(),c1c.pvar())==',(c1a.pvar(),c1b.pvar(),c1c.pvar())\nprint   '(c2a.pvar(),c2b.pvar(),c2c.pvar())==',(c2a.pvar(),c2b.pvar(),c2c.pvar())\n</code>\n</pre>\n", "senID": 29}, {"text": ["Results are the same, only use of c.pvar() is slightly different:"], "childNum": 0, "tag": "p", "senID": 30, "childList": []}, {"code": "<pre>\n<code>\n --- p1  = P(\"1\")  and  p2  = P(\"2\",\"QZX \")  executed ---\np1.__dict__  == {'cat': '^^^ ', 'pvar': '1'}\np2.__dict__  == {'cat': 'QZX ', 'pvar': '2'}\np1.pvar== 1\np2.pvar== 2\n\n--- creations of c1a, c1b, c1c, c2a, c2b, c2c executed ---\np1.__dict__  == {'cat': '^^^ ', 'pvar': '1'}\np2.__dict__  == {'cat': 'QZX ', 'pvar': '2'}\nc1a.__dict__ == {'cat': '^^^ sea', 'name': 'c1a'}\nc1b.__dict__ == {'cat': '^^^ mountain', 'name': 'c1b'}\nc1c.__dict__ == {'cat': '^^^ desert', 'name': 'c1c'}\nc2a.__dict__ == {'cat': 'QZX banana', 'name': 'c2a'}\nc2b.__dict__ == {'cat': 'QZX ', 'name': 'c2b'}\nc2c.__dict__ == {'cat': 'QZX pear', 'name': 'c2c'}\np1.pvar== 1\np2.pvar== 2\n(c1a.pvar(),c1b.pvar(),c1c.pvar())== ('1', '1', '1')\n(c2a.pvar(),c2b.pvar(),c2c.pvar())== ('2', '2', '2')\n\n--- c1a.pvar(\"newpvar1\")  executed ---\np1.pvar== newpvar1\np2.pvar== 2\n(c1a.pvar(),c1b.pvar(),c1c.pvar())== ('newpvar1', 'newpvar1', 'newpvar1')\n(c2a.pvar(),c2b.pvar(),c2c.pvar())== ('2', '2', '2')\n\n--- c2c.pvar(45789) ---\np1.pvar== newpvar1\np2.pvar== 45789\n(c1a.pvar(),c1b.pvar(),c1c.pvar())== ('newpvar1', 'newpvar1', 'newpvar1')\n(c2a.pvar(),c2b.pvar(),c2c.pvar())== (45789, 45789, 45789)\n</code>\n</pre>\n", "senID": 31}, {"text": ["Note that in this last code P's instances can't be values of C'instances because a pobject passed to a c.pvar() method will never be considered as a value."], "childNum": 4, "tag": "p", "senID": 32, "childList": [{"text": "P", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "C", "childNum": 0, "tag": "strong", "childList": []}, {"text": "pobject", "childNum": 0, "tag": "strong", "childList": []}, {"text": "c.pvar()", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["Okay, I think you might want to rephrase your question as:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["How can I extend Python's OOP to make inheritance work on the level of objects rather than classes?"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "How can I extend Python's OOP to make inheritance work on the level of objects rather than classes?", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["First off - don't mess with the dicts:\nIf you are just copying the entries of the parent dict over to the child-dict, this works for instantiation, but  changes in any of the dicts will not automagically update entries in all the other dicts.", "Assigning a new value to an attribute will simply create a new reference, so the attribute will not point to the same object any more. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "First off - don't mess with the dicts:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["The solution is to tell python to look for the attribute in the right place using some Python magic ..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n class ProxyMixin (object):\n\n    def __init__(self, parent):\n        self.parent = parent\n\n    def __getattribute__(self, name):\n        if name != 'parent' and hasattr(self.parent, name):\n            return getattr(self.parent, name)\n        else:\n            return object.__getattribute__(self, name)\n\n    def __setattr__(self, name, val):\n        if name != 'parent' and hasattr(self.parent, name):\n            setattr(self.parent, name)\n        else:\n            object.__setattr__(self, name, val)\n</code>\n</pre>\n", "senID": 4}, {"text": ["(see the python reference on attribute access)"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "python reference on attribute access", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html#attribute-access"}]}, {"text": ["Just add the ProxyMixin to your child class, and you will be fine."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n class P:\n    data = \"shared data\"\n    def __init__(self, name):\n        self.name = name\n    def printname(self):\n        print self.name\n\nclass C(P, ProxyMixin):\n    def __init__(self, parent=None):\n        if parent:\n            ProxyMixin.__init__(self, parent)\n</code>\n</pre>\n", "senID": 7}, {"text": ["Now youn can dynamically rewire the parent object at any time using a simple assignment:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n c.parent = newparent\n</code>\n</pre>\n", "senID": 9}]]