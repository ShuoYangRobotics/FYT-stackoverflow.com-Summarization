[[{"text": ["Two Zen of Python principles leap to mind:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Zen of Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0020/"}]}, {"tag": "ul", "num": 2, "lis": [{"text": "Simple is better than complex.", "tag": "none", "senID": 1}, {"text": "There should be one\u2014and preferably only one\u2014obvious way to do it.", "tag": "none", "senID": 2}]}, {"text": ["The Python built-in function range(start, end) generates a list from start to end.1 The first element of that list is start, and the last element is end - 1."], "childNum": 6, "tag": "p", "senID": 3, "childList": [{"text": "range(start, end)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "start", "childNum": 0, "tag": "code", "childList": []}, {"text": "end", "childNum": 0, "tag": "code", "childList": []}, {"text": "1", "childNum": 0, "tag": "sup", "childList": []}, {"text": "start", "childNum": 0, "tag": "code", "childList": []}, {"text": "end - 1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["There is no range_strict function or inclusive_range function.", "This was very awkward to me when I started in Python.", "(\"I just want a list from a to b inclusive!", "How hard is that, Guido?", "\") However, the convention used in calling the range function was simple and easy to remember, and the lack of multiple functions made it easy to remember exactly how to generate a range every time."], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "range_strict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "inclusive_range", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "range", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"text": ["As you've probably guessed, my recommendation is to only create a function to test whether i is in the range [j, k).", "In fact, my recommendation is to keep only your existing inRange function."], "childNum": 4, "tag": "p", "senID": 5, "childList": [{"text": "i", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "j", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "k", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "inRange", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["(Since your question specifically mentions Pythonicity, I would recommend you name the function as in_range to better fit with the Python Style Guide."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "in_range", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://www.python.org/dev/peps/pep-0008/", "text": "Python Style Guide", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Why is this a good idea?"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": ["The single function is easy to understand.", "It is very easy to learn how to use it."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "The single function is easy to understand. It is very easy to learn how to use it.", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["There is only one function to learn.", "There are not three functions with necessarily similar names."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "There is only one function to learn. There are not three functions with necessarily similar names.", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["The function is easy to edit."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "The function is easy to edit.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["The \"size\" of the range is obvious."], "childNum": 1, "tag": "p", "senID": 11, "childList": [{"text": "The \"size\" of the range is obvious.", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}]}, {"text": ["I'm approaching this problem from a completely generic point of view, such as that of a person writing a function for a publicly-released library.", "Since I don't know your problem domain, I can't say whether this is a practical solution."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Using this solution may mean a fair bit of refactoring of the code that calls these functions.", "Look through this code to see if editing it is prohibitively difficult or tedious."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"tag": "hr", "senID": 14}, {"text": ["1: Actually, it is range([start], end, [step]).", "I trust you get what I mean though."], "childNum": 2, "tag": "p", "senID": 15, "childList": [{"text": "1", "childNum": 0, "tag": "sup", "pos": 0, "childList": []}, {"text": "range([start], end, [step])", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["The Pythonic way to do it is to choose readability, and therefor keep the 3 methods as they were at the beginning."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It's not like they are HUGE methods, or there are thousand of them, or you would have to dynamically generate them."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["No higher-order functions, but it's less code, even with the extraneous else."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "else", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def exclusive(i, j, k):\n    if j &lt;= k:\n        return j &lt; i &lt; k\n    else:\n        return j &lt; i or i &lt; k\n\ndef inclusive_left(i, j, k):\n    return i==j or exclusive(i, j, k)\n\ndef inclusive_right(i, j, k):\n    return i==k or exclusive(i, j, k)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I actually tried switching the identifiers to n, a, b, but the code began to look less cohesive.", "(My point: perfecting this code may not be a productive use of time."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "n, a, b", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Now I am thinking of something such as:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def comparator(lop, rop):\n    def comp(i, j, k):\n        if j &lt;= k:\n            return lop(j, i) and rop(i,k)\n        return lop(j, i) or rop(i,k)\n\n    return comp\n\nfrom operator import le, lt\n\ninRange = comparator(le, lt)\ninStrictRange = comparator(lt, lt)\ninRange2 = comparator(lt, le)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which looks better indeed."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I certainly agree that you need only one function, and that the function should use a (Pythonic) half-open range."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Two suggestions:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["To make it more familiar to your users, I would have one main in_range function with the same bounds as range().", "This makes it much easier to remember, and has other nice properties as Wesley mentioned."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def in_range(i, j, k):\n    return (j &lt;= i &lt; k) if j &lt;= k else (j &lt;= i or i &lt; k)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can certainly use this one alone for all your use cases by adding 1 to j and/or k. If you find that you're using a specific form frequently, then you can define it in terms of the main one:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def exclusive(i, j, k):\n    \"\"\"Excludes both endpoints.\"\"\"\n    return in_range(i, j + 1, k)\n\ndef inclusive(i, j, k):\n    \"\"\"Includes both endpoints.\"\"\"\n    return in_range(i, j, k + 1)\n\ndef weird(i, j, k):\n    \"\"\"Excludes the left endpoint but includes the right endpoint.\"\"\"\n    return in_range(i, j + 1, k + 1)\n</code>\n</pre>\n", "senID": 3}, {"text": ["This is shorter than mucking around with operators, and is also much less confusing to understand.", "Also, note that you should use underscores instead of camelCase for function names in Python."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I'd go one step further than Wesley in aping the normal python 'in range' idiom; i'd write a cyclic_range class:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\nMAX = 10 # or whatever\n\nclass cyclic_range(object):\n\tdef __init__(self, start, stop):\n\t\t# mod so you can be a bit sloppy with indices, plus -1 means the last element, as with list indices\n\t\tself.start = start % MAX\n\t\tself.stop = stop % MAX\n\tdef __len__(self):\n\t\treturn (self.stop - self.start) % MAX\n\tdef __getitem__(self, i):\n\t\treturn (self.start + i) % MAX\n\tdef __contains__(self, x):\n\t\tif (self.start &lt; self.stop):\n\t\t\treturn (x &gt;= self.start) and (x &lt; self.stop)\n\t\telse:\n\t\t\treturn (x &gt;= self.start) or (x &lt; self.stop)\n\tdef __iter__(self):\n\t\tfor i in xrange(len(self)):\n\t\t\tyield self[i]\n\tdef __eq__(self, other):\n\t\tif (len(self) != len(other)): return False\n\t\tfor a, b in itertools.izip(self, other):\n\t\t\tif (a != b): return False\n\t\treturn True\n\tdef __hash__(self):\n\t\treturn (self.start &lt;&lt; 1) + self.stop\n\tdef __str__(self):\n\t\treturn str(list(self))\n\tdef __repr__(self):\n\t\treturn \"cyclic_range(\" + str(self.start) + \", \" + str(self.stop) + \")\"\n\t# and whatever other list-like methods you fancy\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can then write code like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if (myIndex in cyclic_range(firstNode, stopNode)):\n\tblah\n</code>\n</pre>\n", "senID": 3}, {"text": ["To do the equivalent of inRange.", "To do inStrictRange, write:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n if (myIndex in cyclic_range(firstNode + 1, stopNode)):\n</code>\n</pre>\n", "senID": 5}, {"text": ["And to do inRange2:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n if (myIndex in cyclic_range(firstNode + 1, stopNode + 1)):\n</code>\n</pre>\n", "senID": 7}, {"text": ["If you don't like doing the additions by hand, how about adding these methods:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n def strict(self):\n\t\treturn cyclic_range(self.start + 1, self.stop)\n\tdef right_closed(self):\n\t\treturn cyclic_range(self.start + 1, self.stop + 1)\n</code>\n</pre>\n", "senID": 9}, {"text": ["And then doing:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n if (myIndex in cyclic_range(firstNode, stopNode).strict()): # inStrictRange\nif (myIndex in cyclic_range(firstNode, stopNode).closed_right()): # inRange2\n</code>\n</pre>\n", "senID": 11}, {"text": ["Whilst this approach is, IMHO, more readable, it does involve doing an allocation, rather than just a function call, which is more expensive - although still O(1).", "But then if you really cared about performance, you wouldn't be using python!"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}]]