[[{"text": ["1) Keys must not be mutable, unless you have a user-defined class that is hashable but also mutable.", "That's all that's forced upon you.", "However, using a hashable, mutable object as a dict key might be a bad idea."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "unless", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "However, using a hashable, mutable object as a dict key might be a bad idea.", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["2) By not sharing values between the two dicts.", "It's OK to share the keys, because they must be immutable.", "Copying the dictionary, in the copy module sense, is definitely safe.", "Calling the dict constructor here works, too: b = dict(a).", "You could also use immutable values."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "copy", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "b = dict(a)", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["3) All built-in immutable types are hashable.", "All built-in mutable types are not hashable.", "For an object to be hashable, it must have the same hash over its entire lifetime, even if it is mutated."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["4) Not that I'm aware of; I'm describing 2.x."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["A type is mutable if it is not immutable.", "A type is immutable if it is a built-in immutable type: str, int, long, bool, float, tuple, and probably a couple others I'm forgetting.", "User-defined types are always mutable."], "childNum": 6, "tag": "p", "senID": 4, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "long", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "bool", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "float", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["An object is mutable if it is not immutable.", "An object is immutable if it consists, recursively, of only immutable-typed sub-objects.", "Thus, a tuple of lists is mutable; you cannot replace the elements of the tuple, but you can modify them through the list interface, changing the overall data."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["some additional thoughts:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "some additional thoughts", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["There are two main things to know for understanding the behavior of keys: keys must be hashable (which means they implement object.__hash__(self)) and they must also be \"comparable\" (which means they implement something like object.__cmp__(self)).", "One important take-away from the docs: by default, user-defined objects' hash functions return id()."], "childNum": 8, "tag": "p", "senID": 1, "childList": [{"text": "keys", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "hashable", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/glossary.html#term-hashable"}, {"text": "object.__hash__(self)", "tag": "a", "pos": -1, "childList": [{"text": "object.__hash__(self)", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/reference/datamodel.html#object.__hash__"}, {"text": "object.__hash__(self)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "object.__cmp__(self)", "tag": "a", "pos": -1, "childList": [{"text": "object.__cmp__(self)", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/reference/datamodel.html#object.__cmp__"}, {"text": "object.__cmp__(self)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "id()", "tag": "a", "pos": 1, "childList": [{"text": "id()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#id"}, {"text": "id()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Consider this example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class K(object):\n  def __init__(self, x, y):\n     self.x = x\n     self.y = y\n  def __hash__(self):\n     return self.x + self.y\n\nk1 = K(1, 2)\nd1 = {k1: 3}\nd1[k1] # outputs 3\nk1.x = 5\nd1[k1] # KeyError!  The key's hash has changed!\nk2 = K(2, 1)\nd1[k2] # KeyError!  The key's hash is right, but the keys aren't equal.\nk1.x = 1\nd1[k1] # outputs 3\n\nclass NewK(object):\n  def __init__(self, x, y):\n     self.x = x\n     self.y = y\n  def __hash__(self):\n     return self.x + self.y\n  def __cmp__(self, other):\n     return self.x - other.x\n\nnk1 = NewK(3, 4)\nnd1 = {nk1: 5}\nnd1[nk1] # outputs 5\nnk2 = NewK(3, 7)\nnk1 == nk2 # True!\nnd1[nk2] # KeyError! The keys' hashes differ.\nhash(nk1) == hash(nk2) # False\nnk2.y = 4\nnd1[nk2] # outputs 5\n\n# Where this can cause issues:\nnd1.keys()[0].x = 5\nnd1[nk1] # KeyError! nk1 is no longer in the dict!\nid(nd1.keys()[0]) == id(nk1)  # Yikes. True?!\nnd1.keys()[0].x = 3\nnd1[nk1]  # outputs 5\nid(nd1.keys()[0]) == id(nk1)  # True!\n</code>\n</pre>\n", "senID": 3}, {"text": ["Values are much easier to understand, the dict stores references to objects.", "Read the sections on hashable.", "Things like strings are immutable, if you \"change\" them, the dict you changed it in now references a new object.", "Objects which are mutable can be \"changed in-place\", hence the value of both dicts will change."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Values", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n d1 = {1: 'a'}\nd2 = d1.copy()\nid(d1[1]) == id(d2[1]) # True\nd2[1] = 'z'\nid(d1[1]) == id(d2[1]) # False\n\n# the examples in section 2 above have more examples of this.\n</code>\n</pre>\n", "senID": 5}, {"text": ["Anyway, here are the main points of all this:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "For ", "tag": "none", "senID": 7}, {"text": "You care about mutability for values, because by definition, a mutable object's value can be changed without changing the reference to it.", "tag": "none", "senID": 8}]}, {"text": ["I do not think there is a general way to test either of those points.", "The tests for suitability would depend on your use-case.", "For instance, it may be sufficient to check that an object does or does not implement __hash__ and comparison (__eq__ or __cmp__) functions.", "Like-wise, you might be able to \"check\" an object's __setattr__ method in some way to determine if it is mutable."], "childNum": 4, "tag": "p", "senID": 9, "childList": [{"text": "__hash__", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__eq__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__cmp__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__setattr__", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["There's really no guarantee that a type which is hashable is also immutable, but at very least, correctly implementing __hash__ requires that the type is immutable, with respect to it's own hash, and to equality.", "This is not enforced in any particular way.  "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "guarantee", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "__hash__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["However, we are all adults.", "It would be unwise to implement __hash__ unless you really meant it.", "Roughly speaking, this just boils down to saying that if a type actually can be used as a dictionary key, then it is intended to be used in that way."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__hash__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If you're looking for something that is like a dict, but also immutable, then namedtuple might be your best bet from what's in the standard library.", "Admittedly it's not a very good approximation, but it's a start."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "like", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "namedtuple", "tag": "a", "pos": -1, "childList": [{"text": "namedtuple", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/dev/library/collections.html#collections.namedtuple"}, {"text": "namedtuple", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["There isn't actually any such thing as mutability or immutability at the language level in Python.", "Some objects provide no way to change them (eg.", "strings and tuples), and so are effectively immutable, but it's purely conceptual; there's no property at the language level indicating this, neither to your code nor to Python itself."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "effectively", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Immutability is not actually relevant to dicts; it's perfectly fine to use mutable values as keys.", "What matters is comparison and hashing: the object must always remain equal to itself.", "For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class example(object):\n    def __init__(self, a):\n        self.value = a\n    def __eq__(self, rhs):\n        return self.value == rhs.value\n    def __hash__(self):\n        return hash(self.value)\n\na = example(1)\nd = {a: \"first\"}\na.data = 2\nprint d[example(1)]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Here, example is not immutable; we're modifying it with a.data = 2.", "Yet, we're using it as a key of a hash without any trouble.", "Why?", "The property we're changing has no effect on equality: the hash is unchanged, and example(1) is always equal to example(1), ignoring any other properties."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "example", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "a.data = 2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "example(1)", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "example(1)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The most common use of this is caching and memoization: having a property cached or not doesn't logically change the object, and usually has no effect on equality."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["(I'm going to stop here--please don't ask five questions at once."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["There are MutableSequence, MutableSet, MutableMapping in module collections.", "Which can be used to check mutability of premade types."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "collections", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/py3k/library/collections.html"}]}, {"code": "<pre>\n<code>\n issubclass(TYPE, (MutableSequence, MutableSet, MutableMapping))\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want use this on user defined types, the type must be either inherited from one of them or registered as a virtual subclass."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class x(MutableSequence):\n    ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["or"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class x:\n    ...\n\nabc.ABCMeta.register(MutableSequence,x)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Dicts are unordered sets of key:value pairs.", "The keys must be immutable, and therefore hashable.", "To determine if an object is hashable, you can use the hash() function:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "hash()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; hash(1)\n1\n&gt;&gt;&gt; hash('a')\n12416037344\n&gt;&gt;&gt; hash([1,2,3])\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'list'\n&gt;&gt;&gt; hash((1,2,3))\n2528502973977326415\n&gt;&gt;&gt; hash({1: 1})\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unhashable type: 'dict'\n</code>\n</pre>\n", "senID": 1}, {"text": ["The values, on the other hand, can be any object.", "If you need to check if an object is immutable, then I would use hash()."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "hash()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]