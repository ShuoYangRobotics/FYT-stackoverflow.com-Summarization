[[{"text": ["pyparsing is pretty handy for quick and simple parsing like this.", "A bare minimum would be something like:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pyparsing", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/Introduction"}]}, {"code": "<pre>\n<code>\n import pyparsing\nstring = pyparsing.CharsNotIn(\"{} \\t\\r\\n\")\ngroup = pyparsing.Forward()\ngroup &lt;&lt; pyparsing.Group(pyparsing.Literal(\"{\").suppress() + \n                         pyparsing.ZeroOrMore(group) + \n                         pyparsing.Literal(\"}\").suppress()) \n        | string\n\ntoplevel = pyparsing.OneOrMore(group)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The use it as:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; toplevel.parseString(text)\n['protocol', 'sample_thread', [['AUTOSTART', '0'], ['BITMAP', 'thread.gif'], \n['COORDS', ['0', '0']], ['DATAFORMAT', [['TYPE', 'hl7'], ['PREPROCS', \n[['ARGS', [[]]], ['PROCS', 'sample_proc']]]]]]]\n</code>\n</pre>\n", "senID": 3}, {"text": ["From there you can get more sophisticated as you want (parse numbers seperately from strings, look for specific field names etc).", "The above is pretty general, just looking for strings (defined as any non-whitespace character except \"{\" and \"}\") and {} delimited lists of strings."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Taking Brian's pyparsing solution another step, you can create a quasi-deserializer for this format by using the Dict class:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import pyparsing\n\nstring = pyparsing.CharsNotIn(\"{} \\t\\r\\n\")\n# use Word instead of CharsNotIn, to do whitespace skipping\nstringchars = pyparsing.printables.replace(\"{\",\"\").replace(\"}\",\"\")\nstring = pyparsing.Word( stringchars )\n# define a simple integer, plus auto-converting parse action\ninteger = pyparsing.Word(\"0123456789\").setParseAction(lambda t : int(t[0]))\ngroup = pyparsing.Forward()\ngroup &lt;&lt; ( pyparsing.Group(pyparsing.Literal(\"{\").suppress() +\n    pyparsing.ZeroOrMore(group) +\n    pyparsing.Literal(\"}\").suppress())\n    | integer | string )\n\ntoplevel = pyparsing.OneOrMore(group)\n\nsample = \"\"\"\nprotocol sample_thread {\n    { AUTOSTART 0 }\n    { BITMAP thread.gif }\n    { COORDS {0 0} }\n    { DATAFORMAT {\n        { TYPE hl7 }\n        { PREPROCS {\n            { ARGS {{}} }\n            { PROCS sample_proc }\n        } }\n    } } \n    }\n\"\"\"\n\nprint toplevel.parseString(sample).asList()\n\n# Now define something a little more meaningful for a protocol structure, \n# and use Dict to auto-assign results names\nLBRACE,RBRACE = map(pyparsing.Suppress,\"{}\")\nprotocol = ( pyparsing.Keyword(\"protocol\") + \n             string(\"name\") + \n             LBRACE + \n             pyparsing.Dict(pyparsing.OneOrMore(\n                pyparsing.Group(LBRACE + string + group + RBRACE)\n                ) )(\"parameters\") + \n             RBRACE )\n\nresults = protocol.parseString(sample)\nprint results.name\nprint results.parameters.BITMAP\nprint results.parameters.keys()\nprint results.dump()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Prints"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ['protocol', 'sample_thread', [['AUTOSTART', 0], ['BITMAP', 'thread.gif'], ['COORDS', \n\n[0, 0]], ['DATAFORMAT', [['TYPE', 'hl7'], ['PREPROCS', [['ARGS', [[]]], ['PROCS', 'sample_proc']]]]]]]\nsample_thread\nthread.gif\n['DATAFORMAT', 'COORDS', 'AUTOSTART', 'BITMAP']\n['protocol', 'sample_thread', [['AUTOSTART', 0], ['BITMAP', 'thread.gif'], ['COORDS', [0, 0]], ['DATAFORMAT', [['TYPE', 'hl7'], ['PREPROCS', [['ARGS', [[]]], ['PROCS', 'sample_proc']]]]]]]\n- name: sample_thread\n- parameters: [['AUTOSTART', 0], ['BITMAP', 'thread.gif'], ['COORDS', [0, 0]], ['DATAFORMAT', [['TYPE', 'hl7'], ['PREPROCS', [['ARGS', [[]]], ['PROCS', 'sample_proc']]]]]]\n  - AUTOSTART: 0\n  - BITMAP: thread.gif\n  - COORDS: [0, 0]\n  - DATAFORMAT: [['TYPE', 'hl7'], ['PREPROCS', [['ARGS', [[]]], ['PROCS', 'sample_proc']]]]\n</code>\n</pre>\n", "senID": 3}, {"text": ["I think you will get further faster with pyparsing."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["-- Paul"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I'll try and answer what I think is the missing question(s)..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Configuration files come in many formats.", "There are well known formats such as *.ini or apache config - these tend to have many parsers available."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Then there are custom formats.", "That is what yours appears to be (it could be some well-defined format you and I have never seen before - but until you know what that is it doesn't really matter)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I would start with the software this came from and see if they have a programming API that can load/produce these files.", "If nothing is obvious give Quovadx a call.", "Chances are someone has already solved this problem."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Otherwise you're probably on your own to create your own parser."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Writing a parser for this format would not be terribly difficult assuming that your sample is representative of a complete example.", "It's a hierarchy of values where each node can contain either a value or a child hierarchy of values.", "Once you've defined the basic types that the values can contain the parser is a very simple structure."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["You could write this reasonably quickly using something like Lex/Flex or just a straight-forward parser in the language of your choosing."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["You can easily write a script in python which will convert it to python dict, format looks almost like hierarchical name value pairs, only problem seems to be\nCoards {0 0}, where {0 0} isn't a name value pair, but a list\nso who know what other such cases are in the format\nI think your best bet is to have spec for that format and write a simple python script to read it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Your config file is very similar to JSON (pretty much, replace all your \"{\" and \"}\" with \"[\" and \"]\").", "Most languages have a built in JSON parser (PHP, Ruby, Python, etc), and if not, there are libraries available to handle it for you."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "JSON", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.json.org/"}]}, {"text": ["If you can not change the format of the configuration file, you can read all file contents as a string, and replace all the \"{\" and \"}\" characters via whatever means you prefer.", "Then you can parse the string as JSON, and you're set."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I searched a little on the Cheese Shop, but I didn't find anything helpful for your example.", "Check the Examples page, and this specific parser ( it's syntax resembles yours a bit ).", "I think this should help you write your own."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Cheese Shop", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi"}, {"text": "Examples", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/Examples"}, {"text": "this", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://pyparsing.wikispaces.com/file/view/dhcpd%5Fleases%5Fparser.py"}]}], [{"text": ["Look into LEX and YACC.", "A bit of a learning curve, but they can generate parsers for any language."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "LEX and YACC", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://dinosaur.compilertools.net/"}]}], [{"text": ["Maybe you could write a simple script that will convert your config into xml file and then read it just using lxml, Beatuful Soup or anything else?", "And your converter could use PyParsing or regular expressions for example."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]