[[{"text": ["The only suggestion that I have is to get rid of the slight code duplication:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n path = []\nprevious = destination\nwhile previous != origin:\n    path.append(previous)\n    previous = predecessor_map[previous]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Beyond that, I think your code is actually very clear and is unlikely to benefit from any attempts to shorten it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Lastly, it is worth noting that the above also works when destination == origin, whereas your original version most probably doesn't (depends on how exactly predecessor_map is populated).", "Don't know if this is relevant to your use cases."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "destination == origin", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "predecessor_map", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["This might work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n path = [destination]\npath += iter(lambda: predecessor_map[path[-1]], origin)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It behaves the same as your original code.", "But what you've already written is fine as is."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If destination could be equal to origin:"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "destination", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "origin", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n path = []\npath += iter(lambda: predecessor_map[path[-1]] if path else destination, origin)\n</code>\n</pre>\n", "senID": 4}, {"text": ["It behaves the same as @aix's code."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "@aix's code", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/7741662/build-a-list-using-specific-keys-in-a-dict-python/7741801#7741801"}]}], [{"code": "<pre>\n<code>\n def backwalk(mymap, start, origin):\n    yield start\n    current = mymap[start]\n    while current != origin:\n        yield current\n        current = mymap[current]\n\npath = list(backwalk(predecessor_map, destination, origin))\n</code>\n</pre>\n", "senID": 0}, {"text": ["This separates the walking and collecting tasks."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you can ensure that you never start with the origin, you can simplify to"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def backwalk(mymap, start, origin):\n    current = start\n    while current != origin:\n        yield current\n        current = mymap[current]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You can recursively traverse the edges assuming predecessor_map is a dict mapping node to parent node and that None is the root:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "predecessor_map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n predecessor_map={0: None, 1: None, 2: 1, 3: 1, 4: 0, 5: 1}\n</code>\n</pre>\n", "senID": 1}, {"text": ["Define a recursive function that traverses the tree in reverse:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def path(node, predecessors):\n    return [None] if node is None else [node] + path(predecessors.get(node), predecessors)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or, if you dare, a Y combinator:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n Y=lambda f: (lambda x: f(lambda *args: x(x)(*args)))(lambda x: f(lambda *args: x(x)(*args)))\npath=Y(lambda f: lambda node, p: [None] if node is None else [node] + f(p.get(node), p))\n</code>\n</pre>\n", "senID": 5}, {"text": ["In use (using list comprehension):"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print [node for node in path(None, predecessor_map)]\n[None]\n&gt;&gt;&gt; print [node for node in path(0, predecessor_map)]\n[0, None]\n&gt;&gt;&gt; print [node for node in path(1, predecessor_map)]\n[1, None]\n&gt;&gt;&gt; print [node for node in path(2, predecessor_map)]\n[2, 1, None]\n&gt;&gt;&gt; print [node for node in path(3, predecessor_map)]\n[3, 1, None]\n&gt;&gt;&gt; print [node for node in path(4, predecessor_map)]\n[4, 0, None]\n&gt;&gt;&gt; print [node for node in path(5, predecessor_map)]\n[5, 1, None]\n</code>\n</pre>\n", "senID": 7}], [{"text": ["One more possible solution is to use functional style programming with deferred output:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import tee, chain, imap, takewhile\n\npredecessor_map = {2:1, 3:2}\ndestination = 3\norigin = 1\n\ndef backwalk(predecessor_map, start, origin):\n\n    def deffered_output():\n        for i in output:\n            yield i\n\n    result, a = tee(deffered_output())\n    b = imap(predecessor_map.get,a)\n    output = takewhile(lambda x: x!=origin,chain([start],b))\n\n    return result\n\nprint(list(backwalk(predecessor_map,destination,origin)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["I personally wouldn't use this approach.", "But it's interesting for training though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Explanation\nThe key element is deferred_output which postpones the calls to output.", "Then we split output into 2 iterators using tee.", "Then we apply predecessor_map.get to the second iterator called a and assign the new iterator to b.", "Then we control the output with takewhile and stop when origin is reached."], "childNum": 10, "tag": "p", "senID": 3, "childList": [{"text": "Explanation", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "deferred_output", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "output", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "output", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "tee", "childNum": 0, "tag": "code", "childList": []}, {"text": "predecessor_map.get", "childNum": 0, "tag": "code", "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "childList": []}, {"text": "b", "childNum": 0, "tag": "code", "childList": []}, {"text": "takewhile", "childNum": 0, "tag": "code", "childList": []}, {"text": "origin", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I don't think you can do this iteration with a comprehension.", "Maybe you could simplify it a little, like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n path, previous = [], destination\n    while True:\n        path.append(previous)\n        previous = predecessor_map[previous]\n        if previous == origin:\n            break\n</code>\n</pre>\n", "senID": 1}, {"text": ["The above loop would look nicer with a do..while , but Python lacks it"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]