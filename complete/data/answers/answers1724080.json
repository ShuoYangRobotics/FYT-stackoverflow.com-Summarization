[[{"text": ["You don't need list comprehensions for this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n channel_values = open(channel_output_file).read().split()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Just do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n channel_values = open(channel_output_file).read().split()\n</code>\n</pre>\n", "senID": 1}, {"text": ["split() will split according to whitespace that includes ' ' '\\t' and '\\n'.", "It will split all the values into one list."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "split()", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#str.split"}, {"text": "' ' '\\t' and '\\n'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["If you want integer values you can do:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n channel_values = map(int, open(channel_output_file).read().split())\n</code>\n</pre>\n", "senID": 4}, {"text": ["or with list comprehensions:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n channel_values = [int(x) for x in open(channel_output_file).read().split()]\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Also, the reason the original list comprehension had nested lists is because  you added an extra level of list comprehension with the inner set of square brackets.", "You meant this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n channel_values = [x for x in y.split(' ') for y in\n    open(channel_output_file) if x and not x == '\\n']\n</code>\n</pre>\n", "senID": 1}, {"text": ["The other answers are still better ways to write the code, but that was the cause of the problem."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Well another problem is that you're leaving the file open.", "Note that open is an alias for file."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "open", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "file", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["try this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n f = file(channel_output_file)\nchannel_values = f.read().split()\nf.close()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Note they'll be string values so if you want integer ones change the second line to"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n channel_values = [int(x) for x in f.read().split()]\n</code>\n</pre>\n", "senID": 4}, {"text": ["int(x) will throw a ValueError if you have a non integer value in the file."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "ValueError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Sort of.."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Instead of reading each line as an array, with the .readlines() methods, you can just use .read():"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": ".readlines()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".read()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n channel_values = [x for x in open(channel_output_file).readlines().split(' ')\nif x not in [' ', '\\n']]\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you need to do anything more complicated, particularly if it involves multiple list-comprehensions, you're almost always better of expanding it into a regular for loop."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n out = []\nfor y in open(channel_output_file).readlines():\n    for x in y.split(' '):\n        if x not in [' ', '\\n']:\n            out.append(x)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Or using a for loop and a list-comprehension:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n out = []\nfor y in open(channel_output_file).readlines():\n    out.extend(\n        [x for x in y.split(' ')\n        if x != ' ' and x != '\\n'])\n</code>\n</pre>\n", "senID": 6}, {"text": ["Basically, if you can't do something simply with a list comprehension (or need to nest them), list-comprehensions are probably not the best solution."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["If you don't care about dangling file references, and you really must have a list read into memory all at once, the one-liner mentioned in other answers does work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n channel_values = open(channel_output_path).read().split()\n</code>\n</pre>\n", "senID": 1}, {"text": ["In production code, I would probably use a generator, why read all those lines if you don't need them?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def generate_values_for_filename(filename):\n    with open(filename) as f:\n        for line in f:\n            for value in line.split():\n                yield value\n</code>\n</pre>\n", "senID": 3}, {"text": ["You can always make a list later if you really need to do something other than iterate over values:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n channel_values = list(generate_values_for_filename(channel_output_path))\n</code>\n</pre>\n", "senID": 5}]]