[[{"text": ["Boo is a statically typed language for the Common Language Infrastructure (aka.", "the Microsoft .NET platform).", "The syntax is highly inspired by Python, and hashes/lists/array are part of the syntax:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Boo", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://boo.codehaus.org/"}, {"text": "highly", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n i = 5\nif i &gt; 5:\n    print \"i is greater than 5.\"\nelse:\n    print \"i is less than or equal to 5.\"\n\nhash = {'a': 1, 'b': 2, 'monkey': 3, 42: 'the answer'}\nprint hash['a']\nprint hash[42]\n\nfor item in hash:\n    print item.Key, '=&gt;', item.Value\n</code>\n</pre>\n", "senID": 1}], [{"text": ["It may not match all your needs, but have a look at Boo - The wristfriendly language for the CLI"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Boo - The wristfriendly language for the CLI", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://boo.codehaus.org/"}]}, {"text": ["If you do, I highly recommend DSLs in Boo: Domain-Specific Languages in .NET which apart from the DSL aspects, covers Boo syntax in a very nice appendix and a lot of meta-programming."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "DSLs in Boo: Domain-Specific Languages in .NET", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.manning.com/rahien/"}]}, {"text": ["Furthermore the tutorials are a great resource."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "tutorials", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://boo.codehaus.org/Tutorials"}]}], [{"text": ["Cobra is a statically typed language for the CLR (as Boo).", "From its web page:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Cobra", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cobra-language.com/"}]}, {"code": "<pre>\n<code>\n Sample code:\n\n\"\"\"\nThis is a doc string for the whole module.\n\"\"\"\n\n\nclass Person\n    \"\"\"\n    This is a class declaration.\n    \"\"\"\n\n    var _name as String  # declare an object variable. every instance of Person will have a name\n    var _age as int\n\n    cue init(name as String, age as int)\n        _name = name\n        _age = age\n\n    def sayHello\n        # This is a method\n\n        # In strings, anything in brackets ([]) is evaluated as an expression,\n        # converted to a string and substituted into the string:\n        print 'Hello. My name is [_name] and I am [_age].'\n\n    def add(i as int, j as int) as int\n        \"\"\" Adds the two arguments and returns their sum. \"\"\"\n        return i + j\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Although it is not object-oriented, Haskell offers a significant number of the features that interest you:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Haskell", "tag": "a", "pos": 0, "childList": [{"text": "Haskell", "tag": "strong"}], "childNum": 1, "href": "http://www.haskell.org/"}, {"text": "Haskell", "childNum": 0, "tag": "strong", "childList": []}]}, {"tag": "ul", "num": 5, "lis": [{"text": ["Syntax support for list comprehensions, plus do notation for a wide variety of sequencing/binding constructs.", "(Syntax support for dictionaries is limited to lists of pairs, e.g, "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "do", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Functions support full  closures and multiple return values using tuple types.", "Keyword arguments are not supported but a powerful feature of \"implicit arguments\" can sometimes substitute."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["No runtime modification of classes, types or objects."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Avoidance of specificying classes/types everywhere through type inference."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "type inference", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Metaprogramming using Template Haskell."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]}, {"text": ["Also, just so you will feel at home, Haskell has significant indentation!"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I actually think Haskell has quite a different feel from Python overall, but that is primarily because of the extremely powerful static type system.", "If you are interested in trying a statically typed language, Haskell is one of the most ambitious ones out there right now."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["try the Go programming language ?", "I've seen some similar paradigm."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If auto-completion is the thing you are looking for, then you might wanna stick with Python and use a great IDE instead."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Try PyCharm: http://www.jetbrains.com/pycharm/index.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.jetbrains.com/pycharm/index.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.jetbrains.com/pycharm/index.html"}]}, {"text": ["Unless you are coding some extremely dynamic stuff (which you can't probably do in a static language anyway), it will keep up with the code and give you completion, refactoring and all the other goodies we are used to in statically typed languages."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You can give typehints to the IDE where you really need it by doing:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def foo(bar):\n    if 0: bar = Bar() # \"if 0\" will be removed from the bytecode automatically by python\n    bar. # will now autocomplete\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The D programming language is a statically typed, natively compiled language that has some significant features inspired by Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Arrays and associative arrays are built into the language.", "There are no list comprehensions, but the std.range and std.algorithm libraries fill much of that void.", "For example, here's a way to sum up all the even numbers from 0 to 100 in D:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n auto result = reduce!\"a + b\"(\n    filter!\"a % 2 == 0\"(\n        iota(0, 100)\n    )\n);\n</code>\n</pre>\n", "senID": 2}, {"text": ["There are no keyword arguments so far, but closures are there.", "Tuples are supported, but not unpacked automatically."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["In D, you avoid specifying classes (and types in general) everywhere with the auto keyword and with templates.", "For example, here is generic code to find the product of  array of any numeric type:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "auto", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n // The return type of product() is inferred.\nauto product(T)(T[] array) {\n    T ret = 1;\n    foreach(num; array) { // typeof(num) is inferred.\n        ret *= num;\n    }\n\n    return ret;\n}\n</code>\n</pre>\n", "senID": 5}, {"text": ["D's metaprogramming support consists of compile time introspection (for example, you can iterate over the fields of a class or struct at compile time), runtime type information, and templates that are actually designed for metaprogramming beyond simple generics.", "For example, here's how to write a generic function that generates a default comparison operation for two structs, which is useful if you need an arbitrary total ordering for something like a binary tree:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n /**Returns -1 if lhs &lt; rhs, 0 if lhs == rhs, 1 if lhs &gt; rhs.*/\nint compareStructs(T)(T lhs, T rhs) {\n    foreach(tupleIndex, value; lhs.tupleof) {\n        if(value &lt; rhs.tupeof[tupleIndex]) {\n            return -1;\n        } else if(value &gt; rhs.tupleof[tupleIndex]) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n</code>\n</pre>\n", "senID": 7}], [{"text": ["Autocompletion is still possible in a dynamically typed language; nothing prevents the IDE from doing type inference or inspection, even if the language implementation doesn't."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I think Eric and PyScripter have nice autocompletion on Windows, but maybe not as good as PyTools for Visual Studio (Express)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For static typing in Python, i'd use Cython: http://docs.cython.org/src/quickstart/cythonize.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.cython.org/src/quickstart/cythonize.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.cython.org/src/quickstart/cythonize.html"}]}]]