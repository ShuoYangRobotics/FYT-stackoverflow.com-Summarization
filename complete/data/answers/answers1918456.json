[[{"text": ["From the Wikipedia:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Its the good old space vs runtime tradeoff: You can have constant time with linear space usage for the keys in a hastable.", "Or you can store the key implicitly and use log n time by using a binary tree.", "The (binary) hash of a value gives you the path in the tree where it will be stored."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Build your own b-tree in RAM."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Memory use:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["(4 bytes) comparison hash value"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["(4 bytes) index of next leaf if hash &lt;= comparison OR if negative index of value"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["(4 bytes) index of next leaf if hash > comparison OR if negative index of value"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["12 bytes per b-tree node for the b-tree.", "More overhead for the values (see below)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["How you structure this in Python - aren't there \"native arrays\" of 32bit integers upported with almost no extra memory overhead...?", "what are they called... anyway those."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Separate ordered array of subarrays each containing one or more values.", "The \"indexes of value\" above are indexes into this big array, allowing retrieval of all values matching the hash."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["This assumes a 32bit hash.", "You will need more bytes per b-tree node if you have\ngreater than 2^31-1 entries or a larger hash."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["BUT Spanner in the works perhaps: Note that you will not be able, if you are not storing the key values, to verify that a hash value looked up corresponds only to your key unless through some algorithmic or organisational mechanism you have guaranteed that no two keys will have the same hash.", "Quite a serious issue here.", "Have you considered it?", ":)"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["Although python dictionaries are very efficient, I think that if you're going to store billions of items, you may want to create your own C extension with data structures, optimized for the way you are actually using it (sequential access?", "completely random?", "etc).  "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "billions", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "create", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://starship.python.net/crew/arcege/extwriting/pyext.html"}]}, {"text": ["In order to create a C extension, you may want to use SWIG, or something like Pyrex (which I've never used)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "SWIG", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.swig.org/"}, {"href": "http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/", "text": "Pyrex", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["How about using an ordinary dictionary and instead of doing:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n d[x]=y\n</code>\n</pre>\n", "senID": 1}, {"text": ["use:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n d[hash(x)]=y\n</code>\n</pre>\n", "senID": 3}, {"text": ["To look up:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n d[hash(foo)]\n</code>\n</pre>\n", "senID": 5}, {"text": ["Of course, if there is a hash collision, you may get the wrong value back."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Hash table has to store keys, unless you provide a hash function that gives absolutely no collisions, which is nearly impossible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There is, however, if your keys are string-like, there is a very space-efficient data structure - directed acyclic word graph (DAWG).", "I don't know any Python implementation though."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["It's not what you asked for buy why not consider Tokyo Cabinet or BerkleyDB for this job?", "It won't be in memory but you are trading performance for greater storage capacity.", "You could still keep your list in memory and use the database only to check existence."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you're actually storing millions of unique values, why not use a dictionary?", "Store: d[hash(key)/32] |= 2**(hash(key)%32)\nCheck: (d[hash(key)/32] | 2**(hash(key)%32))"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "d[hash(key)/32] |= 2**(hash(key)%32)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "(d[hash(key)/32] | 2**(hash(key)%32))", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you have billions of entries, use a numpy array of size (2**32)/32, instead.", "(Because, after all, you only have 4 billion possible values to store, anyway)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Would you please tell us more about the keys?", "I'm wondering if there is any regularity in the keys that we could exploit."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If the keys are strings in a small alphabet (example: strings of digits, like phone numbers) you could use a trie data structure:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://en.wikipedia.org/wiki/Trie"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://en.wikipedia.org/wiki/Trie", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Trie"}]}], [{"text": ["Why not a dictionary + hashlib?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; hashtable = {}\n&gt;&gt;&gt; def myHash(obj):\n    return hashlib.sha224(obj).hexdigest()\n\n&gt;&gt;&gt; hashtable[myHash(\"foo\")] = 'bar'\n&gt;&gt;&gt; hashtable\n{'0808f64e60d58979fcb676c96ec938270dea42445aeefcd3a4e6f8db': 'bar'}\n</code>\n</pre>\n", "senID": 1}]]