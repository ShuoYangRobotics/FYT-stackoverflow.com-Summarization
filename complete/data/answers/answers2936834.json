[[{"text": ["You can use itertools.groupby to count the groups of positive and non-positive numbers:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "itertools.groupby", "tag": "a", "pos": 0, "childList": [{"text": "itertools.groupby", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.groupby"}, {"text": "itertools.groupby", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = [-3,2,7,-4,1,-1,1,6,-1,0,-2,1] \n\n&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; len(list(itertools.groupby(x, lambda x: x &gt; 0)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Result:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 8\n</code>\n</pre>\n", "senID": 3}, {"text": ["In your question you state that you want:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "to count the changes, not the groups", "tag": "none", "senID": 5}, {"text": "to count an extra change if the first element is not positive.", "tag": "none", "senID": 6}]}, {"text": ["You can do this either by testing the first element directly and adjusting the result:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; len(list(itertools.groupby(x, lambda x: x &gt; 0))) - (x[0] &gt; 0)\n</code>\n</pre>\n", "senID": 8}, {"text": ["or by prepending a positive number to the input before doing the grouping then subtracting 1 from the result:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; len(list(itertools.groupby(itertools.chain([1], x), lambda x: x &gt; 0))) - 1\n</code>\n</pre>\n", "senID": 10}, {"text": ["Watch out if your input list could by empty - the former solution will raise an exception."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"code": "<pre>\n<code>\n X = [-3,2,7,-4,1,-1,1,6,-1,0,-2,1]\n\nlast_sign = 1\nsign_changes = 0\n\nfor x in X:\n    if x == 0:\n        sign = -1\n    else:\n        sign = x / abs(x)\n\n    if sign == -last_sign:\n        sign_changes = sign_changes + 1\n        last_sign = sign\n\nprint sign_changes\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n numbers = [-3,2,7,-4,1,-1,1,6,-1,0,-2,1]\n# could be replaced by     signs = [x &gt; 0 for x in numbers]\n# but this methods gives us nice minus and plus signs\nsigns = map(lambda x: \"+\" if x &gt; 0 else \"-\", numbers)\n\n# zip(\u2026) creates the pairs, each pair that has different signs\n#\u00a0adds one to \"count\"\ncount = sum(1 for x,y in zip(signs[:-1], signs[1:]) if x != y)\n</code>\n</pre>\n", "senID": 0}, {"text": ["-> 7"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For your additional requirement, that a negative number at the start of the list should be considered another change, just add a positive number to your list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you're dealing with huge lists, consider using generators.", "(izip, tee, \u2026)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Here is a solution using fold, have fun figuring it out:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def lolwut((x,c), y):\n    return (y, c+(x^y))\n\nprint reduce( lolwut ,(x &gt; 0 for x in X), (True,0)) # 8\nprint reduce( lolwut ,(x &gt; 0 for x in X), (False,0)) # 7\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you haven't been convinced to read the itertools documentation yet:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def pairs(iterable):\n    'iter -&gt; (iter0, iter1), (iter1, iter2), (iter3, iter4), ...'\n    from itertools import izip, tee\n    first, second = tee(iterable)\n    second.next()\n    return izip(first, second)\n\ndef sign_changes(l):\n    result = 0\n    if l and l[0]&lt;=0: result += 1\n    result += sum(1 for a,b in pairs(l) if b*a&lt;=0 and (a!=0 or b!=0))\n    return result\n</code>\n</pre>\n", "senID": 1}], [{"text": ["For integers, (a^b) &lt; 0 if signs of a and b are different."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "(a^b) &lt; 0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "em", "childList": []}, {"text": "b", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n def countSignChanges(seq):\n    # make sure 0's are treated as negative\n    seq = [-1 if not x else x for x in seq]\n\n    # zip with leading 1, so that opening negative value is \n    # treated as sign change\n    return sum((a^b)&lt;0 for a,b in zip([1]+seq, seq))\n\n\nX = [-3,2,7,-4,1,-1,1,6,-1,0,-2,1]\nprint countSignChanges(X)\n</code>\n</pre>\n", "senID": 1}, {"text": ["gives the desired answer, 8."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "8", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}]]