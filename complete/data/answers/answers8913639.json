[[{"text": ["I present two approaches."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Approach 1: all-out regex"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Approach 1: all-out regex", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n In [1]: import re\n\nIn [2]: s = 'adsgasdlkgasYasdgjaUUalsdkjgaZsdalkjgalsdkjTlaksdjfgasdkgj'\n\nIn [3]: re.match(r'(?:.*?[A-Z]){3}.*?([A-Z].*)', s).group(1)\nOut[3]: 'ZsdalkjgalsdkjTlaksdjfgasdkgj'\n</code>\n</pre>\n", "senID": 2}, {"text": ["The .*?", "[A-Z] consumes characters up to, and including, the first uppercase letter."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": ".*?[A-Z]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The (?:...", "){3} repeats the above three times without creating any capture groups. "], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "(?:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "){3}", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The following .*?", "matches the remaining characters before the fourth uppercase letter."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": ".*?", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Finally, the ([A-Z].", "*) captures the fourth uppercase letter and everything that follows into a capture group."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "([A-Z].*)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Approach 2: simpler regex"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "Approach 2: simpler regex", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n In [1]: import re\n\nIn [2]: s = 'adsgasdlkgasYasdgjaUUalsdkjgaZsdalkjgalsdkjTlaksdjfgasdkgj'\n\nIn [3]: ''.join(re.findall(r'[A-Z][^A-Z]*', s)[3:])\nOut[3]: 'ZsdalkjgalsdkjTlaksdjfgasdkgj'\n</code>\n</pre>\n", "senID": 8}, {"text": ["This attacks the problem directly, and I think is easier to read."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["Anyway not using regular expressions will seen to be too verbose -\nalthough at the bytcodelevel it is a very simple algorithm running, and therefore lightweight."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["It may be that regexpsare faster, since they are implemented in native code, but the \"one obvious way to do it\", though boring, certainly beats any suitable regexp in readability hands down:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def find_capital(string, n=4):\n    count = 0\n    for index, letter in enumerate(string):\n        # The boolean value counts as 0 for False or 1 for True\n        count += letter.isupper()  \n        if count == n:\n            return string[index:]\n    return \"\"\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Found this simpler to deal with by using a regular expression to split the string, then slicing the resulting list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ntext = [\"adsgasdlkgasYasdgjaUUalsdkjgaZsdalkjgalsdkjTlaksdjfgasdkgj\",\n        \"oiwuewHsajlkjfasNasldjgalskjgasdIasdllksjdgaPlsdakjfsldgjQ\"]\n\nfor t in text:\n     print \"\".join(re.split(\"([A-Z])\", t, maxsplit=4)[7:])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Conveniently, this gives you an empty string if there aren't enough capital letters."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A nice, one-line solution could be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s1 = 'adsgasdlkgasYasdgjaUUalsdkjgaZsdalkjgalsdkjTlaksdjfgasdkgj'\n&gt;&gt;&gt; s2 = 'oiwuewHsajlkjfasNasldjgalskjgasdIasdllksjdgaPlsdakjfsldgjQ'\n&gt;&gt;&gt; s1[list(re.finditer('[A-Z]', s1))[3].start():]\n'ZsdalkjgalsdkjTlaksdjfgasdkgj'\n&gt;&gt;&gt; s2[list(re.finditer('[A-Z]', s2))[3].start():]\n'PlsdakjfsldgjQ'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Why this works (in just one line)?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Searches for all capital letters in the string: ", "tag": "none", "senID": 3}, {"text": "Gets the 4th capital letter found: ", "tag": "none", "senID": 4}, {"text": "Returns the position from the 4th capital letter: ", "tag": "none", "senID": 5}, {"text": "Using slicing notation, we get the part we need from the string ", "tag": "none", "senID": 6}]}], [{"text": ["I believe that this will work for you, and be fairly easy to extend in the future:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n check = 'adsgasdlkgasYasdgjaUUalsdkjgaZsdalkjgalsdkjTlaksdjfgasdkgj'\nprint re.match('([^A-Z]*[A-Z]){3}[^A-Z]*([A-Z].*)', check ).group(2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["The first part of the regex ([^A-Z]*[A-Z]){3} is the real key, this finds the first three upper case letters and stores them along with the characters between them in group 1, then we skip any number of non-upper case letters after the third upper case letter, and finally, we capture the rest of the string."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "([^A-Z]*[A-Z]){3}", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Testing a variety of methods.", "I original wrote string_after_Nth_upper and didn't post it; seeing that jsbueno's method was similar; except by doing additions/count comparisons for every character (even lowercase letters) his method is slightly slower."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "string_after_Nth_upper", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n s='adsasdlkgasYasdgjaUUalsdkjgaZsdalkjgalsdkjTlaksdjfgasdkgj'\nimport re\ndef string_after_Nth_upper(your_str, N=4):\n    upper_count = 0\n    for i, c in enumerate(your_str):\n        if c.isupper():\n            upper_count += 1\n            if upper_count == N:\n               return your_str[i:]\n    return \"\"\n\ndef find_capital(string, n=4):\n    count = 0\n    for index, letter in enumerate(string):\n        # The boolean value counts as 0 for False or 1 for True\n        count += letter.isupper()  \n        if count == n:\n            return string[index:]\n    return \"\"\n\ndef regex1(s):\n    return re.match(r'(?:.*?[A-Z]){3}.*?([A-Z].*)', s).group(1)\ndef regex2(s):\n    return re.match(r'([^A-Z]*[A-Z]){3}[^A-Z]*([A-Z].*)', s).group(2)\ndef regex3(s):\n    return s[list(re.finditer('[A-Z]', s))[3].start():]\nif __name__ == '__main__':\n    from timeit import Timer\n    t_simple = Timer(\"string_after_Nth_upper(s)\", \"from __main__ import s, string_after_Nth_upper\")\n    print 'simple:', t_simple.timeit()\n    t_jsbueno = Timer(\"find_capital(s)\", \"from __main__ import s, find_capital\")\n    print 'jsbueno:', t_jsbueno.timeit()\n    t_regex1 = Timer(\"regex1(s)\", \"from __main__ import s, regex1; import re\")\n    print  \"Regex1:\",t_regex1.timeit()\n    t_regex2 = Timer(\"regex2(s)\", \"from __main__ import s, regex2; import re\")\n    print \"Regex2:\", t_regex2.timeit()\n\n    t_regex3 = Timer(\"regex3(s)\", \"from __main__ import s, regex3; import re\")\n    print \"Regex3:\", t_regex3.timeit()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Results:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Simple: 4.80558681488\njsbueno: 5.92122507095\nRegex1: 3.21153497696\nRegex2: 2.80767202377\nRegex3: 6.64155721664\n</code>\n</pre>\n", "senID": 3}, {"text": ["So regex2 wins for time."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["It's not the prettiest approach, but:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n re.match(r'([^A-Z]*[A-Z]){3}[^A-Z]*([A-Z].*)', line).group(2)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n import re\nstrings = [\n    'adsgasdlkgasYasdgjaUUalsdkjgaZsdalkjgalsdkjTlaksdjfgasdkgj',\n    'oiwuewHsajlkjfasNasldjgalskjgasdIasdllksjdgaPlsdakjfsldgjQ',\n]\n\nfor s in strings:\n    m = re.match('[a-z]*[A-Z][a-z]*[A-Z][a-z]*[A-Z][a-z]*([A-Z].+)', s)\n    if m:\n        print m.group(1)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Parsing almost always involves regular expressions.", "However, a regex by itself does not make a parser.", "In the most simple sense, a parser consists of:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "by itself", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n text input stream -&gt; tokenizer\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usually it has an additional step:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n text input stream -&gt; tokenizer -&gt; parser\n</code>\n</pre>\n", "senID": 3}, {"text": ["The tokenizer handles opening the input stream and collecting text in a proper manner, so that the programmer doesn't have to think about it.", "It consumes text elements until there is only one match available to it.", "Then it runs the code associated with this \"token\".", "If you don't have a tokenizer, you have to roll it yourself(in pseudocode):"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n while stuffInStream:\n    currChars + getNextCharFromString\n    if regex('firstCase'):\n         do stuff\n    elif regex('other stuff'):\n         do more stuff\n</code>\n</pre>\n", "senID": 5}, {"text": ["This loop code is full of gotchas, unless you build them all the time.", "It is also easy to have a computer produce it from a set of rules.", "That's how Lex/flex works.", "You can have the rules associated with a token pass the token to yacc/bison as your parser, which adds structure."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "Lex/flex", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://flex.sourceforge.net/"}, {"text": "yacc/bison", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://www.gnu.org/s/bison/"}]}, {"text": ["Notice that the lexer is just a state machine.", "It can do anything when it migrates from state to state.", "I've written lexers that used would strip characters from the input stream, open files, print text, send email and so on."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "state machine", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Finite-state_machine"}, {"text": "anything", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["So, if all you want is to collect the text after the fourth capital letter, a regex is not only appropriate, it is the correct solution.", "BUT if you want to do parsing of textual input, with different rules for what to do and an unknown amount of input, then you need a lexer/parser.", "I suggest PLY since you are using python."], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "BUT", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "parsing of textual input", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "PLY", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/ply/"}]}], [{"text": ["Alternative with re.search and a simple regex:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; txt = 'adsgasdlkgasYasdgjaUUalsdkjgaZsdalkjgalsdkjTlaksdjfgasdkgj'\n&gt;&gt;&gt;\n&gt;&gt;&gt; pat = \"([A-Z][a-z]*){3}([A-Z].*)\"\n&gt;&gt;&gt;\n&gt;&gt;&gt; s = re.search(pat, txt)\n&gt;&gt;&gt; s.groups()[1]\n'ZsdalkjgalsdkjTlaksdjfgasdkgj'\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n caps = set(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\ntemp = ''\nfor char in inputStr:\nif char in caps:\n    temp += char\n    if len(temp) == 4:\n        print temp[-1] # this is the answer that you are looking for\n        break\n</code>\n</pre>\n", "senID": 0}, {"text": ["Alternatively, you could use re.sub to get rid of anything that's not a capital letter and get the 4th character of what's left"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "re.sub", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Another version... not that pretty, but gets the job done."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def stringafter4thupper(s):    \n    i,r = 0,''\n    for c in s:\n        if c.isupper() and i &lt; 4:\n            i+=1\n        if i==4:\n            r+=c\n    return r\n</code>\n</pre>\n", "senID": 1}, {"text": ["Examples:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n stringafter4thupper('adsgasdlkgasYasdgjaUUalsdkjgaZsdalkjgalsdkjTlaksdjfgasdkgj')\nstringafter4thupper('oiwuewHsajlkjfasNasldjgalskjgasdIasdllksjdgaPlsdakjfsldgjQ')\nstringafter4thupper('')\nstringafter4thupper('abcdef')\nstringafter4thupper('ABCDEFGH')\n</code>\n</pre>\n", "senID": 3}, {"text": ["Respectively results:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n 'ZsdalkjgalsdkjTlaksdjfgasdkgj'\n'PlsdakjfsldgjQ'\n''\n''\n'DEFGH'\n</code>\n</pre>\n", "senID": 5}]]