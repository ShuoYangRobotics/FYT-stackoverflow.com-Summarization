[[{"text": ["To match all allowed fields, the following rather fearful looking regex works:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n@((?:cat|mouse|dog|puppy)\\b|\\((?:(?:cat|mouse|dog|puppy)(?:, *|(?=\\))))+\\))\n</pre>\n", "senID": 1}, {"text": ["It returns these matches, in order: @cat, @(cat), @(cat, dog), @cat, @dog, @(cat, dog), @mouse."], "childNum": 7, "tag": "p", "senID": 2, "childList": [{"text": "@cat", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "@(cat)", "childNum": 0, "tag": "code", "childList": []}, {"text": "@(cat, dog)", "childNum": 0, "tag": "code", "childList": []}, {"text": "@cat", "childNum": 0, "tag": "code", "childList": []}, {"text": "@dog", "childNum": 0, "tag": "code", "childList": []}, {"text": "@(cat, dog)", "childNum": 0, "tag": "code", "childList": []}, {"text": "@mouse", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The regex breaks down as follows:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n@                               # the literal character \"@\"\n(                               # match group 1\n  (?:cat|mouse|dog|puppy)       #  one of your valid search terms (not captured)\n  \\b                            #  a word boundary\n  |                             #  or...\n  \\(                            #  a literal opening paren\n  (?:                           #  non-capturing group\n    (?:cat|mouse|dog|puppy)     #   one of your valid search terms (not captured)\n    (?:                         #   non-capturing group\n      , *                       #    a comma \",\" plus any number of spaces\n      |                         #    or...\n      (?=\\))                    #    a position followed by a closing paren\n    )                           #   end non-capture group\n  )+                            #  end non-capture group, repeat\n  \\)                            #  a literal closing paren\n)                               # end match group one.\n</pre>\n", "senID": 4}, {"text": ["Now to identify any invalid search, you would wrap all that in a negative look-ahead:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "invalid", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n@(?!(?:cat|mouse|dog|puppy)\\b|\\((?:(?:cat|mouse|dog|puppy)(?:, *|(?=\\))))+\\))\n--^^\n</pre>\n", "senID": 6}, {"text": ["This would identify any @ character after which an invalid search term (or term combination) was attempted.", "Modifying it so that it also matches the invalid attempt instead of just pointing at it is not that hard anymore."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "@", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "matches", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["You would have to prepare (?", ":cat|mouse|dog|puppy) from your field dynamically and plug it into the static rest of the regex.", "Should not be too hard to do either."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "(?:cat|mouse|dog|puppy)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["This should work:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n @\\((cat|dog|mouse|puppy)\\b(,\\s*(cat|dog|mouse|puppy)\\b)*\\)|@(cat|dog|mouse|puppy)\\b\n</code>\n</pre>\n", "senID": 1}, {"text": ["It will either match a single @parameter or a parenthesized @(par1, par2) list containing only allowed words (one or more)."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "@parameter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "@(par1, par2)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It also makes sure that no partial matches are accepted (@caterpillar)."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "@caterpillar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This pyparsing solution follows a similar logic path as your posted answer.", "All tags are matched, and then checked against the list of known valid tags, removing them from the reported results.", "Only those matches that have values left over after removing the valid ones are reported as matches."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from pyparsing import *\n\n# define the pattern of a tag, setting internal results names for easy validation\nAT,LPAR,RPAR = map(Suppress,\"@()\")\nterm = Word(alphas,alphanums).setResultsName(\"terms\",listAllMatches=True)\nsphxTerm = AT + ~White() + ( term | LPAR + delimitedList(term) + RPAR )\n\n# define tags we consider to be valid\nvalid = set(\"cat mouse dog\".split())\n\n# define a parse action to filter out valid terms, and attach to the sphxTerm\ndef filterValid(tokens):\n    tokens = [t for t in tokens.terms if t not in valid]\n    if not(tokens):\n        raise ParseException(\"\",0,\"\")\n    return tokens\nsphxTerm.setParseAction(filterValid)\n\n\n##### Test out the parser #####\n\ntest = \"\"\"@cat search terms @ house\n    @(cat) search terms \n    @(cat, dog) search term @(goat)\n    @cat searchterm1 @dog searchterm2 @(cat, doggerel)\n    @(cat, dog) searchterm1 @mouse searchterm2 \n    @caterpillar\"\"\"\n\n# scan for invalid terms, and print out the terms and their locations\nfor t,s,e in sphxTerm.scanString(test):\n    print \"Terms:%s Line: %d Col: %d\" % (t, lineno(s, test), col(s, test))\n    print line(s, test)\n    print \" \"*(col(s,test)-1)+\"^\"\n    print\n</code>\n</pre>\n", "senID": 1}, {"text": ["With these lovely results:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Terms:['goat'] Line: 3 Col: 29\n    @(cat, dog) search term @(goat)\n                            ^\n\nTerms:['doggerel'] Line: 4 Col: 39\n    @cat searchterm1 @dog searchterm2 @(cat, doggerel)\n                                      ^\n\nTerms:['caterpillar'] Line: 6 Col: 5\n    @caterpillar\n    ^\n</code>\n</pre>\n", "senID": 3}, {"text": ["This last snippet will do all the scanning for you, and just give you the list of found invalid tags:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n # print out all of the found invalid terms\nprint list(set(sum(sphxTerm.searchString(test), ParseResults([]))))\n</code>\n</pre>\n", "senID": 5}, {"text": ["Prints:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n ['caterpillar', 'goat', 'doggerel']\n</code>\n</pre>\n", "senID": 7}], [{"text": ["This will match all fields that are cat, dog, mouse, or puppy and combinations thereof."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nsphinx_term = \"@goat some words to search\"\nregex = re.compile(\"@\\(?(cat|dog|mouse|puppy)(, ?(cat|dog|mouse|puppy))*\\)? \")\nif regex.search(sphinx_term):\n    send the query to sphinx...\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n field_re = re.compile(r\"@(?:([^()\\s]+)|\\([^()]+\\))\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["A single field name (like cat in @cat) will be captured in group #1, while the names in a parenthesized list like @(cat, dog) will be stored in group #2.", "In the latter case you'll need to break the list down with split() or something; there's no way to capture the names individually with a Python regex."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "cat", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "@cat", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "@(cat, dog)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "split()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I ended up doing this a different way, since none of the above worked.", "First I found the fields like @cat, with this: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n attributes = re.findall('(?:@)([^\\( ]*)', query)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Next, I found the more complicated ones, with this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n regex0 = re.compile('''\n    @               # at sign\n    (?:             # start non-capturing group\n        \\w+             # non-whitespace, one or more\n        \\b              # a boundary character (i.e. no more \\w)\n        |               # OR\n        (               # capturing group\n            \\(              # left paren\n            [^@(),]+        # not an @(),\n            (?:                 # another non-caputing group\n                , *             # a comma, then some spaces\n                [^@(),]+        # not @(),\n            )*              # some quantity of this non-capturing group\n            \\)              # a right paren\n        )               # end of non-capuring group\n    )           # end of non-capturing group\n    ''', re.VERBOSE)\n\n# and this puts them into the attributes list.\ngroupedAttributes = re.findall(regex0, query)\nfor item in groupedAttributes:\n    attributes.extend(item.strip(\"(\").strip(\")\").split(\", \"))\n</code>\n</pre>\n", "senID": 3}, {"text": ["Next, I checked if the attributes I found were valid, and added them (uniquely to an array):"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n # check if the values are valid.\nvalidRegex = re.compile(r'^mice$|^mouse$|^cat$|^dog$')\n\n# if they aren't add them to a new list.\nbadAttrs = []\nfor attribute in attributes:\n    if len(attribute) == 0:\n        # if it's a zero length attribute, we punt\n        continue\n    if validRegex.search(attribute.lower()) == None:\n        # if the attribute from the search isn't in the valid list\n        if attribute not in badAttrs:\n            # and the attribute isn't already in the list\n            badAttrs.append(attribute)\n</code>\n</pre>\n", "senID": 5}, {"text": ["Thanks all for the help though.", "I'm very glad to have had it!"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]