[[{"text": ["This is what I whipped up.", "It doesn't use a class, but it does use function attributes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def max_execs(n=5):\n    def decorator(fn):\n        fn.max = n\n        fn.called = 0\n        def wrapped(*args, **kwargs):\n            fn.called += 1\n            if fn.called &lt;= fn.max:\n                return fn(*args, **kwargs)\n            else:\n                # Replace with your own exception, or something\n                # else that you want to happen when the limit\n                # is reached\n                raise RuntimeError(\"max executions exceeded\")\n        return wrapped\n    return decorator\n</code>\n</pre>\n", "senID": 1}, {"text": ["max_execs returns a functioned called decorator, which in turn returns wrapped.", "decoration stores the max execs and current number of execs in two function attributes, which then get checked in wrapped."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "max_execs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "decorator", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "wrapped", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "decoration", "childNum": 0, "tag": "code", "childList": []}, {"text": "wrapped", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Translation: When using the decorator like this:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Translation:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n @max_execs(5)\ndef f():\n    print \"hi!\"\n</code>\n</pre>\n", "senID": 4}, {"text": ["You're basically doing something like this:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n f = max_execs(5)(f)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Decorator is merely a callable that transforms a function into something else.", "In your case, max_execs(5) must be a callable that transforms a function into another callable object that will count and forward the calls."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "max_execs(5)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n class helper:\n    def __init__(self, i, fn):\n        self.i = i\n        self.fn = fn\n    def __call__(self, *args, **kwargs):\n        if self.i &gt; 0:\n            self.i = self.i - 1\n            return self.fn(*args, **kwargs)\n\nclass max_execs:\n    def __init__(self, i):\n        self.i = i\n    def __call__(self, fn):\n        return helper(self.i, fn)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I don't see why you would want to limit yourself to a function (and not a class).", "But if you really want to..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def max_execs(n):\n    return lambda fn, i=n: return helper(i, fn)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["There are two ways of doing it.", "The object-oriented way is to make a class:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class max_execs:\n    def __init__(self, max_executions):\n        self.max_executions = max_executions\n        self.executions = 0\n\n    def __call__(self, func):\n        @wraps(func)\n        def maybe(*args, **kwargs):\n            if self.executions &lt; self.max_executions:\n                self.executions += 1\n                return func(*args, **kwargs)\n            else:\n                print \"fail\"\n        return maybe\n</code>\n</pre>\n", "senID": 1}, {"text": ["See this question for an explanation of wraps."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "this question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/308999/what-does-functools-wraps-do"}, {"text": "wraps", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I prefer the above OOP approach for this kind of decorator, since you've basically got a private count variable tracking the number of executions.", "However, the other approach is to use a closure, such as"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def max_execs(max_executions):\n    executions = [0]\n    def actual_decorator(func):\n        @wraps(func)\n        def maybe(*args, **kwargs):\n            if executions[0] &lt; max_executions:\n                executions[0] += 1\n                return func(*args, **kwargs)\n            else:\n                print \"fail\"\n        return maybe\n    return actual_decorator\n</code>\n</pre>\n", "senID": 4}, {"text": ["This involved three functions.", "The max_execs function is given a parameter for the number of executions and returns a decorator that will restrict you to that many calls.", "That function, the actual_decorator, does the same thing as our __call__ method in the OOP example.", "The only weirdness is that since we don't have a class with private variables, we need to mutate the executions variable which is in the outer scope of our closure.", "Python 3.0 supports this with the nonlocal statement, but in Python 2.6 or earlier, we need to wrap our executions count in a list so that it can be mutated."], "childNum": 5, "tag": "p", "senID": 5, "childList": [{"text": "max_execs", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "actual_decorator", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__call__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "executions", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "nonlocal", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}], [{"text": ["Without relying to a state in a class, you have to save the state (count) in the function itself:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def max_execs(count):\n    def new_meth(meth):\n        meth.count = count\n        def new(*a,**k):\n            meth.count -= 1\n            print meth.count            \n            if meth.count&gt;=0:\n                return meth(*a,**k)\n        return new\n    return new_meth\n\n@max_execs(5)\ndef f():\n    print \"invoked\"\n\n[f() for _ in range(10)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["It gives:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 5\ninvoked\n4\ninvoked\n3\ninvoked\n2\ninvoked\n1\ninvoked\n0\n-1\n-2\n-3\n-4\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This method does not modify function internals, instead wraps it into a callable object."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Using class slows down execution by ~20% vs using the patched function!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def max_execs(n=1):\n    class limit_wrapper:\n        def __init__(self, fn, max):\n            self.calls_left = max\n            self.fn = fn\n        def __call__(self,*a,**kw):\n            if self.calls_left &gt; 0:\n                self.calls_left -= 1\n                return self.fn(*a,**kw)\n            raise Exception(\"max num of calls is %d\" % self.i)\n\n\n    def decorator(fn):\n        return limit_wrapper(fn,n)\n\n    return decorator\n\n@max_execs(2)\ndef fun():\n    print \"called\"\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I know you said you didn't want a class, but unfortunately that's the only way I can think of how to do it off the top of my head."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class mymethodwrapper:\n    def __init__(self):\n        self.maxcalls = 0\n    def mymethod(self):\n        self.maxcalls += 1\n        if self.maxcalls &gt; 5:\n            return\n        #rest of your code\n        print \"Code fired!\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["Fire it up like this"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a = mymethodwrapper\nfor x in range(1000):\n    a.mymethod()\n</code>\n</pre>\n", "senID": 3}, {"text": ["The output would be:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; Code fired!\n&gt;&gt;&gt; Code fired!\n&gt;&gt;&gt; Code fired!\n&gt;&gt;&gt; Code fired!\n&gt;&gt;&gt; Code fired!\n</code>\n</pre>\n", "senID": 5}]]