[[{"text": ["I would suggest you a book called Programming Collective Intelligence.", "It's a very nice book on how you can retrieve information from simple data like this one.", "There are code examples included (in Python :)"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Programming Collective Intelligence", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://oreilly.com/catalog/9780596529321"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}, {"text": ["Edit:\nJust replying to gbjbaanb: This is Python!"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a = ['books','video','photography','food','toothpaste','burgers']\nb = ['video','processor','photography','LCD','power supply', 'books']\na = set(a)\nb = set(b)\n\na.intersection(b)\n    set(['photography', 'books', 'video'])\n\nb.intersection(a)\n    set(['photography', 'books', 'video'])\n\nb.difference(a)\n    set(['LCD', 'power supply', 'processor'])\n\na.difference(b)\n    set(['food', 'toothpaste', 'burgers'])\n</code>\n</pre>\n", "senID": 2}, {"senID": 3}], [{"text": ["Is position is very important, as you emphasize, then the crucial metric will be based on the difference of positions between the same items in the different vectors (you can, for example, sum the absolute values of the differences, or their squares).", "The big issue that needs to be solved is -- how much to weigh an item that's present (say it's the N-th one) in one vector, and completely absent in the other.", "Is that a relatively minor issue -- as if the missing item was actually present right after the actual ones, for example -- or a really, really big deal?", "That's impossible to say without more understanding of the actual application area.", "You can try various ways to deal with this issue and see what results they give on example cases you care about!"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, suppose \"a missing item is roughly the same as if it were present, right after the actual ones\".", "Then, you can preprocess each input vector into a dict mapping item to position (crucial optimization if you have to compare many pairs of input vectors!", "):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def makedict(avector):\n  return dict((item, i) for i, item in enumerate(avector))\n</code>\n</pre>\n", "senID": 2}, {"text": ["and then, to compare two such dicts:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def comparedicts(d1, d2):\n  allitems = set(d1) | set(d2)      \n  distances = [d1.get(x, len(d1)) - d2.get(x, len(d2)) for x in allitems]\n  return sum(d * d for d in distances)\n</code>\n</pre>\n", "senID": 4}, {"text": ["(or, abs(d) instead of the squaring in the last statement).", "To make missing items weigh more (make dicts, i.e.", "vectors, be considered further away), you could use twice the lengths instead of just the lengths, or some large constant such as 100, in an otherwise similarly structured program."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Take a look at Hamming Distance"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Hamming Distance", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Hamming%5Fdistance"}]}], [{"text": ["As mbg mentioned, the hamming distance is a good start.", "It's basically assigning a bitmask for every possible item whether it is contained in the companies value. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Eg.", "toothpaste is 1 for company A, but 0 for company B.", "You then count the bits which differ between the companies.", "The Jaccard coefficient is related to this."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Hamming distance will actually not be able to capture similarity between things like \"video\" and \"photography\".", "Obviously, a company that sells one does sell the other also with higher probability than a company that sells toothpaste."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For this, you can use stuff like LSI (it's also used for dimensionality reduction) or factorial codes (e.g.", "neural network stuff as Restricted Boltzman Machines, Autoencoders or Predictablity Minimization) to get more compact representations which you can then compare using the euclidean distance."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["pick the rank of each entry  (higher rank is better) and make sum of geometric means between matches"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["for two vectors"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n sum(sqrt(vector_multiply(x,y)))  //multiply matches\n</code>\n</pre>\n", "senID": 2}, {"text": ["Sum of ranks for each value over vector should be same for each vector (preferrebly 1)\nThat way you can make compares between more than 2 vectors."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["If you apply ikkebr's metod you can find how a is simmilar to b"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["in that case just use"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n sum( b( b.intersection(a) ))\n</code>\n</pre>\n", "senID": 6}], [{"text": ["You could use the set_intersection algorithm.", "The 2 vectors must be sorted first (use sort call), then pass in 4 iterators and you'll get a collection back with the common elements inserted into it.", "There are a few others that operate similarly. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "set_intersection", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sgi.com/tech/stl/set%5Fintersection.html"}]}]]