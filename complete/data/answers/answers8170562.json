[[{"text": ["You should map before you reduce."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n points = [(1, 2), (3, 4), (1, 8)]\ndistances = (math.hypot(b[0]-a[0], b[1]-a[1])\n             for a, b in zip(points, points[1:]))\ntotal_distance = sum(distances)\n</code>\n</pre>\n", "senID": 1}, {"text": ["or, if you must use reduce(), although sum() is better for this purpose:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "must", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "reduce()", "childNum": 0, "tag": "code", "childList": []}, {"text": "sum()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import operator\n\ntotal_distance = reduce(operator.add, distances)\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you have a lot of points, you might find NumPy helpful in doing this all at once, quickly:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import numpy\n\ntotal_distance = numpy.hypot(*numpy.diff(numpy.array(points), axis=0)).sum()\n</code>\n</pre>\n", "senID": 5}, {"text": ["Edit: use math.hypot() and add NumPy method."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "math.hypot()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["It isn't pretty but it can be done :-)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; tot = ((1,2),(3,4),(1,8))\n&gt;&gt;&gt; reduce(lambda d,((x0,y0),(x1,y1)): d + ((x1-x0)**2+(y1-y0)**2)**0.5, zip(tot[1:], tot[0:]), 0.0)\n7.3005630797457695\n</code>\n</pre>\n", "senID": 1}], [{"text": ["reduce() is simply the wrong tool for this purpose.", "It is possible to do it with reduce(), but it is a bit weird:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "reduce()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "is", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "reduce()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def distance((x, d), y):\n    return y, d + math.hypot(y[0] - x[0], y[1] - x[1])\n\nprint reduce(distance, [(3,4),(1,8)], ((1, 2), 0.0))[1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["prints"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 7.30056307975\n</code>\n</pre>\n", "senID": 3}, {"text": ["The last parameter passed to the reduce() call is the starting point and the initial value for the distance."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "reduce()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["reduce does not work that way, you start with an initial value a, which you specify or is taken as first element from your iterable.", "afterwards, you pass a,next_element to the function (lambda) provided and store the result in a, repeat until all elements are iterated."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can do what you want with sum and map by first calculating all distances from one point to the next and then summing them:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n path = [(1,2),(3,4),(1,8)]\nsum(map(lambda x,y: math.sqrt((x[0]-y[0])**2+(x[1]-y[1])**2), path[:-1],path[1:]))\n</code>\n</pre>\n", "senID": 2}, {"text": ["edit: or with the hypot function (thx @ralu):"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "hypot", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n sum(map(lambda x,y: math.hypot(x[0]-y[0],x[1]-y[1]), path[:-1],path[1:]))\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Here is a redux meta-iterator that can be combined with the built-in reduce to get the result you want.", "This implementation avoids all buffering of the input sequence."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "redux", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "reduce", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n def redux(f):\n  def execute(iterable):\n    iterable = iter(iterable)\n    try:\n      state = iterable.next()\n    except StopIteration:\n      raise ValueError, 'empty sequences not supported'\n    while True:\n      newstate = iterable.next()\n      yield f(state, newstate)\n      state = newstate\n  return execute\n\nf = redux(lambda x, y: math.sqrt((y[0] - x[0])**2 + (y[1] - x[1])**2))\nprint reduce(operator.add, f(((1,2),(3,4),(1,8))))\n</code>\n</pre>\n", "senID": 1}, {"text": ["The above prints 7.30056307975."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "7.30056307975", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The redux function can be generalized to support more than two arguments at a time in a sliding window, by using inspect.getargspec to count the number of arguments required by its function argument."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "redux", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "inspect.getargspec", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["This is just not the sort of code you want to write.", "Reduce won't be a good solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I suggest a iterative one.", "It will be the most readable, pythonic and maintainable solution."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import math\npath = [(1,2),(3,4),(1,8)]\n\ndef calc_dist(waypoints):\n    dist = 0.0\n    for i in range(len(waypoints) - 1):\n        a = waypoints[i]\n        b = waypoints[i+1]\n        dist += math.hypot(a[0]-b[0], b[1]-a[1])\n    return dist\n\nprint calc_dist( path )\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I'm aware that what I'm about to suggest is not ideal, but I think this is as close as I can get for my contribution.", "This is a fun problem to solve, even if it isn't the most traditional application of reduce."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The key issue seems to be keeping track of the distance from point to point without overwriting the points themselves- adding another 'dimension' to each point gives you a field with which you can track the running distance."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n iterable = ((1,2,0), (3,4,0), (1,8,0))\n# originally ((1,2), (3,4), (1,8))\n\nfrom math import sqrt\n\ndef func(tup1, tup2):\n    '''function to pass to reduce'''\n\n    # extract coordinates\n    x0 = tup1[0]\n    x1 = tup2[0]\n    y0 = tup1[1]\n    y1 = tup2[1]\n\n    dist = tup1[2] # retrieve running total for distance\n\n    dx = x1 - x0   # find change in x\n    dy = y1 - y0   # find change in y\n\n    # add new distance to running total\n    dist += sqrt(dx**2 + dy**2) \n\n    # return 2nd point with the updated distance\n    return tup2[:-1] + (dist,)  # e.g. (3, 4, 2.828)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Now reduce:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n reduce(func, iterable)[-1]\n# returns 7.3005630797457695\n</code>\n</pre>\n", "senID": 4}, {"text": ["This way, the intermediate tuple of tuples (i.e., after one 'reduction') becomes:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n ((3, 4, 2.8284271247461903), (1,8,0))\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Just for fun, here is an alternate solution with a slightly different approach than the reduce(sum, map(hypot, zip(...))) approach."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "reduce(sum, map(hypot, zip(...)))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n tot = ((1,2),(3,4),(1,8))\nreduce(lambda (d,(x,y)),b: (d+math.hypot(x-b[0],y-b[1]), b), tot, (0, tot[0]))[0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that the reduce actually returns the tuple (distance, last point), hence the [0] at the end.", "I think this would be more efficient than zip solutions but haven't actually checked."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "reduce", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[0]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "think", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "zip", "childNum": 0, "tag": "code", "childList": []}]}]]