[[{"text": ["This does have a few disadvantages."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["On the off chance you want to test your module through runtime modification, it may make it more difficult.", "Instead of doing"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import mymodule\nmymodule.othermodule = module_stub\n</code>\n</pre>\n", "senID": 2}, {"text": ["You'll have to do"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import othermodule\nothermodule.foo = foo_stub\n</code>\n</pre>\n", "senID": 4}, {"text": ["This means that you'll have to patch the othermodule globally, as opposed to just change what the reference in mymodule points to."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["This makes it non-obvious what modules your module depends on.", "This is especially irritating if you use many third party libraries or are re-organizing code."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["I had to maintain some legacy code that used imports inline all over the place, it made the code extremely difficult to refactor or repackage."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Because of the way python caches modules, there isn't a performance hit.", "In fact, since the module is in the local namespace, there is a slight performance benefit to importing modules in a function."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Top Import"], "childNum": 0, "tag": "h2", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n import random\n\ndef f():\n    L = []\n    for i in xrange(1000):\n        L.append(random.random())\n\nfor i in xrange(10000):\n    f()\n\n\n$ time python test.py \n\nreal   0m1.569s\nuser   0m1.560s\nsys    0m0.010s\n</code>\n</pre>\n", "senID": 10}, {"text": ["Import in Function Body"], "childNum": 0, "tag": "h2", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n def f():\n    import random\n    L = []\n    for i in xrange(1000):\n        L.append(random.random())\n\nfor i in xrange(10000):\n    f()\n\n$ time python test2.py\n\nreal    0m1.385s\nuser    0m1.380s\nsys     0m0.000s\n</code>\n</pre>\n", "senID": 12}], [{"text": ["A few problems with this approach:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "It's not immediately obvious when opening the file which modules it depends on.", "tag": "none", "senID": 1}, {"text": "It will confuse programs that have to analyze dependencies, such as ", "tag": "none", "senID": 2}, {"text": "What about modules that you use in many functions? You will either end up with a lot of redundant imports or you'll have to have some at the top of the file and some inside functions.", "tag": "none", "senID": 3}]}, {"text": ["So... the preferred way is to put all imports at the top of the file.", "I've found that if my imports get hard to keep track of, it usually means I have too much code that I'd be better off splitting it into two or more files."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Some situations where I have found imports inside functions to be useful:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "have", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "To deal with circular dependencies (if you really really can't avoid them)", "tag": "none", "senID": 6}, {"text": "Platform specific code", "tag": "none", "senID": 7}]}, {"text": ["Also: putting imports inside each function is actually not appreciably slower than at the top of the file.", "The first time each module is loaded it is put into sys.modules, and each subsequent import costs only the time to look up the module, which is fairly fast (it is not reloaded)."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "sys.modules", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["The top-voted answer to this question is nicely formatted but absolutely wrong about permformance.", "Let me demonstrate"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "top-voted answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/477096/python-import-coding-style/477107#477107"}]}, {"text": ["Top Import"], "childNum": 0, "tag": "h2", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import random\n\ndef f():\n    L = []\n    for i in xrange(1000):\n        L.append(random.random())\n\n\nfor i in xrange(1000):\n    f()\n\n$ time python import.py\n\nreal        0m0.721s\nuser        0m0.412s\nsys         0m0.020s\n</code>\n</pre>\n", "senID": 2}, {"text": ["Import in Function Body"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def f():\n    import random\n    L = []\n    for i in xrange(1000):\n        L.append(random.random())\n\nfor i in xrange(1000):\n    f()\n\n$ time python import2.py\n\nreal        0m0.661s\nuser        0m0.404s\nsys         0m0.008s\n</code>\n</pre>\n", "senID": 4}, {"text": ["As you can see, it can be more efficient to import the module in the function.", "The reason for this is simple.", "It moves the reference from a global reference to a local reference.", "This means that, for CPython at least, the compiler will emit LOAD_FAST instructions instead of LOAD_GLOBAL instructions.", "These are, as the name implies, faster.", "The other answerer artificially inflated the performance hit of looking in sys.modules by importing on every single iteration of the loop. "], "childNum": 5, "tag": "p", "senID": 5, "childList": [{"text": "more", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "LOAD_FAST", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "LOAD_GLOBAL", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "sys.modules", "childNum": 0, "tag": "code", "pos": 5, "childList": []}, {"text": "importing on every single iteration of the loop", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["As a rule, it's best to import at the top but performance is not the reason if you are accessing the module a lot of times.", "The reasons are that one can keep track of what a module depends on more easily and that doing so is consistent with most of the rest of the Python universe."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Another useful thing to note is that parts of using \"import\" inside of a function have been completely removed in Python 3.0."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There is a brief mention of it under \"Removed Syntax\" here:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://docs.python.org/3.0/whatsnew/3.0.html"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://docs.python.org/3.0/whatsnew/3.0.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/3.0/whatsnew/3.0.html"}]}], [{"text": ["From a performance point of view, you can see this: Should Python import statements always be at the top of a module?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Should Python import statements always be at the top of a module?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/128478/should-python-import-statements-always-be-at-the-top-of-a-module"}]}, {"text": ["In general, I only use local imports in order to break dependency cycles."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I believe this is a recommended approach in some cases/scenarios.", "For example in Google App Engine lazy-loading big modules is recommended since it will minimize the warm-up cost of instantiating new Python VMs/interpreters.", "Have a look at a Google Engineer's presentation describing this.", "However keep in mind this doesn't mean you should lazy-load all your modules."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Google Engineer's", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "https://sites.google.com/site/io/building-scalable-web-applications-with-google-app-engine"}, {"text": "doesn't", "childNum": 0, "tag": "strong", "pos": 3, "childList": []}]}], [{"text": ["You might want to take a look at Import statement overhead in the python wiki.", "In short: if the module has already been loaded (look at sys.modules) your code will run slower.", "If your module hasn't been loaded yet, and will foo will only get loaded when needed, which can be zero times, then the overall performance will be better."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "statement overhead", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/PythonSpeed/PerformanceTips#ImportStatementOverhead"}, {"text": "sys.modules", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["I would suggest that you try to avoid from foo import bar imports.", "I only use them inside packages, where the splitting into modules is an implementation detail and there won't be many of them anyway."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "from foo import bar", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In all other places, where you import a package, just use import foo and then reference it by the full name foo.bar.", "This way you can always tell where a certain element comes from and don't have to maintain the list of imported elements (in reality this will always be outdated and import no longer used elements). "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "import foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo.bar", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["If foo is a really long name you can simplify it with import foo as f and then write f.bar.", "This is still far more convenient and explicit than maintaining all the from imports."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "import foo as f", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "f.bar", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "from", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["People have explained very well why to avoid inline-imports, but not really alternative workflows to address the reasons you want them in the first place."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To check for unused imports I use pylint.", "It does static(ish)-analysis of Python code, and one of the (many) things it checks for is unused imports.", "For example, the following script.."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "pylint", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.logilab.org/project/pylint"}]}, {"code": "<pre>\n<code>\n import urllib\nimport urllib2\n\nurllib.urlopen(\"http://stackoverflow.com\")\n</code>\n</pre>\n", "senID": 2}, {"text": ["..would generate the following message:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n example.py:2 [W0611] Unused import urllib2\n</code>\n</pre>\n", "senID": 4}, {"text": ["As for checking available imports, I generally rely on TextMate's (fairly simplistic) completion - when you press Esc, it completes the current word with others in the document.", "If I have done import urllib, urll[Esc] will expand to urllib, if not I jump to the start of the file and add the import."], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "import urllib", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "urll[Esc]", "childNum": 0, "tag": "code", "childList": []}, {"text": "urllib", "childNum": 0, "tag": "code", "childList": []}]}]]