[[{"text": ["This is not possible in Python.", "The function on the right hand site has no knowledge of the context it was called in.", "The right hand site is evaluated before any of the name bindings take place."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you don't mind using Python 3, you can ignore what you don't need, for example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a, b, c, d, *_ = (x for x in range(100))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f(n):\n    return (None, ) * n\n</code>\n</pre>\n", "senID": 1}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a, b, c = f(3)\n</code>\n</pre>\n", "senID": 3}, {"text": ["... That's about as far as you can get, since in Python there's no way to know how many variables are in the left-hand side of an assignment."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Can't be done. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Functions in Python return one value, only.", "While it may sometimes look like more, it's still just one value: a tuple.", "Multiple assignment is then a process of tuple unpacking. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "tuple unpacking", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["Your question then can be restated: can we create an object that acts like a tuple of varying length, depending on how many values need to be unpacked?", "And that's simply not made available as an option. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Probably the closest I can think of is to use a generator and get the desired number of items with itertools.islice:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "itertools.islice", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a = itertools.count()\nx, y, z = itertools.islice(a, 3) # 0, 1, 2\nu, v = itertools.islice(a, 2)    # 3, 4\n</code>\n</pre>\n", "senID": 4}, {"text": ["But that's pretty far from what was hoped for."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["pretty not nice but perhaps this helps you:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f(x):\n    for i in x:\n        globals()[i] = None\n\nf(['a','b','c'])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Unfortunately, Python unpacks returned tuples using the Pythonic \"it's easier to ask forgiveness than permission\" approach.", "That is, if you have a statement:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a,b,c = f()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Behind the scenes, it's doing something along the lines of:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n try:\n    a = returned[0]\n    b = returned[1]\n    c = returned[2]\nexcept IndexError:\n    raise ValueError('need more than k values to unpack')\n\ntry:\n    _ = returned[4]\nexcept IndexError:\n    pass\nelse:\n    raise ValueError('too many values to unpack')\n</code>\n</pre>\n", "senID": 3}, {"text": ["So it's discovering dynamically the number of values returned.", "Unfortunately, that precludes us from being clever and creating a new type for handling variable returns:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class VariableReturn(object):\n    def __getitem__(self, index):\n        return ...\n</code>\n</pre>\n", "senID": 5}, {"text": ["In Python 3, you can sort of do what you're asking, but the burden is on the caller, not the function being called.", "The function should always return the same number of results, but we'll trap the remaining results using extended tuple unpacking, as shown in this StackOverflow question."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "extended tuple unpacking", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-3132/"}, {"href": "http://stackoverflow.com/questions/749070/partial-list-unpack-in-python", "text": "this StackOverflow question", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Using this approach, you can return as many results as you'd like, but you need to always return at least as many as you need in the maximal case.", "The rest get packed into a trailing tuple."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n a,*others = f()\na,b,*others = f()\na,b,c,*others = f()\n</code>\n</pre>\n", "senID": 8}]]