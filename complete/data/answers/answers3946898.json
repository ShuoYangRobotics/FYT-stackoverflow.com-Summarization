[[{"text": ["A quick one-liner would be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n grep -a \"63[789]\\...;\" data.csv | sort -n -r -t ';' -k 2 | head --lines=1\n</code>\n</pre>\n", "senID": 1}, {"text": ["This simply sorts the file numerically based on the second column and then prints out the first row.", "Hope that helps."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you are going to use Python, then use Python.", "Why are you intermixing bash commands together?", "It makes your code not portable/dependent on a bash environment."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\nimport glob\nimport operator\nos.chdir(\"/mypath\")\nfor file in glob.glob(\"*.csv\"):\n    data=open(file).readlines()\n    data=[i.strip().split(\";\") for i in data if i[:3] in [\"637\",\"638\",\"639\"]]\n    # data=[i.strip().split(\";\") for i in data if i[:3] in [\"637\",\"638\",\"639\"] and isinstance(float(i[:6]),float) ]\n    sortedlist = sorted(data, key=operator.itemgetter(1), reverse=True)\n    print \"Highest for file %s: %s\" % (file,sortedlist[0])\n</code>\n</pre>\n", "senID": 1}, {"text": ["OR, if you are more interested in a bash+tools solution"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n find . -type f -name '*.csv' |while read -r FILE\ndo\n grep -a \"63[789]\\...;\" \"$FILE\" | sort -n -r -t ';' -k 2 | head -1  &gt;&gt; output.txt\ndone\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n $ cat data.csv | grep -a \"63[789]\\...;\" | awk 'BEGIN {FS=\";\"} $2&gt;max{max=$2; val=$1} END {print \"max \" max \" at \" val}' \n\nmax 1454.2 at 638.14\n</code>\n</pre>\n", "senID": 0}], [{"text": ["If you have a ton of data then you don't want to store all that data into memory and then sort it to get the max value.", "This approach is inefficient regarding both computing time complexity and memory."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "a ton of data", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "store", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "sort", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "inefficient", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["You can simply parse the files and compute the desired values on-the-fly instead.", "A fast pure Python approach to deal with your problem:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "fast", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import os, re\nos.chdir('/path/to/csvdir')\nfor f in os.listdir('.'):\n    dataset, count = 0.0, 0.0\n    for line in open(f):\n        if re.search(r'63[6789]\\...', line):\n            d, c = map(float, line.strip().split(';'))\n            if count &lt; c:\n                dataset, count = d, c\n    print f, dataset\n</code>\n</pre>\n", "senID": 2}, {"text": ["This approach can also be used to show a list of max values (if there can be more than one dataset with highest counts) by modifying the appropriate lines:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n dataset, count = [], 0.0\n...\n        if count &lt; c:\n            dataset, count = [d], c\n        elif count == c:\n            dataset.append(d)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Edit: the script assumes that your csvdir is populated only with files containing the parsing format.", "If you want to filter them by name, you can use either glob (with limited regexp capabilities in name filtering):"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for f in glob.glob('*.csv'):\n</code>\n</pre>\n", "senID": 6}, {"text": ["or apply a filter to os.listdir:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "os.listdir", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n for f in filter(lambda f: re.match('.*\\.csv', f), os.listdir('.')):\n</code>\n</pre>\n", "senID": 8}], [{"text": ["Here is code I wrote to sort csv files using python.", "It allows you to specify multiple columns and to sort in reverse order by using a minus sign."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\n# Usage:\n# (1) sort ctb_consolidated_test_id.csv by Academic Year, Test ID, Period, and Test Name, with Test ID in descending order\n#   sort_csv.py -c \"Academic Year\" -c \"-Test ID\" -c \"Period\" -c \"Test Name\" ctb_consolidated_test_id.csv\nfrom __future__ import with_statement\nfrom __future__ import print_function\n\nimport sys\n\ndef multikeysort(items, columns):\n    from operator import itemgetter\n    import re\n    num_re = re.compile(r'^\\d+$')\n    comparers = [\n        ((itemgetter(col[1:].strip()), -1) if col.startswith('-') else (itemgetter(col.strip()), 1))\n        for col in columns\n    ]\n    def number_comparable(val1, val2):\n        return len(val1) != len(val2) and num_re.match(val1) and num_re.match(val2)\n    def column_comparer(left, right):\n        for fn, mult in comparers:\n            val1, val2 = fn(left), fn(right)\n            if number_comparable(val1, val2):\n                val1, val2 = int(val1), int(val2)\n            result = cmp(val1, val2)\n            if result:\n                return mult * result\n        return 0\n    return sorted(items, cmp=column_comparer)\n\ndef sort_csv(filename, columns):\n    import csv\n    with open(filename, \"r\") as f:\n        reader = csv.DictReader(f)\n        writer = csv.DictWriter(sys.stdout, reader.fieldnames)\n        writer.writerow(dict(zip(reader.fieldnames, reader.fieldnames)))\n        writer.writerows(multikeysort(reader, columns))\n\nif __name__ == '__main__':\n    from glob import glob\n    from optparse import OptionParser, make_option\n    option_list = [\n        make_option('-c', '--column', dest='columns', action='append', metavar='COLUMN NAME'),\n    ]\n    parser = OptionParser(option_list=option_list)\n    (options, args) = parser.parse_args()\n    filenames = (filename for arg in args for filename in glob(arg))\n    for filename in filenames:\n        sort_csv(filename, options.columns)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["nice, thanks a lot, Hakop Palyan !"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Now is there a trick on how to get this data set out of all the csv files and collect it somewhere as a new file?", "something like"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n find . -name '*.csv' -print0 | xargs -0 grep -a \"63[789]\\...;\" | sort -n -r -t ';' -k 2 | head --lines=1\n</code>\n</pre>\n", "senID": 2}, {"text": ["this one prints only the first line, I would need to iterate over the individual files and collect the datasets ..."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I know you are looking for a bash based solution but I could not help offering something using the csv module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "csv", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/csv.html#examples"}]}, {"code": "<pre>\n<code>\n import os\nimport csv\nimport re\n\ntarget_re = re.compile(r'^63[789]\\.\\d\\d$')\ncsv_filenames = [f for f in os.listdir('.') if f.endwith('.csv')]\nlargest_in_each_file = []\n\nfor f in csv_filenames:\n    largest = (None, 0)\n    for a,b in csv.reader(open(f, 'rb'), delimiter=';'):\n        if target_re.match(a) and b &gt; largest[1]:\n            largest = (a, b)\n    largest_in_each_file.append(largest)\n\n\nlargest_overall = largest_in_each_file[0]\nfor largest in largest_in_each_file:\n    print \"%s;%s in %s\" % largest\n    if largest[1] &gt; largest_overall[1]:\n        largest_overall = largest\n\nprint \"-\" * 10\nprint \"%s;%s in %s is the largest record in all files\" % largest_overall\n</code>\n</pre>\n", "senID": 1}]]