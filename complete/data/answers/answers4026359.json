[[{"text": ["Martijn mentioned this in a comment (not sure why people comment with answers), but I agree: use SQLite.", "You should give it a try and see if it will meet your needs."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you don't plan to have a large amounts of deletes, then this isn't that hard.", "Deletes lead to fragmentation."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You also need to commit to a fixed length key.", "You mentioned 80 bytes.", "Are your keys allowed to duplicate?", "If not, it's even easier."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So, here is what you do."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You create an array of: "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n struct {\n    char value[80];\n    char *data;\n} key;\n</code>\n</pre>\n", "senID": 4}, {"text": ["And you keep this array sorted."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["If you keys can duplicate, then you need:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n struct link {\n    char *data;\n    link *next;\n}\n\nstruct {\n    char value[80];\n    link *data;\n} key;\n</code>\n</pre>\n", "senID": 7}, {"text": ["(My C is rusty, but this is the gist of it) The latter has each key pointing to a linked list of values."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["Then a lookup is a simple binary search.", "The \"pain\" is in maintaining this array and inserting/deleting keys.", "It's not as painful as it sounds, but it saves a LOT of memory, especially on 64bit systems."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["What you want to reduce is the number of pointers.", "Pointers are expensive when you have lots of structures filled with pointers.", "On a 64bit system, a pointer is 8 bytes.", "So for a single pointer, there goes 8MB of your memory budget."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["So, the expense is in building the array, copying and compacting memory (if you \"know\" you will have a million rows and can commit to that, then malloc(1000000 * sizeof(key)) right away, it'll save you some copying during expansion)."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["But don't be afraid of, once it's up and running, performance is quite good.", "Modern cpus are actually pretty good at copying 100M blocks of memory around."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Just as an aside, I just did something much like this in Java.", "On a 64bit JVM, a Map with 25M entries is 2G of RAM.", "My solution (using similar techniques to this) has at around 600M).", "Java uses more pointers than C, but the premise is the same."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["Ok, the dirt-simple approach.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Use a python dictionary for the data structure.", "I filled a python dictionary with 1 million random key-value pairs where the key was 80 characters and the value 200 characters.", "It took 360,844 Kb on my computer, which is outside of your specification of no more than 300 MB, but I offer it up as a solution anyway because it's still pretty memory efficient.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This also fails your requirement of having a C API.", "I'm not sure why you need C, but as the question is tagged Python and lacks a C tag, I'll offer the pure Python to see if it just might fit the bill."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Regarding persistence.", "Use the cPickle module.", "It's very fast and, again, dirt-simple.", "To save your dictionary:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n cPickle.dump(mydict, \"myfile.pkl\")\n</code>\n</pre>\n", "senID": 4}, {"text": ["To reload your dictionary:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n mydict = cPickle.load(\"myfile.pkl\")\n</code>\n</pre>\n", "senID": 6}, {"text": ["A second dirt-simple idea is to use the shelve module, which is basically disk-based python dictionary.", "Memory overhead is very low (it's all on disk).", "But it's also much slower."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "shelve", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Have you tried using a straightforward dict?", "Most of your data is in strings, so the overhead might fit within your requirements."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You can use the sha1 of the key instead of the key itself.", "If the keys are unique, then the sha1 hash of the keys is likely, too.", "It provides a memory savings to try to squeak in under your limit."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "sha1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sha1", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from random import choice\nfrom string import letters\nfrom hashlib import sha1\n\ndef keygen(length):\n    return \"\".join(choice(letters) for _ in xrange(length))\n\ndef gentestdata(n=1000*1000):\n    # return dict((sha1(keygen(80)).digest(), keygen(200)) for _ in xrange(n))\n    d = {}\n    for _ in xrange(n):\n        key = sha1(keygen(80)).digest()\n        assert key not in d\n        value = keygen(200)\n        d[key] = value\n    return d\n\nif __name__ == '__main__':\n    d = gentestdata()\n</code>\n</pre>\n", "senID": 1}, {"text": ["On my ubuntu box, this tops out at 304 MB of memory:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 2010-10-26 14:26:02 hbrown@hbrown-ubuntu-wks:~$ ps aux | grep python\n[...]\nhbrown   12082 78.2  7.5 307420 303128 pts/1   S+   14:20   4:47 python\n</code>\n</pre>\n", "senID": 3}, {"text": ["Close enough?", "It's python, not C."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Later: also, if your data is somewhat redundant, you can gzip the values.", "It's a time versus space trade-off."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "gzip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Using SQLite is a good idea.", "A quick implementation can tell if you are fast enough with little effort."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "fast enough", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}, {"text": ["If you determine you have to roll your own, I'd recommend the following:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["How well can you predict the number of pairs, or an upper limit for that?", "How well can you predict the total data size, or an upper limit for that?"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["Arena allocator for strings and nodes.", "(Usually, you'd work on a list of arenas, so you don't have to predict the total size)."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "Arena allocator", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "Arena allocator", "tag": "a"}]}, {"text": "Arena allocator", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.cs.lth.se/EDA150/wA3.html"}]}, {"text": ["Alignment depends on your algorithms, in principle you could pack it byte-tight, and the only overhead is your overallocation, which only minimally affects your working set."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["However, if you have to run any cmp/copy etc.", "operations on these strings, remember that with the following guarantees, you can squeeze a little or a lot from these string operations:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "all elements are CPU word aligned", "tag": "none", "senID": 6}, {"text": "all pad bytes are (e.g.) 0", "tag": "none", "senID": 7}, {"text": "you can safely read \"beyond\" a string end as long as you don't cross a CPU border", "tag": "none", "senID": 8}]}, {"text": ["Hash table for the index.", "A dictionary would work, too, but that makes sense only if potential degradation / rehashing would be a serious issue.", "I don't know any \"stock\" hashtable implementation for C, but there should be one, right?", "right?", "Just replace allocations with calls to the arena allocator."], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Hash table", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Memory Locality "], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "Memory Locality", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If you can guarantee that lookup will never request a string that is not in the map, you should store the keys in a separate arena, as they are needed only on hash collisions.", "That can improve memory locality significantly.", "(In that case, if you ever have a \"final\" table, you could even copy the colliding keys to a new arena, and throw away all the others.", "The benefits of that are probably marginal, though."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["Separation can help or hurt, depending on your access patterns.", "If you typically use the value once after each lookup, having them pair-wise in the same arena is great.", "If you e.g.", "look up a few keys, then use their values repeatedly, separate arenas make sense."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["If you have to support \"funny characters\" / Unicode, normalize your strings before storing them. "], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["You could use struct module to pack binary data and unpack it when needed.", "You can implement a memory efficient storage using this approach.", "I guess access would be a pain."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": ["http://docs.python.org/library/struct.html"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}]}], [{"text": ["Apache Portable Runtime (aka APR) has a c-based hash table.", "You can see documentation at http://apr.apache.org/docs/apr/0.9/group_apr_hash.html "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "http://apr.apache.org/docs/apr/0.9/group_apr_hash.html", "tag": "a", "pos": 1, "childList": [{"text": "apr", "tag": "em"}], "childNum": 1, "href": "http://apr.apache.org/docs/apr/0.9/group__apr__hash.html"}, {"text": "apr", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["With apr_hash_t all you store is void*.", "So it gives you full control over values.", "SO if you want you can store pointer to a 100 byte block instead of actual length of the string."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Since I couldn't find any existing solutions which will pack the memory tightly, I've decided to implement it in C for myself.", "See my design with open addressing in the question."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "open addressing", "childNum": 0, "tag": "i", "pos": 1, "childList": []}]}]]