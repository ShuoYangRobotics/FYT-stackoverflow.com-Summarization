[[{"text": ["Your first thought should be channel security - either SSL/TLS, or IPSec.", "Admittedly, these both have a certain amount of setup overhead, IPSec more than SSL/TLS, especially when it comes to PKI etc.", "- but it more than pays for itself in simplicity of development, reliability, security, and more.", "Just make sure you're using strong cipher suites, as appropriate to the protocol."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["If neither SSL/TLS or IPSec fits your scenario/environment, your next choice should be AES (aka Rijndael).", "Use keys at least 256 bits long, if you want you can go longer.", "Keys should be randomly generated, by a cryptographically secure random number generator (and not a simple rnd() call).", "Set the cipher mode to CBC.", "Use PKCS7 padding.", "Generate a unique, crypto-random Initialization Vector (IV).", "Don't forget to properly protect and manage your keys, and maybe consider periodic key rotations."], "childNum": 7, "tag": "p", "senID": 1, "childList": [{"text": "AES", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 3, "childList": []}, {"text": "CBC", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Cipher_block_chaining"}, {"text": "", "childNum": 0, "tag": "br", "pos": 4, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 5, "childList": []}]}, {"text": ["Depending on your data, you may want to also implement a keyed hash, to provide for message integrity - use SHA-256 for hashing."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "SHA-256", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/SHA-256"}]}, {"text": ["There are also rare situations where you may want to go with a stream cipher, but thats usually more complicated and I would recommend you avoid it your first time out."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Now, I'm not familiar ezpycrypto (or really python in general), and cant really state that it supports all this; but everything here is pretty standard and recommended best practice, if your crypto library doesnt support it, I would suggest finding one that does ;-)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["DANGER!", "If you don't know much about cryptography, don't try to implement it yourself.", "Cryptography is hard to get right.", "There are many, many different ways to break the security of a cryptographic system beyond actually cracking the key (which is usually very hard)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "DANGER!", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "hard to get right", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["If you just slap a cipher on your streaming data, without careful key management and other understanding of the subtleties of cryptographic systems, you will likely open yourself up to all kinds of vulnerabilities.", "For example, the scheme you describe will be vulnerable to man-in-the-middle attacks without some specific plan for key distribution among the nodes, and may be vulnerable to chosen-plaintext and/or known-plaintext attacks depending on how your distributed system communicates with the outside world, and the exact choice of cipher and mode of operation."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "man-in-the-middle attacks", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://wikipedia.org/wiki/Man-in-the-middle_attack"}, {"href": "http://wikipedia.org/wiki/Chosen-plaintext_attack", "text": "chosen-plaintext", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://wikipedia.org/wiki/Known-plaintext_attack", "text": "known-plaintext attacks", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://wikipedia.org/wiki/Block_cipher_mode", "text": "mode of operation", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["So... you will have to read up on crypto in general before you can use it securely."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Assuming the use of symmetric crypto, then AES should be your default choice, unless you have a good very reason to select otherwise. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["There was a long, involved competition to select AES, and the winner was carefully chosen.", "Even Bruce Schneier, crypto god, has said that the AES winner is a better choice than the algorithm (TwoFish) that he submitted to the competition."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["AES 256 is generally the preferred choice, but depending on your location (or your customers' location) you may have legal constraints, and will be forced to use something weaker."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also note that you should use a random IV for each communication and pass it along with the message (this will also save the need for a timestamp)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If possible, try not to depend on the algorithm, and pass the algorithm along with the message.", "The node will then look at the header, and decide on the algorithm that will be used for decryption.", "That way you can easily switch algorithms when a certain deployment calls for it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I'd probably go for AES."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "AES", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Advanced_Encryption_Standard#Implementations"}]}], [{"text": ["Asymmetric encryption would work in this scenario as well.", "Simply have each node publish it's public key.", "Any node that wants to communicate with that node need only encrypt the message with that node's public key.", "One advantage of using asymmetric keys is that it becomes easier to change and distribute keys -- since the public keys can be distributed openly, each node need only update it's public-private key pair and republish.", "You don't need some protocol for the entire network (or each node pair) to agree on a new symmetric key."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Why not create a VPN among the nodes that must communicate securely? "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Then, you don't have to bother coding up your own security solution, and you're not restricted to a static, shared key (which, if compromised, will allow all captured traffic to be decrypted after the fact)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]