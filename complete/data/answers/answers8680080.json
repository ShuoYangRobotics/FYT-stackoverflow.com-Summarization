[[{"text": ["When you receive a string, you'll be sure that it stays the same.", "Suppose that you'd construct a Foo as below with a string argument, and would then modify the string; then the Foo's name would suddenly change:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Foo", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "Foo", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n class Foo(object):\n    def __init__(self, name):\n        self.name = name\n\nname = \"Hello\"\nfoo = Foo(name)\nname[0] = \"J\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["With mutable strings, you'd have to make copies all the time to prevent bad things from happening."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It also allows the convenience that a single character is no different from a string of length one, so all string operators apply to characters as well."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["And lastly, if strings weren't immutable, you couldn't reliably stick them in a dict, since their hash value might suddenly change."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["As for programming with immutable strings, just get used to treating them the same way you treat numbers: as values, not as objects.", "Changing the first letter of name would be"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "values", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "name", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n name = \"J\" + name[1:]\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Here is the answer to the first part of your question which is related to Python Strings"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "Here", "childNum": 1, "tag": "strong", "pos": 0, "childList": [{"text": "Here", "tag": "a"}]}, {"href": "http://effbot.org/pyfaq/why-are-python-strings-immutable.htm", "text": "Here", "childNum": 0, "tag": "a", "childList": []}, {"text": "Python Strings", "childNum": 0, "tag": "strong", "childList": []}]}], [], [{"text": ["Immutable strings can be keys in dictionaries and similar data structures, without the need to copy the strings.", "It is easier to make a mutable wrapper around an immutable string than the other way around."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Immutable strings makes programming much easier, which is why C# and Java use them too."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Had strings been mutable, you would not be able to trust any externally-provided string, since a malicious caller could change it underneath you.", "It would also make multi-threading much more difficult."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}], [{"text": ["Most languages have immutable strings.", "This includes Java, Python, and C#.", "Usually when concatenating strings, the language allocates an entirely new string and copies the content of the two strings into the new string."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Immutability does tend to make programming easier.", "Especially when dealing with a multi-threaded environment."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Immutable strings greatly simplify memory allocation when compared with C strings: you don't guess at a length and over-allocate hoping you over-allocated enough."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["They're more secure: you can never have a buffer overrun the way you can in C. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "never", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["There is only one mutable string use case."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": "replacing a substring or a single character", "tag": "none", "senID": 3}]}, {"text": ["All other string use cases (concatenation, searching, etc., etc.", ") the mutability does not matter.", "In all other cases, mutability does not matter."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "All", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["If you want to replace a character or a substring in Python, you simply create a new string"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n x = x[:place] + replacement + x[place+1:]\n</code>\n</pre>\n", "senID": 6}, {"text": ["That's the only code that novel or distinctive."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["For reasons I fail to understand, it appears important to add the following."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["\"There are other ways to avoid a string buffer overflow than immutable strings."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["For the purposes of this question (about Python, specifically) immutable strings have a pleasant consequence of no buffer overflows.", "For other languages, other principles, rules and nuances apply."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}]]