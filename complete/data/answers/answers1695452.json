[[{"code": "<pre>\n<code>\n try:\n  last_found = -1\n  for num in L1:\n     last_found = L2.index(num, last_found + 1)\n  return True\nexcept ValueError:\n  return False\n</code>\n</pre>\n", "senID": 0}, {"text": ["The index method of list L2 returns the position at which the first argument (num) is found in the list; called, like here, with a second arg, it starts looking in the list at that position.", "If index does not find what it's looking for, it raises a ValueError exception."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "index", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "num", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "index", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "ValueError", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So, this code uses this approach to look for each item num of L1, in order, inside L2.", "The first time it needs to start looking from position 0; each following time, it needs to start looking from the position just after the last one where it found the previous item, i.e.", "last_found + 1 (so at the start we must set last_found = -1 to start looking from position 0 the first time)."], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "num", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "L1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "L2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "last_found + 1", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "last_found = -1", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If every item in L1 is found this way (i.e.", "it's found in L2 after the position where the previous item was found), then the two lists meet the given condition and the code returns True.", "If any item of L1 is ever not-found, the code catches the resulting ValueError exception and just returns False."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "True", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "ValueError", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "False", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["A different approach would be to use iterators over the two lists, that can be formed with the iter built-in function.", "You can \"advance\" an iterator by calling built-in next on it; this will raise StopIteration if there is no \"next item\", i.e., the iterator is exhausted.", "You can also use for on the iterator for a somewhat smoother interface, where applicable.", "The low-level approach using the iter/next idea:"], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "iterators", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "iter", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "next", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "StopIteration", "childNum": 0, "tag": "code", "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n i1 = iter(L1)\ni2 = iter(L2)\nwhile True:\n  try:\n    lookfor = next(i1)\n  except StopIteration:\n    # no more items to look for == all good!\n    return True\n  while True:\n    try:\n      maybe = next(i2)\n    except StopIteration:\n      # item lookfor never matched == nope!\n      return False\n    if maybe == lookfor:\n      break\n</code>\n</pre>\n", "senID": 5}, {"text": ["or, a bit higher-level:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n i1 = iter(L1)\ni2 = iter(L2)\nfor lookfor in i1:\n  for maybe in i2:\n    if maybe == lookfor:\n      break\n  else:\n    # item lookfor never matched == nope!\n    return False\n# no more items to look for == all good!\nreturn True\n</code>\n</pre>\n", "senID": 7}, {"text": ["In fact, the only crucial use of iter here is to get i2 -- having the inner loop as for maybe in i2 guarantees the inner loop won't start looking from the beginning every time, but, rather, it will keep looking where it last left off.", "The outer loop might as well for for lookfor in L1:, since it has no \"restarting\" issue. "], "childNum": 3, "tag": "p", "senID": 8, "childList": [{"text": "iter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "for maybe in i2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "for lookfor in L1:", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Key, here, is the else: clause of loops, which triggers if, and only if, the loop was not interrupted by break but rather exited naturally."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "else:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "break", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Working further on this idea we are again reminded of the in operator, which also can be made to continue where it last left off simply by using an iterator.", "Big simplification:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "in", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n i2 = iter(L2)\nfor lookfor in L1:\n  if lookfor not in i2:\n    return False\n# no more items to look for == all good!\nreturn True\n</code>\n</pre>\n", "senID": 11}, {"text": ["But now we recognize that is exactly the patter abstracted by the short-circuiting any and all built-in \"short-circuiting accumulator\" functions, so...:"], "childNum": 2, "tag": "p", "senID": 12, "childList": [{"text": "any", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "all", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n i2 = iter(L2)\nreturn all(lookfor in i2 for lookfor in L1)\n</code>\n</pre>\n", "senID": 13}, {"text": ["which I believe is just about as simple as you can get.", "The only non-elementary bit left here is: you need to use an iter(L2) explicitly, just once, to make sure the in operator (intrinsically an inner loop) doesn't restart the search from the beginning but rather continues each time from where it last left off."], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "iter(L2)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "in", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["This question looks a bit like homework and for this reason I'd like to take the time and discuss what may be going wrong with the snippet shown in the question."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Although you are using a word in its plural form, for the nums variable, you need to understand that Python will use this variable to store ONE item from l1 at a time, and go through the block of code in this \"for block\", one time for each different item."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The result of your current snippet will therefore be to exit upon the very first iteration, with either True or False depending if by chance the first items in the list happen to match."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit: Yes, A1, exactly as you said: the logic exits with True after the first iteration.", "This is because of the \"return\" when nums is found in l2.", "If you were to do nothing in the \"found\" case, the loop the logic would proceed with finishing whatever logic in the block (none here) and it would then start the next iteration.", "Therefore it would only exit with a \"False\" return value, in the case when an item from l1 is not found l2 (indeed after the very first such not-found item).", "Therefore your logic is almost correct (if it were to do nothing in the \"found case\"), the one thing missing would be to return \"True\", systematically after the for loop (since if it didn't exit with a False value within the loop, then all items of l2 are in l1...)."], "childNum": 5, "tag": "p", "senID": 3, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"text": "your logic is almost correct", "childNum": 0, "tag": "strong", "pos": 4, "childList": []}, {"text": "systematically", "childNum": 0, "tag": "em", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["There are two ways to modify the code so it does nothing for the \"found case\".", "- by using pass, which is a convenient way to instruct Python to do nothing;  \"pass\" is typically used when \"something\", i.e.", "some action is syntactically required but we don't want anything done, but it can also be used when debugging etc.", "- by rewriting the test as a \"not in\" instead"], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "pass", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 3, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"code": "<pre>\n<code>\n if nums not in l2:\n   return False\n#no else:, i.e. do nothing at all if found\n</code>\n</pre>\n", "senID": 5}, {"text": ["Now... Getting into more details.", "There may be a flaw in your program (with the suggested changes), that is that it would consider l1 to be a sublist of l2, even if l1 had say 2 items with value say 5 whereby l2 only had one such value.", "I'm not sure if that kind of consideration is part of the problem (possibly the understanding is that both lists are \"sets\", with no possible duplicate items).", "If duplicates were allowed however, you would have to complicate the logic somewhat (a possible approach would be to intitially make a copy of l2 and each time \"nums\" is find in the l2 copy, to remove this item."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["Another consideration is that maybe a list can only be said to be a sublist if its items are found the same order as the items in the other list...   Again it all depends on the way the problem is defined...  BTW some of the solutions proposed, like Alex Martelli's are written in such fashion because they solve the problem in a way that the order of items with the lists matter."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I think this solution is the fastest, since it iterates only once, albeit on the longer list and exits before finishing the iteration if a match is found.", "(Edit: However, it is not as succinct or as fast as Alex's latest solution)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def ck(l1,l2):\n    i,j = 0,len(l1)\n    for e in l2:\n        if e == l1[i]:\n            i += 1\n        if i == j:\n            return True\n    return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["An improvement was suggested by Anurag Uniyal (see comment) and is reflected in the showdown below."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here are some speed results for a range of list size ratios (List l1 is a 10-element list containing random values from 1-10.", "List l2 ranges from 10-1000 in length (and also contain random values from 1-10)."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "l1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "l2", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Code that compares run times and plots the results:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import random\nimport os\nimport pylab\nimport timeit\n\ndef paul(l1,l2):\n    i = 0\n    j = len(l1)\n    try:\n        for e in l2:\n            if e == l1[i]:\n                i += 1\n    except IndexError: # thanks Anurag\n        return True\n    return False\n\ndef jed(list1, list2):\n    try:\n        for num in list1:\n            list2 = list2[list2.index(num):]\n    except: return False\n    else: return True\n\ndef alex(L1,L2):  # wow!\n    i2 = iter(L2)\n    return all(lookfor in i2 for lookfor in L1)\n\nfrom itertools import dropwhile\nfrom operator import ne\nfrom functools import partial\n\ndef thc4k_andrea(l1, l2):\n    it = iter(l2)\n    try:\n        for e in l1:\n            dropwhile(partial(ne, e), it).next()\n        return True\n    except StopIteration:\n        return False\n\n\nct = 100\nss = range(10,1000,100)\nnms = 'paul alex jed thc4k_andrea'.split()\nls = dict.fromkeys(nms)\nfor nm in nms:\n    ls[nm] = []\n\nsetup = 'import test_sublist as x'\nfor s in ss:\n    l1 = [random.randint(1,10) for i in range(10)]\n    l2 = [random.randint(1,10) for i in range(s)]\n    for nm in nms:\n        stmt = 'x.'+nm+'(%s,%s)'%(str(l1),str(l2))\n        t = timeit.Timer(setup=setup, stmt=stmt).timeit(ct)\n        ls[nm].append( t )\n\npylab.clf()\nfor nm in nms:\n    print len(ss), len(ls[nm])\n    pylab.plot(ss,ls[nm],label=nm)\n    pylab.legend(loc=0)\n\n    pylab.xlabel('length of l2')\n    pylab.ylabel('time')\n\npylab.savefig('cmp_lsts.png')\nos.startfile('cmp_lsts.png')\n</code>\n</pre>\n", "senID": 5}, {"text": ["results:\n"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "", "childNum": 0, "tag": "img", "pos": 0, "childList": []}]}], [{"text": ["This should be easy to understand and avoid corner case nicely as you don't need to work with indexes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def compare(l1, l2):\n    it = iter(l2)\n    for e in l1:\n        try:\n            while it.next() != e: pass\n        except StopIteration: return False\n    return True\n</code>\n</pre>\n", "senID": 1}, {"text": ["it tries to compare each element of l1 to the next element in l2.", "if there is no next element (StopIteration) it returns false (it visited the whole l2 and didn't find the current e) else it found it, so it returns true."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "e", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "l1", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "l2", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "StopIteration", "childNum": 0, "tag": "em", "childList": []}, {"text": "e", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["For faster execution it may help to put the try block outside the for:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def compare(l1, l2):\n    it = iter(l2)\n    try: \n        for e in l1:\n            while it.next() != e: pass\n    except StopIteration: return False\n    return True\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I have a feeling this is more intensive than Alex's answer, but here was my first thought:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def test(list1, list2):\n    try:\n        for num in list1:\n            list2 = list2[list2.index(num):]\n    except: return False\n    else: return True\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: Just tried it.", "His is faster.", "It's close."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Edit 2: Moved try/except out of the loop (this is why others should look at your code).", "Thanks, gnibbler."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "Edit 2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["I have a hard time seeing questions like this and not wishing that Python's list handling was more like Haskell's.", "This seems a much more straightforward solution than anything I could come up with in Python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n contains_inorder :: Eq a =&gt; [a] -&gt; [a] -&gt; Bool\ncontains_inorder [] _ = True\ncontains_inorder _ [] = False\ncontains_inorder (x:xs) (y:ys) | x == y    = contains_inorder xs ys\n                               | otherwise = contains_inorder (x:xs) ys\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The ultra-optimized version of Andrea's solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import dropwhile\nfrom operator import ne\nfrom functools import partial\n\ndef compare(l1, l2):\n    it = iter(l2)\n    try:\n        for e in l1:\n            dropwhile(partial(ne, e), it).next()\n        return True\n    except StopIteration:\n        return False\n</code>\n</pre>\n", "senID": 1}, {"text": ["This can be written even more functional style:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def compare(l1,l2):\n    it = iter(l2)\n    # any( True for .. ) because any([0]) is False, which we don't want here\n    return all( any(True for _ in dropwhile(partial(ne, e), it)) for e in l1 )\n</code>\n</pre>\n", "senID": 3}]]