[[{"text": ["What you have is a bipartite graph.", "As an initial stab, it sounds like you are going to treat neighbour lists as zero-one vectors between which you define some kind of similarity/correlation.", "This could be a normalised Hamming distance for example.", "Depending on which way you do that you will obtain a graph on a single domain -- either product codes or owners.", "It will shortly become clear why I've cast everything in the language of graphs, bear with me.", "Now why do you insist on a Python implementation?", "Clustering large scale data is time and memory consuming.", "To pull the cat out of the bag, I have written and still maintain a graph clustering algorithm, used quite widely in bioinformatics.", "Is is threaded, accepts weighted graphs, and has been used for graphs with millions of nodes and towards a billion of edges.", "Refer to http://micans.org/mcl/ for more information.", "Of course, if you trawl stackoverflow and stackexchange there is quite a few threads that may be of interest to you.", "I would recommend the Louvain method as well, except that I am not sure whether it accepts weighted networks, which you will probably produce."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://micans.org/mcl/", "tag": "a", "pos": 9, "childList": [], "childNum": 0, "href": "http://micans.org/mcl/"}]}], [{"text": ["R language has many packages for finding groups in data, and there are python bindings to R, called RPy.", "R provides several algorithms already mentioned here and also known for good performance on large datasets. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "has many packages for finding groups in data", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://cran.r-project.org/web/views/Cluster.html"}, {"text": "RPy", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://rpy.sourceforge.net/"}]}], [{"text": ["I think you can use pycluster also change algorithm for your problem"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["http://bonsai.hgc.jp/~mdehoon/software/cluster/software.htm"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["http://cran.r-project.org/web/views/Cluster.html"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}]}, {"text": ["also i think you better see this http://www.dennogumi.org/2007/11/data-clustering-with-python"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://www.dennogumi.org/2007/11/data-clustering-with-python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.dennogumi.org/2007/11/data-clustering-with-python"}]}], [{"text": ["I don't know much about your problem domain.", "But PyCluster is pretty decent clustering package which works good on large datasets:\nhttp://bonsai.hgc.jp/~mdehoon/software/cluster/software.htm"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://bonsai.hgc.jp/~mdehoon/software/cluster/software.htm", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://bonsai.hgc.jp/~mdehoon/software/cluster/software.htm"}]}, {"text": ["Hope it helps."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I don't know of an off-the-shelf lib, sorry.", "There are big libs for full-text search and similarity,\nbut for bit sets you'll have to roll your own (as far as i know).", "A couple  of suggestions anyway:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["bitset approach: first get say 10k owners x 100k products, or 100k x 10k, in memory, to play with.", "You could use bitarray to make a big array of 10k x 100k bits.", "But then, what do you want to do with it ?", "To find similar pairs among N objects (either owners or products),\nyou have to look at all N*(N-1)/2 pairs, which is a lot;\nor, there must be some structure in tha data that allows early pruning / hierarchical similarity;\nor, google \"greedy clustering\" Python &mdash; don't see an  off-the-shelf lib."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "bitarray", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/3027925/best-way-in-python-to-determine-all-possible-intersections-in-a-matrix"}, {"text": "", "childNum": 0, "tag": "br", "pos": 2, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 3, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["how do you define \"similarity\" of owners / of products ?", "There are lots of possibilities &mdash; number in common, ratio in common, tf-idf ..."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "tf-idf", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/TF_IDF"}]}]}, {"text": ["(Added): have you looked at Mahout's recommendation system API,\nis that about what you're looking for ?", "This SO question\nsays there's no Python equivalent, which leaves two choices:\na) ask if anyone has used Mahout from Jython,\nor b) if you can't lick 'em, join 'em."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "Mahout", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://mahout.apache.org"}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"href": "http://stackoverflow.com/questions/4819437/javas-mahout-equivalent-in-python", "text": "This", "childNum": 0, "tag": "a", "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}], [{"text": ["You can try to do clustering using the k-means clustering algorithm and its scipy implementation available in scikits.learn.cluster.KMeans."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "k-means clustering algorithm", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/K-means_clustering"}, {"href": "http://scikit-learn.sourceforge.net/modules/generated/scikits.learn.cluster.KMeans.html", "text": "scikits.learn.cluster.KMeans", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["Try Celery, it's a distributed job queue system.", "You can put all your task in the queue, and add work nodes as much as you want."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Celery", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ask.github.com/celery/getting-started/introduction.html"}]}, {"src": "http://i.stack.imgur.com/51UjA.jpg", "tag": "img", "senID": 1}, {"text": ["It should fit your needs."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]