[[{"text": ["Dive into Python has a section on parsing phone numbers"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://www.diveintopython.org/regular%5Fexpressions/phone%5Fnumbers.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://www.diveintopython.org/regular%5Fexpressions/phone%5Fnumbers.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.diveintopython.org/regular%5Fexpressions/phone%5Fnumbers.html"}]}], [{"text": ["I'm not american, but this works with russian phone numbers... maybe it applies to american ones too?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["take only the numbers with a regex.", "then find out if they appended the 1 (NO area code starts with 1).", "if it's there, remove it otherwise, format the 10 digits the way you want. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\npnumber = re.sub(\"[^0-9]\", \"\", input_number)\nif pnumber[0] == 1:\n    pnumber = pnumber[1:]#strip 1st char if it's a 1\n\n#insert the dashes\nif len(pnumber) == 10:\n    pnumber = \"%s-%s-%s\" % (pnumber[:3],pnumber[3:6],pnumber[6:])\nelse:\n    #throw error\n</code>\n</pre>\n", "senID": 1}], [{"text": ["After a little preparation with string.maketrans, strings' translate method affords very fast and simple operation.", "I'm giving Python 2 code for plain strings (Python 3, and Unicode strings in Python 2, are a bit different -- ask if that's what you need):"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "string.maketrans", "tag": "a", "pos": 0, "childList": [{"text": "string.maketrans", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/string.html?highlight=maketrans#string.maketrans"}, {"text": "string.maketrans", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "translate", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/string.html?highlight=maketrans#string.translate"}]}, {"text": ["The preparation (do once and for all, e.g.", "at module load time):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import string\n&gt;&gt;&gt; allchars = string.maketrans('', '')\n&gt;&gt;&gt; nondigits = allchars.translate(allchars, string.digits)\n</code>\n</pre>\n", "senID": 2}, {"text": ["The execution (turn any suitable string into the property formatted number):"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x='1555-555-5555'\n&gt;&gt;&gt; y=(x.translate(allchars, nondigits)).lstrip('1')\n&gt;&gt;&gt; assert len(y) == 10\n&gt;&gt;&gt; '%s-%s-%s' % (y[:3], y[3:6], y[6:])\n'555-555-5555\n</code>\n</pre>\n", "senID": 4}, {"text": ["Of course, you'll need to decide what to do when len(y) does not equal 10 (just raise an exception as I'm doing here, or, what else).", "But, this would be needed for any other form of processing (regex or whatever) just as well.", "The translate approach is really really fast and simple!-)"], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "len(y)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "not", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}, {"text": "translate", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"code": "<pre>\n<code>\n def extractNumber(s):\n    \"\"\"take a string phone number and extract it to the legal string\"\"\"\n\n    target = \"\"\n    for char in s:\n        try:\n            target += int(s)\n        except ValueError:\n            target += '-'\n\n    return target\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Decide which formats you want to recognize, then create a regular expression matching each one grouping the different parts of the number (like area code, prefix etc).", "Finally use a substitution to generate the canonical output you desire."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["to match"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n xxx-xxx-xxxx   -&gt; \\d{3}-\\d{3}-\\d{4}\n(xxx) xxx-xxxx -&gt; \\(\\d{3}\\) \\d{3}-\\d{4}\n1-xxx-xxx-xxx  -&gt; 1-\\d{3}-\\d{3}-\\d{4}\n</code>\n</pre>\n", "senID": 3}, {"text": ["This ignores rules that restrict prefix and area code (the US doesn't allow area codes or prefixes that being with 0 or 1).", "You could try and be super smart and create one regular expression that matches everything but you will end up with a jumbled mess that is impossible to modify instead you should OR the patterns together to make them easier to modify in the future.  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["basic idea:  "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n pattern = re.compile(r'\\d{3}-\\d{3}-\\d{4}|\\(\\d{3}\\) \\d{3}-\\d{4}|1-\\d{3}-\\d{3}-\\d{4}')\n</code>\n</pre>\n", "senID": 6}, {"text": ["with grouping added for canonical output  "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n pattern = re.compile(r'(\\d{3})-(\\d{3})-(\\d{4})|\\((\\d{3})\\) (\\d{3})-(\\d{4})|1-(\\d{3})-(\\d{3})-(\\d{4})')\n</code>\n</pre>\n", "senID": 8}, {"text": ["then just run that against your inputs and for each phone number input you will have 3 matching groups, one for the area code, one for the prefix, and one for the suffix which you can output however you want.", "You need a basic understanding of regular expressions, but it shouldn't be too hard."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}]]