[[{"text": ["(I originally thought) you're not going to speed it up a lot without breaking out to C (like numpy or scipy) or changing what you compute.", "But here's how I'd try that, anyway:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import imap\nfrom math import sqrt\nfrom operator import mul\n\ndef cosine_distance(a, b):\n    assert len(a) == len(b)\n    return 1 - (sum(imap(mul, a, b))\n                / sqrt(sum(imap(mul, a, a))\n                       * sum(imap(mul, b, b))))\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's roughly twice as fast in Python 2.6 with 500k-element arrays.", "(After changing map to imap, following Jarret Hardie."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here's a tweaked version of the original poster's revised code:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip\n\ndef cosine_distance(a, b):\n    assert len(a) == len(b)\n    ab_sum, a_sum, b_sum = 0, 0, 0\n    for ai, bi in izip(a, b):\n        ab_sum += ai * bi\n        a_sum += ai * ai\n        b_sum += bi * bi\n    return 1 - ab_sum / sqrt(a_sum * b_sum)\n</code>\n</pre>\n", "senID": 4}, {"text": ["It's ugly, but it does come out faster.", "."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Edit: And try Psyco!", "It speeds up the final version by another factor of 4.", "How could I forget?"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "Psyco", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://psyco.sourceforge.net/"}]}], [{"text": ["If you can use SciPy, you can use cosine from spatial.distance:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "cosine", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "spatial.distance", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["http://docs.scipy.org/doc/scipy/reference/spatial.distance.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.scipy.org/doc/scipy/reference/spatial.distance.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/scipy/reference/spatial.distance.html"}]}, {"text": ["If you can't use SciPy, you could try to obtain a small speedup by rewriting your Python (EDIT: but it didn't work out like I thought it would, see below)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip\nfrom math import sqrt\n\ndef cosine_distance(a, b):\n    if len(a) != len(b):\n        raise ValueError, \"a and b must be same length\"\n    numerator = sum(tup[0] * tup[1] for tup in izip(a,b))\n    denoma = sum(avalue ** 2 for avalue in a)\n    denomb = sum(bvalue ** 2 for bvalue in b)\n    result = 1 - numerator / (sqrt(denoma)*sqrt(denomb))\n    return result\n</code>\n</pre>\n", "senID": 3}, {"text": ["It is better to raise an exception when the lengths of a and b are mismatched."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["By using generator expressions inside of calls to sum() you can calculate your values with most of the work being done by the C code inside of Python.", "This should be faster than using a for loop."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "sum()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "for", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["I haven't timed this so I can't guess how much faster it might be.", "But the SciPy code is almost certainly written in C or C++ and it should be about as fast as you can get."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["If you are doing bioinformatics in Python, you really should be using SciPy anyway."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["EDIT: Darius Bacon timed my code and found it slower.", "So I timed my code and... yes, it is slower.", "The lesson for all: when you are trying to speed things up, don't guess, measure."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["I am baffled as to why my attempt to put more work on the C internals of Python is slower.", "I tried it for lists of length 1000 and it was still slower."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["I can't spend any more time on trying to hack the Python cleverly.", "If you need more speed, I suggest you try SciPy."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["EDIT: I just tested by hand, without timeit.", "I find that for short a and b, the old code is faster; for long a and b, the new code is faster; in both cases the difference is not large.", "(I'm now wondering if I can trust timeit on my Windows computer; I want to try this test again on Linux.", ")  I wouldn't change working code to try to get it faster.", "And one more time I urge you to try SciPy.", ":-)"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["No need to take abs() of a[i] and b[i] if you're squaring it."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "abs()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a[i]", "childNum": 0, "tag": "code", "childList": []}, {"text": "b[i]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Store a[i] and b[i] in temporary variables, to avoid doing the indexing more than once.", "Maybe the compiler can optimize this, but maybe not."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "a[i]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "b[i]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Check into the **2 operator.", "Is it simplifying it into a multiply, or is it using a general power function (log - multiply by 2 - antilog)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "**2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Don't do sqrt twice (though the cost of that is small).", "Do sqrt(denoma * denomb)."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "sqrt(denoma * denomb)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["This is faster for arrays of around 1000+ elements.   "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from numpy import array\ndef cosine_distance(a, b):\n    a=array(a)\n    b=array(b)\n    numerator=(a*b).sum()\n    denoma=(a*a).sum()\n    denomb=(b*b).sum()\n    result = 1 - numerator / sqrt(denoma*denomb)\n    return result\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Similar to Darius Bacon's answer, I've been toying with operator and itertools to produce a faster answer.", "The following seems to be 1/3 faster on a 500-item array according to timeit:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from math import sqrt\nfrom itertools import imap\nfrom operator import mul\n\ndef op_cosine(a, b):\n    dot_prod = sum(imap(mul, a, b))\n    a_veclen = sqrt(sum(i ** 2 for i in a))\n    b_veclen = sqrt(sum(i ** 2 for i in b))\n\n    return 1 - dot_prod / (a_veclen * b_veclen)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using the C code inside of SciPy wins big for long input arrays.", "Using simple and direct Python wins for short input arrays; Darius Bacon's izip()-based code benchmarked out best.", "Thus, the ultimate solution is to decide which one to use at runtime, based on the length of the input arrays:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "izip()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n from scipy.spatial.distance import cosine as scipy_cos_dist\n\nfrom itertools import izip\nfrom math import sqrt\n\ndef cosine_distance(a, b):\n    len_a = len(a)\n    assert len_a == len(b)\n    if len_a &gt; 200:  # 200 is a magic value found by benchmark\n        return scipy_cos_dist(a, b)\n    # function below is basically just Darius Bacon's code\n    ab_sum = a_sum = b_sum = 0\n    for ai, bi in izip(a, b):\n        ab_sum += ai * bi\n        a_sum += ai * ai\n        b_sum += bi * bi\n    return 1 - ab_sum / sqrt(a_sum * b_sum)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I made a test harness that tested the functions with different length inputs, and found that around length 200 the SciPy function started to win.", "The bigger the input arrays, the bigger it wins.", "For very short length arrays, say length 3, the simpler code wins.", "This function adds a tiny amount of overhead to decide which way to do it, then does it the best way."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In case you are interested, here is the test harness:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n from darius2 import cosine_distance as fn_darius2\nfn_darius2.__name__ = \"fn_darius2\"\n\nfrom ult import cosine_distance as fn_ult\nfn_ult.__name__ = \"fn_ult\"\n\nfrom scipy.spatial.distance import cosine as fn_scipy\nfn_scipy.__name__ = \"fn_scipy\"\n\nimport random\nimport time\n\nlst_fn = [fn_darius2, fn_scipy, fn_ult]\n\ndef run_test(fn, lst0, lst1, test_len):\n    start = time.time()\n    for _ in xrange(test_len):\n        fn(lst0, lst1)\n    end = time.time()\n    return end - start\n\nfor data_len in range(50, 500, 10):\n    a = [random.random() for _ in xrange(data_len)]\n    b = [random.random() for _ in xrange(data_len)]\n    print \"len(a) ==\", len(a)\n    test_len = 10**3\n    for fn in lst_fn:\n        n = fn.__name__\n        r = fn(a, b)\n        t = run_test(fn, a, b, test_len)\n        print \"%s:\\t%f seconds, result %f\" % (n, t, r)\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n def cd(a,b):\n    if(len(a)!=len(b)):\n        raise ValueError, \"a and b must be the same length\"\n    rn = range(len(a))\n    adb = sum([a[k]*b[k] for k in rn])\n    nma = sqrt(sum([a[k]*a[k] for k in rn]))\n    nmb = sqrt(sum([b[k]*b[k] for k in rn]))\n\n    result = 1 - adb / (nma*nmb)\n    return result\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Your updated solution still has two square roots.", "You can reduce this to one by replacing the sqrt line with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A multiply is typically quite a bit quicker than a sqrt.", "It might not seem much as it is only called once in the function, but it sounds like you are calculating a lot of cosine distances, so the improvement will add up."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Your code looks like it should be ripe for vector optimizations.", "So if cross-platofrm support is not an issue and you want to speed it even further, you could code the cosine distance code in C and make sure your compiler is aggressively vectorizing the resulting code (even Pentium II is capable of some floating point vectorisation)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]