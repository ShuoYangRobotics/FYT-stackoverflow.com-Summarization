[[{"text": ["Do you have an application that is running too slow and you provided it to find that a line like this snippet is causing it to be slow?", "Bottlenecks occur at unexpected places."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The current snippet traverses the string 5 times, doing one thing each time.", "You are suggesting traversing it once, probably doing doing five things each time (or at least doing something each time).", "It isn't clear that this will automatically do a better job to me.", "Currently the algorithm used is O(n*m) (assuming the length of the string is longer than the stuff in the rules), where n is the length of the string and m is the number of substitution rules.", "You could, I think, reduce the algorithmic complexity to something like O(n*log(m)) and in the specific case we're in\u2014where the original things are all only one character (but not in the case of multiple calls to replace in general)\u2014O(n), but this doesn't matter since m is 5 but n is unbounded. "], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "replace", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "m is 5", "childNum": 0, "tag": "em", "childList": []}, {"text": "n is unbounded", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["If m is held constant, then, the complexity of both solutions really goes to O(n).", "It is not clear to me that it is going to be a worthy task to try to turn five simple passes into one complex one, the actual time of which I cannot guess at the current moment.", "If there was something about it that could make it scale better, I would have thought it was much more worthwhile task."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Doing everything on one pass rather than consecutive passes also demands questions be answered about what to do about conflicting rules and how they are applied.", "The resolution to these questions is clear with a chain of replace."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "replace", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["How about we just test various ways of doing this and see which comes out faster (assuming we are only caring about the fastest way to do it)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def escape1(input):\n        return input.replace('&amp;', '&amp;amp;').replace('&lt;', '&amp;lt;').replace('&gt;', '&amp;gt;').replace(\"'\", '&amp;#39;').replace('\"', '&amp;quot;')\n\ntranslation_table = {\n    '&amp;': '&amp;amp;',\n    '&lt;': '&amp;lt;',\n    '&gt;': '&amp;gt;',\n    \"'\": '&amp;#39;',\n    '\"': '&amp;quot;',\n}\n\ndef escape2(input):\n        return ''.join(translation_table.get(char, char) for char in input)\n\nimport re\n_escape3_re = re.compile(r'[&amp;&lt;&gt;\\'\"]')\ndef _escape3_repl(x):\n    s = x.group(0)\n    return translation_table.get(s, s)\ndef escape3(x):\n    return _escape3_re.sub(_escape3_repl, x)\n\ndef escape4(x):\n    return unicode(x).translate(translation_table)\n\ntest_strings = (\n    'Nothing in there.',\n    '&lt;this is=\"not\" a=\"tag\" /&gt;',\n    'Something &amp; Something else',\n    'This one is pretty long. ' * 50\n)\n\nimport time\n\nfor test_i, test_string in enumerate(test_strings):\n    print repr(test_string)\n    for func in escape1, escape2, escape3, escape4:\n        start_time = time.time()\n        for i in xrange(1000):\n            x = func(test_string)\n        print '\\t%s done in %.3fms' % (func.__name__, (time.time() - start_time))\n    print\n</code>\n</pre>\n", "senID": 1}, {"text": ["Running this gives you:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 'Nothing in there.'\n    escape1 done in 0.002ms\n    escape2 done in 0.009ms\n    escape3 done in 0.001ms\n    escape4 done in 0.005ms\n\n'&lt;this is=\"not\" a=\"tag\" /&gt;'\n    escape1 done in 0.002ms\n    escape2 done in 0.012ms\n    escape3 done in 0.009ms\n    escape4 done in 0.007ms\n\n'Something &amp; Something else'\n    escape1 done in 0.002ms\n    escape2 done in 0.012ms\n    escape3 done in 0.003ms\n    escape4 done in 0.007ms\n\n'This one is pretty long. &lt;snip&gt;'\n    escape1 done in 0.008ms\n    escape2 done in 0.386ms\n    escape3 done in 0.011ms\n    escape4 done in 0.310ms\n</code>\n</pre>\n", "senID": 3}, {"text": ["Looks like just replacing them one after another goes the fastest."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Edit: Running the tests again with 1000000 iterations gives the following for the first three strings (the fourth would take too long on my machine for me to wait =P):"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n 'Nothing in there.'\n    escape1 done in 0.001ms\n    escape2 done in 0.008ms\n    escape3 done in 0.002ms\n    escape4 done in 0.005ms\n\n'&lt;this is=\"not\" a=\"tag\" /&gt;'\n    escape1 done in 0.002ms\n    escape2 done in 0.011ms\n    escape3 done in 0.009ms\n    escape4 done in 0.007ms\n\n'Something &amp; Something else'\n    escape1 done in 0.002ms\n    escape2 done in 0.011ms\n    escape3 done in 0.003ms\n    escape4 done in 0.007ms\n</code>\n</pre>\n", "senID": 6}, {"text": ["The numbers are pretty much the same.", "In the first case they are actually even more consistent as the direct string replacement is fastest now."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["I prefer something clean like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n substitutions = [\n    ('&lt;', '&amp;lt;'),\n    ('&gt;', '&amp;gt;'),\n    ...]\n\nfor search, replacement in substitutions:\n    string = string.replace(search, replacement)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["That's what Django does:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Django does", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.google.com/codesearch/p?hl=ja#Y-66DYr1B_Q/django/utils/html.py&q=lang%3apy%20escape%20django&sa=N&cd=1&ct=rc&l=30"}]}, {"code": "<pre>\n<code>\n def escape(html):\n    \"\"\"Returns the given HTML with ampersands, quotes and carets encoded.\"\"\"\n    return mark_safe(force_unicode(html).replace('&amp;', '&amp;amp;').replace('&lt;', '&amp;lt;').replace('&gt;', '&amp;gt;').replace('\"', '&amp;quot;').replace(\"'\", '&amp;#39;'))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["In accordance with bebraw's suggestion, here is what I ended up using (in a separate module, of course):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nclass Subs(object):\n    \"\"\"\n    A container holding strings to be searched for and replaced in\n    replace_multi().\n\n    Holds little relation to the sandwich.\n    \"\"\"\n    def __init__(self, needles_and_replacements):\n        \"\"\"\n        Returns a new instance of the Subs class, given a dictionary holding \n        the keys to be searched for and the values to be used as replacements.\n        \"\"\"\n        self.lookup = needles_and_replacements\n        self.regex = re.compile('|'.join(map(re.escape,\n                                             needles_and_replacements)))\n\ndef replace_multi(string, subs):\n    \"\"\"\n    Replaces given items in string efficiently in a single-pass.\n\n    \"string\" should be the string to be searched.\n    \"subs\" can be either:\n        A.) a dictionary containing as its keys the items to be\n            searched for and as its values the items to be replaced.\n        or B.) a pre-compiled instance of the Subs class from this module\n               (which may have slightly better performance if this is\n                called often).\n    \"\"\"\n    if not isinstance(subs, Subs): # Assume dictionary if not our class.\n        subs = Subs(subs)\n    lookup = subs.lookup\n    return subs.regex.sub(lambda match: lookup[match.group(0)], string)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Example usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def escape(string):\n    \"\"\"\n    Returns the given string with ampersands, quotes and angle \n    brackets encoded.\n    \"\"\"\n    # Note that ampersands must be escaped first; the rest can be escaped in \n    # any order.\n    escape.subs = Subs({'&lt;': '&amp;lt;', '&gt;': '&amp;gt;', \"'\": '&amp;#39;', '\"': '&amp;quot;'})\n    return replace_multi(string.replace('&amp;', '&amp;amp;'), escape.subs)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Much better :).", "Thanks for the help."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Edit"], "childNum": 0, "tag": "h2", "senID": 5, "childList": []}, {"text": ["Nevermind, Mike Graham was right.", "I benchmarked it and the replacement ends up actually being much slower."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "much", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Code:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n from urllib2 import urlopen\nimport timeit\n\ndef escape1(string):\n    \"\"\"\n    Returns the given string with ampersands, quotes and angle\n    brackets encoded.\n    \"\"\"\n    return string.replace('&amp;', '&amp;amp;').replace('&lt;', '&amp;lt;').replace('&gt;', '&amp;gt;').replace(\"'\", '&amp;#39;').replace('\"', '&amp;quot;')\n\ndef escape2(string):\n    \"\"\"\n    Returns the given string with ampersands, quotes and angle\n    brackets encoded.\n    \"\"\"\n    # Note that ampersands must be escaped first; the rest can be escaped in\n    # any order.\n    escape2.subs = Subs({'&lt;': '&amp;lt;', '&gt;': '&amp;gt;', \"'\": '&amp;#39;', '\"': '&amp;quot;'})\n    return replace_multi(string.replace('&amp;', '&amp;amp;'), escape2.subs)\n\n# An example test on the stackoverflow homepage.\nrequest = urlopen('http://stackoverflow.com')\ntest_string = request.read()\nrequest.close()\n\ntest1 = timeit.Timer('escape1(test_string)',\n                     setup='from __main__ import escape1, test_string')\ntest2 = timeit.Timer('escape2(test_string)',\n                     setup='from __main__ import escape2, test_string')\nprint 'multi-pass:', test1.timeit(2000)\nprint 'single-pass:', test2.timeit(2000)\n</code>\n</pre>\n", "senID": 8}, {"text": ["Output: "], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n multi-pass: 15.9897229671\nsingle-pass: 66.5422530174\n</code>\n</pre>\n", "senID": 10}, {"text": ["So much for that."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["Apparently it's pretty common to implement that via regex.", "You can find an example of this at ASPN and here."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "ASPN", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/81330"}, {"href": "http://rc98.net/multiple_replace", "text": "here", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["You can use reduce:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n reduce(lambda s,r: s.replace(*r),\n       [('&amp;', '&amp;amp;'),\n        ('&lt;', '&amp;lt;'),\n        ('&gt;', '&amp;gt;'),\n        (\"'\", '&amp;#39;'),\n        ('\"', '&amp;quot;')],\n       string)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you work with non-Unicode strings and Python &lt; 3.0, try an alternate translate method:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "translate", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # Python &lt; 3.0\nimport itertools\n\ndef escape(a_string):\n    replacer= dict( (chr(c),chr(c)) for c in xrange(256))\n    replacer.update(\n        {'&amp;': '&amp;amp;',\n         '&lt;': '&amp;lt;',\n         '&gt;': '&amp;gt;',\n         '\"': '&amp;quot;',\n         \"'\": '&amp;#39;'}\n    )\n    return ''.join(itertools.imap(replacer.__getitem__, a_string))\n\nif __name__ == \"__main__\":\n    print escape('''\"Hello\"&lt;i&gt; to George's friend&amp;co.''')\n\n$ python so2484156.py \n&amp;quot;Hello&amp;quot;&amp;lt;i&amp;gt; to George&amp;#39;s friend&amp;amp;co.\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is closer to a \"single scan\" of the input string, as per your wish."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT"], "childNum": 0, "tag": "h2", "senID": 3, "childList": []}, {"text": ["My intention was to create a unicode.translate equivalent that was not restricted to single-character replacements, so I came up with the answer above; I got a comment by user \"flow\" that was almost completely out of context, with a single correct point: the code above, as is, is intended to work with byte strings and not unicode strings.", "There is an obvious update (i.e.", "unichr() \u2026 xrange(sys.maxunicode+1)) which I strongly dislike, so I came up with another function that works on both unicode and byte strings, given that Python guarantees:"], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "unicode.translate", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "byte strings", "childNum": 0, "tag": "em", "pos": 2, "childList": []}, {"text": "unicode strings", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n all( (chr(i)==unichr(i) and hash(chr(i))==hash(unichr(i)))\n    for i in xrange(128)) is True\n</code>\n</pre>\n", "senID": 5}, {"text": ["The new function follows:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def escape(a_string):\n    replacer= {\n        '&amp;': '&amp;amp;',\n        '&lt;': '&amp;lt;',\n        '&gt;': '&amp;gt;',\n        '\"': '&amp;quot;',\n        \"'\": '&amp;#39;',\n    }\n    return ''.join(\n        itertools.starmap(\n            replacer.get, # .setdefault *might* be faster\n            itertools.izip(a_string, a_string)\n        )\n    )\n</code>\n</pre>\n", "senID": 7}, {"text": ["Notice the use of starmap with a sequence of tuples: for any character not in the replacer dict, return said character."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["ok so i sat down and did the math.", "pls do not get mad at me i answer specifically discussing \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5\u2019s solution, but this would be somewhat hard to shoehorn inside a comment, so let me do it this way.", "i will, in fact, also air some considerations that are relevant to the OP\u2019s question. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["first up, i have been discussing with \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5 the elegance, correctness, and viability of his approach.", "turns out it looks like the proposal, while it does use an (inherently unordered) dictionary as a register to store the substitution pairs, does in fact consistently return correct results, where i had claimed it wouldn\u2019t.", "this is because the call to itertools.starmap() in line 11, below, gets as its second argument an iterator over pairs of single characters/bytes (more on that later) that looks like [ ( 'h', 'h', ), ( 'e', 'e', ), ( 'l', 'l', ), ... ].", "these pairs of characters/bytes is what the first argument, replacer.get, is repeatedly called with.", "there is not a chance to run into a situation where first '&gt;' is transformed into '&amp;gt;' and then inadvertently again into '&amp;amp;gt;', because each character/byte is considered only once for substitution.", "so this part is in principle fine and algorithmically correct."], "childNum": 6, "tag": "p", "senID": 1, "childList": [{"text": "itertools.starmap()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "[ ( 'h', 'h', ), ( 'e', 'e', ), ( 'l', 'l', ), ... ]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "replacer.get", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "'&gt;'", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "'&amp;gt;'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "'&amp;amp;gt;'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["the next question is viability, and that would include a look at performance.", "if a vital task gets correctly completed in 0.01s using an awkward code but 1s using awesome code, then awkward might be considered preferable in practice (but only if the 1 second loss is in fact intolerable).", "here is the code i used for testing; it includes a number of different implementations.", "it is written in python 3.1 so we can use unicode greek letters for identifiers which in itself is awesome (zip in py3k returns the same as itertools.izip in py2):"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "itertools.izip", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import itertools                                                                  #01\n                                                                                  #02\n_replacements = {                                                                 #03\n  '&amp;': '&amp;amp;',                                                                   #04\n  '&lt;': '&amp;lt;',                                                                    #05\n  '&gt;': '&amp;gt;',                                                                    #06\n  '\"': '&amp;quot;',                                                                  #07\n  \"'\": '&amp;#39;', }                                                                 #08\n                                                                                  #09\ndef escape_\u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5( a_string ):                                                  #10\n  return ''.join(                                                                 #11\n    itertools.starmap(                                                            #12\n      _replacements.get,                                                          #13\n      zip( a_string, a_string ) ) )                                               #14\n                                                                                  #15\ndef escape_SIMPLE( text ):                                                        #16\n  return ''.join( _replacements.get( chr, chr ) for chr in text )                 #17\n                                                                                  #18\ndef escape_SIMPLE_optimized( text ):                                              #19\n  get = _replacements.get                                                         #20\n  return ''.join( get( chr, chr ) for chr in text )                               #21\n                                                                                  #22\ndef escape_TRADITIONAL( text ):                                                   #23\n  return text.replace('&amp;', '&amp;amp;').replace('&lt;', '&amp;lt;').replace('&gt;', '&amp;gt;')\\    #24\n    .replace(\"'\", '&amp;#39;').replace('\"', '&amp;quot;')                                 #25\n</code>\n</pre>\n", "senID": 3}, {"text": ["these are the timing results:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n escaping with SIMPLE            took 5.74664253sec for 100000 items\nescaping with SIMPLE_optimized  took 5.11457801sec for 100000 items\nescaping TRADITIONAL in-situ    took 0.57543013sec for 100000 items\nescaping with TRADITIONAL       took 0.62347413sec for 100000 items\nescaping a la \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5          took 2.66592320sec for 100000 items\n</code>\n</pre>\n", "senID": 5}, {"text": ["turns out the original poster\u2019s concern that the \u2018traditional\u2019 method gets \u2018ugly quickly and appears to have poor algorithmic performance\u2019 appears partially unwarranted when put into this context.", "it actually performs best; when stashed away into a function call, we do get to see a 8% performance penalty (\u2018calling methods is expensive\u2019, but in general you should still do it).", "in comparison, \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5\u2019s implementation takes around 5 times as long as the traditional method, which, given it\u2019s higher complexity that has to compete with python\u2019s long-honed, optimized string methods is no surprise. "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["there is yet another algorithm here, the SIMPLE one.", "as far as i can see, this very much does exactly what \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5\u2019s method does: it iterates over the characters/bytes in the text and performs a lookup for each, then joins all the characters/bytes together and returns the resulting escaped text.", "you can see that where one way to do that involves a fairly lengthy and myterious formulation, the SIMPLE implementation is actually understandable at a glance. "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["what really trips me up here, though, is how badly the SIMPLE approach is in performance: it is around 10 times as slow as the traditional one, and also twice as slow as \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5\u2019s method.", "i am completely at a loss here, maybe someone can come up with an idea why this should be so.", "it uses only the most basic building blocks of python and works with two implicit iterations, so it avoids to build throw-away lists and everything, but it still slow, and i don\u2019t know why."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["let me conclude this code review with a remark on the merit of \u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5\u2019s solution.", "i have made it sufficiently clear i find the code hard to read and too overblown for the task at hand.", "more critical than that, however, i find the way he treats characters and makes sure that for a given small range of characters they will behave in a byte-like fashion a little irritating.", "sure it works for the task at hand, but as soon as i iterate e.g.", "over the bytestring '\u03a4\u0396\u03a9\u03a4\u0396\u0399\u039f\u03a5' what i do is iterate over adjacent bytes representing single characters.", "in most situations this is exactly what you should avoid; this is precisely the reason why in py3k \u2018strings\u2019 are now the \u2018unicode objects\u2019 of old, and the \u2018strings\u2019 of old have become \u2018bytes\u2019 and \u2018bytearray\u2019.", "if i was to nominate the one feature of py3k that could warrant a possibly expensive migration of code from the 2 series to the 3 series, it would be this single property of py3k.", "98% of all my encoding issues have just dissolved ever since, period, and there is no clever hack that could have me seriously doubt my move.", "said algorithm is not \u2018conceptually 8bit-clean and unicode safe\u2019, which to me is a seriously shortcome, given this is 2010."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}]]