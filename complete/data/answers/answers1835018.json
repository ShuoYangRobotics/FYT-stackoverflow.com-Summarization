[[{"text": ["I think"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n assert not isinstance(lst, basestring)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Is actually what you want, otherwise you'll miss out on a lot of things which act like lists, but aren't subclasses of list or tuple."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Remember that in Python we want to use \"duck typing\".", "So, anything that acts like a list can be treated as a list.", "So, don't check for the type of a list, just see if it acts like a list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["But strings act like a list too, and often that is not what we want.", "There are times when it is even a problem!", "So, check explicitly for a string, but then use duck typing."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here is a function I wrote for fun.", "It is a special version of repr() that prints any sequence in angle brackets ('&lt;', '>')."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "repr()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def srepr(arg):\n    if isinstance(arg, basestring): # Python 3: isinstance(arg, str)\n        return repr(arg)\n    try:\n        return '&lt;' + \", \".join(srepr(x) for x in arg) + '&gt;'\n    except TypeError: # catch when for loop fails\n        return repr(arg) # not a sequence so just return repr\n</code>\n</pre>\n", "senID": 3}, {"text": ["This is clean and elegant, overall.", "But what's that isinstance() check doing there?", "That's kind of a hack.", "But it is essential."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "isinstance()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This function calls itself recursively on anything that acts like a list.", "If we didn't handle the string specially, then it would be treated like a list, and split up one character at a time.", "But then the recursive call would try to treat each character as a list -- and it would work!", "Even a one-character string works as a list!", "The function would keep on calling itself recursively until stack overflow."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Functions like this one, that depend on each recursive call breaking down the work to be done, have to special-case strings--because you can't break down a string below the level of a one-character string, and even a one-character string acts like a list."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Note: the try/except is the cleanest way to express our intentions.", "But if this code were somehow time-critical, we might want to replace it with some sort of test to see if arg is a sequence.", "Rather than testing the type, we should probably test behaviors.", "If it has a .strip() method, it's a string, so don't consider it a sequence; otherwise, if it is indexable or iterable, it's a sequence:"], "childNum": 4, "tag": "p", "senID": 7, "childList": [{"text": "try", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "except", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "arg", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": ".strip()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"code": "<pre>\n<code>\n def is_sequence(arg):\n    return (not hasattr(arg, \"strip\") and\n            hasattr(arg, \"__getitem__\") or\n            hasattr(arg, \"__iter__\"))\n\ndef srepr(arg):\n    if is_sequence(arg):\n        return '&lt;' + \", \".join(srepr(x) for x in arg) + '&gt;'\n    return repr(arg)\n</code>\n</pre>\n", "senID": 8}, {"text": ["EDIT: I originally wrote the above with a check for __getslice__() but I noticed that in the collections module documentation, the interesting method is __getitem__(); this makes sense, that's how you index an object.", "That seems more fundamental than __getslice__() so I changed the above."], "childNum": 4, "tag": "p", "senID": 9, "childList": [{"text": "__getslice__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "collections", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__getitem__()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "__getslice__()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Also check out the types module:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "types", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import types\n\nassert isinstance(x, types.ListType)\nassert not isinstance(x, types.StringTypes)\n</code>\n</pre>\n", "senID": 1}, {"text": ["and so on..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Generally speaking, the fact that a function which iterates over an object works on strings as well as tuples and lists is more feature than bug.", "You certainly can use isinstance or duck typing to check an argument, but why should you?"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "can", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "isinstance", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["That sounds like a rhetorical question, but it isn't.", "The answer to \"why should I check the argument's type?", "\" is probably going to suggest a solution to the real problem, not the perceived problem.", "Why is it a bug when a string is passed to the function?", "Also:  if it's a bug when a string is passed to this function, is it also a bug if some other non-list/tuple iterable is passed to it?", "Why, or why not?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["I think that the most common answer to the question is likely to be that developers who write f(\"abc\") are expecting the function to behave as though they'd written f([\"abc\"]).", "There are probably circumstances where it makes more sense to protect developers from themselves than it does to support the use case of iterating across the characters in a string.", "But I'd think long and hard about it first."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "f(\"abc\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "f([\"abc\"])", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["The str object doesn't have an __iter__ attribute"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "str", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__iter__", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; hasattr('', '__iter__')\nFalse\n</code>\n</pre>\n", "senID": 1}, {"text": ["so you can do a check"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n assert hasattr(x, '__iter__')\n</code>\n</pre>\n", "senID": 3}, {"text": ["and this will also raise a nice AssertionError for any other non-iterable object too."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "AssertionError", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Edit:\nAs Tim mentions in the comments, this will only work in python 2.x, not 3.x"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Edit:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Python with PHP flavor:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def is_array(var):\n    return isinstance(var, (list, tuple))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I tend to do this (if I really, really had to):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i in some_var:\n   if type(i) == type(list()):\n       #do something with a list\n   elif type(i) == type(tuple()):\n       #do something with a tuple\n   elif type(i) == type(str()):\n       #here's your string\n</code>\n</pre>\n", "senID": 1}]]