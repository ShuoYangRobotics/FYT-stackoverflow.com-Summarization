[[{"text": ["Are you familiar with other functional languages?", "i.e.", "are you trying to learn how python does functional programming, or are you trying to learn about functional programming and using python as the vehicle?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also, do you understand list comprehensions?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n map(f, sequence)\n</code>\n</pre>\n", "senID": 2}, {"text": ["is directly equivalent (*) to:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n [f(x) for x in sequence]\n</code>\n</pre>\n", "senID": 4}, {"text": ["In fact, I think map() was once slated for removal from python 3.0 as being redundant (that didn't happen)."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "map()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n map(f, sequence1, sequence2)\n</code>\n</pre>\n", "senID": 6}, {"text": ["is mostly equivalent to:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n [f(x1, x2) for x1, x2 in zip(sequence1, sequence2)]\n</code>\n</pre>\n", "senID": 8}, {"text": ["(there is a difference in how it handles the case where the sequences are of different length.", "As you saw, map() fills in None when one of the sequences runs out, whereas zip() stops when the shortest sequence stops)"], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "map()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "zip()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["So, to address your specific question, you're trying to produce the result:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n foos[0], bars\nfoos[1], bars\nfoos[2], bars\n# etc.\n</code>\n</pre>\n", "senID": 11}, {"text": ["You could do this by writing a function that takes a single argument and prints it, followed by bars:"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n def maptest(x):\n     print x, bars\nmap(maptest, foos)\n</code>\n</pre>\n", "senID": 13}, {"text": ["Alternatively, you could create a list that looks like this:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n [bars, bars, bars, ] # etc.\n</code>\n</pre>\n", "senID": 15}, {"text": ["and use your original maptest:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n def maptest(x, y):\n    print x, y\n</code>\n</pre>\n", "senID": 17}, {"text": ["One way to do this would be to explicitely build the list beforehand:"], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"code": "<pre>\n<code>\n barses = [bars] * len(foos)\nmap(maptest, foos, barses)\n</code>\n</pre>\n", "senID": 19}, {"text": ["Alternatively, you could pull in the itertools module.", "itertools contains many clever functions that help you do functional-style lazy-evaluation programming in python.", "In this case, we want itertools.repeat, which will output its argument indefinitely as you iterate over it.", "This last fact means that if you do:"], "childNum": 3, "tag": "p", "senID": 20, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "itertools.repeat", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n map(maptest, foos, itertools.repeat(bars))\n</code>\n</pre>\n", "senID": 21}, {"text": ["you will get endless output, since map() keeps going as long as one of the arguments is still producing output.", "However, itertools.imap is just like map(), but stops as soon as the shortest iterable stops."], "childNum": 3, "tag": "p", "senID": 22, "childList": [{"text": "map()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "itertools.imap", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "map()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n itertools.imap(maptest, foos, itertools.repeat(bars))\n</code>\n</pre>\n", "senID": 23}, {"text": ["Hope this helps :-)"], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"text": ["(*) It's a little different in python 3.0.", "There, map() essentially returns a generator expression."], "childNum": 0, "tag": "p", "senID": 25, "childList": []}], [{"text": ["Here's the solution you're looking for:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; foos = [1.0, 2.0, 3.0, 4.0, 5.0]\n&gt;&gt;&gt; bars = [1, 2, 3]\n&gt;&gt;&gt; [(x, bars) for x in foos]\n[(1.0, [1, 2, 3]), (2.0, [1, 2, 3]), (3.0, [1, 2, 3]), (4.0, [1, 2, 3]), (5.0, [\n1, 2, 3])]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'd recommend using a list comprehension (the [(x, bars) for x in foos] part) over using map as it avoids the overhead of a function call on every iteration (which can be very significant).", "If you're just going to use it in a for loop, you'll get better speeds by using a generator comprehension:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[(x, bars) for x in foos]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; y = ((x, bars) for x in foos)\n&gt;&gt;&gt; for z in y:\n...     print z\n...\n(1.0, [1, 2, 3])\n(2.0, [1, 2, 3])\n(3.0, [1, 2, 3])\n(4.0, [1, 2, 3])\n(5.0, [1, 2, 3])\n</code>\n</pre>\n", "senID": 3}, {"text": ["The difference is that the generator comprehension is lazily loaded."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "lazily loaded", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Lazy%5Floading"}]}, {"text": ["UPDATE  In response to this comment:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "UPDATE", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I suppose this is a valid point.", "There are two solutions to this that I can think of.", "The most efficient is probably something like this:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n tbars = tuple(bars)\n[(x, tbars) for x in foos]\n</code>\n</pre>\n", "senID": 7}, {"text": ["Since tuples are immutable, this will prevent bars from being modified through the results of this list comprehension (or generator comprehension if you go that route).", "If you really need to modify each and every one of the results, you can do this:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n from copy import copy\n[(x, copy(bars)) for x in foos]\n</code>\n</pre>\n", "senID": 9}, {"text": ["However, this can be a bit expensive both in terms of memory usage and in speed, so I'd recommend against it unless you really need to add to each one of them."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}], [{"text": ["The easiest way would be not to pass bars through the different functions, but to access it directly from maptest:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "bars", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "maptest", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n foos = [1.0,2.0,3.0,4.0,5.0]\nbars = [1,2,3]\n\ndef maptest(foo):\n    print foo, bars\n\nmap(maptest, foos)\n</code>\n</pre>\n", "senID": 1}, {"text": ["With your original maptest function you could also use a lambda function in map:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "maptest", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n map((lambda foo: maptest(foo, bars)), foos)\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import repeat\n&gt;&gt;&gt; for foo, bars in zip(foos, repeat(bars)):\n...     print foo, bars\n... \n1.0 [1, 2, 3]\n2.0 [1, 2, 3]\n3.0 [1, 2, 3]\n4.0 [1, 2, 3]\n5.0 [1, 2, 3]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Functional programming is about creating side-effect-free code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["map is a functional list transformation abstraction.", "You use it to take a sequence of something and turn it into a sequence of something else."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You are trying to use it as an iterator.", "Don't do that.", ":)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Here is an example of how you might use map to build the list you want.", "There are shorter solutions (I'd just use comprehensions), but this will help you understand what map does a bit better:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def my_transform_function(input):\n    return [input, [1, 2, 3]]\n\nnew_list = map(my_transform, input_list)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Notice at this point, you've only done a data manipulation.", "Now you can print it:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n for n,l in new_list:\n    print n, ll\n</code>\n</pre>\n", "senID": 6}, {"text": ["-- I'm not sure what you mean by 'without loops.", "'  fp isn't about avoiding loops (you can't examine every item in a list without visiting each one).", "It's about avoiding side-effects, thus writing fewer bugs."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"code": "<pre>\n<code>\n import itertools\n\nfoos=[1.0, 2.0, 3.0, 4.0, 5.0]\nbars=[1, 2, 3]\n\nprint zip(foos, itertools.cycle([bars]))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Here's an overview of the parameters to the map(function, *sequences) function:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "map(function, *sequences)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": ["function"], "childNum": 0, "tag": "code", "senID": 1, "childList": []}, {"text": ["sequences"], "childNum": 0, "tag": "code", "senID": 2, "childList": []}]}, {"text": ["It sounds like you're trying to iterate for some of function's parameters but keep others constant, and unfortunately map doesn't support that.", "I found an old proposal to add such a feature to Python, but the map construct is so clean and well-established that I doubt something like that will ever be implemented."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "function", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "map", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "http://mail.python.org/pipermail/python-dev/2003-February/033486.html", "text": "an old proposal", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Use a workaround like global variables or list comprehensions, as others have suggested."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Would this do it?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n foos = [1.0,2.0,3.0,4.0,5.0]\nbars = [1,2,3]\n\ndef maptest2(bar):\n  print bar\n\ndef maptest(foo):\n  print foo\n  map(maptest2, bars)\n\nmap(maptest, foos)\n</code>\n</pre>\n", "senID": 1}]]