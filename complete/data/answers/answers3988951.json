[[{"text": ["There's no way to tell from the URL what it's going to give you.", "Even if it ends in .pdf it could still give you HTML or anything it likes."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": ".pdf", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["You could do a HEAD request and look at the content-type, which, if the server isn't lying to you, will tell you if it's a PDF."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Alternatively you can download it and then work out whether what you got is a PDF."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["As has been said there is no way to tell content type from URL.", "But if you don't mind getting the headers for every URL you can do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n obj = urllib.urlopen(URL)\n\nheaders = obj.info()\nif headers['Content-Type'].find('pdf') != -1:\n   # we have pdf file, download whole\n...\n</code>\n</pre>\n", "senID": 1}, {"text": ["This way you won't have to download each URL just it's headers.", "It's still not exactly saving network traffic, but you won't get better than that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Also you should use mime-types instead of my crude find('pdf')."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["In this case, what you refer to as \"a document that's not explicitly referenced in a URL\" seems to be what is known as a \"redirect\".", "Basically, the server tells you that you have to get the document at another URL.", "Normally, python's urllib will automatically follow these redirects, so that you end up with the right file.", "(and - as others have already mentioned - you can check the response's mime-type header to see if it's a pdf)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, the server in question is doing something strange here.", "You request the url, and it redirects you to another url.", "You request the other url, and it redirects you again... to the same url!", "And again... And again... At some point, urllib decides that this is enough already, and will stop following the redirect, to avoid getting caught in an endless loop."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So how come you are able to get the pdf when you use your browser?", "Because apparently, the server will only serve the pdf if you have cookies enabled.", "(why?", "you have to ask the people responsible for the server...) If you don't have the cookie, it will just keep redirecting you forever."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["(check the urllib2 and cookielib modules to get support for cookies, this tutorial might help)"], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "urllib2", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/urllib2.html"}, {"href": "http://docs.python.org/library/cookielib.html", "text": "cookielib", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://www.voidspace.org.uk/python/articles/cookielib.shtml", "text": "this tutorial", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["At least, that is what I think is causing the problem.", "I haven't actually tried doing it with cookies yet.", "It could also be that the server is does not \"want\" to serve the pdf, because it detects you are not using a \"normal\" browser (in which case you would probably need to fiddle with the User-Agent header), but it would be a strange way of doing that.", "So my guess is that it is somewhere using a \"session cookie\", and in the case you haven't got one yet, keeps on trying to redirect."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["No.", "It is impossible to tell what kind of resource is referenced by a URL just by looking at it.", "It is totally up to the server to decide what he gives you when you request a certain URL."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Check the mimetype with the urllib.info() function.", "This might not be 100% accurate, it really depends on what the site returns as a Content-Type header.", "If it's well behaved it'll return the proper mime type."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "urllib.info()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["A PDF should return application/pdf, but that may not be the case."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Otherwise you might just have to download it and try it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You can't see it from the url directly.", "You could try to only download the header of the HTTP response and look for the Content-Type header.", "However, you have to trust the server on this - it could respond with a wrong Content-Type header not matching the data provided in the body."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]