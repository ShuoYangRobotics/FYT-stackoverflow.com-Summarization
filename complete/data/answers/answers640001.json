[[{"code": "<pre>\n<code>\n s/\\([^)]*\\)//\n</code>\n</pre>\n", "senID": 0}, {"text": ["So in Python, you'd do:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n re.sub(r'\\([^)]*\\)', '', filename)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I would use:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \\([^)]*\\)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If a path may contain parentheses then the r'\\(.", "*?\\)' regex is not enough:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "r'\\(.*?\\)'", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import os, re\n\ndef remove_parenthesized_chunks(path, safeext=True, safedir=True):\n    dirpath, basename = os.path.split(path) if safedir else ('', path)\n    name, ext = os.path.splitext(basename) if safeext else (basename, '')\n    name = re.sub(r'\\(.*?\\)', '', name)\n    return os.path.join(dirpath, name+ext)\n</code>\n</pre>\n", "senID": 1}, {"text": ["By default the function preserves parenthesized chunks in directory and extention parts of the path."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; f = remove_parenthesized_chunks\n&gt;&gt;&gt; f(\"Example_file_(extra_descriptor).ext\")\n'Example_file_.ext'\n&gt;&gt;&gt; path = r\"c:\\dir_(important)\\example(extra).ext(untouchable)\"\n&gt;&gt;&gt; f(path)\n'c:\\\\dir_(important)\\\\example.ext(untouchable)'\n&gt;&gt;&gt; f(path, safeext=False)\n'c:\\\\dir_(important)\\\\example.ext'\n&gt;&gt;&gt; f(path, safedir=False)\n'c:\\\\dir_\\\\example.ext(untouchable)'\n&gt;&gt;&gt; f(path, False, False)\n'c:\\\\dir_\\\\example.ext'\n&gt;&gt;&gt; f(r\"c:\\(extra)\\example(extra).ext\", safedir=False)\n'c:\\\\\\\\example.ext'\n</code>\n</pre>\n", "senID": 4}], [{"text": ["If you can stand to use sed (possibly execute from within your program, it'd be as simple as:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["sed 's/(.", "*)//g'"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["If you don't absolutely need to use a regex, useconsider using Perl's Text::Balanced to remove the parenthesis."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "use", "childNum": 0, "tag": "strike", "pos": 0, "childList": []}, {"href": "http://perldoc.perl.org/Text/Balanced.html", "text": "Text::Balanced", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n use Text::Balanced qw(extract_bracketed);\n\nmy ($extracted, $remainder, $prefix) = extract_bracketed( $filename, '()', '[^(]*' );\n\n{   no warnings 'uninitialized';\n\n    $filename = (defined $prefix or defined $remainder)\n                ? $prefix . $remainder\n                : $extracted;\n}\n</code>\n</pre>\n", "senID": 1}, {"text": ["You may be thinking, \"Why do all this when a regex does the trick in one line?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $filename =~ s/\\([^}]*\\)//;\n</code>\n</pre>\n", "senID": 3}, {"text": ["Text::Balanced handles nested parenthesis.", "So $filename = 'foo_(bar(baz)buz)).foo' will be extracted properly.", "The regex based solutions offered here will fail on this string.", "The one will stop at the first closing paren, and the other will eat them all."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "$filename = 'foo_(bar(baz)buz)).foo'", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["$filename =~ s/([^}]*)//;\n   # returns 'foo_buz)).foo'"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["$filename =~ s/(.", ")//;\n   # returns 'foo.foo'"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": ")//;\n   # returns 'foo", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["# text balanced example returns 'foo_).foo'"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["If either of the regex behaviors is acceptable, use a regex--but document the limitations and the assumptions being made."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; filename = \"Example_file_(extra_descriptor).ext\"\n&gt;&gt;&gt; p = re.compile(r'\\([^)]*\\)')\n&gt;&gt;&gt; re.sub(p, '', filename)\n'Example_file_.ext'\n</code>\n</pre>\n", "senID": 0}]]