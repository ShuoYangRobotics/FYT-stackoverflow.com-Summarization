[[{"text": ["Applying a multimethod to the array might make some sense.", "You switch the strategy to a more functional style in which you focus on a discrete piece of logic (i.e.", "the multimethod) instead of a discrete piece of data (i.e.", "the array objects). "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "multimethod", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Multiple_dispatch"}]}, {"text": ["In your shapes example, this prevents you from having to define and implement the Shape interface.", "(Yes, it's not a big deal here, but what if shape was one of several superclasses you wanted to extend?", "In Java, you're SOL at this point.", ") Instead, you implement a smart draw() multimethod that first examines the argument and then dispatches to the proper drawing functionality or error handling if the object isn't drawable."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Shape", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "draw()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}, {"text": ["Comparisons between functional and object-oriented styles are all over the place; here are a couple relevant questions that should provide a good start: Functional programming vs Object Oriented programming and Explaining functional programming to object-oriented programmers and less technical people."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Functional programming vs Object Oriented programming", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2078978/functional-programming-vs-object-oriented-programming"}, {"href": "http://stackoverflow.com/questions/2294053/explaining-functional-programming-to-object-oriented-programmers-and-less-technic", "text": "Explaining functional programming to object-oriented programmers and less technical people", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["As katrielalex wrote: There is no reason not to support heterogeneous lists.", "In fact, disallowing it would require static typing, and we're back to that old debate.", "But let's refrain from doing so and instead answer the \"why would you use that\" part..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["To be honest, it is not used that much -- if we make use of the exception in your last paragraph and choose a more liberal definition of \"implement the same interface\" than e.g.", "Java or C#.", "Nearly all of my iterable-crunching code expects all items to implement some interface.", "Of course it does, otheriwise it could do very little to it!"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "that", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Don't get me wrong, there are absolutely valid use cases - there's rarely a good reason to write a whole class for containing some data (and even if you add some callables, functional programming sometimes comes to the rescue).", "A dict would be a more common choice though, and namedtuple is very neat as well.", "But they are less common than you seem to think, and they are used with thought and discipline, not for cowboy coding."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "namedtuple", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html?highlight=namedtuple#collections.namedtuple"}]}, {"text": ["(Also, you \"User as nested list\" example is not a good one - since the inner lists are fixed-sized, you better use tuples and that makes it valid even in Haskell (type would be [(String, Integer)]))"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "User", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "[(String, Integer)]", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Yes, there is a very simple reason why you can do this in Python (and i assume the same reason in Ruby): "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["How would you check that a list is heterogenous?"], "childNum": 0, "tag": "h2", "senID": 1, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "It can't just compare the types directly because Python has duck typing.", "tag": "none", "senID": 2}, {"text": "If all the object have some common typeclass Python has no way to guess that either. ", "tag": "none", "senID": 3}, {"text": "It wouldn't make any sense to turn lists into the ", "tag": "none", "senID": 4}]}, {"text": ["There is simply no way to prevent you from creating a heterogenous list!"], "childNum": 0, "tag": "h2", "senID": 5, "childList": []}, {"text": ["No, I can't think of any.", "As you already mentioned in your question, if you use a heterogenous arrays you're just making things harder than they have to be."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["There is no reason not to support heterogeneous lists.", "It's a limitation for technical reasons, and we don't like those."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Not everything needs to be a class!"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In Python, a class is basically a souped up dictionary with some extra stuff anyway.", "So making a classUseris not necessarily any clearer than a dictionary{\"name\": ..., \"id\": ...}."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "In Python, a class is basically a souped up dictionary with some extra stuff anyway. So making a classUseris not necessarily any clearer than a dictionary{\"name\": ..., \"id\": ...}.", "childNum": 2, "tag": "sup", "pos": -1, "childList": [{"text": "User", "tag": "code"}, {"text": "{\"name\": ..., \"id\": ...}", "tag": "code"}]}, {"text": "User", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "{\"name\": ..., \"id\": ...}", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["There is nothing to stop you having a heterogeneous array in Java.", "It is considered poor programming style and using proper POJOs will be faster/more efficient than heterogeneous arrays in Java or any other language as the types of the \"fields\" are statically known and primitives can be used."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In Java you can"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n Object[][] array = {{\"John Smith\", 000}, {\"Smith John\", 001}, ...};\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Eterogenous lists are very useful.", "For instance, to make the game of snake, I can have a list of blocks like this:\n[[x, y, 'down'], [x1, y1, 'down']]\ninstead of a class for the blocks, and I can access faster to every element."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Here is a simple answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Everything extends java.lang.Object... and that's plenty.", "There is no reason not to have Object[] and put anything you like in.", "Object[] are exceptionally useful in any middleware like persistence layer."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "not", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}]]