[[{"code": "<pre>\n<code>\n def removeNonAscii(s): return \"\".join(filter(lambda x: ord(x)&lt;128, s))\n</code>\n</pre>\n", "senID": 0}, {"text": ["edit: my first impulse is always to use a filter, but the generator expression is more memory efficient (and shorter)..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def removeNonAscii(s): return \"\".join(i for i in s if ord(i)&lt;128)\n</code>\n</pre>\n", "senID": 2}, {"text": ["Keep in mind that this is guaranteed to work with UTF-8 encoding (because all bytes in multi-byte characters have the highest bit set to 1)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"tag": "ul", "num": 1, "lis": [{"text": "You need a declaration at the top of each source file that uses Unicode literals.", "tag": "none", "senID": 0}]}, {"text": ["See:\nhttp://docs.python.org/tutorial/interpreter.html#source-code-encoding"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/tutorial/interpreter.html#source-code-encoding", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/interpreter.html#source-code-encoding"}]}, {"text": ["Assuming utf8, this would go at the top:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # -*- coding: utf-8 -*-\n</code>\n</pre>\n", "senID": 3}, {"tag": "ul", "num": 4, "lis": [{"text": ["The source file must be saved using the correct encoding in your text editor as well."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The literal must have a u before it, as in s.replace(u\"\u00c2 \", \"\")"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "u", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "s.replace(u\"\u00c2 \", \"\")", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The string s must be a unicode string as well.", "BeautifulSoup might not be returning unicode here.", "Try s = s.decode('utf-8')"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "s = s.decode('utf-8')", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["string.replace returns a new string and does not edit in place, so make sure you're using the return value as well"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "string.replace", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; unicode_string = u\"hello a\u00e5b\u00e4c\u00f6\"\n&gt;&gt;&gt; unicode_string.encode(\"ascii\", \"ignore\")\n'hello abc'\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n #!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\ns = u\"6\u00c2 918\u00c2 417\u00c2 712\"\ns = s.replace(u\"\u00c2\", \"\") \nprint s\n</code>\n</pre>\n", "senID": 0}, {"text": ["This will print out 6 918 417 712"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "6 918 417 712", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Using Regex:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nstrip_unicode = re.compile(\"([^-_a-zA-Z0-9!@#%&amp;=,/'\\\";:~`\\$\\^\\*\\(\\)\\+\\[\\]\\.\\{\\}\\|\\?\\&lt;\\&gt;\\\\]+|[^\\s]+)\")\nprint strip_unicode.sub('', u'6\u00c2 918\u00c2 417\u00c2 712')\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n s.replace(u'\u00c2 ', '')              # u before string is important\n</code>\n</pre>\n", "senID": 0}, {"text": ["and make your .py file unicode."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": ".py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This is a dirty hack, but may work."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n s2 = \"\"\nfor i in s:\n    if ord(i) &lt; 128:\n        s2 += i\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I know it's an old thread, but I felt compelled to mention the translate method, which is always a good way to replace all character codes above 128 (or other if necessary)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Usage : str.translate(table[, deletechars])"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "Usage", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "translate", "childNum": 0, "tag": "strong", "childList": []}, {"text": "table[, deletechars]", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; trans_table = ''.join( [chr(i) for i in range(128)] + [' '] * 128 )\n\n&gt;&gt;&gt; 'R\u00e9sultat'.translate(trans_table)\n'R sultat'\n&gt;&gt;&gt; '6\u00c2 918\u00c2 417\u00c2 712'.translate(trans_table)\n'6  918  417  712'\n</code>\n</pre>\n", "senID": 2}, {"text": ["Starting with Python 2.6, you can also set the table to None, and use deletechars to delete the characters you don't want as in the examples shown in the standard docs at http://docs.python.org/library/stdtypes.html."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "Python 2.6", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "deletechars", "childNum": 0, "tag": "em", "childList": []}, {"href": "http://docs.python.org/library/stdtypes.html", "text": "http://docs.python.org/library/stdtypes.html", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["With unicode strings, the translation table is not a 256-character string but a dict with the ord() of relevant characters as keys.", "But anyway getting a proper ascii string from a unicode string is simple enough, using the method mentioned by truppo above, namely : unicode_string.encode(\"ascii\", \"ignore\")"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["As a summary, if for some reason you absolutely need to get an ascii string (for instance, when you raise a standard exception with raise Exception, ascii_message ), you can use the following function:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "raise Exception, ascii_message", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n trans_table = ''.join( [chr(i) for i in range(128)] + ['?'] * 128 )\ndef ascii(s):\n    if isinstance(s, unicode):\n        return s.encode('ascii', 'replace')\n    else:\n        return s.translate(trans_table)\n</code>\n</pre>\n", "senID": 6}, {"text": ["The good thing with translate is that you can actually convert accented characters to relevant non-accented ascii characters instead of simply deleting them or replacing them by '?'.", "This is often useful, for instance for indexing purposes."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "relevant", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["For what it was worth, my character set was utf-8 and I had included the classic \"# -- coding: utf-8 --\" line."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "- coding: utf-8 -", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["However, I discovered that I didn't have Universal Newlines when reading this data from a webpage.", "My text had two words, separated by \"\\r\\n\".", "I was only splitting on the \\n and replacing the \"\\n\".", "Once I looped through and saw the character set in question, I realized the mistake."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So, it could also be within the ASCII character set, but a character that you didn't expect."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Way too late for an answer, but the original string was in UTF-8 and '\\xc2\\xa0' is UTF-8 for NO-BREAK SPACE.", "Simply decode the original string as s.decode('utf-8') (\\xa0 displays as a space when decoded incorrectly as Windows-1252 or latin-1:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "s.decode('utf-8')", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n s = b'6\\xc2\\xa0918\\xc2\\xa0417\\xc2\\xa0712'\nprint(s.decode('latin-1')) # incorrectly decoded\nu = s.decode('utf8') # correctly decoded\nprint(u)\nprint(u.replace('\\N{NO-BREAK SPACE}','_'))\nprint(u.replace('\\xa0','-')) # \\xa0 is Unicode for NO-BREAK SPACE\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n<code>\n 6\u00c2\u00a0918\u00c2\u00a0417\u00c2\u00a0712\n6\u00a0918\u00a0417\u00a0712\n6_918_417_712\n6-918-417-712\n</code>\n</pre>\n", "senID": 2}]]