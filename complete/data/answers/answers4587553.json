[[{"text": ["Wow.", "This is the messiest code I've seen in a while.", "You realize that when you add a row, you're just adding the same dictionary that every other column has."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def __init__(self):\n    self.rows = {}\n    self.cols = {}\ndef addrow(self, name):\n    self.rows[name] = self.cols\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think you meant"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def addrow(self, name):\n    self.rows[name] = {}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Every value in self.rows is assigned self.cols, so they share the same dictionary as a key.", "If you modify self.rows[x], then you also modify self.rows[y], because they are the same object.", "Similarly, if you then re-add self.cols as the value for self.rows[z], it has all the same contents, because it's still the same object."], "childNum": 8, "tag": "p", "senID": 0, "childList": [{"text": "self.rows", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self.cols", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "share", "childNum": 0, "tag": "strong", "childList": []}, {"text": "self.rows[x]", "childNum": 0, "tag": "code", "childList": []}, {"text": "self.rows[y]", "childNum": 0, "tag": "code", "childList": []}, {"text": "they are the same object", "childNum": 0, "tag": "strong", "childList": []}, {"text": "self.cols", "childNum": 0, "tag": "code", "childList": []}, {"text": "self.rows[z]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you wanted to make a separate empty dict for the row each time, then do that: assign {}."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "do that", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "{}", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["But you really don't need a class for this in the first place; it's just pushing you into using a custom interface for something that's naturally done directly in Python.", "You should probably also be looking into collections.defaultdict."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "collections.defaultdict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["When you call a.addcol(\"price\") the code modifies self.rows[x][name], setting it equal to None. "], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "a.addcol(\"price\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self.rows[x][name]", "childNum": 0, "tag": "code", "childList": []}, {"text": "None", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["self.cols is thus set to equal the dict {'price': None}.", "Since each self.rows[x] is set equal to self.cols, you get the same dict printed each time."], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "self.cols", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "{'price': None}", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "self.rows[x]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "self.cols", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["When you set up the columns for a row, you always refer to self.cols - because Python handles this like a reference, anytime that you update it you update it for everything that points to that reference."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "self.cols", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You should initialize it to an appropriate value each time if you expect a different set of columns for each row."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You're reusing the same dictionary instance all the time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def addrow(self, name):\n    self.rows[name] = self.cols\n</code>\n</pre>\n", "senID": 1}, {"text": ["Remember that Python is similar like Java when it comes to variables - each name is just a reference to an object instance.", "It's not like in C where variable assignment almost always means copying the value."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "copying", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["If you want to create a quick-n-dirty table class for rows and columns, you could make use of defaultdict, for example:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "defaultdict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from collections import defaultdict\n\nclass RowsAndColumns:\n    def __init__(self):\n        self._rows = defaultdict(dict)\n\n    def get(self, row, col):\n        return self._rows[row][col]\n\n    def set(self, row, col, value):\n        self._rows[row][col] = value\n\nmatrix = RowsAndColumns()\nmatrix.set(\"Coke\", \"Price\", 1.99)\nprint matrix.get(\"Coke\", \"Price\") # 1.99\nprint matrix.get(\"Pepsi\", \"Price\") # KeyError \"Price\"\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The easiest way to do this is to just have a list of dictionaries.", "Like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # A new \"database\"\ndbase = []\n# Adding a new \"row\".\ndbase.append({})\n# Adding columns to a specific row:\ndbase[0]['newcol'] = \"The value\"\n# Retrieving a colum from a row which will raise a KeyError if the column doesn't exist:\ndbase[0]['newcol']\n# Retrieving a colum from a row which will return None if the column doesn't exist:\ndbase[0].get('anothercol')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also you could look at the DefaultDict, but I think it's better to learn how standard dictionaries and objects work first."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]