[[{"text": ["The special-casing of __dict__ works like this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__dict__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def __init__(self):\n    self.__dict__['d_dict'] = {}\n</code>\n</pre>\n", "senID": 1}, {"text": ["There is no need to use a new-style class for that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["the problem seems to be in time of evaluation of your code in __init__ method.", "You could define __new__ method and initialize d_dict variable there instead of __init__.", "Thats a bit hackish but it works, remember though to comment it as after few months it'll be total magic."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class  Foo(object):\n...     def __new__(cls, *args):\n...             my_cls = super(Foo, cls).__new__(cls, *args)\n...             my_cls.d_dict = {}\n...             return my_cls\n\n&gt;&gt;&gt; f = Foo()\n&gt;&gt;&gt; id(f.d_dict)\n3077948796L\n&gt;&gt;&gt; d = Foo()\n&gt;&gt;&gt; id(d.d_dict)\n3078142804L\n</code>\n</pre>\n", "senID": 1}, {"text": ["Word of explanation why I consider that hackish: call to __new__ returns new instance of class so then d_dict initialised in there is kind of static, but it's initialised with new instance of dictionary each time class is \"created\" so everything works as you need."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "class", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "d_dict", "childNum": 0, "tag": "em", "childList": []}, {"text": "static", "childNum": 0, "tag": "strong", "childList": []}, {"text": "created", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["You need to special-case d_dict."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Although of course, in the above code, all you do is replicate what any object does with __dict__ already, so it's pretty pointless.", "Do I guess correctly if you intended to special case some attributes and actally use methods for those?"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__dict__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["In that case, you can use properties."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class C(object):\n    def __init__(self):\n        self._x = None\n\n    @property\n    def x(self):\n        \"\"\"I'm the 'x' property.\"\"\"\n        return self._x\n\n    @x.setter\n    def x(self, value):\n        self._x = value\n\n    @x.deleter\n    def x(self):\n        del self._x\n</code>\n</pre>\n", "senID": 3}], [{"text": ["A solution, not very pythonic but works.", "As Lennart Regebro pointed, you have to use a special case for d_dict."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Token(object):\n\n    def __init__(self):\n        super(Token,self).__setattr__('d_dict', {})\n\n    def __getattr__(self,name):\n        return self.a[name]\n\n    def __setattr__(self,name,value):\n        self.a[name] = value\n</code>\n</pre>\n", "senID": 1}, {"text": ["You need to use new style classes."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It's worth remembering that __getattr__ is only called if the attribute doesn't exist in the object, whereas __setattr__ is always called."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "__getattr__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__setattr__", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I think we'll be able to say something about the overall design of your class if you explain its purpose.", "For example, "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # This is a class that serves as a dictionary but also has user-defined methods\nclass mydict(dict): pass\n\n# This is a class that allows setting x.attr = value or getting x.attr:\nclass mysetget: pass\n\n# This is a class that allows setting x.attr = value or getting x.attr:\nclass mygetsethas: \n    def has(self, key):\n        return key in self.__dict__\n\nx = mygetsethas()\nx.a = 5\nprint(x.has('a'), x.a)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think the last class is closest to what you meant, and I also like to play with syntax and get lots of joy from it, but unfortunately this is not a good thing.", "Reasons why it's not advisable to use object attributes to re-implement dictionary: you can't use x.3, you conflict with x.has(), you have to put quotes in has('a') and many more."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "x.3", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "x.has()", "childNum": 0, "tag": "code", "childList": []}, {"text": "has('a')", "childNum": 0, "tag": "code", "childList": []}]}]]