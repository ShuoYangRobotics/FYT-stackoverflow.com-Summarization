[[{"text": ["You can't do it without iteration.", "Even if you call a single method, internally that will iterate."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Your approach is fine for small list, but you could use this approach instead for larger lists:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n s2 = set(l2)\nresult = [i for i in l1 if not i in s2 ]\n</code>\n</pre>\n", "senID": 2}, {"text": ["This will be fast, and also preserve the original order of the elements in l1."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you don't care about the order of the elements, you can use sets:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l1 = set([2, 3, 4, 5])\nl2 = set([0, 1, 2, 3])\nprint l1 - l2\n</code>\n</pre>\n", "senID": 1}, {"text": ["prints"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n set([4, 5])\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Short answer, yes: list(set(l1) - set(l2)), though this will not keep order."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "list(set(l1) - set(l2))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Long answer, no, since internally the CPU will always iterate.", "Though if you use set() that iteration will be done highly optimized and will be much faster then your list comprehension (not to mention that checking for membership value in list is much faster with sets then lists)."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "set()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "value in list", "childNum": 0, "tag": "code", "childList": []}, {"text": "much", "childNum": 0, "tag": "strong", "childList": []}]}], [{"text": ["you can use use set_1.difference_update(set_2) for in place difference:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;sl1 = set([2, 3, 4, 5])\n&gt;&gt;sl2 = set([0, 1, 2, 3])\n&gt;&gt;sl1.difference_update(sl2)\n&gt;&gt;sl1\nset([4, 5])\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Convert them to sets, use the difference operator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l1=[2,3,4,5]\nl2=[0,1,2,3]\n\nanswer = set(l1) - set(l2)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can do this simply as follows:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n list( set(l1) - set(l2) )\n</code>\n</pre>\n", "senID": 1}, {"text": ["This should do the trick."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["The conversion to sets is great when your list elements can be converted to sets.", "Otherwise you'll need something like Mark's solution above.", "If you have large lists to compare you might not want to pay the memory allocation overhead and simplify his line to:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [l1.remove(m) for m in l1 if m in l2]\n</code>\n</pre>\n", "senID": 1}]]