[[{"code": "<pre>\n<code>\n def fubarise(data):\n    try:\n        if nasty(data):\n            raise ValueError(\"Look, Ma, I'm doing a big fat GOTO ...\") # sheesh #1\n        more_of_the_same()\n        parsed_line = data\n    except ValueError:\n        parsed_line = False\n        # so it can be a \"data\" or False -- sheesh #2\n    return parsed_line\n</code>\n</pre>\n", "senID": 0}, {"text": ["There is no point in having different error messages in the raise statement; they are never seen.", "Sheesh #3."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "raise", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Update: Here is a suggested improvement which uses struct.unpack to partition input lines rapidly.", "It also illustrates better exception handling, under the assumption that the writer of the code is also running it and stopping on the first error is acceptable.", "A robust implementation which logs all errors in all columns of all lines for a user audience is another matter.", "Note that typically the error checking for each column would be much more extensive e.g.", "checking for a leading sign but not checking whether the column contains a valid number seems a little odd."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "struct.unpack", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import struct\n\ndef unpacked_records(self):\n    cols = self.Columns()\n    unpack_fmt = \"\"\n    sign_checks = []\n    start = 0\n    for colx, info in enumerate(cols, 1):\n        clen = info.columnLength\n        if clen &lt; 1:\n            raise ValueError(\"Column %d: Bad columnLength %r\" % (colx, clen))\n        if info.skipColumn:\n            unpack_fmt += str(clen) + \"x\"\n        else:\n            unpack_fmt += str(clen) + \"s\"\n            if info.hasSignage:\n                sign_checks.append(start)\n        start += clen\n    expected_len = start\n    unpack = struct.Struct(unpack_fmt).unpack\n\n    for linex, line in enumerate(self.whatever_the_list_of_lines_is, 1):\n        if len(line) != expected_len:\n            raise ValueError(\n                \"Line %d: Actual length %d, expected %d\"\n                % (linex, len(line), expected_len))\n        if not all(line[i] in '+-' for i in sign_checks):\n            raise ValueError(\"Line %d: At least one column fails sign check\" % linex)\n        yield unpack(line) # a tuple\n</code>\n</pre>\n", "senID": 3}], [{"text": ["what about (using some classes to have an executable example):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Info(object):\n    columnLength = 5\n    hasSignage = True\n    skipColumn = False\n\nclass Something(object):\n\n    def Columns(self):\n        return [Info()]*4\n\n    def bottleneck(self):\n        try:\n            data = []\n            start = 0\n            end = 0\n            line = '+this-is just a line for testing'\n            for info in self.Columns():\n                start = end\n                collength = info.columnLength\n                end = start + collength\n                if info.skipColumn:  # start with this\n                    continue\n\n                elif collength == 0: \n                    raise ValueError('Wrong Input')\n\n                slice = line[start:end] # only now slicing, because it\n                                        # is probably most expensive part\n\n                if len(slice) != collength: \n                    raise ValueError('Wrong Input')\n\n                elif info.hasSignage and slice[0] not in '+-': # bit more compact\n                    raise ValueError('Wrong Input')\n\n                else:\n                    data.append(slice)\n\n            parsedLine = data\n        except:\n            parsedLine = False\n\nSomething().bottleneck()\n</code>\n</pre>\n", "senID": 1}, {"text": ["edit:\n when length of slice is 0, slice[0] does not exist, so if collength == 0 has to be checked for first"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "if collength == 0", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["edit2:\n You are using this bit of code for many many lines, but the column info does not change, right?", "That allows you, to "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": "pre-calculate a list of start points of each colum (no more need to calculate start, end)", "tag": "none", "senID": 4}, {"text": "knowing start-end in advance, .Columns() only needs to return columns that are not skipped and have a columnlength >0 (or do you really need to raise an input for length==0 at each line??)", "tag": "none", "senID": 5}, {"text": "the manditory length of each line is known and equal or each line and can be checked before looping over the column infos", "tag": "none", "senID": 6}]}, {"text": ["edit3:\nI wonder how you will know what data index belongs to which column if you use 'skipColumn'..."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Don't compute  start and end every time through this loop."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "start", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "end", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Compute them exactly once prior to using self.Columns() (Whatever that is.", "If 'Columns` is class with static values, that's silly.", "If it's a function with a name that begins with a capital letter, that's confusing."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "self.Columns()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["if slice == '' or len(slice) != info.columnLength can only happen if line is too short compared to the total size required by Columns.", "Check once, outside the loop."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "if slice == '' or len(slice) != info.columnLength", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Columns", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["slice[0:1].strip() != '+' sure looks like .startswith()."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "slice[0:1].strip() != '+'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".startswith()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["if not info.skipColumn.", "Apply this filter before even starting the loop.", "Remove these from self.Columns()."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "if not info.skipColumn", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self.Columns()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["First thing I would consider is slice = line[start:end].", "Slicing creates new instances; you could try to avoid explicitly constructing line [start:end] and examine its contents manually."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "slice = line[start:end]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "line [start:end]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Why are you doing slice[0:1]?", "This should yield a subsequence containing a single item of slice (shouldn't it?", "), thus it can probably be checked more efficiently. "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "slice[0:1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "slice", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["EDIT: I'm changing this answer a bit.", "I'll leave the original answer below."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In my other answer I commented that the best thing would be to find a built-in Python module that would do the unpacking.", "I couldn't think of one, but perhaps I should have Google searched for one.", "@John Machin provided an answer that showed how to do it: use the Python struct module.", "Since that is written in C, it should be faster than my pure Python solution.", "(I haven't actually measured anything so it is a guess."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "struct", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["I do agree that the logic in the original code is \"un-Pythonic\".", "Returning a sentinel value isn't best; it's better to either return a valid value or raise an exception.", "The other way to do it is to return a list of valid values, plus another list of invalid values.", "Since @John Machin offered code to yield up valid values, I thought I'd write a version here that returns two lists."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["NOTE: Perhaps the best possible answer would be to take @John Machin's answer and modify it to save the invalid values to a file for possible later review.", "His answer yields up answers one at a time, so there is no need to build a large list of parsed records; and saving the bad lines to disk means there is no need to build a possibly-large list of bad lines."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import struct\n\ndef parse_records(self):\n    \"\"\"\n    returns a tuple: (good, bad)\n    good is a list of valid records (as tuples)\n    bad is a list of tuples: (line_num, line, err)\n    \"\"\"\n\n    cols = self.Columns()\n    unpack_fmt = \"\"\n    sign_checks = []\n    start = 0\n    for colx, info in enumerate(cols, 1):\n        clen = info.columnLength\n        if clen &lt; 1:\n            raise ValueError(\"Column %d: Bad columnLength %r\" % (colx, clen))\n        if info.skipColumn:\n            unpack_fmt += str(clen) + \"x\"\n        else:\n            unpack_fmt += str(clen) + \"s\"\n            if info.hasSignage:\n                sign_checks.append(start)\n        start += clen\n    expected_len = start\n    unpack = struct.Struct(unpack_fmt).unpack\n\n    good = []\n    bad = []\n    for line_num, line in enumerate(self.whatever_the_list_of_lines_is, 1):\n        if len(line) != expected_len:\n            bad.append((line_num, line, \"bad length\"))\n            continue\n        if not all(line[i] in '+-' for i in sign_checks):\n            bad.append((line_num, line, \"sign check failed\"))\n            continue\n        good.append(unpack(line))\n\n    return good, bad\n</code>\n</pre>\n", "senID": 4}, {"text": ["ORIGINAL ANSWER TEXT:\nThis answer should be a lot faster if the self.Columns() information is identical over all the records.", "We do the processing of the self.Columns() information one time, and build a couple of lists that contain just what we need to process a record."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "self.Columns()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "self.Columns()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This code shows how to compute parsedList but doesn't actually yield it up or return it or do anything with it.", "Obviously you would need to change that."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "parsedList", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def parse_records(self):\n    cols = self.Columns()\n\n    slices = []\n    sign_checks = []\n    start = 0\n    for info in cols:\n        if info.columnLength &lt; 1:\n            raise ValueError, \"bad columnLength\"\n        end = start + info.columnLength\n        if not info.skipColumn:\n            tup = (start, end)\n            slices.append(tup)   \n            if info.hasSignage:\n                sign_checks.append(start)\n\n    expected_len = end # or use (end - 1) to not count a newline\n\n    try:\n        for line in self.whatever_the_list_of_lines_is:\n            if len(line) != expected_len:\n                raise ValueError, \"wrong length\"\n            if not all(line[i] in '+-' for i in sign_checks):\n                raise ValueError, \"wrong input\"\n            parsedLine = [line[s:e] for s, e in slices]\n\n    except ValueError:\n        parsedLine = False\n</code>\n</pre>\n", "senID": 7}], [{"text": ["I want to tell you to use some sort of built-in Python feature to split the string, but I can't think of one.", "So I'm left with just trying to reduce the amount of code you have."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When we are done, end should be pointing at the end of the string; if this is the case, then all of the .columnLength values must have been okay.", "(Unless one was negative or something!"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "end", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".columnLength", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Since this has a reference to self it must be a snip from a member function.", "So, instead of raising exceptions, you could just return False to exit the function early and return an error flag.", "But I like the debugging potential of changing the except clause to not catch the exception anymore, and getting a stack trace letting you identify where the problem came from."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "self", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return False", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "except", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["@Remi used slice[0] in '+-' where I used slice.startswith(('+', '-)).", "I think I like @Remi's code better there, but I left mine unchanged just to show you a different way.", "The .startswith() way will work for strings longer than length 1, but since this is only a string of length 1 the terse solution works."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "slice[0] in '+-'", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "slice.startswith(('+', '-))", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": ".startswith()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n try:\n    line = line.strip('\\n')\n    data = []\n    start = 0\n    for info in self.Columns():\n        end = start + info.columnLength\n        slice = line[start:end]\n        if info.hasSignage and not slice.startswith(('+', '-')):\n            raise ValueError, \"wrong input\"\n        if not info.skipColumn:\n            data.append(slice)\n        start = end\n\n    if end - 1 != len(line):\n        raise ValueError, \"bad .columnLength\"\n\n    parsedLine = data\n\nexcept ValueError:\n    parsedLine = False\n</code>\n</pre>\n", "senID": 4}]]