[[{"text": ["You can do this using list comprehensions and min() (Python 3.0 code):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "list comprehensions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html"}, {"href": "http://docs.python.org/library/functions.html", "text": "min()", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; nums = [1,2,3,4,5]\n&gt;&gt;&gt; [(x,y) for x in nums for y in nums]\n[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (5, 1), (5, 2), (5, 3), (5, 4), (5, 5)]\n&gt;&gt;&gt; min(_, key=lambda pair: pair[0]/pair[1])\n(1, 5)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that to run this on Python 2.5 you'll need to either make one of the arguments a float, or do from __future__ import division so that 1/5 correctly equals 0.2 instead of 0."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "from __future__ import division", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["If I'm correct in thinking that you want to find the minimum value of a function for all possible pairs of 2 elements from a list..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = [1,2,3,4,5]\n\ndef f(i,j):\n   return i+j \n\n# Prints min value of f(i,j) along with i and j\nprint min( (f(i,j),i,j) for i in l for j in l)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you don't mind importing the numpy package, it has a lot of convenient functionality built in.", "It's likely to be much more efficient to use their data structures than lists of lists and the like."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import division\n\nimport numpy\n\ndata = numpy.asarray([1,2,3,4,5])\ndists = data.reshape((1,5)) / data.reshape((5,1))\n\nprint dists\n\nwhich = dists.argmin()\n(r,c) = (which // 5, which % 5) # assumes C ordering\n\n# pick whichever is most appropriate for you...\nminval = dists[r,c]\nminval = dists.min()\nminval = dists.ravel()[which]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Try this resource"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this resource", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.literateprograms.org/Generating_all_integer_lattice_points_(Python)"}]}], [{"text": ["Doing it the mathy way..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n nums = [1, 2, 3, 4, 5]\nmin_combo = (min(nums), max(nums))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Unless, of course, you have negatives in there.", "In that case, this won't work because you actually want the min and max absolute values - the numerator should be close to zero, and the denominator far from it, in either direction.", "And double negatives would break it."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If working with Python \u22652.6 (including 3.x), you can:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import division\nimport operator, itertools\n\ndef getmin(alist):\n    return min(\n        (operator.div(*pair), pair)\n        for pair in itertools.product(alist, repeat=2)\n    )[1]\n\ngetmin([1, 2, 3, 4, 5])\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDIT: Now that I think of it and if I remember my mathematics correctly, this should also give the answer assuming that all numbers are non-negative:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def getmin(alist):\n    return min(alist), max(alist)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Some readable python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def JoeCalimar(l):\n    masterList = []\n    for i in l:\n        for j in l:\n            masterList.append(1.*i/j)\n    pos = masterList.index(min(masterList))\n    a = pos/len(masterList)\n    b = pos%len(masterList)\n    return (l[a],l[b])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Let me know if something is not clear."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["&gt;&gt;&gt; nums = [1, 2, 3, 4, 5]"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "&gt;&gt;&gt; nums = [1, 2, 3, 4, 5]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["&gt;&gt;&gt; min(map((lambda t: ((float(t[0])/t[1]), t)), ((x, y) for x in nums for y in nums)))[1]"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "&gt;&gt;&gt; min(map((lambda t: ((float(t[0])/t[1]), t)), ((x, y) for x in nums for y in nums)))[1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["(1, 5)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "(1, 5)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]