[[{"text": ["I would suggest using a REAL parser like SimpleParse or PyParsing.", "SimpleParse requires that you actually know EBNF, but is very fast.", "PyParsing has its own EBNF-like syntax but that is adapted for Python and makes it a breeze to build powerfully accurate parsers."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "SimpleParse", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/SimpleParse/2.1.1a2"}, {"text": "PyParsing", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/pyparsing/1.5.2"}]}, {"text": ["Edit: "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Here is an example of how easy it is to use PyParsing in this context:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; test = '/* spam * spam */ eggs'\n&gt;&gt;&gt; import pyparsing\n&gt;&gt;&gt; comment = pyparsing.nestedExpr(\"/*\", \"*/\").suppress()\n&gt;&gt;&gt; print comment.transformString(test)         \n' eggs'\n</code>\n</pre>\n", "senID": 3}, {"text": ["Here is a more complex example using single and multi-line comments."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Before:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n /*\n * multiline comments\n * abc 2323jklj\n * this is the worst C code ever!!\n*/\nvoid\ndo_stuff ( int shoe, short foot ) {\n    /* this is a comment\n     * multiline again! \n     */\n    exciting_function(whee);\n} /* extraneous comment */\n</code>\n</pre>\n", "senID": 6}, {"text": ["After:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print comment.transformString(code)   \n\nvoid\ndo_stuff ( int shoe, short foot ) {\n\n     exciting_function(whee);\n}\n</code>\n</pre>\n", "senID": 8}, {"text": ["It leaves an extra newline wherever it stripped comments, but that could be addressed."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["You are doing it wrong. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Regex is for Regular Languages, which C isn't. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Regular Languages", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Regular_language"}]}], [{"text": ["re.sub returns a string, so changing your code to the following will give results:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "re.sub", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def removeComments(string):\n    string = re.sub(re.compile(\"/\\*.*?\\*/\",re.DOTALL ) ,\"\" ,string) # remove all occurance streamed comments (/*COMMENT */) from string\n    string = re.sub(re.compile(\"//.*?\\n\" ) ,\"\" ,string) # remove all occurance singleline comments (//COMMENT\\n ) from string\n    return string\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I see several things you might want to revise."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First, Python passes objects by value, but some object types are immutable.", "Strings and integers are among these immutable types.", "So if you pass a string to a function, any changes to the string you make within the function won't affect the string you passed in.", "You should try returning a string instead.", "Furthermore, within the removeComments() function, you need to assign the value returned by re.sub() to a new variable -- like any function that takes a string as an argument, re.sub() will not modify the string."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Second, I would echo what others have said about parsing C code.", "Regular expressions are not the best way to go here."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I would recommend you read this page that has a quite detailed analyzis of the problem and gives a good understanding on why your approach doesn't work: http://ostermiller.org/findcomment.html"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://ostermiller.org/findcomment.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://ostermiller.org/findcomment.html"}]}, {"text": ["Short version: The regex you are looking for is this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n (/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+/)|(//.*)\n</code>\n</pre>\n", "senID": 2}, {"text": ["This should match both types of comment blocks.", "If you are having troubles following it read the page i linked."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["As noted in one of my other comments, comment nesting isn't really the problem (in C, comments don't nest, though a few compilers to support nested comments anyway).", "The problem is with things like string literals, that can contain the exact same character sequence as a comment delimiter without actually being one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As Mike Graham said, the right tool for the job is a lexer.", "A parser is unnecessary and would be overkill, but a lexer is exactly the right thing.", "As it happens, I posted a (partial) lexer for C (and C++) earlier this morning.", "It doesn't attempt to correctly identify all lexical elements (i.e.", "all keywords and operators) but it's entirely sufficient for stripping comments.", "It won't do any good on the \"using Python\" front though, as it's written entirely in C (it predates my using C++ for much more than experimental code)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "lexer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2318347/library-to-parse-c-c-source-code/2319255#2319255"}]}], [{"code": "<pre>\n<code>\n mystring=\"\"\"\nblah1 /* comments with\nmultiline */\n\nblah2\nblah3\n// double slashes comments\nblah4 // some junk comments\n\n\"\"\"\nfor s in mystring.split(\"*/\"):\n    s=s[:s.find(\"/*\")]\n    print s[:s.find(\"//\")]\n</code>\n</pre>\n", "senID": 0}, {"text": ["output"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n $ ./python.py\n\nblah1\n\n\nblah2\nblah3\n</code>\n</pre>\n", "senID": 2}]]