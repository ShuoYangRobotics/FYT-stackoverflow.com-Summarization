[[{"code": "<pre>\n<code>\n with open(\"datafile\") as myfile:\n    head=[myfile.next() for x in xrange(N)]\nprint head\n</code>\n</pre>\n", "senID": 0}, {"text": ["Here's another way"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from itertools import islice\nwith open(\"datafile\") as myfile:\n    head=list(islice(myfile,N))\nprint head\n</code>\n</pre>\n", "senID": 2}], [{"text": ["There is no specific method to read number of lines exposed by file object. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I guess the easiest way would be following: "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n lines =[]\nwith open(file_name) as f:\n    lines.extend(f.readline() for i in xrange(N))\n</code>\n</pre>\n", "senID": 2}], [{"text": ["If you want something that obviously (without looking up esoteric stuff in manuals) works without imports and try/except and works on a fair range of Python 2.x versions (2.2 to 2.6):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def headn(file_name, n):\n    \"\"\"Like *x head -N command\"\"\"\n    result = []\n    nlines = 0\n    assert n &gt;= 1\n    for line in open(file_name):\n        result.append(line)\n        nlines += 1\n        if nlines &gt;= n:\n            break\n    return result\n\nif __name__ == \"__main__\":\n    import sys\n    rval = headn(sys.argv[1], int(sys.argv[2]))\n    print rval\n    print len(rval)\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n N=10\nf=open(\"file\")\nfor i in range(N):\n    line=f.next().strip()\n    print line\nf.close()\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Based on gnibbler top voted answer (Nov 20 '09 at 0:27): this class add head() and tail() method to file object."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class File(file):\n    def head(self, lines_2find=1):\n        self.seek(0)                            #Rewind file\n        return [self.next() for x in xrange(lines_2find)]\n\n    def tail(self, lines_2find=1):  \n        self.seek(0, 2)                         #go to end of file\n        bytes_in_file = self.tell()             \n        lines_found, total_bytes_scanned = 0, 0\n        while (lines_2find+1 &gt; lines_found and\n               bytes_in_file &gt; total_bytes_scanned): \n            byte_block = min(1024, bytes_in_file-total_bytes_scanned)\n            self.seek(-(byte_block+total_bytes_scanned), 2)\n            total_bytes_scanned += byte_block\n            lines_found += self.read(1024).count('\\n')\n        self.seek(-total_bytes_scanned, 2)\n        line_list = list(self.readlines())\n        return line_list[-lines_2find:]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n f = File('path/to/file', 'r')\nf.head(3)\nf.tail(3)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["most convinient way on my own:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n LINE_COUNT = 3\nprint [s for (i, s) in enumerate(open('test.txt')) if i &lt; LINE_COUNT]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Solution based on List Comprehension\nThe function open() supports an iteration interface.", "The enumerate() covers open() and return tuples (index, item), then we check that we're inside an accepted range (if i &lt; LINE_COUNT) and then simply print the result."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "List Comprehension", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0202/"}]}, {"text": ["Enjoy the Python.", ";)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]