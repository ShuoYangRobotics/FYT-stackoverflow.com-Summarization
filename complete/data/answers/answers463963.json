[[{"text": ["On the shell, xargs can be used to queue parallel command processing.", "For example, for having always 3 sleeps in parallel, sleeping for 1 second each, and executing 10 sleeps in total do"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "xargs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n echo {1..10} | xargs -d ' ' -n1 -P3 sh -c 'sleep 1s' _\n</code>\n</pre>\n", "senID": 1}, {"text": ["And it would sleep for 4 seconds in total.", "If you have a list of names, and want to pass the names to commands executed, again executing 3 commands in parallel, do"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n cat names | xargs -n1 -P3 process_name\n</code>\n</pre>\n", "senID": 3}, {"text": ["Would execute the command process_name alice, process_name bob and so on."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "process_name alice", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "process_name bob", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I would imagine you could do this using make and the make -j xx command."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Perhaps a makefile like this"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n all : usera userb userc....\n\nusera:\n       imapsync usera\nuserb:\n       imapsync userb\n....\n</code>\n</pre>\n", "senID": 2}, {"text": ["make -j 10 -f makefile"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["For this kind of job PPSS is written: Parallel processing shell script.", "Google for this name and you will find it, I won't linkspam."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Parallel is made exatcly for this purpose."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Parallel", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://savannah.nongnu.org/projects/parallel/"}]}, {"code": "<pre>\n<code>\n cat userlist | parallel imapsync\n</code>\n</pre>\n", "senID": 1}, {"text": ["One of the beauties of Parallel compared to other solutions is that it makes sure output is not mixed.", "Doing traceroute in Parallel works fine for example:"], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "Parallel", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://savannah.nongnu.org/projects/parallel/"}, {"text": "traceroute", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"href": "https://savannah.nongnu.org/projects/parallel/", "text": "Parallel", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n (echo foss.org.my; echo www.debian.org; echo www.freenetproject.org) | parallel traceroute\n</code>\n</pre>\n", "senID": 3}], [{"text": ["GNU make (and perhaps other implementations as well) has the -j argument, which governs how many jobs it will run at once.", "When a job completes, make will start another one."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["Well, if they are largely independent of each other, I'd think in terms of:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n Initialize an array of jobs pending (queue, ...) - 200 entries\nInitialize an array of jobs running - empty\n\nwhile (jobs still pending and queue of jobs running still has space)\n    take a job off the pending queue\n    launch it in background\n    if (queue of jobs running is full)\n        wait for a job to finish\n        remove from jobs running queue\nwhile (queue of jobs is not empty)\n    wait for job to finish\n    remove from jobs running queue\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that the tail test in the main loop means that if the 'jobs running queue' has space when the while loop iterates - preventing premature termination of the loop.", "I think the logic is sound."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["I can see how to do that in C fairly easily - it wouldn't be all that hard in Perl, either (and therefore not too hard in the other scripting languages - Python, Ruby, Tcl, etc).", "I'm not at all sure I'd want to do it in shell - the wait command in shell waits for all children to terminate, rather than for some child to terminate."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "wait", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["In python, you could try:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import Queue, os, threading\n\n# synchronised queue\nqueue = Queue.Queue(0)    # 0 means no maximum size\n\n# do stuff to initialise queue with strings\n# representing os commands\nqueue.put('sleep 10')\nqueue.put('echo Sleeping..')\n# etc\n# or use python to generate commands, e.g.\n# for username in ['joe', 'bob', 'fred']:\n#    queue.put('imapsync %s' % username)\n\ndef go():\n  while True:\n    try:\n      # False here means no blocking: raise exception if queue empty\n      command = queue.get(False)\n      # Run command.  python also has subprocess module which is more\n      # featureful but I am not very familiar with it.\n      # os.system is easy :-)\n      os.system(command)\n    except Queue.Empty:\n      return\n\nfor i in range(10):   # change this to run more/fewer threads\n  threading.Thread(target=go).start()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Untested..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["(of course, python itself is single-threaded.", "You should still get the benefit of multiple threads in terms of waiting for IO, though."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you are going to use Python, I recommend using Twisted for this: http://twistedmatrix.com/trac/"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://twistedmatrix.com/trac/", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://twistedmatrix.com/trac/"}]}, {"text": ["Specifically Twisted Runner: http://twistedmatrix.com/trac/wiki/TwistedRunner"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://twistedmatrix.com/trac/wiki/TwistedRunner", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://twistedmatrix.com/trac/wiki/TwistedRunner"}]}], [{"text": ["Python's multiprocessing module would seem to fit your issue nicely.", "It's a high-level package that supports threading by process."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "multiprocessing module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/dev/library/multiprocessing.html"}]}], [{"text": ["https://savannah.gnu.org/projects/parallel (gnu parallel)\nand pssh might help."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "https://savannah.gnu.org/projects/parallel", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://savannah.gnu.org/projects/parallel"}]}], [{"text": ["Can you elaborate what you mean by in parallel?", "It sounds like you need to implement some sort of locking in the queue so your entries are not selected twice, etc and the commands run only once."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "in parallel", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Most queue systems cheat -- they just write a giant to-do list, then select e.g.", "ten items, work them, and select the next ten items.", "There's no parallelization."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you provide some more details, I'm sure we can help you out."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]