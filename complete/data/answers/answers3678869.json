[[{"text": ["There's a recipe for this in the itertoolsdocumentation:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "itertoolsdocumentation", "tag": "a", "pos": 0, "childList": [{"text": "itertools", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html"}, {"text": "itertools", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def roundrobin(*iterables):\n    \"roundrobin('ABC', 'D', 'EF') --&gt; A D E B F C\"\n    # Recipe credited to George Sakkis\n    pending = len(iterables)\n    nexts = cycle(iter(it).next for it in iterables)\n    while pending:\n        try:\n            for next in nexts:\n                yield next()\n        except StopIteration:\n            pending -= 1\n            nexts = cycle(islice(nexts, pending))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This should do what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; iters = [iter(list1), iter(list2)]\n&gt;&gt;&gt; print list(it.next() for it in itertools.cycle(iters))\n['f', 'hello', 'o', 'world', 'o']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's one way to do it by slicing:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list1 = ['f', 'o', 'o']\n&gt;&gt;&gt; list2 = ['hello', 'world']\n&gt;&gt;&gt; result = [None]*(len(list1)+len(list2))\n&gt;&gt;&gt; result[::2] = list1\n&gt;&gt;&gt; result[1::2] = list2\n&gt;&gt;&gt; result\n['f', 'hello', 'o', 'world', 'o']\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def combine(list1, list2):\n    lst = []\n    len1 = len(list1)\n    len2 = len(list2)\n\n    for index in range( max(len1, len2) ):\n        if index+1 &lt;= len1:\n            lst += [list1[index]]\n\n        if index+1 &lt;= len2:\n            lst += [list2[index]]\n\n    return lst\n</code>\n</pre>\n", "senID": 0}], [{"text": ["I'd do the simple:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n chain.from_iterable( izip( list1, list2 ) )\n</code>\n</pre>\n", "senID": 1}, {"text": ["It'll come up with an iterator without creating any additional storage needs."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I'm too old to be down with list comprehensions, so:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import operator\nlist3 = reduce(operator.add, zip(list1, list2))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Here's a one liner that does it:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["list3 = [ item for pair in zip(list1, list2 + [0]) for item in pair][:-1]"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "list3 = [ item for pair in zip(list1, list2 + [0]) for item in pair][:-1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Here's a one liner using list comprehensions, w/o other libraries:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n list3 = [sub[i] for i in range(len(list2)) for sub in [list1, list2]] + [list1[-1]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here is another approach, if you allow alteration of your initial list1 by side effect:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n [list1.insert((i+1)*2-1, list2[i]) for i in range(len(list2))]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["My take:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = \"hlowrd\"\nb = \"el ol\"\n\ndef func(xs, ys):\n    ys = iter(ys)\n    for x in xs:\n        yield x\n        yield ys.next()\n\nprint [x for x in func(a, b)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Stops on the shortest:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def interlace(*iters, next = next) -&gt; collections.Iterable:\n    \"\"\"\n    interlace(i1, i2, ..., in) -&gt; (\n        i1-0, i2-0, ..., in-0,\n        i1-1, i2-1, ..., in-1,\n        .\n        .\n        .\n        i1-n, i2-n, ..., in-n,\n    )\n    \"\"\"\n    return map(next, cycle([iter(x) for x in iters]))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Sure, resolving the next/_next_ method may be faster."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "next", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Without itertools and assuming l1 is 1 item longer than l2:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; sum(zip(l1, l2+[0]), ())[:-1]\n('f', 'hello', 'o', 'world', 'o')\n</code>\n</pre>\n", "senID": 1}, {"text": ["Using itertools and assuming that lists don't contain None:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; filter(None, sum(itertools.izip_longest(l1, l2), ()))\n('f', 'hello', 'o', 'world', 'o')\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n c=[]\nfor i, j in zip(list1,list2):\n    c.append(i)\n    c.append(j)\nc.append(list1[-1])\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n zip(list1, list2)\n</code>\n</pre>\n", "senID": 0}]]