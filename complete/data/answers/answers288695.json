[[{"text": ["In this case I would use delegation rather than inheritance.", "It means that your class should contain the file object as an attribute and invoke a readline method on it.", "You could pass a file object in the constructor of the logger class."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "delegation", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "inheritance", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "readline", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["There are at least two reasons for this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I am coming from a Java background but I am fairly confident that the same principles will apply in Python.", "As a rule of thumb you should never inherit from a class whose implementation you don't understand and control unless that class has been designed specifically for inheritance.", "If it has been designed in this way it should describe this clearly in its documentation."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "never", "childNum": 0, "tag": "b", "pos": 1, "childList": []}]}, {"text": ["The reason for this is that inheritance can potentially bind you to the implementation details of the class that you are inheriting from."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["To use an example from Josh Bloch's book 'Effective Java'"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If we were to extend the class ArrayList class in order to be able to count the number of items that were added to it during its life-time (not necessarily the number it currently contains) we may be tempted to write something like this."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "ArrayList", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n public class CountingList extends ArrayList {\n    int counter = 0;\n\n    public void add(Object o) {\n        counter++;\n        super.add(0);\n    }\n\n    public void addAll(Collection c) {\n        count += c.size();\n        super.addAll(c);\n    }\n\n    // Etc.\n}\n</code>\n</pre>\n", "senID": 4}, {"text": ["Now this extension looks like it would accurately count the number of elements that were added to the list but in fact it may not.", "If ArrayList has implemented addAll by iterating over the Collection provided and calling its interface method addAll for each element then we will count each element added through the addAll method twice.", "Now the behaviour of our class is dependent on the implementation details of ArrayList."], "childNum": 6, "tag": "p", "senID": 5, "childList": [{"text": "ArrayList", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "addAll", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "Collection", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "addAll", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "addAll", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "ArrayList", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["This is of course in addition to the disadvantage of not being able to use other implementations of List with our CountingList class.", "Plus the disadvantages of inheriting from a concrete class that are discussed above."], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "List", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "CountingList", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["It is my understanding that Python uses a similar (if not identical) method dispatch mechanism to Java and will therefore be subject to the same limitations.", "If someone could provide an example in Python I'm sure it would be even more useful."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Although it is in some cases useful to inherit from builtins, the real question here is what you want to do with the output and what's your big-picture design.", "I would usually write a reader (that uses a file object) and spit out whatever data class I need to hold the information I just read.", "It's then easy to design that data class to fit in with the rest of my design."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You should be fairly safe inheriting from a \"builtin\" class, as later modifications to these classes will usually be compatible with the current version. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["However, you should think seriously about wether you really want to tie your class to the additional functionality provided by the builtin class.", "As mentioned in another answer you should consider (perhaps even prefer) using delegation instead. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "delegation", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["As an example of why to avoid inheritance if you don't need it you can look at the java.util.Stack class.", "As it extends Vector it inherits all of the methods on Vector.", "Most of these methods break the contract implied by Stack, e.g.", "LIFO.", "It would have been much better to implement Stack using a Vector internally, only exposing Stack methods as the API.", "It would then have been easy to change the implementation to ArrayList or something else later, none of which is possible now due to inheritance."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "java.util.Stack", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "all", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}]}], [{"text": ["It is perfectly acceptable to inherit from a built in class.", "In this case I'd say you're right on the money.", "The log \"is a\" file so that tells you inheritance is ok.. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}]}, {"text": ["General rule.", "Dog \"is a\"n animal, therefore inherit from animal.", "Owner \"has a\"n animal therefore don't inherit from animal. "], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}]}], [{"text": ["Thanks for the answers, it seems that truly delegation is the better choice here.", "There happens to be another problem here: I have too many other questions (not well-enough formed yet) for this thread to contain :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You seem to have found your answer that in this case delegation is the better strategy.", "Nevertheless, I would like to add that, excepting delegation, there is nothing wrong with extending a built-in class, particularly if your alternative, depending on the language, is \"monkey patching\" (see http://en.wikipedia.org/wiki/Monkey_patch) "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://en.wikipedia.org/wiki/Monkey_patch", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Monkey_patch"}]}]]