[[{"text": ["I wrote such parser a few years ago.", "It generates python classes for pyasn1 library.", "I used in on ericsson doc to make parser for their CDRs."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I'll try posting the code here now."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import sys\nfrom pyparsing import *\n\nOpenBracket = Regex(\"[({]\").suppress()\nCloseBracket = Regex(\"[)}]\").suppress()\n\ndef Enclose(val):\n  return OpenBracket + val + CloseBracket\n\ndef SetDefType(typekw):\n  def f(a, b, c):\n    c[\"defType\"] = typekw\n  return f\n\ndef NoDashes(a, b, c):\n  return c[0].replace(\"-\", \"_\")\n\ndef DefineTypeDef(typekw, typename, typedef):\n  return typename.addParseAction(SetDefType(typekw)).setResultsName(\"definitionType\") - \\\n    Optional(Enclose(typedef).setResultsName(\"definition\"))\n\n\n\nSizeConstraintBodyOpt = Word(nums).setResultsName(\"minSize\") - \\\n  Optional(Suppress(Literal(\"..\")) - Word(nums + \"n\").setResultsName(\"maxSize\"))\n\nSizeConstraint = Group(Keyword(\"SIZE\").suppress() - Enclose(SizeConstraintBodyOpt)).setResultsName(\"sizeConstraint\")\n\nConstraints = Group(delimitedList(SizeConstraint)).setResultsName(\"constraints\")\n\nDefinitionBody = Forward()\n\nTagPrefix = Enclose(Word(nums).setResultsName(\"tagID\")) - Keyword(\"IMPLICIT\").setResultsName(\"tagFormat\")\n\nOptionalSuffix = Optional(Keyword(\"OPTIONAL\").setResultsName(\"isOptional\"))\nJunkPrefix = Optional(\"--F--\").suppress()\nAName = Word(alphanums + \"-\").setParseAction(NoDashes).setResultsName(\"name\")\n\nSingleElement = Group(JunkPrefix - AName - Optional(TagPrefix) - DefinitionBody.setResultsName(\"typedef\") - OptionalSuffix)\n\nNamedTypes = Dict(delimitedList(SingleElement)).setResultsName(\"namedTypes\")\n\nSetBody = DefineTypeDef(\"Set\", Keyword(\"SET\"), NamedTypes)\nSequenceBody = DefineTypeDef(\"Sequence\", Keyword(\"SEQUENCE\"), NamedTypes)\nChoiceBody = DefineTypeDef(\"Choice\", Keyword(\"CHOICE\"), NamedTypes)\n\nSetOfBody = (Keyword(\"SET\") + Optional(SizeConstraint) + Keyword(\"OF\")).setParseAction(SetDefType(\"SetOf\")) + Group(DefinitionBody).setResultsName(\"typedef\")\nSequenceOfBody = (Keyword(\"SEQUENCE\") + Optional(SizeConstraint) + Keyword(\"OF\")).setParseAction(SetDefType(\"SequenceOf\")) + Group(DefinitionBody).setResultsName(\"typedef\")\n\nCustomBody = DefineTypeDef(\"constructed\", Word(alphanums + \"-\").setParseAction(NoDashes), Constraints)\nNullBody = DefineTypeDef(\"Null\", Keyword(\"NULL\"), Constraints)\n\nOctetStringBody = DefineTypeDef(\"OctetString\", Regex(\"OCTET STRING\"), Constraints)\nIA5StringBody = DefineTypeDef(\"IA5String\", Keyword(\"IA5STRING\"), Constraints)\n\nEnumElement = Group(Word(printables).setResultsName(\"name\") - Enclose(Word(nums).setResultsName(\"value\")))\nNamedValues = Dict(delimitedList(EnumElement)).setResultsName(\"namedValues\")\nEnumBody = DefineTypeDef(\"Enum\", Keyword(\"ENUMERATED\"), NamedValues)\n\nBitStringBody = DefineTypeDef(\"BitString\", Keyword(\"BIT\") + Keyword(\"STRING\"), NamedValues)\n\nDefinitionBody &lt;&lt; (OctetStringBody | SetOfBody | SetBody | ChoiceBody | SequenceOfBody | SequenceBody | EnumBody | BitStringBody | IA5StringBody | NullBody | CustomBody)\n\nDefinition = AName - Literal(\"::=\").suppress() - Optional(TagPrefix) - DefinitionBody\n\nDefinitions = Dict(ZeroOrMore(Group(Definition)))\n\npf = Definitions.parseFile(sys.argv[1])\n\nTypeDeps = {}\nTypeDefs = {}\n\ndef SizeConstraintHelper(size):\n  s2 = s1 = size.get(\"minSize\")\n  s2 = size.get(\"maxSize\", s2)\n  try:\n    return(\"constraint.ValueSizeConstraint(%s, %s)\" % (int(s1), int(s2)))\n  except ValueError:\n    pass\n\nConstraintMap = {\n  'sizeConstraint' : SizeConstraintHelper,\n}\n\ndef ConstraintHelper(c):\n  result = []\n  for key, value in c.items():\n    r = ConstraintMap[key](value)\n    if r:\n      result.append(r)\n  return result\n\ndef GenerateConstraints(c, ancestor, element, level=1):\n  result = ConstraintHelper(c)\n  if result:\n    return [ \"subtypeSpec = %s\" % \" + \".join([\"%s.subtypeSpec\" % ancestor] + result) ]\n  return []\n\ndef GenerateNamedValues(definitions, ancestor, element, level=1):\n  result = [ \"namedValues = namedval.NamedValues(\" ]\n  for kw in definitions:\n    result.append(\"  ('%s', %s),\" % (kw[\"name\"], kw[\"value\"]))\n  result.append(\")\")\n  return result\n\nOptMap = {\n  False: \"\",\n  True: \"Optional\",\n}\n\ndef GenerateNamedTypesList(definitions, element, level=1):\n  result = []\n  for val in definitions:\n    name = val[\"name\"]\n    typename = None\n\n    isOptional = bool(val.get(\"isOptional\"))\n\n    subtype = []\n    constraints = val.get(\"constraints\")\n    if constraints:\n      cg = ConstraintHelper(constraints)\n      subtype.append(\"subtypeSpec=%s\" % \" + \".join(cg))\n    tagId = val.get(\"tagID\")\n    if tagId:\n      subtype.append(\"implicitTag=tag.Tag(tag.tagClassContext, tag.tagFormatConstructed, %s)\" % tagId)\n\n    if subtype:\n      subtype = \".subtype(%s)\" % \", \".join(subtype)\n    else:\n      subtype = \"\"\n\n    cbody = []\n    if val[\"defType\"] == \"constructed\":\n      typename = val[\"typedef\"]\n      element[\"_d\"].append(typename)\n    elif val[\"defType\"] == \"Null\":\n      typename = \"univ.Null\"\n    elif val[\"defType\"] == \"SequenceOf\":\n      typename = \"univ.SequenceOf\"\n      print val.items()\n      cbody = [ \"  componentType=%s()\" % val[\"typedef\"][\"definitionType\"] ]\n    elif val[\"defType\"] == \"Choice\":\n      typename = \"univ.Choice\"\n      indef = val.get(\"definition\")\n      if indef:\n        cbody = [ \"  %s\" % x for x in GenerateClassDefinition(indef, name, typename, element) ]\n    construct = [ \"namedtype.%sNamedType('%s', %s(\" % (OptMap[isOptional], name, typename), \")%s),\" % subtype ]\n    if not cbody:\n      result.append(\"%s%s%s\" % (\"  \" * level, construct[0], construct[1]))\n    else:\n      result.append(\"  %s\" % construct[0])\n      result.extend(cbody)\n      result.append(\"  %s\" % construct[1])\n  return result\n\n\n\ndef GenerateNamedTypes(definitions, ancestor, element, level=1):\n  result = [ \"componentType = namedtype.NamedTypes(\" ]\n  result.extend(GenerateNamedTypesList(definitions, element))\n  result.append(\")\")\n  return result\n\n\ndefmap = {\n  'constraints' : GenerateConstraints,\n  'namedValues' : GenerateNamedValues,\n  'namedTypes' : GenerateNamedTypes,\n}\n\ndef GenerateClassDefinition(definition, name, ancestor, element, level=1):\n  result = []\n  for defkey, defval in definition.items():\n    if defval:\n      fn = defmap.get(defkey)\n      if fn:\n        result.extend(fn(defval, ancestor, element, level))\n  return [\"  %s\" % x for x in result]\n\ndef GenerateClass(element, ancestor):\n  name = element[\"name\"]\n\n  top = \"class %s(%s):\" % (name, ancestor)\n  definition = element.get(\"definition\")\n  body = []\n  if definition:\n    body = GenerateClassDefinition(definition, name, ancestor, element)\n  else:\n    typedef = element.get(\"typedef\")\n    if typedef:\n      element[\"_d\"].append(typedef[\"definitionType\"])\n      body.append(\"  componentType = %s()\" % typedef[\"definitionType\"])\n      szc = element.get('sizeConstraint')\n      if szc:\n        body.extend(GenerateConstraints({ 'sizeConstraint' : szc }, ancestor, element))\n\n  if not body:\n    body.append(\"  pass\")\n\n  TypeDeps[name] = list(frozenset(element[\"_d\"]))\n\n  return \"\\n\".join([top] + body)\n\nStaticMap = {\n  \"Null\" : \"univ.Null\",\n  \"Enum\" : \"univ.Enumerated\",\n  \"OctetString\" : \"univ.OctetString\",\n  \"IA5String\" : \"char.IA5String\",\n  \"Set\" : \"univ.Set\",\n  \"Sequence\" : \"univ.Sequence\",\n  \"Choice\" : \"univ.Choice\",\n  \"SetOf\" : \"univ.SetOf\",\n  \"BitString\" : \"univ.BitString\",\n  \"SequenceOf\" : \"univ.SequenceOf\",\n}\n\ndef StaticConstructor(x):\n  x[\"_d\"] = []\n  if x[\"defType\"] == \"constructed\":\n    dt = x[\"definitionType\"]\n    x[\"_d\"].append(dt)\n  else:\n    dt = StaticMap[x[\"defType\"]]\n  return GenerateClass(x, dt)\n\n\nfor element in pf:\n  TypeDefs[element[\"name\"]] = StaticConstructor(element)\n\nwhile TypeDefs:\n  ready = [ k for k, v in TypeDeps.items() if len(v) == 0 ]\n  if not ready:\n    x = list()\n    for a in TypeDeps.values():\n      x.extend(a)\n    x = frozenset(x) - frozenset(TypeDeps.keys())\n\n    print TypeDefs\n\n    raise ValueError, sorted(x)\n\n  for t in ready:\n    for v in TypeDeps.values():\n      try:\n        v.remove(t)\n      except ValueError:\n        pass\n\n    del TypeDeps[t]\n    print TypeDefs[t]\n    print\n    print\n\n    del TypeDefs[t]\n</code>\n</pre>\n", "senID": 2}, {"text": ["This will take a file with syntax, similar to this one:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n CarrierInfo ::= OCTET STRING (SIZE(2..3))\nChargeAreaCode ::= OCTET STRING (SIZE(3))\nChargeInformation ::= OCTET STRING (SIZE(2..33))\nChargedParty ::= ENUMERATED\n\n (chargingOfCallingSubscriber  (0),\n  chargingOfCalledSubscriber   (1),\n  noCharging                   (2))\nChargingOrigin ::= OCTET STRING (SIZE(1))\nCounter ::= OCTET STRING (SIZE(1..4))\nDate ::= OCTET STRING (SIZE(3..4))\n</code>\n</pre>\n", "senID": 4}, {"text": ["You will need to add this line on top of the generated file:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from pyasn1.type import univ, namedtype, namedval, constraint, tag, char\n</code>\n</pre>\n", "senID": 6}, {"text": ["And name the result defs.py.", "Then, I attached a bunch of prettyprinters to the defs (if you don't have just skip it)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import defs, parsers\n\ndef rplPrettyOut(self, value):\n  return repr(self.decval(value))\n\nfor name in dir(parsers):\n  if (not name.startswith(\"_\")) and hasattr(defs, name):\n    target = getattr(defs, name)\n    target.prettyOut = rplPrettyOut\n    target.decval = getattr(parsers, name)\n</code>\n</pre>\n", "senID": 8}, {"text": ["Then, it's down to:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n def ParseBlock(self, block):\n    while block and block[0] != '\\x00':\n      result, block = pyasn1.codec.ber.decoder.decode(block, asn1Spec=parserimp.defs.CallDataRecord())\n      yield result\n</code>\n</pre>\n", "senID": 10}, {"text": ["If you're still interested I'll put the code somewhere.", "In fact, I'll put it somewhere in any case - but if you're interested just let me know and I'll point you there."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["Never tried them but:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["asn1c"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}, {"text": ["snacc"], "childNum": 0, "tag": "a", "senID": 2, "childList": []}]}, {"text": ["Both seems to do what you want (C, not Python)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["There is an ANTLR ASN.1 grammar; using ANTLR, you should be able to make an ASN.1 parser out of it.", "Generating code for pyasn1 is left as an exercise to the poster :-)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "ANTLR ASN.1 grammar", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.antlr.org/grammar/1231433381400/ASN.g"}]}], [{"text": ["I have done a similar job using asn1c and building around it a Pyrex extension.", "The wrapped structure is described in 3GPP TS 32.401."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "3GPP TS 32.401", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.3gpp.org/ftp/Specs/html-info/32401.htm"}]}, {"text": ["With Pyrex you can write a wrapper thick enough to convert between native Python data types and the correct ASN.1 representations (wrapper generators, such SWIG, tend to not perform complex operations on the type).", "The wrapper I wrote also tracked the ownership of the underlying C data structures (e.g.", "accessing to a sub-structure, a Python object was returned, but there was no copy of the underlying data, only reference sharing)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The wrapper was eventually written in a kind of semi-automatic way, but because that has been my only job with ASN.1 I never did the step of completely automatize the code generation."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You can try to use other Python-C wrappers and perform a completely automatic conversion: the job would be less, but then you would move complexity (and repetitive error-prone operations) to the structure users: for this reason I preferred the Pyrex way.", "asn1c was definitely a good choice."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I have experience with pyasn1 and it's enough to parse quite complex grammars.", "A grammar is expressed with python structure, so no need to run code generator."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pyasn1", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyasn1.sourceforge.net/"}]}], [{"text": ["I'm the author of LEPL, a parser written in Python, and what you want to do is one of the things on my \"TODO\" list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I will not be doing this soon, but you might consider using LEPL to construct your solution because:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["1 - it's a pure Python solution (which makes life simpler)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["2 - it can already parse binary data as well as text, so you would only need to use a single tool - the same parser that you would use to parse the ASN1 spec would then be used to parse the binary data"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["The main downsides are that:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["1 - it's a fairly new package, so it may be buggier than some, and the support community is not that large"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["2 - it is restricted to Python 2.6 and up (and the binary parser only works with Python 3 and up)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["For more information, please see http://www.acooke.org/lepl - in particular,for binary parsing see the relevant section of the manual (I cannot link directly to that as Stack Overflow seems to think I am spamming)"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "http://www.acooke.org/lepl", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.acooke.org/lepl"}]}, {"text": ["Andrew"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["PS  The main reason this is not something I have already started is that the ASN 1 specs are not freely available, as far as I know.", "If you have access to them, and it is not illegal(!", "), a copy would be greatly appreciated (unfortunately I am currently working on another project, so this would still take time to implement, but it would help me get this working sooner...)."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}]]