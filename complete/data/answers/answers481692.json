[[{"text": ["The only way I can think of to do this amounts to giving the function a name:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fact = lambda x: 1 if x == 0 else x * fact(x-1)\n</code>\n</pre>\n", "senID": 1}, {"text": ["or alternately, for earlier versions of python:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n fact = lambda x: x == 0 and 1 or x * fact(x-1)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Update: using the ideas from the other answers, I was able to wedge the factorial function into a single unnamed lambda:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "Update", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; map(lambda n: (lambda f, *a: f(f, *a))(lambda rec, n: 1 if n == 0 else n*rec(rec, n-1), n), range(10))\n[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\n</code>\n</pre>\n", "senID": 5}, {"text": ["So it's possible, but not really recommended!"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["You can't directly do it, because it has no name.", "But with a helper function like the Y-combinator Lemmy pointed to, you can create recursion by passing the function as a parameter to itself (as strange as that sounds):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # helper function\ndef recursive(f, *p, **kw):\n   return f(f, *p, **kw)\n\ndef fib(n):\n   # The rec parameter will be the lambda function itself\n   return recursive((lambda rec, n: rec(rec, n-1) + rec(rec, n-2) if n&gt;1 else 1), n)\n\n# using map since we already started to do black functional programming magic\nprint map(fib, range(10))\n</code>\n</pre>\n", "senID": 1}, {"text": ["This prints the first ten Fibonacci numbers: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55], "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I have never used Python, but this is probably what you are looking for."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://siddhi.blogspot.com/2007/08/y-combinator-in-python.html"}]}], [{"text": ["Yes.", "I have two ways to do it, and one was already covered.", "This is my preferred way."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (lambda v: (lambda n: n * __import__('types').FunctionType(\n        __import__('inspect').stack()[0][0].f_code, \n        dict(__import__=__import__, dict=dict)\n    )(n - 1) if n &gt; 1 else 1)(v))(5)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you were truly masochistic, you might be able to do it using C extensions, but to echo Greg (hi Greg!", "), this exceeds the capability of a lambda (unnamed, anonymous) functon."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["No.", "(for most values of no)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["without reduce, map, named lambdas or python internals:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (lambda a:lambda v:a(a,v))(lambda s,x:1 if x==0 else x*s(s,x-1))(10)\n</code>\n</pre>\n", "senID": 1}]]