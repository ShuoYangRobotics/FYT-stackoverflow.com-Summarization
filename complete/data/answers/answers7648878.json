[[{"code": "<pre>\n<code>\n [''.join(c.upper() if c != 'a' else c for c in word) for word in the_list]\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; sl = ['albert', 'angela', 'leo', 'bridget']\n&gt;&gt;&gt; [re.sub('[^a]+', lambda m: m.group(0).upper(), s) for s in sl]\n['aLBERT', 'aNGELa', 'LEO', 'BRIDGET']\n</code>\n</pre>\n", "senID": 0}], [{"text": ["This is what str.translate is for:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "str.translate", "tag": "a", "pos": 0, "childList": [{"text": "str.translate", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/stdtypes.html#str.translate"}, {"text": "str.translate", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n import string\n\ntable = string.maketrans(string.ascii_lowercase.replace('a', ''),\n                            string.ascii_uppercase.replace('A', ''))\n\nnames = ['albert', 'angela', 'leo', 'bridget']\n\nprint [name.translate(table) for name in names]\n</code>\n</pre>\n", "senID": 1}, {"text": ["translate takes a 256 character table, so you use string.maketrans to turn the string constants representing the lowercase and uppercase alphabet into a table.", "Any letters not appearing in the table are ignored, so removing a and A will uppercase all other letters."], "childNum": 6, "tag": "p", "senID": 2, "childList": [{"text": "translate", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "string.maketrans", "tag": "a", "pos": -1, "childList": [{"text": "string.maketrans", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/string.html#string.maketrans"}, {"text": "string.maketrans", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "string constants", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/string.html#string-constants"}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "A", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Then just apply the translation table to each name in the list."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["It will be faster than iterating over each name and calling upper on every letter but a.", "While the general Python tools make this easy, this is the tool specifically made for this job."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "upper", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["All of the existing answers seem to want to operate on the characters individually.", "It is simpler and easier just to handle the words as a whole:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; the_list = ['albert', 'angela', 'leo', 'bridget']\n&gt;&gt;&gt; [ word.upper().replace('A', 'a') for word in the_list]\n['aLBERT', 'aNGELa', 'LEO', 'BRIDGET']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The inelegant way is simple"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n lst = ['albert', 'angela', 'leo', 'bridget']\n  lst2 = []\n\n  for wrd in lst:\n      newwrd = ''\n      for ltr in wrd:\n          if ltr != 'a':\n              newwrd += ltr.upper()\n          else: newwrd += ltr\n      lst2.append(newwrd)\n</code>\n</pre>\n", "senID": 1}, {"text": ["However list complrehensions will be more pythonic"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n lst = ['albert', 'angela', 'leo', 'bridget']\n[''.join(ltr.upper() if ltr != 'a' else 'a' for ltr in wrd) for wrd in lst]\n</code>\n</pre>\n", "senID": 3}, {"text": ["This is essentially nested list comprehensions replacing the nested loops.", "This is a much neater solution and more understandable"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["A list comprehension is an expression (ltr.upper() if ltr == 'a') followed by  \"for\" and then option if clauses.", "Here we have two (and I see  @JBernardo did the same thing) acting in same way as nested for loops."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["I hope that helps explain the differences."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["If you want to engage the functional programming paradigm a bit more:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def maybe_upper(c, u):\n    return c.upper() if c in u else c\n\ndef some_upper(s, u):\n    return ''.join(map(lambda c: maybe_upper(c, u), s))\n\n&gt;&gt;&gt; some_upper(\"wahwahweeeewagh\", 'uea')\n'wAhwAhwEEEEwAgh'\n</code>\n</pre>\n", "senID": 1}]]