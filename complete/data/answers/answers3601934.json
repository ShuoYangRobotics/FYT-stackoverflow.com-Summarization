[[{"code": "<pre>\n<code>\n import itertools as it\n\npp = [('a',1),('b',1),('c',1),('d',2),('e',2)]\n\n# with normal zip and slicing\nfor a,b in zip(pp,pp[1:]):\n    if a[1] != b[1]:\n        x=(a[0],b[0])\n        print x\n        break\n# with generators and izip\niterfirst = (b for a,b in pp)\nitersecond = (b for a,b in pp[1:])\niterfirstsymbol = (a for a,b in pp)\nitersecondsymbol = (a for a,b in pp[1:])\niteranswer = it.izip(iterfirstsymbol, itersecondsymbol, iterfirst, itersecond)\n\nprint next((symbol1, symbol2)\n           for symbol1,symbol2, first, second in iteranswer\n           if first != second)\n</code>\n</pre>\n", "senID": 0}, {"text": ["Added my readable generator version."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You could try somethingl like :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [[pp[i][0],pp[i+1][0]] for i in xrange(len(pp)-1) if pp[i][1]!=pp[i+1][1]][0]\n</code>\n</pre>\n", "senID": 1}, {"text": ["(using list comprehension)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["try comparing pp[:-1] to pp[1:], something like"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "pp[:-1]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "pp[1:]", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n [a for a in zip(pp[:-1], pp[1:]) if a[0][1] != a[1][1]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["(look at zip(pp[:-1], pp[1:]) first to see what's going on"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "zip(pp[:-1], pp[1:])", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["edit:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["i guess you'd need"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n ([a[0][0], a[1][0]] for a in zip(pp[:-1], pp[1:]) if a[0][1] != a[1][1]).next()\n</code>\n</pre>\n", "senID": 5}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; import itertools\n&gt;&gt;&gt; pp = [('a',1),('b',1),('c',1),('d',2),('e',2)]\n&gt;&gt;&gt; gb = itertools.groupby(pp, key=lambda x: x[1])\n&gt;&gt;&gt; f = lambda x: list(next(gb)[1])[x][0]\n&gt;&gt;&gt; f(-1), f(0)\n('c', 'd')\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Here is something (simple?", ") with recursion:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def first_diff( seq, key=lambda x:x ):\n    \"\"\" returns the first items a,b of `seq` with `key(a) != key(b)` \"\"\"\n    it = iter(seq)\n    def test(last): # recursive function\n        cur = next(it)\n        if key(last) != key(cur):\n            return last, cur\n        else:\n            return test(cur)\n    return test(next(it))\n\nprint first_diff( pp, key=lambda x:x[1]) # (('c', 1), ('d', 2))\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n pp = [('a',1),('b',1),('c',1),('d',2),('e',2)]\ndef find_first(pp):\n    for i,(a,b) in enumerate(pp):\n        if i == 0: oldb = b\n        else:\n            if b != oldb: return i\n    return None\nprint find_first(pp)\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; pp = [('a',1),('b',1),('c',1),('d',2),('e',2)]\n&gt;&gt;&gt; [[t1, t2] for ((t1, v1), (t2, v2)) in zip(pp, pp[1:]) if v1 != v2] [0]\n['c', 'd']\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}, {"text": ["I like this for clarity...if you find list comprehensions clear.", "It does create two temporary lists: pp[1:] and the zip() result.", "Then it compares all the adjacent pairs and gives you the first change it found."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "all", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["This similar-looking generator expression doesn't create temporary lists and stops processing when it reaches the first change:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import islice, izip\n&gt;&gt;&gt; ([t1, t2] for ((t1, v1), (t2, v2)) in izip(pp, islice(pp, 1, None)) \n...           if v1 != v2\n... ).next()\n['c', 'd']\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 3}, {"text": ["Everybody's examples on this page are more compact than they would be if you wanted to catch errors."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]