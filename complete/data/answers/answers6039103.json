[[{"text": ["Here is one way to write the function"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n depth = lambda L: isinstance(L, list) and max(map(depth, L))+1\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think the idea you are missing is to use max()"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "max()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["easy with recursion"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def flat(l):\n    depths = []\n    for item in l:\n        if isinstance(item, list):\n            depths.append(flat(item))\n    if len(depths) &gt; 0:\n        return 1 + max(depths)\n    return 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Let's first rephrase your requirements slightly."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Now, this can be translated directly to code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def depth(l):\n    if isinstance(l, list):\n        return 1 + max(depth(item) for item in l)\n    else:\n        return 0\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Abusive way:\nSay your list is called mylist\nmybrackets = map(lambda x: 1 if x=='[' else -1, [x for x in str(mylist) if x=='[' or x==']'])maxdepth = max([sum(mybrackets[:i+1]) for i in range(len(mybrackets))]) "], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "mylist", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "childList": []}, {"text": "mybrackets = map(lambda x: 1 if x=='[' else -1, [x for x in str(mylist) if x=='[' or x==']'])maxdepth = max([sum(mybrackets[:i+1]) for i in range(len(mybrackets))])", "childNum": 1, "tag": "code", "childList": [{"text": "", "tag": "br"}]}, {"text": "", "childNum": 0, "tag": "br", "childList": []}]}, {"text": ["This converts your list to a list of opening and closing brackets, then finds the largest number of opening brackets that occur before the corresponding closing bracket occurs."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Did it in one line of python :)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["enjoy"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def f(g,count=0): return count if not isinstance(g,list) else max([f(x,count+1) for x in g])\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Breadth-first, without recursion, and it also works with other sequence types:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from collections import Sequence\nfrom itertools import chain, count\n\ndef depth(seq):\n    for level in count():\n        if not seq:\n            return level\n        seq = list(chain.from_iterable(s for s in seq if isinstance(s, Sequence)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["The same idea, but with much less memory consumption:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from collections import Sequence\nfrom itertools import chain, count\n\ndef depth(seq):\n    seq = iter(seq)\n    try:\n        for level in count():\n            seq = chain([next(seq)], seq)\n            seq = chain.from_iterable(s for s in seq if isinstance(s, Sequence))\n    except StopIteration:\n        return level\n</code>\n</pre>\n", "senID": 3}]]