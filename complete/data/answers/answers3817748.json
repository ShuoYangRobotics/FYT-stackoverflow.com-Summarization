[[{"text": ["This is pretty much missing the point of exceptions."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If the first statement has thrown an exception, the system is in an indeterminate state and you have to treat the following statement as unsafe to run."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you know which statements might fail, and how they might fail, then you can use exception handling to specifically clean up the problems which might occur with a particular block of statements before moving on to the next section."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["So, the only real answer is to handle exceptions around each set of statements that you want to treat as atomic"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["update.", "The way to ignore specific exceptions is to catch the type of exception that you want, test it to see if you want to ignore it and re-raise it if you dont. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n try:\n    do_something1\nexcept TheExceptionTypeThatICanHandleError, e:\n    if e.strerror != 10001:\n        raise\nfinally:\n     clean_up\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note also, that each try statement needs its own finally clause if you want it to have one.", "It wont 'attach itself' to the previous try statement.", "A raise statement with nothing else is the correct way to re-raise the last exception.", "Don't let anybody tell you otherwise."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "try", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "finally", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "try", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "raise", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["What you want are continuations which python doesn't natively provide.", "Beyond that, the answer to your question depends on exactly what you want to do.", "If you want do_something1 to continue regardless of exceptions, then it would have to catch the exceptions and ignore them itself."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "do_something1", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "it", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["if you just want do_something2 to happen regardless of if do_something1 completes, you need a separate try statement for each one."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "do_something2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "do_something1", "childNum": 0, "tag": "code", "childList": []}, {"text": "try", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n try:\n   do_something1()\nexcept:\n   pass\n\ntry:\n   do_something2()\nexcept:\n   pass\n</code>\n</pre>\n", "senID": 5}, {"text": ["etc.", "If you can provide a more detailed example of what it is that you want to do, then there is a good chance that myself or someone smarter than myself can either help you or (more likely) talk you out of it and suggest a more reasonable alternative."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["There's no direct way for the code to go back inside the try-except block.", "If, however, you're looking at trying to execute these different independant actions and keep executing when one fails (without copy/pasting the try/except block), you're going to have to write something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n actions = (\n    do_something1, do_something2, #...\n    )\nfor action in actions:\n    try:\n        action()\n    except Exception, error:\n        pass\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Exceptions are usually raised when a performing task can not be completed in a manner intended by the code due to certain reasons.", "This is usually raised as exceptions.", "Exceptions should be handled and not ignored.", "The whole idea of exception is that the program can not continue in the normal execution flow without abnormal results."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What if you write a code to open a file and read it?", "What if this file does not exist?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It is much better to raise exception.", "You can not read a file where none exists.", "What you can do is handle the exception, let the user know that no such file exists.", "What advantage would be obtained for continuing to read the file when a file could not be opened at all."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In fact the above answers provided by Aaron works on the principle of handling your exceptions. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["you could have all of the do_something's in a list, and iterate through them like this, so it's no so wordy.", "You can use lambda functions instead if you require arguments for the working functions"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "do_something", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n work = [lambda: dosomething1(args), dosomething2, lambda: dosomething3(*kw, **kwargs)]\n\nfor each in work:\n    try:\n        each()\n    except:\n       pass\n\ncleanup()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I posted this recently as an answer to another question.", "Here you have a function that returns a function that ignores (\"traps\") specified exceptions when calling any function.", "Then you invoke the desired function indirectly through the \"trap."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "returns", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def maketrap(*exceptions):\n    def trap(func, *args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except exceptions:\n            return None\n    return trap\n\n# create a trap that ignores all exceptions\ntrapall = maketrap(Exception) \n\n# create a trap that ignores two exceptions\ntrapkeyattrerr = maketrap(KeyError, AttributeError)\n\n# Now call some functions, ignoring specific exceptions\ntrapall(dosomething1, arg1, arg2)\ntrapkeyattrerr(dosomething2, arg1, arg2, arg3)\n</code>\n</pre>\n", "senID": 1}, {"text": ["In general I'm with those who say that ignoring exceptions is a bad idea, but if you do it, you should be as specific as possible as to which exceptions you think your code can tolerate."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]