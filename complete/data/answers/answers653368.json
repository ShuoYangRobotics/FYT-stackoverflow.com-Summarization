[[{"text": ["Using keyword arguments with default values (as suggested by kquinn) is a good idea, but will require you to include the parenthesis:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n @redirect_output()\ndef foo():\n    ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you would like a version that works without the parenthesis on the decorator you will have to account both scenarios in your decorator code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you were using Python 3.0 you could use keyword only arguments for this:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def redirect_output(fn=None,*,destination=None):\n  destination = sys.stderr if destination is None else destination\n  def wrapper(*args, **kwargs):\n    ... # your code here\n  if fn is None:\n    def decorator(fn):\n      return functools.update_wrapper(wrapper, fn)\n    return decorator\n  else:\n    return functools.update_wrapper(wrapper, fn)\n</code>\n</pre>\n", "senID": 4}, {"text": ["In Python 2.x this can be emulated with varargs tricks:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def redirected_output(*fn,**options):\n  destination = options.pop('destination', sys.stderr)\n  if options:\n    raise TypeError(\"unsupported keyword arguments: %s\" % \n                    \",\".join(options.keys()))\n  def wrapper(*args, **kwargs):\n    ... # your code here\n  if fn:\n    return functools.update_wrapper(wrapper, fn[0])\n  else:\n    def decorator(fn):\n      return functools.update_wrapper(wrapper, fn)\n    return decorator\n</code>\n</pre>\n", "senID": 6}, {"text": ["Any of these versions would allow you to write code like this:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n @redirected_output\ndef foo():\n    ...\n\n@redirected_output(destination=\"somewhere.log\")\ndef bar():\n    ...\n</code>\n</pre>\n", "senID": 8}], [{"text": ["A python decorator is called in a fundamentally different way depending on whether you give it arguments or not.", "The decoration is actually just a (syntactically restricted) expression."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In your first example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n @redirect_output(\"somewhere.log\")\ndef foo():\n    ....\n</code>\n</pre>\n", "senID": 2}, {"text": ["the function redirect_output is called with the\ngiven argument, which is expected to return a decorator\nfunction, which itself is called with foo as an argument,\nwhich (finally!", ") is expected to return the final decorated function."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "redirect_output", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["The equivalent code looks like this:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def foo():\n    ....\nd = redirect_output(\"somewhere.log\")\nfoo = d(foo)\n</code>\n</pre>\n", "senID": 5}, {"text": ["The equivalent code for your second example looks like:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n def foo():\n    ....\nd = redirect_output\nfoo = d(foo)\n</code>\n</pre>\n", "senID": 7}, {"text": ["So you can do what you'd like but not in a totally seamless way:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "can", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import types\ndef redirect_output(arg):\n    def decorator(file, f):\n        def df(*args, **kwargs):\n            print 'redirecting to ', file\n            return f(*args, **kwargs)\n        return df\n    if type(arg) is types.FunctionType:\n        return decorator(sys.stderr, arg)\n    return lambda f: decorator(arg, f)\n</code>\n</pre>\n", "senID": 9}, {"text": ["This should be ok unless you wish to use a function as an\nargument to your decorator, in which case the decorator\nwill wrongly assume it has no arguments.", "It will also fail\nif this decoration is applied to another decoration that\ndoes not return a function type."], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["An alternative method is just to require that the\ndecorator function is always called, even if it is with no arguments.", "In this case, your second example would look like this:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n @redirect_output()\ndef foo():\n    ....\n</code>\n</pre>\n", "senID": 12}, {"text": ["The decorator function code would look like this:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n def redirect_output(file = sys.stderr):\n    def decorator(file, f):\n        def df(*args, **kwargs):\n            print 'redirecting to ', file\n            return f(*args, **kwargs)\n        return df\n    return lambda f: decorator(file, f)\n</code>\n</pre>\n", "senID": 14}], [{"text": ["You need to detect both cases, for example using the type of the first argument, and accordingly return either the wrapper (when used without parameter) or a decorator (when used with arguments)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from functools import wraps\nimport inspect\n\ndef redirect_output(fn_or_output):\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(*args, **args):\n            # Redirect output\n            try:\n                return fn(*args, **args)\n            finally:\n                # Restore output\n        return wrapper\n\n    if inspect.isfunction(fn_or_output):\n        # Called with no parameter\n        return decorator(fn_or_output)\n    else:\n        # Called with a parameter\n        return decorator\n</code>\n</pre>\n", "senID": 1}, {"text": ["When using the @redirect_output(\"output.log\") syntax, redirect_output is called with a single argument \"output.log\", and it must return a decorator accepting the function to be decorated as an argument.", "When used as @redirect_output, it is called directly with the function to be decorated as an argument."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "@redirect_output(\"output.log\")", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "redirect_output", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "\"output.log\"", "childNum": 0, "tag": "code", "childList": []}, {"text": "@redirect_output", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Or in other words: the @ syntax must be followed by an expression whose result is a function accepting a function to be decorated as its sole argument, and returning the decorated function.", "The expression itself can be a function call, which is the case with @redirect_output(\"output.log\").", "Convoluted, but true :-)"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "@", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "@redirect_output(\"output.log\")", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Generally you can give default arguments in Python..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def redirect_output(fn, output = stderr):\n    # whatever\n</code>\n</pre>\n", "senID": 1}, {"text": ["Not sure if that works with decorators as well, though.", "I don't know of any reason why it wouldn't."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Have you tried keyword arguments with default values?", "Something like"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def decorate_something(foo=bar, baz=quux):\n    pass\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You can use default argument like that:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import sys\ndef redirect_output(fn, output = sys.stderr):\n    ...\n</code>\n</pre>\n", "senID": 1}, {"text": ["Not however, that default arguments are bound when function definition is parsed.", "So if you'd redirect all of stderr elsewhere, it won't work.", "So the other option is \"magic\" default value:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def redirect_output(fn, output = '#stderr#'):\n    if(output == '#stderr#')\n       import sys\n       output = sys.stderr\n    #you might also use None as value to redirect nowhere.\n    if(output == None)\n       import os.path\n       if(os.path.exists('/dev/null')) \n          # one of many UNIX flavours\n          output = open('/dev/null','w')\n       else:\n          # Windows of something like that\n          output = open('nul:', 'w')           \n\n    ...\n</code>\n</pre>\n", "senID": 3}, {"text": ["Now this way following will work as expected:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import sys\nsys.stderr = open('/var/log/error.log','w+')\n\n@redirect_output\ndef foo():\n   ...\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Building on vartec's answer:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n imports sys\n\ndef redirect_output(func, output=None):\n    if output is None:\n        output = sys.stderr\n    if isinstance(output, basestring):\n        output = open(output, 'w') # etc...\n    # everything else...\n</code>\n</pre>\n", "senID": 1}]]