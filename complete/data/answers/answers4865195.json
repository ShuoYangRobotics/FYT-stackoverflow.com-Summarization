[[{"text": ["Edit: Only proposing this since the example isn't unittest-able (and I'm assuming the beginner students will just be confused by the constraint)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you are just concerned with the output matching what you are looking for, why not just use some \"silly\" bash?", "Something like:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n echo -e \"2\\n3\" | python test.py | grep -q \"The sum is 5\" &amp;&amp; echo \"Success\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you are doing relatively trivial programs like this, then this should be a sufficient, or good enough, solution that requires little effort."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You can't really unit-test that.", "One of the things about writing unit tests is you often need to write your code differently to allow it to be unit-tested.", "So in this case, you would need to factor out the calls to input into a separate function, which you can then patch."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def my_input(prompt):\n    return input(prompt)\n\ndef main():\n    a = int(eval(my_input(\"Enter an integer: \"))\n</code>\n</pre>\n", "senID": 1}, {"text": ["etc.", "Now your test can monkey-patch myscript.my_input to return the values you want."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "myscript.my_input", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["If you need more complicated interaction with command-line programs than can be provided with echo then you might want to look at expect."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "echo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "expect", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["From the docs:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "docs", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/datamodel.html"}]}, {"text": ["So following this logic, something like this seems to work.", "Create a file with your required input:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n $ cat sample_stdin.txt\nhello\nworld\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then redirect sys.stdin to point to that file:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "sys.stdin", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nimport sys\n\nfh = open('sample_stdin.txt', 'r')\nsys.stdin = fh\n\nline1 = raw_input('foo: ')\nline2 = raw_input('bar: ')\n\nprint line1\nprint line2\n</code>\n</pre>\n", "senID": 4}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n $python redirecting_stdin.py\nfoo: bar: hello\nworld\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Short answer, don't do that.", "You have to design for testability.", "This means providing an simple way to provide interfaces for things to use to talk to system resources so you can provide alternate implementations of those interfaces when testing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The monkey patching solution described in the other answer does work, but it's the most primitive of your options.", "Personally, I would write an interface class for user interaction.", "For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class UserInteraction(object):\n    def get_input(self):\n        raise NotImplementedError()\n    def send_output(self, output):\n        raise NotImplementedError()\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then things that need to talk to the user can get an instance of your class as a constructor or function argument.", "The default implementation can call the actual input function or whatever, but there is a version used for testing that provides sample input or buffers up the output so it can be checked."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "input", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["This, by the way, is why I hate Singleton (which can't really be effectively implemented in Python anyway).", "It destroys your ability to test by making an instance which is globally accessible that can't be stubbed out with a stub version for testing."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["My suggestion is to refactor your code using one of the two frameworks that Python provides for unit-testing: unittest (aka PyUnit) and doctest."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "unittest", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "doctest", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["This is an example using unittest:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "unittest", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import unittest\n\ndef adder(a, b):\n    \"Return the sum of two numbers as int\"\n    return int(a) + int(b)\n\nclass TestAdder(unittest.TestCase):\n    \"Testing adder() with two int\"\n    def test_adder_int(self):\n        self.assertEqual(adder(2,3), 5)\n\n    \"Testing adder() with two float\"\n    def test_adder_float(self):\n        self.assertEqual(adder(2.0, 3.0), 5)\n\n    \"Testing adder() with two str - lucky case\"\n    def test_adder_str_lucky(self):\n        self.assertEqual(adder('4', '1'), 5)\n\n    \"Testing adder() with two str\"\n    def test_adder_str(self):\n        self.assertRaises(ValueError, adder, 'x', 'y')\n\nif __name__ == '__main__':\n    unittest.main()\n</code>\n</pre>\n", "senID": 2}, {"text": ["And this is an example using doctest:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "doctest", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # adder.py\n\ndef main(a, b):\n    \"\"\"This program calculate the sum of two numbers. \n    It prints an int (see %d in print())\n\n    &gt;&gt;&gt; main(2, 3)\n    The sum is 5\n\n    &gt;&gt;&gt; main(3, 2)\n    The sum is 5\n\n    &gt;&gt;&gt; main(2.0, 3)\n    The sum is 5\n\n    &gt;&gt;&gt; main(2.0, 3.0)\n    The sum is 5\n\n    &gt;&gt;&gt; main('2', '3')\n    Traceback (most recent call last):\n        ...\n    TypeError: %d format: a number is required, not str\n    \"\"\"\n    c = a + b\n    print(\"The sum is %d\" % c)\n\ndef _test():\n    import doctest, adder\n    return doctest.testmod(adder)\n\nif __name__ == '__main__':\n    _test()\n</code>\n</pre>\n", "senID": 4}, {"text": ["With doctest I made another example using input() (I assume you are using Python 3.X):"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "doctest", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # adder_ugly.py\n\ndef main():\n    \"\"\"This program calculate the sum of two numbers.\n    It prints an int (see %d in print())\n\n    &gt;&gt;&gt; main()\n    The sum is 5\n    \"\"\"\n    a = int(input(\"Enter an integer: \"))\n    b = int(input(\"Enter another integer: \"))\n    c = a+b\n    print(\"The sum is %d\" % c)\n\n\ndef _test():\n    import doctest, adder_ugly\n    return doctest.testmod(adder_ugly)\n\nif __name__ == '__main__':\n    _test()\n</code>\n</pre>\n", "senID": 6}, {"text": ["I would run each of the above mentioned examples with the -v option:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "-v", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n python adder_ugly.py -v\n</code>\n</pre>\n", "senID": 8}, {"text": ["For your reference see:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["http://docs.python.org/py3k/library/unittest.html?highlight=unittest#unittest"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "http://docs.python.org/py3k/library/unittest.html?highlight=unittest#unittest", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/py3k/library/unittest.html?highlight=unittest#unittest"}]}, {"text": ["and"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["http://docs.python.org/py3k/library/doctest.html#module-doctest"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "http://docs.python.org/py3k/library/doctest.html#module-doctest", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/py3k/library/doctest.html#module-doctest"}]}], [{"text": ["You may be able to mock the input function to supply inputs from your test environment."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "input", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This seems like it might work.", "It's untested."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class MockInput( object ):\n    def __init__( self, *values ):\n        self.values= list(values)\n        self.history= []\n    def __call__( self, *args, **kw ):\n        try:\n            response= self.values.pop(0)\n            self.history.append( (args, kw, response) )\n            return response\n        except IndexError:\n            raise EOFError()\n\nclass TestSomething( unittest.TestCase ):\n    def test_when_input_invalid( self ):\n        input= MockInput( \"this\", \"and\", \"that\" )\n        # some test case based on the input function\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Replace sys.stdin with a StringIO (or cStringIO) object."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]