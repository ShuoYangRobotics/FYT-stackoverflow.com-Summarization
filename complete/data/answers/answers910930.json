[[{"text": ["Well ...", "If you expect to really fill that space, then you're probably best off with a densely packed matrix-like structure, basically voxels."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "fill", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"href": "http://en.wikipedia.org/wiki/Voxel", "text": "voxels", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["If you don't expect to fill it, look into something a bit more optimized.", "I would start by looking at octrees, which are often used for things like this."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "octrees", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Octree"}]}], [{"text": ["Here's another common approach"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class Point( object ):\n    def __init__( self, x, y, z, data ):\n        self.x, self.y, self.z = x, y, z\n        self.data = data\n    def distFrom( self, x, y, z )\n        return math.sqrt( (self.x-x)**2 + (self.y-y)**2 + (self.z-z)**2 )\n\ndatabase = [ Point(x,y,z,data), Point(x,y,z,data), ... ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Let's look at your use cases."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Get the point where x=1,y=2,z=3."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n [ p for p in database if (p.x, p.y, p.z) == ( 1, 2, 3 ) ]\n</code>\n</pre>\n", "senID": 4}, {"text": ["Getting all points where y=2."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n [ p for p in database if p.y == 2 ]\n</code>\n</pre>\n", "senID": 6}, {"text": ["Getting all points within 3 units of position x=1,y=2,z=3."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n [ p for p in database if p.distFrom( 1, 2, 3 ) &lt;= 3.0 ]\n</code>\n</pre>\n", "senID": 8}, {"text": ["Getting all points where point.getType() == \"Foo\""], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n [ p for p in database if type(p.data) == Foo ]\n</code>\n</pre>\n", "senID": 10}], [{"text": ["One advantage of numpy is that it is blazingly fast, \ne.g.", "calculating the pagerank of a 8000x8000 adjacency matrix takes milliseconds.", "Even though numpy.ndarray will only accept numbers, you can store number/id-object mappings in an external hash-table i.e.", "dictionary (which in again is a highly optimized datastructure). "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy.ndarray", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["The slicing would be as easy as list slicing in python:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from numpy import arange\n\n&gt;&gt;&gt; the_matrix = arange(64).reshape(4, 4, 4)\n&gt;&gt;&gt; print the_matrix[0][1][2]\n    6\n&gt;&gt;&gt; print the_matrix[0][1]\n    [4 5 6 7]\n&gt;&gt;&gt; print the_matrix[0]\n    [[ 0  1  2  3]\n    [ 4  5  6  7]\n    [ 8  9 10 11]\n    [12 13 14 15]]\n</code>\n</pre>\n", "senID": 2}, {"text": ["If you wrap some of your desired functions (distances) around some core matrix and a id-object-mapping hash, you could have your application running within a short period of time."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Good luck!"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["You can do the first 2 queries with slicing in numpy :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = numpy.zeros((4, 4, 4))\na[1, 2, 3] # The point at x=1,y=2,z=3\na[:, 2, :] # All points where y=2\n</code>\n</pre>\n", "senID": 1}, {"text": ["For the third one if you mean \"getting all points within a sphere of radius 3 and centered at x=1,y=2,z=3\", you will have to write a custom function to do that ; if you want a cube you can proceed with slicing, e.g."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a[1:3, 1:3, 1:3] # The 2x2x2 array sliced from the center of 'a'\n</code>\n</pre>\n", "senID": 3}, {"text": ["For the fourth query if the only data stored in your array is the cells type, you could encode it as integers:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n FOO = 1\nBAR = 2\na = numpy.zeros((4, 4, 4), dtype=\"i\")\na[1, 2, 3] = FOO\na[3, 2, 1] = BAR\ndef filter(a, type_code):\n    coords = []\n    for z in range(4):\n        for y in range(4):\n            for x in range(4):\n                if a[x, y, z] == type_code:\n                    coords.append((x, y, z))\n    return coords\nfilter(a, FOO) # =&gt; [(1, 2, 3)]\n</code>\n</pre>\n", "senID": 5}, {"text": ["numpy looks like the good tool for doing what you want, as the arrays will be smaller in memory, easily accessible in C (or even better, cython !", ") and extended slicing syntax will avoid you writing code."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "cython", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.cython.org/"}]}], [{"text": ["Here's an approach that may work."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Each point is a 4-tuple (x,y,z,data), and your database looks like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n database = [ (x,y,z,data), (x,y,z,data), ... ]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Let's look at your use cases."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Get the point where x=1,y=2,z=3."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n [ (x,y,z,data) for x,y,z,data in database if (x,y,z) == (1,2,3) ]\n</code>\n</pre>\n", "senID": 5}, {"text": ["Getting all points where y=2."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n [ (x,y,z,data) for x,y,z,data in database if y == 2 ]\n</code>\n</pre>\n", "senID": 7}, {"text": ["Getting all points within 3 units of position x=1,y=2,z=3."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n [ (x,y,z,data) for x,y,z,data in database if math.sqrt((x-1)**2+(y-2)**2+(z-3)**2)&lt;=3.0 ]\n</code>\n</pre>\n", "senID": 9}, {"text": ["Getting all points where point.getType() == \"Foo\""], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n [ (x,y,z,data) for x,y,z,data in database if type(data) == Foo ]\n</code>\n</pre>\n", "senID": 11}], [{"text": ["When to use Binary Space Partitioning, Quadtree, Octree?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "When to use Binary Space Partitioning, Quadtree, Octree?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/99796/when-to-use-binary-space-partitioning-quadtree-octree"}]}, {"text": ["3d array imo is worthless.", "Especially if your world is dynamic.", "You should decide between BSP, Quadtree or Octtree.", "BSP would do just fine.", "Since your world is in 3d, you need planes when splitting the bsp, not lines."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Cheers !"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Edit"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I guess this is alright if always know how large you data set is and that it never changes, i.e.", "if more points are added to it that in turn are out of bound.", "You would have to resize the 3d array in that case. "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Using a dictionary with x,y,z tuples as keys is another solution, if you want a relatively simple solution with the standard library."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import math\n\n#use indexing to get point at (1,2,3): points[(1,2,3)]\nget_points(points, x=None, y=None, x=None):\n    \"\"\"returns dict of all points with given x,y and/or z values.  Call using keywords (eg get_points(points, x=3)\"\"\"\n    filteredPoints = points.items()\n    if x:\n        filteredPoints = [p for p in filteredPoints if p[0][0] == x]\n    if y:\n        filteredPoints = [p for p in filteredPoints if p[0][1] == y]\n    if z:\n        filteredPoints = [p for p in filteredPoints if p[0][0] == x]\n    return dict(filteredPoints)\n\nget_point_with_type(points, type_):\n    \"\"\"returns dict of points with point.getType() == type_\"\"\"\n    filteredPoints = points.items()\n    return dict((position,data) for position,data in points.iterItems() if data.getType == type_)\n\nget_points_in_radius(points,x,y,z,r):\n    \"\"\"Returns a dict of points within radius r of point (x,y,z)\"\"\"\n    def get_dist(x1,y1,z1,x2,y2,z3):\n        return math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2))\n    return dict((position,data) for position,data in points.iterItems() if get_dist(x,y,z, *position) &lt;= r))\n</code>\n</pre>\n", "senID": 1}, {"text": ["And due to python referencing, you can alter \"points\" in the returned dictionaries, and have the original points change as well (I think)."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It depends upon the precise configuration of your system, but from the example you give you are using integers and discrete points, so it would probably be appropriate to consider Sparse Matrix data structures.  "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Sparse Matrix", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Sparse%5Fmatrix"}]}]]