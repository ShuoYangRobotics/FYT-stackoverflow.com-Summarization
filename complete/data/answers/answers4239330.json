[[{"text": ["I think you're overthinking this.", "You just need to check within the loop if the current letter is O or Q, and if so add a U."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; for letter in prefixes:\n        if letter in ('O', 'Q'):  # if the letter is O or Q\n            print letter + 'u' + suffix\n        else:\n            print letter + suffix\n\n\nJack\nKack\nLack\nMack\nNack\nOuack\nPack\nQuack\n</code>\n</pre>\n", "senID": 0}], [{"text": ["My solution would be:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n prefixes = list('JKLMNP')\nprefixes.extend(['Ou', 'Qu'])\nsuffix = 'ack'\nfor pref in prefixes:\n    print pref + suffix\n</code>\n</pre>\n", "senID": 1}, {"text": ["It is compact and contains very few modifications of the original."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I like data-driven code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n endings = ['ack', 'uack']\nspecials = ['O','Q']\nprefixes = 'JKLMNOPQ'\nsuffixes = dict(zip(prefixes, [endings[p in specials] for p in prefixes]))\nfor letter in prefixes:\n    print letter + suffixes[letter]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I prefer the Gordian Knot approach:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n print '\\n'.join(['Jack', 'Kack', 'Lack', 'Mack', 'Nack', 'Ouack', 'Pack', 'Quack'])\n</code>\n</pre>\n", "senID": 1}, {"text": ["Strictly speaking, that's just a (somewhat radical) modification."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Stuff that, Perl guy."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["All kidding aside, you could do it as the others have mentioned by special casing the \"O\" and \"Q\".", "A (very) slightly more general approach is to think of the extra vowels not as a special case but rather as the only \"visible\" members of a general case:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n suffixes = ['ack'] * 8\nprefixes = 'JKLMNOPQ'\ninfixes = ',,,,,u,,u'.split(',')\n</code>\n</pre>\n", "senID": 5}, {"text": ["The split of the infixes string returns empty strings surrounding the consecutive commas, so the 'u's are the only non-empty elements and they fall in the right places for the final result."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["This makes three iterables (think lists, but strings count too) where all of the parts are lined up in the correct slots.", "This is enough of a shift that you can trade the old loop for a zip, which is probably not the intent of the exercise but is still a pythonic technique.", "Now you just need to run a zipper down the three, which is what the zip function is for, of course."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["The only wrinkle is that zip gives you a out a list of string pairs and we want whole strings, which is what a ''.join is for.", "They are processed by a list comprehension, which you will definitely want to learn if you don't already know:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n result = [''.join(pair) for pair in zip(infixes, suffixes)]\nresult = [''.join(pair) for pair in zip(prefixes, result)]\n</code>\n</pre>\n", "senID": 9}, {"text": ["All that is left is to print:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n print '\\n'.join(result)\n</code>\n</pre>\n", "senID": 11}, {"text": ["To paraphrase a great man, my disclaimer: In theory, I can prove the correctness of this code, but I have not run it, so there may be bugs."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"code": "<pre>\n<code>\n suffix = 'ack'\nprefixes = list('JKLMNP')\nprefixes += ['Qu', 'Ou']\nprefixes.sort()\n\nfor prefix in prefixes:\n    print prefix + suffix\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Being a Perl guy I couldn't help but give you a shorter solution than everyone else's :p"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n prefixes = 'JKLMNOPQ' \nsuffix = 'ack'\nfor letter in prefixes:\n if letter in ('O','Q'):\n  letter+=\"u\"\n print letter+suffix\n</code>\n</pre>\n", "senID": 1}, {"text": ["PS: I take it that the exercise was to modify the given code rather than to revamp it, otherwise there are ways of shrinking it further, within the confines of PEP8 that is:)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "PEP8", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0008/"}]}]]