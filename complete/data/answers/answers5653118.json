[[{"text": ["Firstly,  your regex seems to not work properly.", "The Key field should have values which could include f, right?", "So its group should not be ([0-9A-Ea-e]+) but instead ([0-9A-Fa-f]+).", "Also, it is a good - actually, a wonderful - practice to prefix the regex string with r when dealing with regexes because it avoids problems with \\ escaping characters.", "(If you do not understand why to do it, look at raw strings)"], "childNum": 8, "tag": "p", "senID": 0, "childList": [{"text": "Key", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "f", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "([0-9A-Ea-e]+)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "([0-9A-Fa-f]+)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "wonderful", "childNum": 0, "tag": "em", "pos": 3, "childList": []}, {"text": "r", "childNum": 0, "tag": "code", "pos": 4, "childList": []}, {"text": "\\", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/re.html", "text": "raw strings", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Now, my approach to the problem.", "First, I would create a regex without pipes:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; regex = r\"(Key):[\\s]*([0-9A-Fa-f]+)[\\s]*\" \\\n...     r\"(Index):[\\s]*([0-9]+)[\\s]*\" \\\n...     r\"(Field 1):[\\s]*([0-9]+)[\\s]*\" \\\n...     r\"(Field 2):[\\s]*([0-9 A-Za-z]+)[\\s]*\" \\\n...     r\"(Field 3):[\\s]*([-+]?[0-9]+)[\\s]*\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["With this change, the findall() will return only one tuple of found groups for an entire line.", "In this tuple, each key is followed by its value:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "findall()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; re.findall(regex, line)\n[('Key', 'af12d9', 'Index', '0', 'Field 1', '1234', 'Field 2', '1234 Ring ', 'Field 3', '-10')]\n</code>\n</pre>\n", "senID": 4}, {"text": ["So I get the tuple..."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; found = re.findall(regex, line)[0]\n&gt;&gt;&gt; found\n('Key', 'af12d9', 'Index', '0', 'Field 1', '1234', 'Field 2', '1234 Ring ', 'Field 3', '-10')\n</code>\n</pre>\n", "senID": 6}, {"text": ["...and using slices I get only the keys..."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "slices", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/release/2.3.5/whatsnew/section-slices.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; found[::2]\n('Key', 'Index', 'Field 1', 'Field 2', 'Field 3')\n</code>\n</pre>\n", "senID": 8}, {"text": ["...and also only the values:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; found[1::2]\n('af12d9', '0', '1234', '1234 Ring ', '-10')\n</code>\n</pre>\n", "senID": 10}, {"text": ["Then I create a list of tuples containing the key and its corresponding value with zip()function:"], "childNum": 2, "tag": "p", "senID": 11, "childList": [{"text": "zip()function", "tag": "a", "pos": 0, "childList": [{"text": "zip()", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/functions.html#zip"}, {"text": "zip()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; zip(found[::2], found[1::2])\n[('Key', 'af12d9'), ('Index', '0'), ('Field 1', '1234'), ('Field 2', '1234 Ring '), ('Field 3', '-10')]\n</code>\n</pre>\n", "senID": 12}, {"text": ["The gran finale is to pass the list of tuples to the dict() constructor:"], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "gran finale", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "dict()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dict(zip(found[::2], found[1::2]))\n{'Field 3': '-10', 'Index': '0', 'Field 1': '1234', 'Key': 'af12d9', 'Field 2': '1234 Ring '}\n</code>\n</pre>\n", "senID": 14}, {"text": ["I find this solution the best, but it is indeed a subjective question in some sense.", "HTH anyway :)"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}], [{"text": ["OK, with help of brandizzi, I have found THE answer to this question. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Solution: "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n listconfig = []\nfor line in list_of_strings:\n    matched = re.search(r\"Key:[\\s]*(?P&lt;key&gt;[0-9A-Fa-f]+)[\\s]*\" \\ \n                        r\"(Index:[\\s]*(?P&lt;index&gt;[0-9]+)[\\s]*)?\" \\ \n                        r\"(Field 1:[\\s]*(?P&lt;field_1&gt;[0-9]+)[\\s]*)?\" \\ \n                        r\"(Field 2:[\\s]*(?P&lt;field_2&gt;[0-9 A-Za-z]+)[\\s]*)?\" \\ \n                        r\"(Field 3:[\\s]*(?P&lt;field_3&gt;[-+]?[0-9]+)[\\s]*)?\", line) \n    if matched:\n        print matched.groupdict()\n        listconfig.append(matched.groupdict())\n</code>\n</pre>\n", "senID": 2}], [{"code": "<pre>\n<code>\n import re\n\nstr_list = \"Key: af12d9 Index: 0 Field 1: 1234 Field 2: 1234 Ring Field 3: -10\"\nresults = {}\nfor match in re.findall(\"(.*?):\\ (.*?)\\ \", str_list+' '):\n    results[match[0]] = match[1]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["The pattern in your example is probably not matching your example data due to the \"Ring\".", "Here is some code which might help:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n# the keys to look for\nkeys = ['Key','Index','Field 1','Field 2','Field 3']\n# a pattern for those keys in exact order\npattern = ''.join([\"(%s):(.*)\" % key for key in keys])\n# sample data\ndata = \"Key: af12d9 Index: 0 Field 1: 1234 Field 2: 1234 Ring Field 3: -10\"\n# look for the pattern\nhit = re.match(pattern,data)\nif hit:\n    # get the matched elements\n    groups = hit.groups()\n    # group them in pairs and create a dict\n    d = dict(zip(groups[::2], groups[1::2]))\n    # print result\n    print d\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could use a parser library.", "I know Lepl, so will use that, but because it is implemented in Python it will not be so efficient.", "However, the solution is fairly short and, I hope, very easy to understand:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def parser():\n  key = (Drop(\"Key:\") &amp; Regexp(\"[0-9a-fA-F]+\")) &gt; 'key'\n  index = (Drop(\"Index:\") &amp; Integer()) &gt; 'index'\n  def Field(n):\n      return (Drop(\"Field\" + str(n)) &amp; Integer()) &gt; 'field'+str(n)\n  with DroppedSpaces():\n      line = (key &amp; index &amp; Field(1) &amp; Field(2) &amp; Field(3)) &gt;&gt; make_dict\n      return line[:]\np = parser()\nprint(p.parse_file(...))\n</code>\n</pre>\n", "senID": 1}, {"text": ["It should also be relatively simple to handle a variable number of fields."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Note that the above is not tested (I need to get to work), but should be about right.", "In particular, it should return a list of dictionaries, as required."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Your solution would perform better if you did this[*]:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nfrom itertools import imap\n\nregex = re.compile(flags=re.VERBOSE, pattern=r\"\"\"\n    Key:\\s*(?P&lt;key&gt;[0-9A-Fa-f]+)\\s*\n    Index:\\s*(?P&lt;index&gt;[0-9]+)\\s*\n    Field\\s+1:\\s*(?P&lt;field_1&gt;[0-9]+)\\s*\n    Field\\s+2:\\s*(?P&lt;field_2&gt;[0-9A-Za-z]+)\\s*\n    Field\\s+3:\\s*(?P&lt;field_3&gt;[-+]?[0-9]+)\\s*\n\"\"\")\n\nlist_of_strings = [\n    'Key: af12d9 Index: 0 Field 1: 1234 Field 2: 1234 Field 3: -10',\n    'hey joe!',\n    ''\n]\n\nlistconfig = [\n    match.groupdict() for match in imap(regex.search, list_of_strings) if match\n]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Also, it'd be more succinct.", "Also, I fixed your broken regex pattern."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["BTW, the result of the above would be:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n [{'index': '0', 'field_2': '1234', 'field_3': '-10', 'key': 'af12d9', 'field_1': '1234'}]\n</code>\n</pre>\n", "senID": 4}, {"text": ["[*] Actually - no, it wouldn't.", "I timeit'ed both and neither is faster than the other.", "Still, I like mine better."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}]]