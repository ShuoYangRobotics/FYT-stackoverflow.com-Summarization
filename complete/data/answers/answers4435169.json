[[{"text": ["Don't prematurely optimize.", "If you have no reason to believe there's a speed bottleneck caused by string concatenations then just stick with + and +=:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "+=", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n s  = 'foo'\ns += 'bar'\ns += 'baz'\n</code>\n</pre>\n", "senID": 1}, {"text": ["That said, if you're aiming for something like Java's StringBuilder, the canonical Python idiom is to add items to a list and then use str.join to concatenate them all at the end:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "str.join", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n l = []\nl.append('foo')\nl.append('bar')\nl.append('baz')\n\ns = ''.join(l)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Don't."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["That is, for most cases you are better off generating the whole string in one go rather then appending to an existing string."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For example, don't do: obj1.name + \":\" + str(obj1.count)"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "obj1.name + \":\" + str(obj1.count)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Instead: use \"%s:%d\" % (obj1.name, obj1.count)"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "\"%s:%d\" % (obj1.name, obj1.count)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["That will be easier to read and more efficient."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If you only have one reference to a string and you concatenate another string to the end, Python now special cases this and tries to extend the string in place."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The end result is that the operation is amortized O(n)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["eg"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n s = \"\"\nfor i in range(n):\n    s+=str(n)\n</code>\n</pre>\n", "senID": 3}, {"text": ["used to be O(n^2), but now it is O(n)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["From the source (stringmodule.c)"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n PyString_ConcatAndDel(register PyObject **pv, register PyObject *w)\n{\n    PyString_Concat(pv, w);\n    Py_XDECREF(w);\n}\n\n\n/* The following function breaks the notion that strings are immutable:\n   it changes the size of a string.  We get away with this only if there\n   is only one module referencing the object.  You can also think of it\n   as creating a new string object and destroying the old one, only\n   more efficiently.  In any case, don't use this if the string may\n   already be known to some other part of the code...\n   Note that if there's not enough memory to resize the string, the original\n   string object at *pv is deallocated, *pv is set to NULL, an \"out of\n   memory\" exception is set, and -1 is returned.  Else (on success) 0 is\n   returned, and the value in *pv may or may not be the same as on input.\n   As always, an extra byte is allocated for a trailing \\0 byte (newsize\n   does *not* include that), and a trailing \\0 byte is stored.\n*/\n</code>\n</pre>\n", "senID": 6}], [{"text": ["If you need to do many append operations to build a large string, you can use StringIO or cStringIO.", "The interface is like a file.", "ie: you write to append text to it."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "StringIO", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stringio.html"}, {"text": "write", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["If you're just appending two strings then just use +."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "+", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"code": "<pre>\n<code>\n str1 = \"Hello\"\nstr2 = \"World\"\nnewstr = \" \".join((str1, str2))\n</code>\n</pre>\n", "senID": 0}, {"text": ["That joins str1 and str2 with a space as separators.", "You can also do \"\".join(str1, str2, ...).", "str.join() takes an iterable, so you'd have to put the strings in a list or a tuple."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "\"\".join(str1, str2, ...)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "str.join()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["That's about as efficient as it gets for a builtin method."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["it really depends on your application.", "If you're looping through hundreds of words and want to append them all into a list, "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n .join()\n</code>\n</pre>\n", "senID": 1}, {"text": ["is better.", "But if you're putting together a long sentence, you're better off using "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n '+='\n</code>\n</pre>\n", "senID": 3}]]