[[{"text": ["If you don't like declaring a function before a use and declaring a function after is impossible, what about declaring it in some other module?", "Technically you still declare it before but it's clean."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "before", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "after", "childNum": 0, "tag": "em", "pos": -1, "childList": []}]}, {"text": ["You can create a recursion like the following:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def foo():\n    bar()\n\ndef bar():\n    foo()\n</code>\n</pre>\n", "senID": 2}, {"text": ["(infinite, yes, but it works)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Python's functions are anonymous just like values are anonymous, yet they can be bound to a name.", "In the above code, foo() does not call a function with the name foo, it calls a function that happens to be bound to the name foo at the point the call is made.", "It is possible to redeclare foo somewhere else down the code and bar will therefore call the new function."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "foo()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "childList": []}, {"text": "bar", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Your 'problem' simply cannot be solved because it's precisely like asking to get a variable which has not been declared."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["(actually, it's not really 'anonymous', but I don't know what to call it)"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["What you can do is to wrap the invocation into a function of it's own."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So that"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n foo()\n\ndef foo():\n    print \"Hi!\"\n</code>\n</pre>\n", "senID": 2}, {"text": ["will break, but"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def bar():\n    foo()\n\ndef foo():\n    print \"Hi!\"\n\nbar()\n</code>\n</pre>\n", "senID": 4}, {"text": ["will be working properly."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["General rule in Python is not that function should be defined higher in the code (like in Pascal), but that it should be defined before it's usage."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Hope that helps.  "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["No, I don't believe there is any way to forward-declare a function in Python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Imagine you are the Python interpreter.", "When you get to the line "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n print \"\\n\".join([str(bla) for bla in sorted(mylist, cmp = cmp_configs)])\n</code>\n</pre>\n", "senID": 2}, {"text": ["either you know what cmp_configs is or you don't.", "In order to proceed, you have to\nknow cmp_configs.", "It doesn't matter if there is recursion."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If the call to cmp_configs is inside its own function definition, you should be fine.", "I'll give an example."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def a():\n  b()  # b() hasn't been defined yet, but that's fine because at this point, we're not\n       # actually calling it. We're just defining what should happen when a() is called.\n\na()  # This call fails, because b() hasn't been defined yet, \n     # and thus trying to run a() fails.\n\ndef b():\n  print \"hi\"\n\na()  # This call succeeds because everything has been defined.\n</code>\n</pre>\n", "senID": 1}, {"text": ["In general, putting your code inside functions (such as main()) will resolve your problem; just call main() at the end of the file."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["\"just reorganize my code so that I don't have this problem.", "\"  Correct.", "Easy to do.", "Always works."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You can always provide the function prior to it's reference."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["\"However, there are cases when this is probably unavoidable, for instance when implementing some forms of recursion\""], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Can't see how that's even remotely possible.", "Please provide an example of a place where you cannot define the function prior to it's use."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you kick-start your script through the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if __name__==\"__main__\":\n   main()\n</code>\n</pre>\n", "senID": 1}, {"text": ["then you probably do not have to worry about things like \"forward declaration\".", "You see, the interpreter would go loading up all your functions and then start your main() function.", "Of course, make sure you have all the imports correct too ;-)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Come to think of it, I've never heard such a thing as \"forward declaration\" in python... but then again, I might be wrong ;-)"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["There is no such thing in python like forward declaration.", "You just have to make sure that your function is declared before it is needed.", "Note that the body of a function isn't interpreted until the function is executed."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Consider the following example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def a():\n   b() # won't be resolved until a is invoked.\n\ndef b(): \n   print \"hello\"\n\na() # here b is already defined so this line won't fail.\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can think that a body of a function is just another script that will be interpreted once you call the function."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["You can't forward-declare a function in Python.", "If you have logic executing before you've defined functions, you've probably got a problem anyways.", "Put your action in an if __name__ == '__main__' at the end of your script (by executing a function you name \"main\" if it's non-trivial) and your code will be more modular and you'll be able to use it as a module if you ever need to."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "if __name__ == '__main__'", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Also, replace that list comprehension with a generator express (i.e., print \"\\n\".join(str(bla) for bla in sorted(mylist, cmp=cmp_configs)) )"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Also, don't use cmp, which is deprecated.", "Use \"key\" and provide a less-than function. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Now wait a minute.", "When your module reaches the print statement in your example, before cmp_configs has been defined, what exactly is it that you expect it to do?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "cmp_configs", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["If your posting of a question using print is really trying to represent something like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n fn = lambda mylist:\"\\n\".join([str(bla)\n                         for bla in sorted(mylist, cmp = cmp_configs)])\n</code>\n</pre>\n", "senID": 2}, {"text": ["then there is no requirement to define cmp_configs before executing this statement, just define it later in the code and all will be well."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "cmp_configs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Now if you are trying to reference cmp_configs as a default value of an argument to the lambda, then this is a different story:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "cmp_configs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n fn = lambda mylist,cmp_configs=cmp_configs : \\\n    \"\\n\".join([str(bla) for bla in sorted(mylist, cmp = cmp_configs)])\n</code>\n</pre>\n", "senID": 5}, {"text": ["Now you need a cmp_configs variable defined before you reach this line.  "], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "cmp_configs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["[EDIT - this next part turns out not to be correct, since the default argument value will get assigned when the function is compiled, and that value will be used even if you change the value of cmp_configs later."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Fortunately, Python being so type-accommodating as it is, does not care what you define as cmp_configs, so you could just preface with this statement:"], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "what", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "cmp_configs", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n cmp_configs = None\n</code>\n</pre>\n", "senID": 9}, {"text": ["And the compiler will be happy.", "Just be sure to declare the real cmp_configs before you ever invoke fn."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "cmp_configs", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "fn", "childNum": 0, "tag": "code", "childList": []}]}]]