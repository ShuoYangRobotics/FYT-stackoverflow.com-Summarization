[[{"text": ["You may try to use GDAL library.", "It provides bindings to Python.", "Here is combined tutorial presenting how to read and write images using C++, C and Python APIs\nDepending on GDAL operations and functions being used, GDAL can handle very large images and process images which are too large to be held in RAM."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "GDAL", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.gdal.org"}, {"text": "tutorial", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.gdal.org/gdal_tutorial.html"}]}], [{"text": ["Not too suprising you're running out of memory; that image will take over 2gig in memory and depending on the system you're using your OS might not be able to allocate enough virtual memory to python to run it, regardless of your actual RAM."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You are definitely going to need to write it out incrementally.", "If you're using a raw format you could probably do this per row of images, if they are all of the same dimensions.", "Then you could concatenate the files, otherwise you'd have to be a bit more careful with how you encode the data."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["It's just a matter of understanding the binary file format.", "Compressed formats are going to be more difficult."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Assuming you want a bitmap/DIB, this code:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #incremental_write_bmp.py\nimport binascii\n\ndata='''\n0h -2 -42 4D -\"BM\" -Magic Number (unsigned integer 66, 77)\n2h -4 -46 00 00 00 -70 Bytes -Size of the BMP file\n6h -2 -00 00 -Unused -Application Specific\n8h -2 -00 00 -Unused -Application Specific\nAh -4 -36 00 00 00 -54 bytes -The offset where the bitmap data (pixels) can be found.\nEh -4 -28 00 00 00 -40 bytes -The number of bytes in the header (from this point).\n12h -4 -02 00 00 00 -2 pixels -The width of the bitmap in pixels\n16h -4 -02 00 00 00 -2 pixels -The height of the bitmap in pixels\n1Ah -2 -01 00 -1 plane -Number of color planes being used.\n1Ch -2 -18 00 -24 bits -The number of bits/pixel.\n1Eh -4 -00 00 00 00 -0 -BI_RGB, No compression used\n22h -4 -10 00 00 00 -16 bytes -The size of the raw BMP data (after this header)\n26h -4 -13 0B 00 00 -2,835 pixels/meter -The horizontal resolution of the image\n2Ah -4 -13 0B 00 00 -2,835 pixels/meter -The vertical resolution of the image\n2Eh -4 -00 00 00 00 -0 colors -Number of colors in the palette\n32h -4 -00 00 00 00 -0 important colors -Means all colors are important\n36h -3 -00 00 FF -0 0 255 -Red, Pixel (1,0)\n39h -3 -FF FF FF -255 255 255 -White, Pixel (1,1)\n3Ch -2 -00 00 -0 0 -Padding for 4 byte alignment (Could be a value other than zero)\n3Eh -3 -FF 00 00 -255 0 0 -Blue, Pixel (0,0)\n41h -3 -00 FF 00 -0 255 0 -Green, Pixel (0,1)\n44h -2 -00 00 -0 0 -Padding for 4 byte alignment (Could be a value other than zero)\n'''.strip().split('\\n')\n\nopen('test.bmp','wb')\nfor l in data:\n    b = l.split('-')[2].strip()\n    d = ''.join(b.split())\n    x = binascii.a2b_hex(d)\n    # this re-opens the file and appends each iteration\n    open('test.bmp','ab').write(x)\n</code>\n</pre>\n", "senID": 2}, {"text": ["...will incrementally write the example 2x2 bitmap found here.", "Now it's just a matter of setting the headers to the size you want and reading (and sometimes re-reading) your tiles in the right order.", "I tried it with a very large file and did not see python's memory spike.", "I assume the OS can append to a file without reading the whole thing."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/BMP_file_format#Example_of_a_2x2_Pixel.2C_24-Bit_Bitmap"}]}], [{"text": ["Check if your system runs out of virtual memory when you do this.", "If it does, try adding more.", "That way, you offload the entire problem onto the virtual memory subsystem, which might be quicker."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["mayby You could try out OIIO python bindings that was created by one of the GSoC student?", "OpenImageIO itself can read big images using small memory - but I didn't use it by myself"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["OIIO: http://openimageio.org\nHow to use python bindings: http://openimageio.org/wiki/index.php?title=Python_bindings"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "http://openimageio.org", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://openimageio.org"}, {"href": "http://openimageio.org/wiki/index.php?title=Python_bindings", "text": "http://openimageio.org/wiki/index.php?title=Python_bindings", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["There is also a small script called \"isticher\" that is doing what You want (at least I think so)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Use numpy.memmap and the png module."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]