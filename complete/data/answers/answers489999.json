[[{"code": "<pre>\n<code>\n # Over-explaining a bit:\ndef magic(numList):         # [1,2,3]\n    s = map(str, numList)   # ['1','2','3']\n    s = ''.join(s)          # '123'\n    s = int(s)              # 123\n    return s\n\n\n# How I'd probably write it:\ndef magic(numList):\n    s = ''.join(map(str, numList))\n    return int(s)\n\n\n# As a one-liner  \nnum = int(''.join(map(str,numList)))\n\n\n# Functionally:\ns = reduce(lambda x,y: x+str(y), numList, '')\nnum = int(s)\n\n\n# Using some oft-forgotten built-ins:\ns = filter(str.isdigit, repr(numList))\nnum = int(s)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Two solutions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; nums = [1, 2, 3]\n&gt;&gt;&gt; magic = lambda nums: int(''.join(str(i) for i in nums)) # Generator exp.\n&gt;&gt;&gt; magic(nums)\n123\n&gt;&gt;&gt; magic = lambda nums: sum(digit * 10 ** (len(nums) - 1 - i) # Summation\n...     for i, digit in enumerate(nums))\n&gt;&gt;&gt; magic(nums)\n123\n</code>\n</pre>\n", "senID": 1}, {"text": ["The map-oriented solution actually comes out ahead on my box -- you definitely should not use sum for things that might be large numbers:"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "sum", "childNum": 0, "tag": "code", "childList": []}]}, {"src": "http://lh3.ggpht.com/_t58Xs7CN35o/SYETlAnN6NI/AAAAAAAABSg/KJetpOdJcKw/s400/image.png", "tag": "img", "senID": 3}, {"code": "<pre>\n<code>\n import collections\nimport random\nimport timeit\n\nimport matplotlib.pyplot as pyplot\n\nMICROSECONDS_PER_SECOND = 1E6\nFUNS = []\ndef test_fun(fun):\n    FUNS.append(fun)\n    return fun\n\n@test_fun\ndef with_map(nums):\n    return int(''.join(map(str, nums)))\n\n@test_fun\ndef with_interpolation(nums):\n    return int(''.join('%d' % num for num in nums))\n\n@test_fun\ndef with_genexp(nums):\n    return int(''.join(str(num) for num in nums))\n\n@test_fun\ndef with_sum(nums):\n    return sum(digit * 10 ** (len(nums) - 1 - i)\n        for i, digit in enumerate(nums))\n\n@test_fun\ndef with_reduce(nums):\n    return int(reduce(lambda x, y: x + str(y), nums, ''))\n\n@test_fun\ndef with_builtins(nums):\n    return int(filter(str.isdigit, repr(nums)))\n\n@test_fun\ndef with_accumulator(nums):\n    tot = 0\n    for num in nums:\n        tot *= 10\n        tot += num\n    return tot\n\ndef time_test(digit_count, test_count=10000):\n    \"\"\"\n    :return: Map from func name to (normalized) microseconds per pass.\n    \"\"\"\n    print 'Digit count:', digit_count\n    nums = [random.randrange(1, 10) for i in xrange(digit_count)]\n    stmt = 'to_int(%r)' % nums\n    result_by_method = {}\n    for fun in FUNS:\n        setup = 'from %s import %s as to_int' % (__name__, fun.func_name)\n        t = timeit.Timer(stmt, setup)\n        per_pass = t.timeit(number=test_count) / test_count\n        per_pass *= MICROSECONDS_PER_SECOND\n        print '%20s: %.2f usec/pass' % (fun.func_name, per_pass)\n        result_by_method[fun.func_name] = per_pass\n    return result_by_method\n\nif __name__ == '__main__':\n    pass_times_by_method = collections.defaultdict(list)\n    assert_results = [fun([1, 2, 3]) for fun in FUNS]\n    assert all(result == 123 for result in assert_results)\n    digit_counts = range(1, 100, 2)\n    for digit_count in digit_counts:\n        for method, result in time_test(digit_count).iteritems():\n            pass_times_by_method[method].append(result)\n    for method, pass_times in pass_times_by_method.iteritems():\n        pyplot.plot(digit_counts, pass_times, label=method)\n    pyplot.legend(loc='upper left')\n    pyplot.xlabel('Number of Digits')\n    pyplot.ylabel('Microseconds')\n    pyplot.show()\n</code>\n</pre>\n", "senID": 4}], [{"code": "<pre>\n<code>\n def magic(numbers):\n    return int(''.join([ \"%d\"%x for x in numbers]))\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n def magic(number):\n    return int(''.join(str(i) for i in number))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["pseudo-code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\nint magic(list nums)\n{\n  int tot = 0\n\n  while (!nums.isEmpty())\n  {\n    int digit = nums.takeFirst()\n    tot *= 10\n    tot += digit\n  }\n\n  return tot\n}\n</pre>\n", "senID": 1}], [{"text": ["This seems pretty clean, to me."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def magic( aList, base=10 ):\n    n= 0\n    for d in aList:\n        n = base*n + d\n    return n\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Just for completeness, here's a variant that uses print() (works on Python 2.6-3.x):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "print()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from __future__ import print_function\ntry: from cStringIO import StringIO\nexcept ImportError:\n     from io import StringIO\n\ndef to_int(nums, _s = StringIO()):\n    print(*nums, sep='', end='', file=_s)\n    s = _s.getvalue()\n    _s.truncate(0)\n    return int(s)\n</code>\n</pre>\n", "senID": 1}, {"tag": "hr", "senID": 2}, {"text": ["I've measured performance of @cdleary's functions.", "The results are slightly different. "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "@cdleary's functions", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/489999/python-convert-list-of-ints-to-one-number#490031"}]}, {"text": ["Each function tested with the input list generated by:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def randrange1_10(digit_count): # same as @cdleary\n    return [random.randrange(1, 10) for i in xrange(digit_count)]\n</code>\n</pre>\n", "senID": 5}, {"text": ["You may supply your own function via --sequence-creator=yourmodule.yourfunction command-line argument (see below)."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "--sequence-creator=yourmodule.yourfunction", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The fastest functions for a given number of integers in a list (len(nums) == digit_count) are:"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "len(nums) == digit_count", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": ["len(nums) in 1..30 "], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "len(nums)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "1..30", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["len(nums) in 30..1000 "], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "len(nums)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "30..1000", "childNum": 0, "tag": "strong", "childList": []}]}]}, {"src": "http://i403.photobucket.com/albums/pp111/uber_ulrich/ints2int/_010randrange1_10.png", "tag": "img", "senID": 10}, {"code": "<pre>\n<code>\n |------------------------------+-------------------|\n| Fitting polynom              | Function          |\n|------------------------------+-------------------|\n| 1.00  log2(N)   +  1.25e-015 | N                 |\n| 2.00  log2(N)   +  5.31e-018 | N*N               |\n| 1.19  log2(N)   +      1.116 | N*log2(N)         |\n| 1.37  log2(N)   +      2.232 | N*log2(N)*log2(N) |\n|------------------------------+-------------------|\n| 1.21  log2(N)   +      0.063 | _interpolation    |\n| 1.24  log2(N)   -      0.610 | _genexp           |\n| 1.25  log2(N)   -      0.968 | _imap             |\n| 1.30  log2(N)   -      1.917 | _map              |\n</code>\n</pre>\n", "senID": 11}, {"src": "http://i403.photobucket.com/albums/pp111/uber_ulrich/ints2int/_020randrange1_10.png", "tag": "img", "senID": 12}, {"text": ["To plot the first figure download cdleary.pyandmake-figures.py and run (numpy and matplotlib must be installed to plot):"], "childNum": 5, "tag": "p", "senID": 13, "childList": [{"text": "cdleary.pyandmake-figures.py", "tag": "a", "pos": 0, "childList": [{"text": "cdleary.py", "tag": "code"}, {"text": "make-figures.py", "tag": "code"}], "childNum": 2, "href": "http://gist.github.com/51074"}, {"text": "cdleary.py", "childNum": 0, "tag": "code", "childList": []}, {"text": "make-figures.py", "childNum": 0, "tag": "code", "childList": []}, {"text": "numpy", "childNum": 0, "tag": "code", "childList": []}, {"text": "matplotlib", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n $ python cdleary.py\n</code>\n</pre>\n", "senID": 14}, {"text": ["Or "], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n $ python make-figures.py --sort-function=cdleary._map \\\n&gt; --sort-function=cdleary._imap \\\n&gt; --sort-function=cdleary._interpolation \\\n&gt; --sort-function=cdleary._genexp --sort-function=cdleary._sum \\\n&gt; --sort-function=cdleary._reduce --sort-function=cdleary._builtins \\\n&gt; --sort-function=cdleary._accumulator \\\n&gt; --sequence-creator=cdleary.randrange1_10 --maxn=1000\n</code>\n</pre>\n", "senID": 16}], [{"text": ["This method works in 2.x as long as each element in the list is only a single digit.", "But you shouldn't actually use this.", "It's horrible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; magic = lambda l:int(`l`[1::3])\n&gt;&gt;&gt; magic([3,1,3,3,7])\n31337\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Using a generator expression:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def magic(numbers):\n    digits = ''.join(str(n) for n in numbers)\n    return int(digits)\n</code>\n</pre>\n", "senID": 1}]]