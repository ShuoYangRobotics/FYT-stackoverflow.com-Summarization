[[{"text": ["Python standard library offers a method for it: heapq.merge.", "As the documentation says, it is very similar to using itertools (but with more limitations); if you cannot live with those limitations (or if you do not use Python 2.6) you can do something like this:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "heapq.merge", "tag": "a", "pos": 0, "childList": [{"text": "heapq.merge", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/heapq.html#heapq.merge"}, {"text": "heapq.merge", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "", "childNum": 0, "tag": "br", "pos": 1, "childList": []}, {"href": "http://docs.python.org/library/itertools.html#itertools.chain", "text": "itertools", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n sorted(itertools.chain(args), cmp)\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, I think it has the same complexity as your own solution, although using iterators should give some quite good optimization and speed increase."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Instead of using a list, you can use a heap."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "heap", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Heap%5F%28data%5Fstructure"}]}, {"text": ["The insertion is O(log(n)), so merging a, b and c will be O(n log(n))"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["In Python, you can use the heapqmodule."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "heapqmodule", "tag": "a", "pos": 0, "childList": [{"text": "heapq", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/heapq.html"}, {"text": "heapq", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Use the bisect module.", "From the documentation: \"This module provides support for maintaining a list in sorted order without having to sort the list after each insertion."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "bisect", "tag": "a", "pos": 0, "childList": [{"text": "bisect", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/bisect.html"}, {"text": "bisect", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import bisect\n\ndef magic(*args):\n    r = []\n    for a in args:\n        for i in a:\n            bisect.insort(r, i)\n    return r\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I don't know whether it would be any quicker, but you could simplify it with:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def GetObjKey(a):\n    return a.points\n\nreturn sorted(a + b + c, key=GetObjKey)\n</code>\n</pre>\n", "senID": 1}, {"text": ["You could also, of course, use cmp rather than key if you prefer."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "cmp", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "key", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["One line solution using sorted:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def magic(*args):\n  return sorted(sum(args,[]), key: lambda x: x.points)\n</code>\n</pre>\n", "senID": 1}, {"text": ["IMO this solution is very readable."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Using heapq module, it could be more efficient, but I have not tested it.", "You cannot specify cmp/key function in heapq, so you have to implement Obj to be implicitly sorted."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n import heapq\ndef magic(*args):\n  h = []\n  for a in args:\n    heapq.heappush(h,a)\n  return [i for i in heapq.heappop(h)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Here you go: a fully functioning merge sort for lists (adapted from my sort here):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/hughdbrown/algorithm/blob/05307be15669de0541cd4e91c03b610d440b4290/mergesort.py"}]}, {"code": "<pre>\n<code>\n def merge(*args):\n    import copy\n    def merge_lists(left, right):\n        result = []\n        while (len(left) and len(right)):\n            which_list = (left if left[0] &lt;= right[0] else right)\n            result.append(which_list.pop(0))\n        return result + left + right\n    lists = [arg for arg in args]\n    while len(lists) &gt; 1:\n        left, right = copy.copy(lists.pop(0)), copy.copy(lists.pop(0))\n        result = merge_lists(left, right)\n        lists.append(result)\n    return lists.pop(0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Call it like this:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n merged_list = merge(a, b, c)\nfor item in merged_list:\n    print item\n</code>\n</pre>\n", "senID": 3}, {"text": ["For good measure, I'll throw in a couple of changes to your Obj class:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n class Obj(object):\n    def __init__(self, p) :\n        self.points = p\n    def __cmp__(self, b) :\n        return cmp(self.points, b.points)\n    def __str__(self):\n        return \"%d\" % self.points\n</code>\n</pre>\n", "senID": 5}, {"tag": "ul", "num": 4, "lis": [{"text": "Derive from object ", "tag": "none", "senID": 6}, {"text": "Pass ", "tag": "none", "senID": 7}, {"text": "Make ", "tag": "none", "senID": 8}, {"text": "Add a ", "tag": "none", "senID": 9}]}], [{"text": ["I like Roberto Liffredo's answer.", "I didn't know about heapq.merge().", "Hmmmph."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here's what the complete solution looks like using Roberto's lead:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class Obj(object):\n    def __init__(self, p) :\n        self.points = p\n    def __cmp__(self, b) :\n        return cmp(self.points, b.points)\n    def __str__(self):\n        return \"%d\" % self.points\n\na = [Obj(1), Obj(3), Obj(8)]\nb = [Obj(1), Obj(2), Obj(3)]\nc = [Obj(100), Obj(300), Obj(800)]\n\nimport heapq\n\nsorted = [item for item in heapq.merge(a,b,c)]\nfor item in sorted:\n    print item\n</code>\n</pre>\n", "senID": 2}, {"text": ["Or:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n for item in heapq.merge(a,b,c):\n    print item\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I asked a similar question and got some excellent answers:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": ["Joining a set of ordered-integer yielding Python iterators"], "childNum": 0, "tag": "a", "senID": 1, "childList": []}]}, {"text": ["The best solutions from that question are variants of the merge algorithm, which you can read about here:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": ["Wikipedia: Merge Algorithm"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}]}]]