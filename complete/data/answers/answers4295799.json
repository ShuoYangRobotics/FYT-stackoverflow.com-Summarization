[[{"text": ["First let me tell you how to find the problem.", "Then I'll tell you where it is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I haven't even bothered to try to figure out your code.", "I just ran it and took 3 random-time stack samples.", "I did that by typing control-C and looking at the resulting stacktrace."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["One way to look at it is: if a statement appears on X% of random stack traces, then it is on the stack for about X% of the time, so that is what it's responsible for.", "If you could avoid executing it, that is how much you would save."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["OK, I took 3 stack samples.", "Here they are:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n File \"camels.py\", line 87, in &lt;module&gt;\n  print solve([fCamel, fCamel, fCamel, gap, bCamel, bCamel, bCamel])\nFile \"camels.py\", line 85, in solve\n  return astar(formation, heuristic, solution, getneighbors)\nFile \"camels.py\", line 80, in astar\n  openlist.put((current.g + heuristicf(neighbor), node(neighbor, current.g + 1, current)))\n\nFile \"camels.py\", line 87, in &lt;module&gt;\n  print solve([fCamel, fCamel, fCamel, gap, bCamel, bCamel, bCamel])\nFile \"camels.py\", line 85, in solve\n  return astar(formation, heuristic, solution, getneighbors)\nFile \"camels.py\", line 80, in astar\n  openlist.put((current.g + heuristicf(neighbor), node(neighbor, current.g + 1, current)))\n\nFile \"camels.py\", line 87, in &lt;module&gt;\n  print solve([fCamel, fCamel, fCamel, gap, bCamel, bCamel, bCamel])\nFile \"camels.py\", line 85, in solve\n  return astar(formation, heuristic, solution, getneighbors)\nFile \"camels.py\", line 80, in astar\n  openlist.put((current.g + heuristicf(neighbor), node(neighbor, current.g + 1, current)))\n</code>\n</pre>\n", "senID": 4}, {"text": ["Notice, in this case the stack samples are all identical.", "In other words, each one of these three lines is individually responsible for nearly all of the time.", "So look at them:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n line        87: print solve([fCamel, fCamel, fCamel, gap, bCamel, bCamel, bCamel])\nline solve: 85: return astar(formation, heuristic, solution, getneighbors)\nline astar: 80: openlist.put((current.g + heuristicf(neighbor), node(neighbor, current.g + 1, current)))\n</code>\n</pre>\n", "senID": 6}, {"text": ["Clearly line 87 is not one you can avoid executing, and probably not 85 either.", "That leaves 80, the openlist.put call.", "Now, you can't tell if the problem is in the + operator, the heuristicf call, the node call, or in the put call.", "You could find out if you could split those out onto separate lines."], "childNum": 5, "tag": "p", "senID": 7, "childList": [{"text": "openlist.put", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "+", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "heuristicf", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "node", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "put", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["So I hope you pick up from this a quick and easy way to find out where your performance problems are."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["I've been tripped up by this before too.", "The bottleneck here is actually if neighbor in closedlist."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "if neighbor in closedlist", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["The in statement is so easy to use, you forget that it's linear search, and when you're doing linear searches on lists, it can add up fast.", "What you can do is convert closedlist into a set object.", "This keeps hashes of its items so the in operator is much more efficient than for lists.", "However, lists aren't hashable items, so you will have to change your configurations into tuples instead of lists."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "in", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "set", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "in", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["If the order of closedlist is crucial to the algorithm, you could use a set for the in operator and keep an parallel list around for your results."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "closedlist", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "in", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I tried a simple implementation of this including aaronasterling's namedtuple trick and it performed in 0.2 sec for your first example and 2.1 sec for your second, but I haven't tried verifying the results for the second longer one."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["tkerwin is correct that you should be using a set for closedlist, which speeds things up a lot, but it is still kind of slow for 4 camels on each side.", "The next problem is that you are allowing a lot of solutions that aren't possible because you are allowing fCamels to go backwards and bCamels to go forward.", "To fix this, replace the lines,"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if(igap &gt; 0):\n    genn(igap, igap-1)\nif(igap &gt; 1):\n    genn(igap, igap-2)\nif igap &lt; len(formation) - 1:\n    genn(igap, igap+1)\nif igap &lt; len(formation) - 2:\n    genn(igap, igap+2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["with"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n if(igap &gt; 0 and formation[igap-1] == fCamel):\n    genn(igap, igap-1)\nif(igap &gt; 1 and formation[igap-2] == fCamel):\n    genn(igap, igap-2)\nif (igap &lt; len(formation) - 1) and formation[igap+1] == bCamel:\n    genn(igap, igap+1)\nif (igap &lt; len(formation) - 2) and formation[igap + 2] == bCamel:\n    genn(igap, igap+2)\n</code>\n</pre>\n", "senID": 3}, {"text": ["then I get solution to the 4 camels on each side problem in like .05 seconds rather than 10 seconds.", "I also tried 5 camels on each side and it took 0.09 seconds.", "I also am using a set for closedlist and heapq rather than Queue."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Additional speed-up"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Additional speed-up", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You can get an additional speed-up by using your heuristic correctly.", "Currently, you are using the line"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n openlist.put((current.g + heuristicf(neighbor), node(neighbor, current.g + 1, current)))\n</code>\n</pre>\n", "senID": 7}, {"text": ["(or the heapq version of that) but you should change it to"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n openlist.put((heuristicf(neighbor), node(neighbor, current.g + 1, current)))\n</code>\n</pre>\n", "senID": 9}, {"text": ["This doesn't factor in the number of moves that has been needed, but that is okay.", "With this puzzle (and the screening out of moves that move camels in the wrong direction), you don't need to worry about the number of moves it takes - either a move advances you towards the solution or it will come to a dead end.", "In other words, all possible solutions require the same number of moves.", "This one change takes the time to find the solution of the 12 camels on each side case from over 13 seconds (even using the heapq, set for closedlist, and the changes to find the neighbors above) to 0.389 seconds.", "That's not bad. "], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["By the way, a better way to find if you've found the solution is to check if the index of the first fCamel is equal to the length of the formation/2 + 1(using int division) and that the index before that is equal to the gap."], "childNum": 0, "tag": "p", "senID": 11, "childList": []}], [{"text": ["The code below using less than 1s to solve this"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import permutations\n\nGAP='G'\nLEFT='F'\nRIGHT='B'\nBEGIN=('F','F','F','F','G','B','B','B','B')\nEND=('B','B','B','B','G','F','F','F','F')\nLENGTH=len(BEGIN)\n\nALL=set(permutations(BEGIN))\n\ndef NextMove(seq):\n    g=seq.index(GAP)\n    ret = set()\n    def swap(n):\n        return seq[:n]+seq[n:n+2][::-1]+seq[n+2:]\n    if g&gt;0 and seq[g-1]==LEFT:\n        ret.add(swap(g-1))\n    if g&lt;LENGTH-1 and seq[g+1]==RIGHT:\n        ret.add(swap(g))\n    if g&lt;LENGTH-2 and seq[g+1]==LEFT and seq[g+2]==RIGHT:\n        ret.add(seq[:g]+seq[g+2:g+3]+seq[g+1:g+2]+seq[g:g+1]+seq[g+3:])\n    if g&gt;1 and seq[g-1]==RIGHT and seq[g-2]==LEFT:\n        ret.add(seq[:g-2]+seq[g:g+1]+seq[g-1:g]+seq[g-2:g-1]+seq[g+1:])\n\n    return ret\n\nAllMoves={state:NextMove(state) for state in ALL}\n\ndef Solve(now,target):\n    if now==target:\n        return True\n    for state in AllMoves[now]:\n        if Solve(state,target):\n            print(now)\n            return True\n    return False\n\nSolve(BEGIN,END)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["well, I can't really say quite where your algorithm is running astray, but I just went ahead and made my own.", "In the interest of doing the simplest thing that could possibly work, I used a bastardized version of Dijkstra's algorithm, where open nodes are visited in arbitrary order, without consideration of distance.", "This means I don't have to come up with a heuristic."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \"\"\" notation: a game state is a string containing angle \n    brackets ('&gt;' and '&lt;') and blanks\n '&gt;&gt;&gt; &lt;&lt;&lt;'\n\n \"\"\"\n\ndef get_moves(game):\n    result = []\n    lg = len(game)\n    for i in range(lg):\n        if game[i] == '&gt;':\n            if i &lt; lg-1 and game[i+1] == ' ': # '&gt; ' -&gt; ' &gt;'\n                result.append(game[:i]+' &gt;'+game[i+2:])\n            if i &lt; lg-2 and game[i+1] != ' ' and game[i+2] == ' ': # '&gt;&lt; ' -&gt; ' &lt;&gt;'\n                result.append(game[:i]+' '+game[i+1]+'&gt;'+game[i+3:])\n        if game[i] == '&lt;':\n            if i &gt;= 1 and game[i-1] == ' ': # ' &lt;' -&gt; '&lt; '\n                result.append(game[:i-1]+'&lt; '+game[i+1:])\n            if i &gt;= 2 and game[i-1] != ' ' and game[i-2] == ' ': # ' &gt;&lt;' -&gt; '&lt;&gt; '\n                result.append(game[:i-2]+'&lt;'+game[i-1]+' '+game[i+1:])\n    return result\n\n\n\ndef wander(start, stop):\n    fringe = [start]\n    paths = {}\n\n    paths[start] = ()\n\n    def visit(state):\n      path = paths[state]\n      moves = [move for move in get_moves(state) if move not in paths]\n      for move in moves:\n          paths[move] = paths[state] + (state,)\n      fringe.extend(moves)\n\n    while stop not in paths:\n      visit(fringe.pop())\n\n    print \"still open: \", len(fringe)\n    print \"area covered: \" , len(paths)\n    return paths[stop] + (stop,)\n\nif __name__ == \"__main__\":\n    start = '&gt;&gt;&gt;&gt; &lt;&lt;&lt;&lt;'\n    stop = '&lt;&lt;&lt;&lt; &gt;&gt;&gt;&gt;'\n    print start, \"   --&gt;   \", stop\n    pathway = wander(start,stop)\n    print len(pathway), \"moves: \", pathway\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Replacing "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class node:\n    def __init__(self, a, g, p):\n        self.arrangement = a\n        self.g = g\n        self.parent = p\n</code>\n</pre>\n", "senID": 1}, {"text": ["with "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n node = collections.namedtuple('node', 'arrangement, g, parent')\n</code>\n</pre>\n", "senID": 3}, {"text": ["dropped the times from around 340-600 msecs to 11.4 1.891 msecs on the input [fCamel, fCamel, gap, bCamel, bCamel].", "It yielded the same output."], "childNum": 3, "tag": "p", "senID": 4, "childList": [{"text": "11.4", "childNum": 0, "tag": "strike", "pos": 0, "childList": []}, {"text": "1", "childNum": 0, "tag": "sup", "pos": -1, "childList": []}, {"text": "[fCamel, fCamel, gap, bCamel, bCamel]", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["This obviously wont help with any algorithmic problems but as far as micro-optimizations go, it ain't bad."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["1 I had the wrong input.", "There was an extrafCamelthat was making it run slower"], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "1 I had the wrong input. There was an extrafCamelthat was making it run slower", "childNum": 1, "tag": "sup", "pos": -1, "childList": [{"text": "fCamel", "tag": "code"}]}, {"text": "fCamel", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["My other answer is rather long, so I decided to list this as a separate answer.", "This problem is really better suited to doing a depth-first search.", "I made a depth-first search solution and it is much, much faster than the optimized A-star method made with the changes outlined in my other answer (which is much, much faster than the OP code).", "For instance, here are the results for running both my A-star and my depth-first search methods on the 17 camels per side case."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n A-star:  14.76 seconds\nDepth-first search: 1.30 seconds\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here's my depth-first method code if you are interested:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from sys import argv\n\nfCamel = 'F'\nbCamel = 'B'\ngap = 'G'\n\ndef issolution(formlen):\n    def solution(formation):\n        if formation[formlen2] == gap:\n            return formation.index(fCamel) == x\n        return 0\n    x = formlen/2 + 1\n    formlen2 = formlen/2\n    return solution\n\ndef solve(formation):\n    def depthfirst(form, g):\n        if checksolution(form):\n            return [tuple(form)], g + 1\n        else:\n            igap = form.index(gap)\n            if(igap &gt; 1 and form[igap-2] == fCamel):\n                form[igap-2],form[igap] = form[igap],form[igap-2]\n                res = depthfirst(form,g+1)\n                form[igap-2],form[igap] = form[igap],form[igap-2]\n                if res != 0:\n                    return [tuple(form)]+res[0],res[1]\n            if (igap &lt; flen - 2) and form[igap + 2] == bCamel:\n                form[igap+2],form[igap] = form[igap],form[igap+2]\n                res = depthfirst(form,g+1)\n                form[igap+2],form[igap] = form[igap],form[igap+2]\n                if res != 0:\n                    return [tuple(form)]+res[0],res[1]\n            if(igap &gt; 0 and form[igap-1] == fCamel):                \n                form[igap-1],form[igap] = form[igap],form[igap-1]\n                res = depthfirst(form,g+1)\n                form[igap-1],form[igap] = form[igap],form[igap-1]\n                if res != 0:\n                    return [tuple(form)]+res[0],res[1]               \n            if (igap &lt; flen - 1) and form[igap+1] == bCamel:\n                form[igap+1],form[igap] = form[igap],form[igap+1]\n                res = depthfirst(form,g+1)\n                form[igap+1],form[igap] = form[igap],form[igap+1]\n                if res != 0:\n                    return [tuple(form)]+res[0],res[1]                \n            return 0\n    flen = len(formation)\n    checksolution = issolution(flen)\n    res = depthfirst(list(formation), 0)\n    return res\n\nL = lambda x: tuple([fCamel]*x + [gap] + [bCamel]*x)\nprint solve(L(int(argv[1])))\n</code>\n</pre>\n", "senID": 3}]]