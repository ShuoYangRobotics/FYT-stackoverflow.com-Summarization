[[{"text": ["is is identity testing, == is equality testing.", "what happens in your code would be emulated in the interpreter like this:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "is", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "==", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = 'pub'\n&gt;&gt;&gt; b = ''.join(['p', 'u', 'b'])\n&gt;&gt;&gt; a == b\nTrue\n&gt;&gt;&gt; a is b\nFalse\n</code>\n</pre>\n", "senID": 1}, {"text": ["so, no wonder they're not the same, right?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In other words: is is the id(a) == id(b)"], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "is", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "id(a) == id(b)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["SilentGhost and others are correct here.", "is is used for identity comparison, while == is used for equality comparison."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "is", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "identity", "childNum": 0, "tag": "em", "childList": []}, {"text": "==", "childNum": 0, "tag": "code", "childList": []}, {"text": "equality", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["The reason this works interactively is that (most) string literals are interned by default.", "From Wikipedia:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "interned", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/String%5Finterning"}]}, {"text": ["So, when you have two string literals (words that are literally typed into your program source code, surrounded by quotation marks) in your program that have the same value, the Python compiler will automatically intern the strings, making them both stored at the same memory location.", "(Note that this doesn't always happen, and the rules for when this happens are quite convoluted, so please don't rely on this behavior in production code!"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "always", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["Since in your interactive session both strings are actually stored in the same memory location, they have the same identity, so the is operator works as expected.", "But if you construct a string by some other method (even if that string contains exactly the same characters), then the string may be equal, but it is not the same string -- that is, it has a different identity, because it is stored in a different place in memory."], "childNum": 6, "tag": "p", "senID": 3, "childList": [{"text": "identity", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "is", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "exactly", "childNum": 0, "tag": "em", "childList": []}, {"text": "equal", "childNum": 0, "tag": "em", "childList": []}, {"text": "the same string", "childNum": 0, "tag": "em", "childList": []}, {"text": "identity", "childNum": 0, "tag": "em", "childList": []}]}], [{"text": ["The is keyword is a test for object identity while == is a value comparison."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "is", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "==", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you use is, the result will be true if and only if the object is the same object.", "However, == will be true any time the values of the object are the same."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "is", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "==", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["One last thing to note, you may use the intern function to ensure that you're getting a reference to the same string:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = intern('a')\n&gt;&gt;&gt; a2 = intern('a')\n&gt;&gt;&gt; a is a2\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["As pointed out above, you should probably not be doing is to determine equality on strings.", "But this may be helpful to know if you have some kind of weird requirement to use is."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "is", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Note that the intern function got moved from being a built in function to being in the module sys for Python 3."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "sys", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I think it has to do with the fact that, when the 'is' comparison evaluates to false, two distinct objects are used.", "If it evaluates to true, that means internally it's using the same exact object and not creating a new one, possibly because you created them within a fraction of 2 or so seconds and because there isn't a large time gap in between it's optimized and uses the same object."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["This is why you should be using the equality operator ==, not is, to compare the value of a string object."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "==", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "is", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s = 'one'\n&gt;&gt;&gt; s2 = 'two'\n&gt;&gt;&gt; s is s2\nFalse\n&gt;&gt;&gt; s2 = s2.replace('two', 'one')\n&gt;&gt;&gt; s2\n'one'\n&gt;&gt;&gt; s2 is s\nFalse\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 2}, {"text": ["In this example, I made s2, which was a different string object previously equal to 'one' but it is not the same object as s, because the interpreter did not use the same object as I did not initially assign it to 'one', if I had it would have made them the same object."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["I believe that this is known as \"interned\" strings.", "Python does this, so does Java, and so do C and C++ when compiling in optimized modes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you use two identical strings, instead of wasting memory by creating two string objects, all interned strings with the same contents point to the same memory."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This results in the Python \"is\" operator returning True because two strings with the same contents are pointing at the same string object.", "This will also happen in Java and in C."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This is only useful for memory savings though.", "You cannot rely on it to test for string equality, because the various interpreters and compilers and JIT engines cannot always do it."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["From my limited experience with python, is is used to compare two objects to see if they are the same object as opposed to two different objects with the same value.", "== is used to determine if the values are identical. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "is", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "==", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Here is a good example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; s1 = u'public'\n&gt;&gt;&gt; s2 = 'public'\n&gt;&gt;&gt; s1 is s2\nFalse\n&gt;&gt;&gt; s1 == s2\nTrue\n</code>\n</pre>\n", "senID": 2}, {"text": ["s1 is a unicode string, and s2 is a normal string.", "They are not the same type, but are the same value."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "s1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "s2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["This is a side note, but in idiomatic python, you will often see things like:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n if x is None: \n    # some clauses\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is safe, because there is guaranteed to be one instance of the Null Object (i.e., None)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "there is guaranteed to be one instance of the Null Object (i.e., None)", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#the-null-object"}]}], [{"text": ["If you're not sure what you're doing, use the '=='.", "If you have a little more knowledge about it you can use 'is' for known objects like 'None'."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Otherwise you'll end up wondering why things doesn't work and why this happens:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = 1\n&gt;&gt;&gt; b = 1\n&gt;&gt;&gt; b is a\nTrue\n&gt;&gt;&gt; a = 6000\n&gt;&gt;&gt; b = 6000\n&gt;&gt;&gt; b is a\nFalse\n</code>\n</pre>\n", "senID": 2}, {"text": ["I'm not even sure if some things are guaranteed to stay the same between different python versions/implementations."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]