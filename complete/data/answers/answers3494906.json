[[{"text": ["This works for dictionaries of any length:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; result = {}\n&gt;&gt;&gt; for d in L: result.update(d)\n... \n{'a':1,'c':2,'b':1,'d':2}\n</code>\n</pre>\n", "senID": 1}, {"text": ["And as generator-oneliner:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n dict((k,v) for d in L for (k,v) in d.items())\n</code>\n</pre>\n", "senID": 3}, {"text": ["Edit: As pointed out by katrielalex, dictionary comprehension:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n { k: v for d in L for k, v in d.items() }\n</code>\n</pre>\n", "senID": 5}, {"text": ["is even better.", "OTOH they are Python3-only, so they may not be available to you."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; L=[{'a':1},{'b':2},{'c':1},{'d':2}]    \n&gt;&gt;&gt; dict(i.items()[0] for i in L)\n{'a': 1, 'c': 1, 'b': 2, 'd': 2}\n</code>\n</pre>\n", "senID": 0}, {"text": ["Note: the order of 'b' and 'c' doesn't match your output because dicts are unordered"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["if the dicts can have more than one key/value"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dict(j for i in L for j in i.items())\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n dict1.update( dict2 )\n</code>\n</pre>\n", "senID": 0}, {"text": ["This is asymmetrical because you need to choose what to do with duplicate keys; in this case, dict2 will overwrite dict1.", "Exchange them for the other way."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "dict2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dict1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["EDIT: Ah, sorry, didn't see that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It is possible to do this in a single expression:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from itertools import chain\n&gt;&gt;&gt; dict( chain( *map( dict.items, theDicts ) ) )\n{'a': 1, 'c': 1, 'b': 2, 'd': 2}\n</code>\n</pre>\n", "senID": 4}, {"text": ["No credit to me for this last!"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["However, I'd argue that it might be more Pythonic (explicit > implicit, flat > nested ) to do this with a simple for loop.", "YMMV."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "for", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["see this http://stackoverflow.com/questions/2365921/merging-python-dictionaries"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://stackoverflow.com/questions/2365921/merging-python-dictionaries", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2365921/merging-python-dictionaries"}]}], [{"text": ["This handles all the subdicts in your list, even if they have multiple items:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dict(sum((d.items() for d in L), []))\n</code>\n</pre>\n", "senID": 1}, {"text": ["But I think update() is preferred:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; dd = {}\n&gt;&gt;&gt; for d in L: dd.update(d)\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; dictlist = [{'a':1},{'b':2},{'c':1},{'d':2, 'e':3}]\n&gt;&gt;&gt; dict(kv for d in dictlist for kv in d.iteritems())\n{'a': 1, 'c': 1, 'b': 2, 'e': 3, 'd': 2}\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 0}, {"text": ["Note I added a second key/value pair to the last dictionary to show it works with multiple entries.", "Also keys from dicts later in the list will overwrite the same key from an earlier dict."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]