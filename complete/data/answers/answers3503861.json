[[{"text": ["example squarer.py program (it just happens to be in Python, use your Fortran executable):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #!/usr/bin/python\nimport sys\ndata= sys.stdin.readline() # expecting lots of data in one line\nprocessed_data= data[-2::-1] # reverse without the newline\nsys.stdout.write(processed_data+'\\n')\n</code>\n</pre>\n", "senID": 1}, {"text": ["example target.py program:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import thread, Queue\nimport subprocess as sbp\n\nclass Companion(object):\n    \"A companion process manager\"\n    def __init__(self, cmdline):\n        \"Start the companion process\"\n        self.companion= sbp.Popen(\n            cmdline, shell=False,\n            stdin=sbp.PIPE,\n            stdout=sbp.PIPE)\n        self.putque= Queue.Queue()\n        self.getque= Queue.Queue()\n        thread.start_new_thread(self._sender, (self.putque,))\n        thread.start_new_thread(self._receiver, (self.getque,))\n\n    def _sender(self, que):\n        \"Actually sends the data to the companion process\"\n        while 1:\n            datum= que.get()\n            if datum is Ellipsis:\n                break\n            self.companion.stdin.write(datum)\n            if not datum.endswith('\\n'):\n                self.companion.stdin.write('\\n')\n\n    def _receiver(self, que):\n        \"Actually receives data from the companion process\"\n        while 1:\n            datum= self.companion.stdout.readline()\n            que.put(datum)\n\n    def close(self):\n        self.putque.put(Ellipsis)\n\n    def send(self, data):\n        \"Schedule a long line to be sent to the companion process\"\n        self.putque.put(data)\n\n    def recv(self):\n        \"Get a long line of output from the companion process\"\n        return self.getque.get()\n\ndef main():\n    my_data= '12345678 ' * 5000\n    my_companion= Companion((\"/usr/bin/python\", \"squarer.py\"))\n\n    my_companion.send(my_data)\n    my_answer= my_companion.recv()\n    print my_answer[:20] # don't print the long stuff\n    # rinse, repeat\n\n    my_companion.close()\n\nif __name__ == \"__main__\":\n    main()\n</code>\n</pre>\n", "senID": 3}, {"text": ["The main function contains the code you will use: setup a Companion object, companion.send a long line of data, companion.recv a line.", "Repeat as necessary."], "childNum": 4, "tag": "p", "senID": 4, "childList": [{"text": "main", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Companion", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "companion.send", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "companion.recv", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["I think that you only add one linebreak here:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n p.write(' '.join([\"%.10f\"%k for k in x]) + os.linesep)\n</code>\n</pre>\n", "senID": 1}, {"text": ["instead of adding one per line."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Looks like you're timing out (default timeout, I believe, 30 seconds) because preparing, sending, receiving, and processing that much data is taking a lot of time.", "Per the docs, timeout= is an optional named parameter to the expect method, which you're not calling -- maybe there's an undocumented way to set the default timeout in the initializer, which could be found by poring over the sources (or, worst case, created by hacking those sources)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "the docs", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.noah.org/wiki/Pexpect"}, {"text": "timeout=", "childNum": 0, "tag": "code", "childList": []}, {"text": "expect", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If the Fortran program read and saved (say) 100 items at a time, with a prompt, syncing up would become enormously easier.", "Could you modify your Fortran code for the purpose, or would you rather go for the undocumented / hack approach?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Here's a huge simplification: Break your Python into two things."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n python source.py | squarer | python sink.py\n</code>\n</pre>\n", "senID": 1}, {"text": ["The squarer application is  your Fortran code.", "Reads from stdin, writes to stdout."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "squarer", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Your source.py is your Python that does "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "source.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import sys\nsys.stdout.write(' '.join([\"%.10f\"%k for k in x]) + os.linesep)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Or, perhaps something a tiny bit simpler, i.e. "], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import print_function\nprint( ' '.join([\"{0:.10f}\".format(k) for k in x]) )\n</code>\n</pre>\n", "senID": 6}, {"text": ["And your sink.py is something like this."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "sink.py", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import fileinput\nfor line in fileinput.input():\n    # process the line\n</code>\n</pre>\n", "senID": 8}, {"text": ["Separating source, squarer and sink gets you 3 separate processes (instead of 2) and will use more cores.", "More cores == more concurrency == more fun."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["Found a solution using the \"communicate\" method from the subprocess module, so I'm posting it here for reference, and in case anyone else needs to do the same thing."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import subprocess as sbp\n\nclass ExternalProg:\n\n    def __init__(self, arg_list):\n        self.opt = sbp.Popen(arg_list, stdin=sbp.PIPE, stdout=sbp.PIPE, shell=True, close_fds=True)\n\n    def toString(self,x):\n        return ' '.join([\"%.12f\"%k for k in x])\n\n    def toFloat(self,x):\n        return float64(x.strip().split())\n\n    def sendString(self,string):\n        if not string.endswith('\\n'):\n            string = string + '\\n'\n        self.opt.stdin.write(string)\n\n    def sendArray(self,x):\n        self.opt.stdin.write(self.toString(x)+'\\n')\n\n    def readInt(self):\n        return int(self.opt.stdout.readline().strip())\n\n    def sendScalar(self,x):\n        if type(x) == int:\n            self.opt.stdin.write(\"%i\\n\"%x)\n        elif type(x) == float:\n            self.opt.stdin.write(\"%.12f\\n\"%x)\n\n    def readArray(self):\n        return self.toFloat(self.opt.stdout.readline())\n\n    def close(self):\n        self.opt.kill()\n</code>\n</pre>\n", "senID": 1}, {"text": ["The class is invoked with an external program called 'optimizer' as:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n optim = ExternalProg(['./optimizer'])\noptim.sendScalar(500) # send the optimizer the length of the state vector, for example\noptim.sendArray(init_x) # the initial guess for x\noptim.sendArray(init_g) # the initial gradient g\nnext_x = optim.readArray() # get the next estimate of x\nnext_g = evaluateGradient(next_x) # calculate gradient at next_x from within python\n# repeat until convergence\n</code>\n</pre>\n", "senID": 3}, {"text": ["On the fortran side (the program compiled to give the executable 'optimizer'), a 500-element vector would be read in so:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n read(*,*) input_vector(1:500)\n</code>\n</pre>\n", "senID": 5}, {"text": ["and would be written out so:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n write(*,'(500f18.11)') output_vector(1:500)\n</code>\n</pre>\n", "senID": 7}, {"text": ["and that's it!", "I've tested it with state vectors up to 200,000 elements (which is the upper limit of what I need right now).", "Hope this helps someone other than myself.", "This solution works with ifort and xlf90, but not with gfortran for some reason I don't understand."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["I tried a circular pipe"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["mkfifo pipe;\npython script.py &lt; pipe | optimizer > pipe"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "mkfifo pipe;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "python script.py &lt; pipe | optimizer > pipe", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["but that locks up too."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]