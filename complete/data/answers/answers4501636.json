[[{"text": ["Such a list of lists could be constructed using a list comprehension:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "list comprehension", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions"}]}, {"code": "<pre>\n<code>\n In [17]: seq=[1,2,3,4,5,6,7,8]\nIn [18]: [seq[i:i+3] for i in range(0,len(seq),3)]\nOut[18]: [[1, 2, 3], [4, 5, 6], [7, 8]]\n</code>\n</pre>\n", "senID": 1}, {"text": ["There is also the grouper idiom:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "grouper idiom", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#recipes"}]}, {"code": "<pre>\n<code>\n In [19]: import itertools\nIn [20]: list(itertools.izip_longest(*[iter(seq)]*3))\nOut[20]: [(1, 2, 3), (4, 5, 6), (7, 8, None)]\n</code>\n</pre>\n", "senID": 3}, {"text": ["but note that missing elements are filled with the value None.", "izip_longest can take a fillvalue parameter as well if something other than None is desired."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "izip_longest", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.izip_longest"}, {"text": "fillvalue", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["list1+=[list2] -- noting the brackets this time -- is equivalent to list1.append(list2).", "My highest priority when writing code is readability, \nnot speed.", "For this reason, I would go with list1.append(list2).", "Readability is subjective, however, and probably is influenced greatly by what idioms you're familiar with. "], "childNum": 3, "tag": "p", "senID": 5, "childList": [{"text": "list1+=[list2]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "list1.append(list2)", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "list1.append(list2)", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Happily, in this case, readability and speed seem to coincide:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n In [41]: %timeit list1=[1,2,3]; list1.append(list2)\n1000000 loops, best of 3: 612 ns per loop\n\nIn [42]: %timeit list1=[1,2,3]; list1+=[list2]\n1000000 loops, best of 3: 847 ns per loop\n</code>\n</pre>\n", "senID": 7}], [{"text": ["How about the following (where x is your list):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n [x[i:i+3] for i in range(0, len(x), 3)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is trivial to generalize for n!=3."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "n!=3", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["As to your second question, they're equivalent so I think it's a matter of style.", "However, do make sure you're not confusingappendwithextend."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "confusingappendwithextend", "tag": "a", "pos": 1, "childList": [{"text": "append", "tag": "code"}, {"text": "extend", "tag": "code"}], "childNum": 2, "href": "http://www.wellho.net/mouth/899_Python-extend-v-append-on-a-list.html"}, {"text": "append", "childNum": 0, "tag": "code", "childList": []}, {"text": "extend", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["This function can take any kind of input iterable (not only sequences of known length):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import itertools\n\ndef grouper(n, it):\n    \"grouper(3, 'ABCDEFG') --&gt; ABC DEF G\"\n    it = iter(it)\n    return iter(lambda: list(itertools.islice(it, n)), [])\n\nprint(list(grouper(3, [1,2,3,4,5,6,7,8,9,10])))\n# [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think this split function does what you're looking for (though it works with any iterator rather than just lists):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import islice\n\ndef take(n, it):\n    \"Return first n items of the iterable as a list\"\n    return list(islice(it, n))\n\ndef split(it, size):\n    it = iter(it)\n    size = int(size)\n    ret = take(size, it)\n    while ret:\n        yield ret\n        ret = take(size, it)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: Regarding your asside, I always use list.append(blah), as it feels more idiomatic to me, but I believe they are functionally equivalent."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I know, it looks like a brainfuck, but is works:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "brainfuck", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Brainfuck"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n&gt;&gt;&gt; n = 3\n&gt;&gt;&gt; [i for j in [[a[t:t+n] for x in a[:1:t+1] if (t%n)==False] for t in range(len(a))] for i in j]\n[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15]]\n\n&gt;&gt;&gt; n = 4\n&gt;&gt;&gt; [i for j in [[a[t:t+n] for x in a[:1:t+1] if (t%n)==False] for t in range(len(a))] for i in j]\n[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15]]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["For some specific cases, it might be useful to use the numpy package.", "In this package you have a reshape routine:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "reshape", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html"}]}, {"code": "<pre>\n<code>\n import numpy as np\nx = np.array([1,2,3,4,5,6])\nnp.reshape(x, (-1,3))\n</code>\n</pre>\n", "senID": 1}, {"text": ["However, this solution won't pad your list, if it's not a multiply of n."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]