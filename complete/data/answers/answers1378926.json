[[{"text": ["dir( object )"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "dir( object )", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["will give you the list."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["for instance:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n a = 2\ndir( a )\n</code>\n</pre>\n", "senID": 3}, {"text": ["will list off all the methods you can call for an integer."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Existing answers do a good job of showing you how to get the ATTRIBUTES of an object, but do not precisely answer the question you posed -- how to get the METHODS of an object.", "Python objects have a unified namespace (differently from Ruby, where methods and attributes use different namespaces).", "Consider for example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class X(object):\n...   @classmethod\n...   def clame(cls): pass\n...   @staticmethod\n...   def stame(): pass\n...   def meth(self): pass\n...   def __init__(self):\n...     self.lam = lambda: None\n...     self.val = 23\n... \n&gt;&gt;&gt; x = X()\n&gt;&gt;&gt; dir(x)\n['__class__', '__delattr__', '__dict__', '__doc__', '__format__',\n '__getattribute__', '__hash__', '__init__', '__module__',\n '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__',\n '__sizeof__', '__str__', '__subclasshook__', '__weakref__',\n 'clame', 'lam', 'meth', 'stame', 'val']\n</code>\n</pre>\n", "senID": 1}, {"text": ["((output split for readability))."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["As you see, this is giving you the names of all attributes -- including plenty of special methods that are just inherited from object, special data attributes such as __class__, __dict__ and __doc__, per-instance data attributes (val), per-instance executable attributes (lam), as well as actual methods."], "childNum": 6, "tag": "p", "senID": 3, "childList": [{"text": "object", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "__class__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__dict__", "childNum": 0, "tag": "code", "childList": []}, {"text": "__doc__", "childNum": 0, "tag": "code", "childList": []}, {"text": "val", "childNum": 0, "tag": "code", "childList": []}, {"text": "lam", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If and when you need to be more selective, try:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import inspect\n&gt;&gt;&gt; [n for n, v in inspect.getmembers(x, inspect.ismethod)]\n['__init__', 'clame', 'meth']\n</code>\n</pre>\n", "senID": 5}, {"text": ["Standard library module inspect is the best way to do introspection in Python: it builds on top of the built-in introspection hooks (such as dir and more advanced ones) to offer you useful, rich, and simple introspection services.", "Here, for example, you see that only instance and class methods specifically designed by this class are shown -- not static methods, not instance attributes whether callable or not, not special methods inherited from object.", "If your selectivity needs are slightly different, it's easy to build your own tweaked version of ismethod and pass it as the second argument of getmembers, to tailor the results to your precise, exact needs."], "childNum": 5, "tag": "p", "senID": 6, "childList": [{"text": "inspect", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dir", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "object", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "ismethod", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "getmembers", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; help(my_object)\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Others have mentioned dir.", "Let me make an remark of caution: Python objects may have a __getattr__ method defined which is called when one attempts to call an undefined method on said object.", "Obviously dir does not list all those (infinitely many) method names.", "Some libraries make explicit use of this feature, e.g.", "PLY (Python Lex-Yacc)."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "dir", "tag": "a", "pos": 0, "childList": [{"text": "dir", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/library/functions.html#dir"}, {"text": "dir", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "__getattr__", "tag": "a", "pos": -1, "childList": [{"text": "__getattr__", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/3.1/reference/datamodel.html?highlight=%5F%5Fgetattr%5F%5F#object.%5F%5Fgetattr%5F%5F"}, {"text": "__getattr__", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "dir", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "PLY", "tag": "a", "pos": 4, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/ply/"}]}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; class Test:\n...     def __getattr__(self, name):\n...         return 'foo &lt;%s&gt;' % name\n...\n&gt;&gt;&gt; t = Test()\n&gt;&gt;&gt; t.bar\n'foo &lt;bar&gt;'\n&gt;&gt;&gt; 'bar' in dir(t)\nFalse\n</code>\n</pre>\n", "senID": 2}], [{"text": ["For an enhanced version of dir() check out see()!"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "dir()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "see()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; test = [1,2,3]\n&gt;&gt;&gt; see(test)\n    []    in    +    +=    *    *=    &lt;    &lt;=    ==    !=    &gt;    &gt;=    hash()\n    help()    iter()    len()    repr()    reversed()    str()    .append()\n    .count()    .extend()    .index()    .insert()    .pop()    .remove()\n    .reverse()    .sort()\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can get it here:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["http://pypi.python.org/pypi/see/0.5.4"], "childNum": 0, "tag": "a", "senID": 3, "childList": []}, {"text": ["http://inky.github.com/see/"], "childNum": 0, "tag": "a", "senID": 4, "childList": []}, {"text": ["http://github.com/inky/see/tree/master"], "childNum": 0, "tag": "a", "senID": 5, "childList": []}]}], [{"text": ["Do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dir(obj)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Python supports tab completion as well.", "I prefer my python prompt clean (so no thanks to IPython), but with tab completion."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Setup in .bashrc or similar:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n PYTHONSTARTUP=$HOME/.pythonrc\n</code>\n</pre>\n", "senID": 2}, {"text": ["Put this in .pythonrc:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n try:\n    import readline\nexcept ImportError:\n    print (\"Module readline not available.\")\nelse:\n    print (\"Enabling tab completion\")\n    import rlcompleter\n    readline.parse_and_bind(\"tab: complete\")\n</code>\n</pre>\n", "senID": 4}, {"text": ["It will print \"Enabling tab completion\" each time the python prompt starts up, because it's better to be explicit.", "This won't interfere with execution of python scripts and programs."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"tag": "hr", "senID": 6}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; lst = []\n&gt;&gt;&gt; lst.\nlst.__add__(           lst.__iadd__(          lst.__setattr__(\nlst.__class__(         lst.__imul__(          lst.__setitem__(\nlst.__contains__(      lst.__init__(          lst.__setslice__(\nlst.__delattr__(       lst.__iter__(          lst.__sizeof__(\nlst.__delitem__(       lst.__le__(            lst.__str__(\nlst.__delslice__(      lst.__len__(           lst.__subclasshook__(\nlst.__doc__            lst.__lt__(            lst.append(\nlst.__eq__(            lst.__mul__(           lst.count(\nlst.__format__(        lst.__ne__(            lst.extend(\nlst.__ge__(            lst.__new__(           lst.index(\nlst.__getattribute__(  lst.__reduce__(        lst.insert(\nlst.__getitem__(       lst.__reduce_ex__(     lst.pop(\nlst.__getslice__(      lst.__repr__(          lst.remove(\nlst.__gt__(            lst.__reversed__(      lst.reverse(\nlst.__hash__           lst.__rmul__(          lst.sort(\n</code>\n</pre>\n", "senID": 8}], [{"text": ["If you want only methods, then"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def methods(obj):\n    return [attr for attr in dir(obj) if callable(getattr(obj, attr))]\n</code>\n</pre>\n", "senID": 1}, {"text": ["But do try out IPython, it has tab completion for object attributes, so typing obj.&lt;tab&gt; shows you a list of available attributes on that object."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "obj.&lt;tab&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]