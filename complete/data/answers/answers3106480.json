[[{"text": ["lxml has been mentioned.", "You might also check out lxml.objectify for some really simple manipulation."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "lxml.objectify", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://codespeak.net/lxml/objectify.html"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from lxml import objectify\n&gt;&gt;&gt; tree = objectify.fromstring(your_xml)\n&gt;&gt;&gt; tree.weather.attrib[\"module_id\"]\n'0'\n&gt;&gt;&gt; tree.weather.forecast_information.city.attrib[\"data\"]\n'Mountain View, CA'\n&gt;&gt;&gt; tree.weather.forecast_information.postal_code.attrib[\"data\"]\n'94043'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You want a thin veneer?", "That's easy to cook up.", "Try the following trivial wrapper around ElementTree as a start:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n # geetree.py\nimport xml.etree.ElementTree as ET\n\nclass GeeElem(object):\n    \"\"\"Wrapper around an ElementTree element. a['foo'] gets the\n       attribute foo, a.foo gets the first subelement foo.\"\"\"\n    def __init__(self, elem):\n        self.etElem = elem\n\n    def __getitem__(self, name):\n        res = self._getattr(name)\n        if res is None:\n            raise AttributeError, \"No attribute named '%s'\" % name\n        return res\n\n    def __getattr__(self, name):\n        res = self._getelem(name)\n        if res is None:\n            raise IndexError, \"No element named '%s'\" % name\n        return res\n\n    def _getelem(self, name):\n        res = self.etElem.find(name)\n        if res is None:\n            return None\n        return GeeElem(res)\n\n    def _getattr(self, name):\n        return self.etElem.get(name)\n\nclass GeeTree(object):\n    \"Wrapper around an ElementTree.\"\n    def __init__(self, fname):\n        self.doc = ET.parse(fname)\n\n    def __getattr__(self, name):\n        if self.doc.getroot().tag != name:\n            raise IndexError, \"No element named '%s'\" % name\n        return GeeElem(self.doc.getroot())\n\n    def getroot(self):\n        return self.doc.getroot()\n</code>\n</pre>\n", "senID": 1}, {"text": ["You invoke it so:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import geetree\n&gt;&gt;&gt; t = geetree.GeeTree('foo.xml')\n&gt;&gt;&gt; t.xml_api_reply.weather.forecast_information.city['data']\n'Mountain View, CA'\n&gt;&gt;&gt; t.xml_api_reply.weather.current_conditions.temp_f['data']\n'68'\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Take a look at Amara 2, particularly the Bindery part of this tutorial."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this tutorial", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.xml3k.org/Amara2/Tutorial"}]}, {"text": ["It works in a way pretty similar to what you describe."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["On the other hand.", "ElementTree's find*() methods can give you 90% of that and are packaged with Python."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "find*()", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/xml.etree.elementtree.html#xml.etree.ElementTree.ElementTree.find"}]}], [{"text": ["I highly recommend lxml.etree and xpath to parse and analyse your data.", "Here is a complete example.", "I have truncated the xml to make it easier to read."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import lxml.etree\n\ns = \"\"\"&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;xml_api_reply version=\"1\"&gt;\n  &lt;weather module_id=\"0\" tab_id=\"0\" mobile_row=\"0\" mobile_zipped=\"1\" row=\"0\" section=\"0\" &gt;\n    &lt;forecast_information&gt;\n      &lt;city data=\"Mountain View, CA\"/&gt; &lt;forecast_date data=\"2010-06-23\"/&gt;\n    &lt;/forecast_information&gt;\n    &lt;forecast_conditions&gt;\n      &lt;day_of_week data=\"Sat\"/&gt;\n      &lt;low data=\"59\"/&gt;\n      &lt;high data=\"75\"/&gt;\n      &lt;icon data=\"/ig/images/weather/partly_cloudy.gif\"/&gt;\n      &lt;condition data=\"Partly Cloudy\"/&gt;\n    &lt;/forecast_conditions&gt;\n  &lt;/weather&gt;\n&lt;/xml_api_reply&gt;\"\"\"\n\ntree = lxml.etree.fromstring(s)\nfor weather in tree.xpath('/xml_api_reply/weather'):\n    print weather.find('forecast_information/city/@data')[0]\n    print weather.find('forecast_information/forecast_date/@data')[0]\n    print weather.find('forecast_conditions/low/@data')[0]\n    print weather.find('forecast_conditions/high/@data')[0]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you don't mind using a 3rd party library, then BeautifulSoup will do almost exactly what you ask for:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "BeautifulSoup", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.crummy.com/software/BeautifulSoup/"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from BeautifulSoup import BeautifulStoneSoup\n&gt;&gt;&gt; soup = BeautifulStoneSoup('''&lt;snip&gt;''')\n&gt;&gt;&gt; soup.xml_api_reply.weather.current_conditions.temp_f['data']\nu'68'\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I believe that the built in python xml module will do the trick.", "Look at \"xml.parsers.expat\""], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["xml.parsers.expat"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "xml.parsers.expat", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/pyexpat.html#module-xml.parsers.expat"}]}], [{"text": ["The suds project provides a Web Services client library that works almost exactly as you describe -- provide it a wsdl and then use factory methods to create the defined types (and process the responses too!", ")."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I found the following python-simplexml module, which in the attempts of the author to get something close to SimpleXML from PHP is indeed a small wrapper around ElementTree.", "It's under 100 lines but seems to do what was requested:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "python-simplexml", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://github.com/joestump/python-simplexml"}, {"text": "small wrapper around ElementTree", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import SimpleXml\n&gt;&gt;&gt; x = SimpleXml.parse(urllib.urlopen('http://www.google.com/ig/api?weather=94043'))\n&gt;&gt;&gt; print x.weather.current_conditions.temp_f['data']\n58\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you haven't already, I'd suggest looking into the DOM API for Python.", "DOM is a pretty widely used XML interpretation system, so it should be pretty robust."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "DOM API for Python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/xml.dom.html"}]}, {"text": ["It's probably a little more complicated than what you describe, but that comes from its attempts to preserve all the information implicit in XML markup rather than from bad design."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]