[[{"text": ["Using generator functions can make your example a little easier to read and probably boost the performance."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def flatten(l):\n    for el in l:\n        if isinstance(el, collections.Iterable) and not isinstance(el, basestring):\n            for sub in flatten(el):\n                yield sub\n        else:\n            yield el\n</code>\n</pre>\n", "senID": 1}, {"text": ["I used the Iterable ABC added in 2.6."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Iterable ABC", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/collections.html#abcs-abstract-base-classes"}]}], [{"text": ["Generator version of @unutbu's non-recursive solution, as requested by @Andrew in a comment:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def genflat(l, ltypes=collections.Sequence):\n    l = list(l)\n    i = 0\n    while i &lt; len(l):\n        while isinstance(l[i], ltypes):\n            if not l[i]:\n                l.pop(i)\n                i -= 1\n                break\n            else:\n                l[i:i + 1] = l[i]\n        yield l[i]\n        i += 1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Slightly simplified version of this generator:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def genflat(l, ltypes=collections.Sequence):\n    l = list(l)\n    while l:\n        while l and isinstance(l[0], ltypes):\n            l[0:1] = l[0]\n        if l: yield l.pop(0)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This version of flatten avoids python's recursion limit (and thus works with arbitrarily-deep nested lists):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "flatten", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def flatten(l, ltypes=collections.Sequence):\n    # http://rightfootin.blogspot.com/2006/09/more-on-python-flatten.html\n    # http://stackoverflow.com/questions/716477/join-list-of-lists-in-python/716479#716479\n    # flatten([[1,2,3],[4,5,6],[7,8,9]]) --&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    ltype = type(l)\n    l = list(l)\n    i = 0\n    while i &lt; len(l):\n        while isinstance(l[i], ltypes):\n            if not l[i]:\n                l.pop(i)\n                i -= 1\n                break\n            else:\n                l[i:i + 1] = l[i]\n        i += 1\n    return ltype(l)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here is a generator versions of the same thing:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def flatten_gen(l, ltypes=collections.Sequence):       \n    ltype = type(l)\n    l = list(l)\n    i = 0\n    while i &lt; len(l):\n        while isinstance(l[i], ltypes):\n            if not l[i]:\n                l.pop(i)\n                i -= 1\n                break\n            else:\n                l[i:i + 1] = l[i]\n        else:\n            yield l[i]\n        i += 1\n</code>\n</pre>\n", "senID": 3}], [{"text": ["My solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def flatten(x):\n    if isinstance(x, collections.Iterable):\n        return [a for i in x for a in flatten(i)]\n    else:\n        return [x]\n</code>\n</pre>\n", "senID": 1}, {"text": ["A little more concise, but pretty much the same."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's another answer that is even more interesting..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\ndef Flatten(TheList):\n    a = str(TheList)\n    b,crap = re.subn(r'[\\[,\\]]', ' ', a)\n    c = b.split()\n    d = [int(x) for x in c]\n\n    return(d)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Basically, it converts the nested list to a string, uses a regex to strip out the nested syntax, and then converts the result back to a (flattened) list."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["python3"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "python3", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from functools import reduce\n&gt;&gt;&gt; flatten = lambda x:reduce(lambda x,y:x+y,map(flatten,x)) if isinstance(x[0],list) else x\n&gt;&gt;&gt; t = [[['3', '1'], ['5', '7']], [['6'], ['8', '11']], [['2', '1']], [['43'], ['66', '51']], [['77'], ['']]]\n&gt;&gt;&gt; flatten(t)\n['3', '1', '5', '7', '6', '8', '11', '2', '1', '43', '66', '51', '77', '']\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I prefer simple answers.", "No generators.", "No recursion or recursion limits.", "Just iteration:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def flatten(TheList):\n    listIsNested = True\n\n    while listIsNested:                 #outer loop\n        keepChecking = False\n        Temp = []\n\n        for element in TheList:         #inner loop\n            if isinstance(element,list):\n                Temp.extend(element)\n                keepChecking = True\n            else:\n                Temp.append(element)\n\n        listIsNested = keepChecking     #determine if outer loop exits\n        TheList = Temp[:]\n\n    return TheList\n</code>\n</pre>\n", "senID": 1}, {"text": ["This works with two lists: an inner for loop and an outer while loop.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["The inner for loop iterates through the list.", "If it finds a list element, it (1) uses list.extend() to flatten that part one level of nesting and (2) switches keepChecking to True.", "keepchecking is used to control the outer while loop.", "If the outer loop gets set to true, it triggers the inner loop for another pass.  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Those passes keep happening until no more nested lists are found.", "When a pass finally occurs where none are found, keepChecking never gets tripped to true, which means listIsNested stays false and the outer while loop exits.  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["The flattened list is then returned."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Test-run   "], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n flatten([1,2,3,4,[100,200,300,[1000,2000,3000]]])\n</code>\n</pre>\n", "senID": 7}, {"text": ["[1, 2, 3, 4, 100, 200, 300, 1000, 2000, 3000]"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "[1, 2, 3, 4, 100, 200, 300, 1000, 2000, 3000]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Here is my functional version of recursive flatten which handles both tuples and lists, and lets you throw in any mix of positional arguments.", "Returns a generator which produces the entire sequence in order, arg by arg:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n flatten = lambda *n: (e for a in n\n    for e in (flatten(*a) if isinstance(a, (tuple, list)) else (a,)))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n l1 = ['a', ['b', ('c', 'd')]]\nl2 = [0, 1, (2, 3), [[4, 5, (6, 7, (8,), [9]), 10]], (11,)]\nprint list(flatten(l1, -2, -1, l2))\n['a', 'b', 'c', 'd', -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If you like recursion, this might be a solution of interest to you:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def f(E):\n    if E==[]: \n        return []\n    elif type(E) != list: \n        return [E]\n    else:\n        a = f(E[0])\n        b = f(E[1:])\n        a.extend(b)\n        return a\n</code>\n</pre>\n", "senID": 1}, {"text": ["I actually adapted this from some practice Scheme code that I had written a while back. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Enjoy!"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I'm new to python and come from a lisp background.", "This is what I came up with (check out the var names for lulz):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def flatten(lst):\n    if lst:\n        car,*cdr=lst\n        if isinstance(car,(list,tuple)):\n            if cdr: return flatten(car) + flatten(cdr)\n            return flatten(car)\n        if cdr: return [car] + flatten(cdr)\n        return [car]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Seems to work.", "Test:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n flatten((1,2,3,(4,5,6,(7,8,(((1,2)))))))\n</code>\n</pre>\n", "senID": 3}, {"text": ["returns:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n [1, 2, 3, 4, 5, 6, 7, 8, 1, 2]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Although an elegant and very pythonic answer has been selected I would present my solution just for the review:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def flat(l):\n    ret = []\n    for i in l:\n        if isinstance(i, list) or isinstance(i, tuple):\n            ret.extend(flat(i))\n        else:\n            ret.append(i)\n    return ret\n</code>\n</pre>\n", "senID": 1}, {"text": ["Please tell how good or bad this code is?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I don't see anything like this posted around here and just got here from a closed question on the same subject, but why not just do something like this(if you know the type of the list you want to split):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You would need to know the type of the elements but I think this can be generalised and in terms of speed I think it would be faster."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]