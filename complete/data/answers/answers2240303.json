[[{"text": ["tokenize can help:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "tokenize", "tag": "a", "pos": 0, "childList": [{"text": "tokenize", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/tokenize.html"}, {"text": "tokenize", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import StringIO\n&gt;&gt;&gt; s = StringIO.StringIO('27GB')\n&gt;&gt;&gt; for token in tokenize.generate_tokens(s.readline):\n...   print token\n... \n(2, '27', (1, 0), (1, 2), '27GB')\n(1, 'GB', (1, 2), (1, 4), '27GB')\n(0, '', (2, 0), (2, 0), '')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could use a regular expression to divide the string into groups:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; p = re.compile('(\\d+)\\s*(\\w+)')\n&gt;&gt;&gt; p.match('2GB').groups()\n('2', 'GB')\n&gt;&gt;&gt; p.match('17 ft').groups()\n('17', 'ft')\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n s='17GB'\nfor i,c in enumerate(s):\n    if not c.isdigit():\n        break\nnumber=int(s[:i])\nunit=s[i:]\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You can break out of the loop when you find the first non-digit character"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i,c in enumerate(s):\n    if not c.isdigit():\n        break\nnumber = s[:i]\nunit = s[i:].lstrip()\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you have negative and decimals:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n numeric = '0123456789-.'\nfor i,c in enumerate(s):\n    if c not in numeric:\n        break\nnumber = s[:i]\nunit = s[i:].lstrip()\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n &gt;&gt;&gt; s=\"17GB\"\n&gt;&gt;&gt; ind=map(str.isalpha,s).index(True)\n&gt;&gt;&gt; num,suffix=s[:ind],s[ind:]\n&gt;&gt;&gt; print num+\":\"+suffix\n17:GB\n</code>\n</pre>\n", "senID": 0}], [{"text": ["How about using a regular expression"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://python.org/doc/1.6/lib/module-regsub.html"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://python.org/doc/1.6/lib/module-regsub.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://python.org/doc/1.6/lib/module-regsub.html"}]}], [{"text": ["You should use regular expressions, grouping together what you want to find out:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\ns = \"17GB\"\nmatch = re.match(r\"^([1-9][0-9]*)\\s*(GB|MB|KB|B)$\", s)\nif match:\n  print \"Number: %d, unit: %s\" % (int(match.group(1)), match.group(2))\n</code>\n</pre>\n", "senID": 1}, {"text": ["Change the regex according to what you want to parse.", "If you're unfamiliar with regular expressions, here's a great tutorial site."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "here's", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.regular-expressions.info/"}]}], [{"text": ["For this task, I would definitely use a regular expression:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nthere = re.compile(r'\\s*(\\d+)\\s*(\\S+)')\nthematch = there.match(s)\nif thematch:\n  number, unit = thematch.groups()\nelse:\n  raise ValueError('String %r not in the expected format' % s)\n</code>\n</pre>\n", "senID": 1}, {"text": ["In the RE pattern, \\s means \"whitespace\", \\d means \"digit\", \\S means non-whitespace; * means \"0 or more of the preceding\", + means \"1 or more of the preceding, and the parentheses enclose \"capturing groups\" which are then returned by the groups() call on the match-object.", "(thematch is None if the given string doesn't correspond to the pattern: optional whitespace, then one or more digits, then optional whitespace, then one or more non-whitespace characters)."], "childNum": 7, "tag": "p", "senID": 2, "childList": [{"text": "\\s", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "\\d", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\\S", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "+", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "groups()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "thematch", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["A regular expression."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nm = re.match(r'\\s*(?P&lt;n&gt;[-+]?[.0-9])\\s*(?P&lt;u&gt;.*)', s)\nif m is None:\n  raise ValueError(\"not a number with units\")\nnumber = m.group(\"n\")\nunit = m.group(\"u\")\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will give you a number (integer or fixed point; too hard to disambiguate scientific notation's \"e\" from a unit prefix) with an optional sign, followed by the units, with optional whitespace."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You can use re.compile() if you're going to be doing a lot of matches."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "re.compile()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]