[[{"text": ["This is a neat problem, and I've been thinking about it for a while (with solutions similar to Sjoerd's), but in the end, here's what I think:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Sjoerd's", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2076838/generating-non-repeating-random-numbers-in-python/2076937#2076937"}]}, {"text": ["Use your point 1) and stop worrying."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Assuming real randomness, the probability that a random number has already been chosen before is the count of previously chosen numbers divided by the size of your pool, i.e.", "the maximal number."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you say you only need a billion numbers, i.e.", "nine digits: Treat yourself to 3 more digits, so you have 12-digit serial numbers (that's three groups of four digits &ndash; nice and readable)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Even when you're close to having chosen a billion numbers previously, the probability that your new number is already taken is still only 0,1%."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Do step 1 and draw again.", "You can still check for an \"infinite\" loop, say don't try more than 1000 times or so, and then fallback to adding 1 (or something else)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["You'll win the lottery before that fallback ever gets used."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["With some modular arithmic and prime numbers, you can create all numbers between 0 and a big prime, out of order.", "If you choose your numbers carefully, the next number is hard to guess."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "If you choose your numbers carefully, the next number is hard to guess.", "childNum": 0, "tag": "strike", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n modulo = 87178291199 # prime\nincrementor = 17180131327 # relative prime\n\ncurrent = 433494437 # some start value\nfor i in xrange(1, 100):\n    print current\n    current = (current + incrementor) % modulo\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I think you are overestimating the problems with approach 1).", "Unless you have hard-realtime requirements just checking by random choice terminates rather fast.", "The probability of needing more than a number of iterations decays exponentially.", "With 100M numbers outputted (10% fillfactor) you'll have one in billion chance of requiring more than 9 iterations.", "Even with 50% of numbers taken you'll on average need 2 iterations and have one in a billion chance of requiring more than 30 checks.", "Or even the extreme case where 99% of the numbers are already taken might still be reasonable - you'll average a 100 iterations and have 1 in a billion change of requiring 2062 iterations"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["My first thought is to use a symmetric encryption algorithm (e.g.", "DES or AES) in counter mode.", "Your counter just goes from 0 upwards, and the encryption uses a key of your choice to turn it into a seemingly random value, that is guaranteed to never have collisions (because cryptographic algorithms create a 1:1 mapping).", "One benefit is that this is reversible, so you could take the serial number and decrypt it to get back to the simple counter value."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "DES", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Data_Encryption_Standard"}, {"text": "AES", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"}, {"text": "counter mode", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29"}]}, {"text": ["The one problem I see with this is that the encrypted value is 64 bits (for DES) which would give you a 20-digit decimal serial number which is probably impractically large."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Still, since you aren't really after a cryptographic solution, I wonder if you could take this general idea and adapt it for your needs.", "Interested in making a \"32-bit block encryption algorithm\"?"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "\"32-bit block encryption algorithm\"", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://www.codeproject.com/KB/security/xOr.aspx"}]}, {"text": ["(Actually, you mention timing attacks, so perhaps you do need something cryptographically secure?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["The standard Linear Congruential random number generator's seed sequence CANNOT repeat until the full set of numbers from the starting seed value have been generated.", "Then it MUST repeat precisely.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The internal seed is often large (48 or 64 bits).", "The generated numbers are smaller (32 bits usually) because the entire set of bits are not random.", "If you follow the seed values they will form a distinct non-repeating sequence.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The question is essentially one of locating a good seed that generates \"enough\" numbers.", "You can pick a seed, and generate numbers until you get back to the starting seed.", "That's the length of the sequence.", "It may be millions or billions of numbers."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["There are some guidelines in Knuth for picking suitable seeds that will generate very long sequences of unique numbers."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If they don't have to be random, but just not obviously linear (1, 2, 3, 4, ...), then here's a simple algorithm:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Pick two prime numbers.", "One of them will be the largest number you can generate, so it should be around one billion.", "The other should be fairly large."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n max_value = 795028841\nstep = 360287471\nprevious_serial = 0\nfor i in xrange(0, max_value):\n    previous_serial += step\n    previous_serial %= max_value\n    print \"Serial: %09i\" % previous_serial\n</code>\n</pre>\n", "senID": 2}, {"text": ["Just store the previous serial each time so you know where you left off.", "I can't prove mathmatically that this works (been too long since those particular classes), but it's demonstrably correct with smaller primes:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n s = set()\nwith open(\"test.txt\", \"w+\") as f:\n    previous_serial = 0\n    for i in xrange(0, 2711):\n        previous_serial += 1811\n        previous_serial %= 2711\n        assert previous_serial not in s\n        s.add(previous_serial)\n</code>\n</pre>\n", "senID": 4}, {"text": ["You could also prove it empirically with 9-digit primes, it'd just take a bit more work (or a lot more memory)."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["This does mean that given a few serial numbers, it'd be possible to figure out what your values are--but with only nine digits, it's not likely that you're going for unguessable numbers anyway."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["If you don't need something cryptographically secure, but just \"sufficiently obfuscated\"..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Galois Fields"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Galois Fields", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["You could try operations in Galois Fields, e.g.", "GF(2)32, to map a simple incrementing counter x to a seemingly random serial number y:"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "Galois Fields", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Finite_field"}, {"text": "32", "childNum": 0, "tag": "sup", "pos": 1, "childList": []}, {"text": "x", "childNum": 0, "tag": "em", "childList": []}, {"text": "y", "childNum": 0, "tag": "em", "childList": []}]}, {"code": "<pre>\n<code>\n x = counter_value\ny = some_galois_function(x)\n</code>\n</pre>\n", "senID": 3}, {"tag": "ul", "num": 4, "lis": [{"text": "Multiply by a constant\n", "tag": "none", "senID": 4}, {"text": ["Raise to a power"], "childNum": 0, "tag": "a", "senID": 5, "childList": []}, {"text": "Reciprocal ", "tag": "none", "senID": 6}, {"text": ["Exponentiation"], "childNum": 0, "tag": "a", "senID": 7, "childList": []}]}, {"text": ["Many of these operations have an inverse, which means, given your serial number, you can calculate the original counter value from which it was derived."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["As for finding a library for Galois Field for Python... good question.", "If you don't need speed (which you wouldn't for this) then you could make your own.", "I haven't tried these:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"tag": "ul", "num": 3, "lis": [{"text": ["NZMATH"], "childNum": 0, "tag": "a", "senID": 10, "childList": []}, {"text": ["Finite field Python package"], "childNum": 0, "tag": "a", "senID": 11, "childList": []}, {"text": ["Sage"], "childNum": 0, "tag": "a", "senID": 12, "childList": []}]}, {"text": ["Matrix multiplication in GF(2)"], "childNum": 2, "tag": "p", "senID": 13, "childList": [{"text": "Matrix multiplication in GF(2)", "childNum": 1, "tag": "em", "pos": 0, "childList": [{"text": "Matrix multiplication in GF(2)", "tag": "strong"}]}, {"text": "Matrix multiplication in GF(2)", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Pick a suitable 32\u00d732 invertible matrix in GF(2), and multiply a 32-bit input counter by it.", "This is conceptually related to LFSR, as described in S.Lott's answer."], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "S.Lott's answer", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/a/2077409/60075"}]}, {"text": ["CRC"], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "CRC", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["A related possibility is to use a CRC calculation.", "Based on the remainder of long-division with an irreducible polynomial in GF(2).", "Python code is readily available for CRCs (crcmod, pycrc), although you might want to pick a different irreducible polynomial than is normally used, for your purposes.", "I'm a little fuzzy on the theory, but I think a 32-bit CRC should generate a unique value for every possible combination of 4-byte inputs.", "Check this.", "It's quite easy to experimentally check this, by feeding the output back into the input, and checking that it produces a complete cycle of length 232-1 (zero just maps to zero).", "You may need to get rid of any initial/final XORs in the CRC algorithm for this check to work."], "childNum": 4, "tag": "p", "senID": 16, "childList": [{"text": "CRC", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Cyclic_redundancy_check"}, {"text": "crcmod", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://crcmod.sourceforge.net/"}, {"text": "pycrc", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://www.tty1.net/pycrc/"}, {"text": "32", "childNum": 0, "tag": "sup", "pos": 3, "childList": []}]}], [{"text": ["Do you need this to be cryptographically secure or just hard to guess?", "How bad are collisions?", "Because if it needs to be cryptographically strong and have zero collisions, it is, sadly, impossible."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I started trying to write an explanation of the approach used below, but just implementing it was easier and more accurate.", "This approach has the odd behavior that it gets faster the more numbers you've generated.", "But it works, and it doesn't require you to generate all the numbers in advance.  "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As a simple optimization, you could easily make this class use a probabilistic algorithm (generate a random number, and if it's not in the set of used numbers add it to the set and return it) at first, keep track of the collision rate, and switch over to the deterministic approach used here once the collision rate gets bad."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import random\n\nclass NonRepeatingRandom(object):\n\n    def __init__(self, maxvalue):\n        self.maxvalue = maxvalue\n        self.used = set()\n\n    def next(self):\n        if len(self.used) &gt;= self.maxvalue:\n            raise StopIteration\n        r = random.randrange(0, self.maxvalue - len(self.used))\n        result = 0\n        for i in range(1, r+1):\n            result += 1\n            while result in self.used:\n                 result += 1\n        self.used.add(result)\n        return result\n\n    def __iter__(self):\n        return self\n\n    def __getitem__(self):\n        raise NotImplemented\n\n    def get_all(self):\n        return [i for i in self]\n\n&gt;&gt;&gt; n = NonRepeatingRandom(20)\n&gt;&gt;&gt; n.get_all()\n[12, 14, 13, 2, 20, 4, 15, 16, 19, 1, 8, 6, 7, 9, 5, 11, 10, 3, 18, 17]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["You can run 1) without running into the problem of too many wrong random numbers if you just decrease the random interval by one each time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For this method to work, you will need to save the numbers already given (which you want to do anyway) and also save the quantity of numbers taken."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It is pretty obvious that, after having collected 10 numbers, your pool of possible random numbers will have been decreased by 10.", "Therefore, you must not choose a number between 1 and 1.000.000 but between 1 an 999.990.", "Of course this number is not the real number but only an index (unless the 10 numbers collected have been 999.991, 999.992, \u2026); you\u2019d have to count now from 1 omitting all the numbers already collected."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Of course, your algorithm should be smarter than just counting from 1 to 1.000.000 but I hope you understand the method."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I don\u2019t like drawing random numbers until I get one which fits either.", "It just feels wrong."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["If it is enough for you that a casual observer can't guess the next value, you can use things like a linear congruential generator or even a simple linear feedback shift register to generate the values and keep the state in the database in case you need more values.", "If you use these right, the values won't repeat until the end of the universe.", "You'll find more ideas in the list of random number generators."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "linear congruential generator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Linear_congruential_generator"}, {"text": "linear feedback shift register", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Linear_feedback_shift_register"}, {"text": "list of random number generators", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/List_of_pseudorandom_number_generators"}]}, {"text": ["If you think there might be someone who would have a serious interest to guess the next values, you can use a database sequence to count the values you generate and encrypt them with an encryption algorithm or another cryptographically strong perfect has function.", "However you need to take care that the encryption algorithm isn't easily breakable if one can get hold of a sequence of successive numbers you generated - a simple RSA, for instance, won't do it because of the Franklin-Reiter Related Message Attack."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "RSA", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/RSA_%28algorithm%29"}, {"href": "http://en.wikipedia.org/wiki/Coppersmith%27s_Attack", "text": "Franklin-Reiter Related Message Attack", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I'd rethink the problem itself... You don't seem to be doing anything sequential with the numbers... and you've got an index on the column which has them.", "Do they actually need to be numbers?"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "need", "childNum": 0, "tag": "strong", "pos": 1, "childList": []}, {"text": "numbers", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["Consider a sha hash... you don't actually need the entire thing.", "Do what git or other url shortening services do, and take first 3/4/5 characters of the hash.", "Given that each character now has 36 possible values instead of 10, you have 2,176,782,336 combinations instead of 999,999 combinations (for six digits).", "Combine that with a quick check on whether the combination exists (a pure index query) and a seed like a timestamp + random number and it should do for almost any situation.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You are stating that you store the numbers in a database."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Wouldn't it then be easier to store all the numbers there, and ask the database for a random unused number?", "Most databases support such a request."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Examples"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["MySQL:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n SELECT column FROM table\nORDER BY RAND()\nLIMIT 1\n</code>\n</pre>\n", "senID": 4}, {"text": ["PostgreSQL:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n SELECT column FROM table\nORDER BY RANDOM()\nLIMIT 1\n</code>\n</pre>\n", "senID": 6}]]