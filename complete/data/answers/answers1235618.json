[[{"code": "<pre>\n<code>\n thelist[:] = [d for d in thelist if d.get('id') != 2]\n</code>\n</pre>\n", "senID": 0}, {"text": ["Edit: as some doubts have been expressed in a comment about the performance of this code (some based on misunderstanding Python's performance characteristics, some on assuming beyond the given specs that there is exactly one dict in the list with a value of 2 for key 'id'), I wish to offer reassurance on this point."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["On an old Linux box, measuring this code:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ python -mtimeit -s\"lod=[{'id':i, 'name':'nam%s'%i} for i in range(99)]; import random\" \"thelist=list(lod); random.shuffle(thelist); thelist[:] = [d for d in thelist if d.get('id') != 2]\"\n10000 loops, best of 3: 82.3 usec per loop\n</code>\n</pre>\n", "senID": 3}, {"text": ["of which about 57 microseconds for the random.shuffle (needed to ensure that the element to remove is not ALWAYS at the same spot;-) and 0.65 microseconds for the initial copy (whoever worries about performance impact of shallow copies of Python lists is most obviously out to lunch;-), needed to avoid altering the original list in the loop (so each leg of the loop does have something to delete;-)."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["When it is known that there is exactly one item to remove, it's possible to locate and remove it even more expeditiously:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n $ python -mtimeit -s\"lod=[{'id':i, 'name':'nam%s'%i} for i in range(99)]; import random\" \"thelist=list(lod); random.shuffle(thelist); where=(i for i,d in enumerate(thelist) if d.get('id')==2).next(); del thelist[where]\"\n10000 loops, best of 3: 72.8 usec per loop\n</code>\n</pre>\n", "senID": 6}, {"text": ["(use the next builtin rather than the .next method if you're on Python 2.6 or better, of course) -- but this code breaks down if the number of dicts that satisfy the removal condition is not exactly one.", "Generalizing this, we have:"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "next", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": ".next", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n $ python -mtimeit -s\"lod=[{'id':i, 'name':'nam%s'%i} for i in range(33)]*3; import random\" \"thelist=list(lod); where=[i for i,d in enumerate(thelist) if d.get('id')==2]; where.reverse()\" \"for i in where: del thelist[i]\"\n10000 loops, best of 3: 23.7 usec per loop\n</code>\n</pre>\n", "senID": 8}, {"text": ["where the shuffling can be removed because there are already three equispaced dicts to remove, as we know.", "And the listcomp, unchanged, fares well:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n $ python -mtimeit -s\"lod=[{'id':i, 'name':'nam%s'%i} for i in range(33)]*3; import random\" \"thelist=list(lod); thelist[:] = [d for d in thelist if d.get('id') != 2]\"\n10000 loops, best of 3: 23.8 usec per loop\n</code>\n</pre>\n", "senID": 10}, {"text": ["totally neck and neck, with even just 3 elements of 99 to be removed.", "With longer lists and more repetitions, this holds even more of course:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n $ python -mtimeit -s\"lod=[{'id':i, 'name':'nam%s'%i} for i in range(33)]*133; import random\" \"thelist=list(lod); where=[i for i,d in enumerate(thelist) if d.get('id')==2]; where.reverse()\" \"for i in where: del thelist[i]\"\n1000 loops, best of 3: 1.11 msec per loop\n$ python -mtimeit -s\"lod=[{'id':i, 'name':'nam%s'%i} for i in range(33)]*133; import random\" \"thelist=list(lod); thelist[:] = [d for d in thelist if d.get('id') != 2]\"\n1000 loops, best of 3: 998 usec per loop\n</code>\n</pre>\n", "senID": 12}, {"text": ["All in all, it's obviously not worth deploying the subtlety of making and reversing the list of indices to remove, vs the perfectly simple and obvious list comprehension, to possibly gain 100 nanoseconds in one small case -- and lose 113 microseconds in a larger one;-).", "Avoiding or criticizing simple, straightforward, and perfectly performance-adequate solutions (like list comprehensions for this general class of \"remove some items from a list\" problems) is a particularly nasty example of Knuth's and Hoare's well-known thesis that \"premature optimization is the root of all evil in programming\"!-)"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["This is not properly an anwser (as I think you already have some quite good of them), but... have you considered of having a dictionary of &lt;id&gt;:&lt;name&gt; instead of a list of dictionaries?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "&lt;id&gt;:&lt;name&gt;", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["list.pop() is a good choice:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [{'id': 1, 'name': 'paul'},\n... {'id': 2, 'name': 'john'}]\n&gt;&gt;&gt; a.pop(1)\n{'id': 2, 'name': 'john'}\n&gt;&gt;&gt; a\n[{'id': 1, 'name': 'paul'}]\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can develop other ways of tracking done which dictionary you want to eliminate, so long as it resolves to an integer.", "Here is one of those ways:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "which", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = [{'id': 1, 'name': 'paul'},\n... {'id': 2, 'name': 'john'}]\n&gt;&gt;&gt; for i in reversed(range(len(a))):\n...     if a[i].get('id') == 2:\n...             a.pop(i)\n...\n{'id': 2, 'name': 'john'}\n&gt;&gt;&gt; a\n[{'id': 1, 'name': 'paul'}]\n</code>\n</pre>\n", "senID": 3}, {"text": ["Another possibility is to use del:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n [{'id': 1, 'name': 'paul'}]\n&gt;&gt;&gt; a = [{'id': 1, 'name': 'paul'},\n... {'id': 2, 'name': 'john'}]\n&gt;&gt;&gt; a\n[{'id': 1, 'name': 'paul'}, {'id': 2, 'name': 'john'}]\n&gt;&gt;&gt; del a[1]\n&gt;&gt;&gt; a\n[{'id': 1, 'name': 'paul'}]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Here's a way to do it with a list comprehension (assuming you name your list 'foo'):"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [x for x in foo if not (2 == x.get('id'))]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Substitute 'john' == x.get('name') or whatever as appropriate."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "'john' == x.get('name')", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["filter also works:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "filter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["foo.filter(lambda x: x.get('id')!=2, foo)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "foo.filter(lambda x: x.get('id')!=2, foo)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["And if you want a generator you can use itertools:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["itertools.ifilter(lambda x: x.get('id')!=2, foo)"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "itertools.ifilter(lambda x: x.get('id')!=2, foo)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["However, as of Python 3, filter will return an iterator anyway, so the list comprehension is really the best choice, as Alex suggested."], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "filter", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["You can try the following: "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n a = [{'id': 1, 'name': 'paul'},\n     {'id': 2, 'name': 'john'}]\n\nfor e in range(len(a) - 1, -1, -1):\n    if a[e]['id'] == 2:\n        a.pop(e)\n</code>\n</pre>\n", "senID": 1}, {"text": ["If You can't pop from the beginning - pop from the end, it won't ruin the for loop."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could try something along the following lines:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def destructively_remove_if(predicate, list):\n      for k in xrange(len(list)):\n          if predicate(list[k]):\n              del list[k]\n              break\n      return list\n\n  list = [\n      { 'id': 1, 'name': 'John' },\n      { 'id': 2, 'name': 'Karl' },\n      { 'id': 3, 'name': 'Desdemona' } \n  ]\n\n  print \"Before:\", list\n  destructively_remove_if(lambda p: p[\"id\"] == 2, list)\n  print \"After:\", list\n</code>\n</pre>\n", "senID": 1}, {"text": ["Unless you build something akin to an index over your data, I\ndon't think that you can do better than doing a brute-force \"table\nscan\" over the entire list.", "If your data is sorted by the key you\nare using, you might be able to employ the bisect module to\nfind the object you are looking for somewhat faster."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "bisect", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"code": "<pre>\n<code>\n # assume ls contains your list\nfor i in range(len(ls)):\n    if ls[i]['id'] == 2:\n        del ls[i]\n        break\n</code>\n</pre>\n", "senID": 0}, {"text": ["Will probably be faster than the list comprehension methods on average because it doesn't traverse the whole list if it finds the item in question early on."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]