[[{"text": ["This activestate recipe gives an easy-to-follow approach, specifically the version in the comments that doesn't require you to pre-normalize your weights:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "This activestate recipe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/117241/"}]}, {"code": "<pre>\n<code>\n import random\n\ndef weighted_choice(items):\n    \"\"\"items is a list of tuples in the form (item, weight)\"\"\"\n    weight_total = sum((item[1] for item in items))\n    n = random.uniform(0, weight_total)\n    for item, weight in items:\n        if n &lt; weight:\n            return item\n        n = n - weight\n    return item\n</code>\n</pre>\n", "senID": 1}, {"text": ["This will be slow if you have a large list of items.", "A binary search would probably be better in that case... but would also be more complicated to write, for little gain if you have a small sample size.", "Here's an example of the binary search approach in python if you want to follow that route."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Here's an example of the binary search approach in python", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/498229/"}]}, {"text": ["(I'd recommend doing some quick performance testing of both methods on your dataset.", "The performance of different approaches to this sort of algorithm is often a bit unintuitive."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"tag": "hr", "senID": 4}, {"text": ["Edit: I took my own advice, since I was curious, and did a few tests."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["I compared four approaches:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["*The weighted_choice function above."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["A binary-search choice function like so:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "A binary-search choice function like so:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def weighted_choice_bisect(items):\n    added_weights = []\n    last_sum = 0\n\n    for item, weight in items:\n        last_sum += weight\n        added_weights.append(last_sum)\n\n    return items[bisect.bisect(added_weights, random.random() * last_sum)][0]\n</code>\n</pre>\n", "senID": 9}, {"text": ["A compiling version of 1:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "A compiling version of 1:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def weighted_choice_compile(items):\n    \"\"\"returns a function that fetches a random item from items\n\n    items is a list of tuples in the form (item, weight)\"\"\"\n    weight_total = sum((item[1] for item in items))\n    def choice(uniform = random.uniform):\n        n = uniform(0, weight_total)\n        for item, weight in items:\n            if n &lt; weight:\n                return item\n            n = n - weight\n        return item\n    return choice\n</code>\n</pre>\n", "senID": 11}, {"text": ["A compiling version of 2:"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "A compiling version of 2:", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def weighted_choice_bisect_compile(items):\n    \"\"\"Returns a function that makes a weighted random choice from items.\"\"\"\n    added_weights = []\n    last_sum = 0\n\n    for item, weight in items:\n        last_sum += weight\n        added_weights.append(last_sum)\n\n    def choice(rnd=random.random, bis=bisect.bisect):\n        return items[bis(added_weights, rnd() * last_sum)][0]\n    return choice\n</code>\n</pre>\n", "senID": 13}, {"text": ["I then built a big list of choices like so:"], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"code": "<pre>\n<code>\n choices = [(random.choice(\"abcdefg\"), random.uniform(0,50)) for i in xrange(2500)]\n</code>\n</pre>\n", "senID": 15}, {"text": ["And an excessively simple profiling function:"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"code": "<pre>\n<code>\n def profiler(f, n, *args, **kwargs):\n    start = time.time()\n    for i in xrange(n):\n        f(*args, **kwargs)\n    return time.time() - start\n</code>\n</pre>\n", "senID": 17}, {"text": ["The results:"], "childNum": 1, "tag": "p", "senID": 18, "childList": [{"text": "The results:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["(Seconds taken for 1,000 calls to the function."], "childNum": 0, "tag": "p", "senID": 19, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Simple uncompiled: 0.918624162674", "tag": "none", "senID": 20}, {"text": "Binary uncompiled: 1.01497793198", "tag": "none", "senID": 21}, {"text": "Simple compiled: 0.287325024605", "tag": "none", "senID": 22}, {"text": "Binary compiled: 0.00327413797379", "tag": "none", "senID": 23}]}, {"text": ["The \"compiled\" results include the average time taken to compile the choice function once.", "(I timed 1,000 compiles, then divided that time by 1,000, and added the result to the choice function time."], "childNum": 0, "tag": "p", "senID": 24, "childList": []}, {"text": ["So: if you have a list of items+weights which change very rarely, the binary compiled method is by far the fastest."], "childNum": 1, "tag": "p", "senID": 25, "childList": [{"text": "by far", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["In comments on the original post, Nicholas Leonard suggests that both the exchanging and the sampling need to be fast.", "Here's an idea for that case; I haven't tried it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If only sampling had to be fast, we could use an array of the values together with the running sum of their probabilities, and do a binary search on the running sum (with key being a uniform random number) -- an O(log(n)) operation.", "But an exchange would require updating all of the running-sum values appearing after the entries exchanged -- an O(n) operation.", "(Could you choose to exchange only items near the end of their lists?", "I'll assume not."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So let's aim for O(log(n)) in both operations.", "Instead of an array, keep a binary tree for each set to sample from.", "A leaf holds the sample value and its (unnormalized) probability.", "A branch node holds the total probability of its children."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["To sample, generate a uniform random number x between 0 and the total probability of the root, and descend the tree.", "At each branch, choose the left child if the left child has total probability &lt;= x.", "Else subtract the left child's probability from x and go right.", "Return the leaf value you reach."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "&lt;= x", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["To exchange, remove the leaf from its tree and adjust the branches that lead down to it (decreasing their total probability, and cutting out any single-child branch nodes).", "Insert the leaf into the destination tree: you have a choice of where to put it, so keep it balanced.", "Picking a random child at each level is probably good enough -- that's where I'd start.", "Increase each parent node's probability, back up to the root."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Now both sampling and exchange are O(log(n)) on average.", "(If you need guaranteed balance, a simple way is to add another field to the branch nodes holding the count of leaves in the whole subtree.", "When adding a leaf, at each level pick the child with fewer leaves.", "This leaves the possibility of a tree getting unbalanced solely by deletions; this can't be a problem if there's reasonably even traffic between the sets, but if it is, then choose rotations during deletion using the leaf-count information on each node in your traversal."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["Update: On request, here's a basic implementation.", "Haven't tuned it at all.", "Usage:"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Update:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; t1 = build_tree([('one', 20), ('two', 2), ('three', 50)])\n&gt;&gt;&gt; t1\nBranch(Leaf(20, 'one'), Branch(Leaf(2, 'two'), Leaf(50, 'three')))\n&gt;&gt;&gt; t1.sample()\nLeaf(50, 'three')\n&gt;&gt;&gt; t1.sample()\nLeaf(20, 'one')\n&gt;&gt;&gt; t2 = build_tree([('four', 10), ('five', 30)])\n&gt;&gt;&gt; t1a, t2a = transfer(t1, t2)\n&gt;&gt;&gt; t1a\nBranch(Leaf(20, 'one'), Leaf(2, 'two'))\n&gt;&gt;&gt; t2a\nBranch(Leaf(10, 'four'), Branch(Leaf(30, 'five'), Leaf(50, 'three')))\n</code>\n</pre>\n", "senID": 7}, {"text": ["Code:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n import random\n\ndef build_tree(pairs):\n    tree = Empty()\n    for value, weight in pairs:\n        tree = tree.add(Leaf(weight, value))\n    return tree\n\ndef transfer(from_tree, to_tree):\n    \"\"\"Given a nonempty tree and a target, move a leaf from the former to\n    the latter. Return the two updated trees.\"\"\"\n    leaf, from_tree1 = from_tree.extract()\n    return from_tree1, to_tree.add(leaf)\n\nclass Tree:\n    def add(self, leaf):\n        \"Return a new tree holding my leaves plus the given leaf.\"\n        abstract\n    def sample(self):\n        \"Pick one of my leaves at random in proportion to its weight.\"\n        return self.sampling(random.uniform(0, self.weight))\n    def extract(self):\n        \"\"\"Pick one of my leaves and return it along with a new tree\n        holding my leaves minus that one leaf.\"\"\"\n        return self.extracting(random.uniform(0, self.weight))        \n\nclass Empty(Tree):\n    weight = 0\n    def __repr__(self):\n        return 'Empty()'\n    def add(self, leaf):\n        return leaf\n    def sampling(self, weight):\n        raise Exception(\"You can't sample an empty tree\")\n    def extracting(self, weight):\n        raise Exception(\"You can't extract from an empty tree\")\n\nclass Leaf(Tree):\n    def __init__(self, weight, value):\n        self.weight = weight\n        self.value = value\n    def __repr__(self):\n        return 'Leaf(%r, %r)' % (self.weight, self.value)\n    def add(self, leaf):\n        return Branch(self, leaf)\n    def sampling(self, weight):\n        return self\n    def extracting(self, weight):\n        return self, Empty()\n\ndef combine(left, right):\n    if isinstance(left, Empty): return right\n    if isinstance(right, Empty): return left\n    return Branch(left, right)\n\nclass Branch(Tree):\n    def __init__(self, left, right):\n        self.weight = left.weight + right.weight\n        self.left = left\n        self.right = right\n    def __repr__(self):\n        return 'Branch(%r, %r)' % (self.left, self.right)\n    def add(self, leaf):\n        # Adding to a random branch as a clumsy way to keep an\n        # approximately balanced tree.\n        if random.random() &lt; 0.5:\n            return combine(self.left.add(leaf), self.right)\n        return combine(self.left, self.right.add(leaf))\n    def sampling(self, weight):\n        if weight &lt; self.left.weight:\n            return self.left.sampling(weight)\n        return self.right.sampling(weight - self.left.weight)\n    def extracting(self, weight):\n        if weight &lt; self.left.weight:\n            leaf, left1 = self.left.extracting(weight)\n            return leaf, combine(left1, self.right)\n        leaf, right1 = self.right.extracting(weight - self.left.weight)\n        return leaf, combine(self.left, right1)\n</code>\n</pre>\n", "senID": 9}, {"text": ["Update 2: In answering another problem, Jason Orendorff points out that the binary trees can be kept perfectly balanced by representing them in an array just like the classical heap structure.", "(This saves the space spent on pointers, too.", ") See my comments to that answer for how to adapt his code to this problem."], "childNum": 2, "tag": "p", "senID": 10, "childList": [{"text": "Update 2:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "answering another problem", "tag": "a", "pos": -1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/2140787/select-random-k-elements-from-a-list-whose-elements-have-weights/2149533#2149533"}]}], [{"text": ["I would use this recipe .", "You will need to add a weight to your objects, but that is just a simple ratio and put them in a list of tuples (object, conviction/(sum of convictions)).", "This should be easy to do using a list comprehension."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "recipe", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/117241/"}]}], [{"text": ["I suggest you port this PHP implementation of weighted random to Python.", "In particular, the binary-search-based second algorithm helps address your speed concerns."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this PHP implementation of weighted random", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://w-shadow.com/blog/2008/12/10/fast-weighted-random-choice-in-php/"}]}], [{"text": ["Here is a version that generates a random index that allows for changing the weights on the fly.", "It chooses a random object and then generates a random number between 0 and 100 then does a test of this value against the weight to determine if to choose the random element or to try again.", "After 100 tries if nothing is found just pick a random index and call it a day.", "The two interesting methods are GetRdnObject which returns a random object and RemoveRndObject which removes and returns a random object.", "There is also an iterator so you can loop over the objects with the most probable coming out first. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Edit: Here is the math behind this method.", "The normal method for weighted items is to generate the sum and then probx=weightx/sumw.", "This has a performance problem because you either have to generate a map that is size sumw each time a weight changes or you have to do a search each time a random number is generated to find the value."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["My method uses a probability tree that would have the exact same probability distribution if you were to make it infinitely large.", "However the terms fall off at a fairly fast rate so I capped my tree at 100 levels and then just pick a item to give it an end condition.", "To accomplish this I needed a standard max weight which I choose to be 100. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Using this the algorithm is the following.", "If there are n items choose one at random ri which gives the standard not weighted probability 1/n that each item will be chosen.", "Then calculate another random in the range 0 to maxw and if r &lt; w[ri] return item ri.", "Else repeat by choosing another random ri and repeating the test.  "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Here is the math.  "], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\nn = number of items \n      sumw = sum(wx)\n      px=wx/100 prob of returning item if given a chance\n      qx = 1-px \n      sqx = sum of all qx\n      Pi is the overall probability that an item will be returned\n      s = sum k=0 to inf (sqx/n)**k\n      It can be shown that\n      Pi = px*s/n == wx/sumw\n\n      Instead of allowing an infinite sum I choose to sum s only over \n      the first 100 tries which makes s with the end condition\n      s= (sum k=0 to 99 of (sqx/n)**k) + ((sqx/n)**100)/n\n\n      The difference between the two is someting in the order of 10**-15.\n      You can reduce the max tries to something like 50 or 25 with not \n      a huge loss in accuracy.\n</pre>\n", "senID": 5}, {"text": ["You can think of it as all of the weights are setting the path length and shorter the path ie larger the weight the more probable that that item will be selected."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n import random\n\nclass RandomObject:\n    \"\"\"\n    The objects are in a list\n    ex [o1,o2,o3,o4]\n    The weight list should contain values between 0 and 100.\n    ex [0.1,1,10,100]\n    it is up to the caller to make sure object list and weight list are same size\n    \"\"\"\n\n    def __init__(self,olist, wlist,n=0,remove=False):\n        self._odata = olist[:]\n        self._wdata = wlist[:]\n        self._len=len(wlist)\n        if n==0:\n            self._n=self._len\n        else:\n            self._n=n\n        self._remove=remove\n\n\n    def __iter__(self):\n        return self.next()\n\n    def next(self):\n        while (self._len &gt; 0) and (self._n&gt;0):\n            self._n -= 1\n            i=self.i()\n            if i &lt; self._len:\n                if self._remove:\n                    self._len -=1\n                    self._wdata.pop(i)\n                    yield self._odata.pop(i)\n                else:\n                    yield self._odata[i]\n\n\n    def GetObject(self,i):\n        if i &lt; self._len:\n            return self._odata[i]\n        else:\n            return None\n\n    def GetWeight(self,i):\n        if i &lt; self._len:\n            return self._wdata[i]\n        else:\n            return 0\n\n    def SetWeight(self,i,w):\n        if i &lt; self._len:\n            self._wdata[i]=w\n\n    def RemoveObject(self,i):\n        if i &lt; self._len:\n            self._len -=1\n            self._wdata.pop(i)\n            return self._odata.pop(i)\n        else:\n            return None\n\n    def Remove(self,i):\n        if (self._len &gt;0 ) and (i &lt; self._len):\n            self._len -=1\n            self._wdata.pop(i)\n\n    def Append(self,o,w):\n        self._len +=1\n        self._wdata.append(w)\n        self._odata.append(o)\n\n    def Insert(self,i,o,w):\n        if i &lt; self._len:\n            self._len +=1\n            self._wdata.insert(i,w)\n            self._odata.insert(i,o)\n        else:\n            self._len +=1\n            self._wdata.append(w)\n            self._odata.append(o)\n\n    def GetRdnObject(self):\n        i=self.i()\n        if (self._len &gt;0 ) and (i &lt; self._len):\n            return [self._odata[i],i]\n        else:\n            return None\n\n    def RemoveRndObject(self):\n        i=self.i()\n        if (self._len &gt;0 ) and (i &lt; self._len):\n            self._len -=1\n            self._wdata.pop(i)\n            return [self._odata.pop(i),i]\n        else:\n            return None\n\n    def i(self):\n        for i in range(100):\n            ri=random.randint(0,self._len-1) #choose a random object\n            rx=random.uniform(0,100)\n            if rx &lt;= self._wdata[ri]: # test to see if that is the value we want\n                return ri\n        # if you do not find one after 100 tries then just get a random one\n        return random.randint(0,self._len-1)             \n\n\n\n#test code\no=[1,2,3,4]\nwx=[0.1,1,10,100] #weight list\nro=RandomObject(o,wx)\n\nl=[]\nfor i in range(100):\n    o=ro.GetRdnObject()\n    l.append(o[0])\n\nprint(\"random list=\",l)\n\n\n#modify the weights\nro.SetWeight(0,100) \nro.SetWeight(1,50)\nro.SetWeight(2,0)\nro.SetWeight(3,0)\n\nl=[]\nfor i in range(100):\n    o=ro.GetRdnObject()\n    l.append(o[0])\n\nprint(\"random list=\",l)\n\narsize=2500\nlpsz=100\nwx=[x*100/arsize for x in range(arsize)] #weight list\no=[x for x in range(arsize)]\n\nro=RandomObject(o,wx)\n\nl=[]\n\nprint(\"loop size=\",lpsz)\nfor j in range(lpsz):\n    o=ro.RemoveRndObject()\n    l.append(o[0])\n\nprint(\"random list=\",l)\n\narsize=100\nwx=[x*100/arsize for x in range(arsize)] #weight list\no=[x for x in range(arsize)]\n\n#iterate over the objects\nl=[]\nfor x in RandomObject(o,wx,50):\n    l.append(x)\n\nprint(\"random list=\",l)\n</code>\n</pre>\n", "senID": 7}], [{"text": ["The simplest thing to do is to use random.choice (which uses a uniform distribution) and vary the frequency of occurrence on the object in the source collection."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; random.choice([1, 2, 3, 4])\n4\n</code>\n</pre>\n", "senID": 1}, {"text": ["... vs:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; random.choice([1, 1, 1, 1, 2, 2, 2, 3, 3, 4])\n2\n</code>\n</pre>\n", "senID": 3}, {"text": ["So your objects could have a base occurrence rate (n) and between 1 and n objects are added to the source collection as a function of the conviction rate.", "This method is really simple; however, it can have significant overhead if the number of distinct objects is large or the conviction rate needs to be very fine grained."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Alternatively, if you generate more that one random number using a uniform distribution and sum them, numbers occurring near the mean are more probable that those occurring near the extremes (think of rolling two dice and the probability of getting 7 versus 12 or 2).", "You can then order the objects by conviction rate and generate a number using multiple die rolls which you use to calculate and index into the objects.", "Use numbers near the mean to index low conviction objects and numbers near the extremes to index high conviction items.", "You can vary the precise probability that a given object will be selected by changing the \"number of sides\" and number of your \"dice\" (it may be simpler to put the objects into buckets and use dice with a small number of sides rather than trying to associate each object with a specific result):"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; die = lambda sides : random.randint(1, sides)\n&gt;&gt;&gt; die(6)\n3\n&gt;&gt;&gt; die(6) + die(6) + die(6)\n10\n</code>\n</pre>\n", "senID": 6}], [{"text": ["You want to give each object a weight.", "The bigger the weight the more likely it will happen.", "More precisely probx =weight/sum_all_weights."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Then generate a random number in the range 0 to sum_all_weights\nand map it to each object."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["This code allows you to generate a random index and it is mapped when the object is created for speed.", "If all of your sets of objects have the same distribution then you can get by with only one RandomIndex object."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import random\n\nclass RandomIndex:\n    def __init__(self, wlist):\n        self._wi=[]\n        self._rsize=sum(wlist)-1\n        self._m={}\n        i=0\n        s=wlist[i]\n        for n in range(self._rsize+1):\n            if n == s:\n                i+=1\n                s+=wlist[i]\n            self._m[n]=i    \n\n    def i(self):\n        rn=random.randint(0,self._rsize)\n        return self._m[rn]\n\n\nsx=[1,2,3,4]\n\n\nwx=[1,10,100,1000] #weight list\nri=RandomIndex(wx)\n\ncnt=[0,0,0,0]\n\nfor i in range(1000):\n    cnt[ri.i()] +=1  #keep track of number of times each index was generated\n\nprint(cnt)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here is a classic way to do it, in pseudocode, where random.random() gives you a random float from 0 to 1."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n let z = sum of all the convictions\nlet choice = random.random() * z \niterate through your objects:\n    choice = choice - the current object's conviction\n    if choice &lt;= 0, return this object\nreturn the last object\n</code>\n</pre>\n", "senID": 1}, {"text": ["For an example: imagine you have two objects, one with weight 2, another with weight 4.", "You generate a number from 0 to 6.", "If choice is between 0 and 2, which will happen with 2/6 = 1/3 probability, then it will get subtracted by 2 and the first object is chosen.", "If choice is between 2 and 6, which will happen with 4/6 = 2/3 probability, then the first subtraction will still have choice being > 0, and the second subtraction will make the 2nd object get chosen."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "choice", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}], [{"text": ["A very easy and simple way of doing this is to set weights for each of the values, and it wouldn't require much memory."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You could probably use a hash/dictionary to do this."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["What you'll want to do is to have the random number, x, multiplied and summed over the entire set of things you want selected, and divide that result over the number of objects in your set."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "x", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Pseudo-code:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n objectSet = [(object1, weight1), ..., (objectN, weightN)]\nsum = 0\nrand = random()\nfor obj, weight in objectSet\n    sum = sum+weight*rand\nchoice = objectSet[floor(sum/objectSet.size())]\n</code>\n</pre>\n", "senID": 4}, {"text": ["EDIT: I just thought of how slow my code would be with very large sets (it's O(n)).", "The following pseudo-code is O(log(n)), and is basically using a binary search."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "EDIT", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n objectSet = [(object1, weight1), ..., (objectN, weightN)]\nsort objectSet from less to greater according to weights\nchoice = random() * N # where N is the number of objects in objectSet\ndo a binary search until you have just one answer\n</code>\n</pre>\n", "senID": 6}, {"text": ["There are implementations of binary search in Python all over the 'net, so no need repeating here."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}], [{"text": ["Here's a better answer for a special probability distribution, the one Rex Logan's answer seems to be geared at.", "The distribution is like this: each object has an integer weight between 0 and 100, and its probability is in proportion to its weight.", "Since that's the currently accepted answer, I guess this is worth thinking about."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Rex Logan's answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/526255/probability-distribution-in-python/526585#526585"}]}, {"text": ["So keep an array of 101 bins.", "Each bin holds a list of all of the objects with its particular weight.", "Each bin also knows the total weight of all its objects."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "total", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"text": ["To sample: pick a bin at random in proportion to its total weight.", "(Use one of the standard recipes for this -- linear or binary search.", ") Then pick an object from the bin uniformly at random."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["To transfer an object: remove it from its bin, put it in its bin in the target, and update both bins' weights.", "(If you're using binary search for sampling, you must also update the running sums that uses.", "This is still reasonably fast since there aren't many bins."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["(A year later)\nWalker's alias method for random objects with different probablities is very fast and very simple"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Walker's alias method for random objects with different probablities", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/576564"}]}], [{"text": ["I was needed in faster functions, for non very large numbers.", "So here it is, in Visual C++:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n #undef _DEBUG // disable linking with python25_d.dll\n#include &lt;Python.h&gt;\n#include &lt;malloc.h&gt;\n#include &lt;stdlib.h&gt;\n\nstatic PyObject* dieroll(PyObject *, PyObject *args)\n{\n    PyObject *list;\n    if (!PyArg_ParseTuple(args, \"O:decompress\", &amp;list))\n        return NULL;\n\n    if (!PyList_Check(list)) \n        return PyErr_Format(PyExc_TypeError, \"list of numbers expected ('%s' given)\", list-&gt;ob_type-&gt;tp_name), NULL;\n\n    int size = PyList_Size(list);\n\n    if (size &lt; 1)\n        return PyErr_Format(PyExc_TypeError, \"got empty list\"), NULL;\n\n    long *array = (long*)alloca(size*sizeof(long));\n\n    long sum = 0;\n    for (int i = 0; i &lt; size; i++) {\n        PyObject *o = PyList_GetItem(list, i);\n\n        if (!PyInt_Check(o))\n            return PyErr_Format(PyExc_TypeError, \"list of ints expected ('%s' found)\", o-&gt;ob_type-&gt;tp_name), NULL;\n        long n = PyInt_AsLong(o);\n        if (n == -1 &amp;&amp; PyErr_Occurred())\n            return NULL;\n        if (n &lt; 0)\n            return PyErr_Format(PyExc_TypeError, \"list of positive ints expected (negative found)\"), NULL;\n\n        sum += n; //NOTE: integer overflow\n        array[i] = sum;\n    }\n\n    if (sum &lt;= 0)\n        return PyErr_Format(PyExc_TypeError, \"sum of numbers is not positive\"), NULL;\n\n    int r = rand() * (sum-1) / RAND_MAX; //NOTE: rand() may be too small (0x7fff).    rand() * sum may result in integer overlow.\n\n    assert(array[size-1] == sum);\n    assert(r &lt; sum &amp;&amp; r &lt; array[size-1]);\n    for (int i = 0; i &lt; size; ++i)\n    {\n        if (r &lt; array[i])\n            return PyInt_FromLong(i);\n    }\n    return PyErr_Format(PyExc_TypeError, \"internal error.\"), NULL;\n}\n\nstatic PyMethodDef module_methods[] = \n{\n    {\"dieroll\", (PyCFunction)dieroll, METH_VARARGS, \"random index, beased on weights\" },\n    {NULL}  /* Sentinel */\n};\n\nPyMODINIT_FUNC initdieroll(void) \n{\n    PyObject *module = Py_InitModule3(\"dieroll\", module_methods, \"dieroll\");\n    if (module == NULL)\n        return;\n}\n</code>\n</pre>\n", "senID": 1}]]