[[{"text": ["Nicer DRY way to solve your actual problem:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def message(msg):\n    print msg\nmessage.re = '^&lt;\\w+&gt; (.*)'\n\ndef warning(msg):\n    global num_warnings, num_fatals\n    num_warnings += 1\n    if ( is_fatal( msg ) ):\n        num_fatals += 1\nwarning.re = '^\\*{3} (.*)'\n\nhandlers = [(re.compile(x.re), x) for x in [\n        message,\n        warning,\n        foo,\n        bar,\n        baz,\n    ]]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is based on Udi's nice answer."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Udi's nice answer", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/6629876/how-to-make-an-anonymous-function-in-python-without-christening-it/6630179#6630179"}]}, {"text": ["I think that the difficulty of creating anonymous functions is a bit of a red herring.", "What you really want to do is to keep related code together, and make the code neat.", "So I think decorators may work for you."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import re\n\n# List of pairs (regexp, handler)\nhandlers = []\n\ndef handler_for(regexp):\n    \"\"\"Declare a function as handler for a regular expression.\"\"\"\n    def gethandler(f):\n        handlers.append((re.compile(regexp), f))\n        return f\n    return gethandler\n\n@handler_for(r'^&lt;\\w+&gt; (.*)')\ndef handle_message(msg):\n    print msg\n\n@handler_for(r'^\\*{3} (.*)')\ndef handle_warning(msg):\n    global num_warnings, num_fatals\n    num_warnings += 1\n    if is_fatal(msg):\n        num_fatals += 1\n</code>\n</pre>\n", "senID": 2}], [{"text": ["If you want to keep a clean namespace, use del:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def myprint(msg):\n    print msg\nf_list = [ myprint ]\ndel myprint\nf_list[0]('hi')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Continuing Gareth's clean approach with a modular self contained solution:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Gareth's", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/6629876/how-to-make-an-anonymous-function-in-python-without-christening-it/6631098#6631098"}]}, {"code": "<pre>\n<code>\n import re\n\n# in util.py\nclass GenericLogProcessor(object):\n\n    def __init__(self):\n      self.handlers = [] # List of pairs (regexp, handler)\n\n    def register(self, regexp):\n        \"\"\"Declare a function as handler for a regular expression.\"\"\"\n        def gethandler(f):\n            self.handlers.append((re.compile(regexp), f))\n            return f\n        return gethandler\n\n    def process(self, file):\n        \"\"\"Process a file line by line and execute all handlers by registered regular expressions\"\"\"\n        for line in file:\n            for regex, handler in self.handlers:\n                m = regex.search(line)\n                if (m):\n                  handler(m.group(1))      \n\n# in log_processor.py\nlog_processor = GenericLogProcessor()\n\n@log_processor.register(r'^&lt;\\w+&gt; (.*)')\ndef handle_message(msg):\n    print msg\n\n@log_processor.register(r'^\\*{3} (.*)')\ndef handle_warning(msg):\n    global num_warnings, num_fatals\n    num_warnings += 1\n    if is_fatal(msg):\n        num_fatals += 1\n\n# in your code\nwith open(\"1.log\") as f:\n  log_processor.process(f)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["As you stated, this can't be done.", "But you can approximate it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def create_printer():\n  def myprint(x):\n    print x\n  return myprint\n\nx = create_printer()\n</code>\n</pre>\n", "senID": 1}, {"text": ["myprint is effectively anonymous here, since the variable scope in which it was created is no longer accessible to the caller.", "(See closures in Python."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "myprint", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "closures in Python", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://ynniv.com/blog/2007/08/closures-in-python.html"}]}], [{"text": ["The only way to make an anonymous function is with lambda, and as you know, they can only contain a single expression."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You can create a number of functions with the same name so at least you don't have to think of new names for each one."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["It would be great to have truly anonymous functions, but Python's syntax can't support them easily."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Personally I'd just name it something use it and not fret about it \"hanging around\".", "The only thing you'll gain by using suggestions such as as redefining it later or using del to drop the name out of the namespace is a potential for confusion or bugs if someone later comes along and moves some code around without groking what you're doing."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "del", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["If you're concerned about polluting the namespace, create your functions inside of another function.", "Then you're only \"polluting\" the local namespace of the create_functions function and not the outer namespace."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "create_functions", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def create_functions():\n    def myprint(msg):\n        print msg\n    return [myprint]\n\nf_list = create_functions()\nf_list[0]('hi')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The only option is to use a lambda expression, like you mention.", "Without that, it is not possible.", "That is the way python works."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["As all said lambda is the only way, but you have to think not about lambda limitations but how to avoid them - for example you can use lists, dicts, comprehensions and so on in order to do what you want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n funcs = [lambda x,y: x+y, lambda x,y: x-y, lambda x,y: x*y, lambda x: x]\nfuncs[0](1,2)\n&gt;&gt;&gt; 3\nfuncs[1](funcs[0](1,2),funcs[0](2,2))\n&gt;&gt;&gt; -1\n[func(x,y) for x,y in zip(xrange(10),xrange(10,20)) for func in funcs]\n</code>\n</pre>\n", "senID": 1}, {"text": ["EDITED with print(try to look at the pprint module) and control-flow:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "pprint module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/pprint.html"}]}, {"code": "<pre>\n<code>\n add = True\n(funcs[0] if add else funcs[1])(1,2)\n&gt;&gt;&gt; 3\n\nfrom pprint import pprint\nprintMsg = lambda isWarning, msg: pprint('WARNING: ' + msg) if isWarning else pprint('MSG:' + msg)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You should not do it cause eval is evil, but you can compile function code on run time using FunctionType and compile:"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "FunctionType", "tag": "a", "pos": 0, "childList": [{"text": "FunctionType", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/types.html#types.FunctionType"}, {"text": "FunctionType", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/functions.html#compile", "text": "compile", "childNum": 1, "tag": "a", "childList": [{"text": "compile", "tag": "code"}]}, {"text": "compile", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def f(msg): print msg\n&gt;&gt;&gt; type(f)\n &lt;type 'function'&gt;\n&gt;&gt;&gt; help(type(f))\n...\nclass function(object)\n |  function(code, globals[, name[, argdefs[, closure]]])\n |\n |  Create a function object from a code object and a dictionary.\n |  The optional name string overrides the name from the code object.\n |  The optional argdefs tuple specifies the default argument values.\n |  The optional closure tuple supplies the bindings for free variables.    \n...\n\n&gt;&gt;&gt; help(compile)\nHelp on built-in function compile in module __builtin__:\n\ncompile(...)\n    compile(source, filename, mode[, flags[, dont_inherit]]) -&gt; code object\n\n    Compile the source string (a Python module, statement or expression)\n    into a code object that can be executed by the exec statement or eval().\n    The filename will be used for run-time error messages.\n    The mode must be 'exec' to compile a module, 'single' to compile a\n    single (interactive) statement, or 'eval' to compile an expression.\n    The flags argument, if present, controls which future statements influence\n    the compilation of the code.\n    The dont_inherit argument, if non-zero, stops the compilation inheriting\n    the effects of any future statements in effect in the code calling\n    compile; if absent or zero these statements do influence the compilation,\n    in addition to any features explicitly specified.\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could use exec:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "exec", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def define(arglist, body):\n    g = {}\n    exec(\"def anonfunc({0}):\\n{1}\".format(arglist,\n                                     \"\\n\".join(\"    {0}\".format(line)\n                                               for line in body.splitlines())), g)\n    return g[\"anonfunc\"]\n\nf_list = [define(\"msg\", \"print(msg)\")]\nf_list[0]('hi')\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Python really, really doesn't want to do this.", "Not only does it not have any way to define a multi-line anonymous function, but function definitions don't return the function, so even if this were syntactically valid..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n mylist.sort(key=def _(v):\n                    try:\n                        return -v\n                    except:\n                        return None)\n</code>\n</pre>\n", "senID": 1}, {"text": ["... it still wouldn't work.", "(Although I guess if it were syntactically valid, they'd make function definitions return the function, so it would work."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "would", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["So you can write your own function to make a function from a string (using exec of course) and pass in a triply-quoted string.", "It's kinda ugly syntactically, but it works:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "exec", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def function(text, cache={}):\n\n    # strip everything before the first paren in case it's \"def foo(...):\"\n    if not text.startswith(\"(\"):\n        text = text[text.index(\"(\"):]\n\n    # keep a cache so we don't recompile the same func twice\n    if text in cache:\n        return cache[text]\n\n    exec \"def func\" + text\n    func.__name__ = \"&lt;anonymous&gt;\"\n\n    cache[text] = func\n    return func\n\n    # never executed; forces func to be local (a tiny bit more speed)\n    func = None\n</code>\n</pre>\n", "senID": 4}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n mylist.sort(key=function(\"\"\"(v):\n                                try:\n                                    return -v\n                                except:\n                                    return None\"\"\"))\n</code>\n</pre>\n", "senID": 6}], [{"text": ["If your function is complicated enough to not fit in a lambda function, then, for readability's sake, it would probably be best to define it in a normal block anyway."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "lambda", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}]]