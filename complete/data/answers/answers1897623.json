[[{"text": ["This is similar to your decorator idea, but it is a bit more general, as it allows you to pass an arbitrary number of dicts to foo, and the decorator does not have to know anything about the keys in the dicts or the order of the arguments when calling the underlying foo function."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "foo", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n #!/usr/bin/env python\nd1 = {'x':1,'y':2}\nd2 = {'a':3,'b':4}\n\ndef unpack_dicts(f):\n    def f_new(*dicts):\n        new_dict={}\n        for d in dicts:\n            new_dict.update(d)\n        return f(**new_dict)\n    return f_new\n\n@unpack_dicts\ndef foo(x,y,a,b):\n    print x,y,a,b\n\nfoo(d1,d2)\n# 1 2 3 4\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you like d.variable syntax better than d['variable'], you can wrap the dictionary in an almost trivial \"bunch\" object such as this:"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "d.variable", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "d['variable']", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://code.activestate.com/recipes/52308/", "text": "an almost trivial \"bunch\" object", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n class Bunch:\n    def __init__(self, **kw):\n        self.__dict__.update(kw)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It doesn't exactly bring dictionary contents into the local namespace, but comes close if you use short names for the objects. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I do not think you can get any more convenience for dict unpacking in Python.", "So, here comes the obligatory \"if that hurts, don't do that\" answer."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Mapping item access IS more cumbersome than attribute access in Python, so maybe you should pass instances of user-defined classes instead of dicts."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I think the common wisdom is \"don't use the inspect module in production code\", and I mostly agree with that.", "As such, I think it is a bad idea to do the following in production code.", "But, if you're working on a python that supports frames (like CPython), this should work:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "inspect", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "should", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def framelocals():\n...    return inspect.currentframe(1).f_locals\n... \n&gt;&gt;&gt; def foo(ns):\n...    framelocals().update(ns)\n...    print locals()\n... \n&gt;&gt;&gt; foo({'bar': 17})\n{'ns': {'bar': 17}, 'bar': 17}\n</code>\n</pre>\n", "senID": 1}, {"text": ["It just grabs the actual dict out of the caller's frame, which when called inside a function body, should be the function's name space.", "I don't know if there is or isn't a situation when using CPython when locals() doesn't just do this anyway; the warning in the documentation might be to say \"the effects of modifying the dict returned by locals() are python implementation dependent\".", "Thus, while it works to modify that dict in CPython, it may not in another implementation.  "], "childNum": 5, "tag": "p", "senID": 2, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "locals()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "locals()", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["UPDATE: This method doesn't actually work. "], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "UPDATE:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def flup(ns):\n...    framelocals().update(ns)\n...    print locals()\n...    print bar\n... \n&gt;&gt;&gt; flup({'bar': 17})\n{'ns': {'bar': 17}, 'bar': 17}\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 4, in flup\nNameError: global name 'bar' is not defined\n</code>\n</pre>\n", "senID": 4}, {"text": ["As ddaa suggested, there's some deeper magic in the function compilation which makes note of the local variables.", "Thus you can update the dict, but you can't see the update with normal local namespace lookup."], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "ddaa", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/11549/ddaa"}, {"text": "dict", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["You can always pass a dictionary as an argument to a function.", "For instance, "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dict = {'a':1, 'b':2}\ndef myFunc( a=0,b=0,c=0 ):\n  print a,b,c\nmyFunc(**dict)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Assuming all keys in your dictionary qualify to be identifiers,\nYou can simply do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n adict = { 'x' : 'I am x', 'y' : ' I am y' }\nfor key in  adict.keys():\n  exec(key + \" = adict['\" + key + \"']\")\nblah(x)\nblah(y)\n</code>\n</pre>\n", "senID": 1}]]