[[{"text": ["A dictionary would be a std::map in c++, and a tuple with two elements would be a std::pair."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The python code provided would translate to:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n #include &lt;iostream&gt;\n#include &lt;map&gt;\n\ntypedef std::map&lt;std::pair&lt;int, int&gt;, int&gt; Dict;\ntypedef Dict::const_iterator It;\n\nint main()\n{\n   Dict d;\n\n   d[std::make_pair(0, 0)] = 0;\n   d[std::make_pair(1, 2)] = 1;\n   d[std::make_pair(2, 1)] = 2;\n   d[std::make_pair(2, 3)] = 3;\n   d[std::make_pair(3, 2)] = 4;\n\n   for (It it(d.begin()); it != d.end(); ++it)\n   {\n      int i(it-&gt;first.first);\n      int j(it-&gt;first.second);\n      std::cout &lt;&lt;it-&gt;second &lt;&lt;' '\n                &lt;&lt;d[std::make_pair(j, i)] &lt;&lt;'\\n';\n   }\n}\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The type is"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n std::map&lt; std::pair&lt;int,int&gt;, int&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["The code to add entries to map is like here:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n typedef  std::map&lt; std::pair&lt;int,int&gt;, int&gt; container;\n\ncontainer m;\n\nm[ make_pair(1,2) ] = 3; //...\n\nfor(container::iterator i = m.begin();  i != m.end(); ++i){\n   std::cout &lt;&lt; i.second &lt;&lt; ' '; \n   // not really sure how to translate [i,j] [j,i] idiom here easily\n}\n</code>\n</pre>\n", "senID": 3}], [{"text": ["std::map or more likely std::tr1::unordered_map / boost::unordered_map (aka hash_map) is what you want. "], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "std::map", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "std::tr1::unordered_map", "childNum": 0, "tag": "code", "childList": []}, {"text": "boost::unordered_map", "childNum": 0, "tag": "code", "childList": []}, {"text": "hash_map", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Also, as kriss said, Boost.Python is a good idea to look at here.", "It provides a C++ version of python's dict class already, so if you're doing cross-language stuff, it might be useful."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Have a look at Boost.python.", "It's for interaction between python and C++ (basically building python libs using C++, but also for embedding python in C++ programs).", "Most pythons data structures and their C++ equivalents are described (didn't checked for the one you want)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Boost.python", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.boost.org/doc/libs/1%5F41%5F0/libs/python/doc/index.html"}]}], [{"text": ["Do you want to call an optimized C++ routine via Python?", "If so, read on:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Often times I use PyYaml when dealing with dictionaries in Python.", "Perhaps you could link in something like LibYAML or yamlcpp to:"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "PyYaml", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pyyaml.org/"}, {"text": "LibYAML", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://pyyaml.org/wiki/LibYAML"}, {"href": "http://www.x37v.info/projects/cpp/yaml/", "text": "yamlcpp", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Warning:  I have never tried this, but using everyone's favorite search engine on \"yaml std::map\" yields lots of interesting links"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "\"yaml std::map\"", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.google.com/search?q=yaml+std"}]}], [{"text": ["As a direct answer to your question (for the python part look at my other answer).", "You can forget the tuple part if you want.", "You can use any mapping type key/value (hash, etc.", ") in C++, you just have to find a unique key function.", "In some cases that can be easy.", "For instance if you two integers are integers between 1 and 65536 you just could use a 32 bits integer with each 16 bits part one of the keys.", "A simple shift and an 'or' or + to combine the two values would do the trick and it's very efficient."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]