[[{"text": ["Since quickCheck is being called close to 25,000,000 times, you might want to use memoization to cache the answers."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "quickCheck", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You can do memoization in C as well as Python.", "Things will be much faster in C, also."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You're computing 1/6 in each iteration of quickCheck.", "I'm not sure if this will be optimized out by Python, but if you can avoid recomputing constant values, you'll find things are faster.", "C compilers do this for you."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "1/6", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Doing things like if condition: return True; else: return False is silly -- and time consuming.", "Simply do return condition."], "childNum": 2, "tag": "p", "senID": 3, "childList": [{"text": "if condition: return True; else: return False", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "return condition", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["In Python 3.x, /2 must create floating-point values.", "You appear to need integers for this.", "You should be using //2 division.", "It will be closer to the C version in terms of what it does, but I don't think it's significantly faster. "], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "/2", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "//2", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["Finally, Python is generally interpreted.", "The interpreter will always be significantly slower than C."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["I made it go from ~7 seconds to ~3 seconds on my machine:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 4, "lis": [{"text": "Precomputed ", "tag": "none", "senID": 1}, {"text": "Cached calls to quickCheck", "tag": "none", "senID": 2}, {"text": "Removed ", "tag": "none", "senID": 3}, {"text": "Removed ", "tag": "none", "senID": 4}]}, {"text": ["Also put the quickCheck-function inside main, to make all variables local (which have faster lookup than global).", "I'm sure there are more micro-optimizations available."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n def main():\n        maxNumber = 5000\n        diff = 1000\n\n        p = {}\n        quickCache = {}\n\n        for i in range(maxNumber):\n            p[i] = i * (3 * i - 1 ) / 2\n\n        def quickCheck(n):\n            if n in quickCache: return quickCache[n]\n            partial_c = (sqrt(1 + 24 * (n)))/-6 \n            c = 1/6 + partial_c\n            if int(c.real) == c.real:\n                    quickCache[n] = True\n                    return True\n            c = c - 2*partial_c\n            if int(c.real) == c.real:\n                    quickCache[n] = True\n                    return True\n            quickCache[n] = False\n            return False\n\n        for i in range(1, maxNumber):\n                mi = p[i]\n                for g in range(i+1, maxNumber):\n                        ma = p[g]\n                        if ma - mi &lt; diff and quickCheck(ma - mi) and quickCheck(ma + mi):\n                                print('New couple ', ma, mi)\n                                diff = ma - mi\n</code>\n</pre>\n", "senID": 6}], [{"text": ["There are some python compilers that might actually do a good bit for you.", "Have a look at Psyco."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Psyco", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://psyco.sourceforge.net/doc.html"}]}, {"text": ["Another way of dealing with math intensive programs is to rewrite the majority of the work into a math kernel, such as NumPy, so that heavily optimized code is doing the work, and your python code only guides the calculation.", "To get the most out of this strategy, avoid doing calculations in loops, and instead let the math kernel do all of that."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "NumPy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://numpy.scipy.org/"}]}], [{"text": ["The other respondents have already mentioned several optimizations that will help.", "However, ultimately, you're not going to be able to match the performance of C in Python.", "Python is a nice tool, but since it's interpreted, it isn't really suited for heavy number crunching or other apps where performance is key."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Also, even in your C version, your inner loop could use quite a bit of help.", "Updated version:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n for(i = 1; i &lt; maxNumber; i++){\n    for(g = 1; g &lt; maxNumber; g++){\n      if(i == g)\n        continue;\n      max=i;\n      min=g;\n\n      if (max&lt;min) { \n          // xor swap - could use swap(p_max,p_min) instead. \n          max=max^min;\n          min=max^min;\n          max=max^min;\n      }\n\n      p_max=P(max);\n      p_min=P(min);\n      p_i=P(i);\n      p_g=P(g);\n\n      if(p_max - p_min &lt; diff &amp;&amp;  fullCheck(p_max-p_min) &amp;&amp; fullCheck(p_i + p_g)){\n          diff = p_max - p_min;\n          printf(\"We have a couple %llu %llu with diff %llu\\n\", p_i, p_g, diff);\n      }\n    }\n  }\n\n\n///////////////////////////\nfloat fullCheck(int number){\n  float den=sqrt(1+24*number)/6.0;\n  float check = 1/6.0 - den;\n  float check2 = 1/6.0 + den;\n\n\n  if(check == (int)check)\n    return check;\n  if(check2 == (int)check2)\n    return check2;\n\n  return 0.0;\n}\n</code>\n</pre>\n", "senID": 2}, {"text": ["Division, function calls, etc are costly.", "Also, calculating them once and storing in vars such as I've done can make things a lot more readable. "], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["You might consider declaring P() as inline or rewrite as a preprocessor macro.", "Depending on how good your optimizer is, you might want to perform some of the arithmetic yourself and simplify its implementation."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "inline", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Your implementation of fullCheck() would return what appear to be invalid results, since 1/6==0, where 1/6.0 would return 0.166... as you would expect."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["This is a very brief take on what you can do to your C code to improve performance.", "This will, no doubt, widen the gap between C and Python performance."], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "very", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Because the function p() monotonically increasing you can avoid comparing the values as g > i implies p(g) > p(i).", "Also, the inner loop can be broken early because p(g) - p(i) >= diff implies p(g+1) - p(i) >= diff."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "g > i", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "p(g) > p(i)", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "p(g) - p(i) >= diff", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "p(g+1) - p(i) >= diff", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["Also for correctness, I changed the equality comparison in quickCheck to compare difference against an epsilon because exact comparison with floating point is pretty fragile."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["On my machine this reduced the runtime to 7.8ms using Python 2.6.", "Using PyPy with JIT reduced this to 0.77ms."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This shows that before turning to micro-optimization it pays to look for algorithmic optimizations.", "Micro-optimizations make spotting algorithmic changes much harder for relatively tiny gains."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n EPS = 0.00000001\ndef quickCheck(n):\n    partial_c = sqrt(1 + 24*n) / -6\n    c = 1/6 + partial_c\n    if abs(int(c) - c) &lt; EPS:\n        return True\n    c = 1/6 - partial_c\n    if abs(int(c) - c) &lt; EPS:\n        return True\n    return False\n\ndef p(i):\n    return i * (3 * i - 1 ) / 2\n\ndef main(maxNumber):\n    diff = 1000\n\n    for i in range(1, maxNumber):\n        for g in range(i+1, maxNumber):\n            if p(g) - p(i) &gt;= diff:\n                break \n            if quickCheck(p(g) - p(i)) and quickCheck(p(g) + p(i)):\n                print('New couple ', p(g), p(i), p(g) - p(i))\n                diff = p(g) - p(i)\n</code>\n</pre>\n", "senID": 4}], [{"text": ["20x difference between Python and C for a number crunching task seems quite good to me."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Check the usual performance differences for some CPU intensive tasks (keep in mind that the scale is logarithmic)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "performance differences", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=python&lang2=gcc"}]}, {"text": ["But look on the bright side, what's 1 minute of CPU time compared with the brain and typing time you saved writing Python instead of C?", ":-)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]