[[{"text": ["This will give you the names:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n L1=['cat', 'dog', 'fish', 'rabbit', 'horse', 'bird', 'frog', 'mouse']\n\nfrom itertools import combinations\n\nfor combo in combinations(L1, 2):\n    print '_'.join(combo)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n cat_dog\ncat_fish\ncat_rabbit\ncat_horse\ncat_bird\ncat_frog\ncat_mouse\ndog_fish\ndog_rabbit\ndog_horse\ndog_bird\ndog_frog\ndog_mouse\nfish_rabbit\nfish_horse\nfish_bird\nfish_frog\nfish_mouse\nrabbit_horse\nrabbit_bird\nrabbit_frog\nrabbit_mouse\nhorse_bird\nhorse_frog\nhorse_mouse\nbird_frog\nbird_mouse\nfrog_mouse\n</code>\n</pre>\n", "senID": 3}], [{"text": ["How about itertools.combinations?"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools.combinations", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.combinations"}]}, {"text": ["Usage example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; list(itertools.combinations([1, 2, 3, 4, 5, 6], 2))\n[(1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (2, 3), (2, 4), (2, 5), (2, 6), (3, 4),\n(3, 5), (3, 6), (4, 5), (4, 6), (5, 6)]\n</code>\n</pre>\n", "senID": 2}, {"text": ["First argument is an iterable, second is r, length of subsequences returned."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "r", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["You can then concatenate the results with ease using map or a comprehension:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n map(lambda x: x[0] + \"_\" + x[1], itertools.combinations([\"cat\", \"dog\", \"fish\"], 2)))\n</code>\n</pre>\n", "senID": 5}, {"text": ["x in the lambda is a r-sized tuple. "], "childNum": 2, "tag": "p", "senID": 6, "childList": [{"text": "x", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "r", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Result of the above would be:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n ['cat_dog', 'cat_fish', 'dog_fish']\n</code>\n</pre>\n", "senID": 8}], [{"text": ["There's itertools that can perform combinations and permutations (you'd want the former).", "As far as I can tell, you can't really specify the output format, so you'd get \"catdog\" as output, but the doc page gives you an idea of how the combinations function works, so you can adapt it to build what you need."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#itertools.combinations"}]}], [{"text": ["you can also do it as a generator:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n L1=['cat', 'dog', 'fish', 'rabbit', 'horse', 'bird', 'frog', 'mouse']\ntuples = [(x,y) for x in L1 for y in L1 if x != y]\nfor entry in tuples:\n    if (entry[1], entry[0]) in tuples:\n        tuples.remove((entry[1],entry[0]))\nfor pair in tuples:\n    input1= open('file_%s'%(pair[0]), 'r')\n    file1= pickle.load(input1)\n    input2= open('file_%s'%(pair[1]), 'r')\n    file2= pickle.load(input2)\n</code>\n</pre>\n", "senID": 1}, {"text": ["After the first loop, the contents of tuples is:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "tuples", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n ('cat', 'dog')\n('cat', 'fish')\n('cat', 'rabbit')\n('cat', 'horse')\n('cat', 'bird')\n('cat', 'frog')\n('cat', 'mouse')\n('dog', 'fish')\n('dog', 'rabbit')\n('dog', 'horse')\n('dog', 'bird')\n('dog', 'frog')\n('dog', 'mouse')\n('fish', 'rabbit')\n('fish', 'horse')\n('fish', 'bird')\n('fish', 'frog')\n('fish', 'mouse')\n('rabbit', 'horse')\n('rabbit', 'bird')\n('rabbit', 'frog')\n('rabbit', 'mouse')\n('horse', 'bird')\n('horse', 'frog')\n('horse', 'mouse')\n('bird', 'frog')\n('bird', 'mouse')\n('frog', 'mouse')\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n import itertools\nimport cPickle\n\ndef unique_pairs(lst):\n    return itertools.combinations(lst, 2)\n\nFNAME = \"file_{0}\".format\ndef load_pickle(fname):\n    with open(fname) as inf:\n        return cPickle.load(inf)\n\ndef naive_method(lst):\n    # load each file every time it is requested\n    for x,y in unique_pairs(lst):\n        input1 = load_pickle(FNAME(x))\n        input2 = load_pickle(FNAME(y))\n        # do something with input1 and input2\n\ndef better_method(lst):\n    # if you have enough memory for it!\n    dat = [load_pickle(FNAME(i)) for i in lst]\n    for x,y in unique_pairs(range(len(lst))):\n        input1 = dat[x]\n        input2 = dat[y]\n        # do something with input1 and input2\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Or everyone could give you the answer anyways."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you're more interested in the actual logic as opposed to a built in function that does it for you (which if it's homework, is probably what your teacher is looking for)..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n L1=['cat', 'dog', 'snake', 'hippo']\n    for i in range(len(L1)):\n        n=i+1\n        while n &lt; len(L1):\n            print L1[i] + '_' + L1[n]\n            n+=1\n</code>\n</pre>\n", "senID": 2}]]