[[{"text": ["I would say, \"use xrange() instead\", but you are actually using the list of ints as the sieve result.....", "So an integer generator is not a correct solution."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "xrange()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I think it will be difficult to materialize a list with 39312312323123123 elements in it, no matter what function you use to do so.... That is, after all, 279 petabytes of 64-bit integers."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Try this."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n class FoundComposite(Exception): pass\n\nprimes = [2]\n\nseq = itertools.takewhile(        # Take integers from a list\n          lambda x: x&lt;MAXNUM,     #   until we reach MAXNUM\n          itertools.count(2)      #   the list of integers starting from 2\n          )\n\n#seq = xrange(2, MAXNUM)          # alternatively\n\nfor i in seq:\n    try:\n        for divisor in primes:\n            if not (i % divisor):\n                # no remainder - thus an even divisor\n                # continue to next i in seq\n                raise FoundComposite \n        # if this is reached, we have tried all divisors.\n        primes.append(i)\n    except FoundComposite:\n        pass\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Your algorithm is broken.", "Get it to work for maxnum=100 first."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Once you get it working you will find maxnum=100000000 will takes a long long time to run."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Plot the time it takes to run for maxnum in (10,100,1000,10000,100000,1000000...) you may be able to extrapolate how long 39312312323123123 will take :)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It's a more complex algorithm, perhaps technically not counting as the sieve, but one approach is to not remove all multiples of a given prime at once, but queue the next multiple (along with the prime).", "This could be used in a generator implementation.", "The queue will still end up containing a lot of (multiples of) primes, but not as many as by building then filtering a list."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["First few steps done manually, to show the principle..."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "2 is prime - yield and queue (4, 2)", "tag": "none", "senID": 2}, {"text": "3 is prime - yield and queue (6, 3)", "tag": "none", "senID": 3}, {"text": "4 is composite - replace (4, 2) with (6, 2) in the queue", "tag": "none", "senID": 4}, {"text": "5 is prime - yield and queue (10, 5)", "tag": "none", "senID": 5}, {"text": "6 is composite - replace (6, 2) with (8, 2) and (6, 3) with (9, 3)", "tag": "none", "senID": 6}]}, {"text": ["Note - the queue isn't a FIFO.", "You will always be extracting the tuples with the lowest first item, but new/replacement tuples don't (usually) have the highest first item and (as with 6 above) there will be duplicates."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["To handle the queue efficiently in Python, I suggest a dictionary (ie hashtable) keyed by the first item of the tuple.", "The data is a set of second item values (original primes)."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["As suggested elsewhere, test with small targets before trying for the big one.", "And don't be too surprised if you fail.", "It may still be that you need too many heap-allocated large integers at one time (in the queue) to complete the solution."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["There is a third party module for python called gmpy"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "gmpy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["It has a couple of functions that may be useful to you as they are very fast.", "The probabilistic stuff kicks in around the 4 billion mark."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n next_prime(...)\n    next_prime(x): returns the smallest prime number &gt; x.  Note that\n    GMP may use a probabilistic definition of 'prime', and also that\n    if x&lt;0 GMP considers x 'prime' iff -x is prime; gmpy reflects these\n    GMP design choices. x must be an mpz, or else gets coerced to one.\n\nis_prime(...)\n    is_prime(x,n=25): returns 2 if x is _certainly_ prime, 1 if x is\n    _probably_ prime (probability &gt; 1 - 1/2**n), 0 if x is composite.\n    If x&lt;0, GMP considers x 'prime' iff -x is prime; gmpy reflects this\n    GMP design choice. x must be an mpz, or else gets coerced to one.\n</code>\n</pre>\n", "senID": 2}], [{"text": ["range() returns a list containing all the numbers in the requested range, while xrange is a generator and yields the numbers one after another with a memory consumption close to zero. "], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "range()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "xrange", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["About the memory limit, how about creating a custom list (class) that internally is a linked list of lists or arrays.", "Magically traverse from one to the other internally, and add more as needed, as the caller uses your custom list with the external interface you've provided which will be similar to those members needed to facilitate the .append .remove, etc needs of the arrays used in your problem."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Note: I'm not a Python programmer.", "Not a clue how to implement what I said in Python.", "Maybe I don't know the context here, so I will understand if I'm voted down."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Note", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Maybe use \"generators\" as they're called in python to yield results of your internal lists as if it were one huge single list.", "Possibly with linked list."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "generators", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.ibm.com/developerworks/library/l-pycon.html"}, {"text": "linked list", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/280243/python-linked-list"}]}], [{"text": ["Try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def getPrimes(maxnum):\n    primes = []\n    for i in xrange(2, maxnum):\n        is_mul = False\n        for j in primes:         # Try dividing by all previous primes\n            if i % j == 0:\n                is_mul = True    # Once we find a prime that i is divisible by\n                break            # short circuit so we don't have to try all of them\n        if not is_mul:           # if we try every prime we've seen so far and `i`\n            primes.append(i)     # isn't a multiple, so it must be prime\n    return primes\n</code>\n</pre>\n", "senID": 1}, {"text": ["You shouldn't run out of memory until you get to a very large number of primes.", "This way you don't have to worry about creating a list of multiples.", "Not sure if this still counts as the sieve though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Actually, this won't work for maxnum = 39312312323123123.", "Using the Prime number theorem we can estimate that there will be approximately 1,028,840,332,567,181 prime numbers in that range."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "maxnum = 39312312323123123", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Prime number theorem", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Prime_number_theorem"}, {"text": "1,028,840,332,567,181", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["As pointed out in this question the maximum size of a python list on a 32-bit system is 536,870,912.", "So even if you don't run out of memory, you still won't be able to finish the calculation."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "this question", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/855191/how-big-can-a-python-array-get"}, {"text": "536,870,912", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["You shouldn't have that problem with a 64-bit system though."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["2 ** 64 =&gt; 18446744073709551616"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "2 ** 64 =&gt; 18446744073709551616", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Using the math from the aforementioned question (2 ** 64) / 8, the maximum number of elements in a list would be 2,305,843,009,213,693,951 which is greater than the estimated number of primes you will encounter."], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "(2 ** 64) / 8", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "2,305,843,009,213,693,951", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["To avoid memory issues, you could store your list of primes in a file on the hard disk.", "Store one prime per line and read the file every time you check a new number."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"text": ["Maybe something like this:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n primes_path = r'C:\\temp\\primes.txt'\n\ndef genPrimes():\n    for line in open(primes_path, 'r'):\n        yield int(line.strip())    \n\ndef addPrime(prime):\n    primes_file = open(primes_path, 'a')\n    primes_file.write('%s\\n' % prime)\n    primes_file.close()\n\ndef findPrimes(maxnum):\n    for i in xrange(2, maxnum):\n        is_mul = False\n        for prime in genPrimes():  # generate the primes from a file on disk\n            if i % prime == 0:\n                is_mul = True    \n                break            \n        if not is_mul:           \n            addPrime(i)  # append the new prime to the end of your primes file\n</code>\n</pre>\n", "senID": 11}, {"text": ["At the end, you would have a file on your hard drive that contained all your primes."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"text": ["Ok, so this would be pretty slow, but you wouldn't run out of memory.", "You could make it faster by increasing the speed at which you can read/write files (like RAID)."], "childNum": 1, "tag": "p", "senID": 13, "childList": [{"text": "RAID", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/RAID"}]}]]