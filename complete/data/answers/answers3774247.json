[[{"text": ["Hmm... a counterpoint."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n (`ap` tail) . zipWith\n</code>\n</pre>\n", "senID": 1}, {"text": ["doesn't deserve a name."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["BTW, quicksilver says:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n zip`ap`tail\n</code>\n</pre>\n", "senID": 4}, {"text": ["The Aztec god of consecutive numbers"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Since it's similar to \"fold\" but doesn't collapse the list into a single value, how about \"crease\"?", "If you keep \"creasing\", you end up \"folding\" (sort of). "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["We could go with a cooking metaphor and call it \"pinch\", like pinching the crust of a pie, though this might suggest a circular zipping, where the last element of the list is paired with the first."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n def pinch(f, l):\n    return map(lambda t: f(*t), zip(l, l[1:]+l[:1]))\n</code>\n</pre>\n", "senID": 2}, {"text": ["(If you only like one of \"crease\" or \"pinch\", please note so as a comment.", "Should these be separate suggestions?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Here's another implementation for Python which works if l is a generator too"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "l", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import itertools as it\n\ndef apply_pairwise(f, l):\n    left, right = it.tee(l)\n    next(right)\n    return it.starmap(f, it.izip(left, right))\n</code>\n</pre>\n", "senID": 1}, {"text": ["I think apply_pairwise is a better name"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "apply_pairwise", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["In Python the meld equivalent is in the itertools receipes and called pairwise."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "meld", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from itertools import starmap, izp, tee\n\ndef pairwise(iterable):\n    \"s -&gt; (s0,s1), (s1,s2), (s2, s3), ...\"\n    a, b = tee(iterable)\n    next(b, None)\n    return izip(a, b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["So I would call it:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n def pairwith(func, seq):\n    return starmap(func, pairwise(seq))\n</code>\n</pre>\n", "senID": 3}, {"text": ["I think this makes sense because when you call it with the identity function, it simply returns pairs."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I really can't see any codified names for this anywhere in Python, that's for sure.", "\"Merge\" is good but spoken for in a variety of other contexts.", "\"Plow\" tends to be unused and supplies a great visual of pushing steadily through a line of soil.", "Maybe I've just spent too much time gardening."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I also expanded the principle to allow functions that receive any number of parameters.  "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You might also consider: Pleat.", "It describes well the way you're taking a list (like a long strand of fabric) and bunching segments of it together.  "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import operator\n\ndef stagger(l, w):\n    if len(l)&gt;=w:\n        return [tuple(l[0:w])]+stagger(l[1:], w)\n    return []\n\ndef pleat(f, l, w=2):\n    return map(lambda p: f(*p), stagger(l, w))\n\nprint pleat(operator.add, range(10))\nprint pleat(lambda x, y, z: x*y/z, range(3, 13), 3)\nprint pleat(lambda x: \"~%s~\"%(x), range(10), 1)\nprint pleat(lambda a, b, x, y: a+b==x+y, [3, 2, 4, 1, 5, 0, 9, 9, 0], 4)\n</code>\n</pre>\n", "senID": 3}], [{"text": ["zipWithTail or adjacentPairs."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "zipWithTail", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "adjacentPairs", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I vote for smearWith or smudgeWith because it's like you are smearing/smudging the operation across the list."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "smearWith", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "smudgeWith", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["this seems like ruby's each_cons"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "each_cons", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n ruby-1.9.2-p0 &gt; (1..10).each_cons(2).to_a\n\n=&gt; [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9], [9, 10]]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This reminds me of convolution from image processing.", "But not sure if this is mathematically correct."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "convolution", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["The generalized variant of the plain zip version of this is what I would think of as window.", "Not at a ghci terminal right now, but I think window n = take n .", "tails.", "Then your function is zipWith (\\[x,yj -&gt; f x y) .", "window 2.", "This sort of style naturally works better when f is of type [a] -&gt; b."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "window", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "window n = take n . tails", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "zipWith (\\[x,yj -&gt; f x y) . window 2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "[a] -&gt; b", "childNum": 0, "tag": "code", "pos": 5, "childList": []}]}], [{"text": ["in C++ Standard Template Library, it is called adjacent_difference (though the operator can be any operation, not just subtraction)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "adjacent_difference", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sgi.com/tech/stl/adjacent_difference.html"}]}], [{"text": ["So because there seems to be no name for this I suggest 'merger' or simple 'merge' because you are merging adjacent values together."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "So because there seems to be no name for this I suggest 'merger' or simple 'merge' because you are merging adjacent values together.", "childNum": 0, "tag": "strike", "pos": 0, "childList": []}]}, {"text": ["So merge is already taken so I now suggest 'meld' (or 'merger' still but that may be too close to 'merge')"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n meld :: (a -&gt; a -&gt; b) -&gt; [a] -&gt; [b]\nmeld _ [] = []\nmeld f xs = zipWith f (init xs) (tail xs)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Which can be used as:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt; meld (+) [1..10]\n[3,5,7,9,11,13,15,17,19]\n&gt; meld compare \"hello world\"\n[GT,LT,EQ,LT,GT,LT,GT,LT,GT,GT]\n</code>\n</pre>\n", "senID": 5}, {"text": ["Where the second example makes no real sense but makes a cool example."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["Using Mathematica"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Plus @@@ Partition[{0, 1, 2, 3}, 2, 1]\nor either of these more verbose alternatives"], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "Plus", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://reference.wolfram.com/mathematica/ref/Plus.html?q=Plus&lang=en"}, {"href": "http://reference.wolfram.com/mathematica/ref/Apply.html#1519920741", "text": "@@@", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://reference.wolfram.com/mathematica/ref/Partition.html?q=Partition&lang=en", "text": "Partition", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n Apply[Plus, Partition[{0, 1, 2, 3}, 2, 1], {1}]\nMap[Apply[Plus, #] &amp;, Partition[{0, 1, 2, 3}, 2, 1]]\n</code>\n</pre>\n", "senID": 2}, {"text": ["I have used and enjoyed this higher order function in many languages but I have enjoyed it the most in Mathematica; it seems succinct and flexible broken down into Partition and Apply with levelspec option."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["I'd be tempted to call it contour as I've used it for \"contour\" processing in music software - at the time I called it twomap or something silly like that."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "contour", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["There are also two specific named 'contours' in music processing one is gross contour - does the pitch go up or down.", "The other is refined contour where the the contour is either up, down, leap up or leap down, though I can't seem to find a reference for how large the semitone difference has to be to make a leap. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Nice idiom!", "I just needed to use this in Perl to determine the time between sequential events.", "Here's what I ended up with."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sub pinch(&amp;@) {\n  my ( $f, @list ) = @_;\n  no strict \"refs\";\n\n  use vars qw( $a $b );\n\n  my $caller = caller;\n  local( *{$caller . \"::a\"} ) = \\my $a;\n  local( *{$caller . \"::b\"} ) = \\my $b;\n\n  my @res;\n  for ( my $i = 0; $i &lt; @list - 1; ++$i ) {\n    $a = $list[$i];\n    $b = $list[$i + 1];\n    push( @res, $f-&gt;() );\n  }\n  wantarray ? @res : \\@res;\n}\n\nprint join( \",\", pinch { $b - $a } qw( 1 2 3 4 5 6 7 ) ), $/;\n# ==&gt; 1,1,1,1,1,1\n</code>\n</pre>\n", "senID": 1}, {"text": ["The implementation could probably be prettier if I'd made it dependent on List::Util, but... meh!"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "List::Util", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["BinaryOperate or BinaryMerge"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]