[[{"code": "<pre>\n<code>\n myList = ['a','b','c','d']\nmyString = \",\".join(myList )\n</code>\n</pre>\n", "senID": 0}, {"text": ["I'm pretty sure that doesn't work if the list contains numbers."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Why the map/lambda magic?", "Doesn't this work?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;foo = [ 'a', 'b', 'c' ]\n&gt;&gt;&gt;print \",\".join(foo)\na,b,c\n&gt;&gt;&gt;print \",\".join([])\n\n&gt;&gt;&gt;print \",\".join(['a'])\na\n</code>\n</pre>\n", "senID": 1}, {"text": ["Edit: @mark-biek points out the case for numbers.", "Perhaps the list comprehension:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;','.join([str(x) for x in foo])\n</code>\n</pre>\n", "senID": 3}, {"text": ["is more \"pythonic\"."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["Edit2:\nThanks for the suggestions.", "I'll use the generator rather than the list comprehension in the future."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;','.join(str(x) for x in foo)\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Don't you just want:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n \",\".join(l)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Obviously it gets more complicated if you need to quote/escape commas etc in the values.", "In that case I would suggest looking at the csv module in the standard library:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["http://docs.python.org/lib/module-csv.html"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "http://docs.python.org/lib/module-csv.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/lib/module-csv.html"}]}], [{"text": ["@jmanning2k using a list comprehension has the downside of creating a new temporary list.", "The better solution would be using itertools.imap which returns an iterator"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import imap\nl = [1, \"foo\", 4 ,\"bar\"]\n\",\".join(imap(str, l))\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Unless I'm missing something, ','.join(foo) should do what you're asking for."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "','.join(foo)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; ','.join([''])\n''\n&gt;&gt;&gt; ','.join(['s'])\n's'\n&gt;&gt;&gt; ','.join(['a','b','c'])\n'a,b,c'\n</code>\n</pre>\n", "senID": 1}, {"text": ["(edit:  and as jmanning2k points out, "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ','.join([str(x) for x in foo])\n</code>\n</pre>\n", "senID": 3}, {"text": ["is safer and quite Pythonic, though the resulting string will be difficult to parse if the elements can contain commas -- at that point, you need the full power of the csv module, as Douglas points out in his answer."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "csv", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["@Peter Hoffmann"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Peter Hoffmann", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "#44878"}]}, {"text": ["Using generator expressions has the benefit of also producing an iterator but saves importing itertools.", "Furthermore, list comprehensions are generally preferred to map, thus, I'd expect generator expressions to be preferred to imap."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l = [1, \"foo\", 4 ,\"bar\"]\n&gt;&gt;&gt; \",\".join(str(bit) for bit in l)\n'1,foo,4,bar'\n</code>\n</pre>\n", "senID": 2}], [{"text": [">>> l=['a', 1, 'b', 2]"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": [">>>print str(l)[1:-1]"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["\"'a', 1, 'b', 2\""], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here is a alternative solution in Python 3.0 which allows non-string list items:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; alist = ['a', 1, (2, 'b')]\n</code>\n</pre>\n", "senID": 1}, {"tag": "ul", "num": 2, "lis": [{"text": ["a standard way"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["the alternative solution"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]}, {"text": ["NOTE: The space after comma is intentional."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["What if you want to concatenate strings excluding empty values?", "For example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; mylist = ('aaa', '', 'ccc')\n</code>\n</pre>\n", "senID": 1}, {"text": ["What I would like to obtain is a string that excludes values of the string that are empty, so:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 'aaa, ccc'\n</code>\n</pre>\n", "senID": 3}, {"text": ["instead of what ', '.join(mylist) does, which is "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "', '.join(mylist)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; 'aaa, , ccc'\n</code>\n</pre>\n", "senID": 5}, {"text": ["Is there an easy way?"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}]]