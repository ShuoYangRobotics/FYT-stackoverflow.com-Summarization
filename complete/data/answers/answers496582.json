[[{"text": ["I would say, the standard practice to avoid this is to not write classes where you can be 1000 lines away from anything!"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "not write classes where you can be 1000 lines away from anything!", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Seriously, that's way too much for just about any useful class, especially in a language that is as expressive as Python.", "Using more of what the Standard Library offers and abstracting away code into separate modules should help keeping your LOC count down."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The largest classes in the standard library have well below 100 lines! "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["First of all: class attributes, or instance attributes?", "Or both?", "=)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Usually you just add instance attributes in __init__, and class attributes in the class definition, often before method definitions... which should probably cover 90% of use cases."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "Usually", "childNum": 0, "tag": "em", "pos": 0, "childList": []}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If code adds attributes on the fly, it probably (hopefully :-) has good reasons for doing so... leveraging dynamic features, introspection, etc.", "Other than that, adding attributes this way is probably less common than you think."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Instance variables should be initialized in the class's __init__() method.", "(In general)"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__init__()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["If that's not possible.", "You can use __dict__ to get a dictionary of all instance variables of an object during runtime.", "If you really need to track this in documentation add a list of instance variables you are using into the docstring of the class. "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "__dict__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["pylint can statically detect attributes that aren't detected in __init__, along with many other potential bugs."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "pylint", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.logilab.org/project/pylint"}, {"text": "__init__", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["I'd also recommend writing unit tests and running your code often to detect these types of \"whoopsie\" programming mistakes."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["It sounds like you're talking about instance variables and not class variables.", "Note that in the following code a is a class variable and b is an instance variable."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class foo:\n  a = 0 #class variable\n\n  def __init__(self):\n    self.b = 0 #instance variable\n</code>\n</pre>\n", "senID": 1}, {"text": ["Regarding the hypothetical where you create an unneeded instance variable because the other one was about one thousand lines away: The best solution is to not have classes that are one thousand lines long.", "If you can't avoid the length, then your class should have a well defined purpose and that will enable you to keep all of the complexities in your head at once."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A documentation generation system such as Epydoc can be used as a reference for what instance/class variables an object has, and if you're worried about accidentally creating new variables via typos you can use PyChecker to check your code for this."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Epydoc", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://epydoc.sourceforge.net/"}, {"href": "http://pychecker.sourceforge.net/", "text": "PyChecker", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["This is a common concern I hear from many programmers who come from a C, C++, or other statically typed language where variables are pre-declared.", "In fact it was one of the biggest concerns we heard when we were persuading programmers at our organization to abandon C for high-level programs and use Python instead."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In theory, yes you can add instance variables to an object at any time.", "Yes it can happen from typos, etc.", "In practice, it rarely results in a bug.", "When it does, the bugs are generally not hard to find. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["As long as your classes are not bloated (1000 lines is pretty huge!", ") and you have ample unit tests, you should rarely run in to a real problem.", "In case you do, it's easy to drop to a Python console at almost any time and inspect things as much as you wish."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["It seems to me that the main issue here is that you're thinking in terms of C++ when you're working in python."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Having a 1000 line class is not a very wise thing anyway in python, (I know it happens alot in C++ though), "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Learn to exploit the dynamism that python gives you, for instance you can combine lists and dictionaries in very creative ways and save your self hundreds of useless lines of code."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["For example, if you're mapping strings to functions (for dispatching), you can exploit the fact that functions are first class objects and have a dictionary that goes like:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n d = {'command1' : func1, 'command2': func2, 'command3' : func3}\n#then somewhere else use this list to dispatch\n#given a string `str`\nfunc = d[str]\nfunc() #call the function!\n</code>\n</pre>\n", "senID": 4}, {"text": ["Something like this in C++ would take up sooo many lines of code!"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["The easiest is to use an IDE.", "PyDev is a plugin for eclipse."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I'm not a full on expert in all ways pythonic, but in general I define my class members right under the class definition in python, so if I add members, they're all relative."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["My personal opinion is that class members should be declared in one section, for this specific reason."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Local scoped variables, otoh, should be defined closest to when they are used (except in C--which I believe still requires variables to be declared at the beginning of a method)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Consider using slots."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "slots", "tag": "a", "pos": 0, "childList": [{"text": "slots", "tag": "strong"}], "childNum": 1, "href": "http://docs.python.org/reference/datamodel.html#id3"}, {"text": "slots", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["For example:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\nclass Foo:\n     __slots__ = \"a b c\".split()\n   x = Foo()\n   x.a =1    # ok\n   x.b =1    # ok\n   x.c =1    # ok\n   x.bb = 1  # will raise \"AttributeError: Foo instance has no attribute 'bb'\"\n</pre>\n", "senID": 2}, {"text": ["It is generally a concern in any dynamic programming language -- any language that does not require variable declaration -- that a typo in a variable name will create a new variable instead of raise an exception or cause a compile-time error.", "Slots helps with instance variables, but doesn't help you with, module-scope variables, globals, local variables, etc.", "There's no silver bullet for this; it's part of the trade-off of not having to declare variables."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}]]