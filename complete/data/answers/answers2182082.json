[[{"text": ["Generators are perfect for tasks like this.", "They are readable, maintain perfect separation of concerns, and efficient in memory-use and time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def RemoveComments(lines):\n    for line in lines:\n        if not line.strip().startswith('#'):\n            yield line\n\ndef RemoveBlankLines(lines):\n    for line in lines:\n        if line.strip():\n            yield line\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now applying these to your file:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n filehandle = open('myfile', 'r')\nfor line in RemoveComments(RemoveBlankLines(filehandle)):\n    Process(line)\n</code>\n</pre>\n", "senID": 3}, {"text": ["In this case, it's pretty clear that the two generators can be merged into a single one, but I left them separate to demonstrate their composability."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n lines = [r for r in open(thefile) if not r.isspace() and r[0] != '#']\n</code>\n</pre>\n", "senID": 0}, {"text": ["The .isspace() method of strings is by far the best way to test if a string is entirely whitespace -- no need for contortions such as len(r.strip()) == 0 (ech;-)."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": ".isspace()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "len(r.strip()) == 0", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n for line in open(\"file\"):\n    sline=line.strip()\n    if sline and not sline[0]==\"#\" :\n       print line.strip()\n</code>\n</pre>\n", "senID": 0}, {"text": ["output"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n $ cat file\none\n#\n  #\n\ntwo\n\nthree\n$ ./python.py\none\ntwo\nthree\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I would use this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n processed = [process(line.strip())\n             for line in open(config_file, 'r')\n             if line.strip() and not line.strip().startswith('#')]\n</code>\n</pre>\n", "senID": 1}, {"text": ["The only ugliness I see here is all the repeated stripping.", "Getting rid of it complicates the function a bit:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n processed = [process(line)\n             for line in (line.strip() for line in open(config_file, 'r'))\n             if line and not line.startswith('#')]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["This matches the description, ie "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["So lines that start or end in spaces are passed through unfettered."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n with open(\"config_file\",\"r\") as fp:\n    data = (line for line in fp if line.strip() and not line.startswith(\"#\"))\n    for item in data:\n        print repr(item)\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I like Paul Hankin's thinking, but I'd do it differently:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import ifilter, ifilterfalse, imap\n\nwith open(r'c:\\temp\\testfile.txt', 'rb') as f:\n    s1 = ifilterfalse(str.isspace, f)\n    s2 = ifilter(lambda x: not x.startswith('#'), s1)\n    s3 = imap(str.rstrip, s2)\n    print \"\\n\".join(s3)\n</code>\n</pre>\n", "senID": 1}, {"text": ["I'd probably only do it this way instead of using some of the more obvious approaches suggested here if I were concerned about memory usage.", "And I might define an iscomment function to eliminate the lambda."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "iscomment", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["The file is small, so performance is not really an issue.", "I will go for clarity than conciseness:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n fp = open('file.txt')\nfor line in fp:\n    line = line.strip()\n    if line and not line.startswith('#'):\n        # process\nfp.close()\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want, you can wrap this in a function."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Using slightly newer idioms (or with Python 2.5 from __future__ import with) you could do this, which has the advantage of cleaning up safely yet is quite concise."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "from __future__ import with", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n with file('file.txt') as fp:\n    for line in fp:\n        line = line.strip()\n        if not line or line[0] == '#':\n            continue\n\n        # rest of processing here\n</code>\n</pre>\n", "senID": 1}, {"text": ["Note that stripping the line first means the check for \"#\" will actually reject lines with that as the first non-blank, not merely \"as first character\".", "Easy enough to modify if you're strict about that."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "first non-blank", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}]]