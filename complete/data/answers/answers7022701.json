[[{"text": ["It is tuple unpacking, see Python documentation.", "If your function returns a tuple you can always unpack it using a syntax similar to a, b = func()."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "Python documentation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#tuples-and-sequences"}, {"text": "a, b = func()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["Also, you can use tuples on the fly, like a, b = b, a can be used for swapping two values."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "a, b = b, a", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["typ, dat is a tuple.", "When used on the left hand side of an assignment a, b = x it is equivalent to:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "typ, dat", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "a, b = x", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n a = x[0]\nb = x[1]\n</code>\n</pre>\n", "senID": 1}, {"text": ["In your example, typ, dat = imap_conn.search(None, search_string) is equivalent to:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "typ, dat = imap_conn.search(None, search_string)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n search_res = imap_conn.search(None, search_string)\ntyp = search_res[0]\ndat = search_res[1]\n</code>\n</pre>\n", "senID": 3}, {"text": ["This technique of writing a tuple on the left hand side of an assignment is known as tuple unpacking."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["In Python, you can assign and/or return more than one value, as per the following code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fn ():\n    return (7, 2)\n\n(seven, two) = fn()\nprint seven\nprint two\nprint fn()\n</code>\n</pre>\n", "senID": 1}, {"text": ["This outputs:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n 7\n2\n(7, 2)\n</code>\n</pre>\n", "senID": 3}, {"text": ["I prefer the explicit tuple syntax (the one with the parentheses) myself since I believe it makes the intent clearer."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"code": "<pre>\n<code>\n typ, dat = imap_conn.search(None, search_string)\n</code>\n</pre>\n", "senID": 0}, {"text": ["The expression on right-hand side returns two values which are assigned to the two variables on the left-hand side."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Depends what search is returning.", "You can unpack a result using that syntax.", "So for example:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt;x, y = (1,2)\n&gt;&gt;&gt;x\n1\n&gt;&gt;&gt;y\n2\n&gt;&gt;&gt; x, y =[(1,2), [1,2,3,(1,2)]]\n&gt;&gt;&gt; x\n(1, 2)\n&gt;&gt;&gt; y\n[1, 2, 3, (1, 2)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is what is called \"unpacking\", i believe the imap_conn.search(None, search_string method returns 2 values (probably a tuple), this notation allows you can assign them to 2 variables in one shot."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "imap_conn.search(None, search_string", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["This is equivalent to:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n return_val = imap_conn.search(None, search_string)\ntyp = return_val[0]\ndat = return_val[1]\n</code>\n</pre>\n", "senID": 2}], [{"text": ["The syntax for assignments is given at http://docs.python.org/reference/simple_stmts.html#assignment-statements"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "http://docs.python.org/reference/simple_stmts.html#assignment-statements", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/reference/simple_stmts.html#assignment-statements"}]}, {"code": "<pre>\n<code>\n assignment_stmt ::=  (target_list \"=\")+ (expression_list | yield_expression)\ntarget_list     ::=  target (\",\" target)* [\",\"]\ntarget          ::=  identifier\n                     | \"(\" target_list \")\"\n                     | \"[\" target_list \"]\"\n                     | attributeref\n                     | subscription\n                     | slicing\n</code>\n</pre>\n", "senID": 1}, {"text": ["the left hand side of the assignment contains one or more target_list which are comma separate targets.", "A sequence on the right hand side is then unpacked into each target.", "Notice that the definition is recursive, so you can even do things like:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "target_list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n a, [b, c, [d, e]], f = 1, (2, 3, (4, 5)), 6\n</code>\n</pre>\n", "senID": 3}, {"text": ["but at each level the number of elements and the nesting must match.", "If you are using Python 3 then there is an option to include *target in the target_list and that will swallow a variable number of arguments. "], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "*target", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}]]