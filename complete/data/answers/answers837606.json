[[{"text": ["To do it in Python, you can use os.walk(path) to iterate recursively over the files, and the st_size and st_mtime attributes of os.stat(filename) to get the file sizes and modification times."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "os.walk(path)", "tag": "a", "pos": 0, "childList": [{"text": "os.walk(path)", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/os.html"}, {"text": "os.walk(path)", "childNum": 0, "tag": "code", "childList": []}, {"text": "st_size", "childNum": 0, "tag": "code", "childList": []}, {"text": "st_mtime", "childNum": 0, "tag": "code", "childList": []}, {"href": "http://docs.python.org/library/os.html", "text": "os.stat(filename)", "childNum": 1, "tag": "a", "childList": [{"text": "os.stat(filename)", "tag": "code"}]}, {"text": "os.stat(filename)", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["You can use stat and fnmatch modules together to find the files"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "stat", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stat.html#module-stat"}, {"href": "http://docs.python.org/library/fnmatch.html#module-fnmatch", "text": "fnmatch", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["ST_MTIME refere to the last modification time.", "You can choose another value if you want"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import os, stat, fnmatch\nfile_list = []\nfor filename in os.listdir('.'):\n    if fnmatch.fnmatch(filename, '*.avi'):\n        file_list.append((os.stat(filename)[stat.ST_MTIME], filename))\n</code>\n</pre>\n", "senID": 2}, {"text": ["Then you can order the list by time and delete according to it."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n file_list.sort(key=lambda a: a[0])\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I think the easiest way to do this would be to use find along with ls -t (sort files by time)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["something along these lines should do the trick (deletes oldest avi file under specified directory)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n find / -name \"*.avi\" | xargs ls -t | tail -n 1 | xargs rm\n</code>\n</pre>\n", "senID": 2}, {"text": ["step by step...."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["find / -name \"*.avi\" - find all avi files recursively starting at the root directory"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "find / -name \"*.avi\"", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["xargs ls -t - sort all files found by modification time, from newest to oldest."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "xargs ls -t", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["tail -n 1 - grab the last file in the list (oldest)"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "tail -n 1", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["xargs rm - and remove it"], "childNum": 1, "tag": "p", "senID": 7, "childList": [{"text": "xargs rm", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}], [{"text": ["Hm.", "Nadia's answer is closer to what you meant to ask, however, for finding the (single) oldest file in a tree, try this:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "meant", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import os\ndef oldest_file_in_tree(rootfolder, extension=\".avi\"):\n    return min(\n        (os.path.join(dirname, filename)\n        for dirname, dirnames, filenames in os.walk(rootfolder)\n        for filename in filenames\n        if filename.endswith(extension)),\n        key=lambda fn: os.stat(fn).st_mtime)\n</code>\n</pre>\n", "senID": 1}, {"text": ["With a little modification, you can get the n oldest files (similar to Nadia's answer):"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import os, heapq\ndef oldest_files_in_tree(rootfolder, count=1, extension=\".avi\"):\n    return heapq.nsmallest(count,\n        (os.path.join(dirname, filename)\n        for dirname, dirnames, filenames in os.walk(rootfolder)\n        for filename in filenames\n        if filename.endswith(extension)),\n        key=lambda fn: os.stat(fn).st_mtime)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that using the .endswith method allows calls as:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": ".endswith", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n oldest_files_in_tree(\"/home/user\", 20, (\".avi\", \".mov\"))\n</code>\n</pre>\n", "senID": 5}, {"text": ["to select more than one extension."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Finally, should you want the complete list of files, ordered by modification time, in order to delete as many as required to free space, here's some code:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import os\ndef files_to_delete(rootfolder, extension=\".avi\"):\n    return sorted(\n        (os.path.join(dirname, filename)\n         for dirname, dirnames, filenames in os.walk(rootfolder)\n         for filename in filenames\n         if filename.endswith(extension)),\n        key=lambda fn: os.stat(fn).st_mtime),\n        reverse=True)\n</code>\n</pre>\n", "senID": 8}, {"text": ["and note that the reverse=True brings the oldest files at the end of the list, so that for the next file to delete, you just do a file_list.pop()."], "childNum": 2, "tag": "p", "senID": 9, "childList": [{"text": "reverse=True", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "file_list.pop()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["By the way, for a complete solution to your issue, since you are running on Linux, where the os.statvfs is available, you can do:"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "os.statvfs", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import os\ndef free_space_up_to(free_bytes_required, rootfolder, extension=\".avi\"):\n    file_list= files_to_delete(rootfolder, extension)\n    while file_list:\n        statv= os.statvfs(rootfolder)\n        if statv.f_bfree*statv.f_bsize &gt;= free_bytes_required:\n            break\n        os.remove(file_list.pop())\n</code>\n</pre>\n", "senID": 11}, {"text": ["statvfs.f_bfree are the device free blocks and statvfs.f_bsize is the block size.", "We take the rootfolder statvfs, so mind any symbolic links pointing to other devices, where we could delete many files without actually freeing up space in this device."], "childNum": 3, "tag": "p", "senID": 12, "childList": [{"text": "statvfs.f_bfree", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "statvfs.f_bsize", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "rootfolder", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Check out the linux command find."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "find", "tag": "a", "pos": 0, "childList": [{"text": "find", "tag": "code"}], "childNum": 1, "href": "http://content.hccfl.edu/pollock/Unix/FindCmd.htm"}, {"text": "find", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Alternatively, this post pipes together ls and tail to delete the oldest file in a directory.", "That could be done in a loop while there isn't enough free space."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "this post", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.linuxforums.org/forum/debian-linux-help/70289-remove-oldest-file-directory.html"}]}, {"text": ["For reference, here's the shell code that does it (follow the link for more alternatives and a discussion): "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ls -t -r -1 /path/to/files | head --lines 1 | xargs rm\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Here's another Python formulation, which a bit old-school compared to some others, but is easy to modify, and handles the case of no matching files without raising an exception."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import os\n\ndef find_oldest_file(dirname=\"..\", extension=\".avi\"):\n    oldest_file, oldest_time = None, None\n    for dirpath, dirs, files in os.walk(dirname):\n        for filename in files:\n            file_path = os.path.join(dirpath, filename)\n            file_time = os.stat(file_path).st_mtime\n                if file_path.endswith(extension) and (file_time&lt;oldest_time or oldest_time is None):\n                oldest_file, oldest_time = file_path, file_time\n    return oldest_file, oldest_time\n\nprint find_oldest_file()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The os module provides the functions that you need to get directory listings and file info in Python.", "I've found os.walk to be especially useful for walking directories recursively, and os.stat will give you detailed info (including modification time) on each entry."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "os module", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/os.html#files-and-directories"}, {"text": "os.walk", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/os.html?highlight=walk#os.walk"}]}, {"text": ["You may be able to do this easier with a simple shell command.", "Whether that works better for you or not depends on what you want to do with the results."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]