[[{"text": ["You seem to misunderstand how Python (the language) is designed.", "Attributes have no a-priori type (the language is dynamically typed), and therefore it makes, most of the time, little sense to try to coerce attributes explicitly when setting them."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["In AppEngine, each model has a properties() class method, which returns the dict of properties you declared in your model.", "You can use it to check the types your model expects for each attribute:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "properties()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n def populate_object_properties(values_as_strings, \n                               object_to_populate, \n                               properties_to_populate):\n    model_properties = object_to_populate.properties()\n    for k in properties_to_populate:        \n        value = values_as_strings.get(k)\n        model_property = model_properties.get(k)\n        if value:\n            if isinstance(model_property, StringProperty):\n                setattr(object_to_populate, k, str(value))\n            elif isinstance(model_property, IntegerProperty):\n                setattr(object_to_populate, k, int(value))\n        else:\n            setattr(object_to_populate, k, None)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Check a.__class__ , or maybe isinstance(obj, class) if you want to check if the type is as expected."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "__class__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = 1\n&gt;&gt;&gt; a.__class__\n&lt;type 'int'&gt;\n&gt;&gt;&gt; isinstance(a, int)\nTrue\n</code>\n</pre>\n", "senID": 1}, {"text": ["more to the point for you is probably:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; b = \"10\"\n&gt;&gt;&gt; isinstance(b, str)\nTrue\n&gt;&gt;&gt; isinstance(b, int)\nFalse\n&gt;&gt;&gt; int(b)\n10\n</code>\n</pre>\n", "senID": 3}, {"text": ["If your only goal is to set an attribute if the given argument can be expressed as an integer you could also use something like:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def convert(x):\n    try:\n      return int(x) # Or do something else with it\n    except ValueError, e: \n      print \"The value\", x, \"is not an integer\"\n      raise\n\nconvert(123) # =&gt; 123 \nconvert(\"123\") # =&gt; 123\nconvert(\"abc\") # =&gt; ValueError\n</code>\n</pre>\n", "senID": 5}, {"text": ["Some extra text in the question makes me think of changing:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n value = values_as_strings.get(k)\n</code>\n</pre>\n", "senID": 7}, {"text": ["to"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n try:\n  value = int( values_as_strings.get(k) )\nexcept ValueError, e:\n  # It's not an int or string with int contents, what to do?\n  raise\n</code>\n</pre>\n", "senID": 9}, {"text": ["resulting in:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n try:\n  setattr(object_to_populate, k, int( values_as_strings.get(k) ))\nexcept:\n  setattr(object_to_populate, k, None)\n</code>\n</pre>\n", "senID": 11}], [{"text": ["you can use type(a.v) to check it, but if it doesn't have a default value, it could as well be None or undefined."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "type(a.v)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt; class A:\n&gt;&gt;    v=10\n&gt;&gt;    u=None\n&gt;&gt; a=A()\n&gt;&gt; print type(a.v)\n&lt;type 'int'&gt;\n&gt;&gt; print type(a.u)\n&lt;type 'NoneType'&gt;\n&gt;&gt; print type(a.w)\nAttributeError\n&gt;&gt; a.w=20\n&gt;&gt; print type(a.w)\n&lt;type 'int'&gt;\n</code>\n</pre>\n", "senID": 1}, {"text": ["Python builtin tools for introspecion are not utterly useful here.", "I wouldn't rely on them in this case.", "For example xmlrpc libs provide more helpful ways for doing that."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["If you only know the name use a.getattr('v') instead of a.v in the code above."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n if type(getattr(object_to_populate, k))==type('a'):\n    setattr(object_to_populate, k, value)\n</code>\n</pre>\n", "senID": 4}, {"text": ["or use isinstance as suggested by extraneon, it's just the same."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Since python does not do type checking in this case you have to implement this feature by hand (or use existing libraries; see Alex Martellis answer)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One approach: Check if the value is an instance of the desired type, via isinstance."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "isinstance", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Here is a modified version of your code, I'd start with ..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n # 'pdict' is a dictionary of property-value pairs { 'property' : 'value', ... }\ndef populate_object_properties(object_to_populate, pdict):\n    for p, v in pdict.items():\n        setattr(object_to_populate, p, v)\n</code>\n</pre>\n", "senID": 3}, {"text": ["Then we add the typecheck, for this example, we just want to populate the attributes of the object with objects of the same type as the currently used values ...."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n def populate_object_properties(object_to_populate, pdict):\n    for p, v in pdict.items():\n\n        current_value = getattr(p, v, None)\n        klass = type(current_value)\n\n        # allow setting the attribute, when \n        # \n        #    - the attribute did not exist before,\n        #    - the attribute value was 'None',\n        #    - the value to be inserted is of the same type as the current value\n\n        if not current_value or isinstance(v, klass): \n            setattr(object_to_populate, p, v)\n</code>\n</pre>\n", "senID": 5}, {"text": ["A couple of sidenotes:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n # why don't you just take two parameters? 1) the object, 2) a dict with \n# property-value pairs?\n\ndef populate_object_properties(values_as_strings, \n                               object_to_populate, \n                               properties_to_populate):\n\n    for k in properties_to_populate:        \n        value = values_as_strings.get(k)\n\n        # here you are branching on 'value', just to populate \n        # property 'k' with whah might have been 'value' before ..\n        # it's nothing serious, though, just a bit too much to read\n\n        if value:\n            setattr(object_to_populate, k, value)\n        else:\n            setattr(object_to_populate, k, None)\n\n        # you could simply write:\n        # setattr(object_to_populate, k, value)\n</code>\n</pre>\n", "senID": 7}, {"text": ["Further reading: "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"tag": "ul", "num": 1, "lis": [{"text": ["isinstance() considered harmful"], "childNum": 0, "tag": "a", "senID": 9, "childList": []}]}], [{"text": ["Normally, a Python class (or instance thereof) carries no information regarding what types it \"expects\" any given attribute to have, because it has no such \"expectation\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["When you need to encode such metadata, rather than \"rolling your own\", you can use existing third party extensions like Enthought's Traits -- in Traits, among other features, you get:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Traits", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.enthought.com/projects/traits/"}]}], [{"text": ["Since explicit type-checking is so un-pythonic, consider just wrapping the value in int().", "Then, if the value (whatever it is) can be coerced into an int, it will be.", "If it cannot be coerced into an int, then you need to throw an error anyway (which it will do automatically)."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "int()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "int", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"text": ["This is an example of the fundamental difference between \"look before you leap\" and \"it's easier to ask forgiveness than to ask permission\".", "Python isn't a \"look before you leap\" language, it's an \"it's easier to ask forgiveness than ask permission\" language.", ":)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]