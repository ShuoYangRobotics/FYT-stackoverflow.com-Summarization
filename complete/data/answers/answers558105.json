[[{"text": ["Building unashamedly on MrTopf's effort:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nrx = re.compile(\"((?:@\\w+ +)+)(.*)\")\nt='@abc   @def  @xyz Hello this part is text and my email is foo@ba.r'\na,s = rx.match(t).groups()\nl = re.split('[@ ]+',a)[1:-1]\nprint l\nprint s\n</code>\n</pre>\n", "senID": 1}, {"text": ["prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"tag": "hr", "senID": 3}, {"text": ["Justly called to account by hasen j, let me clarify how this works:"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "hasen j", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/users/35364/hasen-j"}]}, {"code": "<pre>\n<code>\n /@\\w+ +/\n</code>\n</pre>\n", "senID": 5}, {"text": ["matches a single tag - @ followed by at least one alphanumeric or _ followed by at least one space character.", "+ is greedy, so if there is more than one space, it will grab them all."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["To match any number of these tags, we need to add a plus (one or more things) to the pattern for tag; so we need to group it with parentheses:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n /(@\\w+ +)+/\n</code>\n</pre>\n", "senID": 8}, {"text": ["which matches one-or-more tags, and, being greedy, matches all of them.", "However, those parentheses now fiddle around with our capture groups, so we undo that by making them into an anonymous group:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n /(?:@\\w+ +)+/\n</code>\n</pre>\n", "senID": 10}, {"text": ["Finally, we make that into a capture group and add another to sweep up the rest:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n /((?:@\\w+ +)+)(.*)/\n</code>\n</pre>\n", "senID": 12}, {"text": ["A last breakdown to sum up:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n ((?:@\\w+ +)+)(.*)\n (?:@\\w+ +)+\n (  @\\w+ +)\n    @\\w+ +\n</code>\n</pre>\n", "senID": 14}, {"tag": "hr", "senID": 15}, {"text": ["Note that in reviewing this, I've improved it - \\w didn't need to be in a set, and it now allows for multiple spaces between tags.", "Thanks, hasen-j!"], "childNum": 0, "tag": "p", "senID": 16, "childList": []}], [{"code": "<pre>\n<code>\n t='@abc @def Hello this part is text'\n\nwords = t.split(' ')\n\nnames = []\nwhile words:\n    w = words.pop(0)\n    if w.startswith('@'):\n        names.append(w[1:])\n    else:\n        break\n\ntext = ' '.join(words)\n\nprint names\nprint text\n</code>\n</pre>\n", "senID": 0}], [{"text": ["How about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"code": "<pre>\n<code>\n [i.strip('@') for i in t.split(' ', 2)[:2]]     # for a fixed number of @def\n a = [i.strip('@') for i in t.split(' ') if i.startswith('@')]\n s = ' '.join(i for i in t.split(' ') if not i.startwith('@'))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["You might also use regular expressions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\nrx = re.compile(\"@([\\w]+) @([\\w]+) (.*)\")\nt='@abc @def Hello this part is text and my email is foo@ba.r'\na,b,s = rx.match(t).groups()\n</code>\n</pre>\n", "senID": 1}, {"text": ["But this all depends on how your data can look like.", "So you might need to adjust it.", "What it does is basically creating group via () and checking for what's allowed in them."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["[edit: this is implementing what was suggested by Osama above]"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "edit", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["This will create L based on the @ variables from the beginning of the string, and then once a non @ var is found, just grab the rest of the string."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n t = '@one @two @three some text   afterward with @ symbols@ meow@meow'\n\nwords = t.split(' ')         # split into list of words based on spaces\nL = []\ns = ''\nfor i in range(len(words)):  # go through each word\n    word = words[i]\n    if word[0] == '@':       # grab @'s from beginning of string\n        L.append(word[1:])\n        continue\n    s = ' '.join(words[i:])  # put spaces back in\n    break                    # you can ignore the rest of the words\n</code>\n</pre>\n", "senID": 2}, {"text": ["You can refactor this to be less code, but I'm trying to make what is going on obvious."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["Here's just another variation that uses split() and no regexpes:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n t='@abc @def My email is red@hjk.com'\ntags = []\nwords = iter(t.split())\n\n# iterate over words until first non-tag word\nfor w in words:\n  if not w.startswith(\"@\"):\n    # join this word and all the following\n    s = w + \" \" + (\" \".join(words))\n    break\n  tags.append(w[1:])\nelse:\n  s = \"\" # handle string with only tags\n\nprint tags, s\n</code>\n</pre>\n", "senID": 1}, {"text": ["Here's a shorter but perhaps a bit cryptic version that uses a regexp to find the first space followed by a non-@ character:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n import re\nt = '@abc @def My email is red@hjk.com @extra bye'\nm = re.search(r\"\\s([^@].*)$\", t)\ntags = [tag[1:] for tag in t[:m.start()].split()]\ns = m.group(1)\nprint tags, s # ['abc', 'def'] My email is red@hjk.com @extra bye\n</code>\n</pre>\n", "senID": 3}, {"text": ["This doesn't work properly if there are no tags or no text.", "The format is underspecified.", "You'll need to provide more test cases to validate."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]