[[{"text": ["Why are you writing a sort?", "Use Python's builtin sorting."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def sort_with_indexes(data):\n    sorted_data = sorted(enumerate(data), key=lambda key: key[1])\n    indexes = range(len(data))\n    indexes.sort(key=lambda key: sorted_data[key][0])\n    return [i[1] for i in sorted_data], indexes\n\ndata, indexes = sort_with_indexes([1,3,4,2])\nprint data, indexes\n</code>\n</pre>\n", "senID": 1}], [{"text": ["the fix to NullUserException's answer is simple:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sorted_list, mapping = zip(*sorted([ (v, i) for i, v in enumerate(l) ]))\nindex_list = [ mapping.index(i) for i in range(len(sorted_list)) ]\n</code>\n</pre>\n", "senID": 1}, {"text": ["just replace the call to sorted with your sorting algorithm."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["When you set A[i+1]=key, clearly indices[j]=i+1.", "However, when you set A[i+1]=A[i] You must increment the value of the element of indices that has the value i (because the element of A that was at i is now at i+1).", "Unfortunately, I think the naive implementation of this algorithm will be O(n^3) in the worst case."], "childNum": 9, "tag": "p", "senID": 0, "childList": [{"text": "A[i+1]=key", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "indices[j]=i+1", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "A[i+1]=A[i]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "indices", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "value", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "i", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "A", "childNum": 0, "tag": "code", "childList": []}, {"text": "i", "childNum": 0, "tag": "code", "childList": []}, {"text": "i+1", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Seems like your idea of changing the indices array while changing the original in order to keep track of them should work.", "I find that when I sometimes have trouble tracking two indices at once and I'll often resort to stepping through the loop(s) on paper to figure out where I'm going wrong."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I modified your version slightly.", "It now sorts the list A in place (non descending) and returns a list with the \"sorted indices\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def insertionSort(A):\n    sorted_indices = [0]\n    for j in range(1, len(A)):\n        sorted_indices.append(j)\n        key = A[j]\n        i = j - 1\n        while i &gt;= 0 and A[i] &gt; key:\n            A[i+1] = A[i]\n            sorted_indices[i+1] = sorted_indices[i]\n            i -= 1\n        A[i+1] = key\n        sorted_indices[i+1] = j\n    return sorted_indices\n</code>\n</pre>\n", "senID": 1}], [{"text": ["I was trying to solve the same problem, but I was sorting arrays rather than lists.", "The problem with using sorted was that it returns a list, which for my purposes took up too much memory.", "Luckily, you can do this with numpy using arrays and argsort:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy\na=numpy.array([1,3,4,2])\np=a.argsort()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Which will give array([0,3,1,2]) as a result.", "This is sorted low to high."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]