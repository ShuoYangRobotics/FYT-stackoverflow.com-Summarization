[[{"code": "<pre>\n<code>\n s = [\"this\", \"this\", \"and\", \"that\"]\nfor i in xrange(1,len(s)):\n    if s[i] == s[i-1]:\n        print s[i]\n</code>\n</pre>\n", "senID": 0}, {"text": ["EDIT:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Just as a side note, if you are using python 3.X use range instead of xrange"], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "range", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "xrange", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n strings = ['this', 'this', 'and', 'that']\nfor a, b in zip(strings, strings[1:]):\n    if a == b:\n        print a\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Most Pythonic is a list comprehension, which is exactly built for looping and testing at the same time:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "list comprehension", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/tutorial/datastructures.html#list-comprehensions"}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; strings = ['this', 'this', 'and', 'that']\n\n&gt;&gt;&gt; [a for (a,b) in zip(strings, strings[1:]) if a==b]\n\n['this']\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or, to avoid temporary objects (h/t @9000):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import itertools as it\n&gt;&gt;&gt; [a for (a,b) in it.izip(strings, it.islice(strings,1)) if a==b]\n\n['this']\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Sometimes, I like to stick with old-fashioned loops:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n strings = ['this', 'this', 'and', 'that']\nfor i in range(0, len(strings)-1):\n   if strings[i] == strings[i+1]:\n      print strings[i]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Everyone knows what's going on without much thinking, and it's fairly efficient..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["why not simply ?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n strings = ['this', 'this', 'and', 'that', 'or', 'or', 12,15,15,15, 'end']\n\na = strings[0]\nfor x in strings:\n    if x==a:\n        print x\n    else:\n        a = x\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n TEST = [\"this\", \"this\", \"and\", \"that\"]\nfor i, s in enumerate(TEST):\n   if i &gt; 0 and TEST[i-1] == s:\n      print s\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Is that homework?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = [\"this\", \"this\", \"and\", \"that\", \"foo\", \"bar\", \"bar\", \"baz\"]\n\nfor i in xrange(len(l)-1):\n   try:\n      if l.index(l[i], i+1) == i+1:\n         print l[i]\n   except ValueError:\n      pass\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Generally speaking, if you're processing over items in a list and you need to look at the current item's neighbors, you're going to want to use enumerate, since enumerate gives you both the current item and its position in the list."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "enumerate", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "enumerate", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Unlike the approaches that use zip, this list comprehension requires no duplication of the list:"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n print [s for i, s in enumerate(test[:-1]) if s == test[i + 1]]\n</code>\n</pre>\n", "senID": 2}, {"text": ["Note that it fails if there aren't at least two elements in test, and that test must be a list.", "(The zip approaches will work on any iterable."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "test", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "test", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "zip", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["Here's a little different approach that uses a special class to detect repeats in a sequence.", "Then you can actually find the repeats using a simple list comprehension."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class repeat_detector(object):\n    def __init__(self, initial=None):\n        self.last = initial\n    def __call__(self, current):\n        if self.last == current:\n            return True\n        self.last = current\n        return False\n\nstrings = [\"this\", \"this\", \"and\", \"that\"]\n\nis_repeat = repeat_detector()\n\nrepeats = [item for item in strings if is_repeat(item)]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Use the recipe for pairwise() from the stdlib itertools documentation (I'll quote it here):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "pairwise()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://docs.python.org/library/itertools.html#recipes", "text": "itertools", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n def pairwise(iterable):\n    \"s -&gt; (s0,s1), (s1,s2), (s2, s3), ...\"\n    a, b = tee(iterable)\n    next(b, None)\n    return izip(a, b)\n</code>\n</pre>\n", "senID": 1}, {"text": ["And you can do:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for a, b in pairwise(L):\n    if a == b:\n        print a\n</code>\n</pre>\n", "senID": 3}, {"text": ["Or with a generator expression thrown in:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n for i in (a for a, b in pairwise(L) if a==b):\n    print i\n</code>\n</pre>\n", "senID": 5}]]