[[{"text": ["Two fairly simple suggestions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["if n is not far from r then using the recursive definition of combination is probably better, since xC0 == 1 you will only have a few iterations:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The relevant recursive definition here is:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["nCr = (n-1)C(r-1) * n/r"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["This can be nicely computed using tail recursion with the following list:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["[(n - r, 0), (n - r + 1, 1), (n - r + 2, 2), ..., (n - 1, r - 1), (n, r)]"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["which is of course easily generated in Python (we omit the first entry since nC0 = 1) by izip(xrange(n - r + 1, n+1), xrange(1, r+1)) Note that this assumes r &lt;= n you need to check for that and swap them if they are not.", "Also to optimize use if r &lt; n/2  then r = n - r."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "izip(xrange(n - r + 1, n+1), xrange(1, r+1))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Now we simply need to apply the recursion step using tail recursion with reduce.", "We start with 1 since nC0 is 1 and then multiply the current value with the next entry from the list as below."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n from itertools import izip\n\nreduce(lambda x, y: x * y[0] / y[1], izip(xrange(n - r + 1, n+1), xrange(1, r+1)), 1)\n</code>\n</pre>\n", "senID": 7}], [{"text": ["If you are computing N choose K (which is what I think you're doing with ncr), there is a dynamic programming solution that may be a lot faster.", "This will avoid factorial, plus you can keep the table if you want for later use."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is a teaching link for it:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["http://www.csc.liv.ac.uk/~ped/teachadmin/algor/dyprog.html"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "http://www.csc.liv.ac.uk/~ped/teachadmin/algor/dyprog.html", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.csc.liv.ac.uk/~ped/teachadmin/algor/dyprog.html"}]}, {"text": ["I am unsure of how to better solve your first problem, though, sorry."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["Edit: Here is the mock-up.", "There are some pretty hilarious off-by-one errors, so it can certainly stand some more clean up."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import sys\nn = int(sys.argv[1])+2#100\nk = int(sys.argv[2])+1#20\ntable = [[0]*(n+2)]*(n+2)\n\nfor i in range(1,n):\n    table[i][i] = 1\nfor i in range(1,n):\n    for j in range(1,n-i):\n        x = i+j\n        if j == 1: table[x][j] = 1\n        else: table[x][j] = table[x-1][j-1] + table[x-1][j]\n\nprint table[n][k]\n</code>\n</pre>\n", "senID": 5}], [{"text": ["If you don't need a pure-python solution, gmpy might help (gmpy.comb is very fast)."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "gmpy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/gmpy/"}, {"text": "gmpy.comb", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["If your problem does not require knowing the exact number of permutations or combinations, then you could use Stirling's approximation for the factorial."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Stirling's approximation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Stirling%27s_approximation"}]}, {"text": ["That would lead to code like this:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import math\n\ndef stirling(n):\n    # http://en.wikipedia.org/wiki/Stirling%27s_approximation\n    return math.sqrt(2*math.pi*n)*(n/math.e)**n\n\ndef npr(n,r):\n    return (stirling(n)/stirling(n-r) if n&gt;20 else\n            math.factorial(n)/math.factorial(n-r))\n\ndef ncr(n,r):    \n    return (stirling(n)/stirling(r)/stirling(n-r) if n&gt;20 else\n            math.factorial(n)/math.factorial(r)/math.factorial(n-r))\n\nprint(npr(3,2))\n# 6\nprint(npr(100,20))\n# 1.30426670868e+39\nprint(ncr(3,2))\n# 3\nprint(ncr(100,20))\n# 5.38333246453e+20\n</code>\n</pre>\n", "senID": 2}], [{"text": ["Using xrange() instead of range() will speed things up slightly due to the fact that no intermediate list is created, populated, iterated through, and then destroyed.", "Also, reduce() with operator.mul."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "xrange()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "range()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "reduce()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "operator.mul", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["For N choose K you could use Pascals triangle.", "Basically you would need to keep array of size N around to compute all the N choose K values.", "Only additions would be required."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]