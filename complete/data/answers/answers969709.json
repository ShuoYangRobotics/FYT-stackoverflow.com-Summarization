[[{"code": "<pre>\n<code>\n import heapq, itertools\ndef intersect(*its):\n    for key, values in itertools.groupby(heapq.merge(*its)):\n    \tif len(list(values)) == len(its):\n    \t\tyield key\n\n&gt;&gt;&gt; list(intersect(*postings))\n[100, 322]\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n def postings(posts):\n    sets = (set(l) for l in posts)\n    return sorted(reduce(set.intersection, sets))\n</code>\n</pre>\n", "senID": 0}, {"text": ["... you could try and take advantage of the fact that the lists are ordered, but since reduce, generator expressions and set are all implemented in C, you'll probably have a hard time doing better than the above with logic implemented in python."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["This solution will compute the intersection of your iterators.", "It works by advancing the iterators one step at a time and looking for the same value in all of them.", "When found, such values are yielded -- this makes the intersect function a generator itself."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "intersect", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import operator\n\ndef intersect(sequences):\n    \"\"\"Compute intersection of sequences of increasing integers.\n\n    &gt;&gt;&gt; list(intersect([[1,   100, 142, 322, 12312],\n    ...                 [2,   100, 101, 322, 1221],\n    ...                 [100, 142, 322, 956, 1222]]))\n    [100, 322]\n    \"\"\"\n    iterators = [iter(seq) for seq in sequences]\n    last = [iterator.next() for iterator in iterators]\n    indices = range(len(iterators) - 1)\n    while True:\n        # The while loop stops when StopIteration is raised. The\n        # exception will also stop the iteration by our caller.\n        if reduce(operator.and_, [l == last[0] for l in last]):\n            # All iterators contain last[0]\n            yield last[0]\n            last = [iterator.next() for iterator in iterators]\n\n        # Now go over the iterators once and advance them as\n        # necessary. To stop as soon as the smallest iterator is\n        # exhausted we advance each iterator only once per iteration\n        # in the while loop.\n        for i in indices:\n            if last[i] &lt; last[i+1]:\n                last[i] = iterators[i].next()\n            if last[i] &gt; last[i+1]:\n                last[i+1] = iterators[i+1].next()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If these are really long (or even infinite) sequences, and you don't want to load everything into a set in advance, you can implement this with a 1-item lookahead on each iterator."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n EndOfIter = object() # Sentinel value\n\nclass PeekableIterator(object):\n    def __init__(self, it):\n        self.it = it\n        self._peek = None\n        self.next() # pump iterator to get first value\n\n    def __iter__(self): return self\n\n    def next(self):\n        cur = self._peek\n        if cur is EndOfIter:\n            raise StopIteration()\n\n        try:\n            self._peek = self.it.next()\n        except StopIteration:\n            self._peek = EndOfIter\n        return cur\n\n    def peek(self): \n        return self._peek\n\n\ndef contained_in_all(seqs):\n   if not seqs: return   # No items\n   iterators = [PeekableIterator(iter(seq)) for seq in seqs]\n   first, rest = iterators[0], iterators[1:]\n\n   for item in first:\n       candidates = list(rest)\n       while candidates:\n           if any(c.peek() is EndOfIter for c in candidates): return  # Exhausted an iterator\n           candidates = [c for c in candidates if c.peek() &lt; item]\n           for c in candidates: c.next()\n\n       # Out of loop if first item in remaining iterator are all &gt;= item.\n       if all(it.peek() == item for it in rest):\n           yield item\n</code>\n</pre>\n", "senID": 1}, {"text": ["Usage:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; print list(contained_in_all(postings))\n[100, 322]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["What about this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import heapq\n\ndef inalliters(iterators):\n  heap=[(iterator.next(),iterator) for iterator in iterators]\n  heapq.heapify(heap)\n  maximal = max(heap)[0]\n  while True:\n    value,iterator = heapq.heappop(heap)\n    if maximal==value: yield value\n    nextvalue=iterator.next()\n    heapq.heappush(heap,(nextvalue,iterator))\n    maximal=max(maximal,nextvalue)\n\npostings = [iter([1,   100, 142, 322, 12312]),\n            iter([2,   100, 101, 322, 1221]),\n            iter([100, 142, 322, 956, 1222])]\nprint [x for x in inalliters(postings)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["I haven't tested it very thoroughly (just ran your example), but I believe the basic idea is sound."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["I want to show that there's an elegant solution, which only iterates forward once.", "Sorry, I don't know the Python well enough, so I use fictional classes.", "This one reads input, an array of iterators, and writes to output on-the-fly without ever going back or using any array function!."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "only iterates forward once", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "input", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "output", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n def intersect (input, output) \n        do:\n            min = input[0]\n            bingo = True\n            for i in input:\n                if (i.cur &lt; min.cur):\n                     bingo = False\n                     min =  i\n            if bingo: \n                output.push(min.cur)\n        while (min.step())\n</code>\n</pre>\n", "senID": 1}]]