[[{"text": ["You can achieve the same with zip:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; l = [\"t0\", \"t1\", \"t2\", \"t3\", \"t4\", \"t5\", \"t6\"]\n&gt;&gt;&gt; zip(l[::2], l[1::2])\n[('t0', 't1'), ('t2', 't3'), ('t4', 't5')]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Both list and tuple are ordered."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "tuple", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n dtg0, dtg1 = itertools.tee(mdtimes)\nnext(dtg0)\ndtsegs = zip(dtg0, dtg1)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Instead of: dtg0 = [x for x in mdtimes], dtg0 = mdtimes[:] would do, since you just copy one list into another."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "dtg0 = [x for x in mdtimes]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "dtg0 = mdtimes[:]", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["As for order, zip's order is well defined, and both lists and tuples are ordered collections, so you should have no problem here."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "zip", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["Turning (x1, x2, x3, ...) into [(x1, x2), (x2, x3), ...] is called a pairwise combination, and it's so common a pattern that the itertools documentation provides a recipe:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/itertools.html#recipes"}]}, {"code": "<pre>\n<code>\n def pairwise(iterable):\n    \"s -&gt; (s0,s1), (s1,s2), (s2, s3), ...\"\n    a, b = tee(iterable)\n    next(b, None)\n    return izip(a, b)\n\nfor ta, tb in pairwise(mdtimes): \n    ....\n</code>\n</pre>\n", "senID": 1}], [{"text": ["This is an answer to the question \"Is this a reasonable approach?", "\" (which appears to have been ignored by all)."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "This is an answer to the question \"Is this a reasonable approach?\" (which appears to have been ignored by all).", "childNum": 0, "tag": "strong", "pos": -1, "childList": []}]}, {"text": ["Summary: You may want/need to lift your gaze from making a pairwise thingy out of mdtimes to the encompassing problem (segmenting bigdata)."], "childNum": 3, "tag": "p", "senID": 1, "childList": [{"text": "Summary:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "mdtimes", "childNum": 0, "tag": "code", "childList": []}, {"text": "bigdata", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Detail:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Detail:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The desired use of the result is expressed as:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n datasegment = [x for x in bigdata if ( (x['datetime'] &gt; tleft) and (x['datetime'] &lt; tright))]\n</code>\n</pre>\n", "senID": 4}, {"text": ["which is better expressed as:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n datasegment = [x for x in bigdata if tleft &lt; x['datetime'] &lt; tright]\n</code>\n</pre>\n", "senID": 6}, {"text": ["Note that as that stands, it will not include any cases where the timestamp is exactly equal to one of the boundary points, so let's change it to:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n datasegment = [x for x in bigdata if tleft &lt;= x['datetime'] &lt; tright]\n</code>\n</pre>\n", "senID": 8}, {"text": ["But that's going to appear in a loop:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n for tleft, tright in dtsegs:\n    datasegment = [x for x in bigdata if tleft &lt;= x['datetime'] &lt; tright]\n    do_something_with(datasegment)\n</code>\n</pre>\n", "senID": 10}, {"text": ["Whoops!", "That's going to take time proportional to len(bigdata) * len(dtsegs) ... what are likely values of len(bigdata) and len(dtsegs)?"], "childNum": 3, "tag": "p", "senID": 11, "childList": [{"text": "len(bigdata) * len(dtsegs)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "len(bigdata)", "childNum": 0, "tag": "code", "childList": []}, {"text": "len(dtsegs)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If bigdata is sorted, what you want to do can be done in time proportional to N, where N = len(bigdata).", "If bigdata is not already sorted, it can be sorted in time proportional to N * log(N)."], "childNum": 5, "tag": "p", "senID": 12, "childList": [{"text": "bigdata", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "N", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "N = len(bigdata)", "childNum": 0, "tag": "code", "childList": []}, {"text": "bigdata", "childNum": 0, "tag": "code", "childList": []}, {"text": "N * log(N)", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["You might like to ask another question ..."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["It's also worth pointing out that any items in bigdata that have a timestamp &lt; min(mdtimes) or >= max(mdtimes) will not be included in any data segment ... is this intentional?"], "childNum": 1, "tag": "p", "senID": 14, "childList": [{"text": "bigdata", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [], [{"text": ["I'm no expert, but aren't you quadrupling your memory requirements by copying the list and then making a new list of pairs taken from two lists?", "Why not just do the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n dtsegs = [(dtg0[i], dtg0[i+1]) for i in range(len(dtg0)-1)]\n</code>\n</pre>\n", "senID": 1}, {"text": ["Dunno how \"Pythonic\" that is, though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: Actually, looking at what you need to do with this list of tuples, you could just do this [i] and [i+1] stuff directly at that level and not even create this new structure at all.", "I don't know how many dates you're dealing with, though - if it's some small number I suppose it doesn't really matter."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["For what it's worth, a couple of the other answerers here seem to be misunderstanding your question, though I can't comment on their posts since I don't have enough reputation yet :) Ignacio Vazquez-Abrams's solution seems the best to me, though his \"next(dtg0)\" should probably be \"next(dtg1)\" (?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}]]