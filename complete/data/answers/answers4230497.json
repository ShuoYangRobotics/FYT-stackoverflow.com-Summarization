[[{"text": ["Since this is homework, consider this pseudo-code that just counts a list:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n function count (LIST)\n    if LIST has more items\n        // recursive case.\n        // Add one for the current item we are counting,\n        // and call count() again to process the *remaining* items.\n        remaining = everything in LIST except the first item\n        return 1 + count(remaining)\n    else\n        // base case -- what \"ends\" the recursion\n        // If an item is removed each time, the list will eventually be empty.\n        return 0\n</code>\n</pre>\n", "senID": 1}, {"text": ["This is very similar to what the homework is asking for, but it needs to be translate to Python and you must work out the correct recursive case logic."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Happy coding."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"code": "<pre>\n<code>\n def count_odd(L):\n    return (L[0]%2) + count_odd(L[1:]) if L else 0\n</code>\n</pre>\n", "senID": 0}], [{"text": ["Are slices ok?", "Doesn't 'feel' recursive to me, but I guess the whole thing is kind of against usual idioms (ie - recursion of this sort in python)"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def countOdd(l):\n    if l == list(): return 0       //base case, empty list means we're done\n    return l[0] % 2 + countOdd(l[1:]) //add 1 (or don't) depending on odd/even of element 0.  recurse on the rest\n</code>\n</pre>\n", "senID": 1}, {"text": ["x%2 is 1 for odds, 0 for evens.", "if you are uncomfortable with it or just dont understand use the following in place of the last line above"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n thisElement = l[0]\n   restOfList = l[1:]\n   if thisElement % 2 == 0: currentElementOdd = 0\n   else: currentElementOdd = 1\n   return currentElementOdd + countOdd(restOfList)\n</code>\n</pre>\n", "senID": 3}, {"text": ["PS - this is pretty recursive, see what your teacher says if you turn this in  =P"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def countOdd(l):\n...     return fold(lambda x,y: x+(y&amp;1),l,0)\n... \n&gt;&gt;&gt; def fold(f,l,a):\n...     if l == list(): return a\n...     return fold(f,l[1:],f(a,l[0]))\n</code>\n</pre>\n", "senID": 5}], [{"text": ["The goal of recursion is to divide the problem into smaller pieces, and apply the solution to the smaller pieces.", "In this case, we can check if the first number of the list (l[0]) is odd, then call the function again (this is the \"recursion\") with the rest of the list (l[1:]), adding our current result to the result of the recursion."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "l[0]", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "l[1:]", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n def count_odd(series):\n    if not series:\n        return 0\n    else:\n        left, right = series[0], series[1:]\n        return count_odd(right) + (1 if (left &amp; 1) else 0)\n</code>\n</pre>\n", "senID": 0}], [{"code": "<pre>\n<code>\n def count_odd(integers):\n    def iter_(lst, count):\n        return iter_(rest(lst), count + is_odd(first(lst))) if lst else count\n    return iter_(integers, 0)\n\ndef is_odd(integer):\n    \"\"\"Whether the `integer` is odd.\"\"\"\n    return integer % 2 != 0 # or `return integer &amp; 1`\n\ndef first(lst):\n    \"\"\"Get the first element from the `lst` list.\n\n    Return `None` if there are no elements.\n    \"\"\"\n    return lst[0] if lst else None\n\ndef rest(lst):\n    \"\"\"Return `lst` list without the first element.\"\"\"\n    return lst[1:]\n</code>\n</pre>\n", "senID": 0}, {"text": ["There is no tail-call optimization in Python, so the above version is purely educational."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The call could be visualize as:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n count_odd([1,2,3])    # returns\niter_([1,2,3], 0)      # could be replaced by; depth=1\niter_([2,3], 0 + is_odd(1)) if [1,2,3] else 0 # `bool([1,2,3])` is True in Python\niter_([2,3], 0 + True) # `True == 1` in Python\niter_([2,3], 1)        # depth=2\niter_([3], 1 + is_odd(2)) if [2,3] else 1\niter_([3], 1 + False)  # `False == 0` in Python\niter_([3], 1)          # depth=3\niter_([], 1 + is_odd(3)) if [3] else 1\niter_([], 2)           # depth=4\niter_(rest([]), 2 + is_odd(first([])) if [] else 2 # bool([]) is False in Python\n2 # the answer\n</code>\n</pre>\n", "senID": 3}, {"text": ["To avoid 'max recursion depth exceeded' errors for large arrays all tail calls in recursive functions can be wrapped in lambda: expressions; and special trampoline() function can be used to unwrap such expressions.", "It effectively converts recursion into iterating over a simple loop:"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "lambda:", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "trampoline()", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"code": "<pre>\n<code>\n import functools\n\ndef trampoline(function):\n    \"\"\"Resolve delayed calls.\"\"\"\n    @functools.wraps(function)\n    def wrapper(*args):\n        f = function(*args)\n        while callable(f):\n            f = f()\n        return f\n    return wrapper\n\ndef iter_(lst, count):\n    #NOTE: added `lambda:` before the tail call\n    return (lambda:iter_(rest(lst), count+is_odd(first(lst)))) if lst else count\n\n@trampoline\ndef count_odd(integers):\n    return iter_(integers, 0)\n</code>\n</pre>\n", "senID": 5}, {"text": ["Example:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n count_odd([1,2,3])\niter_([1,2,3], 0)         # returns callable\nlambda:iter_(rest(lst), count+is_odd(first(lst))) # f = f()\niter_([2,3], 0+is_odd(1)) # returns callable\nlambda:iter_(rest(lst), count+is_odd(first(lst))) # f = f()\niter_([3], 1+is_odd(2))   # returns callable\nlambda:iter_(rest(lst), count+is_odd(first(lst))) # f = f()\niter_([], 1+is_odd(3))\n2                         # callable(2) is False\n</code>\n</pre>\n", "senID": 7}]]