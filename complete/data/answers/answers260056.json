[[{"text": ["This is not possible to do with a regular hash table in any language.", "You'll either have to iterate through the entire keyset, attempting to match the key to your regex, or use a different data structure."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You should choose a data structure that is appropriate to the problem you're trying to solve.", "If you have to match against any arbitrary regular expression, I don't know of a good solution.", "If the class of regular expressions you'll be using is more restrictive, you might be able to use a data structure such as a trie or suffix tree."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "trie", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Trie"}, {"href": "http://en.wikipedia.org/wiki/Suffix_tree", "text": "suffix tree", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["In the general case, what you need is a lexer generator.", "It takes a bunch of regular expressions and compiles them into a recognizer.", "\"lex\" will work if you are using C.  I have never used a lexer generator in Python, but there seem to be a few to choose from.", "Google shows PLY, PyGgy and PyLexer."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "PLY", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://www.dabeaz.com/ply/"}, {"href": "http://www.lava.net/~newsham/pyggy/", "text": "PyGgy", "childNum": 0, "tag": "a", "childList": []}, {"href": "http://margolis-yateley.org.uk/python/various/index.php", "text": "PyLexer", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["If the regular expressions all resemble each other in some way, then you may be able to take some shortcuts.", "We would need to know more about the ultimate problem that you are trying to solve in order to come up with any suggestions.", "Can you share some sample regular expressions and some sample data?"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Also, how many regular expressions are you dealing with here?", "Are you sure that the naive approach won't work?", "As Rob Pike once said, \"Fancy algorithms are slow when n is small, and n is usually small.", "\"  Unless you have thousands of regular expressions, and thousands of things to match against them, and this is an interactive application where a user is waiting for you, you may be best off just doing it the easy way and looping through the regular expressions."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "won't", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": "once said", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://www.lysator.liu.se/c/pikestyle.html"}]}], [{"text": ["This is definitely possible, as long as you're using 'real' regular expressions.", "A textbook regular expression is something that can be recognized by a deterministic finite state machine, which primarily means you can't have back-references in there."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "deterministic finite state machine", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Deterministic_finite_state_machine"}]}, {"text": ["There's a property of regular languages that \"the union of two regular languages is regular\", meaning that you can recognize an arbitrary number of regular expressions at once with a single state machine.", "The state machine runs in O(1) time with respect to the number of expressions (it runs in O(n) time with respect to the length of the input string, but hash tables do too)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Once the state machine completes you'll know which expressions matched, and from there it's easy to look up values in O(1) time."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["What happens if you have a dictionary such as"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n regex_dict = { re.compile(\"foo.*\"): 5, re.compile(\"f.*\"): 6 }\n</code>\n</pre>\n", "senID": 1}, {"text": ["In this case regex_dict[\"food\"] could legitimately return either 5 or 6."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "regex_dict[\"food\"]", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Even ignoring that problem, there's probably no way to do this efficiently with the regex module.", "Instead, what you'd need is an internal directed graph or tree structure."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["There is a Perl module that does just this Tie::Hash::Regex."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Tie::Hash::Regex", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://search.cpan.org/~davecross/Tie-Hash-Regex-1.02/lib/Tie/Hash/Regex.pm"}]}, {"code": "<pre>\n<code>\n use Tie::Hash::Regex;\nmy %h;\n\ntie %h, 'Tie::Hash::Regex';\n\n$h{key}   = 'value';\n$h{key2}  = 'another value';\n$h{stuff} = 'something else';\n\nprint $h{key};  # prints 'value'\nprint $h{2};    # prints 'another value'\nprint $h{'^s'}; # prints 'something else'\n\nprint tied(%h)-&gt;FETCH(k); # prints 'value' and 'another value'\n\ndelete $h{k};   # deletes $h{key} and $h{key2};\n</code>\n</pre>\n", "senID": 1}], [{"text": ["As other respondents have pointed out, it's not possible to do this with a hash table in constant time."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One approximation that might help is to use a technique called \"n-grams\".", "Create an inverted index from n-character chunks of a word to the entire word.", "When given a pattern, split it into n-character chunks, and use the index to compute a scored list of matching words."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "\"n-grams\"", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://en.wikipedia.org/wiki/Ngram#n-grams_for_approximate_matching"}]}, {"text": ["Even if you can't accept an approximation, in most cases this would still provide an accurate filtering mechanism so that you don't have to apply the regex to every key."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["A special case of this problem came up in the 70s AI languages oriented around deductive databases.", "The keys in these databases could be patterns with variables -- like regular expressions without the * or | operators.", "They tended to use fancy extensions of trie structures for indexes.", "See krep*.lisp in Norvig's Paradigms of AI Programming for the general idea."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Paradigms of AI Programming", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://norvig.com/paip/"}]}], [{"text": ["If you have a small set of possible inputs, you can cache the matches as they appear in a second dict and get O(1) for the cached values."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If the set of possible inputs is too big to cache but not infinite, either, you can just keep the last N matches in the cache (check Google for \"LRU maps\" - least recently used)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["If you can't do this, you can try to chop down the number of regexps you have to try by checking a prefix or somesuch."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["What you want to do is very similar to what is supported by xrdb.", "They only support a fairly minimal notion of globbing however."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Internally you can implement a larger family of regular languages than theirs by storing your regular expressions as a character trie. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"tag": "ul", "num": 5, "lis": [{"text": "single characters just become trie nodes. ", "tag": "none", "senID": 2}, {"text": ".'s become wildcard insertions covering all children of the current trie node. ", "tag": "none", "senID": 3}, {"text": "*'s become back links in the trie to node at the start of the previous item. ", "tag": "none", "senID": 4}, {"text": "[a-z] ranges insert the same subsequent child nodes repeatedly under each of the characters in the range. With care, while inserts/updates may be somewhat expensive the search can be linear in the size of the string. With some placeholder stuff the common combinatorial explosion cases can be kept under control. ", "tag": "none", "senID": 5}, {"text": "(foo)|(bar) nodes become multiple insertions", "tag": "none", "senID": 6}]}, {"text": ["This doesn't handle regexes that occur at arbitrary points in the string, but that can be modeled by wrapping your regex with .", "* on either side."], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Perl has a couple of Text::Trie -like modules you can raid for ideas.", "(Heck I think I even wrote one of them way back when)"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["I created this exact data structure for a project once.", "I implemented it naively, as you suggested.", "I did make two immensely helpful optimizations, which may or may not be feasible for you, depending on the size of your data:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": "Memoizing the hash lookups", "tag": "none", "senID": 1}, {"text": "Pre-seeding the the memoization table (not sure what to call this... warming up the cache?)", "tag": "none", "senID": 2}]}, {"text": ["To avoid the problem of multiple keys matching the input, I gave each regex key a priority and the highest priority was used."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["What about the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class redict(dict):\ndef __init__(self, d):\n\tdict.__init__(self, d)\n\ndef __getitem__(self, regex):\n\tr = re.compile(regex)\n\tmkeys = filter(r.match, self.keys())\n\tfor i in mkeys:\n\t\tyield dict.__getitem__(self, i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["It's basically a subclass of the dict type in Python.", "With this you can supply a regular expression as a key, and the values of all keys that match this regex are returned in an iterable fashion using yield."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["With this you can do the following:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; keys = [\"a\", \"b\", \"c\", \"ab\", \"ce\", \"de\"]\n&gt;&gt;&gt; vals = range(0,len(keys))\n&gt;&gt;&gt; red = redict(zip(keys, vals))\n&gt;&gt;&gt; for i in red[r\"^.e$\"]:\n...     print i\n... \n5\n4\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 4}], [{"text": ["The fundamental assumption is flawed, I think.", "you can't map hashes to regular expressions. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["I don't think it's even theoretically possible.", "What happens if someone passes in a string that matches more than 1 regular expression. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For example, what would happen if someone did:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; regex_dict['FileNfoo']\n</code>\n</pre>\n", "senID": 2}, {"text": ["How can something like that possibly be O(1)?"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["It may be possible to get the regex compiler to do most of the work for you by concatenating the search expressions into one big regexp, separated by \"|\".", "A clever regex compiler might search for commonalities in the alternatives in such a case, and devise a more efficient search strategy than simply checking each one in turn.", "But I have no idea whether there are compilers which will do that."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "may", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["It really depends on what these regexes look like.", "If you don't have a lot regexes that will match almost anything like '.", "*' or '\\d+', and instead you have regexes that contains mostly words and phrases or any fixed patterns longer than 4 characters (e.g.", "'a*b*c' in ^\\d+a\\*b\\*c:\\s+\\w+) , as in your examples.", "You can do this common trick that scales well to millions of regexes:"], "childNum": 5, "tag": "p", "senID": 0, "childList": [{"text": ".*", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "\\d+", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "contains", "childNum": 0, "tag": "em", "pos": -1, "childList": []}, {"text": "a*b*c", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "^\\d+a\\*b\\*c:\\s+\\w+", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["Build a inverted index for the regexes (rabin-karp-hash('fixed pattern') -> list of regexes containing 'fixed pattern').", "Then at matching time, using Rabin-Karp hashing to compute sliding hashes and look up the inverted index, advancing one character at a time.", "You now have O(1) look-up for inverted-index non-matches and a reasonable O(k) time for matches, k is the average length of the lists of regexes in the inverted index.", "k can be quite small (less than 10) for many applications.", "The quality (false positive means bigger k, false negative means missed matches) of the inverted index depends on how well the indexer understands the regex syntax.", "If the regexes are generated by human experts, they can provide hints for contained fixed patterns as well."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Ok, I have a very similar requirements, I have a lot of lines of different syntax, basically remark lines and lines with some codes for to use in a process of smart-card format, also, descriptor lines of  keys and secret codes, in every case, I think that the \"model\" pattern/action is the beast approach for to recognize and to process a lot of lines.", "I'm using C++/CLI for to develop my assembly named LanguageProcessor.dll, the core of this library is a lex_rule class that basically contains :"], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "", "childNum": 0, "tag": "br", "pos": 0, "childList": []}, {"text": "C++/CLI", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "LanguageProcessor.dll", "childNum": 0, "tag": "code", "childList": []}]}, {"tag": "ul", "num": 2, "lis": [{"text": "a Regex member", "tag": "none", "senID": 1}, {"text": "an event member ", "tag": "none", "senID": 2}]}, {"text": ["The constructor loads the regex string and call the necessary codes for to build the event on the fly using DynamicMethod, Emit and Reflexion... also into the assembly exists other class like meta and object that constructs ans instantiates the objects by the simple names of the publisher and the receiver class, receiver class provides the action handlers for each rule matched. "], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "DynamicMethod", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "Emit", "childNum": 0, "tag": "code", "childList": []}, {"text": "Reflexion", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Late, I have a class named fasterlex_engine that build a Dictionary&lt;Regex, action_delegate&gt;\nthat load the definitions from an array for to run."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "fasterlex_engine", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "&lt;Regex, action_delegate&gt;", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["The project is in advanced point  but I'm still building, today.", "I will try to enhance the performance of running surrounding the sequential access to  every pair foreach line input, thru using some mechanism of lookup the dictionary directly using the regexp like:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n map_rule[gcnew Regex(\"[a-zA-Z]\")];\n</code>\n</pre>\n", "senID": 6}, {"text": ["Here, some of segments of my code:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n public ref class lex_rule: ILexRule\n{\nprivate:\n    Exception           ^m_exception;\n    Regex               ^m_pattern;\n\n    //BACKSTORAGE delegates, esto me lo aprendi asiendo la huella.net de m*e*da JEJE\n    yy_lexical_action   ^m_yy_lexical_action; \n    yy_user_action      ^m_yy_user_action;\n\npublic: \n    virtual property    String ^short_id; \nprivate:\n    void init(String ^_short_id, String ^well_formed_regex);\npublic:\n\n    lex_rule();\n    lex_rule(String ^_short_id,String ^well_formed_regex);\n    virtual event    yy_lexical_action ^YY_RULE_MATCHED\n    {\n        virtual void add(yy_lexical_action ^_delegateHandle)\n        {\n            if(nullptr==m_yy_lexical_action)\n                m_yy_lexical_action=_delegateHandle;\n        }\n        virtual void remove(yy_lexical_action ^)\n        {\n            m_yy_lexical_action=nullptr;\n        }\n\n        virtual long raise(String ^id_rule, String ^input_string, String ^match_string, int index) \n        {\n            long lReturn=-1L;\n            if(m_yy_lexical_action)\n                lReturn=m_yy_lexical_action(id_rule,input_string, match_string, index);\n            return lReturn;\n        }\n    }\n};\n</code>\n</pre>\n", "senID": 8}, {"text": ["Now the fasterlex_engine class that execute a lot of pattern/action pair:"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}, {"code": "<pre>\n<code>\n public ref class fasterlex_engine \n{\nprivate: \n    Dictionary&lt;String^,ILexRule^&gt; ^m_map_rules;\npublic:\n    fasterlex_engine();\n    fasterlex_engine(array&lt;String ^,2&gt;^defs);\n    Dictionary&lt;String ^,Exception ^&gt; ^load_definitions(array&lt;String ^,2&gt; ^defs);\n    void run();\n};\n</code>\n</pre>\n", "senID": 10}, {"text": ["AND FOR TO DECORATE THIS TOPIC..some code of my cpp file:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"text": ["this code creates a constructor invoker by parameter sign"], "childNum": 0, "tag": "p", "senID": 12, "childList": []}, {"code": "<pre>\n<code>\n inline Exception ^object::builder(ConstructorInfo ^target, array&lt;Type^&gt; ^args)\n{\ntry\n{\n    DynamicMethod ^dm=gcnew DynamicMethod(\n        \"dyna_method_by_totem_motorist\",\n        Object::typeid,\n        args,\n        target-&gt;DeclaringType);\n    ILGenerator ^il=dm-&gt;GetILGenerator();\n    il-&gt;Emit(OpCodes::Ldarg_0);\n    il-&gt;Emit(OpCodes::Call,Object::typeid-&gt;GetConstructor(Type::EmptyTypes)); //invoca a constructor base\n    il-&gt;Emit(OpCodes::Ldarg_0);\n    il-&gt;Emit(OpCodes::Ldarg_1);\n    il-&gt;Emit(OpCodes::Newobj, target); //NewObj crea el objeto e invoca al constructor definido en target\n    il-&gt;Emit(OpCodes::Ret);\n    method_handler=(method_invoker ^) dm-&gt;CreateDelegate(method_invoker::typeid);\n}\ncatch (Exception ^e)\n{\n    return  e;\n}\nreturn nullptr;\n</code>\n</pre>\n", "senID": 13}, {"text": [], "childNum": 0, "tag": "p", "senID": 14, "childList": []}, {"text": ["This code attach an any  handler function (static or not) for to  deal with a callback raised by matching of a input string"], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"code": "<pre>\n<code>\n Delegate ^connection_point::hook(String ^receiver_namespace,String ^receiver_class_name, String ^handler_name)\n{\nDelegate ^d=nullptr;\nif(connection_point::waitfor_hook&lt;=m_state) // si es 0,1,2 o mas =&gt; intenta hookear\n{ \n    try \n    {\n        Type ^tmp=meta::_class(receiver_namespace+\".\"+receiver_class_name);\n        m_handler=tmp-&gt;GetMethod(handler_name);\n        m_receiver_object=Activator::CreateInstance(tmp,false); \n\n        d=m_handler-&gt;IsStatic?\n            Delegate::CreateDelegate(m_tdelegate,m_handler):\n            Delegate::CreateDelegate(m_tdelegate,m_receiver_object,m_handler);\n\n        m_add_handler=m_connection_point-&gt;GetAddMethod();\n        array&lt;Object^&gt; ^add_handler_args={d};\n        m_add_handler-&gt;Invoke(m_publisher_object, add_handler_args);\n        ++m_state;\n        m_exception_flag=false;\n    }\n    catch(Exception ^e)\n    {\n        m_exception_flag=true;\n        throw gcnew Exception(e-&gt;ToString()) ;\n    }\n}\nreturn d;       \n}\n</code>\n</pre>\n", "senID": 16}, {"text": ["finally the code that call the lexer engine: "], "childNum": 0, "tag": "p", "senID": 17, "childList": []}, {"code": "<pre>\n<code>\n array&lt;String ^,2&gt; ^defs=gcnew array&lt;String^,2&gt;  {/*   shortID    pattern         namespc    clase           fun*/\n                                                    {\"LETRAS\",  \"[A-Za-z]+\"     ,\"prueba\",  \"manejador\",    \"procesa_directriz\"},\n                                                    {\"INTS\",    \"[0-9]+\"        ,\"prueba\",  \"manejador\",    \"procesa_comentario\"},\n                                                    {\"REM\",     \"--[^\\\\n]*\"     ,\"prueba\",  \"manejador\",    \"nullptr\"}\n                                                }; //[3,5]\n\n//USO EL IDENTIFICADOR ESPECIAL \"nullptr\" para que el sistema asigne el proceso del evento a un default que realice nada\nfasterlex_engine ^lex=gcnew fasterlex_engine();\nDictionary&lt;String ^,Exception ^&gt; ^map_error_list=lex-&gt;load_definitions(defs);\nlex-&gt;run();\n</code>\n</pre>\n", "senID": 18}]]