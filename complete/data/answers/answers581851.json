[[{"text": ["Creating the folder with a 4-digit random number is insecure, and you also need to worry about collisions with other instances of your program. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A much better way is to create the folder using tempfile.mkdtemp, which does exactly what you want (i.e.", "the folder is not deleted when your script exits).", "You would then pass the folder name to the second Popen'ed script as an argument, and it would be responsible for deleting it."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "tempfile.mkdtemp", "tag": "a", "pos": 0, "childList": [{"text": "tempfile.mkdtemp", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/tempfile.html"}, {"text": "tempfile.mkdtemp", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["What you've suggested is dangerous.", "You may have race conditions if anyone else is trying to create those directories -- including other instances of your application.", "Also, deleting anything containing \"temp\" may result in deleting more than you intended.", "As others have mentioned, tempfile.mkdtemp is probably the safest way to go.", "Here is an example of what you've described, including launching a subprocess to use the new directory."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "tempfile.mkdtemp", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/tempfile.html#tempfile.mkdtemp"}]}, {"code": "<pre>\n<code>\n import tempfile\nimport shutil\nimport subprocess\n\nd = tempfile.mkdtemp(prefix='tmp')\ntry:\n    subprocess.check_call(['/bin/echo', 'Directory:', d])\nfinally:\n    shutil.rmtree(d)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["\"I need to create a folder that I use only once, but need to have it exist until the next run."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["\"Incidentally, the reason that I need the folder around is that I start a process ...\""], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Not incidental, at all.", "Crucial."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["It appears you have the following design pattern."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n mkdir someDirectory\nproc1 -o someDirectory # Write to the directory\nproc2 -i someDirectory # Read from the directory\nif [ %? == 0 ]\nthen\n    rm someDirectory\nfi\n</code>\n</pre>\n", "senID": 4}, {"text": ["Is that the kind of thing you'd write at the shell level?"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["If so, consider breaking your Python application into to several parts."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["The parts that do the real work (\"proc1\" and \"proc2\") "], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["A Shell which manages the resources and processes; essentially a Python replacement for a bash script."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}]}], [{"text": ["A temporary file is something that lasts for a single program run."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["What you need is not, therefore, a temporary file."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Also, beware of multiple users on a single machine - just deleting anything with the 'temp' pattern could be anti-social, doubly so if the directory is not located securely out of the way."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["Also, remember that on some machines, the /tmp file system is rebuilt when the machine reboots."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "/tmp", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["tempfile is just fine, but to be on a safe side you'd need to safe a directory name somewhere until the next run, for example pickle it.", "then read it in the next run and delete directory.", "and you are not required to have /tmp for the root, tempfile.mkdtemp has an optional dir parameter for that.", "by and large, though, it won't be different from what you're doing at the moment."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "tempfile", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "/tmp", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "tempfile.mkdtemp", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "dir", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["The best way of creating the temporary file name is either using tempName.TemporaryFile(mode='w+b', suffix='.tmp', prifix='someRandomNumber' dir=None)\nor u can use mktemp() function."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The mktemp() function will not actually create any file, but will provide a unique filename (actually does not contain PID). "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["You can also automatically register an function to completely remove the temporary directory on any exit (with or without error) by doing :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import atexit\nimport shutil\nimport tempfile\n\n# create your temporary directory\nd = tempfile.mkdtemp()\n\n# suppress it when python will be closed\natexit.register(lambda: shutil.rmtree(d))\n\n# do your stuff...\nsubprocess.Popen([command], shell=True).pid\n</code>\n</pre>\n", "senID": 1}]]