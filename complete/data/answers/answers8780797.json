[[{"text": ["If Thing.. represents an arbitrary text (not a literal data in the string):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Thing..", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import re\n\ndef explode(s, keywords):\n    for k in keywords:\n        m = re.search(r'(%s~[^~]*)(?:~|$)' % (re.escape(k),), s)\n        yield m and m.group(1)\n\nfor row in lst:\n    row[1:2] = explode(row[1], \"Mega Mid Micro\".split())\n</code>\n</pre>\n", "senID": 1}, {"code": "<pre>\n<code>\n import re\nfrom pprint import pprint\n\ndef explode(s, keywords):\n    for k in keywords:\n        m = re.search(r'(%s~[^~]*)(?:~|$)' % (re.escape(k),), s)\n        yield m and m.group(1)\n\n\nlst = [\n ['171000', 'Thing..Mega~Corporate~Thing..Mid~Dairy~Thing..Micro~Cheese', 'Cheese', '0.012174'],\n ['171000', 'Thing..Mega~Corporate', 'Cheese', '0.012174'],\n]\n\nprint(\"Before:\")\npprint(lst)\n\nfor row in lst:\n    row[1:2] = explode(row[1], \"Mega Mid Micro\".split())\n\nprint(\"\\nAfter:\")\npprint(lst)\n</code>\n</pre>\n", "senID": 2}, {"code": "<pre>\n<code>\n Before:\n[['171000',\n  'Thing..Mega~Corporate~Thing..Mid~Dairy~Thing..Micro~Cheese',\n  'Cheese',\n  '0.012174'],\n ['171000', 'Thing..Mega~Corporate', 'Cheese', '0.012174']]\n\nAfter:\n[['171000',\n  'Mega~Corporate',\n  'Mid~Dairy',\n  'Micro~Cheese',\n  'Cheese',\n  '0.012174'],\n ['171000', 'Mega~Corporate', None, None, 'Cheese', '0.012174']]\n</code>\n</pre>\n", "senID": 3}], [{"text": ["If you loop through it, spliting on '..' each time; you can concat everything together in a new list.", "I don't think there's a much simpler solution.", "Speed however, isn't my specialty."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n row = ['171000', 'Thing..Mega~Corporate~Thing..Mid~Dairy~Thing..Micro~Cheese', 'Cheese', '0.012174']\nnew_row = []\nfor i in row: \n    new_row += i.split('..')\n</code>\n</pre>\n", "senID": 1}, {"text": ["The end result is..."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n ['171000', 'Thing', 'Mega~Corporate~Thing', 'Mid~Dairy~Thing', 'Micro~Cheese', 'Cheese', '0.012174']\n</code>\n</pre>\n", "senID": 3}, {"text": ["If you don't want to use an extra variable, another way to do it is using reduce."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "reduce", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n row = reduce(lambda x, y: x + y.split('..'), row, [])\n</code>\n</pre>\n", "senID": 5}, {"text": ["I'm not quite sure what the significance of 'Thing' is in your code, or why it doesn't appear in the output.", "If you explain the rule for it, I'll update my answer."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}], [{"text": ["I don't think I really understand the question...  but hopefully this will give you a hint:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n l = ['171000', 'Mega~Corporate~Thing..Mid~Dairy~Thing..Micro~Cheese', 'Cheese', '0.012174']\n\nstrs = l[1].split('..')\nl = [l[0]] + strs + l[2:]\nprint l\n</code>\n</pre>\n", "senID": 1}], [{"text": ["FakeRainBrigand nailed it already, except if '..' appears in other elements.", "Regardless, I'd be curious to compare timings to see how bad this idea is, which is also technically more correct:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for row in myfile:\n  toSplit = row.pop(1)  # 1 being the position of the string to manipulate\n  for fragment in toSplit.split('..'):\n    row.insert(-2,fragment)\n</code>\n</pre>\n", "senID": 1}, {"text": ["UPDATE: this is what timeit says:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n s1 = \"\"\"myfile = [ ['171000', 'Mega~Corporate~Thing..Mid~Dairy~Thing..Micro~Cheese', 'Cheese', '0.012174'] for i in xrange(1,10000) ]\nfor row in myfile:\n  toSplit = row.pop(1)\n  for fragment in toSplit.split('..'):\n    row.insert(-2,fragment)\n\"\"\"\ns2 = \"\"\"myfile = [ ['171000', 'Mega~Corporate~Thing..Mid~Dairy~Thing..Micro~Cheese', 'Cheese', '0.012174'] for i in xrange(1,10000) ]\nfor row in myfile:\n  new_row = []\n  for i in row: \n    new_row += i.split('..')\n\"\"\"\n&gt;&gt;&gt; t1 = timeit.Timer(stmt=s1)\n&gt;&gt;&gt; t2 = timeit.Timer(stmt=s2)\n&gt;&gt;&gt; print \"%.2f usec/pass\" % (1000000 * t1.timeit(number=1000)/100000)\n166.36 usec/pass\n&gt;&gt;&gt; print \"%.2f usec/pass\" % (1000000 * t2.timeit(number=1000)/100000)\n214.22 usec/pass\n</code>\n</pre>\n", "senID": 3}, {"text": ["Both are not very fast, I'm sure we can do better.", "I'd expect any regex-based solution to be slower.", "Note that splitting on '..' or splitting on '~Thing..' are exactly equivalent, as long as the string remains the same throughout the entire operation."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["Try running this code:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import re\n\nrow = ['171000', 'Thing..Mega~Corporate~Thing..Mid~Dairy~Thing..Micro~Cheese', 'Cheese', '0.012174']\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now, for each row:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n col2 = re.split(r'~?Thing\\.\\.', row[1])[1:]\nrow[1:2] = col2 + ['placeholder'] * (3 - len(col2))\n</code>\n</pre>\n", "senID": 3}, {"text": ["After the last line, row will be as you asked, even filling-in with placeholders if the second position has less than 3 elements after splitting it."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "row", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["This version does lots of checking:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def explode_strg(strg):\n    temp = strg.split('~')\n    npieces = len(temp)\n    assert npieces in (6, 4, 2)\n    result = ['', '', '']\n    prefix = 'Thing..'\n    for i in xrange(0, npieces, 2):\n        k = temp[i]\n        v = temp[i+1]\n        assert k.startswith(prefix)\n        k = k[len(prefix):]\n        j = i // 2\n        assert k == ('Mega', 'Mid', 'Micro')[j]\n        result[j] = k + '~' + v\n    return result\n\ntests = [\n    ('Thing..Mega~Corporate~Thing..Mid~Dairy~Thing..Micro~Cheese', ['Mega~Corporate', 'Mid~Dairy', 'Micro~Cheese']),\n    ('Thing..Mega~Corporate~Thing..Mid~Dairy',                     ['Mega~Corporate', 'Mid~Dairy', '']),\n    ('Thing..Mega~Corporate',                                      ['Mega~Corporate', '', '']),\n    ]\n\nfor s, elist in tests:\n    alist = explode_strg(s)\n    print alist == elist, s, alist\n</code>\n</pre>\n", "senID": 1}]]