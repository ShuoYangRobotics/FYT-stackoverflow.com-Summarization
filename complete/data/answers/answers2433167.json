[[{"text": ["Further significant improvements are possible."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Further significant improvements are possible.", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["The following script file demonstrates these, using (for brevity) only the size 4 loop (which takes up well over 90% of the time)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["method 0: the OP's original code"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["method 1: John Kugleman's solution"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["method 2: (1) and move some string concatenation out of inner loops"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["method 3: (2) and put the code inside a function -- accessing local variables is MUCH faster than global variables.", "Any script can do this.", "Many scripts should do this."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"text": ["method 4: (3) and accumulate strings in a list then join them and write them.", "Note that this uses memory like you may not believe.", "My code doesn't attempt to do it for the whole file, because (127 - 33) ** 4 is 78M strings.", "On a 32-bit box, that's 78 * 4 = 312Mb for the list alone (ignoring unused memory at the end of the list), plus 78 * 28 = 2184 Mb for the str objects (sys.getsizeof(\"1234\") produces 28), plus 78 * 5 = 390 Mb for the join result.", "You just blew your user address space or your ulimit or something else blowable.", "Or if you have 1 Gb of real memory of which 128Mb has been snarfed by the video driver, but enough swap space, you have time for lunch (if running a particular OS, dinner as well)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["method 5: (4) and don't ask the list for the whereabouts of its append attribute 78 million times :-)"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["Here is the script file:"], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"code": "<pre>\n<code>\n import time, sys\ntime_function = time.clock # Windows; time.time may be better on *x\nubound, which = map(int, sys.argv[1:3])\nt0 = time_function()\nif which == 0:\n    ### original ###\n    f = open('wl4.txt', 'w')\n    hh = 0\n    n = 4\n    for l in range(33, ubound):\n        if n == 1:\n            pass\n        elif n == 2:\n            pass\n        elif n == 3:\n            pass\n        elif n == 4:\n            for s0 in range(33, ubound):\n                for s1 in range(33, ubound):\n                    for s2 in range(33,ubound):\n                        b = chr(l) + chr(s0) + chr(s1) + chr(s2) + '\\n'\n                        f.write(b)\n                        hh += 1\n    f.close()\nelif which == 1:\n    ### John Kugleman ###\n    f = open('wl4.txt', 'w')\n    chars = [chr(c) for c in range(33, ubound)]\n    hh = 0\n    for l in chars:\n        for s0 in chars:\n            for s1 in chars:\n                for s2 in chars:\n                    b = l + s0 + s1 + s2 + '\\n'\n                    f.write(b)\n                    hh += 1\n    f.close()\nelif which == 2:\n    ### JohnK, saving + ###\n    f = open('wl4.txt', 'w')\n    chars = [chr(c) for c in range(33, ubound)]\n    hh = 0\n    for L in chars: # \"L\" as in \"Legible\" ;-)\n        for s0 in chars:\n            b0 = L + s0\n            for s1 in chars:\n                b1 = b0 + s1\n                for s2 in chars:\n                    b = b1 + s2 + '\\n'\n                    f.write(b)\n                    hh += 1\n    f.close()\nelif which == 3:\n    ### JohnK,  saving +, function ###\n    def which3func():\n        f = open('wl4.txt', 'w')\n        chars = [chr(c) for c in range(33, ubound)]\n        nwords = 0\n        for L in chars:\n            for s0 in chars:\n                b0 = L + s0\n                for s1 in chars:\n                    b1 = b0 + s1\n                    for s2 in chars:\n                        b = b1 + s2 + '\\n'\n                        f.write(b)\n                        nwords += 1\n        f.close()\n        return nwords\n    hh = which3func()\nelif which == 4:\n    ### JohnK, saving +, function, linesep.join() ###\n    def which4func():\n        f = open('wl4.txt', 'w')\n        chars = [chr(c) for c in range(33, ubound)]\n        nwords = 0\n        for L in chars:\n            accum = []\n            for s0 in chars:\n                b0 = L + s0\n                for s1 in chars:\n                    b1 = b0 + s1\n                    for s2 in chars:\n                        accum.append(b1 + s2)\n            nwords += len(accum)\n            accum.append(\"\") # so that we get a final newline\n            f.write('\\n'.join(accum))\n        f.close()\n        return nwords\n    hh = which4func()\nelif which == 5:\n    ### JohnK, saving +, function, linesep.join(), avoid method lookup in loop ###\n    def which5func():\n        f = open('wl4.txt', 'w')\n        chars = [chr(c) for c in range(33, ubound)]\n        nwords = 0\n        for L in chars:\n            accum = []; accum_append = accum.append\n            for s0 in chars:\n                b0 = L + s0\n                for s1 in chars:\n                    b1 = b0 + s1\n                    for s2 in chars:\n                        accum_append(b1 + s2)\n            nwords += len(accum)\n            accum_append(\"\") # so that we get a final newline\n            f.write('\\n'.join(accum))\n        f.close()\n        return nwords\n    hh = which5func()\nelse:\n    print \"Bzzzzzzt!!!\"\nt1 = time_function()\nprint \"Method %d made %d words in %.1f seconds\" % (which, hh, t1 - t0)\n</code>\n</pre>\n", "senID": 9}, {"text": ["Here are some results:"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"code": "<pre>\n<code>\n C:\\junk\\so&gt;for %w in (0 1 2 3 4 5) do \\python26\\python wl4.py 127 %w\n\nC:\\junk\\so&gt;\\python26\\python wl4.py 127 0\nMethod 0 made 78074896 words in 352.3 seconds\n\nC:\\junk\\so&gt;\\python26\\python wl4.py 127 1\nMethod 1 made 78074896 words in 183.9 seconds\n\nC:\\junk\\so&gt;\\python26\\python wl4.py 127 2\nMethod 2 made 78074896 words in 157.9 seconds\n\nC:\\junk\\so&gt;\\python26\\python wl4.py 127 3\nMethod 3 made 78074896 words in 126.0 seconds\n\nC:\\junk\\so&gt;\\python26\\python wl4.py 127 4\nMethod 4 made 78074896 words in 68.3 seconds\n\nC:\\junk\\so&gt;\\python26\\python wl4.py 127 5\nMethod 5 made 78074896 words in 60.5 seconds\n</code>\n</pre>\n", "senID": 11}, {"text": ["Update in response to OP's questions"], "childNum": 1, "tag": "p", "senID": 12, "childList": [{"text": "Update in response to OP's questions", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["\"\"\" When I try to add for loops, i got a memory error for accum_append.. what is the problem ??", "\"\"\""], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"text": ["I don't know what the problem is; I can't read your code at this distance.", "Guess: If you are trying to do length == 5, you have probably got the accum initialisation and writing bits in the wrong place, and accum is trying to grow beyond the capacity of your system's memory (as I hoped I'd explained earlier)."], "childNum": 2, "tag": "p", "senID": 14, "childList": [{"text": "accum", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "accum", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["\"\"\"Now Method 5 is the fastest one, but its make a word tell length 4.. how could i make how much i want ??", ":)\"\"\""], "childNum": 0, "tag": "p", "senID": 15, "childList": []}, {"text": ["You have two choices: (1) you continue to use nested for loops (2) you look at the answers that don't use nested for loops, with the length specified dynamically."], "childNum": 0, "tag": "p", "senID": 16, "childList": []}, {"text": ["Methods 4 and 5 got speedups by using accum but the manner of doing that was tailored to the exact knowledge of how much memory would be used."], "childNum": 1, "tag": "p", "senID": 17, "childList": [{"text": "accum", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Below are 3 more methods.", "101 is tgray's method with no extra memory use.", "201 is Paul Hankin's method (plus some write-to-file code) similarly with no extra memory use.", "These two methods are of about the same speed and are within sight of method 3 speedwise.", "They both allow dynamic specification of the desired length."], "childNum": 0, "tag": "p", "senID": 18, "childList": []}, {"text": ["Method 102 is tgray's method with a fixed 1Mb buffer -- it attempts to save time by reducing the number of calls to f.write() ... you may wish to experiment with the buffer size.", "You could create an orthogonal 202 method if you wished.", "Note that tgray's method uses itertools.product for which you'll need Python 2.6, whereas Paul Hankin's method uses generator expressions which have been around for a while."], "childNum": 1, "tag": "p", "senID": 19, "childList": [{"text": "itertools.product", "childNum": 0, "tag": "code", "pos": 2, "childList": []}]}, {"code": "<pre>\n<code>\n elif which == 101:\n    ### tgray, memory-lite version\n    def which101func():\n        f = open('wl4.txt', 'w')\n        f_write = f.write\n        nwords = 0\n        chars = map(chr, xrange(33, ubound))  # create a list of characters\n        length = 4 #### length is a variable\n        for x in product(chars, repeat=length):\n            f_write(''.join(x) + '\\n')\n            nwords += 1\n        f.close()\n        return nwords\n    hh = which101func()\nelif which == 102:\n    ### tgray, memory-lite version, buffered\n    def which102func():\n        f = open('wl4.txt', 'w')\n        f_write = f.write\n        nwords = 0\n        chars = map(chr, xrange(33, ubound))  # create a list of characters\n        length = 4 #### length is a variable\n        buffer_size_bytes = 1024 * 1024\n        buffer_size_words = buffer_size_bytes // (length + 1)\n        words_in_buffer = 0\n        buffer = []; buffer_append = buffer.append\n        for x in product(chars, repeat=length):\n            words_in_buffer += 1\n            buffer_append(''.join(x) + '\\n')\n            if words_in_buffer &gt;= buffer_size_words:\n                f_write(''.join(buffer))\n                nwords += words_in_buffer\n                words_in_buffer = 0\n                del buffer[:]\n        if buffer:\n            f_write(''.join(buffer))\n            nwords += words_in_buffer\n        f.close()\n        return nwords\n    hh = which102func()\nelif which == 201:\n    ### Paul Hankin (needed output-to-file code added)\n    def AllWords(n, CHARS=[chr(i) for i in xrange(33, ubound)]):\n        #### n is the required word length\n        if n == 1: return CHARS\n        return (w + c for w in AllWords(n - 1) for c in CHARS)\n    def which201func():\n        f = open('wl4.txt', 'w')\n        f_write = f.write\n        nwords = 0\n        for w in AllWords(4):\n            f_write(w + '\\n')\n            nwords += 1\n        f.close()\n        return nwords\n    hh = which201func()\n</code>\n</pre>\n", "senID": 20}], [{"text": ["You can create the range(33, 127) once and save it off.", "Not having to create it repeatedly cuts the runtime in half on my machine."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "range(33, 127)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n chars = [chr(c) for c in range(33, 127)]\n\n...\n\nfor s0 in chars:\n    for s1 in chars:\n        for s2 in chars:\n            b = l + s0 + s1 + s2 + '\\n'\n            f.write(b)\n            hh += 1\n</code>\n</pre>\n", "senID": 1}], [{"text": ["The outer loop seems pretty pointless.", "Why not simply:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for l in range(33,127)\n   .. your code for the n==1 case\n\nfor l in range(33,127)\n   .. your code for the n==2 case\n\nfor l in range(33,127)\n   .. your code for the n==3 case\n\nfor l in range(33,127)\n   .. your code for the n==4 case\n</code>\n</pre>\n", "senID": 1}, {"text": ["That will be both faster and easier read."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["When doing operations that involve iterating a lot, a good place to start is the itertools package."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "tag": "a", "pos": 0, "childList": [{"text": "itertools", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html"}, {"text": "itertools", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["In this case it looks like you want the productfunction.", "Which gives you the:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "productfunction", "tag": "a", "pos": 0, "childList": [{"text": "product", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/itertools.html#itertools.product"}, {"text": "product", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}, {"text": ["So to get a list of the \"words\" you are creating:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from itertools import product\n\nchars = map(chr, xrange(33,127))  # create a list of characters\nwords = []                        # this will be the list of words\n\nfor length in xrange(1, 5):       # length is the length of the words created\n    words.extend([''.join(x) for x in product(chars, repeat=length)])\n\n# instead of keeping a separate counter, hh, we can use the len function\nprint \"We Made %d Words.\" % (len(words))  \n\nf = open('wl4.txt', 'w')\nf.write('\\n'.join(words))         # write one word per line\nf.close()\n</code>\n</pre>\n", "senID": 3}, {"text": ["As a result we get the result that your script gives us.", "And since itertools is implemented in c, it is also faster."], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "c", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Per John Machin's very astute comment about the memory usage, here's updated code that doesn't give me a memory error when I run it on the whole range(33, 127)."], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n from itertools import product\n\nchars = map(chr, xrange(33,127))  # create a list of characters\nf_words = open('wl4.txt', 'w')\n\nnum_words = 0                     # a counter (was hh in OPs code)\nfor length in xrange(1, 5):       # length is the length of the words created\n    for char_tup in product(chars, repeat=length):\n        f_words.write(''.join(char_tup) + '\\n')\n        num_words += 1\n\nf.close()\nprint \"We Made %d Words.\" % (num_words)\n</code>\n</pre>\n", "senID": 7}, {"text": ["This runs in about 4 minutes (240 seconds) on my machine."], "childNum": 0, "tag": "p", "senID": 8, "childList": []}], [{"text": ["How about this it workes with arbitary word lengths: (Password generator?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f = open('wl4.txt', 'w')\nhh=0\nchars = map(chr,xrange(33, 127))\n\ndef func(n, result):\n    if (n == 0):\n        f.write(result + \"\\n\")\n        hh +=1\n    else:\n        for c in chars:\n            func(n-1, result+c)\n\nfor n in range(1, 5):\n    func(n,\"\")\n######################################   \nprint \"We Made %d Words.\" %(hh)   \n######################################   \nf.close()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Do you need all of the words sorted by their length?", "If you can mingle the lengths together, you can improve slightly on John Kugelman's answer like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n f = open(\"wl4.txt\", \"w\")\n\nchars = [chr(c) for c in range(33, 127)]\nc = len(chars)\ncount = c + c*c + c**3 + c**4\n\nfor c0 in chars:\n    print &gt;&gt;f, c0\n    for c1 in chars:\n        s1 = c0 + c1\n        print &gt;&gt;f, s1\n        for c2 in chars:\n            s2 = s1 + c2\n            print &gt;&gt;f, s2\n            for c3 in chars:\n                print &gt;&gt;f, s2 + c3\n\nprint \"We Made %d Words.\" % count\n</code>\n</pre>\n", "senID": 1}, {"text": ["Directly calculating hh instead of all of the incrementing is also a big win (about 15% on this laptop).", "There's also an improvement from using print over f.write, though i have no idea why that's the case.", "This version runs in about 39 seconds for me."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Here's a short recursive solution."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def AllWords(n, CHARS=[chr(i) for i in xrange(33, 127)]):\n    if n == 1: return CHARS\n    return (w + c for w in AllWords(n - 1) for c in CHARS)\n\nfor i in xrange(1, 5):\n    for w in AllWords(i):\n        print w\n</code>\n</pre>\n", "senID": 1}, {"text": ["PS: is it an error that character 127 is excluded?"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]