[[{"text": ["You want to check out \"django.db.transaction.commit_manually\"."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["http://docs.djangoproject.com/en/dev/topics/db/transactions/#django-db-transaction-commit-manually"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.djangoproject.com/en/dev/topics/db/transactions/#django-db-transaction-commit-manually", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.djangoproject.com/en/dev/topics/db/transactions/#django-db-transaction-commit-manually"}]}, {"text": ["So it would be something like:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n from django.db import transaction\n\n@transaction.commit_manually\ndef viewfunc(request):\n    ...\n    for item in items:\n        entry = Entry(a1=item.a1, a2=item.a2)\n        entry.save()\n    transaction.commit()\n</code>\n</pre>\n", "senID": 3}, {"text": ["Which will only commit once, instead at each save()."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In django 1.3 context managers were introduced.", "So now you can use transaction.commit_on_success() in a similar way:"], "childNum": 2, "tag": "p", "senID": 5, "childList": [{"text": "transaction.commit_on_success()", "childNum": 1, "tag": "strong", "pos": 1, "childList": [{"text": "transaction.commit_on_success()", "tag": "a"}]}, {"href": "https://docs.djangoproject.com/en/1.3/topics/db/transactions/#controlling-transaction-management-in-views", "text": "transaction.commit_on_success()", "childNum": 0, "tag": "a", "childList": []}]}, {"code": "<pre>\n<code>\n from django.db import transaction\n\ndef viewfunc(request):\n    ...\n    with transaction.commit_on_success():\n        for item in items:\n            entry = Entry(a1=item.a1, a2=item.a2)\n            entry.save()\n</code>\n</pre>\n", "senID": 6}], [{"text": ["Have a look at this.", "It's meant for use out-of-the-box with MySQL only, but there are pointers on what to do for other databases."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "this", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.djangosnippets.org/snippets/446/"}]}], [{"text": ["You might be better off bulk-loading the items - prepare a file and use a bulk load tool.", "This will be vastly more efficient than 8000 individual inserts."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["You should check out DSE.", "I wrote DSE to solve these kinds of problems ( massive insert or updates ).", "Using the django orm is a dead-end, you got to do it in plain SQL and DSE takes care of much of that for you."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "DSE", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://pypi.python.org/pypi/dse/0.4.0"}]}, {"text": ["Thomas"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["I recommend using plain SQL (not ORM) you can insert multiple rows with a single insert:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n insert into A select from B;\n</code>\n</pre>\n", "senID": 1}, {"text": ["The select from B portion of your sql could be as complicated as you want it to get as long as the results match the columns in table A and there are no constraint conflicts."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "select from B", "childNum": 0, "tag": "b", "pos": 0, "childList": []}]}], [{"text": ["Bulk creation will be available in Django 1.4:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["https://docs.djangoproject.com/en/dev/ref/models/querysets/#bulk-create"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "https://docs.djangoproject.com/en/dev/ref/models/querysets/#bulk-create", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://docs.djangoproject.com/en/dev/ref/models/querysets/#bulk-create"}]}], [{"text": ["I've ran into the same problem and I can't figure out a way to do it without so many inserts.", "I agree that using transactions is probably the right way to solve it, but here is my hack:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "right", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n def viewfunc(request):\n     ...\n     to_save = [];\n     for item in items:\n         entry = Entry(a1=item.a1, a2=item.a2)\n         to_save.append(entry);\n     map(lambda x: x.save(), to_save);\n</code>\n</pre>\n", "senID": 1}]]