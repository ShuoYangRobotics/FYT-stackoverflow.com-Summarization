[[{"code": "<pre>\n<code>\n import os, threading, Queue\n\ndef idmaker(aqueue):\n  while True:\n    u = hexlify(os.urandom(8)).decode('ascii')\n    aqueue.put(u)\n\nidqueue = Queue.Queue(2)\n\nt = threading.Thread(target=idmaker, args=(idqueue,))\nt.daemon = True\nt.start()\n\ndef idgetter():\n  return idqueue.get()\n</code>\n</pre>\n", "senID": 0}, {"text": ["Queue is often the best way to synchronize threads in Python -- that's frequent enough that when designing a multi-thread system your first thought should be \"how could I best do this with Queues\".", "The underlying idea is to dedicate a thread to entirely \"own\" a shared resource or subsystem, and have all other \"worker\" threads access the resource only by gets and/or puts on Queues used by that dedicated thread (Queue is intrinsically threadsafe)."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Here, we make an idqueue with a length of only 2 (we don't want the id generation to go wild, making a lot of ids beforehand, which wastes memory and exhausts the entropy pool -- not sure if 2 is optimal, but the sweet spot is definitely going to be a pretty small integer;-), so the id generator thread will block when trying to add the third one, and wait until some space opens in the queue.", "idgetter (which could also be simply defined by a top-level assignment, idgetter = idqueue.get) will normally find an id already there and waiting (and make space for the next one!", ") -- if not, it intrinsically blocks and waits, waking up as soon as the id generator has placed a new id in the queue."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "idqueue", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "2", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "idgetter", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "idgetter = idqueue.get", "childNum": 0, "tag": "code", "pos": -1, "childList": []}]}], [{"text": ["Your algorithm is OK (thread safe as far as your DB API module is safe) and probably is the best way to go.", "It will never give you duplicate (assuming you have PRIMARY or UNIQUE key on sid), but you have a neglectfully small chance to get IntegrityError exception on INSERT.", "But your code doesn't look good.", "It's better to use a loop with limited number of attempts instead of recursion (which in case of some error in the code could become infinite):"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "IntegrityError", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n for i in range(MAX_ATTEMPTS):\n    sid = os.urandom(8).decode('hex')\n    db.execute('SELECT COUNT(*) FROM sessions WHERE sid=?', (sid,))\n    if not db.fetchone()[0]:\n        # You can catch IntegrityError here and continue, but there are reasons\n        # to avoid this.\n        db.execute('INSERT INTO sessions (sid) VALUES (?)', (sid,))\n        break\nelse:\n    raise RuntimeError('Failed to generate unique session ID')\n</code>\n</pre>\n", "senID": 1}, {"text": ["You can raise the number of random characters read used to make chance to fail even smaller.", "base64.urlsafe_b64encode() is your friend if you'd like to make SID shorter, but then you have to insure your database uses case-sensitive comparison for this columns (MySQL's VARCHAR is not suitable unless you set binary collation for it, but VARBINARY is OK)."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "base64.urlsafe_b64encode()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}], [{"text": ["I'm suggesting just a small modification to the accepted answer by Denis:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n for i in range(MAX_ATTEMPTS):\n    sid = os.urandom(8).decode('hex')\n    try:\n        db.execute('INSERT INTO sessions (sid) VALUES (?)', (sid,))\n    except IntegrityError:\n        continue\n    break\nelse:\n    raise RuntimeError('Failed to generate unique session ID')\n</code>\n</pre>\n", "senID": 1}, {"text": ["We simply attempt the insert without explicitly checking for the generated ID.", "The insert will very rarely fail, so we most often only have to make the one database call, instead of two."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "very", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}, {"text": ["This will improve efficiency by making fewer database calls, without compromising thread-safety (as this will effectively be handled by the database engine)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["If you require thread safety why not put you random number generator a function that uses a shared lock:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import threading\nlock = threading.Lock()\ndef get_random_number(lock)\n    with lock:\n        print \"This can only be done by one thread at a time\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["If all the threads calling get_random_number use the same lock instance, then only one of them at time can create a random number. "], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "get_random_number", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Of course you have also just created a bottle neck in your application with this solution.", "There are other solutions depending on your requirements such as creating blocks of unique identifiers then consuming them in parallel."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}], [{"text": ["No need to call the database I'd think:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import uuid\n\n# make a UUID based on the host ID and current time\n&gt;&gt;&gt; uuid.uuid1()\nUUID('a8098c1a-f86e-11da-bd1a-00112444be1e')\n</code>\n</pre>\n", "senID": 1}, {"text": ["From this page."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "this page", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://zesty.ca/python/uuid.html"}]}], [{"text": ["I'd start with a thread-unique ID and (somehow) concatenate that with a thread-local counter, then feed it through a cryptographic hash algorithm."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["If you absolutely need to verify uid against database and avoid race conditions, use transactions:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n BEGIN TRANSACTION\nSELECT COUNT(*) FROM sessions WHERE sid=%s\nINSERT INTO sessions (sid,...) VALUES (%s,...)\nCOMMIT\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Is there not a unique piece of data in each thread?", "It is difficult for me to imagine two threads with exactly the same data.", "Though I don't discount the possibility."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["In the past when I have done things of this nature there is usually something unique about the thread.", "User name or client name or something of that nature.", "The solution for me was to concatenate the UserName, for example, and the current time in milliseconds then hash that string and get a hex digest of the hash.", "This gives one a nice string that is always the same length."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["There is a really remote possibility that two different John Smith's (or whatever) in two threads generate the id in the same millisecond.", "If that possibility makes one nervous then the locking route as mentioned may be needed. "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["As was already mentioned there are already routines to get a GUID.", "I personally like fiddling with hash functions so I have rolled my own in the way mentioned on large multi threaded systems with success."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["It is ultimately up to you to decide if you really have threads with duplicate data.", "Be sure to choose a good hashing algorithm.", "I have used md5 successfully but I have read that it is possible to generate a hash collision with md5 though I have never done it.", "Lately I have been using sha1."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["mkdtemp should be thread-safe,simple and secure :"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def uuid():\n    import tempfile,os\n    _tdir = tempfile.mkdtemp(prefix='uuid_')\n    _uuid = os.path.basename(_tdir)\n    os.rmdir(_tdir)\n    return _uuid\n</code>\n</pre>\n", "senID": 1}]]