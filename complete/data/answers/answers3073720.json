[[{"text": ["No.", "There's no way the superclass can know anything about the subclass.", "What it means is if you instantiate the subclass B, and it inherits a method foo(), and overrides a method bar(), then when you call foo(), that will call the bar() definition in B, not the bar() definition in A.", "This is not what the superclass writer intended - he expected his call to bar() to go to his own definition."], "childNum": 6, "tag": "p", "senID": 0, "childList": [{"text": "foo()", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "bar()", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "foo()", "childNum": 0, "tag": "code", "childList": []}, {"text": "bar()", "childNum": 0, "tag": "code", "childList": []}, {"text": "bar()", "childNum": 0, "tag": "code", "childList": []}, {"text": "bar()", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["No, any object that is an A will invoke A.bar and print \"from A\""], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "A", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "A.bar", "childNum": 0, "tag": "code", "childList": []}, {"text": "from A", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Which overridden method is called depends on what the object is, not what other classes may be derived from its class.", "Think of the class as a cookie cutter, and the object as the cookie."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "is", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["Not exactly:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class A:\n   def foo(self):\n       self.bar()\n\n   def foo2(self):\n       self.bar2()\n\n   def bar(self):\n       print \"Bar A\"\n\n   def bar2(self):\n       print \"Bar2 A\"\n\nclass B(A):\n   def bar(self):\n       print \"Bar B\"\n\nobjA = A()\nobjA.foo()\nobjA.foo2()\n\nobjB = B()\nobjB.foo()\nobjB.foo2()\n</code>\n</pre>\n", "senID": 1}, {"text": ["Output:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n Bar A\nBar2 A\nBar B\nBar2 A\n</code>\n</pre>\n", "senID": 3}], [{"text": ["No, it means that you if you have following object:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class B(A):\n    def bar(self):\n        print \"from B\"\n</code>\n</pre>\n", "senID": 1}, {"text": ["and you do"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n obj = B()\nobj.foo()\n</code>\n</pre>\n", "senID": 3}, {"text": ["then this will print from B as foo(), which is defined in the base class, calls bar(), which is also defined in the base class, but overridden in the derived class."], "childNum": 5, "tag": "p", "senID": 4, "childList": [{"text": "from B", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "foo()", "childNum": 0, "tag": "code", "childList": []}, {"text": "base class", "childNum": 0, "tag": "strong", "childList": []}, {"text": "bar()", "childNum": 0, "tag": "code", "childList": []}, {"text": "overridden in the derived class", "childNum": 0, "tag": "strong", "childList": []}]}, {"text": ["At least this is how I read it."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"code": "<pre>\n<code>\n a = A()\na.foo()\nb = B()\nb.foo()\na.bar = b.bar\na.foo()\n</code>\n</pre>\n", "senID": 0}, {"text": ["output:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from A\nfrom B\nfrom B\n</code>\n</pre>\n", "senID": 2}], [{"text": ["My answer doesn't necessarily contradict the ones posted already, but it does show a way to get the base class to print \"from B\" by calling the base class method from the inherited class.", "The base class still calls the inherited class method as it is working from the inherited self.", "Perhaps this is the type of situation the paragraph is referring to?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class A:\n    def foo(self):\n        self.bar()\n\n    def bar(self):\n        print(\"from A\")\n\nclass B(A):\n    def foo(self):\n        super().foo()\n\n    def bar(self):\n        print(\"from B\")\n\n\nA().foo() #prints \"from A\"\nB().foo() #prints \"from B\" but indirectly through the base class\n</code>\n</pre>\n", "senID": 1}]]