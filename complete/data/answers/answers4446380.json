[[{"text": ["lst.count(1) would return the number of times it occurs.", "If you're going to be counting items in a list, O(n) is what you're going to get."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "lst.count(1)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The general function on the list is list.count(x), and will return the number of times x occurs in a list."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "list.count(x)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "x", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Are you asking whether every item in the list is unique?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n len(set(lst)) == len(lst)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Whether 1 occurs more than once?"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n lst.count(1) &gt; 1\n</code>\n</pre>\n", "senID": 3}, {"text": ["Note that the above is not maximally efficient, because it won't short-circuit -- even if 1 occurs twice, it will still count the rest of the occurrences.", "If you want it to short-circuit you will have to write something a little more complicated."], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "1", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["Whether the first element occurs more than once?"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "first", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n lst[0] in lst[1:]\n</code>\n</pre>\n", "senID": 6}, {"text": ["How often each element occurs?"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n import collections\ncollections.Counter(lst)\n</code>\n</pre>\n", "senID": 8}, {"text": ["Something else?"], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["For multiple occurrences, this give you the index of each occurence:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; lst=[1,2,3,4,5,1]\n&gt;&gt;&gt; tgt=1\n&gt;&gt;&gt; found=[]\n&gt;&gt;&gt; for index, suspect in enumerate(lst):\n...     if(tgt==suspect):\n...        found.append(index)\n...\n&gt;&gt;&gt; print len(found), \"found at index:\",\", \".join(map(str,found))\n2 found at index: 0, 5\n</code>\n</pre>\n", "senID": 1}, {"text": ["If you want the count of each item in the list:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; lst=[1,2,3,4,5,2,2,1,5,5,5,5,6]\n&gt;&gt;&gt; count={}\n&gt;&gt;&gt; for item in lst:\n...     count[item]=lst.count(item)\n...\n&gt;&gt;&gt; count\n{1: 2, 2: 3, 3: 1, 4: 1, 5: 5, 6: 1}\n</code>\n</pre>\n", "senID": 3}], [{"code": "<pre>\n<code>\n def valCount(lst):\n    res = {}\n    for v in lst:\n        try:\n            res[v] += 1\n        except KeyError:\n            res[v] = 1\n    return res\n\nu = [ x for x,y in valCount(lst).iteritems() if y &gt; 1 ]\n</code>\n</pre>\n", "senID": 0}, {"text": ["u is now a list of all values which appear more than once."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["Edit:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Edit:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["@katrielalex: thank you for pointing out collections.Counter, of which I was not previously aware.", "It can also be written more concisely using a collections.defaultdict, as demonstrated in the following tests.", "All three methods are roughly O(n) and reasonably close in run-time performance (using collections.defaultdict is in fact slightly faster than collections.Counter)."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["My intention was to give an easy-to-understand response to what seemed a relatively unsophisticated request.", "Given that, are there any other senses in which you consider it \"bad code\" or \"done poorly\"?"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import collections\nimport random\nimport time\n\ndef test1(lst):\n    res = {}\n    for v in lst:\n        try:\n            res[v] += 1\n        except KeyError:\n            res[v] = 1\n    return res\n\ndef test2(lst):\n    res = collections.defaultdict(lambda: 0)\n    for v in lst:\n        res[v] += 1\n    return res\n\ndef test3(lst):\n    return collections.Counter(lst)\n\ndef rndLst(lstLen):\n    r = random.randint\n    return [r(0,lstLen) for i in xrange(lstLen)]\n\ndef timeFn(fn, *args):\n    st = time.clock()\n    res = fn(*args)\n    return time.clock() - st\n\ndef main():\n    reps = 5000\n\n    res = []\n    tests = [test1, test2, test3]\n\n    for t in xrange(reps):\n        lstLen = random.randint(10,50000)\n        lst = rndLst(lstLen)\n        res.append( [lstLen] + [timeFn(fn, lst) for fn in tests] )\n\n    res.sort()\n    return res\n</code>\n</pre>\n", "senID": 5}, {"text": ["And the results, for random lists containing up to 50,000 items, are as follows:\n(Vertical axis is time in seconds, horizontal axis is number of items in list)\n"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "", "childNum": 0, "tag": "img", "pos": 0, "childList": []}]}], [{"text": ["Another way to get all items that occur more than once:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n lst = [1,2,3,4,1]\nd = {}\nfor x in lst: \n    d[x] = x in d\nprint d[1] # True\nprint d[2] # False\nprint [x for x in d if d[x]] # [1]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["You could also sort the list which is O(n*log(n)), then check the adjacent elements for equality, which is O(n).", "The result is O(n*log(n)).", "This has the disadvantage of requiring the entire list be sorted before possibly bailing when a duplicate is found. "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["For a large list with a relatively rare duplicates, this could be the about the best you can do.", "The best way to approach this really does depend on the size of the data involved and its nature."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}]]