[[{"text": ["For the single-dimensional case:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n sum(1 for i in x if i)\n</code>\n</pre>\n", "senID": 1}, {"text": ["For the multi-dimensional case, you can either nest:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n sum(sum(1 for i in row if i) for row in rows)\n</code>\n</pre>\n", "senID": 3}, {"text": ["or do it all within the one construct:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n sum(1 for row in rows\n      for i in row if i)\n</code>\n</pre>\n", "senID": 5}], [{"text": ["If you are using numpy as suggested by the fact that you're using multi-dimensional arrays in Python, the following is similar to @Marcelo's answer, but a tad cleaner:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; a = numpy.array([[1,2,3,0],[0,4,2,0]])\n&gt;&gt;&gt; sum(1 for i in a.flat if i)\n5\n&gt;&gt;&gt;\n</code>\n</pre>\n", "senID": 1}], [{"text": ["While perhaps not concise, this is my choice of how to solve this which works for any dimension:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def sum(li):\n  s = 0\n  for l in li:\n    if isinstance(l, list):\n      s += sum(l)\n    elif l:\n      s += 1\n  return s\n</code>\n</pre>\n", "senID": 1}], [{"code": "<pre>\n<code>\n def zeros(n):\n    return len(filter(lambda x:type(x)==int and x!=0,n))+sum(map(zeros,filter(lambda x:type(x)==list,n)))\n</code>\n</pre>\n", "senID": 0}, {"text": ["Can't really say if it is the fastest way but it is recursive and works with N dimensional lists."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n zeros([1,2,3,4,0,[1,2,3,0,[1,2,3,0,0,0]]]) =&gt; 10\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I would have slightly changed Marcelo's answer to the following:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n len([x for x in my_list if x != 0])\n</code>\n</pre>\n", "senID": 1}, {"text": ["The sum() above tricked me for a second, as I thought he was getting the total value instead of count until I seen the 1 hovering at the start.", "I'd rather be explicit with len()."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["If you go with numpy and your 3D array is a numpy array, this one-liner will do the trick:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["numpy.where(your_array_name != 0, 1, 0).sum()"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["example:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["In [23]: import numpy"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["In [24]: a = numpy.array([ [[0, 1, 2], [0, 0, 7], [9, 2, 0]], [[0, 0, 0], [1, 4, 6], [9, 0, 3]], [[1, 3, 2], [3, 4, 0], [1, 7, 9]] ])"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["In [25]: numpy.where(a != 0, 1, 0).sum()\nOut[25]: 18"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["Using chain to reduce array lookups:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from itertools import chain\nBINS = [[[2,2,2],[0,0,0],[1,2,0]],\n        [[1,0,0],[0,0,2],[1,2,0]],\n        [[0,0,0],[1,1,1],[1,3,0]]]\nsum(1 for c in chain.from_iterable(chain.from_iterable(BINS)) if c &gt; 0)\n14\n</code>\n</pre>\n", "senID": 1}, {"text": ["I haven't done any performance checks on this.", "But it doesn't use any significant memory.", "Note that it is using a generator expression, not a list comprehension.", "Adding the [list comprehension] syntax will create an array to be summed instead of feeding one number at a time to sum."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]