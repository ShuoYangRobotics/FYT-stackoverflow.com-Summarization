[[{"text": ["You could use a generator as an input.", "The generator will only return when there is data available to process."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "generator", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/Generators"}]}, {"text": ["Update: thanks for the brilliant comment, I wanted to remove this entry :)"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n class lazylist(object):\n    def __init__(self):\n        self.cnt = 0\n        self.length = 5000000\n\n    def __iter__(self):\n        return self\n\n    def __len__(self):\n        return self.length\n\n    def next(self):\n        if self.cnt &lt; self.length:\n            self.cnt += 1\n            #return data here or wait for it\n            return self.cnt #just return a counter for this example\n        else:\n            raise StopIteration()\n\n    def __getitem__(self, i):\n        #again, block till you have data.\n        return i+1 #simple counter\n\nmyFunction(lazylist())\n</code>\n</pre>\n", "senID": 2}, {"text": ["Update: As you can see from the comments and other solutions your loop construct and len call causes a lot of headaches, if you can eliminate it you can use a lot more elegant solution.", "for e in li or enumerate is the pythonic way to go."], "childNum": 3, "tag": "p", "senID": 3, "childList": [{"text": "len", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "for e in li", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "enumerate", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["By \"list of numbers\", do you mean an actual built-in list type? "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "list", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"tag": "ul", "num": 1, "lis": [{"text": ["If not, it's simple.", "Python uses duck-typing, so passing any sequence that supports iteration will do.", "Use the yield keyword to pass a generator."], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "yield", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"href": "http://docs.python.org/tutorial/classes.html#generators", "text": "generator", "childNum": 0, "tag": "a", "childList": []}]}]}, {"text": ["and then,"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n myFunction(delayed_list())\n</code>\n</pre>\n", "senID": 3}, {"tag": "ul", "num": 1, "lis": [{"text": "If yes, then it's trickier :)", "tag": "none", "senID": 4}]}, {"text": ["Also, check out PEP8 for recommended Python code style: "], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "PEP8", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.python.org/dev/peps/pep-0008/"}]}, {"tag": "ul", "num": 3, "lis": [{"text": "no spaces around brackets", "tag": "none", "senID": 6}, {"text": ["my_function"], "childNum": 0, "tag": "code", "senID": 7, "childList": []}, {"text": ["for i, val in enumerate(numbers):"], "childNum": 0, "tag": "code", "senID": 8, "childList": []}]}], [{"text": ["subclass list so that when the function tries to read the last value it blocks until another thread provides the value."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import threading\nimport time\n\nclass lastblocks(list):\n    def __init__(self,*args,**kwargs):\n        list.__init__(self,*args,**kwargs)\n        self.e = threading.Event()\n    def __getitem__(self, index):\n        v1 = list.__getitem__(self,index)\n        if index == len(self)-1:\n            self.e.wait()\n            v2 = list.__getitem__(self,index)\n            return v2\n        else:\n            return v1\n\n\nl = lastblocks(range(5000000-1)+[None])\n\ndef reader(l):\n    s = 0\n    for i in xrange(len(l)):\n        s += l[i]\n    print s\n\ndef writer(l):\n    time.sleep(10)\n    l[5000000-1]=5000000-1\n    l.e.set()\n    print \"written\"\n\nreader = threading.Thread(target=reader, args=(l,))\nwriter = threading.Thread(target=writer, args=(l,))\nreader.start()\nwriter.start()\n</code>\n</pre>\n", "senID": 1}, {"text": ["prints:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n written\n12499997500000\n</code>\n</pre>\n", "senID": 3}, {"text": ["for numpy:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n import threading\nimport time\n\nimport numpy as np\n\nclass lastblocks(np.ndarray):\n    def __new__(cls, arry):\n        obj = np.asarray(arry).view(cls)\n        obj.e = threading.Event()\n        return obj\n    def __array_finalize__(self, obj):\n        if obj is None: return\n        self.e = getattr(obj, 'e', None)\n\n    def __getitem__(self, index):\n        v1 = np.ndarray.__getitem__(self,index)\n        if index == len(self)-1:\n            self.e.wait()\n            v2 = np.ndarray.__getitem__(self,index)\n            return v2\n        else:\n            return v1\n\n\nl = lastblocks(np.asarray(range(5000000-1)+[None]))\n\ndef reader(l):\n    s = 0\n    for i in xrange(len(l)):\n        s += l[i]\n    print s\n\ndef writer(l):\n    time.sleep(10)\n    l[5000000-1]=5000000-1\n    l.e.set()\n    print \"written\"\n\nreader = threading.Thread(target=reader, args=(l,))\nwriter = threading.Thread(target=writer, args=(l,))\nreader.start()\nwriter.start()\n</code>\n</pre>\n", "senID": 5}], [{"text": ["Memory protection barriers are a general way to solve this type of problem when the techniques suggested in the other answers (generators and mock objects) are unavailable."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Memory protection barriers", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.memorymanagement.org/glossary/b.html#barrier-1"}]}, {"text": ["A memory barrier is a hardware feature that causes an interrupt when a program tries to access a forbidden area of memory (usually controllable at the page level).", "The interrupt handler can then take appropriate action, for example suspending the program until the data is ready."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["So in this case you'd set up a barrier on the last page of the list, and the interrupt handler would wait until 06:00 before allowing the program to continue."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["You could just create your own iterator to iterate over the 5,000,000 elements.", "This would do whatever you need to do to wait around for the final element (can't be specific since the example in the question is rather abstract).", "I'm assuming you don't care about the code hanging until 6:00, or know how to do it in a background thread."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["More information about writing your own iterator is at http://docs.python.org/library/stdtypes.html#iterator-types"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://docs.python.org/library/stdtypes.html#iterator-types", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/stdtypes.html#iterator-types"}]}], [{"text": ["I'm a little bit confused about not being able to investigate myFunction.", "At least you have to know if your list is being iterated or accessed by index.", "Your example might suggest an index is used.", "If you want to take advantage of iterators/generators, you have to iterate.", "I know you said myFunction is unchangeable, but just want to point out, that most pythonic version would be:"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "myFunction", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "myFunction", "childNum": 0, "tag": "code", "pos": 4, "childList": []}]}, {"code": "<pre>\n<code>\n def myFunction( listNumbers ):\n    calcResult = 0\n\n    # enumerate if you really need an index of element in array\n    for n,v in enumerate(listNumbers):\n        # some complex calculation goes here, changing the value of 'calcResult'\n\n    return calcResult\n</code>\n</pre>\n", "senID": 1}, {"text": ["And now you can start introducing nice ideas.", "One is probably wrapping list with your own type and provide __iter__ method (as a generator); you could return value if accessible, wait for more data if you expect any or return after yielding last element. "], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "__iter__", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "yielding", "childNum": 0, "tag": "em", "childList": []}]}, {"text": ["If you have to access list by index, you can use __getitem__ as in Dan D's example.", "It'll have a limitation though, and you'll have to know the size of array in advance."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "__getitem__", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["There is a simpler generator solution:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def fnc(lst):\n    result = 0\n    index = 0\n    while index &lt; len(lst):\n        while index &lt; len(lst):\n            ... do some manipulations here ...\n            index += 1\n        yield result\n\nlst = [1, 2, 3]\ngen = fnc(lst)\nprint gen.next()\n\nlst.append(4)\nprint gen.next()\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Couldn't you simply do something like this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n processedBefore6 = myFunction([1,2,3]) # the first 4,999,999 vals.\n\nwhile lastVal.notavailable:\n  sleep(1)\n\nprocessedAfter6 = myFunction([processedBefore6, lastVal])\n</code>\n</pre>\n", "senID": 1}, {"text": ["If the effects are linear (step 1 -> step 2 -> step 3, etc) this should allow you to do as much work as possible up front, then catch the final value when it's available and finish up."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]