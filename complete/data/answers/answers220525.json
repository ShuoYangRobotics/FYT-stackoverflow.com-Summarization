[[{"text": ["The Right Thing is advisory locking using flock(LOCK_EX); in Python, this is found in the fcnl module."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "flock(LOCK_EX)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://www.python.org/doc/2.5.2/lib/module-fcntl.html", "text": "the fcnl module", "childNum": 0, "tag": "a", "childList": []}]}, {"text": ["Unlike pidfiles, these locks are always automatically released when your process dies for any reason, have no race conditions exist relating to file deletion (as the file doesn't need to be deleted to release the lock), and there's no chance of a different process inheriting the PID and thus appearing to validate a stale lock."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "need", "childNum": 0, "tag": "i", "pos": 0, "childList": []}]}, {"text": ["If you want unclean shutdown detection, you can write a marker (such as your PID, for traditionalists) into the file after grabbing the lock, and then truncate the file to 0-byte status before a clean shutdown (while the lock is being held); thus, if the lock is not held and the file is non-empty, an unclean shutdown is indicated."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["There are several common techniques including using semaphores.", "The one I see used most often is to create a \"pid lock file\" on startup that contains the pid of the running process.", "If the file already exists when the program starts up, open it up and grab the pid inside, check to see if a process with that pid is running, if it is check the cmdline value in /proc/pid to see if it is an instance of your program, if it is then quit, otherwise overwrite the file with your pid.", "The usual name for the pid file is *application_name*.pid."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "pid", "childNum": 0, "tag": "em", "pos": 1, "childList": []}, {"text": ".pid", "childNum": 0, "tag": "code", "pos": 3, "childList": []}]}], [{"text": ["Complete locking solution using fcntl module:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import fcntl\npid_file = 'program.pid'\nfp = open(pid_file, 'w')\ntry:\n    fcntl.lockf(fp, fcntl.LOCK_EX | fcntl.LOCK_NB)\nexcept IOError:\n    # another instance is running\n    sys.exit(0)\n</code>\n</pre>\n", "senID": 1}, {"text": ["HTH."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["wxWidgets offers a wxSingleInstanceChecker class for this purpose: wxPython doc, or wxWidgets doc.", "The wxWidgets doc has sample code in C++, but the python equivalent should be something like this (untested):"], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "wxPython doc", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.wxpython.org/docs/api/wx.SingleInstanceChecker-class.html"}, {"text": "wxWidgets doc", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://docs.wxwidgets.org/stable/wx_wxsingleinstancechecker.html"}]}, {"code": "<pre>\n<code>\n name = \"MyApp-%s\" % wx.GetUserId()\n  checker = wx.SingleInstanceChecker(name)\n  if checker.IsAnotherRunning():\n      return False\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you create a lock file and put the pid in it, you can check your process id against it and tell if you crashed, no?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I haven't done this personally, so take with appropriate amounts of salt.", ":p"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Can you use the 'pidof' utility?", "If your app is running, pidof will write the Process ID of your app to stdout.", "If not, it will print a newline (LF) and return an error code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Example (from bash, for simplicity):"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n linux# pidof myapp\n8947\nlinux# pidof nonexistent_app\n\nlinux#\n</code>\n</pre>\n", "senID": 2}], [{"text": ["By far the most common method is to drop a file into /var/run/ called [application].pid which contains only the PID of the running process, or parent process.", "As an alternative, you can create a named pipe in the same directory to be able to send messages to the active process, e.g.", "to open a new file."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["This is the Posix equivalent, I believe."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "This", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.opengroup.org/onlinepubs/007908799/xsh/semaphore.h.html"}]}], [{"text": ["Look for a python module that interfaces to SYSV semaphores on unix.", "The semaphores have a SEM_UNDO flag which will cause the resources held by the a process to be released if the process crashes."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Otherwise as Bernard suggested, you can use "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import os\nos.getpid()\n</code>\n</pre>\n", "senID": 2}, {"text": ["And write it to /var/run/*application_name*.pid.", "When the process starts, it should check if the pid in /var/run/*application_name*.pid is listed in the ps table and quit if it is, otherwise write its own pid into /var/run/*application_name*.pid.", "In the following var_run_pid is the pid you read from /var/run/*application_name*.pid"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n cmd = \"ps -p %s -o comm=\" % var_run_pid\napp_name = os.popen(cmd).read().strip()\nif len(app_name) &gt; 0:\n    Already running\n</code>\n</pre>\n", "senID": 4}], [{"text": ["I found this link, which uses fcntl as suggested by others: Interprocess Synchronization in Python/Linux."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "fcntl", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"href": "http://www.soundc.de/blog/2008/10/21/interprocess-synchronization-in-pythonlinux/", "text": "Interprocess Synchronization in Python/Linux", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["I've made a basic framework for running these kinds of applications when you want to be able to pass the command line arguments of subsequent attempted instances to the first one.", "An instance will start listening on a predefined port if it does not find an instance already listening there.", "If an instance already exists, it sends its command line arguments over the socket and exits."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["code w/ explanation"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "code w/ explanation", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://dwiel.net/blog/single-instance-application-with-command-line-interface/"}]}]]