[[{"text": ["Have you considered Numpy arrays?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["PyTables are wonderful when your data is too large to fit in memory, but a\n200x2000 matrix of 8 byte floats only requires about 3MB of memory.", "So I think\nPyTables may be overkill. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["You can save numpy arrays to files using np.savetxt or np.savez (for compression), and can read them from files with np.loadtxt or np.load."], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "np.savetxt", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "np.savez", "childNum": 0, "tag": "code", "childList": []}, {"text": "np.loadtxt", "childNum": 0, "tag": "code", "childList": []}, {"text": "np.load", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["If you have many such arrays to store on disk, then I'd suggest using a database instead of numpy .npz files.", "By the way, to store a 200x2000 matrix in a database, you only need 3 table columns: row, col, value:"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": ".npz", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import sqlite3\nimport numpy as np\n\ndb = sqlite3.connect(':memory:')\ncursor = db.cursor()\ncursor.execute('''CREATE TABLE foo\n                  (row INTEGER,\n                   col INTEGER,\n                   value FLOAT,\n                   PRIMARY KEY (row,col))''')\nROWS=4\nCOLUMNS=6\nmatrix = np.random.random((ROWS,COLUMNS))\nprint(matrix)\n# [[ 0.87050721  0.22395398  0.19473001  0.14597821  0.02363803  0.20299432]\n#  [ 0.11744885  0.61332597  0.19860043  0.91995295  0.84857095  0.53863863]\n#  [ 0.80123759  0.52689885  0.05861043  0.71784406  0.20222138  0.63094807]\n#  [ 0.01309897  0.45391578  0.04950273  0.93040381  0.41150517  0.66263562]]\n\n# Store matrix in table foo\ncursor.executemany('INSERT INTO foo(row, col, value) VALUES (?,?,?) ',\n                   ((r,c,value) for r,row in enumerate(matrix) \n                                for c,value in enumerate(row)))\n\n# Retrieve matrix from table foo\ncursor.execute('SELECT value FROM foo ORDER BY row,col')\ndata=zip(*cursor.fetchall())[0]\nmatrix2 = np.fromiter(data,dtype=np.float).reshape((ROWS,COLUMNS))\nprint(matrix2)\n# [[ 0.87050721  0.22395398  0.19473001  0.14597821  0.02363803  0.20299432]\n#  [ 0.11744885  0.61332597  0.19860043  0.91995295  0.84857095  0.53863863]\n#  [ 0.80123759  0.52689885  0.05861043  0.71784406  0.20222138  0.63094807]\n#  [ 0.01309897  0.45391578  0.04950273  0.93040381  0.41150517  0.66263562]]\n</code>\n</pre>\n", "senID": 4}, {"text": ["If you have many such 200x2000 matrices, you just need one more table column to specify which matrix."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["As far as importing/exporting goes, PyTables uses a standardized file format called HDF5.", "Many scientific software packages (like MATLAB) have built-in support for HDF5, and the C API isn't terrible.", "So any data you need to export from or import to one of these languages can simply be kept in HDF5 files. "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "HDF5", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.hdfgroup.org/HDF5/"}]}, {"text": ["PyTables does add some attributes of its own, but these shouldn't hurt you.", "Of course, if you store Python objects in the file, you won't be able to read them elsewhere. "], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["The one nice thing about CSV files is that they're human readable.", "However, if you need to store anything other than simple numbers in them and communicate with others, you'll have issues.", "I receive CSV files from people in other organizations, and I've noticed that humans aren't good at making sure things like string quoting are done correctly.", "It's good that Python's CSV parser is as flexible as it is.", "One other issue is that floating point numbers can't be stored exactly in text using decimal format.", "It's usually good enough, though."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["These are not \"exclusive\" choices."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You need both."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["CSV is just a data exchange format.", "If you use pytables, you still need to import and export in CSV format."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["i think its very hard to comapre pytables and csv.. pyTable is a datastructure ehile CSV is an exchange format for data."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["This is actually quite related to another answer I've provided regarding reading / writing csv files w/ numpy:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Python: how to do basic data manipulation like in R?"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Python: how to do basic data manipulation like in R?", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/4899851/python-how-to-do-basic-data-manipulation-like-in-r/4902234#4902234"}]}, {"text": ["You should definitely use numpy, no matter what else!", "The ease of indexing, etc.", "far outweighs the cost of the additional dependency (well, I think so).", "PyTables, of course, relies on numpy too."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "definitely", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}, {"text": ["Otherwise, it really depends on your application, your hardware and your audience.", "I suspect that reading in csv files of the size you're talking about won't matter in terms of speed compared to PyTables.", "But if that's a concern, write a benchmark!", "Read and write some random data 100 times.", "Or, if read times matter more, write once, read 100 times, etc."], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["I strongly suspect that PyTables will outperform SQL.", "SQL will rock on complex multi-table queries (especially if you do the same ones frequently), but even on single-table (so called \"denormalized\") table queries, pytables is hard to beat in terms of speed.", "I can't find a reference for this off-hand, but you may be able to dig something up if you mine the links here:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["http://www.pytables.org/moin/HowToUse#HintsforSQLusers"], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "http://www.pytables.org/moin/HowToUse#HintsforSQLusers", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.pytables.org/moin/HowToUse#HintsforSQLusers"}]}, {"text": ["I'm guessing execute performance for you at this stage will pale in comparison to coder performance.", "So, above all, pick something that makes the most sense to you!"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"text": ["Other points:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"text": ["As with SQL, PyTables has an undo feature.", "CSV files won't have this, but you can keep them in version control, and you VCS doesn't need to be too smart (CSV files are text). "], "childNum": 0, "tag": "p", "senID": 8, "childList": []}, {"text": ["On a related note, CSV files will be much bigger than binary formats (you can certainly write your own tests for this too)."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["One big plus for PyTables is the storage of metadata, like variables etc.", "If you run the simulations more often with different parameters you the store the results as an array entry in the h5 file."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["We use it to store measurement data + experiment scripts to get the data so it is all self contained."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["BTW: If you need to look quickly into a hdf5 file you can use HDFView.", "It's a Java app for free from the HDFGroup.", "It's easy to install."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}]]