[[{"text": ["I'd parse the string if conversion fails:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def convert(s):\n    try:\n        return float(s)\n    except ValueError:\n        num, denom = s.split('/')\n        return float(num) / float(denom)\n...\n\n&gt;&gt;&gt; convert(\"0.1234\")\n0.1234\n\n&gt;&gt;&gt; convert(\"1/2\")\n0.5\n</code>\n</pre>\n", "senID": 1}, {"text": ["Generally using eval is a bad idea, since it's a security risk.", "Especially if the string being evaluated came from outside the system."], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Especially", "childNum": 0, "tag": "em", "pos": 1, "childList": []}]}], [{"text": ["As others have pointed out, using eval is potentially a security risk, and certainly a bad habit to get into.", "(if you don't think it's as risky as exec, imagine evaling something like: __import__('os').system('rm -rf /'))"], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "eval", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "exec", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "eval", "childNum": 0, "tag": "code", "childList": []}, {"text": "__import__('os').system('rm -rf /')", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["However, if you have python 2.6 or up, you can use ast.literal_eval, for which the string provided:"], "childNum": 2, "tag": "p", "senID": 1, "childList": [{"text": "ast.literal_eval", "tag": "a", "pos": 0, "childList": [{"text": "ast.literal_eval", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/ast.html#ast.literal_eval"}, {"text": "ast.literal_eval", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["Thus it should be quite safe :-)"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["Another option (also only for 2.6 and up) is the fractions module."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "fractions", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; Fraction(\"0.1234\")\nFraction(617, 5000)\n&gt;&gt;&gt; Fraction(\"1/2\")\nFraction(1, 2)\n&gt;&gt;&gt; float(Fraction(\"0.1234\"))\n0.1234\n&gt;&gt;&gt; float(Fraction(\"1/2\"))\n0.5\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Use from __future__ import division to get the behavior you want.", "Then, in a pinch, you can do something like "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "from __future__ import division", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n from __future__ import division\nstrings = [\"0.1234\", \"1/2\", \"2/3\"]\nnumbers = map(eval, strings)\n</code>\n</pre>\n", "senID": 1}, {"text": ["to get a list of floats out of your strings.", "If you want to do this the \"right\" way, don't use eval(), but instead write a function that accepts a string and calls float() on it if it contains no slash, or parses the string and divides the numerator and denominator if there's a slash in it."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "eval()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "float()", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["One way to do it:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n def parse_float_string(x)\n    parts = x.split('/', 1)\n    if len(parts) == 1:\n        return float(x)\n    elif len(parts) == 2:\n        return float(parts[0])/float(parts[1])\n    else:\n        raise ValueError\n</code>\n</pre>\n", "senID": 4}, {"text": ["Then just map(parse_float_string, strings) will get you your list."], "childNum": 1, "tag": "p", "senID": 5, "childList": [{"text": "map(parse_float_string, strings)", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["The / operator does integer division.", "Try:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "/", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; eval(\"1.0*\" + \"1/2\")\n0.5\n</code>\n</pre>\n", "senID": 1}, {"text": ["Because eval() is potentially dangerous, you should always check precisely what you are passing into it:"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "eval()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; import re\n&gt;&gt;&gt; s = \"1/2\"\n&gt;&gt;&gt; if re.match(r\"\\d+/\\d+$\", s):\n...     eval(\"1.0*\" + s)\n...\n0.5\n</code>\n</pre>\n", "senID": 3}, {"text": ["However, if you go to the trouble of matching the input against a regex in the first place, you might as well use r\"(\\d+)/(\\d+)$\" to extract the numerator and denominator, do the division yourself, and entirely avoid eval():"], "childNum": 2, "tag": "p", "senID": 4, "childList": [{"text": "r\"(\\d+)/(\\d+)$\"", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "eval()", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; m = re.match(r\"(\\d+)/(\\d+)$\", s)\n&gt;&gt;&gt; if m:\n...     float(m.group(1)) / float(m.group(2))\n...\n0.5\n</code>\n</pre>\n", "senID": 5}], [{"text": ["The problem with eval is that, as in python, the quotient of integers is an integer.", "So, you have several choices."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["The first is simply to make integer division return floats:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n from __future__ import division\n</code>\n</pre>\n", "senID": 2}, {"text": ["The other is to split the rational number:"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n reduce(lambda x, y: x*y, map(int, rat_str.split(\"/\")), 1)\n</code>\n</pre>\n", "senID": 4}, {"text": ["Where rat_str is the string with a rational number."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["That's because 1 and 2 are interpreted by Python as integers and not floats.", "It needs to be 1.0/2.0 or some mix of that."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["The suggestions with from __future__ import division combined with eval will certainly work."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "from __future__ import division", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "eval", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["It's probably worth pointing out that the suggestions that don't use eval but rather parse the string do so because eval is dangerous: if there is some way for an arbitrary string to get sent to eval, then your system is vulnerable.", "So it's a bad habit.", "(But if this is just quick and dirty code, it's probably not that big a deal!"], "childNum": 4, "tag": "p", "senID": 1, "childList": [{"text": "eval", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "eval", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "eval", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "that", "childNum": 0, "tag": "em", "pos": 2, "childList": []}]}], [{"text": ["In Python 3, this should work."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x = [\"0.1234\", \"1/2\"]\n&gt;&gt;&gt; [eval(i) for i in x]\n[0.1234, 0.5]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["sympy can help you out here:"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "sympy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://code.google.com/p/sympy/"}]}, {"code": "<pre>\n<code>\n import sympy\n\nhalf = sympy.Rational('1/2')\np1234 = sympy.Rational('0.1234')\nprint '%f, %f\" % (half, p1234)\n</code>\n</pre>\n", "senID": 1}]]