[[{"text": ["I solved this problem by creating a function that wraps the cursor.execute() method since that's what was throwing the MySQLdb.OperationalError exception.", "The other example above implies that it is the conn.cursor() method that throws this exception."], "childNum": 3, "tag": "p", "senID": 0, "childList": [{"text": "cursor.execute()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "MySQLdb.OperationalError", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "conn.cursor()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n import MySQLdb\n\nclass DB:\n  conn = None\n\n  def connect(self):\n    self.conn = MySQLdb.connect()\n\n  def query(self, sql):\n    try:\n      cursor = self.conn.cursor()\n      cursor.execute(sql)\n    except (AttributeError, MySQLdb.OperationalError):\n      self.connect()\n      cursor = self.conn.cursor()\n      cursor.execute(sql)\n    return cursor\n\ndb = DB()\nsql = \"SELECT * FROM foo\"\ncur = db.query(sql)\n# wait a long time for the Mysql connection to timeout\ncur = db.query(sql)\n# still works\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you are using ubuntu Linux there was a patch added to the python-mysql package that added the ability to set that same MYSQL_OPT_RECONNECT option (see here).", "I have not tried it though."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://launchpad.net/ubuntu/hardy/+source/python-mysqldb/1.2.2-5"}]}, {"text": ["Unfortunately, the patch was later removed due to a conflict with autoconnect and transations (described here)."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "here", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "https://launchpad.net/ubuntu/+source/python-mysqldb"}]}, {"text": ["The comments from that page say:\n1.2.2-7 Published in intrepid-release on 2008-06-19 "], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["python-mysqldb (1.2.2-7) unstable; urgency=low"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"text": ["[ Sandro Tosi ]\n  * debian/control\n    - list items lines in description starts with 2 space, to avoid reformat\n      on webpages (Closes: #480341)"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["[ Bernd Zeimetz ]\n  * debian/patches/02_reconnect.dpatch:\n    - Dropping patch:\n      Comment in Storm which explains the problem:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n # Here is another sad story about bad transactional behavior. MySQL\n    # offers a feature to automatically reconnect dropped connections.\n    # What sounds like a dream, is actually a nightmare for anyone who\n    # is dealing with transactions. When a reconnection happens, the\n    # currently running transaction is transparently rolled back, and\n    # everything that was being done is lost, without notice. Not only\n    # that, but the connection may be put back in AUTOCOMMIT mode, even\n    # when that's not the default MySQLdb behavior. The MySQL developers\n    # quickly understood that this is a terrible idea, and removed the\n    # behavior in MySQL 5.0.3. Unfortunately, Debian and Ubuntu still\n    # have a patch right now which *reenables* that behavior by default\n    # even past version 5.0.3.\n</code>\n</pre>\n", "senID": 6}], [{"text": ["You other bet it to work around dropped connections yourself with code."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["One way to do it would be the following:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n import MySQLdb\n\nclass DB:\n    conn = None\n\n    def connect(self):\n        self.conn = MySQLdb.connect()\n\n    def cursor(self):\n        try:\n            return self.conn.cursor()\n        except (AttributeError, MySQLdb.OperationalError):\n            self.connect()\n            return self.conn.cursor()\n\ndb = DB()\ncur = db.cursor()\n# wait a long time for the Mysql connection to timeout\ncur = db.cursor()\n# still works\n</code>\n</pre>\n", "senID": 2}], [{"text": ["I had a similar problem with MySQL and Python, and the solution that worked for me was to upgrade MySQL to 5.0.27 (on Fedora Core 6; your system may work fine with a different version)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["I tried a lot of other things, including patching the Python libraries, but upgrading the database was a lot easier and (I think) a better decision."], "childNum": 0, "tag": "p", "senID": 1, "childList": []}], [{"text": ["Hmm, transactions are only an issue if you use InnoDB and transactions!", "The python-mysqldb people have made a political, not technical decision to remove this option.", "Screws people over who actually use this feature."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}], [{"text": ["you can separate the commit and the close for the connection...that's not cute but it does it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n class SqlManager(object):\n \"\"\"\n Class that handle the database operation\n \"\"\"\n def __init__(self,server, database, username, pswd):\n\n      self.server = server\n      self.dataBase = database\n      self.userID = username\n      self.password = pswd\n\ndef Close_Transation(self):\n      \"\"\"\n      Commit the SQL Query\n      \"\"\"\n      try:\n        self.conn.commit()\n      except Sql.Error, e:\n        print \"-- reading SQL Error %d: %s\" % (e.args[0], e.args[1])\n\n def Close_db(self):\n    try:\n        self.conn.close()\n    except Sql.Error, e:\n        print \"-- reading SQL Error %d: %s\" % (e.args[0], e.args[1])\n\n def __del__(self):\n    print \"close connection with database..\"\n    self.conn.close()\n</code>\n</pre>\n", "senID": 1}]]