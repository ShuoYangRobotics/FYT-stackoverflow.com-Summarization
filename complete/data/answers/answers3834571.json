[[{"text": ["The problem with dictionaries is their undefined order.", "You must make sure you always get the same result of equal dictionaries (if you want to compare them as strings)."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["You could do it in multiple ways:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"text": ["1) Python hash (only for checking equality; hash implementation might be specific to the Python version!"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Python hash", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n print hash(str(sorted({1 : 2, 3 : 4}.items())))\n</code>\n</pre>\n", "senID": 3}, {"text": ["2) MD5 (best if you only want to check equality)"], "childNum": 1, "tag": "p", "senID": 4, "childList": [{"text": "MD5", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import hashlib\nprint hashlib.md5(str(sorted({1 : 2, 3 : 4}.items()))).hexdigest()\n</code>\n</pre>\n", "senID": 5}, {"text": ["3) Pickling (serialization)"], "childNum": 1, "tag": "p", "senID": 6, "childList": [{"text": "Pickling", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import pickle\nserializedString = pickle.dumps({1 : 2, 3 : 4})\n</code>\n</pre>\n", "senID": 7}, {"text": ["The pickle module has different protocols (and I think it doesn't sort the dictionary items), so you can't do string comparison.", "You have to unpickle the data to a dictionary and then compare the old and new dictionary directly (d = pickle.loads(serializedString))."], "childNum": 2, "tag": "p", "senID": 8, "childList": [{"text": "pickle", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "d = pickle.loads(serializedString)", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"text": ["4) Item tuple representation (serialization)"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "Item tuple representation", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["According to your comment, you want something embeddable into Python source code.", "As S.Lott suggested, you can use the object representation of someDictionary.items(), which is a list containing all (key, value) combinations as tuples (most probably unsorted):"], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "someDictionary.items()", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; repr({1 : 2, 3 : 4}.items())\n'[(1, 2), (3, 4)]'\n</code>\n</pre>\n", "senID": 11}, {"text": ["You can copy-and-paste this representation into your source code if you want the object serialized as a string ."], "childNum": 0, "tag": "p", "senID": 12, "childList": []}], [{"text": ["You could use JSON to get what you are asking for."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n from django.utils import simplejson as json\n\ndict_1 = {'a': 1, 'b': 2, 'c': 3}\ndict_2 = {'a': 2, 'b': 7, 'd': 9}\n\ndict_1_str = json.dumps(dict_1, sort_keys=True)\ndict_2_str = json.dumps(dict_2, sort_keys=True)\n\nif dict_1_str == dict_2_str:\n   # do something with the new dict...\n   pass\n</code>\n</pre>\n", "senID": 1}, {"text": ["The dict_X_str variables will contain a serialized version of the dict.", "You can store it in memcahce or the datastore for later comparison."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}], [{"text": ["pickle is definitely what you're looking for."], "childNum": 2, "tag": "p", "senID": 0, "childList": [{"text": "pickle", "tag": "a", "pos": 0, "childList": [{"text": "pickle", "tag": "code"}], "childNum": 1, "href": "http://docs.python.org/library/pickle.html"}, {"text": "pickle", "childNum": 0, "tag": "code", "childList": []}]}], [{"code": "<pre>\n<code>\n pickle.dumps(set(yourdict.items()))\n</code>\n</pre>\n", "senID": 0}], [{"text": ["By using pickle you could create a new DictProperty allowing you to put the dict in the datastore and retrieve it later for comparison."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Here is one implementation: http://stackoverflow.com/questions/1953784/can-i-store-a-python-dictionary-in-googles-bigtable-datastore-without-serializin/1953956#1953956"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "http://stackoverflow.com/questions/1953784/can-i-store-a-python-dictionary-in-googles-bigtable-datastore-without-serializin/1953956#1953956", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://stackoverflow.com/questions/1953784/can-i-store-a-python-dictionary-in-googles-bigtable-datastore-without-serializin/1953956#1953956"}]}], [{"text": ["If you do this, you get an object which is consistent and comparable.", "It has a well-defined and predictable order.", "You can use difflib to find differences.", "Further, you can trivially rebuild the high-performance dictionary from it."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n static = list(sorted(some_dict.items()))\n\na_dict= dict( static )\n</code>\n</pre>\n", "senID": 1}]]