[[{"text": ["You can't store the object itself in the DB.", "What you do is to store the data from the object and reconstruct it later."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["A good way is to use the excellent SQLAlchemy library.", "It lets you map your defined class to a table in the database.", "Every mapped attribute will be stored, and can be used to reconstruct the object.", "Querying the database returns instances of your class."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "SQLAlchemy", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://www.sqlalchemy.org"}]}, {"text": ["With it you can use not only sqlite, but most databases - It currently also supports Postgres, MySQL, Oracle, MS-SQL, Firebird, MaxDB, MS Access, Sybase, Informix and IBM DB2.", "And you can have your user choose which one she wants to use, because you can basically switch between those databases without changing the code at all."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["There are also a lot of cool features - like automatic JOINs, polymorphing..."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "JOIN", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["A quick, simple example you can run:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"code": "<pre>\n<code>\n from sqlalchemy import Column, Integer, Unicode, UnicodeText, String\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.ext.declarative import declarative_base\n\nfrom random import choice\nfrom string import letters\n\nengine = create_engine('sqlite:////tmp/teste.db', echo=True)\nBase = declarative_base(bind=engine)\n\nclass User(Base):\n    __tablename__ = 'users'\n    id = Column(Integer, primary_key=True)\n    name = Column(Unicode(40))\n    address = Column(UnicodeText, nullable=True)\n    password = Column(String(20))\n\n    def __init__(self, name, address=None, password=None):\n        self.name = name\n        self.address = address\n        if password is None:\n            password = ''.join(choice(letters) for n in xrange(10))\n        self.password = password\n\nBase.metadata.create_all()\n\nSession = sessionmaker(bind=engine)\ns = Session()\n</code>\n</pre>\n", "senID": 5}, {"text": ["Then I can use it like this:"], "childNum": 0, "tag": "p", "senID": 6, "childList": []}, {"code": "<pre>\n<code>\n # create instances of my user object\nu = User('nosklo')\nu.address = '66 Some Street #500'\n\nu2 = User('lakshmipathi')\nu2.password = 'ihtapimhskal'\n\n# testing\ns.add_all([u, u2])\ns.commit()\n</code>\n</pre>\n", "senID": 7}, {"text": ["That would run INSERT statements against the database."], "childNum": 1, "tag": "p", "senID": 8, "childList": [{"text": "INSERT", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n # When you query the data back it returns instances of your class:\n\nfor user in s.query(User):\n    print type(user), user.name, user.password\n</code>\n</pre>\n", "senID": 9}, {"text": ["That query would run SELECT users.id AS users_id, users.name AS users_name, users.address AS users_address, users.password AS users_password."], "childNum": 1, "tag": "p", "senID": 10, "childList": [{"text": "SELECT users.id AS users_id, users.name AS users_name, users.address AS users_address, users.password AS users_password", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["The printed result would be:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n &lt;class '__main__.User'&gt; nosklo aBPDXlTPJs\n&lt;class '__main__.User'&gt; lakshmipathi ihtapimhskal\n</code>\n</pre>\n", "senID": 12}, {"text": ["So you're effectively storing your object into the database, the best way."], "childNum": 0, "tag": "p", "senID": 13, "childList": []}], [{"text": ["Yes it's possible but there are different approaches and which one is the suitable one, will depend on your requirements."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"tag": "ul", "num": 2, "lis": [{"text": ["Pickling"], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "Pickling", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["Object-Relational-Mapping"], "childNum": 1, "tag": "p", "senID": 2, "childList": [{"text": "Object-Relational-Mapping", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}]}], [{"text": ["You can use pickle to serialize the object.", "The serialized object can be inserted to the sqlite DB as a bytearray field."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pickle", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/pickle.html"}]}, {"code": "<pre>\n<code>\n f=open('object.dump', 'rw')\npickle.dump(obj, f)\n</code>\n</pre>\n", "senID": 1}, {"text": ["Now read object.dump from the file, and write it to the sqlite DB.", "You might want to write it as a binary data type; read about storing binary data and blob in SQLite here.", "Note that according to this source, SQLite limits the size of such datafield to 1Mb."], "childNum": 3, "tag": "p", "senID": 2, "childList": [{"text": "object.dump", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "here", "tag": "a", "pos": 1, "childList": [], "childNum": 0, "href": "http://code.activestate.com/recipes/252531/"}, {"text": "this source", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://effbot.org/zone/sqlite-blob.htm"}]}, {"text": ["I think that a better option would be serializing your object into a file, and keeping the file name, not contents, in the database."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "name", "childNum": 0, "tag": "em", "pos": 0, "childList": []}]}], [{"text": ["You other choice instead of pickling is to use an ORM.", "This lets you map rows in a database to an object.", "See http://wiki.python.org/moin/HigherLevelDatabaseProgramming for a starting point.", "I'd recommend SQLAlchemy or SQLObject."], "childNum": 4, "tag": "p", "senID": 0, "childList": [{"text": "ORM", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}, {"text": "http://wiki.python.org/moin/HigherLevelDatabaseProgramming", "tag": "a", "pos": 2, "childList": [], "childNum": 0, "href": "http://wiki.python.org/moin/HigherLevelDatabaseProgramming"}, {"text": "SQLAlchemy", "tag": "a", "pos": 3, "childList": [], "childNum": 0, "href": "http://www.sqlalchemy.org/"}, {"href": "http://www.sqlobject.org/", "text": "SQLObject", "childNum": 0, "tag": "a", "childList": []}]}], [{"text": ["You can use pickle.dumps, its return pickable objects as strings, you would not need to write it to temporary files."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "pickle.dumps", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://docs.python.org/library/pickle.html#what-can-be-pickled-and-unpickled"}]}, {"code": "<pre>\n<code>\n import pickle\n\nclass Foo:\n    attr = 'a class attr'\n\npicklestring = pickle.dumps(Foo)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["One option is to use an O/R mapper like SQLObject.", "It will do most of the plumbing to persist the Python object to a database, and it supports SQLite.", "As mentioned elsewhere you can also serialise the object using a method such as pickle, which dumps out a representation of the object that it can reconstruct by reading back in and parsing."], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "SQLObject.", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://sqlobject.org/"}]}]]