[[{"text": ["I like @Benjamin's solution.", "An alternative though is:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import numpy as np\na = np.empty((15,))\na[::2] = 1\na[1::2] = -1\n</code>\n</pre>\n", "senID": 1}, {"text": ["This also allows for odd-length lists."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["EDIT: Also just to note speeds, for a array of 10000 elements"], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "EDIT:", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import numpy as np\nfrom timeit import Timer\n\nif __name__ == '__main__':\n\n    setupstr=\"\"\"\nimport numpy as np\nN = 10000\n\"\"\"\n\n    method1=\"\"\"\na = np.empty((N,),int)\na[::2] = 1\na[1::2] = -1\n\"\"\"\n\n    method2=\"\"\"\na = np.tile([1,-1],N)\n\"\"\"\n\n    method3=\"\"\"\na = np.array([1,-1]*N)   \n\"\"\"\n\n    method4=\"\"\"\na = np.array(list(itertools.islice(itertools.cycle((1,-1)), N)))    \n\"\"\"\n    nl = 1000\n    t1 = Timer(method1, setupstr).timeit(nl)\n    t2 = Timer(method2, setupstr).timeit(nl)\n    t3 = Timer(method3, setupstr).timeit(nl)\n    t4 = Timer(method4, setupstr).timeit(nl)\n\n    print 'method1', t1\n    print 'method2', t2\n    print 'method3', t3\n    print 'method4', t4\n</code>\n</pre>\n", "senID": 4}, {"text": ["Results in timings of:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n method1 0.0130500793457\nmethod2 0.114426136017\nmethod3 4.30518102646\nmethod4 2.84446692467\n</code>\n</pre>\n", "senID": 6}, {"text": ["If N = 100, things start to even out but starting with the empty numpy arrays is still significantly faster (nl changed to 10000)"], "childNum": 2, "tag": "p", "senID": 7, "childList": [{"text": "N = 100", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "nl", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n method1 0.05735206604\nmethod2 0.323992013931\nmethod3 0.556654930115\nmethod4 0.46702003479\n</code>\n</pre>\n", "senID": 8}, {"text": ["Numpy arrays are special awesome objects and should not be treated like python lists."], "childNum": 0, "tag": "p", "senID": 9, "childList": []}], [{"text": ["use multiplication:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n [1,-1] * n\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Use numpy.tile!"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "numpy.tile", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n import numpy\na = numpy.tile([1,-1], 15)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If you want a memory efficient solution, try this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n def alternator(n):\n    for i in xrange(n):\n        if i % 2 == 0:\n            yield 1\n        else:\n            yield -1\n</code>\n</pre>\n", "senID": 1}, {"text": ["Then you can iterate over the answers like so:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n for i in alternator(n):\n    # do something with i\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Maybe you're looking for itertools.cycle?"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n list_ = (1,-1,2,-2)  # ,3,-3, ...\n\nfor n, item in enumerate(itertools.cycle(list_)):\n    if n==30:\n        break\n\n    print item\n</code>\n</pre>\n", "senID": 1}], [{"text": ["use resize():"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n In [38]: np.resize([1,-1], 10) # 10 is the length of result array\nOut[38]: array([ 1, -1,  1, -1,  1, -1,  1, -1,  1, -1])\n</code>\n</pre>\n", "senID": 1}, {"text": ["it can produce odd-length array:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n In [39]: np.resize([1,-1], 11)\nOut[39]: array([ 1, -1,  1, -1,  1, -1,  1, -1,  1, -1,  1])\n</code>\n</pre>\n", "senID": 3}], [{"text": ["Use itertools: "], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "itertools", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["list(itertools.islice(itertools.cycle((1,-1)), 11)), note the odd length of 11."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "list(itertools.islice(itertools.cycle((1,-1)), 11))", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["cycle() repeats a sequence endlessly, and islice cuts first few items of it."], "childNum": 2, "tag": "p", "senID": 2, "childList": [{"text": "cycle()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "islice", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["I'll just throw these out there because they could be more useful in some circumstances."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["If you just want to alternate between positive and negative:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n [(-1)**i for i in range(n)]\n</code>\n</pre>\n", "senID": 2}, {"text": ["or for a more general solution"], "childNum": 0, "tag": "p", "senID": 3, "childList": []}, {"code": "<pre>\n<code>\n nums = [1, -1, 2]\n[nums[i % len(nums)] for i in range(n)]\n</code>\n</pre>\n", "senID": 4}], [{"text": ["Since this is a simple repeating pattern, [1,-1]*n is the most simple.", "For more complex patters I often find it easier to have two separate lists and merge them"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "[1,-1]*n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; x=[1,1,1]\n&gt;&gt;&gt; y=[-1,-1,-1]\n&gt;&gt;&gt; list(sum(zip(x,y),()))\n[1, -1, 1, -1, 1, -1]\n</code>\n</pre>\n", "senID": 1}]]