[[{"text": ["They look pretty much the same on Python 3.2."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["As gnibbler pointed out, the first doesn't need to lookup dict, which should make it a tiny bit faster."], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n &gt;&gt;&gt; def literal():\n...   d = {'one': 1, 'two': 2}\n...\n&gt;&gt;&gt; def constructor():\n...   d = dict(one='1', two='2')\n...\n&gt;&gt;&gt; import dis\n&gt;&gt;&gt; dis.dis(literal)\n  2           0 BUILD_MAP                2\n              3 LOAD_CONST               1 (1)\n              6 LOAD_CONST               2 ('one')\n              9 STORE_MAP\n             10 LOAD_CONST               3 (2)\n             13 LOAD_CONST               4 ('two')\n             16 STORE_MAP\n             17 STORE_FAST               0 (d)\n             20 LOAD_CONST               0 (None)\n             23 RETURN_VALUE\n&gt;&gt;&gt; dis.dis(constructor)\n  2           0 LOAD_GLOBAL              0 (dict)\n              3 LOAD_CONST               1 ('one')\n              6 LOAD_CONST               2 ('1')\n              9 LOAD_CONST               3 ('two')\n             12 LOAD_CONST               4 ('2')\n             15 CALL_FUNCTION          512\n             18 STORE_FAST               0 (d)\n             21 LOAD_CONST               0 (None)\n             24 RETURN_VALUE\n</code>\n</pre>\n", "senID": 2}], [{"text": ["These two approaches produce identical dictionaries, except, as you've noted, where the lexical rules of Python interfere."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["Dictionary literals are a little more obviously dictionaries, and you can create any kind of key, but you need to quote the key names.", "On the other hand, you can use variables for keys if you need to for some reason:"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n a = \"hello\"\nd = {\n    a: 'hi'\n    }\n</code>\n</pre>\n", "senID": 2}, {"text": ["The dict() constructor gives you more flexibility because of the variety of forms of input it takes.", "For example, you can provide it with an iterator of pairs, and it will treat them as key/value pairs."], "childNum": 1, "tag": "p", "senID": 3, "childList": [{"text": "dict()", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["I have no idea why PyCharm would offer to convert one form to the other."], "childNum": 0, "tag": "p", "senID": 4, "childList": []}], [{"text": ["I think you have pointed out the most obvious difference.", "Apart from that, "], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"text": ["the first doesn't need to lookup dict which should make it a tiny bit faster "], "childNum": 1, "tag": "p", "senID": 1, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"text": ["the second looks up dict in locals() and then globals() and the finds the builtin, so you can switch the behaviour by defining a local called dict for example although I can't think of anywhere this would be a good idea apart from maybe when debugging"], "childNum": 4, "tag": "p", "senID": 2, "childList": [{"text": "dict", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "locals()", "childNum": 0, "tag": "code", "childList": []}, {"text": "globals()", "childNum": 0, "tag": "code", "childList": []}, {"text": "dict", "childNum": 0, "tag": "code", "childList": []}]}], [{"text": ["Literal is much faster, since it uses optimized BUILD_MAP and STORE_MAP opcodes rather than generic CALL_FUNCTION:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n &gt; python2.7 -m timeit \"d = dict(a=1, b=2, c=3, d=4, e=5)\"\n1000000 loops, best of 3: 0.958 usec per loop\n\n&gt; python2.7 -m timeit \"d = {'a':1, 'b':2, 'c':3, 'd':4, 'e':5}\"\n1000000 loops, best of 3: 0.479 usec per loop\n\n&gt; python3.2 -m timeit \"d = dict(a=1, b=2, c=3, d=4, e=5)\"\n1000000 loops, best of 3: 0.975 usec per loop\n\n&gt; python3.2 -m timeit \"d = {'a':1, 'b':2, 'c':3, 'd':4, 'e':5}\"\n1000000 loops, best of 3: 0.409 usec per loop\n</code>\n</pre>\n", "senID": 1}], [{"text": ["From python 2.7 tutorial:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n tel = {'jack': 4098, 'sape': 4139}\ndata = {k:v for k,v in zip(xrange(10), xrange(10,20))}\n</code>\n</pre>\n", "senID": 1}, {"text": ["While:"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n tel = dict([('sape', 4139), ('guido', 4127), ('jack', 4098)]) {'sape': 4139, 'jack': 4098, 'guido': 4127}\ndata = dict((k,v) for k,v in zip(xrange(10), xrange(10,20)))\n</code>\n</pre>\n", "senID": 3}, {"code": "<pre>\n<code>\n dict(sape=4139, guido=4127, jack=4098)\n&gt;&gt;&gt;  {'sape': 4139, 'jack':4098, 'guido': 4127}\n</code>\n</pre>\n", "senID": 4}, {"text": ["So both {} and dict() produce dictionary but provide a bit different ways of dictionary data initialization."], "childNum": 0, "tag": "p", "senID": 5, "childList": []}], [{"text": ["The second approach returns a dict object that you can later reuse in easier form.", "So one advantage is certainly that ease of object reuse and also\nobject modification.", "If you want to add, remove, update anything in the dict object, the second syntax is easier.", "You can also make it part of a class or module.", "You can pass it to a function as well."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}]]