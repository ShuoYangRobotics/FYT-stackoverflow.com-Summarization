[[{"text": ["Using python:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n totals = [ int(i)+int(j) for i, j in zip ( open(fname1), open(fname2) ) ]\n</code>\n</pre>\n", "senID": 1}], [{"text": ["If c1 and c2 are youre files, you can do this:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n $ paste c1 c2 | awk '{print $1 + $2}'\n</code>\n</pre>\n", "senID": 1}, {"text": ["Or (without AWK):"], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"code": "<pre>\n<code>\n $ paste c1 c2 | while read i j; do echo $(($i+$j)); done\n</code>\n</pre>\n", "senID": 3}], [{"text": ["You can avoid the intermediate steps by just using a command that do the counts and the comparison at the same time:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n find . -type f -exec perl -nle 'END { print $ARGV if $h{\"{\"} != $h{\"}\"} } $h{$_}++ for /([}{])/g' {}\\;\n</code>\n</pre>\n", "senID": 1}, {"text": ["This calls the Perl program once per file, the Perl program counts the number of each type curly brace and prints the name of the file if they counts don't match."], "childNum": 0, "tag": "p", "senID": 2, "childList": []}, {"text": ["You must be careful with the /([}{]])/ section, find will think it needs to do the replacement on {} if you say /([{}]])/."], "childNum": 4, "tag": "p", "senID": 3, "childList": [{"text": "/([}{]])/", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "find", "childNum": 0, "tag": "code", "childList": []}, {"text": "{}", "childNum": 0, "tag": "code", "childList": []}, {"text": "/([{}]])/", "childNum": 0, "tag": "code", "childList": []}]}, {"text": ["WARNING: this code will have false positives and negatives if you are trying to run it against source code.", "Consider the following cases:"], "childNum": 0, "tag": "p", "senID": 4, "childList": []}, {"text": ["balanced, but curlies in strings:"], "childNum": 0, "tag": "p", "senID": 5, "childList": []}, {"code": "<pre>\n<code>\n if ($s eq '{') {\n    print \"I saw a {\\n\"\n}\n</code>\n</pre>\n", "senID": 6}, {"text": ["unbalanced, but curlies in strings:"], "childNum": 0, "tag": "p", "senID": 7, "childList": []}, {"code": "<pre>\n<code>\n while (1) {\n   print \"}\";\n</code>\n</pre>\n", "senID": 8}, {"text": ["You can expand the Perl command by using B::Deparse:"], "childNum": 1, "tag": "p", "senID": 9, "childList": [{"text": "B::Deparse", "tag": "a", "pos": 0, "childList": [], "childNum": 0, "href": "http://perldoc.perl.org/B/Deparse.html"}]}, {"text": ["perl -MO=Deparse -nle 'END { print $ARGV if $h{\"{\"} != $h{\"}\"} } $h{$_}++ for /([}{])/g'"], "childNum": 0, "tag": "p", "senID": 10, "childList": []}, {"text": ["Which results in:"], "childNum": 0, "tag": "p", "senID": 11, "childList": []}, {"code": "<pre>\n<code>\n BEGIN { $/ = \"\\n\"; $\\ = \"\\n\"; }\nLINE: while (defined($_ = &lt;ARGV&gt;)) {\n    chomp $_;\n    sub END {\n        print $ARGV if $h{'{'} != $h{'}'};\n    }\n    ;\n    ++$h{$_} foreach (/([}{])/g);\n}\n</code>\n</pre>\n", "senID": 12}, {"text": ["We can now look at each piece of the program:"], "childNum": 0, "tag": "p", "senID": 13, "childList": []}, {"code": "<pre>\n<code>\n BEGIN { $/ = \"\\n\"; $\\ = \"\\n\"; }\n</code>\n</pre>\n", "senID": 14}, {"text": ["This is caused by the -l option.", "It sets both the input and output record separators to \"\\n\".", "This means anything read in will be broken into records based \"\\n\" and any print statement will have \"\\n\" appended to it."], "childNum": 1, "tag": "p", "senID": 15, "childList": [{"text": "-l", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}, {"code": "<pre>\n<code>\n LINE: while (defined($_ = &lt;ARGV&gt;)) {\n}\n</code>\n</pre>\n", "senID": 16}, {"text": ["This is created by the -n option.", "It loops over every file passed in via the commandline (or STDIN if no files are passed) reading each line of those files.", "This also happens to set $ARGV to the last file read by &lt;ARGV&gt;."], "childNum": 3, "tag": "p", "senID": 17, "childList": [{"text": "-n", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "$ARGV", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "&lt;ARGV&gt;", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n chomp $_;\n</code>\n</pre>\n", "senID": 18}, {"text": ["This removes whatever is in the $/ variable from the line that was just read ($_), it does nothing useful here.", "It was caused by the -l option."], "childNum": 3, "tag": "p", "senID": 19, "childList": [{"text": "$/", "childNum": 0, "tag": "code", "pos": 0, "childList": []}, {"text": "$_", "childNum": 0, "tag": "code", "pos": -1, "childList": []}, {"text": "-l", "childNum": 0, "tag": "code", "pos": 1, "childList": []}]}, {"code": "<pre>\n<code>\n sub END {\n    print $ARGV if $h{'{'} != $h{'}'};\n}\n</code>\n</pre>\n", "senID": 20}, {"text": ["This is an END block, this code will run at the end of the program.", "It prints $ARGV (the name of the file last read from, see above) if the values stored in %h associated with the keys '{' and '}' are equal."], "childNum": 4, "tag": "p", "senID": 21, "childList": [{"text": "$ARGV", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "%h", "childNum": 0, "tag": "code", "childList": []}, {"text": "'{'", "childNum": 0, "tag": "code", "childList": []}, {"text": "'}'", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n ++$h{$_} foreach (/([}{])/g);\n</code>\n</pre>\n", "senID": 22}, {"text": ["This needs to be broken down further:"], "childNum": 0, "tag": "p", "senID": 23, "childList": []}, {"code": "<pre>\n<code>\n /\n    (    #begin capture\n    [}{] #match any of the '}' or '{' characters\n    )    #end capture\n/gx\n</code>\n</pre>\n", "senID": 24}, {"text": ["Is a regex that returns a list of '{' and '}' characters that are in the string being matched.", "Since no string was specified the $_ variable (which holds the line last read from the file, see above) will be matched against.", "That list is fed into the foreach statement which then runs the statement it is in front of for each item (hence the name) in the list.", "It also sets $_ (as you can see $_ is a popular variable in Perl) to be the item from the list."], "childNum": 4, "tag": "p", "senID": 25, "childList": [{"text": "$_", "childNum": 0, "tag": "code", "pos": 1, "childList": []}, {"text": "foreach", "childNum": 0, "tag": "code", "pos": 2, "childList": []}, {"text": "$_", "childNum": 0, "tag": "code", "pos": 3, "childList": []}, {"text": "$_", "childNum": 0, "tag": "code", "childList": []}]}, {"code": "<pre>\n<code>\n ++h{$_}\n</code>\n</pre>\n", "senID": 26}, {"text": ["This line increments the value in $h that is associated with $_ (which will be either '{' or '}', see above) by one."], "childNum": 1, "tag": "p", "senID": 27, "childList": [{"text": "$_", "childNum": 0, "tag": "code", "pos": 0, "childList": []}]}], [{"text": ["In Python (or Perl, Awk, &amp;c) you can reasonably do it in a single stand-alone \"pass\" -- I'm not sure what you mean by \"too many curly brackets\", but you can surely count curly use per file.", "For example (unless you have to worry about multi-GB files), the 10 files using most curly braces:"], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n import heapq\nimport os\nimport re\n\ncurliest = dict()\n\nfor path, dirs, files in os.walk('.'):\n  for afile in files:\n    fn = os.path.join(path, afile)\n    with open(fn) as f:\n      data = f.read()\n      braces = data.count('{') + data.count('}')\n    curliest[fn] = bracs\n\ntop10 = heapq.nlargest(10, curlies, curliest.get)\ntop10.sort(key=curliest.get)\nfor fn in top10:\n  print '%6d %s' % (curliest[fn], fn)\n</code>\n</pre>\n", "senID": 1}], [{"text": ["Reply to Lutz'n answer"], "childNum": 1, "tag": "p", "senID": 0, "childList": [{"text": "Reply to Lutz'n answer", "childNum": 0, "tag": "strong", "pos": 0, "childList": []}]}, {"text": ["My problem was finally solved by this commnad"], "childNum": 0, "tag": "p", "senID": 1, "childList": []}, {"code": "<pre>\n<code>\n paste -d: /tmp/1 /tmp/2 | awk -F: '{ print $1 \"\\t\" $2 - $4 }'\n</code>\n</pre>\n", "senID": 2}], [{"text": ["your problem can be solved with just 1 awk command..."], "childNum": 0, "tag": "p", "senID": 0, "childList": []}, {"code": "<pre>\n<code>\n awk '{getline i&lt;\"file1\";print i+$0}'  file2\n</code>\n</pre>\n", "senID": 1}]]